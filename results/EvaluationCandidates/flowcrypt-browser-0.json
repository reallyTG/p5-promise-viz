{
  "promises": {
    "0": {
      "source": "build/test/test/source/async-stack.js:143:23:143:23",
      "startTime": "577210859812601",
      "endTime": "577211266051058",
      "elapsedTime": "406238457",
      "asyncId": 3,
      "triggerAsyncId": 1,
      "io": "",
      "createdIn": 1625853495764,
      "functionName": "",
      "userCode": false,
      "line": "\n            };\n            try {\n                await doTestWith('error', [\n                    'Error: this failed',\n                    ' at thisWillFail ',\n                    ' at func '",
      "startLine": 143,
      "startCol": 23,
      "endLine": 143,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        9
      ],
      "uniqueid": 0
    },
    "1": {
      "source": "build/test/test/source/async-stack.js:116:42:116:42",
      "startTime": "577210860117633",
      "endTime": "577211265945199",
      "elapsedTime": "405827566",
      "asyncId": 4,
      "triggerAsyncId": 1,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " doTestWith",
      "userCode": false,
      "line": "\n                try {\n                    try {\n                        await ClassAsync.staticAsyncFunc(type);\n                    }\n                    catch (e) {\n                        if (!(e instanceof Error)) ",
      "startLine": 116,
      "startCol": 42,
      "endLine": 116,
      "endCol": 42,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        8
      ],
      "uniqueid": 1
    },
    "2": {
      "source": "build/test/test/source/async-stack.js:4:24:4:24",
      "startTime": "577210860373533",
      "endTime": "577210961234979",
      "elapsedTime": "100861446",
      "asyncId": 5,
      "triggerAsyncId": 1,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " wait",
      "userCode": false,
      "line": "\n/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n(() => {\n    const wait = () => new Promise(resolve => setTimeout(resolve, 100));\n    const acceptCb = (cb) => {\n        // nothing\n    }",
      "startLine": 4,
      "startCol": 24,
      "endLine": 4,
      "endCol": 24,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        7
      ],
      "uniqueid": 2
    },
    "3": {
      "source": "build/test/test/source/async-stack.js:116:42:116:42",
      "startTime": "577210860997513",
      "endTime": "577210963415045",
      "elapsedTime": "102417532",
      "asyncId": 7,
      "triggerAsyncId": 5,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " doTestWith",
      "userCode": false,
      "line": "\n                try {\n                    try {\n                        await ClassAsync.staticAsyncFunc(type);\n                    }\n                    catch (e) {\n                        if (!(e instanceof Error)) ",
      "startLine": 116,
      "startCol": 42,
      "endLine": 116,
      "endCol": 42,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        12,
        11
      ],
      "uniqueid": 3
    },
    "4": {
      "source": "build/test/test/source/async-stack.js:143:23:143:23",
      "startTime": "577210861272518",
      "endTime": "577211266096513",
      "elapsedTime": "404823995",
      "asyncId": 8,
      "triggerAsyncId": 4,
      "io": "",
      "createdIn": 1625853495764,
      "functionName": "",
      "userCode": false,
      "line": "\n            };\n            try {\n                await doTestWith('error', [\n                    'Error: this failed',\n                    ' at thisWillFail ',\n                    ' at func '",
      "startLine": 143,
      "startCol": 23,
      "endLine": 143,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 4
    },
    "5": {
      "source": "build/test/test/source/async-stack.js:174:7:174:7",
      "startTime": "577210861447847",
      "endTime": "577211266873530",
      "elapsedTime": "405425683",
      "asyncId": 9,
      "triggerAsyncId": 3,
      "io": "",
      "createdIn": 1625853495764,
      "functionName": "",
      "userCode": false,
      "line": "\n            if(t instanceof Error){t.stack+=\"\\n    at <async> <anonymous> (../test/source/async-stack.ts:77:4)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n        }\n    })().catch(e => {\n        console.error(e);\n        process.exit(1);\n    })",
      "startLine": 174,
      "startCol": 7,
      "endLine": 174,
      "endCol": 7,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        30,
        29,
        28
      ],
      "uniqueid": 5
    },
    "6": {
      "source": "build/test/test/source/async-stack.js:93:34:93:34",
      "startTime": "577210962962577",
      "endTime": "577211265864889",
      "elapsedTime": "302902312",
      "asyncId": 11,
      "triggerAsyncId": 7,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Function.staticAsyncFunc",
      "userCode": false,
      "line": "\n            try {\n                await wait();\n                await ClassAsync.staticConstAttrAsync(type);\n                await wait();\n            }\n            catch (t) ",
      "startLine": 93,
      "startCol": 34,
      "endLine": 93,
      "endCol": 34,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        15
      ],
      "uniqueid": 6
    },
    "7": {
      "source": "build/test/test/source/async-stack.js:4:24:4:24",
      "startTime": "577210963119511",
      "endTime": "577211063652331",
      "elapsedTime": "100532820",
      "asyncId": 12,
      "triggerAsyncId": 7,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " wait",
      "userCode": false,
      "line": "\n/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n(() => {\n    const wait = () => new Promise(resolve => setTimeout(resolve, 100));\n    const acceptCb = (cb) => {\n        // nothing\n    }",
      "startLine": 4,
      "startCol": 24,
      "endLine": 4,
      "endCol": 24,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        14
      ],
      "uniqueid": 7
    },
    "8": {
      "source": "build/test/test/source/async-stack.js:93:34:93:34",
      "startTime": "577210963272959",
      "endTime": "577211065092190",
      "elapsedTime": "101819231",
      "asyncId": 14,
      "triggerAsyncId": 12,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Function.staticAsyncFunc",
      "userCode": false,
      "line": "\n            try {\n                await wait();\n                await ClassAsync.staticConstAttrAsync(type);\n                await wait();\n            }\n            catch (t) ",
      "startLine": 93,
      "startCol": 34,
      "endLine": 93,
      "endCol": 34,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        18,
        17,
        16
      ],
      "uniqueid": 8
    },
    "9": {
      "source": "build/test/test/source/async-stack.js:116:25:116:25",
      "startTime": "577210963393946",
      "endTime": "577211265981698",
      "elapsedTime": "302587752",
      "asyncId": 15,
      "triggerAsyncId": 11,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " async doTestWith",
      "userCode": false,
      "line": "\n                try {\n                    try {\n                        await ClassAsync.staticAsyncFunc(type);\n                    }\n                    catch (e) {\n                        if (!(e instanceof Error)) ",
      "startLine": 116,
      "startCol": 25,
      "endLine": 116,
      "endCol": 25,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 9
    },
    "10": {
      "source": "build/test/test/source/async-stack.js:104:23:104:23",
      "startTime": "577211064098817",
      "endTime": "577211265777515",
      "elapsedTime": "201678698",
      "asyncId": 16,
      "triggerAsyncId": 14,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Function.ClassAsync.staticConstAttrAsync",
      "userCode": false,
      "line": "\n        try {\n            await wait();\n            await obj.paramFunc(type);\n            await wait();\n        }\n        catch (t) ",
      "startLine": 104,
      "startCol": 23,
      "endLine": 104,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        22
      ],
      "uniqueid": 10
    },
    "11": {
      "source": "build/test/test/source/async-stack.js:82:23:82:23",
      "startTime": "577211064469172",
      "endTime": "577211265686464",
      "elapsedTime": "201217292",
      "asyncId": 17,
      "triggerAsyncId": 14,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Object.paramFunc",
      "userCode": false,
      "line": "\n        paramFunc: async (type) => {\n            try {\n                await asyncFunc(type);\n            }\n            catch (t) {\n                if(t instanceof Error){t.stack+=\"\\n    at <async> paramFunc (../test/source/async-stack.ts:59:15)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e",
      "startLine": 82,
      "startCol": 23,
      "endLine": 82,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        21
      ],
      "uniqueid": 11
    },
    "12": {
      "source": "build/test/test/source/async-stack.js:4:24:4:24",
      "startTime": "577211064638148",
      "endTime": "577211164306016",
      "elapsedTime": "99667868",
      "asyncId": 18,
      "triggerAsyncId": 14,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " wait",
      "userCode": false,
      "line": "\n/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n(() => {\n    const wait = () => new Promise(resolve => setTimeout(resolve, 100));\n    const acceptCb = (cb) => {\n        // nothing\n    }",
      "startLine": 4,
      "startCol": 24,
      "endLine": 4,
      "endCol": 24,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        20
      ],
      "uniqueid": 12
    },
    "13": {
      "source": "build/test/test/source/async-stack.js:82:23:82:23",
      "startTime": "577211064805382",
      "endTime": "577211165240328",
      "elapsedTime": "100434946",
      "asyncId": 20,
      "triggerAsyncId": 18,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Object.paramFunc",
      "userCode": false,
      "line": "\n        paramFunc: async (type) => {\n            try {\n                await asyncFunc(type);\n            }\n            catch (t) {\n                if(t instanceof Error){t.stack+=\"\\n    at <async> paramFunc (../test/source/async-stack.ts:59:15)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e",
      "startLine": 82,
      "startCol": 23,
      "endLine": 82,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        24,
        23
      ],
      "uniqueid": 13
    },
    "14": {
      "source": "build/test/test/source/async-stack.js:104:23:104:23",
      "startTime": "577211064936407",
      "endTime": "577211265820175",
      "elapsedTime": "200883768",
      "asyncId": 21,
      "triggerAsyncId": 17,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Function.ClassAsync.staticConstAttrAsync",
      "userCode": false,
      "line": "\n        try {\n            await wait();\n            await obj.paramFunc(type);\n            await wait();\n        }\n        catch (t) ",
      "startLine": 104,
      "startCol": 23,
      "endLine": 104,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 14
    },
    "15": {
      "source": "build/test/test/source/async-stack.js:93:17:93:17",
      "startTime": "577211065073785",
      "endTime": "577211265902049",
      "elapsedTime": "200828264",
      "asyncId": 22,
      "triggerAsyncId": 16,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " async Function.staticAsyncFunc",
      "userCode": false,
      "line": "\n            try {\n                await wait();\n                await ClassAsync.staticConstAttrAsync(type);\n                await wait();\n            }\n            catch (t) ",
      "startLine": 93,
      "startCol": 17,
      "endLine": 93,
      "endCol": 17,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 15
    },
    "16": {
      "source": "build/test/test/source/async-stack.js:72:19:72:19",
      "startTime": "577211164737304",
      "endTime": "577211265594031",
      "elapsedTime": "100856727",
      "asyncId": 23,
      "triggerAsyncId": 20,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " asyncFunc",
      "userCode": false,
      "line": "\n        try {\n            await wait();\n            await asyncArrowConst(type);\n            await wait();\n        }\n        catch (t) ",
      "startLine": 72,
      "startCol": 19,
      "endLine": 72,
      "endCol": 19,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        27
      ],
      "uniqueid": 16
    },
    "17": {
      "source": "build/test/test/source/async-stack.js:4:24:4:24",
      "startTime": "577211164896543",
      "endTime": "577211265422009",
      "elapsedTime": "100525466",
      "asyncId": 24,
      "triggerAsyncId": 20,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " wait",
      "userCode": false,
      "line": "\n/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n(() => {\n    const wait = () => new Promise(resolve => setTimeout(resolve, 100));\n    const acceptCb = (cb) => {\n        // nothing\n    }",
      "startLine": 4,
      "startCol": 24,
      "endLine": 4,
      "endCol": 24,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        26
      ],
      "uniqueid": 17
    },
    "18": {
      "source": "build/test/test/source/async-stack.js:72:19:72:19",
      "startTime": "577211165079606",
      "endTime": "577211265637673",
      "elapsedTime": "100558067",
      "asyncId": 26,
      "triggerAsyncId": 24,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " asyncFunc",
      "userCode": false,
      "line": "\n        try {\n            await wait();\n            await asyncArrowConst(type);\n            await wait();\n        }\n        catch (t) ",
      "startLine": 72,
      "startCol": 19,
      "endLine": 72,
      "endCol": 19,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 18
    },
    "19": {
      "source": "build/test/test/source/async-stack.js:82:17:82:17",
      "startTime": "577211165222704",
      "endTime": "577211265730236",
      "elapsedTime": "100507532",
      "asyncId": 27,
      "triggerAsyncId": 23,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " async Object.paramFunc",
      "userCode": false,
      "line": "\n        paramFunc: async (type) => {\n            try {\n                await asyncFunc(type);\n            }\n            catch (t) {\n                if(t instanceof Error){t.stack+=\"\\n    at <async> paramFunc (../test/source/async-stack.ts:59:15)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e",
      "startLine": 82,
      "startCol": 17,
      "endLine": 82,
      "endCol": 17,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 19
    },
    "20": {
      "source": "build/test/test/source/async-stack.js:156:23:156:23",
      "startTime": "577211266232358",
      "endTime": "577211670664758",
      "elapsedTime": "404432400",
      "asyncId": 28,
      "triggerAsyncId": 9,
      "io": "",
      "createdIn": 1625853495764,
      "functionName": "",
      "userCode": false,
      "line": "\n                    ' at <async> staticAsyncFunc ',\n                ]);\n                await doTestWith('object', [\n                    'Error: Thrown[object][object Object]',\n                    ' at asyncArrowConst ',\n                    ' at <async> asyncFunc '",
      "startLine": 156,
      "startCol": 23,
      "endLine": 156,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 20
    },
    "21": {
      "source": "build/test/test/source/async-stack.js:116:42:116:42",
      "startTime": "577211266341142",
      "endTime": "577211670576122",
      "elapsedTime": "404234980",
      "asyncId": 29,
      "triggerAsyncId": 9,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " doTestWith",
      "userCode": false,
      "line": "\n                try {\n                    try {\n                        await ClassAsync.staticAsyncFunc(type);\n                    }\n                    catch (e) {\n                        if (!(e instanceof Error)) ",
      "startLine": 116,
      "startCol": 42,
      "endLine": 116,
      "endCol": 42,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        33
      ],
      "uniqueid": 21
    },
    "22": {
      "source": "build/test/test/source/async-stack.js:4:24:4:24",
      "startTime": "577211266473530",
      "endTime": "577211366536157",
      "elapsedTime": "100062627",
      "asyncId": 30,
      "triggerAsyncId": 9,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " wait",
      "userCode": false,
      "line": "\n/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n(() => {\n    const wait = () => new Promise(resolve => setTimeout(resolve, 100));\n    const acceptCb = (cb) => {\n        // nothing\n    }",
      "startLine": 4,
      "startCol": 24,
      "endLine": 4,
      "endCol": 24,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        32
      ],
      "uniqueid": 22
    },
    "23": {
      "source": "build/test/test/source/async-stack.js:116:42:116:42",
      "startTime": "577211266615175",
      "endTime": "577211367151491",
      "elapsedTime": "100536316",
      "asyncId": 32,
      "triggerAsyncId": 30,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " doTestWith",
      "userCode": false,
      "line": "\n                try {\n                    try {\n                        await ClassAsync.staticAsyncFunc(type);\n                    }\n                    catch (e) {\n                        if (!(e instanceof Error)) ",
      "startLine": 116,
      "startCol": 42,
      "endLine": 116,
      "endCol": 42,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        36,
        35
      ],
      "uniqueid": 23
    },
    "24": {
      "source": "build/test/test/source/async-stack.js:156:23:156:23",
      "startTime": "577211266732275",
      "endTime": "577211670701657",
      "elapsedTime": "403969382",
      "asyncId": 33,
      "triggerAsyncId": 29,
      "io": "",
      "createdIn": 1625853495764,
      "functionName": "",
      "userCode": false,
      "line": "\n                    ' at <async> staticAsyncFunc ',\n                ]);\n                await doTestWith('object', [\n                    'Error: Thrown[object][object Object]',\n                    ' at asyncArrowConst ',\n                    ' at <async> asyncFunc '",
      "startLine": 156,
      "startCol": 23,
      "endLine": 156,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 24
    },
    "25": {
      "source": "build/test/test/source/async-stack.js:93:34:93:34",
      "startTime": "577211366711566",
      "endTime": "577211670464813",
      "elapsedTime": "303753247",
      "asyncId": 35,
      "triggerAsyncId": 32,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Function.staticAsyncFunc",
      "userCode": false,
      "line": "\n            try {\n                await wait();\n                await ClassAsync.staticConstAttrAsync(type);\n                await wait();\n            }\n            catch (t) ",
      "startLine": 93,
      "startCol": 34,
      "endLine": 93,
      "endCol": 34,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        39
      ],
      "uniqueid": 25
    },
    "26": {
      "source": "build/test/test/source/async-stack.js:4:24:4:24",
      "startTime": "577211366849354",
      "endTime": "577211467315729",
      "elapsedTime": "100466375",
      "asyncId": 36,
      "triggerAsyncId": 32,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " wait",
      "userCode": false,
      "line": "\n/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n(() => {\n    const wait = () => new Promise(resolve => setTimeout(resolve, 100));\n    const acceptCb = (cb) => {\n        // nothing\n    }",
      "startLine": 4,
      "startCol": 24,
      "endLine": 4,
      "endCol": 24,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        38
      ],
      "uniqueid": 26
    },
    "27": {
      "source": "build/test/test/source/async-stack.js:93:34:93:34",
      "startTime": "577211367016848",
      "endTime": "577211468264999",
      "elapsedTime": "101248151",
      "asyncId": 38,
      "triggerAsyncId": 36,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Function.staticAsyncFunc",
      "userCode": false,
      "line": "\n            try {\n                await wait();\n                await ClassAsync.staticConstAttrAsync(type);\n                await wait();\n            }\n            catch (t) ",
      "startLine": 93,
      "startCol": 34,
      "endLine": 93,
      "endCol": 34,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        42,
        41,
        40
      ],
      "uniqueid": 27
    },
    "28": {
      "source": "build/test/test/source/async-stack.js:116:25:116:25",
      "startTime": "577211367134469",
      "endTime": "577211670611138",
      "elapsedTime": "303476669",
      "asyncId": 39,
      "triggerAsyncId": 35,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " async doTestWith",
      "userCode": false,
      "line": "\n                try {\n                    try {\n                        await ClassAsync.staticAsyncFunc(type);\n                    }\n                    catch (e) {\n                        if (!(e instanceof Error)) ",
      "startLine": 116,
      "startCol": 25,
      "endLine": 116,
      "endCol": 25,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 28
    },
    "29": {
      "source": "build/test/test/source/async-stack.js:104:23:104:23",
      "startTime": "577211467481500",
      "endTime": "577211670317577",
      "elapsedTime": "202836077",
      "asyncId": 40,
      "triggerAsyncId": 38,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Function.ClassAsync.staticConstAttrAsync",
      "userCode": false,
      "line": "\n        try {\n            await wait();\n            await obj.paramFunc(type);\n            await wait();\n        }\n        catch (t) ",
      "startLine": 104,
      "startCol": 23,
      "endLine": 104,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        46
      ],
      "uniqueid": 29
    },
    "30": {
      "source": "build/test/test/source/async-stack.js:82:23:82:23",
      "startTime": "577211467630299",
      "endTime": "577211670153320",
      "elapsedTime": "202523021",
      "asyncId": 41,
      "triggerAsyncId": 38,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Object.paramFunc",
      "userCode": false,
      "line": "\n        paramFunc: async (type) => {\n            try {\n                await asyncFunc(type);\n            }\n            catch (t) {\n                if(t instanceof Error){t.stack+=\"\\n    at <async> paramFunc (../test/source/async-stack.ts:59:15)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e",
      "startLine": 82,
      "startCol": 23,
      "endLine": 82,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        45
      ],
      "uniqueid": 30
    },
    "31": {
      "source": "build/test/test/source/async-stack.js:4:24:4:24",
      "startTime": "577211467788976",
      "endTime": "577211568474532",
      "elapsedTime": "100685556",
      "asyncId": 42,
      "triggerAsyncId": 38,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " wait",
      "userCode": false,
      "line": "\n/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n(() => {\n    const wait = () => new Promise(resolve => setTimeout(resolve, 100));\n    const acceptCb = (cb) => {\n        // nothing\n    }",
      "startLine": 4,
      "startCol": 24,
      "endLine": 4,
      "endCol": 24,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        44
      ],
      "uniqueid": 31
    },
    "32": {
      "source": "build/test/test/source/async-stack.js:82:23:82:23",
      "startTime": "577211467966970",
      "endTime": "577211569598138",
      "elapsedTime": "101631168",
      "asyncId": 44,
      "triggerAsyncId": 42,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Object.paramFunc",
      "userCode": false,
      "line": "\n        paramFunc: async (type) => {\n            try {\n                await asyncFunc(type);\n            }\n            catch (t) {\n                if(t instanceof Error){t.stack+=\"\\n    at <async> paramFunc (../test/source/async-stack.ts:59:15)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e",
      "startLine": 82,
      "startCol": 23,
      "endLine": 82,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        48,
        47
      ],
      "uniqueid": 32
    },
    "33": {
      "source": "build/test/test/source/async-stack.js:104:23:104:23",
      "startTime": "577211468119045",
      "endTime": "577211670391776",
      "elapsedTime": "202272731",
      "asyncId": 45,
      "triggerAsyncId": 41,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " Function.ClassAsync.staticConstAttrAsync",
      "userCode": false,
      "line": "\n        try {\n            await wait();\n            await obj.paramFunc(type);\n            await wait();\n        }\n        catch (t) ",
      "startLine": 104,
      "startCol": 23,
      "endLine": 104,
      "endCol": 23,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 33
    },
    "34": {
      "source": "build/test/test/source/async-stack.js:93:17:93:17",
      "startTime": "577211468247786",
      "endTime": "577211670532039",
      "elapsedTime": "202284253",
      "asyncId": 46,
      "triggerAsyncId": 40,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " async Function.staticAsyncFunc",
      "userCode": false,
      "line": "\n            try {\n                await wait();\n                await ClassAsync.staticConstAttrAsync(type);\n                await wait();\n            }\n            catch (t) ",
      "startLine": 93,
      "startCol": 17,
      "endLine": 93,
      "endCol": 17,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 34
    },
    "35": {
      "source": "build/test/test/source/async-stack.js:72:19:72:19",
      "startTime": "577211568841480",
      "endTime": "577211669937024",
      "elapsedTime": "101095544",
      "asyncId": 47,
      "triggerAsyncId": 44,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " asyncFunc",
      "userCode": false,
      "line": "\n        try {\n            await wait();\n            await asyncArrowConst(type);\n            await wait();\n        }\n        catch (t) ",
      "startLine": 72,
      "startCol": 19,
      "endLine": 72,
      "endCol": 19,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        51
      ],
      "uniqueid": 35
    },
    "36": {
      "source": "build/test/test/source/async-stack.js:4:24:4:24",
      "startTime": "577211569156140",
      "endTime": "577211669790750",
      "elapsedTime": "100634610",
      "asyncId": 48,
      "triggerAsyncId": 44,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " wait",
      "userCode": false,
      "line": "\n/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n(() => {\n    const wait = () => new Promise(resolve => setTimeout(resolve, 100));\n    const acceptCb = (cb) => {\n        // nothing\n    }",
      "startLine": 4,
      "startCol": 24,
      "endLine": 4,
      "endCol": 24,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [
        50
      ],
      "uniqueid": 36
    },
    "37": {
      "source": "build/test/test/source/async-stack.js:72:19:72:19",
      "startTime": "577211569432929",
      "endTime": "577211670024368",
      "elapsedTime": "100591439",
      "asyncId": 50,
      "triggerAsyncId": 48,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " asyncFunc",
      "userCode": false,
      "line": "\n        try {\n            await wait();\n            await asyncArrowConst(type);\n            await wait();\n        }\n        catch (t) ",
      "startLine": 72,
      "startCol": 19,
      "endLine": 72,
      "endCol": 19,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 37
    },
    "38": {
      "source": "build/test/test/source/async-stack.js:82:17:82:17",
      "startTime": "577211569581728",
      "endTime": "577211670223341",
      "elapsedTime": "100641613",
      "asyncId": 51,
      "triggerAsyncId": 47,
      "io": false,
      "createdIn": 1625853495764,
      "functionName": " async Object.paramFunc",
      "userCode": false,
      "line": "\n        paramFunc: async (type) => {\n            try {\n                await asyncFunc(type);\n            }\n            catch (t) {\n                if(t instanceof Error){t.stack+=\"\\n    at <async> paramFunc (../test/source/async-stack.ts:59:15)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e",
      "startLine": 82,
      "startCol": 17,
      "endLine": 82,
      "endCol": 17,
      "file": "build/test/test/source/async-stack.js",
      "triggers": [],
      "uniqueid": 38
    }
  },
  "antipatterns": {
    "0": {
      "patternID": "pattern5",
      "file": "extension/js/background_page/bg-handlers.ts",
      "startLine": "46",
      "startCol": "63",
      "endLine": "61",
      "endCol": "4"
    },
    "1": {
      "patternID": "pattern5",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "26",
      "startCol": "14",
      "endLine": "26",
      "endCol": "169"
    },
    "2": {
      "patternID": "pattern5",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "119",
      "startCol": "11",
      "endLine": "134",
      "endCol": "6"
    },
    "3": {
      "patternID": "pattern5",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "135",
      "startCol": "12",
      "endLine": "135",
      "endCol": "178"
    },
    "4": {
      "patternID": "pattern5",
      "file": "test/source/async-stack.ts",
      "startLine": "7",
      "startCol": "16",
      "endLine": "7",
      "endCol": "84"
    },
    "5": {
      "patternID": "pattern5",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "106",
      "startCol": "34",
      "endLine": "121",
      "endCol": "3"
    },
    "6": {
      "patternID": "pattern5",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "126",
      "startCol": "26",
      "endLine": "131",
      "endCol": "3"
    },
    "7": {
      "patternID": "pattern5",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "237",
      "startCol": "18",
      "endLine": "239",
      "endCol": "3"
    },
    "8": {
      "patternID": "pattern5",
      "file": "test/source/mock/google/google-data.ts",
      "startLine": "117",
      "startCol": "42",
      "endLine": "117",
      "endCol": "121"
    },
    "9": {
      "patternID": "pattern5",
      "file": "test/source/mock/lib/api.ts",
      "startLine": "81",
      "startCol": "19",
      "endLine": "102",
      "endCol": "3"
    },
    "10": {
      "patternID": "pattern5",
      "file": "test/source/mock/lib/api.ts",
      "startLine": "104",
      "startCol": "18",
      "endLine": "106",
      "endCol": "3"
    },
    "11": {
      "patternID": "pattern5",
      "file": "test/source/mock/lib/api.ts",
      "startLine": "184",
      "startCol": "26",
      "endLine": "208",
      "endCol": "3"
    },
    "12": {
      "patternID": "pattern5",
      "file": "test/source/tests/tooling/index.ts",
      "startLine": "66",
      "startCol": "34",
      "endLine": "68",
      "endCol": "1"
    },
    "13": {
      "patternID": "pattern5",
      "file": "tooling/release.js",
      "startLine": "16",
      "startCol": "14",
      "endLine": "20",
      "endCol": "2"
    },
    "14": {
      "patternID": "pattern3",
      "file": "extension/chrome/dev/export.ts",
      "startLine": "114",
      "startCol": "25",
      "endLine": "114",
      "endCol": "118"
    },
    "15": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/add_pubkey.ts",
      "startLine": "44",
      "startCol": "49",
      "endLine": "44",
      "endCol": "160"
    },
    "16": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/attachment.ts",
      "startLine": "176",
      "startCol": "28",
      "endLine": "202",
      "endCol": "3"
    },
    "17": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/attachment_preview.ts",
      "startLine": "84",
      "startCol": "21",
      "endLine": "96",
      "endCol": "3"
    },
    "18": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/backup.ts",
      "startLine": "62",
      "startCol": "53",
      "endLine": "62",
      "endCol": "163"
    },
    "19": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "48",
      "startCol": "49",
      "endLine": "48",
      "endCol": "86"
    },
    "20": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "59",
      "startCol": "94",
      "endLine": "59",
      "endCol": "147"
    },
    "21": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "78",
      "startCol": "9",
      "endLine": "78",
      "endCol": "73"
    },
    "22": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "95",
      "startCol": "98",
      "endLine": "95",
      "endCol": "157"
    },
    "23": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "114",
      "startCol": "27",
      "endLine": "114",
      "endCol": "76"
    },
    "24": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "128",
      "startCol": "28",
      "endLine": "128",
      "endCol": "97"
    },
    "25": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "144",
      "startCol": "13",
      "endLine": "144",
      "endCol": "101"
    },
    "26": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "194",
      "startCol": "17",
      "endLine": "194",
      "endCol": "32"
    },
    "27": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "239",
      "startCol": "5",
      "endLine": "239",
      "endCol": "118"
    },
    "28": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "248",
      "startCol": "35",
      "endLine": "276",
      "endCol": "3"
    },
    "29": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "254",
      "startCol": "24",
      "endLine": "254",
      "endCol": "68"
    },
    "30": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "314",
      "startCol": "5",
      "endLine": "314",
      "endCol": "63"
    },
    "31": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-draft-module.ts",
      "startLine": "320",
      "startCol": "7",
      "endLine": "320",
      "endCol": "63"
    },
    "32": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-err-module.ts",
      "startLine": "33",
      "startCol": "16",
      "endLine": "33",
      "endCol": "112"
    },
    "33": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-err-module.ts",
      "startLine": "125",
      "startCol": "18",
      "endLine": "125",
      "endCol": "72"
    },
    "34": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-err-module.ts",
      "startLine": "136",
      "startCol": "18",
      "endLine": "136",
      "endCol": "70"
    },
    "35": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-input-module.ts",
      "startLine": "238",
      "startCol": "7",
      "endLine": "238",
      "endCol": "45"
    },
    "36": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-my-pubkey-module.ts",
      "startLine": "49",
      "startCol": "24",
      "endLine": "49",
      "endCol": "72"
    },
    "37": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-my-pubkey-module.ts",
      "startLine": "64",
      "startCol": "28",
      "endLine": "64",
      "endCol": "84"
    },
    "38": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-my-pubkey-module.ts",
      "startLine": "74",
      "startCol": "17",
      "endLine": "74",
      "endCol": "85"
    },
    "39": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-pwd-or-pubkey-container-module.ts",
      "startLine": "34",
      "startCol": "7",
      "endLine": "34",
      "endCol": "69"
    },
    "40": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-pwd-or-pubkey-container-module.ts",
      "startLine": "62",
      "startCol": "7",
      "endLine": "65",
      "endCol": "30"
    },
    "41": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-pwd-or-pubkey-container-module.ts",
      "startLine": "96",
      "startCol": "28",
      "endLine": "96",
      "endCol": "93"
    },
    "42": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-quote-module.ts",
      "startLine": "34",
      "startCol": "24",
      "endLine": "34",
      "endCol": "108"
    },
    "43": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-quote-module.ts",
      "startLine": "70",
      "startCol": "24",
      "endLine": "70",
      "endCol": "108"
    },
    "44": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-quote-module.ts",
      "startLine": "86",
      "startCol": "23",
      "endLine": "86",
      "endCol": "125"
    },
    "45": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-quote-module.ts",
      "startLine": "162",
      "startCol": "28",
      "endLine": "179",
      "endCol": "3"
    },
    "46": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-recipients-module.ts",
      "startLine": "87",
      "startCol": "49",
      "endLine": "87",
      "endCol": "133"
    },
    "47": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-recipients-module.ts",
      "startLine": "175",
      "startCol": "5",
      "endLine": "175",
      "endCol": "75"
    },
    "48": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-recipients-module.ts",
      "startLine": "196",
      "startCol": "29",
      "endLine": "196",
      "endCol": "134"
    },
    "49": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-recipients-module.ts",
      "startLine": "204",
      "startCol": "5",
      "endLine": "204",
      "endCol": "56"
    },
    "50": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-recipients-module.ts",
      "startLine": "234",
      "startCol": "7",
      "endLine": "234",
      "endCol": "92"
    },
    "51": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-recipients-module.ts",
      "startLine": "284",
      "startCol": "7",
      "endLine": "284",
      "endCol": "68"
    },
    "52": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-recipients-module.ts",
      "startLine": "317",
      "startCol": "24",
      "endLine": "317",
      "endCol": "107"
    },
    "53": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-recipients-module.ts",
      "startLine": "339",
      "startCol": "7",
      "endLine": "339",
      "endCol": "77"
    },
    "54": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-recipients-module.ts",
      "startLine": "554",
      "startCol": "5",
      "endLine": "565",
      "endCol": "6"
    },
    "55": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-recipients-module.ts",
      "startLine": "749",
      "startCol": "5",
      "endLine": "753",
      "endCol": "8"
    },
    "56": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-recipients-module.ts",
      "startLine": "823",
      "startCol": "75",
      "endLine": "823",
      "endCol": "116"
    },
    "57": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "35",
      "startCol": "27",
      "endLine": "35",
      "endCol": "89"
    },
    "58": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "40",
      "startCol": "9",
      "endLine": "40",
      "endCol": "65"
    },
    "59": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "60",
      "startCol": "7",
      "endLine": "60",
      "endCol": "99"
    },
    "60": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "63",
      "startCol": "5",
      "endLine": "63",
      "endCol": "50"
    },
    "61": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "70",
      "startCol": "5",
      "endLine": "70",
      "endCol": "97"
    },
    "62": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "73",
      "startCol": "22",
      "endLine": "73",
      "endCol": "92"
    },
    "63": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "82",
      "startCol": "9",
      "endLine": "82",
      "endCol": "120"
    },
    "64": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "165",
      "startCol": "24",
      "endLine": "165",
      "endCol": "94"
    },
    "65": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "242",
      "startCol": "5",
      "endLine": "242",
      "endCol": "58"
    },
    "66": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "246",
      "startCol": "9",
      "endLine": "246",
      "endCol": "94"
    },
    "67": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "251",
      "startCol": "7",
      "endLine": "251",
      "endCol": "72"
    },
    "68": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "321",
      "startCol": "7",
      "endLine": "321",
      "endCol": "92"
    },
    "69": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-render-module.ts",
      "startLine": "345",
      "startCol": "5",
      "endLine": "345",
      "endCol": "114"
    },
    "70": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-send-btn-module.ts",
      "startLine": "114",
      "startCol": "7",
      "endLine": "114",
      "endCol": "66"
    },
    "71": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-send-btn-module.ts",
      "startLine": "115",
      "startCol": "24",
      "endLine": "115",
      "endCol": "95"
    },
    "72": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-send-btn-module.ts",
      "startLine": "128",
      "startCol": "7",
      "endLine": "128",
      "endCol": "48"
    },
    "73": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-send-btn-module.ts",
      "startLine": "212",
      "startCol": "20",
      "endLine": "212",
      "endCol": "118"
    },
    "74": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-send-btn-module.ts",
      "startLine": "216",
      "startCol": "22",
      "endLine": "216",
      "endCol": "120"
    },
    "75": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-send-btn-module.ts",
      "startLine": "224",
      "startCol": "5",
      "endLine": "224",
      "endCol": "45"
    },
    "76": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-send-btn-module.ts",
      "startLine": "235",
      "startCol": "24",
      "endLine": "235",
      "endCol": "76"
    },
    "77": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-send-btn-module.ts",
      "startLine": "238",
      "startCol": "19",
      "endLine": "238",
      "endCol": "79"
    },
    "78": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-send-btn-module.ts",
      "startLine": "233",
      "startCol": "30",
      "endLine": "250",
      "endCol": "3"
    },
    "79": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-send-btn-module.ts",
      "startLine": "255",
      "startCol": "14",
      "endLine": "270",
      "endCol": "9"
    },
    "80": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-send-btn-module.ts",
      "startLine": "254",
      "startCol": "28",
      "endLine": "271",
      "endCol": "5"
    },
    "81": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-sender-module.ts",
      "startLine": "81",
      "startCol": "5",
      "endLine": "81",
      "endCol": "101"
    },
    "82": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-sender-module.ts",
      "startLine": "82",
      "startCol": "5",
      "endLine": "82",
      "endCol": "97"
    },
    "83": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-sender-module.ts",
      "startLine": "83",
      "startCol": "44",
      "endLine": "83",
      "endCol": "128"
    },
    "84": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-size-module.ts",
      "startLine": "126",
      "startCol": "7",
      "endLine": "126",
      "endCol": "99"
    },
    "85": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-size-module.ts",
      "startLine": "152",
      "startCol": "7",
      "endLine": "152",
      "endCol": "99"
    },
    "86": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-storage-module.ts",
      "startLine": "37",
      "startCol": "18",
      "endLine": "37",
      "endCol": "97"
    },
    "87": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-storage-module.ts",
      "startLine": "74",
      "startCol": "26",
      "endLine": "79",
      "endCol": "3"
    },
    "88": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-storage-module.ts",
      "startLine": "81",
      "startCol": "61",
      "endLine": "91",
      "endCol": "3"
    },
    "89": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-storage-module.ts",
      "startLine": "95",
      "startCol": "28",
      "endLine": "95",
      "endCol": "71"
    },
    "90": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-storage-module.ts",
      "startLine": "123",
      "startCol": "11",
      "endLine": "123",
      "endCol": "111"
    },
    "91": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-storage-module.ts",
      "startLine": "123",
      "startCol": "41",
      "endLine": "123",
      "endCol": "109"
    },
    "92": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-storage-module.ts",
      "startLine": "146",
      "startCol": "50",
      "endLine": "146",
      "endCol": "113"
    },
    "93": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-storage-module.ts",
      "startLine": "158",
      "startCol": "13",
      "endLine": "158",
      "endCol": "80"
    },
    "94": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/compose-storage-module.ts",
      "startLine": "170",
      "startCol": "40",
      "endLine": "185",
      "endCol": "3"
    },
    "95": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/compose-storage-module.ts",
      "startLine": "191",
      "startCol": "9",
      "endLine": "191",
      "endCol": "70"
    },
    "96": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts",
      "startLine": "27",
      "startCol": "24",
      "endLine": "37",
      "endCol": "3"
    },
    "97": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts",
      "startLine": "43",
      "startCol": "106",
      "endLine": "43",
      "endCol": "170"
    },
    "98": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts",
      "startLine": "45",
      "startCol": "21",
      "endLine": "49",
      "endCol": "5"
    },
    "99": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts",
      "startLine": "59",
      "startCol": "14",
      "endLine": "59",
      "endCol": "89"
    },
    "100": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts",
      "startLine": "53",
      "startCol": "28",
      "endLine": "62",
      "endCol": "3"
    },
    "101": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts",
      "startLine": "69",
      "startCol": "61",
      "endLine": "69",
      "endCol": "125"
    },
    "102": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts",
      "startLine": "64",
      "startCol": "35",
      "endLine": "80",
      "endCol": "3"
    },
    "103": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts",
      "startLine": "76",
      "startCol": "61",
      "endLine": "76",
      "endCol": "136"
    },
    "104": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts",
      "startLine": "83",
      "startCol": "50",
      "endLine": "83",
      "endCol": "114"
    },
    "105": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts",
      "startLine": "82",
      "startCol": "33",
      "endLine": "93",
      "endCol": "3"
    },
    "106": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts",
      "startLine": "115",
      "startCol": "24",
      "endLine": "115",
      "endCol": "72"
    },
    "107": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/formatters/general-mail-formatter.ts",
      "startLine": "15",
      "startCol": "33",
      "endLine": "32",
      "endCol": "3"
    },
    "108": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/formatters/general-mail-formatter.ts",
      "startLine": "26",
      "startCol": "54",
      "endLine": "26",
      "endCol": "152"
    },
    "109": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/formatters/general-mail-formatter.ts",
      "startLine": "28",
      "startCol": "7",
      "endLine": "28",
      "endCol": "81"
    },
    "110": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/formatters/plain-mail-msg-formatter.ts",
      "startLine": "14",
      "startCol": "45",
      "endLine": "14",
      "endCol": "109"
    },
    "111": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/formatters/plain-mail-msg-formatter.ts",
      "startLine": "12",
      "startCol": "24",
      "endLine": "20",
      "endCol": "3"
    },
    "112": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/compose-modules/formatters/signed-msg-mail-formatter.ts",
      "startLine": "19",
      "startCol": "45",
      "endLine": "19",
      "endCol": "109"
    },
    "113": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose-modules/formatters/signed-msg-mail-formatter.ts",
      "startLine": "17",
      "startCol": "24",
      "endLine": "43",
      "endCol": "3"
    },
    "114": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/compose.ts",
      "startLine": "194",
      "startCol": "54",
      "endLine": "194",
      "endCol": "119"
    },
    "115": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "31",
      "startCol": "25",
      "endLine": "31",
      "endCol": "76"
    },
    "116": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "39",
      "startCol": "11",
      "endLine": "39",
      "endCol": "174"
    },
    "117": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "51",
      "startCol": "50",
      "endLine": "53",
      "endCol": "12"
    },
    "118": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "61",
      "startCol": "7",
      "endLine": "61",
      "endCol": "56"
    },
    "119": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "70",
      "startCol": "9",
      "endLine": "70",
      "endCol": "96"
    },
    "120": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "76",
      "startCol": "11",
      "endLine": "84",
      "endCol": "28"
    },
    "121": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "91",
      "startCol": "11",
      "endLine": "91",
      "endCol": "130"
    },
    "122": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "95",
      "startCol": "9",
      "endLine": "95",
      "endCol": "65"
    },
    "123": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "106",
      "startCol": "11",
      "endLine": "106",
      "endCol": "162"
    },
    "124": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "108",
      "startCol": "11",
      "endLine": "108",
      "endCol": "150"
    },
    "125": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "110",
      "startCol": "11",
      "endLine": "110",
      "endCol": "98"
    },
    "126": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "112",
      "startCol": "11",
      "endLine": "112",
      "endCol": "97"
    },
    "127": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "114",
      "startCol": "11",
      "endLine": "114",
      "endCol": "160"
    },
    "128": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "116",
      "startCol": "11",
      "endLine": "116",
      "endCol": "179"
    },
    "129": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "123",
      "startCol": "7",
      "endLine": "124",
      "endCol": "123"
    },
    "130": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts",
      "startLine": "124",
      "startCol": "9",
      "endLine": "124",
      "endCol": "122"
    },
    "131": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-error-module.ts",
      "startLine": "23",
      "startCol": "5",
      "endLine": "23",
      "endCol": "139"
    },
    "132": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-error-module.ts",
      "startLine": "27",
      "startCol": "64",
      "endLine": "27",
      "endCol": "181"
    },
    "133": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-error-module.ts",
      "startLine": "28",
      "startCol": "54",
      "endLine": "28",
      "endCol": "129"
    },
    "134": {
      "patternID": "pattern1",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-error-module.ts",
      "startLine": "29",
      "startCol": "62",
      "endLine": "29",
      "endCol": "177"
    },
    "135": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-quote-module.ts",
      "startLine": "37",
      "startCol": "9",
      "endLine": "37",
      "endCol": "73"
    },
    "136": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-quote-module.ts",
      "startLine": "40",
      "startCol": "9",
      "endLine": "40",
      "endCol": "75"
    },
    "137": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-quote-module.ts",
      "startLine": "61",
      "startCol": "7",
      "endLine": "61",
      "endCol": "105"
    },
    "138": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-render-module.ts",
      "startLine": "119",
      "startCol": "5",
      "endLine": "119",
      "endCol": "92"
    },
    "139": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-signature-module.ts",
      "startLine": "78",
      "startCol": "29",
      "endLine": "78",
      "endCol": "78"
    },
    "140": {
      "patternID": "pattern3",
      "file": "extension/chrome/elements/pgp_block_modules/pgp-block-signature-module.ts",
      "startLine": "92",
      "startCol": "29",
      "endLine": "92",
      "endCol": "53"
    },
    "141": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/inbox/inbox-modules/inbox-active-thread-module.ts",
      "startLine": "33",
      "startCol": "26",
      "endLine": "33",
      "endCol": "78"
    },
    "142": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/inbox/inbox-modules/inbox-active-thread-module.ts",
      "startLine": "104",
      "startCol": "23",
      "endLine": "104",
      "endCol": "69"
    },
    "143": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/inbox/inbox-modules/inbox-active-thread-module.ts",
      "startLine": "149",
      "startCol": "18",
      "endLine": "149",
      "endCol": "60"
    },
    "144": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/inbox/inbox-modules/inbox-active-thread-module.ts",
      "startLine": "150",
      "startCol": "17",
      "endLine": "150",
      "endCol": "58"
    },
    "145": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/inbox/inbox-modules/inbox-active-thread-module.ts",
      "startLine": "152",
      "startCol": "5",
      "endLine": "152",
      "endCol": "63"
    },
    "146": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/inbox/inbox-modules/inbox-list-threads-module.ts",
      "startLine": "20",
      "startCol": "27",
      "endLine": "20",
      "endCol": "67"
    },
    "147": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/inbox/inbox-modules/inbox-list-threads-module.ts",
      "startLine": "22",
      "startCol": "9",
      "endLine": "22",
      "endCol": "71"
    },
    "148": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/inbox/inbox-modules/inbox-list-threads-module.ts",
      "startLine": "47",
      "startCol": "22",
      "endLine": "47",
      "endCol": "74"
    },
    "149": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/inbox/inbox-modules/inbox-menu-module.ts",
      "startLine": "24",
      "startCol": "23",
      "endLine": "24",
      "endCol": "55"
    },
    "150": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/inbox/inbox-modules/inbox-menu-module.ts",
      "startLine": "107",
      "startCol": "5",
      "endLine": "107",
      "endCol": "68"
    },
    "151": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/inbox/inbox.ts",
      "startLine": "96",
      "startCol": "54",
      "endLine": "96",
      "endCol": "124"
    },
    "152": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/inbox/inbox.ts",
      "startLine": "101",
      "startCol": "69",
      "endLine": "101",
      "endCol": "148"
    },
    "153": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/index.ts",
      "startLine": "161",
      "startCol": "69",
      "endLine": "161",
      "endCol": "148"
    },
    "154": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/index.ts",
      "startLine": "162",
      "startCol": "69",
      "endLine": "162",
      "endCol": "164"
    },
    "155": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/index.ts",
      "startLine": "196",
      "startCol": "59",
      "endLine": "196",
      "endCol": "181"
    },
    "156": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/index.ts",
      "startLine": "197",
      "startCol": "64",
      "endLine": "197",
      "endCol": "183"
    },
    "157": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/modules/add_key.ts",
      "startLine": "70",
      "startCol": "34",
      "endLine": "95",
      "endCol": "3"
    },
    "158": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/modules/backup-automatic-module.ts",
      "startLine": "18",
      "startCol": "54",
      "endLine": "24",
      "endCol": "3"
    },
    "159": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/backup-automatic-module.ts",
      "startLine": "33",
      "startCol": "7",
      "endLine": "33",
      "endCol": "77"
    },
    "160": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/backup-automatic-module.ts",
      "startLine": "34",
      "startCol": "7",
      "endLine": "34",
      "endCol": "40"
    },
    "161": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/backup-manual-module.ts",
      "startLine": "45",
      "startCol": "29",
      "endLine": "45",
      "endCol": "109"
    },
    "162": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/backup-manual-module.ts",
      "startLine": "50",
      "startCol": "14",
      "endLine": "50",
      "endCol": "47"
    },
    "163": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/modules/backup-manual-module.ts",
      "startLine": "44",
      "startCol": "36",
      "endLine": "54",
      "endCol": "3"
    },
    "164": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/modules/backup-manual-module.ts",
      "startLine": "78",
      "startCol": "46",
      "endLine": "115",
      "endCol": "3"
    },
    "165": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/backup-manual-module.ts",
      "startLine": "114",
      "startCol": "5",
      "endLine": "114",
      "endCol": "38"
    },
    "166": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/backup-manual-module.ts",
      "startLine": "121",
      "startCol": "5",
      "endLine": "121",
      "endCol": "38"
    },
    "167": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/backup-manual-module.ts",
      "startLine": "129",
      "startCol": "5",
      "endLine": "129",
      "endCol": "43"
    },
    "168": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/modules/backup-status-module.ts",
      "startLine": "20",
      "startCol": "71",
      "endLine": "20",
      "endCol": "112"
    },
    "169": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/backup-status-module.ts",
      "startLine": "25",
      "startCol": "23",
      "endLine": "25",
      "endCol": "61"
    },
    "170": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/modules/keyserver.ts",
      "startLine": "78",
      "startCol": "36",
      "endLine": "92",
      "endCol": "3"
    },
    "171": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/keyserver.ts",
      "startLine": "85",
      "startCol": "7",
      "endLine": "85",
      "endCol": "106"
    },
    "172": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/modules/keyserver.ts",
      "startLine": "94",
      "startCol": "37",
      "endLine": "109",
      "endCol": "3"
    },
    "173": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/keyserver.ts",
      "startLine": "101",
      "startCol": "28",
      "endLine": "101",
      "endCol": "121"
    },
    "174": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/keyserver.ts",
      "startLine": "116",
      "startCol": "21",
      "endLine": "116",
      "endCol": "111"
    },
    "175": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/my_key.ts",
      "startLine": "73",
      "startCol": "22",
      "endLine": "73",
      "endCol": "78"
    },
    "176": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/modules/my_key_update.ts",
      "startLine": "61",
      "startCol": "29",
      "endLine": "61",
      "endCol": "148"
    },
    "177": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-create-key.ts",
      "startLine": "46",
      "startCol": "9",
      "endLine": "46",
      "endCol": "53"
    },
    "178": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/setup/setup-create-key.ts",
      "startLine": "84",
      "startCol": "45",
      "endLine": "114",
      "endCol": "3"
    },
    "179": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-import-key.ts",
      "startLine": "32",
      "startCol": "23",
      "endLine": "32",
      "endCol": "160"
    },
    "180": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-import-key.ts",
      "startLine": "37",
      "startCol": "7",
      "endLine": "37",
      "endCol": "51"
    },
    "181": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/setup/setup-import-key.ts",
      "startLine": "19",
      "startCol": "41",
      "endLine": "50",
      "endCol": "3"
    },
    "182": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-import-key.ts",
      "startLine": "67",
      "startCol": "5",
      "endLine": "67",
      "endCol": "49"
    },
    "183": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-key-manager-autogen.ts",
      "startLine": "32",
      "startCol": "31",
      "endLine": "32",
      "endCol": "92"
    },
    "184": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-key-manager-autogen.ts",
      "startLine": "41",
      "startCol": "7",
      "endLine": "41",
      "endCol": "51"
    },
    "185": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-recover-key.ts",
      "startLine": "71",
      "startCol": "9",
      "endLine": "71",
      "endCol": "53"
    },
    "186": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-recover-key.ts",
      "startLine": "73",
      "startCol": "9",
      "endLine": "73",
      "endCol": "53"
    },
    "187": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-recover-key.ts",
      "startLine": "112",
      "startCol": "23",
      "endLine": "112",
      "endCol": "61"
    },
    "188": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-recover-key.ts",
      "startLine": "122",
      "startCol": "7",
      "endLine": "122",
      "endCol": "51"
    },
    "189": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/setup/setup-render.ts",
      "startLine": "19",
      "startCol": "26",
      "endLine": "53",
      "endCol": "3"
    },
    "190": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-render.ts",
      "startLine": "38",
      "startCol": "9",
      "endLine": "38",
      "endCol": "64"
    },
    "191": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-render.ts",
      "startLine": "49",
      "startCol": "7",
      "endLine": "49",
      "endCol": "80"
    },
    "192": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-render.ts",
      "startLine": "95",
      "startCol": "22",
      "endLine": "95",
      "endCol": "79"
    },
    "193": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/setup/setup-render.ts",
      "startLine": "92",
      "startCol": "30",
      "endLine": "126",
      "endCol": "3"
    },
    "194": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup/setup-render.ts",
      "startLine": "105",
      "startCol": "27",
      "endLine": "105",
      "endCol": "65"
    },
    "195": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/setup.ts",
      "startLine": "142",
      "startCol": "50",
      "endLine": "142",
      "endCol": "155"
    },
    "196": {
      "patternID": "pattern1",
      "file": "extension/chrome/settings/setup.ts",
      "startLine": "189",
      "startCol": "45",
      "endLine": "198",
      "endCol": "3"
    },
    "197": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup.ts",
      "startLine": "255",
      "startCol": "7",
      "endLine": "255",
      "endCol": "79"
    },
    "198": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup.ts",
      "startLine": "258",
      "startCol": "7",
      "endLine": "258",
      "endCol": "99"
    },
    "199": {
      "patternID": "pattern3",
      "file": "extension/chrome/settings/setup.ts",
      "startLine": "262",
      "startCol": "7",
      "endLine": "262",
      "endCol": "97"
    },
    "200": {
      "patternID": "pattern1",
      "file": "extension/js/background_page/bg-handlers.ts",
      "startLine": "18",
      "startCol": "38",
      "endLine": "28",
      "endCol": "3"
    },
    "201": {
      "patternID": "pattern3",
      "file": "extension/js/background_page/bg-handlers.ts",
      "startLine": "25",
      "startCol": "14",
      "endLine": "25",
      "endCol": "49"
    },
    "202": {
      "patternID": "pattern3",
      "file": "extension/js/background_page/bg-handlers.ts",
      "startLine": "27",
      "startCol": "12",
      "endLine": "27",
      "endCol": "44"
    },
    "203": {
      "patternID": "pattern1",
      "file": "extension/js/background_page/bg-handlers.ts",
      "startLine": "30",
      "startCol": "31",
      "endLine": "32",
      "endCol": "3"
    },
    "204": {
      "patternID": "pattern1",
      "file": "extension/js/background_page/bgutils.ts",
      "startLine": "34",
      "startCol": "44",
      "endLine": "47",
      "endCol": "3"
    },
    "205": {
      "patternID": "pattern3",
      "file": "extension/js/background_page/migrations.ts",
      "startLine": "124",
      "startCol": "24",
      "endLine": "125",
      "endCol": "66"
    },
    "206": {
      "patternID": "pattern1",
      "file": "extension/js/background_page/migrations.ts",
      "startLine": "125",
      "startCol": "9",
      "endLine": "125",
      "endCol": "64"
    },
    "207": {
      "patternID": "pattern3",
      "file": "extension/js/background_page/migrations.ts",
      "startLine": "173",
      "startCol": "21",
      "endLine": "187",
      "endCol": "5"
    },
    "208": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/account-server.ts",
      "startLine": "29",
      "startCol": "42",
      "endLine": "36",
      "endCol": "3"
    },
    "209": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/account-server.ts",
      "startLine": "47",
      "startCol": "26",
      "endLine": "49",
      "endCol": "3"
    },
    "210": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/account-server.ts",
      "startLine": "51",
      "startCol": "25",
      "endLine": "53",
      "endCol": "3"
    },
    "211": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/account-servers/enterprise-server.ts",
      "startLine": "78",
      "startCol": "27",
      "endLine": "80",
      "endCol": "3"
    },
    "212": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/account-servers/enterprise-server.ts",
      "startLine": "112",
      "startCol": "12",
      "endLine": "112",
      "endCol": "137"
    },
    "213": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/account-servers/enterprise-server.ts",
      "startLine": "111",
      "startCol": "21",
      "endLine": "113",
      "endCol": "3"
    },
    "214": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/account-servers/flowcrypt-com-api.ts",
      "startLine": "52",
      "startCol": "33",
      "endLine": "58",
      "endCol": "3"
    },
    "215": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/account-servers/flowcrypt-com-api.ts",
      "startLine": "78",
      "startCol": "32",
      "endLine": "81",
      "endCol": "3"
    },
    "216": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/account-servers/flowcrypt-com-api.ts",
      "startLine": "84",
      "startCol": "12",
      "endLine": "84",
      "endCol": "138"
    },
    "217": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/account-servers/flowcrypt-com-api.ts",
      "startLine": "83",
      "startCol": "28",
      "endLine": "85",
      "endCol": "3"
    },
    "218": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "42",
      "startCol": "22",
      "endLine": "44",
      "endCol": "3"
    },
    "219": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "46",
      "startCol": "23",
      "endLine": "54",
      "endCol": "3"
    },
    "220": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "56",
      "startCol": "25",
      "endLine": "61",
      "endCol": "3"
    },
    "221": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "63",
      "startCol": "24",
      "endLine": "65",
      "endCol": "3"
    },
    "222": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "67",
      "startCol": "24",
      "endLine": "69",
      "endCol": "3"
    },
    "223": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "71",
      "startCol": "24",
      "endLine": "73",
      "endCol": "3"
    },
    "224": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "75",
      "startCol": "21",
      "endLine": "77",
      "endCol": "3"
    },
    "225": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "79",
      "startCol": "22",
      "endLine": "81",
      "endCol": "3"
    },
    "226": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "83",
      "startCol": "22",
      "endLine": "85",
      "endCol": "3"
    },
    "227": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "87",
      "startCol": "20",
      "endLine": "93",
      "endCol": "3"
    },
    "228": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "95",
      "startCol": "20",
      "endLine": "97",
      "endCol": "3"
    },
    "229": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "104",
      "startCol": "19",
      "endLine": "106",
      "endCol": "3"
    },
    "230": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "109",
      "startCol": "12",
      "endLine": "109",
      "endCol": "71"
    },
    "231": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "108",
      "startCol": "20",
      "endLine": "110",
      "endCol": "3"
    },
    "232": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "112",
      "startCol": "22",
      "endLine": "114",
      "endCol": "3"
    },
    "233": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "122",
      "startCol": "31",
      "endLine": "207",
      "endCol": "3"
    },
    "234": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "217",
      "startCol": "23",
      "endLine": "227",
      "endCol": "8"
    },
    "235": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "327",
      "startCol": "41",
      "endLine": "330",
      "endCol": "3"
    },
    "236": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "342",
      "startCol": "21",
      "endLine": "342",
      "endCol": "86"
    },
    "237": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "387",
      "startCol": "53",
      "endLine": "387",
      "endCol": "169"
    },
    "238": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "426",
      "startCol": "9",
      "endLine": "426",
      "endCol": "88"
    },
    "239": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/email-provider/gmail/gmail.ts",
      "startLine": "429",
      "startCol": "5",
      "endLine": "429",
      "endCol": "49"
    },
    "240": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/google-auth.ts",
      "startLine": "100",
      "startCol": "54",
      "endLine": "110",
      "endCol": "3"
    },
    "241": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/email-provider/gmail/google-auth.ts",
      "startLine": "128",
      "startCol": "21",
      "endLine": "131",
      "endCol": "6"
    },
    "242": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/google-auth.ts",
      "startLine": "172",
      "startCol": "38",
      "endLine": "174",
      "endCol": "3"
    },
    "243": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/gmail/google-auth.ts",
      "startLine": "176",
      "startCol": "45",
      "endLine": "186",
      "endCol": "3"
    },
    "244": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/sendable-msg.ts",
      "startLine": "40",
      "startCol": "31",
      "endLine": "42",
      "endCol": "3"
    },
    "245": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/sendable-msg.ts",
      "startLine": "44",
      "startCol": "31",
      "endLine": "46",
      "endCol": "3"
    },
    "246": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/sendable-msg.ts",
      "startLine": "48",
      "startCol": "35",
      "endLine": "50",
      "endCol": "3"
    },
    "247": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/sendable-msg.ts",
      "startLine": "52",
      "startCol": "32",
      "endLine": "60",
      "endCol": "3"
    },
    "248": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/sendable-msg.ts",
      "startLine": "62",
      "startCol": "33",
      "endLine": "64",
      "endCol": "3"
    },
    "249": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/sendable-msg.ts",
      "startLine": "78",
      "startCol": "38",
      "endLine": "88",
      "endCol": "3"
    },
    "250": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/email-provider/sendable-msg.ts",
      "startLine": "129",
      "startCol": "19",
      "endLine": "149",
      "endCol": "3"
    },
    "251": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/flowcrypt-website.ts",
      "startLine": "30",
      "startCol": "32",
      "endLine": "35",
      "endCol": "3"
    },
    "252": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/flowcrypt-website.ts",
      "startLine": "53",
      "startCol": "12",
      "endLine": "53",
      "endCol": "139"
    },
    "253": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/flowcrypt-website.ts",
      "startLine": "52",
      "startCol": "28",
      "endLine": "54",
      "endCol": "3"
    },
    "254": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/key-server/attester.ts",
      "startLine": "46",
      "startCol": "5",
      "endLine": "48",
      "endCol": "7"
    },
    "255": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/key-server/attester.ts",
      "startLine": "55",
      "startCol": "30",
      "endLine": "57",
      "endCol": "3"
    },
    "256": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/key-server/attester.ts",
      "startLine": "99",
      "startCol": "32",
      "endLine": "104",
      "endCol": "3"
    },
    "257": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/key-server/attester.ts",
      "startLine": "106",
      "startCol": "24",
      "endLine": "108",
      "endCol": "3"
    },
    "258": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/key-server/attester.ts",
      "startLine": "114",
      "startCol": "21",
      "endLine": "116",
      "endCol": "3"
    },
    "259": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/key-server/key-manager.ts",
      "startLine": "29",
      "startCol": "28",
      "endLine": "31",
      "endCol": "3"
    },
    "260": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/key-server/key-manager.ts",
      "startLine": "33",
      "startCol": "28",
      "endLine": "35",
      "endCol": "3"
    },
    "261": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/key-server/key-manager.ts",
      "startLine": "37",
      "startCol": "21",
      "endLine": "39",
      "endCol": "3"
    },
    "262": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/key-server/sks.ts",
      "startLine": "27",
      "startCol": "24",
      "endLine": "59",
      "endCol": "3"
    },
    "263": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/key-server/wkd.ts",
      "startLine": "42",
      "startCol": "40",
      "endLine": "42",
      "endCol": "126"
    },
    "264": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/key-server/wkd.ts",
      "startLine": "23",
      "startCol": "27",
      "endLine": "59",
      "endCol": "3"
    },
    "265": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/key-server/wkd.ts",
      "startLine": "79",
      "startCol": "7",
      "endLine": "79",
      "endCol": "65"
    },
    "266": {
      "patternID": "pattern3",
      "file": "extension/js/common/api/key-server/wkd.ts",
      "startLine": "84",
      "startCol": "19",
      "endLine": "84",
      "endCol": "82"
    },
    "267": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/pub-lookup.ts",
      "startLine": "66",
      "startCol": "30",
      "endLine": "80",
      "endCol": "3"
    },
    "268": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/shared/api.ts",
      "startLine": "40",
      "startCol": "28",
      "endLine": "65",
      "endCol": "3"
    },
    "269": {
      "patternID": "pattern1",
      "file": "extension/js/common/api/shared/api.ts",
      "startLine": "67",
      "startCol": "24",
      "endLine": "95",
      "endCol": "3"
    },
    "270": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/browser-msg.ts",
      "startLine": "253",
      "startCol": "10",
      "endLine": "253",
      "endCol": "82"
    },
    "271": {
      "patternID": "pattern1",
      "file": "extension/js/common/browser/browser-msg.ts",
      "startLine": "253",
      "startCol": "42",
      "endLine": "253",
      "endCol": "80"
    },
    "272": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/browser-msg.ts",
      "startLine": "382",
      "startCol": "14",
      "endLine": "382",
      "endCol": "44"
    },
    "273": {
      "patternID": "pattern1",
      "file": "extension/js/common/browser/browser-msg.ts",
      "startLine": "376",
      "startCol": "30",
      "endLine": "436",
      "endCol": "3"
    },
    "274": {
      "patternID": "pattern1",
      "file": "extension/js/common/browser/chrome.ts",
      "startLine": "33",
      "startCol": "26",
      "endLine": "35",
      "endCol": "1"
    },
    "275": {
      "patternID": "pattern1",
      "file": "extension/js/common/browser/chrome.ts",
      "startLine": "37",
      "startCol": "30",
      "endLine": "45",
      "endCol": "1"
    },
    "276": {
      "patternID": "pattern1",
      "file": "extension/js/common/browser/chrome.ts",
      "startLine": "47",
      "startCol": "32",
      "endLine": "63",
      "endCol": "1"
    },
    "277": {
      "patternID": "pattern1",
      "file": "extension/js/common/browser/chrome.ts",
      "startLine": "65",
      "startCol": "35",
      "endLine": "73",
      "endCol": "1"
    },
    "278": {
      "patternID": "pattern1",
      "file": "extension/js/common/browser/chrome.ts",
      "startLine": "75",
      "startCol": "32",
      "endLine": "83",
      "endCol": "1"
    },
    "279": {
      "patternID": "pattern1",
      "file": "extension/js/common/browser/chrome.ts",
      "startLine": "85",
      "startCol": "35",
      "endLine": "93",
      "endCol": "1"
    },
    "280": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "141",
      "startCol": "7",
      "endLine": "148",
      "endCol": "8"
    },
    "281": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "152",
      "startCol": "7",
      "endLine": "160",
      "endCol": "8"
    },
    "282": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "165",
      "startCol": "7",
      "endLine": "173",
      "endCol": "8"
    },
    "283": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "194",
      "startCol": "27",
      "endLine": "194",
      "endCol": "51"
    },
    "284": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "219",
      "startCol": "27",
      "endLine": "219",
      "endCol": "51"
    },
    "285": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "223",
      "startCol": "18",
      "endLine": "223",
      "endCol": "52"
    },
    "286": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "223",
      "startCol": "25",
      "endLine": "223",
      "endCol": "44"
    },
    "287": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "228",
      "startCol": "7",
      "endLine": "241",
      "endCol": "8"
    },
    "288": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "245",
      "startCol": "7",
      "endLine": "264",
      "endCol": "8"
    },
    "289": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "267",
      "startCol": "7",
      "endLine": "277",
      "endCol": "8"
    },
    "290": {
      "patternID": "pattern3",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "280",
      "startCol": "7",
      "endLine": "292",
      "endCol": "8"
    },
    "291": {
      "patternID": "pattern1",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "309",
      "startCol": "25",
      "endLine": "311",
      "endCol": "3"
    },
    "292": {
      "patternID": "pattern1",
      "file": "extension/js/common/browser/ui.ts",
      "startLine": "319",
      "startCol": "54",
      "endLine": "353",
      "endCol": "3"
    },
    "293": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "85",
      "startCol": "47",
      "endLine": "92",
      "endCol": "3"
    },
    "294": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "131",
      "startCol": "29",
      "endLine": "140",
      "endCol": "3"
    },
    "295": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "145",
      "startCol": "29",
      "endLine": "145",
      "endCol": "52"
    },
    "296": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "208",
      "startCol": "35",
      "endLine": "208",
      "endCol": "43"
    },
    "297": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "218",
      "startCol": "31",
      "endLine": "225",
      "endCol": "3"
    },
    "298": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "246",
      "startCol": "17",
      "endLine": "246",
      "endCol": "51"
    },
    "299": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "248",
      "startCol": "17",
      "endLine": "248",
      "endCol": "51"
    },
    "300": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "250",
      "startCol": "35",
      "endLine": "250",
      "endCol": "73"
    },
    "301": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "264",
      "startCol": "35",
      "endLine": "272",
      "endCol": "3"
    },
    "302": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "306",
      "startCol": "27",
      "endLine": "312",
      "endCol": "3"
    },
    "303": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "314",
      "startCol": "27",
      "endLine": "320",
      "endCol": "3"
    },
    "304": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "322",
      "startCol": "31",
      "endLine": "328",
      "endCol": "3"
    },
    "305": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/key.ts",
      "startLine": "330",
      "startCol": "26",
      "endLine": "336",
      "endCol": "3"
    },
    "306": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "146",
      "startCol": "24",
      "endLine": "149",
      "endCol": "3"
    },
    "307": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "156",
      "startCol": "29",
      "endLine": "156",
      "endCol": "50"
    },
    "308": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "159",
      "startCol": "22",
      "endLine": "159",
      "endCol": "56"
    },
    "309": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "168",
      "startCol": "85",
      "endLine": "168",
      "endCol": "111"
    },
    "310": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "200",
      "startCol": "5",
      "endLine": "200",
      "endCol": "68"
    },
    "311": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "198",
      "startCol": "63",
      "endLine": "203",
      "endCol": "3"
    },
    "312": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "240",
      "startCol": "53",
      "endLine": "240",
      "endCol": "108"
    },
    "313": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "255",
      "startCol": "56",
      "endLine": "265",
      "endCol": "3"
    },
    "314": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "268",
      "startCol": "15",
      "endLine": "268",
      "endCol": "79"
    },
    "315": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "271",
      "startCol": "21",
      "endLine": "271",
      "endCol": "81"
    },
    "316": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "293",
      "startCol": "47",
      "endLine": "293",
      "endCol": "104"
    },
    "317": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/msg-util.ts",
      "startLine": "345",
      "startCol": "34",
      "endLine": "355",
      "endCol": "3"
    },
    "318": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "28",
      "startCol": "20",
      "endLine": "28",
      "endCol": "51"
    },
    "319": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "39",
      "startCol": "31",
      "endLine": "47",
      "endCol": "3"
    },
    "320": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "67",
      "startCol": "9",
      "endLine": "67",
      "endCol": "43"
    },
    "321": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "92",
      "startCol": "5",
      "endLine": "92",
      "endCol": "33"
    },
    "322": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "100",
      "startCol": "12",
      "endLine": "100",
      "endCol": "135"
    },
    "323": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "99",
      "startCol": "34",
      "endLine": "101",
      "endCol": "3"
    },
    "324": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "110",
      "startCol": "38",
      "endLine": "110",
      "endCol": "86"
    },
    "325": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "130",
      "startCol": "20",
      "endLine": "130",
      "endCol": "46"
    },
    "326": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "138",
      "startCol": "47",
      "endLine": "141",
      "endCol": "3"
    },
    "327": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "145",
      "startCol": "21",
      "endLine": "145",
      "endCol": "122"
    },
    "328": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "143",
      "startCol": "31",
      "endLine": "147",
      "endCol": "3"
    },
    "329": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "159",
      "startCol": "13",
      "endLine": "159",
      "endCol": "68"
    },
    "330": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "250",
      "startCol": "21",
      "endLine": "250",
      "endCol": "98"
    },
    "331": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "257",
      "startCol": "12",
      "endLine": "257",
      "endCol": "81"
    },
    "332": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "247",
      "startCol": "24",
      "endLine": "258",
      "endCol": "3"
    },
    "333": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "262",
      "startCol": "11",
      "endLine": "262",
      "endCol": "31"
    },
    "334": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "263",
      "startCol": "13",
      "endLine": "263",
      "endCol": "32"
    },
    "335": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "265",
      "startCol": "25",
      "endLine": "265",
      "endCol": "60"
    },
    "336": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "271",
      "startCol": "14",
      "endLine": "271",
      "endCol": "53"
    },
    "337": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "260",
      "startCol": "26",
      "endLine": "273",
      "endCol": "3"
    },
    "338": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "303",
      "startCol": "18",
      "endLine": "303",
      "endCol": "43"
    },
    "339": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "315",
      "startCol": "11",
      "endLine": "315",
      "endCol": "39"
    },
    "340": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "329",
      "startCol": "7",
      "endLine": "329",
      "endCol": "34"
    },
    "341": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "332",
      "startCol": "107",
      "endLine": "332",
      "endCol": "133"
    },
    "342": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "333",
      "startCol": "109",
      "endLine": "333",
      "endCol": "137"
    },
    "343": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "335",
      "startCol": "5",
      "endLine": "335",
      "endCol": "95"
    },
    "344": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "337",
      "startCol": "70",
      "endLine": "337",
      "endCol": "117"
    },
    "345": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "348",
      "startCol": "9",
      "endLine": "348",
      "endCol": "43"
    },
    "346": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "406",
      "startCol": "15",
      "endLine": "406",
      "endCol": "41"
    },
    "347": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "425",
      "startCol": "28",
      "endLine": "425",
      "endCol": "55"
    },
    "348": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "427",
      "startCol": "29",
      "endLine": "427",
      "endCol": "58"
    },
    "349": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "449",
      "startCol": "38",
      "endLine": "449",
      "endCol": "104"
    },
    "350": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "521",
      "startCol": "25",
      "endLine": "521",
      "endCol": "50"
    },
    "351": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "531",
      "startCol": "5",
      "endLine": "531",
      "endCol": "33"
    },
    "352": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "659",
      "startCol": "28",
      "endLine": "659",
      "endCol": "149"
    },
    "353": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "662",
      "startCol": "30",
      "endLine": "662",
      "endCol": "129"
    },
    "354": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "662",
      "startCol": "60",
      "endLine": "662",
      "endCol": "108"
    },
    "355": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/openpgp-key.ts",
      "startLine": "679",
      "startCol": "29",
      "endLine": "679",
      "endCol": "94"
    },
    "356": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/pgp-armor.ts",
      "startLine": "88",
      "startCol": "55",
      "endLine": "88",
      "endCol": "117"
    },
    "357": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/pgp-armor.ts",
      "startLine": "90",
      "startCol": "23",
      "endLine": "90",
      "endCol": "83"
    },
    "358": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/pgp-armor.ts",
      "startLine": "94",
      "startCol": "56",
      "endLine": "94",
      "endCol": "89"
    },
    "359": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/pgp-armor.ts",
      "startLine": "100",
      "startCol": "21",
      "endLine": "100",
      "endCol": "49"
    },
    "360": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/pgp-hash.ts",
      "startLine": "11",
      "startCol": "40",
      "endLine": "11",
      "endCol": "114"
    },
    "361": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/crypto/pgp/pgp-hash.ts",
      "startLine": "15",
      "startCol": "40",
      "endLine": "15",
      "endCol": "116"
    },
    "362": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/crypto/pgp/pgp-hash.ts",
      "startLine": "22",
      "startCol": "35",
      "endLine": "24",
      "endCol": "3"
    },
    "363": {
      "patternID": "pattern1",
      "file": "extension/js/common/core/mime.ts",
      "startLine": "147",
      "startCol": "26",
      "endLine": "197",
      "endCol": "3"
    },
    "364": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/mime.ts",
      "startLine": "266",
      "startCol": "27",
      "endLine": "266",
      "endCol": "54"
    },
    "365": {
      "patternID": "pattern3",
      "file": "extension/js/common/core/stream.ts",
      "startLine": "7",
      "startCol": "5",
      "endLine": "7",
      "endCol": "25"
    },
    "366": {
      "patternID": "pattern3",
      "file": "extension/js/common/platform/catch.ts",
      "startLine": "239",
      "startCol": "7",
      "endLine": "239",
      "endCol": "13"
    },
    "367": {
      "patternID": "pattern3",
      "file": "extension/js/common/platform/catch.ts",
      "startLine": "251",
      "startCol": "14",
      "endLine": "251",
      "endCol": "20"
    },
    "368": {
      "patternID": "pattern1",
      "file": "extension/js/common/platform/catch.ts",
      "startLine": "249",
      "startCol": "40",
      "endLine": "255",
      "endCol": "3"
    },
    "369": {
      "patternID": "pattern1",
      "file": "extension/js/common/platform/store/acct-store.ts",
      "startLine": "82",
      "startCol": "23",
      "endLine": "101",
      "endCol": "3"
    },
    "370": {
      "patternID": "pattern1",
      "file": "extension/js/common/platform/store/acct-store.ts",
      "startLine": "112",
      "startCol": "23",
      "endLine": "134",
      "endCol": "3"
    },
    "371": {
      "patternID": "pattern1",
      "file": "extension/js/common/platform/store/contact-store.ts",
      "startLine": "80",
      "startCol": "26",
      "endLine": "109",
      "endCol": "3"
    },
    "372": {
      "patternID": "pattern3",
      "file": "extension/js/common/platform/store/contact-store.ts",
      "startLine": "173",
      "startCol": "7",
      "endLine": "173",
      "endCol": "85"
    },
    "373": {
      "patternID": "pattern3",
      "file": "extension/js/common/platform/store/contact-store.ts",
      "startLine": "203",
      "startCol": "7",
      "endLine": "203",
      "endCol": "89"
    },
    "374": {
      "patternID": "pattern1",
      "file": "extension/js/common/platform/store/contact-store.ts",
      "startLine": "446",
      "startCol": "35",
      "endLine": "454",
      "endCol": "3"
    },
    "375": {
      "patternID": "pattern3",
      "file": "extension/js/common/platform/store/contact-store.ts",
      "startLine": "554",
      "startCol": "22",
      "endLine": "565",
      "endCol": "9"
    },
    "376": {
      "patternID": "pattern1",
      "file": "extension/js/common/platform/store/contact-store.ts",
      "startLine": "547",
      "startCol": "44",
      "endLine": "600",
      "endCol": "3"
    },
    "377": {
      "patternID": "pattern1",
      "file": "extension/js/common/platform/store/global-store.ts",
      "startLine": "35",
      "startCol": "23",
      "endLine": "47",
      "endCol": "3"
    },
    "378": {
      "patternID": "pattern1",
      "file": "extension/js/common/platform/store/global-store.ts",
      "startLine": "49",
      "startCol": "23",
      "endLine": "57",
      "endCol": "3"
    },
    "379": {
      "patternID": "pattern3",
      "file": "extension/js/common/platform/store/passphrase-store.ts",
      "startLine": "56",
      "startCol": "25",
      "endLine": "56",
      "endCol": "123"
    },
    "380": {
      "patternID": "pattern3",
      "file": "extension/js/common/platform/store/passphrase-store.ts",
      "startLine": "63",
      "startCol": "28",
      "endLine": "63",
      "endCol": "116"
    },
    "381": {
      "patternID": "pattern1",
      "file": "extension/js/common/platform/store/session-store.ts",
      "startLine": "12",
      "startCol": "23",
      "endLine": "19",
      "endCol": "3"
    },
    "382": {
      "patternID": "pattern1",
      "file": "extension/js/common/platform/store/session-store.ts",
      "startLine": "21",
      "startCol": "23",
      "endLine": "32",
      "endCol": "3"
    },
    "383": {
      "patternID": "pattern1",
      "file": "extension/js/common/settings.ts",
      "startLine": "71",
      "startCol": "36",
      "endLine": "104",
      "endCol": "3"
    },
    "384": {
      "patternID": "pattern1",
      "file": "extension/js/common/settings.ts",
      "startLine": "155",
      "startCol": "65",
      "endLine": "222",
      "endCol": "3"
    },
    "385": {
      "patternID": "pattern3",
      "file": "extension/js/common/settings.ts",
      "startLine": "226",
      "startCol": "7",
      "endLine": "226",
      "endCol": "20"
    },
    "386": {
      "patternID": "pattern1",
      "file": "extension/js/common/settings.ts",
      "startLine": "224",
      "startCol": "40",
      "endLine": "230",
      "endCol": "3"
    },
    "387": {
      "patternID": "pattern3",
      "file": "extension/js/common/settings.ts",
      "startLine": "243",
      "startCol": "16",
      "endLine": "243",
      "endCol": "30"
    },
    "388": {
      "patternID": "pattern1",
      "file": "extension/js/common/settings.ts",
      "startLine": "235",
      "startCol": "33",
      "endLine": "255",
      "endCol": "3"
    },
    "389": {
      "patternID": "pattern3",
      "file": "extension/js/common/settings.ts",
      "startLine": "254",
      "startCol": "12",
      "endLine": "254",
      "endCol": "26"
    },
    "390": {
      "patternID": "pattern3",
      "file": "extension/js/common/ui/attachment-ui.ts",
      "startLine": "117",
      "startCol": "20",
      "endLine": "117",
      "endCol": "41"
    },
    "391": {
      "patternID": "pattern3",
      "file": "extension/js/common/ui/attachment-ui.ts",
      "startLine": "127",
      "startCol": "9",
      "endLine": "127",
      "endCol": "67"
    },
    "392": {
      "patternID": "pattern3",
      "file": "extension/js/common/ui/attachment-ui.ts",
      "startLine": "136",
      "startCol": "7",
      "endLine": "136",
      "endCol": "45"
    },
    "393": {
      "patternID": "pattern1",
      "file": "extension/js/common/ui/attachment-ui.ts",
      "startLine": "156",
      "startCol": "39",
      "endLine": "164",
      "endCol": "3"
    },
    "394": {
      "patternID": "pattern3",
      "file": "extension/js/common/ui/attachment_preview_pdf.ts",
      "startLine": "61",
      "startCol": "18",
      "endLine": "61",
      "endCol": "46"
    },
    "395": {
      "patternID": "pattern3",
      "file": "extension/js/common/ui/attachment_preview_pdf.ts",
      "startLine": "65",
      "startCol": "5",
      "endLine": "65",
      "endCol": "111"
    },
    "396": {
      "patternID": "pattern1",
      "file": "extension/js/common/ui/fetch-key-ui.ts",
      "startLine": "27",
      "startCol": "25",
      "endLine": "36",
      "endCol": "3"
    },
    "397": {
      "patternID": "pattern3",
      "file": "extension/js/common/ui/key-import-ui.ts",
      "startLine": "83",
      "startCol": "31",
      "endLine": "83",
      "endCol": "81"
    },
    "398": {
      "patternID": "pattern3",
      "file": "extension/js/content_scripts/webmail/setup-webmail-content-script.ts",
      "startLine": "224",
      "startCol": "7",
      "endLine": "224",
      "endCol": "92"
    },
    "399": {
      "patternID": "pattern3",
      "file": "extension/js/content_scripts/webmail/webmail.ts",
      "startLine": "95",
      "startCol": "7",
      "endLine": "95",
      "endCol": "48"
    },
    "400": {
      "patternID": "pattern3",
      "file": "test/debug/puppeteer_cannot_access_iframes/ext-frame-online.js",
      "startLine": "8",
      "startCol": "13",
      "endLine": "16",
      "endCol": "4"
    },
    "401": {
      "patternID": "pattern3",
      "file": "test/debug/puppeteer_cannot_access_iframes/ext-frame-online.js",
      "startLine": "18",
      "startCol": "14",
      "endLine": "18",
      "endCol": "36"
    },
    "402": {
      "patternID": "pattern3",
      "file": "test/debug/puppeteer_cannot_access_iframes/ext-frame-online.js",
      "startLine": "19",
      "startCol": "3",
      "endLine": "19",
      "endCol": "43"
    },
    "403": {
      "patternID": "pattern3",
      "file": "test/debug/puppeteer_cannot_access_iframes/ext-frame-online.js",
      "startLine": "21",
      "startCol": "3",
      "endLine": "21",
      "endCol": "72"
    },
    "404": {
      "patternID": "pattern3",
      "file": "test/debug/puppeteer_cannot_access_iframes/ext-frame-online.js",
      "startLine": "22",
      "startCol": "22",
      "endLine": "22",
      "endCol": "43"
    },
    "405": {
      "patternID": "pattern3",
      "file": "test/debug/puppeteer_cannot_access_iframes/ext-frame-online.js",
      "startLine": "23",
      "startCol": "19",
      "endLine": "23",
      "endCol": "75"
    },
    "406": {
      "patternID": "pattern3",
      "file": "test/debug/puppeteer_cannot_access_iframes/ext-frame-online.js",
      "startLine": "23",
      "startCol": "26",
      "endLine": "23",
      "endCol": "62"
    },
    "407": {
      "patternID": "pattern3",
      "file": "test/debug/puppeteer_cannot_access_iframes/ext-frame-online.js",
      "startLine": "25",
      "startCol": "16",
      "endLine": "25",
      "endCol": "34"
    },
    "408": {
      "patternID": "pattern1",
      "file": "test/source/async-stack.ts",
      "startLine": "21",
      "startCol": "12",
      "endLine": "21",
      "endCol": "35"
    },
    "409": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "24",
      "startCol": "18",
      "endLine": "24",
      "endCol": "45"
    },
    "410": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "25",
      "startCol": "5",
      "endLine": "25",
      "endCol": "41"
    },
    "411": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "29",
      "startCol": "9",
      "endLine": "29",
      "endCol": "55"
    },
    "412": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "45",
      "startCol": "7",
      "endLine": "45",
      "endCol": "43"
    },
    "413": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "61",
      "startCol": "24",
      "endLine": "61",
      "endCol": "49"
    },
    "414": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "63",
      "startCol": "9",
      "endLine": "63",
      "endCol": "26"
    },
    "415": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "70",
      "startCol": "5",
      "endLine": "70",
      "endCol": "30"
    },
    "416": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "82",
      "startCol": "19",
      "endLine": "82",
      "endCol": "158"
    },
    "417": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "83",
      "startCol": "27",
      "endLine": "83",
      "endCol": "66"
    },
    "418": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "91",
      "startCol": "54",
      "endLine": "91",
      "endCol": "77"
    },
    "419": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-handle.ts",
      "startLine": "96",
      "startCol": "79",
      "endLine": "96",
      "endCol": "96"
    },
    "420": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "46",
      "startCol": "21",
      "endLine": "46",
      "endCol": "116"
    },
    "421": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "55",
      "startCol": "25",
      "endLine": "55",
      "endCol": "52"
    },
    "422": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "60",
      "startCol": "11",
      "endLine": "60",
      "endCol": "35"
    },
    "423": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "73",
      "startCol": "21",
      "endLine": "73",
      "endCol": "49"
    },
    "424": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "94",
      "startCol": "7",
      "endLine": "94",
      "endCol": "48"
    },
    "425": {
      "patternID": "pattern1",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "98",
      "startCol": "31",
      "endLine": "104",
      "endCol": "3"
    },
    "426": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "119",
      "startCol": "7",
      "endLine": "119",
      "endCol": "26"
    },
    "427": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "141",
      "startCol": "25",
      "endLine": "141",
      "endCol": "68"
    },
    "428": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "143",
      "startCol": "11",
      "endLine": "143",
      "endCol": "109"
    },
    "429": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "143",
      "startCol": "61",
      "endLine": "143",
      "endCol": "80"
    },
    "430": {
      "patternID": "pattern1",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "143",
      "startCol": "49",
      "endLine": "143",
      "endCol": "80"
    },
    "431": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "154",
      "startCol": "11",
      "endLine": "154",
      "endCol": "31"
    },
    "432": {
      "patternID": "pattern3",
      "file": "test/source/browser/browser-pool.ts",
      "startLine": "180",
      "startCol": "11",
      "endLine": "180",
      "endCol": "53"
    },
    "433": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "53",
      "startCol": "9",
      "endLine": "53",
      "endCol": "86"
    },
    "434": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "57",
      "startCol": "9",
      "endLine": "57",
      "endCol": "89"
    },
    "435": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "70",
      "startCol": "28",
      "endLine": "70",
      "endCol": "111"
    },
    "436": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "72",
      "startCol": "18",
      "endLine": "72",
      "endCol": "44"
    },
    "437": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "103",
      "startCol": "23",
      "endLine": "105",
      "endCol": "3"
    },
    "438": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "111",
      "startCol": "29",
      "endLine": "111",
      "endCol": "90"
    },
    "439": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "132",
      "startCol": "7",
      "endLine": "132",
      "endCol": "21"
    },
    "440": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "149",
      "startCol": "7",
      "endLine": "149",
      "endCol": "24"
    },
    "441": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "151",
      "startCol": "32",
      "endLine": "165",
      "endCol": "39"
    },
    "442": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "167",
      "startCol": "9",
      "endLine": "167",
      "endCol": "66"
    },
    "443": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "173",
      "startCol": "12",
      "endLine": "176",
      "endCol": "37"
    },
    "444": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "172",
      "startCol": "17",
      "endLine": "177",
      "endCol": "3"
    },
    "445": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "181",
      "startCol": "12",
      "endLine": "188",
      "endCol": "31"
    },
    "446": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "179",
      "startCol": "18",
      "endLine": "189",
      "endCol": "3"
    },
    "447": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "192",
      "startCol": "12",
      "endLine": "192",
      "endCol": "105"
    },
    "448": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "191",
      "startCol": "23",
      "endLine": "193",
      "endCol": "3"
    },
    "449": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "196",
      "startCol": "12",
      "endLine": "196",
      "endCol": "104"
    },
    "450": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "195",
      "startCol": "22",
      "endLine": "197",
      "endCol": "3"
    },
    "451": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "200",
      "startCol": "23",
      "endLine": "200",
      "endCol": "117"
    },
    "452": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "206",
      "startCol": "12",
      "endLine": "212",
      "endCol": "31"
    },
    "453": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "205",
      "startCol": "27",
      "endLine": "213",
      "endCol": "3"
    },
    "454": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "218",
      "startCol": "14",
      "endLine": "218",
      "endCol": "163"
    },
    "455": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "215",
      "startCol": "17",
      "endLine": "222",
      "endCol": "3"
    },
    "456": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "220",
      "startCol": "14",
      "endLine": "220",
      "endCol": "93"
    },
    "457": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "225",
      "startCol": "12",
      "endLine": "225",
      "endCol": "106"
    },
    "458": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "224",
      "startCol": "21",
      "endLine": "226",
      "endCol": "3"
    },
    "459": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "230",
      "startCol": "5",
      "endLine": "230",
      "endCol": "109"
    },
    "460": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "241",
      "startCol": "5",
      "endLine": "241",
      "endCol": "52"
    },
    "461": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "340",
      "startCol": "26",
      "endLine": "355",
      "endCol": "3"
    },
    "462": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "365",
      "startCol": "18",
      "endLine": "365",
      "endCol": "53"
    },
    "463": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "367",
      "startCol": "18",
      "endLine": "367",
      "endCol": "59"
    },
    "464": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "391",
      "startCol": "7",
      "endLine": "391",
      "endCol": "110"
    },
    "465": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "395",
      "startCol": "9",
      "endLine": "395",
      "endCol": "24"
    },
    "466": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "401",
      "startCol": "12",
      "endLine": "401",
      "endCol": "63"
    },
    "467": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "387",
      "startCol": "45",
      "endLine": "402",
      "endCol": "3"
    },
    "468": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "438",
      "startCol": "15",
      "endLine": "438",
      "endCol": "44"
    },
    "469": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "440",
      "startCol": "14",
      "endLine": "440",
      "endCol": "42"
    },
    "470": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "435",
      "startCol": "23",
      "endLine": "442",
      "endCol": "3"
    },
    "471": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "450",
      "startCol": "26",
      "endLine": "450",
      "endCol": "55"
    },
    "472": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "452",
      "startCol": "26",
      "endLine": "452",
      "endCol": "51"
    },
    "473": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "481",
      "startCol": "5",
      "endLine": "481",
      "endCol": "30"
    },
    "474": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "486",
      "startCol": "5",
      "endLine": "486",
      "endCol": "31"
    },
    "475": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "540",
      "startCol": "32",
      "endLine": "547",
      "endCol": "3"
    },
    "476": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "551",
      "startCol": "7",
      "endLine": "551",
      "endCol": "68"
    },
    "477": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "565",
      "startCol": "5",
      "endLine": "568",
      "endCol": "6"
    },
    "478": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "576",
      "startCol": "7",
      "endLine": "576",
      "endCol": "29"
    },
    "479": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "582",
      "startCol": "7",
      "endLine": "582",
      "endCol": "41"
    },
    "480": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "588",
      "startCol": "12",
      "endLine": "591",
      "endCol": "6"
    },
    "481": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "586",
      "startCol": "23",
      "endLine": "592",
      "endCol": "3"
    },
    "482": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "596",
      "startCol": "12",
      "endLine": "596",
      "endCol": "91"
    },
    "483": {
      "patternID": "pattern1",
      "file": "test/source/browser/controllable.ts",
      "startLine": "594",
      "startCol": "17",
      "endLine": "597",
      "endCol": "3"
    },
    "484": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "616",
      "startCol": "38",
      "endLine": "616",
      "endCol": "161"
    },
    "485": {
      "patternID": "pattern3",
      "file": "test/source/browser/controllable.ts",
      "startLine": "648",
      "startCol": "9",
      "endLine": "648",
      "endCol": "85"
    },
    "486": {
      "patternID": "pattern1",
      "file": "test/source/mock/attester/attester-endpoints.ts",
      "startLine": "41",
      "startCol": "22",
      "endLine": "87",
      "endCol": "3"
    },
    "487": {
      "patternID": "pattern3",
      "file": "test/source/mock/google/google-data.ts",
      "startLine": "118",
      "startCol": "21",
      "endLine": "118",
      "endCol": "51"
    },
    "488": {
      "patternID": "pattern3",
      "file": "test/source/mock/google/strategies/send-message-strategy.ts",
      "startLine": "37",
      "startCol": "23",
      "endLine": "37",
      "endCol": "126"
    },
    "489": {
      "patternID": "pattern3",
      "file": "test/source/mock/google/strategies/send-message-strategy.ts",
      "startLine": "54",
      "startCol": "23",
      "endLine": "54",
      "endCol": "121"
    },
    "490": {
      "patternID": "pattern3",
      "file": "test/source/mock/google/strategies/send-message-strategy.ts",
      "startLine": "97",
      "startCol": "23",
      "endLine": "97",
      "endCol": "121"
    },
    "491": {
      "patternID": "pattern3",
      "file": "test/source/mock/key-manager/key-manager-endpoints.ts",
      "startLine": "232",
      "startCol": "21",
      "endLine": "232",
      "endCol": "64"
    },
    "492": {
      "patternID": "pattern3",
      "file": "test/source/mock/key-manager/key-manager-endpoints.ts",
      "startLine": "240",
      "startCol": "21",
      "endLine": "240",
      "endCol": "54"
    },
    "493": {
      "patternID": "pattern3",
      "file": "test/source/mock/key-manager/key-manager-endpoints.ts",
      "startLine": "258",
      "startCol": "21",
      "endLine": "258",
      "endCol": "64"
    },
    "494": {
      "patternID": "pattern3",
      "file": "test/source/mock/key-manager/key-manager-endpoints.ts",
      "startLine": "266",
      "startCol": "21",
      "endLine": "266",
      "endCol": "54"
    },
    "495": {
      "patternID": "pattern3",
      "file": "test/source/mock/key-manager/key-manager-endpoints.ts",
      "startLine": "286",
      "startCol": "37",
      "endLine": "286",
      "endCol": "95"
    },
    "496": {
      "patternID": "pattern3",
      "file": "test/source/mock/key-manager/key-manager-endpoints.ts",
      "startLine": "286",
      "startCol": "63",
      "endLine": "286",
      "endCol": "94"
    },
    "497": {
      "patternID": "pattern3",
      "file": "test/source/mock/lib/api.ts",
      "startLine": "121",
      "startCol": "33",
      "endLine": "121",
      "endCol": "102"
    },
    "498": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "106",
      "startCol": "17",
      "endLine": "106",
      "endCol": "121"
    },
    "499": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "106",
      "startCol": "43",
      "endLine": "106",
      "endCol": "120"
    },
    "500": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "107",
      "startCol": "25",
      "endLine": "107",
      "endCol": "66"
    },
    "501": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "110",
      "startCol": "25",
      "endLine": "110",
      "endCol": "56"
    },
    "502": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "113",
      "startCol": "25",
      "endLine": "113",
      "endCol": "56"
    },
    "503": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "116",
      "startCol": "25",
      "endLine": "116",
      "endCol": "60"
    },
    "504": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "119",
      "startCol": "25",
      "endLine": "119",
      "endCol": "55"
    },
    "505": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "122",
      "startCol": "25",
      "endLine": "122",
      "endCol": "55"
    },
    "506": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "125",
      "startCol": "25",
      "endLine": "125",
      "endCol": "53"
    },
    "507": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "129",
      "startCol": "11",
      "endLine": "129",
      "endCol": "67"
    },
    "508": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "130",
      "startCol": "11",
      "endLine": "130",
      "endCol": "64"
    },
    "509": {
      "patternID": "pattern3",
      "file": "test/source/mock/wkd/wkd-endpoints.ts",
      "startLine": "131",
      "startCol": "11",
      "endLine": "131",
      "endCol": "67"
    },
    "510": {
      "patternID": "pattern1",
      "file": "test/source/mock.ts",
      "startLine": "5",
      "startCol": "21",
      "endLine": "7",
      "endCol": "1"
    },
    "511": {
      "patternID": "pattern3",
      "file": "test/source/platform/catch.ts",
      "startLine": "29",
      "startCol": "7",
      "endLine": "29",
      "endCol": "13"
    },
    "512": {
      "patternID": "pattern3",
      "file": "test/source/platform/catch.ts",
      "startLine": "41",
      "startCol": "14",
      "endLine": "41",
      "endCol": "20"
    },
    "513": {
      "patternID": "pattern1",
      "file": "test/source/platform/catch.ts",
      "startLine": "39",
      "startCol": "40",
      "endLine": "45",
      "endCol": "3"
    },
    "514": {
      "patternID": "pattern3",
      "file": "test/source/platform/store/contact-store.ts",
      "startLine": "27",
      "startCol": "7",
      "endLine": "27",
      "endCol": "89"
    },
    "515": {
      "patternID": "pattern3",
      "file": "test/source/platform/store/contact-store.ts",
      "startLine": "36",
      "startCol": "23",
      "endLine": "36",
      "endCol": "62"
    },
    "516": {
      "patternID": "pattern3",
      "file": "test/source/platform/store/contact-store.ts",
      "startLine": "43",
      "startCol": "55",
      "endLine": "43",
      "endCol": "88"
    },
    "517": {
      "patternID": "pattern3",
      "file": "test/source/platform/store/contact-store.ts",
      "startLine": "65",
      "startCol": "16",
      "endLine": "65",
      "endCol": "42"
    },
    "518": {
      "patternID": "pattern3",
      "file": "test/source/test.ts",
      "startLine": "75",
      "startCol": "7",
      "endLine": "75",
      "endCol": "26"
    },
    "519": {
      "patternID": "pattern3",
      "file": "test/source/test.ts",
      "startLine": "78",
      "startCol": "24",
      "endLine": "78",
      "endCol": "98"
    },
    "520": {
      "patternID": "pattern3",
      "file": "test/source/test.ts",
      "startLine": "79",
      "startCol": "25",
      "endLine": "79",
      "endCol": "94"
    },
    "521": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-AttUI.js",
      "startLine": "39",
      "startCol": "34",
      "endLine": "39",
      "endCol": "60"
    },
    "522": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-AttUI.js",
      "startLine": "41",
      "startCol": "17",
      "endLine": "41",
      "endCol": "76"
    },
    "523": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "27",
      "startCol": "25",
      "endLine": "29",
      "endCol": "4"
    },
    "524": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "30",
      "startCol": "25",
      "endLine": "32",
      "endCol": "4"
    },
    "525": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "33",
      "startCol": "25",
      "endLine": "35",
      "endCol": "4"
    },
    "526": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "36",
      "startCol": "25",
      "endLine": "38",
      "endCol": "4"
    },
    "527": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "39",
      "startCol": "36",
      "endLine": "41",
      "endCol": "4"
    },
    "528": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "42",
      "startCol": "3",
      "endLine": "43",
      "endCol": "30"
    },
    "529": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "44",
      "startCol": "23",
      "endLine": "44",
      "endCol": "94"
    },
    "530": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "48",
      "startCol": "24",
      "endLine": "48",
      "endCol": "96"
    },
    "531": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "52",
      "startCol": "25",
      "endLine": "52",
      "endCol": "98"
    },
    "532": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "59",
      "startCol": "23",
      "endLine": "59",
      "endCol": "94"
    },
    "533": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "63",
      "startCol": "23",
      "endLine": "63",
      "endCol": "94"
    },
    "534": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "72",
      "startCol": "14",
      "endLine": "72",
      "endCol": "40"
    },
    "535": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "73",
      "startCol": "19",
      "endLine": "75",
      "endCol": "4"
    },
    "536": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "76",
      "startCol": "3",
      "endLine": "76",
      "endCol": "38"
    },
    "537": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "90",
      "startCol": "14",
      "endLine": "90",
      "endCol": "40"
    },
    "538": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "91",
      "startCol": "19",
      "endLine": "93",
      "endCol": "4"
    },
    "539": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "94",
      "startCol": "3",
      "endLine": "94",
      "endCol": "38"
    },
    "540": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "109",
      "startCol": "14",
      "endLine": "109",
      "endCol": "40"
    },
    "541": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "113",
      "startCol": "5",
      "endLine": "116",
      "endCol": "6"
    },
    "542": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "117",
      "startCol": "5",
      "endLine": "121",
      "endCol": "6"
    },
    "543": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "122",
      "startCol": "3",
      "endLine": "122",
      "endCol": "39"
    },
    "544": {
      "patternID": "pattern1",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "126",
      "startCol": "21",
      "endLine": "131",
      "endCol": "3"
    },
    "545": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "146",
      "startCol": "19",
      "endLine": "146",
      "endCol": "100"
    },
    "546": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "147",
      "startCol": "19",
      "endLine": "147",
      "endCol": "100"
    },
    "547": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "150",
      "startCol": "3",
      "endLine": "150",
      "endCol": "85"
    },
    "548": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "162",
      "startCol": "3",
      "endLine": "162",
      "endCol": "87"
    },
    "549": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "163",
      "startCol": "3",
      "endLine": "163",
      "endCol": "85"
    },
    "550": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "174",
      "startCol": "3",
      "endLine": "174",
      "endCol": "61"
    },
    "551": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "189",
      "startCol": "14",
      "endLine": "189",
      "endCol": "40"
    },
    "552": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "193",
      "startCol": "5",
      "endLine": "193",
      "endCol": "45"
    },
    "553": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "194",
      "startCol": "5",
      "endLine": "194",
      "endCol": "45"
    },
    "554": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "195",
      "startCol": "3",
      "endLine": "195",
      "endCol": "39"
    },
    "555": {
      "patternID": "pattern1",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "206",
      "startCol": "21",
      "endLine": "211",
      "endCol": "3"
    },
    "556": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "227",
      "startCol": "3",
      "endLine": "227",
      "endCol": "68"
    },
    "557": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "229",
      "startCol": "3",
      "endLine": "229",
      "endCol": "60"
    },
    "558": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "233",
      "startCol": "3",
      "endLine": "233",
      "endCol": "58"
    },
    "559": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "235",
      "startCol": "3",
      "endLine": "235",
      "endCol": "63"
    },
    "560": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "246",
      "startCol": "19",
      "endLine": "246",
      "endCol": "105"
    },
    "561": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "247",
      "startCol": "3",
      "endLine": "247",
      "endCol": "47"
    },
    "562": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "248",
      "startCol": "20",
      "endLine": "248",
      "endCol": "61"
    },
    "563": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "263",
      "startCol": "25",
      "endLine": "265",
      "endCol": "4"
    },
    "564": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "266",
      "startCol": "25",
      "endLine": "268",
      "endCol": "4"
    },
    "565": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "269",
      "startCol": "25",
      "endLine": "271",
      "endCol": "4"
    },
    "566": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "272",
      "startCol": "25",
      "endLine": "274",
      "endCol": "4"
    },
    "567": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "275",
      "startCol": "3",
      "endLine": "275",
      "endCol": "98"
    },
    "568": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "276",
      "startCol": "35",
      "endLine": "276",
      "endCol": "89"
    },
    "569": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "283",
      "startCol": "34",
      "endLine": "283",
      "endCol": "88"
    },
    "570": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "291",
      "startCol": "35",
      "endLine": "291",
      "endCol": "89"
    },
    "571": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "298",
      "startCol": "34",
      "endLine": "298",
      "endCol": "88"
    },
    "572": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "306",
      "startCol": "35",
      "endLine": "306",
      "endCol": "89"
    },
    "573": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "313",
      "startCol": "34",
      "endLine": "313",
      "endCol": "88"
    },
    "574": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "321",
      "startCol": "35",
      "endLine": "321",
      "endCol": "89"
    },
    "575": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "328",
      "startCol": "34",
      "endLine": "328",
      "endCol": "88"
    },
    "576": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "342",
      "startCol": "3",
      "endLine": "342",
      "endCol": "136"
    },
    "577": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "342",
      "startCol": "80",
      "endLine": "342",
      "endCol": "133"
    },
    "578": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "343",
      "startCol": "3",
      "endLine": "343",
      "endCol": "133"
    },
    "579": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "343",
      "startCol": "80",
      "endLine": "343",
      "endCol": "130"
    },
    "580": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "344",
      "startCol": "3",
      "endLine": "344",
      "endCol": "136"
    },
    "581": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "344",
      "startCol": "80",
      "endLine": "344",
      "endCol": "133"
    },
    "582": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "346",
      "startCol": "27",
      "endLine": "346",
      "endCol": "91"
    },
    "583": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "350",
      "startCol": "30",
      "endLine": "350",
      "endCol": "84"
    },
    "584": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "354",
      "startCol": "30",
      "endLine": "354",
      "endCol": "84"
    },
    "585": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "363",
      "startCol": "14",
      "endLine": "363",
      "endCol": "40"
    },
    "586": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "366",
      "startCol": "5",
      "endLine": "369",
      "endCol": "6"
    },
    "587": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "370",
      "startCol": "3",
      "endLine": "370",
      "endCol": "39"
    },
    "588": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "384",
      "startCol": "29",
      "endLine": "384",
      "endCol": "64"
    },
    "589": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "388",
      "startCol": "28",
      "endLine": "388",
      "endCol": "62"
    },
    "590": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "397",
      "startCol": "14",
      "endLine": "397",
      "endCol": "40"
    },
    "591": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "400",
      "startCol": "21",
      "endLine": "400",
      "endCol": "61"
    },
    "592": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "401",
      "startCol": "3",
      "endLine": "401",
      "endCol": "39"
    },
    "593": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "416",
      "startCol": "21",
      "endLine": "416",
      "endCol": "77"
    },
    "594": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "428",
      "startCol": "14",
      "endLine": "428",
      "endCol": "40"
    },
    "595": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "429",
      "startCol": "30",
      "endLine": "429",
      "endCol": "80"
    },
    "596": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "434",
      "startCol": "3",
      "endLine": "434",
      "endCol": "93"
    },
    "597": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "435",
      "startCol": "28",
      "endLine": "435",
      "endCol": "85"
    },
    "598": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "439",
      "startCol": "28",
      "endLine": "439",
      "endCol": "75"
    },
    "599": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "450",
      "startCol": "28",
      "endLine": "450",
      "endCol": "85"
    },
    "600": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "454",
      "startCol": "28",
      "endLine": "454",
      "endCol": "75"
    },
    "601": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "463",
      "startCol": "14",
      "endLine": "463",
      "endCol": "40"
    },
    "602": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "464",
      "startCol": "20",
      "endLine": "464",
      "endCol": "63"
    },
    "603": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "465",
      "startCol": "3",
      "endLine": "465",
      "endCol": "80"
    },
    "604": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "466",
      "startCol": "25",
      "endLine": "466",
      "endCol": "79"
    },
    "605": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "471",
      "startCol": "25",
      "endLine": "471",
      "endCol": "60"
    },
    "606": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "482",
      "startCol": "25",
      "endLine": "482",
      "endCol": "79"
    },
    "607": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "486",
      "startCol": "25",
      "endLine": "486",
      "endCol": "60"
    },
    "608": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "495",
      "startCol": "14",
      "endLine": "495",
      "endCol": "40"
    },
    "609": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "496",
      "startCol": "30",
      "endLine": "496",
      "endCol": "80"
    },
    "610": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "501",
      "startCol": "26",
      "endLine": "501",
      "endCol": "86"
    },
    "611": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "505",
      "startCol": "3",
      "endLine": "505",
      "endCol": "93"
    },
    "612": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "506",
      "startCol": "28",
      "endLine": "506",
      "endCol": "85"
    },
    "613": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "510",
      "startCol": "28",
      "endLine": "510",
      "endCol": "75"
    },
    "614": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "514",
      "startCol": "3",
      "endLine": "514",
      "endCol": "89"
    },
    "615": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "515",
      "startCol": "28",
      "endLine": "515",
      "endCol": "85"
    },
    "616": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "519",
      "startCol": "28",
      "endLine": "519",
      "endCol": "75"
    },
    "617": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "523",
      "startCol": "3",
      "endLine": "523",
      "endCol": "93"
    },
    "618": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "524",
      "startCol": "28",
      "endLine": "524",
      "endCol": "85"
    },
    "619": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "528",
      "startCol": "28",
      "endLine": "528",
      "endCol": "75"
    },
    "620": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "537",
      "startCol": "14",
      "endLine": "537",
      "endCol": "40"
    },
    "621": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "538",
      "startCol": "25",
      "endLine": "540",
      "endCol": "4"
    },
    "622": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "541",
      "startCol": "25",
      "endLine": "543",
      "endCol": "4"
    },
    "623": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "544",
      "startCol": "25",
      "endLine": "546",
      "endCol": "4"
    },
    "624": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "547",
      "startCol": "25",
      "endLine": "549",
      "endCol": "4"
    },
    "625": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "550",
      "startCol": "3",
      "endLine": "550",
      "endCol": "91"
    },
    "626": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "551",
      "startCol": "21",
      "endLine": "551",
      "endCol": "74"
    },
    "627": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "552",
      "startCol": "25",
      "endLine": "552",
      "endCol": "97"
    },
    "628": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "552",
      "startCol": "72",
      "endLine": "552",
      "endCol": "95"
    },
    "629": {
      "patternID": "pattern1",
      "file": "test/source/tests/browser-unit-tests/unit-ContactStore.js",
      "startLine": "552",
      "startCol": "57",
      "endLine": "552",
      "endCol": "95"
    },
    "630": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Mime.js",
      "startLine": "297",
      "startCol": "19",
      "endLine": "297",
      "endCol": "98"
    },
    "631": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Mime.js",
      "startLine": "306",
      "startCol": "19",
      "endLine": "306",
      "endCol": "44"
    },
    "632": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Mime.js",
      "startLine": "325",
      "startCol": "19",
      "endLine": "325",
      "endCol": "98"
    },
    "633": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Mime.js",
      "startLine": "326",
      "startCol": "19",
      "endLine": "326",
      "endCol": "44"
    },
    "634": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Sks.js",
      "startLine": "27",
      "startCol": "22",
      "endLine": "27",
      "endCol": "49"
    },
    "635": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Sks.js",
      "startLine": "28",
      "startCol": "15",
      "endLine": "28",
      "endCol": "41"
    },
    "636": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Sks.js",
      "startLine": "39",
      "startCol": "22",
      "endLine": "39",
      "endCol": "49"
    },
    "637": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Sks.js",
      "startLine": "40",
      "startCol": "15",
      "endLine": "40",
      "endCol": "41"
    },
    "638": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Sks.js",
      "startLine": "52",
      "startCol": "5",
      "endLine": "52",
      "endCol": "32"
    },
    "639": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Sks.js",
      "startLine": "66",
      "startCol": "22",
      "endLine": "66",
      "endCol": "49"
    },
    "640": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Sks.js",
      "startLine": "78",
      "startCol": "22",
      "endLine": "78",
      "endCol": "49"
    },
    "641": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Sks.js",
      "startLine": "79",
      "startCol": "15",
      "endLine": "79",
      "endCol": "41"
    },
    "642": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Wkd.js",
      "startLine": "29",
      "startCol": "9",
      "endLine": "29",
      "endCol": "36"
    },
    "643": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Wkd.js",
      "startLine": "33",
      "startCol": "9",
      "endLine": "33",
      "endCol": "36"
    },
    "644": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Wkd.js",
      "startLine": "45",
      "startCol": "9",
      "endLine": "45",
      "endCol": "36"
    },
    "645": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Wkd.js",
      "startLine": "49",
      "startCol": "9",
      "endLine": "49",
      "endCol": "36"
    },
    "646": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Wkd.js",
      "startLine": "60",
      "startCol": "20",
      "endLine": "60",
      "endCol": "47"
    },
    "647": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Wkd.js",
      "startLine": "64",
      "startCol": "16",
      "endLine": "64",
      "endCol": "91"
    },
    "648": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Wkd.js",
      "startLine": "64",
      "startCol": "63",
      "endLine": "64",
      "endCol": "89"
    },
    "649": {
      "patternID": "pattern1",
      "file": "test/source/tests/browser-unit-tests/unit-Wkd.js",
      "startLine": "64",
      "startCol": "46",
      "endLine": "64",
      "endCol": "89"
    },
    "650": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Wkd.js",
      "startLine": "79",
      "startCol": "8",
      "endLine": "79",
      "endCol": "35"
    },
    "651": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Wkd.js",
      "startLine": "90",
      "startCol": "8",
      "endLine": "90",
      "endCol": "35"
    },
    "652": {
      "patternID": "pattern3",
      "file": "test/source/tests/browser-unit-tests/unit-Wkd.js",
      "startLine": "100",
      "startCol": "9",
      "endLine": "100",
      "endCol": "36"
    },
    "653": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "35",
      "startCol": "25",
      "endLine": "35",
      "endCol": "110"
    },
    "654": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "37",
      "startCol": "41",
      "endLine": "37",
      "endCol": "80"
    },
    "655": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "38",
      "startCol": "7",
      "endLine": "38",
      "endCol": "51"
    },
    "656": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "39",
      "startCol": "40",
      "endLine": "39",
      "endCol": "91"
    },
    "657": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "42",
      "startCol": "7",
      "endLine": "42",
      "endCol": "54"
    },
    "658": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "43",
      "startCol": "14",
      "endLine": "43",
      "endCol": "53"
    },
    "659": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "45",
      "startCol": "7",
      "endLine": "45",
      "endCol": "54"
    },
    "660": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "46",
      "startCol": "14",
      "endLine": "46",
      "endCol": "53"
    },
    "661": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "51",
      "startCol": "28",
      "endLine": "51",
      "endCol": "112"
    },
    "662": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "53",
      "startCol": "25",
      "endLine": "53",
      "endCol": "106"
    },
    "663": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "56",
      "startCol": "7",
      "endLine": "56",
      "endCol": "53"
    },
    "664": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "57",
      "startCol": "7",
      "endLine": "57",
      "endCol": "51"
    },
    "665": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "58",
      "startCol": "32",
      "endLine": "58",
      "endCol": "75"
    },
    "666": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "59",
      "startCol": "7",
      "endLine": "59",
      "endCol": "76"
    },
    "667": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "60",
      "startCol": "7",
      "endLine": "60",
      "endCol": "78"
    },
    "668": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "61",
      "startCol": "7",
      "endLine": "61",
      "endCol": "56"
    },
    "669": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "62",
      "startCol": "7",
      "endLine": "62",
      "endCol": "60"
    },
    "670": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "67",
      "startCol": "7",
      "endLine": "67",
      "endCol": "32"
    },
    "671": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "68",
      "startCol": "7",
      "endLine": "68",
      "endCol": "29"
    },
    "672": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "74",
      "startCol": "7",
      "endLine": "74",
      "endCol": "51"
    },
    "673": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "75",
      "startCol": "7",
      "endLine": "75",
      "endCol": "108"
    },
    "674": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "76",
      "startCol": "7",
      "endLine": "76",
      "endCol": "110"
    },
    "675": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "79",
      "startCol": "7",
      "endLine": "79",
      "endCol": "51"
    },
    "676": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "80",
      "startCol": "7",
      "endLine": "80",
      "endCol": "108"
    },
    "677": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "81",
      "startCol": "7",
      "endLine": "81",
      "endCol": "110"
    },
    "678": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "87",
      "startCol": "7",
      "endLine": "87",
      "endCol": "55"
    },
    "679": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "88",
      "startCol": "7",
      "endLine": "88",
      "endCol": "119"
    },
    "680": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "91",
      "startCol": "7",
      "endLine": "91",
      "endCol": "55"
    },
    "681": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "92",
      "startCol": "7",
      "endLine": "92",
      "endCol": "119"
    },
    "682": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "98",
      "startCol": "7",
      "endLine": "98",
      "endCol": "50"
    },
    "683": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "99",
      "startCol": "7",
      "endLine": "99",
      "endCol": "126"
    },
    "684": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "100",
      "startCol": "7",
      "endLine": "100",
      "endCol": "139"
    },
    "685": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "102",
      "startCol": "7",
      "endLine": "102",
      "endCol": "54"
    },
    "686": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "103",
      "startCol": "7",
      "endLine": "103",
      "endCol": "115"
    },
    "687": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "104",
      "startCol": "7",
      "endLine": "104",
      "endCol": "123"
    },
    "688": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "110",
      "startCol": "7",
      "endLine": "110",
      "endCol": "69"
    },
    "689": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "112",
      "startCol": "7",
      "endLine": "112",
      "endCol": "66"
    },
    "690": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "113",
      "startCol": "7",
      "endLine": "113",
      "endCol": "65"
    },
    "691": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "114",
      "startCol": "7",
      "endLine": "114",
      "endCol": "51"
    },
    "692": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "115",
      "startCol": "7",
      "endLine": "115",
      "endCol": "48"
    },
    "693": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "116",
      "startCol": "28",
      "endLine": "116",
      "endCol": "75"
    },
    "694": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "123",
      "startCol": "7",
      "endLine": "123",
      "endCol": "69"
    },
    "695": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "125",
      "startCol": "7",
      "endLine": "125",
      "endCol": "48"
    },
    "696": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "127",
      "startCol": "14",
      "endLine": "127",
      "endCol": "75"
    },
    "697": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "128",
      "startCol": "7",
      "endLine": "128",
      "endCol": "76"
    },
    "698": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "129",
      "startCol": "7",
      "endLine": "129",
      "endCol": "51"
    },
    "699": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "130",
      "startCol": "7",
      "endLine": "130",
      "endCol": "48"
    },
    "700": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "132",
      "startCol": "14",
      "endLine": "132",
      "endCol": "75"
    },
    "701": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "140",
      "startCol": "7",
      "endLine": "140",
      "endCol": "69"
    },
    "702": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "142",
      "startCol": "7",
      "endLine": "142",
      "endCol": "48"
    },
    "703": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "144",
      "startCol": "14",
      "endLine": "144",
      "endCol": "75"
    },
    "704": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "145",
      "startCol": "7",
      "endLine": "145",
      "endCol": "76"
    },
    "705": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "146",
      "startCol": "7",
      "endLine": "146",
      "endCol": "51"
    },
    "706": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "147",
      "startCol": "7",
      "endLine": "147",
      "endCol": "48"
    },
    "707": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "149",
      "startCol": "14",
      "endLine": "149",
      "endCol": "75"
    },
    "708": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "172",
      "startCol": "7",
      "endLine": "172",
      "endCol": "87"
    },
    "709": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "180",
      "startCol": "25",
      "endLine": "180",
      "endCol": "70"
    },
    "710": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "181",
      "startCol": "7",
      "endLine": "181",
      "endCol": "111"
    },
    "711": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "192",
      "startCol": "25",
      "endLine": "192",
      "endCol": "106"
    },
    "712": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "196",
      "startCol": "7",
      "endLine": "196",
      "endCol": "66"
    },
    "713": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "197",
      "startCol": "7",
      "endLine": "197",
      "endCol": "60"
    },
    "714": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "200",
      "startCol": "7",
      "endLine": "200",
      "endCol": "85"
    },
    "715": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "201",
      "startCol": "7",
      "endLine": "201",
      "endCol": "51"
    },
    "716": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "202",
      "startCol": "31",
      "endLine": "202",
      "endCol": "74"
    },
    "717": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "203",
      "startCol": "7",
      "endLine": "203",
      "endCol": "62"
    },
    "718": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "205",
      "startCol": "7",
      "endLine": "205",
      "endCol": "90"
    },
    "719": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "207",
      "startCol": "7",
      "endLine": "207",
      "endCol": "62"
    },
    "720": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "208",
      "startCol": "7",
      "endLine": "208",
      "endCol": "56"
    },
    "721": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "209",
      "startCol": "7",
      "endLine": "209",
      "endCol": "67"
    },
    "722": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "210",
      "startCol": "7",
      "endLine": "210",
      "endCol": "60"
    },
    "723": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "214",
      "startCol": "25",
      "endLine": "214",
      "endCol": "106"
    },
    "724": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "216",
      "startCol": "7",
      "endLine": "216",
      "endCol": "190"
    },
    "725": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "217",
      "startCol": "7",
      "endLine": "217",
      "endCol": "98"
    },
    "726": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "221",
      "startCol": "25",
      "endLine": "221",
      "endCol": "106"
    },
    "727": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "223",
      "startCol": "7",
      "endLine": "223",
      "endCol": "69"
    },
    "728": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "224",
      "startCol": "7",
      "endLine": "224",
      "endCol": "36"
    },
    "729": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "225",
      "startCol": "7",
      "endLine": "225",
      "endCol": "43"
    },
    "730": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "226",
      "startCol": "7",
      "endLine": "226",
      "endCol": "36"
    },
    "731": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "227",
      "startCol": "14",
      "endLine": "227",
      "endCol": "52"
    },
    "732": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "231",
      "startCol": "25",
      "endLine": "231",
      "endCol": "106"
    },
    "733": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "233",
      "startCol": "7",
      "endLine": "233",
      "endCol": "61"
    },
    "734": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "237",
      "startCol": "7",
      "endLine": "237",
      "endCol": "36"
    },
    "735": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "238",
      "startCol": "7",
      "endLine": "238",
      "endCol": "23"
    },
    "736": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "244",
      "startCol": "7",
      "endLine": "244",
      "endCol": "78"
    },
    "737": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "245",
      "startCol": "14",
      "endLine": "245",
      "endCol": "50"
    },
    "738": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "246",
      "startCol": "7",
      "endLine": "246",
      "endCol": "64"
    },
    "739": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "252",
      "startCol": "7",
      "endLine": "252",
      "endCol": "78"
    },
    "740": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "253",
      "startCol": "14",
      "endLine": "253",
      "endCol": "50"
    },
    "741": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "254",
      "startCol": "7",
      "endLine": "254",
      "endCol": "64"
    },
    "742": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "260",
      "startCol": "7",
      "endLine": "260",
      "endCol": "70"
    },
    "743": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "280",
      "startCol": "7",
      "endLine": "280",
      "endCol": "70"
    },
    "744": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "291",
      "startCol": "7",
      "endLine": "291",
      "endCol": "70"
    },
    "745": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "292",
      "startCol": "14",
      "endLine": "292",
      "endCol": "50"
    },
    "746": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "308",
      "startCol": "7",
      "endLine": "308",
      "endCol": "70"
    },
    "747": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "322",
      "startCol": "9",
      "endLine": "322",
      "endCol": "53"
    },
    "748": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "323",
      "startCol": "33",
      "endLine": "323",
      "endCol": "76"
    },
    "749": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "324",
      "startCol": "9",
      "endLine": "324",
      "endCol": "67"
    },
    "750": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "326",
      "startCol": "11",
      "endLine": "326",
      "endCol": "81"
    },
    "751": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "328",
      "startCol": "11",
      "endLine": "328",
      "endCol": "40"
    },
    "752": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "330",
      "startCol": "9",
      "endLine": "330",
      "endCol": "47"
    },
    "753": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "350",
      "startCol": "9",
      "endLine": "350",
      "endCol": "53"
    },
    "754": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "351",
      "startCol": "33",
      "endLine": "351",
      "endCol": "76"
    },
    "755": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "353",
      "startCol": "11",
      "endLine": "353",
      "endCol": "80"
    },
    "756": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "355",
      "startCol": "11",
      "endLine": "355",
      "endCol": "41"
    },
    "757": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "357",
      "startCol": "9",
      "endLine": "357",
      "endCol": "47"
    },
    "758": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "358",
      "startCol": "9",
      "endLine": "358",
      "endCol": "64"
    },
    "759": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "359",
      "startCol": "27",
      "endLine": "359",
      "endCol": "62"
    },
    "760": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "371",
      "startCol": "7",
      "endLine": "371",
      "endCol": "69"
    },
    "761": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "372",
      "startCol": "7",
      "endLine": "372",
      "endCol": "70"
    },
    "762": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "373",
      "startCol": "7",
      "endLine": "373",
      "endCol": "47"
    },
    "763": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "375",
      "startCol": "14",
      "endLine": "375",
      "endCol": "51"
    },
    "764": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "376",
      "startCol": "7",
      "endLine": "376",
      "endCol": "68"
    },
    "765": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "377",
      "startCol": "7",
      "endLine": "377",
      "endCol": "108"
    },
    "766": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "378",
      "startCol": "7",
      "endLine": "378",
      "endCol": "65"
    },
    "767": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "386",
      "startCol": "7",
      "endLine": "386",
      "endCol": "55"
    },
    "768": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "388",
      "startCol": "14",
      "endLine": "388",
      "endCol": "50"
    },
    "769": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "389",
      "startCol": "7",
      "endLine": "389",
      "endCol": "48"
    },
    "770": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "395",
      "startCol": "14",
      "endLine": "395",
      "endCol": "61"
    },
    "771": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "396",
      "startCol": "14",
      "endLine": "396",
      "endCol": "80"
    },
    "772": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "397",
      "startCol": "7",
      "endLine": "397",
      "endCol": "48"
    },
    "773": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "398",
      "startCol": "7",
      "endLine": "398",
      "endCol": "67"
    },
    "774": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "410",
      "startCol": "7",
      "endLine": "410",
      "endCol": "85"
    },
    "775": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "420",
      "startCol": "31",
      "endLine": "420",
      "endCol": "96"
    },
    "776": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "421",
      "startCol": "25",
      "endLine": "421",
      "endCol": "70"
    },
    "777": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "423",
      "startCol": "7",
      "endLine": "423",
      "endCol": "52"
    },
    "778": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "425",
      "startCol": "7",
      "endLine": "425",
      "endCol": "57"
    },
    "779": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "426",
      "startCol": "7",
      "endLine": "426",
      "endCol": "31"
    },
    "780": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "430",
      "startCol": "22",
      "endLine": "430",
      "endCol": "96"
    },
    "781": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "431",
      "startCol": "7",
      "endLine": "435",
      "endCol": "50"
    },
    "782": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "432",
      "startCol": "20",
      "endLine": "432",
      "endCol": "62"
    },
    "783": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "433",
      "startCol": "32",
      "endLine": "433",
      "endCol": "74"
    },
    "784": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "434",
      "startCol": "9",
      "endLine": "434",
      "endCol": "113"
    },
    "785": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "436",
      "startCol": "7",
      "endLine": "436",
      "endCol": "26"
    },
    "786": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "439",
      "startCol": "31",
      "endLine": "439",
      "endCol": "96"
    },
    "787": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "440",
      "startCol": "25",
      "endLine": "440",
      "endCol": "70"
    },
    "788": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "442",
      "startCol": "7",
      "endLine": "442",
      "endCol": "31"
    },
    "789": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "446",
      "startCol": "22",
      "endLine": "446",
      "endCol": "96"
    },
    "790": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "447",
      "startCol": "7",
      "endLine": "456",
      "endCol": "40"
    },
    "791": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "448",
      "startCol": "20",
      "endLine": "448",
      "endCol": "62"
    },
    "792": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "449",
      "startCol": "36",
      "endLine": "449",
      "endCol": "78"
    },
    "793": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "450",
      "startCol": "9",
      "endLine": "450",
      "endCol": "121"
    },
    "794": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "457",
      "startCol": "7",
      "endLine": "457",
      "endCol": "26"
    },
    "795": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "460",
      "startCol": "31",
      "endLine": "460",
      "endCol": "96"
    },
    "796": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "461",
      "startCol": "25",
      "endLine": "461",
      "endCol": "70"
    },
    "797": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "463",
      "startCol": "7",
      "endLine": "463",
      "endCol": "31"
    },
    "798": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "467",
      "startCol": "22",
      "endLine": "467",
      "endCol": "96"
    },
    "799": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "468",
      "startCol": "7",
      "endLine": "472",
      "endCol": "50"
    },
    "800": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "469",
      "startCol": "20",
      "endLine": "469",
      "endCol": "62"
    },
    "801": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "470",
      "startCol": "32",
      "endLine": "470",
      "endCol": "74"
    },
    "802": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "471",
      "startCol": "9",
      "endLine": "471",
      "endCol": "113"
    },
    "803": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "473",
      "startCol": "7",
      "endLine": "473",
      "endCol": "26"
    },
    "804": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "476",
      "startCol": "7",
      "endLine": "476",
      "endCol": "71"
    },
    "805": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "477",
      "startCol": "7",
      "endLine": "477",
      "endCol": "31"
    },
    "806": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "481",
      "startCol": "22",
      "endLine": "481",
      "endCol": "96"
    },
    "807": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "482",
      "startCol": "7",
      "endLine": "486",
      "endCol": "40"
    },
    "808": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "483",
      "startCol": "20",
      "endLine": "483",
      "endCol": "62"
    },
    "809": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "484",
      "startCol": "30",
      "endLine": "484",
      "endCol": "72"
    },
    "810": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "485",
      "startCol": "9",
      "endLine": "485",
      "endCol": "115"
    },
    "811": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "487",
      "startCol": "7",
      "endLine": "487",
      "endCol": "26"
    },
    "812": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "490",
      "startCol": "7",
      "endLine": "490",
      "endCol": "49"
    },
    "813": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "491",
      "startCol": "7",
      "endLine": "491",
      "endCol": "56"
    },
    "814": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "492",
      "startCol": "7",
      "endLine": "492",
      "endCol": "31"
    },
    "815": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "496",
      "startCol": "22",
      "endLine": "496",
      "endCol": "96"
    },
    "816": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "497",
      "startCol": "7",
      "endLine": "501",
      "endCol": "50"
    },
    "817": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "498",
      "startCol": "20",
      "endLine": "498",
      "endCol": "62"
    },
    "818": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "499",
      "startCol": "32",
      "endLine": "499",
      "endCol": "74"
    },
    "819": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "500",
      "startCol": "9",
      "endLine": "500",
      "endCol": "113"
    },
    "820": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "502",
      "startCol": "7",
      "endLine": "502",
      "endCol": "26"
    },
    "821": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "505",
      "startCol": "7",
      "endLine": "505",
      "endCol": "51"
    },
    "822": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "506",
      "startCol": "7",
      "endLine": "506",
      "endCol": "54"
    },
    "823": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "507",
      "startCol": "7",
      "endLine": "507",
      "endCol": "31"
    },
    "824": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "511",
      "startCol": "22",
      "endLine": "511",
      "endCol": "96"
    },
    "825": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "512",
      "startCol": "7",
      "endLine": "516",
      "endCol": "40"
    },
    "826": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "513",
      "startCol": "20",
      "endLine": "513",
      "endCol": "62"
    },
    "827": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "514",
      "startCol": "30",
      "endLine": "514",
      "endCol": "72"
    },
    "828": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "515",
      "startCol": "9",
      "endLine": "515",
      "endCol": "115"
    },
    "829": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "517",
      "startCol": "7",
      "endLine": "517",
      "endCol": "26"
    },
    "830": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "520",
      "startCol": "7",
      "endLine": "520",
      "endCol": "76"
    },
    "831": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "521",
      "startCol": "7",
      "endLine": "521",
      "endCol": "31"
    },
    "832": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "529",
      "startCol": "29",
      "endLine": "529",
      "endCol": "71"
    },
    "833": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "531",
      "startCol": "17",
      "endLine": "531",
      "endCol": "53"
    },
    "834": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "532",
      "startCol": "28",
      "endLine": "532",
      "endCol": "90"
    },
    "835": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "543",
      "startCol": "7",
      "endLine": "543",
      "endCol": "77"
    },
    "836": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "545",
      "startCol": "14",
      "endLine": "545",
      "endCol": "50"
    },
    "837": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "550",
      "startCol": "33",
      "endLine": "550",
      "endCol": "196"
    },
    "838": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "551",
      "startCol": "7",
      "endLine": "551",
      "endCol": "58"
    },
    "839": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "554",
      "startCol": "14",
      "endLine": "554",
      "endCol": "56"
    },
    "840": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "555",
      "startCol": "7",
      "endLine": "555",
      "endCol": "56"
    },
    "841": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "562",
      "startCol": "7",
      "endLine": "562",
      "endCol": "71"
    },
    "842": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "563",
      "startCol": "7",
      "endLine": "563",
      "endCol": "52"
    },
    "843": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "564",
      "startCol": "7",
      "endLine": "564",
      "endCol": "77"
    },
    "844": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "566",
      "startCol": "28",
      "endLine": "566",
      "endCol": "74"
    },
    "845": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "567",
      "startCol": "28",
      "endLine": "567",
      "endCol": "67"
    },
    "846": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "586",
      "startCol": "7",
      "endLine": "586",
      "endCol": "70"
    },
    "847": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "587",
      "startCol": "7",
      "endLine": "587",
      "endCol": "47"
    },
    "848": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "589",
      "startCol": "14",
      "endLine": "589",
      "endCol": "51"
    },
    "849": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "590",
      "startCol": "7",
      "endLine": "590",
      "endCol": "68"
    },
    "850": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "591",
      "startCol": "7",
      "endLine": "591",
      "endCol": "108"
    },
    "851": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "592",
      "startCol": "7",
      "endLine": "592",
      "endCol": "65"
    },
    "852": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "593",
      "startCol": "25",
      "endLine": "593",
      "endCol": "70"
    },
    "853": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "594",
      "startCol": "7",
      "endLine": "594",
      "endCol": "71"
    },
    "854": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "595",
      "startCol": "7",
      "endLine": "595",
      "endCol": "66"
    },
    "855": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "596",
      "startCol": "26",
      "endLine": "596",
      "endCol": "101"
    },
    "856": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "597",
      "startCol": "7",
      "endLine": "597",
      "endCol": "51"
    },
    "857": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "598",
      "startCol": "24",
      "endLine": "600",
      "endCol": "8"
    },
    "858": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "599",
      "startCol": "9",
      "endLine": "599",
      "endCol": "43"
    },
    "859": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "602",
      "startCol": "7",
      "endLine": "602",
      "endCol": "31"
    },
    "860": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "608",
      "startCol": "7",
      "endLine": "608",
      "endCol": "66"
    },
    "861": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "609",
      "startCol": "14",
      "endLine": "609",
      "endCol": "54"
    },
    "862": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "610",
      "startCol": "14",
      "endLine": "610",
      "endCol": "65"
    },
    "863": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "611",
      "startCol": "7",
      "endLine": "611",
      "endCol": "93"
    },
    "864": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "612",
      "startCol": "14",
      "endLine": "612",
      "endCol": "54"
    },
    "865": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "613",
      "startCol": "14",
      "endLine": "613",
      "endCol": "65"
    },
    "866": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "618",
      "startCol": "7",
      "endLine": "618",
      "endCol": "77"
    },
    "867": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "619",
      "startCol": "7",
      "endLine": "619",
      "endCol": "52"
    },
    "868": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "625",
      "startCol": "28",
      "endLine": "625",
      "endCol": "130"
    },
    "869": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "631",
      "startCol": "7",
      "endLine": "631",
      "endCol": "77"
    },
    "870": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "632",
      "startCol": "7",
      "endLine": "632",
      "endCol": "52"
    },
    "871": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "634",
      "startCol": "7",
      "endLine": "634",
      "endCol": "70"
    },
    "872": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "638",
      "startCol": "25",
      "endLine": "638",
      "endCol": "106"
    },
    "873": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "640",
      "startCol": "7",
      "endLine": "640",
      "endCol": "61"
    },
    "874": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "643",
      "startCol": "28",
      "endLine": "643",
      "endCol": "131"
    },
    "875": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "656",
      "startCol": "7",
      "endLine": "656",
      "endCol": "66"
    },
    "876": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "657",
      "startCol": "7",
      "endLine": "657",
      "endCol": "60"
    },
    "877": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "662",
      "startCol": "7",
      "endLine": "662",
      "endCol": "67"
    },
    "878": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "663",
      "startCol": "7",
      "endLine": "663",
      "endCol": "54"
    },
    "879": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "664",
      "startCol": "7",
      "endLine": "664",
      "endCol": "66"
    },
    "880": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "665",
      "startCol": "7",
      "endLine": "665",
      "endCol": "60"
    },
    "881": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "670",
      "startCol": "7",
      "endLine": "670",
      "endCol": "66"
    },
    "882": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "671",
      "startCol": "7",
      "endLine": "671",
      "endCol": "60"
    },
    "883": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "675",
      "startCol": "7",
      "endLine": "675",
      "endCol": "68"
    },
    "884": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "676",
      "startCol": "7",
      "endLine": "676",
      "endCol": "67"
    },
    "885": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "677",
      "startCol": "7",
      "endLine": "677",
      "endCol": "54"
    },
    "886": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "678",
      "startCol": "7",
      "endLine": "678",
      "endCol": "66"
    },
    "887": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "679",
      "startCol": "7",
      "endLine": "679",
      "endCol": "60"
    },
    "888": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "682",
      "startCol": "7",
      "endLine": "682",
      "endCol": "61"
    },
    "889": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "698",
      "startCol": "7",
      "endLine": "698",
      "endCol": "72"
    },
    "890": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "699",
      "startCol": "7",
      "endLine": "699",
      "endCol": "38"
    },
    "891": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "700",
      "startCol": "7",
      "endLine": "700",
      "endCol": "72"
    },
    "892": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "701",
      "startCol": "7",
      "endLine": "701",
      "endCol": "38"
    },
    "893": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "704",
      "startCol": "7",
      "endLine": "704",
      "endCol": "42"
    },
    "894": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "707",
      "startCol": "7",
      "endLine": "707",
      "endCol": "52"
    },
    "895": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "708",
      "startCol": "7",
      "endLine": "708",
      "endCol": "39"
    },
    "896": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "711",
      "startCol": "7",
      "endLine": "711",
      "endCol": "52"
    },
    "897": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "712",
      "startCol": "7",
      "endLine": "712",
      "endCol": "42"
    },
    "898": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "719",
      "startCol": "7",
      "endLine": "719",
      "endCol": "52"
    },
    "899": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "720",
      "startCol": "14",
      "endLine": "720",
      "endCol": "60"
    },
    "900": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "721",
      "startCol": "7",
      "endLine": "721",
      "endCol": "53"
    },
    "901": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "722",
      "startCol": "7",
      "endLine": "722",
      "endCol": "102"
    },
    "902": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "723",
      "startCol": "7",
      "endLine": "723",
      "endCol": "52"
    },
    "903": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "724",
      "startCol": "14",
      "endLine": "724",
      "endCol": "60"
    },
    "904": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "725",
      "startCol": "7",
      "endLine": "725",
      "endCol": "53"
    },
    "905": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "726",
      "startCol": "7",
      "endLine": "726",
      "endCol": "80"
    },
    "906": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "727",
      "startCol": "22",
      "endLine": "727",
      "endCol": "58"
    },
    "907": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "729",
      "startCol": "7",
      "endLine": "729",
      "endCol": "52"
    },
    "908": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "730",
      "startCol": "14",
      "endLine": "730",
      "endCol": "60"
    },
    "909": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "731",
      "startCol": "7",
      "endLine": "731",
      "endCol": "53"
    },
    "910": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "732",
      "startCol": "7",
      "endLine": "732",
      "endCol": "90"
    },
    "911": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "745",
      "startCol": "14",
      "endLine": "745",
      "endCol": "50"
    },
    "912": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "749",
      "startCol": "25",
      "endLine": "749",
      "endCol": "125"
    },
    "913": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "750",
      "startCol": "7",
      "endLine": "750",
      "endCol": "72"
    },
    "914": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "751",
      "startCol": "7",
      "endLine": "751",
      "endCol": "57"
    },
    "915": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "752",
      "startCol": "28",
      "endLine": "752",
      "endCol": "68"
    },
    "916": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "753",
      "startCol": "7",
      "endLine": "753",
      "endCol": "53"
    },
    "917": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "754",
      "startCol": "27",
      "endLine": "754",
      "endCol": "60"
    },
    "918": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "757",
      "startCol": "7",
      "endLine": "757",
      "endCol": "70"
    },
    "919": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "760",
      "startCol": "7",
      "endLine": "760",
      "endCol": "70"
    },
    "920": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "763",
      "startCol": "7",
      "endLine": "763",
      "endCol": "84"
    },
    "921": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "765",
      "startCol": "7",
      "endLine": "765",
      "endCol": "84"
    },
    "922": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "774",
      "startCol": "7",
      "endLine": "774",
      "endCol": "125"
    },
    "923": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "776",
      "startCol": "7",
      "endLine": "776",
      "endCol": "31"
    },
    "924": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "778",
      "startCol": "20",
      "endLine": "778",
      "endCol": "59"
    },
    "925": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "779",
      "startCol": "7",
      "endLine": "779",
      "endCol": "50"
    },
    "926": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "780",
      "startCol": "14",
      "endLine": "780",
      "endCol": "78"
    },
    "927": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "785",
      "startCol": "7",
      "endLine": "785",
      "endCol": "61"
    },
    "928": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "787",
      "startCol": "14",
      "endLine": "787",
      "endCol": "51"
    },
    "929": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "788",
      "startCol": "7",
      "endLine": "788",
      "endCol": "92"
    },
    "930": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "790",
      "startCol": "7",
      "endLine": "790",
      "endCol": "31"
    },
    "931": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "792",
      "startCol": "14",
      "endLine": "792",
      "endCol": "54"
    },
    "932": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "793",
      "startCol": "7",
      "endLine": "793",
      "endCol": "102"
    },
    "933": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "798",
      "startCol": "7",
      "endLine": "798",
      "endCol": "51"
    },
    "934": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "799",
      "startCol": "14",
      "endLine": "799",
      "endCol": "60"
    },
    "935": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "800",
      "startCol": "7",
      "endLine": "800",
      "endCol": "42"
    },
    "936": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "801",
      "startCol": "14",
      "endLine": "801",
      "endCol": "60"
    },
    "937": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "802",
      "startCol": "7",
      "endLine": "802",
      "endCol": "51"
    },
    "938": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "803",
      "startCol": "14",
      "endLine": "803",
      "endCol": "60"
    },
    "939": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "811",
      "startCol": "7",
      "endLine": "811",
      "endCol": "31"
    },
    "940": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "813",
      "startCol": "14",
      "endLine": "813",
      "endCol": "60"
    },
    "941": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "814",
      "startCol": "14",
      "endLine": "814",
      "endCol": "54"
    },
    "942": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "822",
      "startCol": "7",
      "endLine": "822",
      "endCol": "31"
    },
    "943": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "824",
      "startCol": "14",
      "endLine": "824",
      "endCol": "54"
    },
    "944": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "853",
      "startCol": "7",
      "endLine": "853",
      "endCol": "76"
    },
    "945": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "867",
      "startCol": "25",
      "endLine": "867",
      "endCol": "70"
    },
    "946": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "869",
      "startCol": "7",
      "endLine": "869",
      "endCol": "66"
    },
    "947": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "870",
      "startCol": "7",
      "endLine": "870",
      "endCol": "44"
    },
    "948": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "871",
      "startCol": "7",
      "endLine": "871",
      "endCol": "149"
    },
    "949": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "873",
      "startCol": "7",
      "endLine": "873",
      "endCol": "62"
    },
    "950": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "875",
      "startCol": "7",
      "endLine": "875",
      "endCol": "59"
    },
    "951": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "876",
      "startCol": "7",
      "endLine": "876",
      "endCol": "79"
    },
    "952": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "882",
      "startCol": "25",
      "endLine": "882",
      "endCol": "147"
    },
    "953": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "883",
      "startCol": "7",
      "endLine": "883",
      "endCol": "39"
    },
    "954": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "884",
      "startCol": "26",
      "endLine": "884",
      "endCol": "66"
    },
    "955": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "885",
      "startCol": "7",
      "endLine": "885",
      "endCol": "55"
    },
    "956": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "886",
      "startCol": "25",
      "endLine": "886",
      "endCol": "69"
    },
    "957": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "887",
      "startCol": "7",
      "endLine": "887",
      "endCol": "59"
    },
    "958": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "888",
      "startCol": "7",
      "endLine": "888",
      "endCol": "51"
    },
    "959": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "889",
      "startCol": "26",
      "endLine": "889",
      "endCol": "88"
    },
    "960": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "890",
      "startCol": "7",
      "endLine": "890",
      "endCol": "51"
    },
    "961": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "891",
      "startCol": "7",
      "endLine": "891",
      "endCol": "36"
    },
    "962": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "892",
      "startCol": "38",
      "endLine": "892",
      "endCol": "89"
    },
    "963": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "893",
      "startCol": "7",
      "endLine": "893",
      "endCol": "102"
    },
    "964": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "897",
      "startCol": "25",
      "endLine": "897",
      "endCol": "173"
    },
    "965": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "898",
      "startCol": "26",
      "endLine": "898",
      "endCol": "69"
    },
    "966": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "899",
      "startCol": "7",
      "endLine": "899",
      "endCol": "59"
    },
    "967": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "900",
      "startCol": "7",
      "endLine": "900",
      "endCol": "61"
    },
    "968": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "901",
      "startCol": "35",
      "endLine": "901",
      "endCol": "86"
    },
    "969": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "902",
      "startCol": "7",
      "endLine": "902",
      "endCol": "104"
    },
    "970": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "903",
      "startCol": "7",
      "endLine": "903",
      "endCol": "90"
    },
    "971": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "912",
      "startCol": "7",
      "endLine": "912",
      "endCol": "118"
    },
    "972": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "913",
      "startCol": "14",
      "endLine": "913",
      "endCol": "70"
    },
    "973": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "919",
      "startCol": "7",
      "endLine": "919",
      "endCol": "89"
    },
    "974": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "920",
      "startCol": "14",
      "endLine": "920",
      "endCol": "70"
    },
    "975": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "926",
      "startCol": "7",
      "endLine": "926",
      "endCol": "84"
    },
    "976": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "927",
      "startCol": "7",
      "endLine": "927",
      "endCol": "50"
    },
    "977": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "935",
      "startCol": "25",
      "endLine": "935",
      "endCol": "106"
    },
    "978": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "939",
      "startCol": "7",
      "endLine": "939",
      "endCol": "67"
    },
    "979": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "940",
      "startCol": "7",
      "endLine": "940",
      "endCol": "60"
    },
    "980": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "944",
      "startCol": "25",
      "endLine": "944",
      "endCol": "106"
    },
    "981": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "949",
      "startCol": "7",
      "endLine": "949",
      "endCol": "67"
    },
    "982": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "950",
      "startCol": "7",
      "endLine": "950",
      "endCol": "60"
    },
    "983": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "955",
      "startCol": "25",
      "endLine": "955",
      "endCol": "106"
    },
    "984": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "959",
      "startCol": "25",
      "endLine": "959",
      "endCol": "71"
    },
    "985": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "960",
      "startCol": "7",
      "endLine": "960",
      "endCol": "111"
    },
    "986": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "961",
      "startCol": "7",
      "endLine": "961",
      "endCol": "67"
    },
    "987": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "962",
      "startCol": "7",
      "endLine": "962",
      "endCol": "60"
    },
    "988": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "966",
      "startCol": "25",
      "endLine": "966",
      "endCol": "106"
    },
    "989": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "970",
      "startCol": "7",
      "endLine": "970",
      "endCol": "67"
    },
    "990": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "978",
      "startCol": "25",
      "endLine": "978",
      "endCol": "106"
    },
    "991": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "984",
      "startCol": "7",
      "endLine": "984",
      "endCol": "107"
    },
    "992": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "988",
      "startCol": "25",
      "endLine": "988",
      "endCol": "106"
    },
    "993": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "993",
      "startCol": "7",
      "endLine": "993",
      "endCol": "148"
    },
    "994": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "997",
      "startCol": "25",
      "endLine": "997",
      "endCol": "106"
    },
    "995": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1003",
      "startCol": "7",
      "endLine": "1003",
      "endCol": "191"
    },
    "996": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1010",
      "startCol": "28",
      "endLine": "1010",
      "endCol": "112"
    },
    "997": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1013",
      "startCol": "7",
      "endLine": "1013",
      "endCol": "51"
    },
    "998": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1014",
      "startCol": "7",
      "endLine": "1014",
      "endCol": "101"
    },
    "999": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1015",
      "startCol": "7",
      "endLine": "1015",
      "endCol": "82"
    },
    "1000": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1016",
      "startCol": "7",
      "endLine": "1016",
      "endCol": "96"
    },
    "1001": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1017",
      "startCol": "7",
      "endLine": "1017",
      "endCol": "43"
    },
    "1002": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1018",
      "startCol": "27",
      "endLine": "1018",
      "endCol": "74"
    },
    "1003": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1019",
      "startCol": "7",
      "endLine": "1019",
      "endCol": "83"
    },
    "1004": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1020",
      "startCol": "7",
      "endLine": "1020",
      "endCol": "59"
    },
    "1005": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1021",
      "startCol": "7",
      "endLine": "1021",
      "endCol": "90"
    },
    "1006": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1022",
      "startCol": "7",
      "endLine": "1022",
      "endCol": "93"
    },
    "1007": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1023",
      "startCol": "7",
      "endLine": "1023",
      "endCol": "129"
    },
    "1008": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1024",
      "startCol": "7",
      "endLine": "1024",
      "endCol": "86"
    },
    "1009": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1025",
      "startCol": "7",
      "endLine": "1025",
      "endCol": "135"
    },
    "1010": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1026",
      "startCol": "7",
      "endLine": "1026",
      "endCol": "97"
    },
    "1011": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1027",
      "startCol": "7",
      "endLine": "1027",
      "endCol": "109"
    },
    "1012": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1028",
      "startCol": "7",
      "endLine": "1028",
      "endCol": "109"
    },
    "1013": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1029",
      "startCol": "7",
      "endLine": "1029",
      "endCol": "85"
    },
    "1014": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1030",
      "startCol": "7",
      "endLine": "1030",
      "endCol": "101"
    },
    "1015": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1031",
      "startCol": "7",
      "endLine": "1031",
      "endCol": "98"
    },
    "1016": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1035",
      "startCol": "31",
      "endLine": "1035",
      "endCol": "96"
    },
    "1017": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1036",
      "startCol": "25",
      "endLine": "1036",
      "endCol": "70"
    },
    "1018": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1040",
      "startCol": "7",
      "endLine": "1040",
      "endCol": "93"
    },
    "1019": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1041",
      "startCol": "7",
      "endLine": "1041",
      "endCol": "129"
    },
    "1020": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1042",
      "startCol": "7",
      "endLine": "1042",
      "endCol": "84"
    },
    "1021": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1043",
      "startCol": "7",
      "endLine": "1043",
      "endCol": "100"
    },
    "1022": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1044",
      "startCol": "7",
      "endLine": "1044",
      "endCol": "100"
    },
    "1023": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1051",
      "startCol": "7",
      "endLine": "1051",
      "endCol": "80"
    },
    "1024": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1054",
      "startCol": "27",
      "endLine": "1054",
      "endCol": "66"
    },
    "1025": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1055",
      "startCol": "7",
      "endLine": "1055",
      "endCol": "67"
    },
    "1026": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1056",
      "startCol": "7",
      "endLine": "1056",
      "endCol": "75"
    },
    "1027": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1057",
      "startCol": "7",
      "endLine": "1057",
      "endCol": "59"
    },
    "1028": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1058",
      "startCol": "7",
      "endLine": "1058",
      "endCol": "90"
    },
    "1029": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1060",
      "startCol": "7",
      "endLine": "1060",
      "endCol": "31"
    },
    "1030": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1061",
      "startCol": "7",
      "endLine": "1061",
      "endCol": "94"
    },
    "1031": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1068",
      "startCol": "28",
      "endLine": "1068",
      "endCol": "112"
    },
    "1032": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1071",
      "startCol": "7",
      "endLine": "1071",
      "endCol": "51"
    },
    "1033": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1072",
      "startCol": "7",
      "endLine": "1072",
      "endCol": "101"
    },
    "1034": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1073",
      "startCol": "7",
      "endLine": "1073",
      "endCol": "81"
    },
    "1035": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1074",
      "startCol": "7",
      "endLine": "1074",
      "endCol": "96"
    },
    "1036": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1075",
      "startCol": "7",
      "endLine": "1075",
      "endCol": "43"
    },
    "1037": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1076",
      "startCol": "27",
      "endLine": "1076",
      "endCol": "74"
    },
    "1038": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1077",
      "startCol": "7",
      "endLine": "1077",
      "endCol": "83"
    },
    "1039": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1078",
      "startCol": "7",
      "endLine": "1078",
      "endCol": "59"
    },
    "1040": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1079",
      "startCol": "7",
      "endLine": "1079",
      "endCol": "90"
    },
    "1041": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1080",
      "startCol": "7",
      "endLine": "1080",
      "endCol": "93"
    },
    "1042": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1081",
      "startCol": "7",
      "endLine": "1081",
      "endCol": "129"
    },
    "1043": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1082",
      "startCol": "7",
      "endLine": "1082",
      "endCol": "86"
    },
    "1044": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1083",
      "startCol": "7",
      "endLine": "1083",
      "endCol": "135"
    },
    "1045": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1084",
      "startCol": "7",
      "endLine": "1084",
      "endCol": "97"
    },
    "1046": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1085",
      "startCol": "7",
      "endLine": "1085",
      "endCol": "109"
    },
    "1047": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1086",
      "startCol": "7",
      "endLine": "1086",
      "endCol": "109"
    },
    "1048": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1087",
      "startCol": "7",
      "endLine": "1087",
      "endCol": "113"
    },
    "1049": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1088",
      "startCol": "7",
      "endLine": "1088",
      "endCol": "85"
    },
    "1050": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1089",
      "startCol": "7",
      "endLine": "1089",
      "endCol": "101"
    },
    "1051": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1090",
      "startCol": "7",
      "endLine": "1090",
      "endCol": "98"
    },
    "1052": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1094",
      "startCol": "31",
      "endLine": "1094",
      "endCol": "96"
    },
    "1053": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1095",
      "startCol": "25",
      "endLine": "1095",
      "endCol": "70"
    },
    "1054": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1097",
      "startCol": "7",
      "endLine": "1097",
      "endCol": "31"
    },
    "1055": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1099",
      "startCol": "7",
      "endLine": "1099",
      "endCol": "93"
    },
    "1056": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1100",
      "startCol": "7",
      "endLine": "1100",
      "endCol": "129"
    },
    "1057": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1101",
      "startCol": "7",
      "endLine": "1101",
      "endCol": "135"
    },
    "1058": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1102",
      "startCol": "7",
      "endLine": "1102",
      "endCol": "109"
    },
    "1059": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1103",
      "startCol": "7",
      "endLine": "1103",
      "endCol": "109"
    },
    "1060": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1104",
      "startCol": "7",
      "endLine": "1104",
      "endCol": "85"
    },
    "1061": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1111",
      "startCol": "28",
      "endLine": "1111",
      "endCol": "112"
    },
    "1062": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1114",
      "startCol": "7",
      "endLine": "1114",
      "endCol": "51"
    },
    "1063": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1115",
      "startCol": "7",
      "endLine": "1115",
      "endCol": "101"
    },
    "1064": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1116",
      "startCol": "7",
      "endLine": "1116",
      "endCol": "89"
    },
    "1065": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1117",
      "startCol": "7",
      "endLine": "1117",
      "endCol": "96"
    },
    "1066": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1118",
      "startCol": "7",
      "endLine": "1118",
      "endCol": "43"
    },
    "1067": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1119",
      "startCol": "27",
      "endLine": "1119",
      "endCol": "74"
    },
    "1068": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1120",
      "startCol": "7",
      "endLine": "1120",
      "endCol": "83"
    },
    "1069": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1121",
      "startCol": "7",
      "endLine": "1121",
      "endCol": "59"
    },
    "1070": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1122",
      "startCol": "7",
      "endLine": "1122",
      "endCol": "90"
    },
    "1071": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1123",
      "startCol": "7",
      "endLine": "1123",
      "endCol": "93"
    },
    "1072": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1124",
      "startCol": "7",
      "endLine": "1124",
      "endCol": "129"
    },
    "1073": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1125",
      "startCol": "7",
      "endLine": "1125",
      "endCol": "83"
    },
    "1074": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1126",
      "startCol": "7",
      "endLine": "1126",
      "endCol": "135"
    },
    "1075": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1127",
      "startCol": "7",
      "endLine": "1127",
      "endCol": "97"
    },
    "1076": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1128",
      "startCol": "7",
      "endLine": "1128",
      "endCol": "100"
    },
    "1077": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1129",
      "startCol": "7",
      "endLine": "1129",
      "endCol": "100"
    },
    "1078": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1130",
      "startCol": "7",
      "endLine": "1130",
      "endCol": "85"
    },
    "1079": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1131",
      "startCol": "7",
      "endLine": "1131",
      "endCol": "100"
    },
    "1080": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1132",
      "startCol": "7",
      "endLine": "1132",
      "endCol": "97"
    },
    "1081": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1138",
      "startCol": "7",
      "endLine": "1138",
      "endCol": "69"
    },
    "1082": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1139",
      "startCol": "7",
      "endLine": "1139",
      "endCol": "44"
    },
    "1083": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1140",
      "startCol": "7",
      "endLine": "1140",
      "endCol": "53"
    },
    "1084": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1150",
      "startCol": "3",
      "endLine": "1150",
      "endCol": "71"
    },
    "1085": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1151",
      "startCol": "3",
      "endLine": "1151",
      "endCol": "81"
    },
    "1086": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1152",
      "startCol": "3",
      "endLine": "1152",
      "endCol": "47"
    },
    "1087": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1153",
      "startCol": "27",
      "endLine": "1153",
      "endCol": "70"
    },
    "1088": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1154",
      "startCol": "3",
      "endLine": "1154",
      "endCol": "57"
    },
    "1089": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1156",
      "startCol": "3",
      "endLine": "1156",
      "endCol": "58"
    },
    "1090": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1162",
      "startCol": "3",
      "endLine": "1162",
      "endCol": "52"
    },
    "1091": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1174",
      "startCol": "3",
      "endLine": "1174",
      "endCol": "121"
    },
    "1092": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1189",
      "startCol": "23",
      "endLine": "1189",
      "endCol": "51"
    },
    "1093": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1190",
      "startCol": "24",
      "endLine": "1190",
      "endCol": "68"
    },
    "1094": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1191",
      "startCol": "3",
      "endLine": "1191",
      "endCol": "47"
    },
    "1095": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1192",
      "startCol": "10",
      "endLine": "1192",
      "endCol": "51"
    },
    "1096": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1193",
      "startCol": "3",
      "endLine": "1193",
      "endCol": "52"
    },
    "1097": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1194",
      "startCol": "3",
      "endLine": "1194",
      "endCol": "52"
    },
    "1098": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1195",
      "startCol": "15",
      "endLine": "1195",
      "endCol": "52"
    },
    "1099": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1207",
      "startCol": "3",
      "endLine": "1207",
      "endCol": "66"
    },
    "1100": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1208",
      "startCol": "10",
      "endLine": "1208",
      "endCol": "46"
    },
    "1101": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1221",
      "startCol": "24",
      "endLine": "1221",
      "endCol": "77"
    },
    "1102": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1224",
      "startCol": "21",
      "endLine": "1224",
      "endCol": "169"
    },
    "1103": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1225",
      "startCol": "3",
      "endLine": "1225",
      "endCol": "35"
    },
    "1104": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1227",
      "startCol": "22",
      "endLine": "1227",
      "endCol": "62"
    },
    "1105": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1228",
      "startCol": "3",
      "endLine": "1228",
      "endCol": "51"
    },
    "1106": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1234",
      "startCol": "3",
      "endLine": "1234",
      "endCol": "59"
    },
    "1107": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1236",
      "startCol": "10",
      "endLine": "1236",
      "endCol": "46"
    },
    "1108": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1237",
      "startCol": "3",
      "endLine": "1237",
      "endCol": "62"
    },
    "1109": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1238",
      "startCol": "3",
      "endLine": "1238",
      "endCol": "64"
    },
    "1110": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1239",
      "startCol": "10",
      "endLine": "1239",
      "endCol": "46"
    },
    "1111": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1246",
      "startCol": "25",
      "endLine": "1246",
      "endCol": "92"
    },
    "1112": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1247",
      "startCol": "33",
      "endLine": "1247",
      "endCol": "72"
    },
    "1113": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1258",
      "startCol": "3",
      "endLine": "1258",
      "endCol": "50"
    },
    "1114": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1260",
      "startCol": "3",
      "endLine": "1260",
      "endCol": "63"
    },
    "1115": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1262",
      "startCol": "20",
      "endLine": "1262",
      "endCol": "67"
    },
    "1116": {
      "patternID": "pattern3",
      "file": "test/source/tests/compose.ts",
      "startLine": "1263",
      "startCol": "24",
      "endLine": "1263",
      "endCol": "46"
    },
    "1117": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "277",
      "startCol": "28",
      "endLine": "277",
      "endCol": "81"
    },
    "1118": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "290",
      "startCol": "25",
      "endLine": "290",
      "endCol": "147"
    },
    "1119": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "291",
      "startCol": "7",
      "endLine": "291",
      "endCol": "39"
    },
    "1120": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "292",
      "startCol": "24",
      "endLine": "292",
      "endCol": "66"
    },
    "1121": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "293",
      "startCol": "7",
      "endLine": "293",
      "endCol": "49"
    },
    "1122": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "294",
      "startCol": "20",
      "endLine": "294",
      "endCol": "82"
    },
    "1123": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "301",
      "startCol": "25",
      "endLine": "301",
      "endCol": "147"
    },
    "1124": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "302",
      "startCol": "7",
      "endLine": "302",
      "endCol": "39"
    },
    "1125": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "303",
      "startCol": "24",
      "endLine": "303",
      "endCol": "66"
    },
    "1126": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "304",
      "startCol": "7",
      "endLine": "304",
      "endCol": "49"
    },
    "1127": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "305",
      "startCol": "20",
      "endLine": "305",
      "endCol": "82"
    },
    "1128": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "312",
      "startCol": "25",
      "endLine": "312",
      "endCol": "147"
    },
    "1129": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "313",
      "startCol": "7",
      "endLine": "313",
      "endCol": "39"
    },
    "1130": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "314",
      "startCol": "24",
      "endLine": "314",
      "endCol": "66"
    },
    "1131": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "315",
      "startCol": "7",
      "endLine": "315",
      "endCol": "49"
    },
    "1132": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "316",
      "startCol": "20",
      "endLine": "316",
      "endCol": "82"
    },
    "1133": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "323",
      "startCol": "25",
      "endLine": "323",
      "endCol": "147"
    },
    "1134": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "324",
      "startCol": "7",
      "endLine": "324",
      "endCol": "55"
    },
    "1135": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "325",
      "startCol": "20",
      "endLine": "325",
      "endCol": "113"
    },
    "1136": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "335",
      "startCol": "25",
      "endLine": "335",
      "endCol": "147"
    },
    "1137": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "336",
      "startCol": "7",
      "endLine": "336",
      "endCol": "55"
    },
    "1138": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "337",
      "startCol": "20",
      "endLine": "337",
      "endCol": "98"
    },
    "1139": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "347",
      "startCol": "25",
      "endLine": "347",
      "endCol": "147"
    },
    "1140": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "348",
      "startCol": "7",
      "endLine": "348",
      "endCol": "55"
    },
    "1141": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "349",
      "startCol": "20",
      "endLine": "349",
      "endCol": "113"
    },
    "1142": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "364",
      "startCol": "24",
      "endLine": "364",
      "endCol": "60"
    },
    "1143": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "365",
      "startCol": "7",
      "endLine": "365",
      "endCol": "56"
    },
    "1144": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "367",
      "startCol": "7",
      "endLine": "367",
      "endCol": "28"
    },
    "1145": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "403",
      "startCol": "24",
      "endLine": "403",
      "endCol": "60"
    },
    "1146": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "404",
      "startCol": "7",
      "endLine": "404",
      "endCol": "51"
    },
    "1147": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "405",
      "startCol": "15",
      "endLine": "405",
      "endCol": "56"
    },
    "1148": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "406",
      "startCol": "7",
      "endLine": "406",
      "endCol": "49"
    },
    "1149": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "408",
      "startCol": "7",
      "endLine": "408",
      "endCol": "28"
    },
    "1150": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "413",
      "startCol": "24",
      "endLine": "413",
      "endCol": "60"
    },
    "1151": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "415",
      "startCol": "7",
      "endLine": "415",
      "endCol": "54"
    },
    "1152": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "416",
      "startCol": "15",
      "endLine": "416",
      "endCol": "58"
    },
    "1153": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "417",
      "startCol": "7",
      "endLine": "417",
      "endCol": "28"
    },
    "1154": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "428",
      "startCol": "25",
      "endLine": "428",
      "endCol": "155"
    },
    "1155": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "429",
      "startCol": "7",
      "endLine": "429",
      "endCol": "49"
    },
    "1156": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "430",
      "startCol": "24",
      "endLine": "430",
      "endCol": "66"
    },
    "1157": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "431",
      "startCol": "7",
      "endLine": "431",
      "endCol": "49"
    },
    "1158": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "432",
      "startCol": "23",
      "endLine": "432",
      "endCol": "55"
    },
    "1159": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "437",
      "startCol": "25",
      "endLine": "437",
      "endCol": "155"
    },
    "1160": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "438",
      "startCol": "7",
      "endLine": "438",
      "endCol": "49"
    },
    "1161": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "439",
      "startCol": "24",
      "endLine": "439",
      "endCol": "66"
    },
    "1162": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "440",
      "startCol": "7",
      "endLine": "440",
      "endCol": "49"
    },
    "1163": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "441",
      "startCol": "27",
      "endLine": "441",
      "endCol": "63"
    },
    "1164": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "446",
      "startCol": "25",
      "endLine": "446",
      "endCol": "155"
    },
    "1165": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "447",
      "startCol": "7",
      "endLine": "447",
      "endCol": "49"
    },
    "1166": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "448",
      "startCol": "24",
      "endLine": "448",
      "endCol": "66"
    },
    "1167": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "449",
      "startCol": "7",
      "endLine": "449",
      "endCol": "49"
    },
    "1168": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "450",
      "startCol": "7",
      "endLine": "450",
      "endCol": "31"
    },
    "1169": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "452",
      "startCol": "29",
      "endLine": "452",
      "endCol": "57"
    },
    "1170": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "453",
      "startCol": "7",
      "endLine": "453",
      "endCol": "49"
    },
    "1171": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "456",
      "startCol": "7",
      "endLine": "456",
      "endCol": "97"
    },
    "1172": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "461",
      "startCol": "27",
      "endLine": "461",
      "endCol": "5151"
    },
    "1173": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "462",
      "startCol": "28",
      "endLine": "462",
      "endCol": "72"
    },
    "1174": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "463",
      "startCol": "7",
      "endLine": "463",
      "endCol": "53"
    },
    "1175": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "464",
      "startCol": "14",
      "endLine": "464",
      "endCol": "65"
    },
    "1176": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "468",
      "startCol": "27",
      "endLine": "468",
      "endCol": "8121"
    },
    "1177": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "469",
      "startCol": "28",
      "endLine": "469",
      "endCol": "72"
    },
    "1178": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "470",
      "startCol": "7",
      "endLine": "470",
      "endCol": "53"
    },
    "1179": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "471",
      "startCol": "14",
      "endLine": "471",
      "endCol": "65"
    },
    "1180": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "478",
      "startCol": "27",
      "endLine": "478",
      "endCol": "94"
    },
    "1181": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "479",
      "startCol": "28",
      "endLine": "479",
      "endCol": "72"
    },
    "1182": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "480",
      "startCol": "7",
      "endLine": "480",
      "endCol": "56"
    },
    "1183": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "481",
      "startCol": "7",
      "endLine": "481",
      "endCol": "94"
    },
    "1184": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "486",
      "startCol": "27",
      "endLine": "486",
      "endCol": "94"
    },
    "1185": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "487",
      "startCol": "28",
      "endLine": "487",
      "endCol": "72"
    },
    "1186": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "488",
      "startCol": "7",
      "endLine": "488",
      "endCol": "56"
    },
    "1187": {
      "patternID": "pattern3",
      "file": "test/source/tests/decrypt.ts",
      "startLine": "489",
      "startCol": "7",
      "endLine": "489",
      "endCol": "94"
    },
    "1188": {
      "patternID": "pattern3",
      "file": "test/source/tests/elements.ts",
      "startLine": "19",
      "startCol": "20",
      "endLine": "19",
      "endCol": "48"
    },
    "1189": {
      "patternID": "pattern3",
      "file": "test/source/tests/elements.ts",
      "startLine": "20",
      "startCol": "7",
      "endLine": "20",
      "endCol": "84"
    },
    "1190": {
      "patternID": "pattern3",
      "file": "test/source/tests/elements.ts",
      "startLine": "21",
      "startCol": "7",
      "endLine": "21",
      "endCol": "79"
    },
    "1191": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "30",
      "startCol": "7",
      "endLine": "30",
      "endCol": "82"
    },
    "1192": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "31",
      "startCol": "7",
      "endLine": "31",
      "endCol": "78"
    },
    "1193": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "32",
      "startCol": "7",
      "endLine": "32",
      "endCol": "79"
    },
    "1194": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "33",
      "startCol": "7",
      "endLine": "33",
      "endCol": "78"
    },
    "1195": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "34",
      "startCol": "7",
      "endLine": "34",
      "endCol": "70"
    },
    "1196": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "35",
      "startCol": "7",
      "endLine": "35",
      "endCol": "162"
    },
    "1197": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "36",
      "startCol": "7",
      "endLine": "36",
      "endCol": "32"
    },
    "1198": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "40",
      "startCol": "7",
      "endLine": "40",
      "endCol": "52"
    },
    "1199": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "41",
      "startCol": "7",
      "endLine": "41",
      "endCol": "142"
    },
    "1200": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "42",
      "startCol": "41",
      "endLine": "42",
      "endCol": "129"
    },
    "1201": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "43",
      "startCol": "20",
      "endLine": "43",
      "endCol": "87"
    },
    "1202": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "44",
      "startCol": "7",
      "endLine": "44",
      "endCol": "31"
    },
    "1203": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "45",
      "startCol": "7",
      "endLine": "45",
      "endCol": "45"
    },
    "1204": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "47",
      "startCol": "29",
      "endLine": "47",
      "endCol": "61"
    },
    "1205": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "48",
      "startCol": "7",
      "endLine": "48",
      "endCol": "65"
    },
    "1206": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "49",
      "startCol": "7",
      "endLine": "49",
      "endCol": "61"
    },
    "1207": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "50",
      "startCol": "7",
      "endLine": "50",
      "endCol": "60"
    },
    "1208": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "52",
      "startCol": "7",
      "endLine": "52",
      "endCol": "33"
    },
    "1209": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "78",
      "startCol": "7",
      "endLine": "78",
      "endCol": "87"
    },
    "1210": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "86",
      "startCol": "25",
      "endLine": "86",
      "endCol": "70"
    },
    "1211": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "87",
      "startCol": "7",
      "endLine": "87",
      "endCol": "137"
    },
    "1212": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "94",
      "startCol": "25",
      "endLine": "94",
      "endCol": "70"
    },
    "1213": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "95",
      "startCol": "7",
      "endLine": "95",
      "endCol": "59"
    },
    "1214": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "105",
      "startCol": "25",
      "endLine": "105",
      "endCol": "70"
    },
    "1215": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "106",
      "startCol": "7",
      "endLine": "106",
      "endCol": "59"
    },
    "1216": {
      "patternID": "pattern3",
      "file": "test/source/tests/flaky.ts",
      "startLine": "119",
      "startCol": "22",
      "endLine": "119",
      "endCol": "51"
    },
    "1217": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "28",
      "startCol": "20",
      "endLine": "28",
      "endCol": "96"
    },
    "1218": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "31",
      "startCol": "26",
      "endLine": "31",
      "endCol": "58"
    },
    "1219": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "33",
      "startCol": "11",
      "endLine": "33",
      "endCol": "48"
    },
    "1220": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "34",
      "startCol": "11",
      "endLine": "34",
      "endCol": "66"
    },
    "1221": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "36",
      "startCol": "11",
      "endLine": "36",
      "endCol": "63"
    },
    "1222": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "37",
      "startCol": "11",
      "endLine": "37",
      "endCol": "51"
    },
    "1223": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "39",
      "startCol": "9",
      "endLine": "39",
      "endCol": "30"
    },
    "1224": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "44",
      "startCol": "7",
      "endLine": "44",
      "endCol": "39"
    },
    "1225": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "45",
      "startCol": "20",
      "endLine": "45",
      "endCol": "82"
    },
    "1226": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "47",
      "startCol": "24",
      "endLine": "47",
      "endCol": "56"
    },
    "1227": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "49",
      "startCol": "9",
      "endLine": "49",
      "endCol": "69"
    },
    "1228": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "51",
      "startCol": "9",
      "endLine": "51",
      "endCol": "45"
    },
    "1229": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "57",
      "startCol": "20",
      "endLine": "57",
      "endCol": "96"
    },
    "1230": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "63",
      "startCol": "25",
      "endLine": "63",
      "endCol": "53"
    },
    "1231": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "64",
      "startCol": "7",
      "endLine": "64",
      "endCol": "55"
    },
    "1232": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "66",
      "startCol": "9",
      "endLine": "66",
      "endCol": "33"
    },
    "1233": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "73",
      "startCol": "7",
      "endLine": "73",
      "endCol": "32"
    },
    "1234": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "75",
      "startCol": "7",
      "endLine": "75",
      "endCol": "174"
    },
    "1235": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "76",
      "startCol": "7",
      "endLine": "76",
      "endCol": "93"
    },
    "1236": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "77",
      "startCol": "7",
      "endLine": "77",
      "endCol": "29"
    },
    "1237": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "79",
      "startCol": "7",
      "endLine": "79",
      "endCol": "174"
    },
    "1238": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "80",
      "startCol": "31",
      "endLine": "80",
      "endCol": "139"
    },
    "1239": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "81",
      "startCol": "7",
      "endLine": "81",
      "endCol": "63"
    },
    "1240": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "87",
      "startCol": "7",
      "endLine": "87",
      "endCol": "105"
    },
    "1241": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "88",
      "startCol": "7",
      "endLine": "88",
      "endCol": "106"
    },
    "1242": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "89",
      "startCol": "7",
      "endLine": "89",
      "endCol": "29"
    },
    "1243": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "91",
      "startCol": "7",
      "endLine": "91",
      "endCol": "144"
    },
    "1244": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "92",
      "startCol": "7",
      "endLine": "92",
      "endCol": "29"
    },
    "1245": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "95",
      "startCol": "30",
      "endLine": "95",
      "endCol": "87"
    },
    "1246": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "98",
      "startCol": "9",
      "endLine": "98",
      "endCol": "66"
    },
    "1247": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "100",
      "startCol": "9",
      "endLine": "100",
      "endCol": "34"
    },
    "1248": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "102",
      "startCol": "28",
      "endLine": "102",
      "endCol": "85"
    },
    "1249": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "103",
      "startCol": "7",
      "endLine": "103",
      "endCol": "125"
    },
    "1250": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "107",
      "startCol": "7",
      "endLine": "107",
      "endCol": "60"
    },
    "1251": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "108",
      "startCol": "7",
      "endLine": "108",
      "endCol": "85"
    },
    "1252": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "110",
      "startCol": "14",
      "endLine": "110",
      "endCol": "58"
    },
    "1253": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "111",
      "startCol": "26",
      "endLine": "111",
      "endCol": "119"
    },
    "1254": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "113",
      "startCol": "7",
      "endLine": "113",
      "endCol": "56"
    },
    "1255": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "115",
      "startCol": "14",
      "endLine": "115",
      "endCol": "58"
    },
    "1256": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "116",
      "startCol": "7",
      "endLine": "116",
      "endCol": "29"
    },
    "1257": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "119",
      "startCol": "7",
      "endLine": "119",
      "endCol": "60"
    },
    "1258": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "121",
      "startCol": "7",
      "endLine": "121",
      "endCol": "59"
    },
    "1259": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "127",
      "startCol": "7",
      "endLine": "127",
      "endCol": "174"
    },
    "1260": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "128",
      "startCol": "7",
      "endLine": "128",
      "endCol": "95"
    },
    "1261": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "129",
      "startCol": "7",
      "endLine": "129",
      "endCol": "29"
    },
    "1262": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "131",
      "startCol": "7",
      "endLine": "131",
      "endCol": "177"
    },
    "1263": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "140",
      "startCol": "7",
      "endLine": "140",
      "endCol": "59"
    },
    "1264": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "141",
      "startCol": "7",
      "endLine": "141",
      "endCol": "50"
    },
    "1265": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "142",
      "startCol": "7",
      "endLine": "142",
      "endCol": "89"
    },
    "1266": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "143",
      "startCol": "20",
      "endLine": "143",
      "endCol": "98"
    },
    "1267": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "150",
      "startCol": "7",
      "endLine": "150",
      "endCol": "95"
    },
    "1268": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "151",
      "startCol": "7",
      "endLine": "151",
      "endCol": "36"
    },
    "1269": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "153",
      "startCol": "7",
      "endLine": "153",
      "endCol": "47"
    },
    "1270": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "154",
      "startCol": "7",
      "endLine": "154",
      "endCol": "36"
    },
    "1271": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "158",
      "startCol": "20",
      "endLine": "158",
      "endCol": "98"
    },
    "1272": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "159",
      "startCol": "28",
      "endLine": "159",
      "endCol": "51"
    },
    "1273": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "160",
      "startCol": "7",
      "endLine": "160",
      "endCol": "50"
    },
    "1274": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "161",
      "startCol": "7",
      "endLine": "161",
      "endCol": "43"
    },
    "1275": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "162",
      "startCol": "7",
      "endLine": "162",
      "endCol": "97"
    },
    "1276": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "167",
      "startCol": "20",
      "endLine": "167",
      "endCol": "113"
    },
    "1277": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "176",
      "startCol": "20",
      "endLine": "176",
      "endCol": "113"
    },
    "1278": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "186",
      "startCol": "20",
      "endLine": "186",
      "endCol": "114"
    },
    "1279": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "191",
      "startCol": "26",
      "endLine": "191",
      "endCol": "58"
    },
    "1280": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "192",
      "startCol": "7",
      "endLine": "192",
      "endCol": "128"
    },
    "1281": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "197",
      "startCol": "20",
      "endLine": "197",
      "endCol": "113"
    },
    "1282": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "209",
      "startCol": "20",
      "endLine": "209",
      "endCol": "114"
    },
    "1283": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "212",
      "startCol": "26",
      "endLine": "212",
      "endCol": "58"
    },
    "1284": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "213",
      "startCol": "7",
      "endLine": "213",
      "endCol": "128"
    },
    "1285": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "218",
      "startCol": "20",
      "endLine": "218",
      "endCol": "114"
    },
    "1286": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "221",
      "startCol": "26",
      "endLine": "221",
      "endCol": "58"
    },
    "1287": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "222",
      "startCol": "7",
      "endLine": "222",
      "endCol": "128"
    },
    "1288": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "230",
      "startCol": "7",
      "endLine": "230",
      "endCol": "58"
    },
    "1289": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "232",
      "startCol": "7",
      "endLine": "232",
      "endCol": "53"
    },
    "1290": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "234",
      "startCol": "7",
      "endLine": "234",
      "endCol": "35"
    },
    "1291": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "237",
      "startCol": "7",
      "endLine": "237",
      "endCol": "49"
    },
    "1292": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "239",
      "startCol": "7",
      "endLine": "239",
      "endCol": "28"
    },
    "1293": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "240",
      "startCol": "7",
      "endLine": "240",
      "endCol": "35"
    },
    "1294": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "241",
      "startCol": "7",
      "endLine": "241",
      "endCol": "71"
    },
    "1295": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "242",
      "startCol": "7",
      "endLine": "242",
      "endCol": "109"
    },
    "1296": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "249",
      "startCol": "7",
      "endLine": "249",
      "endCol": "60"
    },
    "1297": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "250",
      "startCol": "7",
      "endLine": "250",
      "endCol": "82"
    },
    "1298": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "252",
      "startCol": "7",
      "endLine": "252",
      "endCol": "60"
    },
    "1299": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "255",
      "startCol": "7",
      "endLine": "255",
      "endCol": "55"
    },
    "1300": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "256",
      "startCol": "7",
      "endLine": "256",
      "endCol": "169"
    },
    "1301": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "257",
      "startCol": "7",
      "endLine": "257",
      "endCol": "67"
    },
    "1302": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "260",
      "startCol": "7",
      "endLine": "260",
      "endCol": "82"
    },
    "1303": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "262",
      "startCol": "7",
      "endLine": "262",
      "endCol": "60"
    },
    "1304": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "264",
      "startCol": "7",
      "endLine": "264",
      "endCol": "80"
    },
    "1305": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "269",
      "startCol": "7",
      "endLine": "269",
      "endCol": "60"
    },
    "1306": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "271",
      "startCol": "7",
      "endLine": "271",
      "endCol": "81"
    },
    "1307": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "272",
      "startCol": "7",
      "endLine": "272",
      "endCol": "49"
    },
    "1308": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "274",
      "startCol": "7",
      "endLine": "274",
      "endCol": "82"
    },
    "1309": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "276",
      "startCol": "7",
      "endLine": "276",
      "endCol": "85"
    },
    "1310": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "277",
      "startCol": "7",
      "endLine": "277",
      "endCol": "60"
    },
    "1311": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "282",
      "startCol": "20",
      "endLine": "282",
      "endCol": "114"
    },
    "1312": {
      "patternID": "pattern3",
      "file": "test/source/tests/gmail.ts",
      "startLine": "318",
      "startCol": "23",
      "endLine": "318",
      "endCol": "87"
    },
    "1313": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/abstract-page-recipe.ts",
      "startLine": "14",
      "startCol": "12",
      "endLine": "14",
      "endCol": "75"
    },
    "1314": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/abstract-page-recipe.ts",
      "startLine": "14",
      "startCol": "19",
      "endLine": "14",
      "endCol": "50"
    },
    "1315": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/abstract-page-recipe.ts",
      "startLine": "18",
      "startCol": "28",
      "endLine": "18",
      "endCol": "87"
    },
    "1316": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/abstract-page-recipe.ts",
      "startLine": "20",
      "startCol": "30",
      "endLine": "20",
      "endCol": "76"
    },
    "1317": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/abstract-page-recipe.ts",
      "startLine": "24",
      "startCol": "22",
      "endLine": "24",
      "endCol": "81"
    },
    "1318": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/abstract-page-recipe.ts",
      "startLine": "25",
      "startCol": "7",
      "endLine": "25",
      "endCol": "27"
    },
    "1319": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/abstract-page-recipe.ts",
      "startLine": "35",
      "startCol": "12",
      "endLine": "35",
      "endCol": "118"
    },
    "1320": {
      "patternID": "pattern1",
      "file": "test/source/tests/page-recipe/abstract-page-recipe.ts",
      "startLine": "32",
      "startCol": "3",
      "endLine": "36",
      "endCol": "3"
    },
    "1321": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "30",
      "startCol": "25",
      "endLine": "31",
      "endCol": "28"
    },
    "1322": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "35",
      "startCol": "9",
      "endLine": "35",
      "endCol": "84"
    },
    "1323": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "36",
      "startCol": "9",
      "endLine": "36",
      "endCol": "105"
    },
    "1324": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "41",
      "startCol": "11",
      "endLine": "41",
      "endCol": "68"
    },
    "1325": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "44",
      "startCol": "7",
      "endLine": "44",
      "endCol": "52"
    },
    "1326": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "59",
      "startCol": "7",
      "endLine": "59",
      "endCol": "54"
    },
    "1327": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "61",
      "startCol": "7",
      "endLine": "61",
      "endCol": "127"
    },
    "1328": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "71",
      "startCol": "5",
      "endLine": "71",
      "endCol": "54"
    },
    "1329": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "76",
      "startCol": "5",
      "endLine": "76",
      "endCol": "73"
    },
    "1330": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "77",
      "startCol": "5",
      "endLine": "77",
      "endCol": "66"
    },
    "1331": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "78",
      "startCol": "31",
      "endLine": "78",
      "endCol": "99"
    },
    "1332": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "80",
      "startCol": "7",
      "endLine": "80",
      "endCol": "68"
    },
    "1333": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "82",
      "startCol": "7",
      "endLine": "82",
      "endCol": "58"
    },
    "1334": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "84",
      "startCol": "5",
      "endLine": "84",
      "endCol": "71"
    },
    "1335": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "89",
      "startCol": "7",
      "endLine": "89",
      "endCol": "84"
    },
    "1336": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "91",
      "startCol": "5",
      "endLine": "91",
      "endCol": "65"
    },
    "1337": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "97",
      "startCol": "11",
      "endLine": "97",
      "endCol": "78"
    },
    "1338": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "99",
      "startCol": "9",
      "endLine": "99",
      "endCol": "76"
    },
    "1339": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "103",
      "startCol": "5",
      "endLine": "103",
      "endCol": "81"
    },
    "1340": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "108",
      "startCol": "5",
      "endLine": "108",
      "endCol": "90"
    },
    "1341": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "112",
      "startCol": "5",
      "endLine": "112",
      "endCol": "114"
    },
    "1342": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "120",
      "startCol": "7",
      "endLine": "120",
      "endCol": "64"
    },
    "1343": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "122",
      "startCol": "5",
      "endLine": "122",
      "endCol": "64"
    },
    "1344": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "124",
      "startCol": "7",
      "endLine": "124",
      "endCol": "67"
    },
    "1345": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "130",
      "startCol": "5",
      "endLine": "133",
      "endCol": "6"
    },
    "1346": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/compose-page-recipe.ts",
      "startLine": "134",
      "startCol": "5",
      "endLine": "134",
      "endCol": "29"
    },
    "1347": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "13",
      "startCol": "5",
      "endLine": "13",
      "endCol": "72"
    },
    "1348": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "14",
      "startCol": "5",
      "endLine": "14",
      "endCol": "53"
    },
    "1349": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "15",
      "startCol": "18",
      "endLine": "15",
      "endCol": "94"
    },
    "1350": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "17",
      "startCol": "12",
      "endLine": "17",
      "endCol": "69"
    },
    "1351": {
      "patternID": "pattern1",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "12",
      "startCol": "37",
      "endLine": "18",
      "endCol": "3"
    },
    "1352": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "21",
      "startCol": "5",
      "endLine": "21",
      "endCol": "48"
    },
    "1353": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "22",
      "startCol": "18",
      "endLine": "22",
      "endCol": "96"
    },
    "1354": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "24",
      "startCol": "12",
      "endLine": "24",
      "endCol": "44"
    },
    "1355": {
      "patternID": "pattern1",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "20",
      "startCol": "38",
      "endLine": "25",
      "endCol": "3"
    },
    "1356": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "28",
      "startCol": "5",
      "endLine": "28",
      "endCol": "81"
    },
    "1357": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "33",
      "startCol": "5",
      "endLine": "33",
      "endCol": "47"
    },
    "1358": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "35",
      "startCol": "7",
      "endLine": "35",
      "endCol": "34"
    },
    "1359": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "37",
      "startCol": "5",
      "endLine": "37",
      "endCol": "45"
    },
    "1360": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "38",
      "startCol": "5",
      "endLine": "38",
      "endCol": "57"
    },
    "1361": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "43",
      "startCol": "5",
      "endLine": "43",
      "endCol": "55"
    },
    "1362": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "44",
      "startCol": "5",
      "endLine": "44",
      "endCol": "41"
    },
    "1363": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/gmail-page-recipe.ts",
      "startLine": "45",
      "startCol": "5",
      "endLine": "45",
      "endCol": "34"
    },
    "1364": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "16",
      "startCol": "23",
      "endLine": "16",
      "endCol": "145"
    },
    "1365": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "17",
      "startCol": "5",
      "endLine": "17",
      "endCol": "37"
    },
    "1366": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "19",
      "startCol": "7",
      "endLine": "19",
      "endCol": "60"
    },
    "1367": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "21",
      "startCol": "7",
      "endLine": "21",
      "endCol": "39"
    },
    "1368": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "23",
      "startCol": "27",
      "endLine": "23",
      "endCol": "69"
    },
    "1369": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "24",
      "startCol": "5",
      "endLine": "24",
      "endCol": "53"
    },
    "1370": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "25",
      "startCol": "5",
      "endLine": "25",
      "endCol": "52"
    },
    "1371": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "27",
      "startCol": "7",
      "endLine": "27",
      "endCol": "58"
    },
    "1372": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "28",
      "startCol": "7",
      "endLine": "28",
      "endCol": "86"
    },
    "1373": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "29",
      "startCol": "7",
      "endLine": "29",
      "endCol": "51"
    },
    "1374": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "30",
      "startCol": "23",
      "endLine": "30",
      "endCol": "66"
    },
    "1375": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "31",
      "startCol": "7",
      "endLine": "31",
      "endCol": "62"
    },
    "1376": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "32",
      "startCol": "7",
      "endLine": "32",
      "endCol": "83"
    },
    "1377": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "33",
      "startCol": "7",
      "endLine": "33",
      "endCol": "54"
    },
    "1378": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "34",
      "startCol": "7",
      "endLine": "34",
      "endCol": "55"
    },
    "1379": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "37",
      "startCol": "21",
      "endLine": "37",
      "endCol": "66"
    },
    "1380": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "41",
      "startCol": "5",
      "endLine": "41",
      "endCol": "27"
    },
    "1381": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "45",
      "startCol": "23",
      "endLine": "45",
      "endCol": "145"
    },
    "1382": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "46",
      "startCol": "5",
      "endLine": "46",
      "endCol": "37"
    },
    "1383": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "47",
      "startCol": "5",
      "endLine": "47",
      "endCol": "58"
    },
    "1384": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "48",
      "startCol": "5",
      "endLine": "48",
      "endCol": "58"
    },
    "1385": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "50",
      "startCol": "27",
      "endLine": "50",
      "endCol": "69"
    },
    "1386": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "53"
    },
    "1387": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "52",
      "startCol": "5",
      "endLine": "52",
      "endCol": "52"
    },
    "1388": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "53",
      "startCol": "5",
      "endLine": "53",
      "endCol": "84"
    },
    "1389": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "54",
      "startCol": "5",
      "endLine": "54",
      "endCol": "49"
    },
    "1390": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "67",
      "startCol": "23",
      "endLine": "67",
      "endCol": "137"
    },
    "1391": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "68",
      "startCol": "5",
      "endLine": "68",
      "endCol": "80"
    },
    "1392": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "70",
      "startCol": "7",
      "endLine": "70",
      "endCol": "65"
    },
    "1393": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "72",
      "startCol": "5",
      "endLine": "72",
      "endCol": "27"
    },
    "1394": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "76",
      "startCol": "5",
      "endLine": "76",
      "endCol": "70"
    },
    "1395": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "77",
      "startCol": "5",
      "endLine": "77",
      "endCol": "53"
    },
    "1396": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "79",
      "startCol": "26",
      "endLine": "79",
      "endCol": "66"
    },
    "1397": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "80",
      "startCol": "5",
      "endLine": "80",
      "endCol": "110"
    },
    "1398": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/inbox-page-recipe.ts",
      "startLine": "81",
      "startCol": "5",
      "endLine": "81",
      "endCol": "51"
    },
    "1399": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "20",
      "startCol": "11",
      "endLine": "20",
      "endCol": "33"
    },
    "1400": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "22",
      "startCol": "11",
      "endLine": "22",
      "endCol": "118"
    },
    "1401": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "24",
      "startCol": "11",
      "endLine": "24",
      "endCol": "69"
    },
    "1402": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "45",
      "startCol": "7",
      "endLine": "45",
      "endCol": "124"
    },
    "1403": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "46",
      "startCol": "11",
      "endLine": "46",
      "endCol": "57"
    },
    "1404": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "47",
      "startCol": "9",
      "endLine": "47",
      "endCol": "96"
    },
    "1405": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "48",
      "startCol": "9",
      "endLine": "48",
      "endCol": "83"
    },
    "1406": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "49",
      "startCol": "9",
      "endLine": "49",
      "endCol": "79"
    },
    "1407": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "50",
      "startCol": "9",
      "endLine": "50",
      "endCol": "48"
    },
    "1408": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "51",
      "startCol": "18",
      "endLine": "51",
      "endCol": "90"
    },
    "1409": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "52",
      "startCol": "9",
      "endLine": "52",
      "endCol": "99"
    },
    "1410": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "53",
      "startCol": "18",
      "endLine": "53",
      "endCol": "52"
    },
    "1411": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "54",
      "startCol": "9",
      "endLine": "54",
      "endCol": "61"
    },
    "1412": {
      "patternID": "pattern1",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "13",
      "startCol": "26",
      "endLine": "98",
      "endCol": "3"
    },
    "1413": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "57",
      "startCol": "18",
      "endLine": "57",
      "endCol": "83"
    },
    "1414": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "59",
      "startCol": "22",
      "endLine": "59",
      "endCol": "71"
    },
    "1415": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "60",
      "startCol": "9",
      "endLine": "60",
      "endCol": "34"
    },
    "1416": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "70",
      "startCol": "7",
      "endLine": "70",
      "endCol": "83"
    },
    "1417": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "71",
      "startCol": "11",
      "endLine": "71",
      "endCol": "68"
    },
    "1418": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "72",
      "startCol": "9",
      "endLine": "72",
      "endCol": "72"
    },
    "1419": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "74",
      "startCol": "11",
      "endLine": "74",
      "endCol": "77"
    },
    "1420": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "76",
      "startCol": "9",
      "endLine": "76",
      "endCol": "63"
    },
    "1421": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "77",
      "startCol": "9",
      "endLine": "77",
      "endCol": "48"
    },
    "1422": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "80",
      "startCol": "7",
      "endLine": "80",
      "endCol": "55"
    },
    "1423": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "84",
      "startCol": "9",
      "endLine": "84",
      "endCol": "31"
    },
    "1424": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/oauth-page-recipe.ts",
      "startLine": "88",
      "startCol": "9",
      "endLine": "88",
      "endCol": "76"
    },
    "1425": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "17",
      "startCol": "5",
      "endLine": "17",
      "endCol": "48"
    },
    "1426": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "18",
      "startCol": "5",
      "endLine": "18",
      "endCol": "51"
    },
    "1427": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "24",
      "startCol": "5",
      "endLine": "24",
      "endCol": "120"
    },
    "1428": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "26",
      "startCol": "5",
      "endLine": "26",
      "endCol": "115"
    },
    "1429": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "31",
      "startCol": "5",
      "endLine": "31",
      "endCol": "66"
    },
    "1430": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "32",
      "startCol": "5",
      "endLine": "32",
      "endCol": "46"
    },
    "1431": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "37",
      "startCol": "5",
      "endLine": "37",
      "endCol": "49"
    },
    "1432": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "38",
      "startCol": "5",
      "endLine": "38",
      "endCol": "41"
    },
    "1433": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "39",
      "startCol": "12",
      "endLine": "39",
      "endCol": "54"
    },
    "1434": {
      "patternID": "pattern1",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "35",
      "startCol": "37",
      "endLine": "40",
      "endCol": "3"
    },
    "1435": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "44",
      "startCol": "5",
      "endLine": "44",
      "endCol": "67"
    },
    "1436": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "45",
      "startCol": "5",
      "endLine": "45",
      "endCol": "78"
    },
    "1437": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "85"
    },
    "1438": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "53",
      "startCol": "7",
      "endLine": "53",
      "endCol": "83"
    },
    "1439": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "54",
      "startCol": "7",
      "endLine": "54",
      "endCol": "82"
    },
    "1440": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "56",
      "startCol": "5",
      "endLine": "56",
      "endCol": "73"
    },
    "1441": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "57",
      "startCol": "5",
      "endLine": "57",
      "endCol": "81"
    },
    "1442": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "58",
      "startCol": "5",
      "endLine": "58",
      "endCol": "81"
    },
    "1443": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "59",
      "startCol": "5",
      "endLine": "59",
      "endCol": "76"
    },
    "1444": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "60",
      "startCol": "5",
      "endLine": "60",
      "endCol": "134"
    },
    "1445": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "61",
      "startCol": "5",
      "endLine": "61",
      "endCol": "59"
    },
    "1446": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "62",
      "startCol": "5",
      "endLine": "62",
      "endCol": "70"
    },
    "1447": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "63",
      "startCol": "5",
      "endLine": "63",
      "endCol": "75"
    },
    "1448": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "64",
      "startCol": "5",
      "endLine": "64",
      "endCol": "103"
    },
    "1449": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "65",
      "startCol": "5",
      "endLine": "65",
      "endCol": "116"
    },
    "1450": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "71",
      "startCol": "5",
      "endLine": "71",
      "endCol": "57"
    },
    "1451": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "72",
      "startCol": "5",
      "endLine": "72",
      "endCol": "77"
    },
    "1452": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "73",
      "startCol": "5",
      "endLine": "73",
      "endCol": "86"
    },
    "1453": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "84",
      "startCol": "5",
      "endLine": "84",
      "endCol": "52"
    },
    "1454": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "88",
      "startCol": "12",
      "endLine": "88",
      "endCol": "56"
    },
    "1455": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "96",
      "startCol": "5",
      "endLine": "96",
      "endCol": "69"
    },
    "1456": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "97",
      "startCol": "5",
      "endLine": "97",
      "endCol": "73"
    },
    "1457": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "98",
      "startCol": "5",
      "endLine": "98",
      "endCol": "79"
    },
    "1458": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "100",
      "startCol": "7",
      "endLine": "100",
      "endCol": "82"
    },
    "1459": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "102",
      "startCol": "7",
      "endLine": "102",
      "endCol": "82"
    },
    "1460": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "105",
      "startCol": "5",
      "endLine": "105",
      "endCol": "46"
    },
    "1461": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "109",
      "startCol": "24",
      "endLine": "109",
      "endCol": "138"
    },
    "1462": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "110",
      "startCol": "5",
      "endLine": "110",
      "endCol": "50"
    },
    "1463": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "111",
      "startCol": "5",
      "endLine": "111",
      "endCol": "69"
    },
    "1464": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "112",
      "startCol": "5",
      "endLine": "112",
      "endCol": "61"
    },
    "1465": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "113",
      "startCol": "5",
      "endLine": "113",
      "endCol": "65"
    },
    "1466": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "114",
      "startCol": "5",
      "endLine": "114",
      "endCol": "74"
    },
    "1467": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "115",
      "startCol": "5",
      "endLine": "115",
      "endCol": "53"
    },
    "1468": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "117",
      "startCol": "5",
      "endLine": "117",
      "endCol": "28"
    },
    "1469": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "119",
      "startCol": "26",
      "endLine": "119",
      "endCol": "88"
    },
    "1470": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "121",
      "startCol": "17",
      "endLine": "121",
      "endCol": "50"
    },
    "1471": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "123",
      "startCol": "5",
      "endLine": "123",
      "endCol": "74"
    },
    "1472": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/settings-page-recipe.ts",
      "startLine": "124",
      "startCol": "5",
      "endLine": "124",
      "endCol": "30"
    },
    "1473": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "42",
      "startCol": "14",
      "endLine": "42",
      "endCol": "75"
    },
    "1474": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "43",
      "startCol": "14",
      "endLine": "43",
      "endCol": "80"
    },
    "1475": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "46",
      "startCol": "7",
      "endLine": "46",
      "endCol": "77"
    },
    "1476": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "48",
      "startCol": "7",
      "endLine": "48",
      "endCol": "79"
    },
    "1477": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "50",
      "startCol": "26",
      "endLine": "50",
      "endCol": "103"
    },
    "1478": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "51",
      "startCol": "7",
      "endLine": "51",
      "endCol": "80"
    },
    "1479": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "53",
      "startCol": "5",
      "endLine": "53",
      "endCol": "80"
    },
    "1480": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "54",
      "startCol": "5",
      "endLine": "54",
      "endCol": "113"
    },
    "1481": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "56",
      "startCol": "7",
      "endLine": "56",
      "endCol": "88"
    },
    "1482": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "57",
      "startCol": "7",
      "endLine": "57",
      "endCol": "76"
    },
    "1483": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "61",
      "startCol": "7",
      "endLine": "61",
      "endCol": "71"
    },
    "1484": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "66",
      "startCol": "7",
      "endLine": "66",
      "endCol": "76"
    },
    "1485": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "68",
      "startCol": "9",
      "endLine": "68",
      "endCol": "69"
    },
    "1486": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "69",
      "startCol": "9",
      "endLine": "69",
      "endCol": "106"
    },
    "1487": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "72",
      "startCol": "5",
      "endLine": "72",
      "endCol": "85"
    },
    "1488": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "73",
      "startCol": "5",
      "endLine": "73",
      "endCol": "73"
    },
    "1489": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "97",
      "startCol": "9",
      "endLine": "97",
      "endCol": "105"
    },
    "1490": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "99",
      "startCol": "9",
      "endLine": "99",
      "endCol": "109"
    },
    "1491": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "106",
      "startCol": "7",
      "endLine": "106",
      "endCol": "99"
    },
    "1492": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "107",
      "startCol": "7",
      "endLine": "107",
      "endCol": "87"
    },
    "1493": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "109",
      "startCol": "7",
      "endLine": "109",
      "endCol": "91"
    },
    "1494": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "111",
      "startCol": "25",
      "endLine": "111",
      "endCol": "71"
    },
    "1495": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "112",
      "startCol": "7",
      "endLine": "112",
      "endCol": "47"
    },
    "1496": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "117",
      "startCol": "5",
      "endLine": "117",
      "endCol": "74"
    },
    "1497": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "119",
      "startCol": "7",
      "endLine": "119",
      "endCol": "60"
    },
    "1498": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "122",
      "startCol": "7",
      "endLine": "122",
      "endCol": "81"
    },
    "1499": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "126",
      "startCol": "7",
      "endLine": "126",
      "endCol": "86"
    },
    "1500": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "127",
      "startCol": "7",
      "endLine": "127",
      "endCol": "91"
    },
    "1501": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "130",
      "startCol": "7",
      "endLine": "130",
      "endCol": "76"
    },
    "1502": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "131",
      "startCol": "7",
      "endLine": "131",
      "endCol": "102"
    },
    "1503": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "133",
      "startCol": "9",
      "endLine": "133",
      "endCol": "90"
    },
    "1504": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "135",
      "startCol": "29",
      "endLine": "135",
      "endCol": "91"
    },
    "1505": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "140",
      "startCol": "36",
      "endLine": "140",
      "endCol": "96"
    },
    "1506": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "145",
      "startCol": "9",
      "endLine": "145",
      "endCol": "93"
    },
    "1507": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "149",
      "startCol": "7",
      "endLine": "149",
      "endCol": "77"
    },
    "1508": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "151",
      "startCol": "7",
      "endLine": "151",
      "endCol": "74"
    },
    "1509": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "153",
      "startCol": "9",
      "endLine": "153",
      "endCol": "81"
    },
    "1510": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "156",
      "startCol": "5",
      "endLine": "156",
      "endCol": "63"
    },
    "1511": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "162",
      "startCol": "9",
      "endLine": "162",
      "endCol": "52"
    },
    "1512": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "164",
      "startCol": "7",
      "endLine": "164",
      "endCol": "84"
    },
    "1513": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "166",
      "startCol": "9",
      "endLine": "166",
      "endCol": "75"
    },
    "1514": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "167",
      "startCol": "9",
      "endLine": "167",
      "endCol": "85"
    },
    "1515": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "168",
      "startCol": "9",
      "endLine": "168",
      "endCol": "69"
    },
    "1516": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "171",
      "startCol": "9",
      "endLine": "171",
      "endCol": "158"
    },
    "1517": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "173",
      "startCol": "16",
      "endLine": "173",
      "endCol": "72"
    },
    "1518": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "174",
      "startCol": "9",
      "endLine": "174",
      "endCol": "64"
    },
    "1519": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "175",
      "startCol": "9",
      "endLine": "175",
      "endCol": "64"
    },
    "1520": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "177",
      "startCol": "16",
      "endLine": "177",
      "endCol": "68"
    },
    "1521": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "178",
      "startCol": "16",
      "endLine": "178",
      "endCol": "68"
    },
    "1522": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "179",
      "startCol": "9",
      "endLine": "179",
      "endCol": "53"
    },
    "1523": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "180",
      "startCol": "9",
      "endLine": "180",
      "endCol": "57"
    },
    "1524": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "183",
      "startCol": "7",
      "endLine": "183",
      "endCol": "101"
    },
    "1525": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "184",
      "startCol": "7",
      "endLine": "184",
      "endCol": "75"
    },
    "1526": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "187",
      "startCol": "7",
      "endLine": "187",
      "endCol": "51"
    },
    "1527": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "194",
      "startCol": "5",
      "endLine": "194",
      "endCol": "78"
    },
    "1528": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "195",
      "startCol": "5",
      "endLine": "195",
      "endCol": "79"
    },
    "1529": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "197",
      "startCol": "5",
      "endLine": "197",
      "endCol": "62"
    },
    "1530": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "199",
      "startCol": "7",
      "endLine": "199",
      "endCol": "81"
    },
    "1531": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "201",
      "startCol": "7",
      "endLine": "201",
      "endCol": "112"
    },
    "1532": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "203",
      "startCol": "7",
      "endLine": "203",
      "endCol": "127"
    },
    "1533": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "205",
      "startCol": "9",
      "endLine": "205",
      "endCol": "113"
    },
    "1534": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "207",
      "startCol": "11",
      "endLine": "207",
      "endCol": "80"
    },
    "1535": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "209",
      "startCol": "11",
      "endLine": "209",
      "endCol": "79"
    },
    "1536": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "213",
      "startCol": "9",
      "endLine": "213",
      "endCol": "72"
    },
    "1537": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "217",
      "startCol": "11",
      "endLine": "217",
      "endCol": "79"
    },
    "1538": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "226",
      "startCol": "7",
      "endLine": "226",
      "endCol": "111"
    },
    "1539": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "227",
      "startCol": "14",
      "endLine": "227",
      "endCol": "60"
    },
    "1540": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "228",
      "startCol": "14",
      "endLine": "228",
      "endCol": "59"
    },
    "1541": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "230",
      "startCol": "7",
      "endLine": "230",
      "endCol": "96"
    },
    "1542": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "238",
      "startCol": "7",
      "endLine": "238",
      "endCol": "83"
    },
    "1543": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "240",
      "startCol": "7",
      "endLine": "240",
      "endCol": "87"
    },
    "1544": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "242",
      "startCol": "5",
      "endLine": "242",
      "endCol": "90"
    },
    "1545": {
      "patternID": "pattern3",
      "file": "test/source/tests/page-recipe/setup-page-recipe.ts",
      "startLine": "243",
      "startCol": "5",
      "endLine": "243",
      "endCol": "90"
    },
    "1546": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "28",
      "startCol": "28",
      "endLine": "28",
      "endCol": "116"
    },
    "1547": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "31",
      "startCol": "7",
      "endLine": "31",
      "endCol": "51"
    },
    "1548": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "33",
      "startCol": "14",
      "endLine": "33",
      "endCol": "55"
    },
    "1549": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "34",
      "startCol": "14",
      "endLine": "34",
      "endCol": "55"
    },
    "1550": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "40",
      "startCol": "28",
      "endLine": "40",
      "endCol": "116"
    },
    "1551": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "43",
      "startCol": "7",
      "endLine": "43",
      "endCol": "51"
    },
    "1552": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "45",
      "startCol": "7",
      "endLine": "45",
      "endCol": "50"
    },
    "1553": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "46",
      "startCol": "7",
      "endLine": "46",
      "endCol": "95"
    },
    "1554": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "47",
      "startCol": "7",
      "endLine": "47",
      "endCol": "94"
    },
    "1555": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "53",
      "startCol": "28",
      "endLine": "53",
      "endCol": "116"
    },
    "1556": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "58",
      "startCol": "28",
      "endLine": "58",
      "endCol": "116"
    },
    "1557": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "67",
      "startCol": "28",
      "endLine": "67",
      "endCol": "116"
    },
    "1558": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "68",
      "startCol": "7",
      "endLine": "68",
      "endCol": "66"
    },
    "1559": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "69",
      "startCol": "7",
      "endLine": "69",
      "endCol": "43"
    },
    "1560": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "70",
      "startCol": "25",
      "endLine": "70",
      "endCol": "65"
    },
    "1561": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "71",
      "startCol": "7",
      "endLine": "71",
      "endCol": "120"
    },
    "1562": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "72",
      "startCol": "7",
      "endLine": "72",
      "endCol": "59"
    },
    "1563": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "73",
      "startCol": "7",
      "endLine": "73",
      "endCol": "79"
    },
    "1564": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "77",
      "startCol": "28",
      "endLine": "77",
      "endCol": "116"
    },
    "1565": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "80",
      "startCol": "7",
      "endLine": "80",
      "endCol": "51"
    },
    "1566": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "82",
      "startCol": "7",
      "endLine": "82",
      "endCol": "115"
    },
    "1567": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "84",
      "startCol": "24",
      "endLine": "84",
      "endCol": "65"
    },
    "1568": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "90",
      "startCol": "7",
      "endLine": "90",
      "endCol": "93"
    },
    "1569": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "92",
      "startCol": "14",
      "endLine": "92",
      "endCol": "55"
    },
    "1570": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "93",
      "startCol": "14",
      "endLine": "93",
      "endCol": "55"
    },
    "1571": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "99",
      "startCol": "28",
      "endLine": "99",
      "endCol": "116"
    },
    "1572": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "105",
      "startCol": "28",
      "endLine": "105",
      "endCol": "116"
    },
    "1573": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "108",
      "startCol": "7",
      "endLine": "108",
      "endCol": "61"
    },
    "1574": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "109",
      "startCol": "7",
      "endLine": "109",
      "endCol": "59"
    },
    "1575": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "110",
      "startCol": "7",
      "endLine": "110",
      "endCol": "78"
    },
    "1576": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "112",
      "startCol": "7",
      "endLine": "112",
      "endCol": "61"
    },
    "1577": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "113",
      "startCol": "7",
      "endLine": "113",
      "endCol": "57"
    },
    "1578": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "124",
      "startCol": "7",
      "endLine": "124",
      "endCol": "54"
    },
    "1579": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "125",
      "startCol": "7",
      "endLine": "125",
      "endCol": "57"
    },
    "1580": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "170",
      "startCol": "28",
      "endLine": "170",
      "endCol": "116"
    },
    "1581": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "173",
      "startCol": "7",
      "endLine": "173",
      "endCol": "63"
    },
    "1582": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "178",
      "startCol": "25",
      "endLine": "178",
      "endCol": "173"
    },
    "1583": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "180",
      "startCol": "31",
      "endLine": "180",
      "endCol": "96"
    },
    "1584": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "181",
      "startCol": "7",
      "endLine": "181",
      "endCol": "56"
    },
    "1585": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "182",
      "startCol": "7",
      "endLine": "182",
      "endCol": "41"
    },
    "1586": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "183",
      "startCol": "38",
      "endLine": "183",
      "endCol": "89"
    },
    "1587": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "184",
      "startCol": "7",
      "endLine": "184",
      "endCol": "102"
    },
    "1588": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "185",
      "startCol": "7",
      "endLine": "185",
      "endCol": "37"
    },
    "1589": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "187",
      "startCol": "30",
      "endLine": "187",
      "endCol": "91"
    },
    "1590": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "188",
      "startCol": "7",
      "endLine": "188",
      "endCol": "55"
    },
    "1591": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "189",
      "startCol": "7",
      "endLine": "189",
      "endCol": "40"
    },
    "1592": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "190",
      "startCol": "37",
      "endLine": "190",
      "endCol": "88"
    },
    "1593": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "191",
      "startCol": "7",
      "endLine": "191",
      "endCol": "124"
    },
    "1594": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "192",
      "startCol": "7",
      "endLine": "192",
      "endCol": "37"
    },
    "1595": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "194",
      "startCol": "29",
      "endLine": "194",
      "endCol": "90"
    },
    "1596": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "195",
      "startCol": "7",
      "endLine": "195",
      "endCol": "54"
    },
    "1597": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "196",
      "startCol": "7",
      "endLine": "196",
      "endCol": "39"
    },
    "1598": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "197",
      "startCol": "36",
      "endLine": "197",
      "endCol": "87"
    },
    "1599": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "198",
      "startCol": "7",
      "endLine": "198",
      "endCol": "125"
    },
    "1600": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "199",
      "startCol": "7",
      "endLine": "199",
      "endCol": "37"
    },
    "1601": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "201",
      "startCol": "31",
      "endLine": "201",
      "endCol": "90"
    },
    "1602": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "202",
      "startCol": "7",
      "endLine": "202",
      "endCol": "56"
    },
    "1603": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "203",
      "startCol": "7",
      "endLine": "203",
      "endCol": "41"
    },
    "1604": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "204",
      "startCol": "38",
      "endLine": "204",
      "endCol": "89"
    },
    "1605": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "205",
      "startCol": "7",
      "endLine": "205",
      "endCol": "138"
    },
    "1606": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "206",
      "startCol": "7",
      "endLine": "206",
      "endCol": "136"
    },
    "1607": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "210",
      "startCol": "28",
      "endLine": "210",
      "endCol": "116"
    },
    "1608": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "213",
      "startCol": "25",
      "endLine": "213",
      "endCol": "173"
    },
    "1609": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "214",
      "startCol": "31",
      "endLine": "214",
      "endCol": "96"
    },
    "1610": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "215",
      "startCol": "7",
      "endLine": "215",
      "endCol": "56"
    },
    "1611": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "216",
      "startCol": "7",
      "endLine": "216",
      "endCol": "41"
    },
    "1612": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "218",
      "startCol": "7",
      "endLine": "218",
      "endCol": "56"
    },
    "1613": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "220",
      "startCol": "7",
      "endLine": "220",
      "endCol": "54"
    },
    "1614": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "221",
      "startCol": "7",
      "endLine": "221",
      "endCol": "41"
    },
    "1615": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "222",
      "startCol": "32",
      "endLine": "222",
      "endCol": "75"
    },
    "1616": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "223",
      "startCol": "7",
      "endLine": "223",
      "endCol": "76"
    },
    "1617": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "224",
      "startCol": "7",
      "endLine": "224",
      "endCol": "78"
    },
    "1618": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "225",
      "startCol": "38",
      "endLine": "225",
      "endCol": "89"
    },
    "1619": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "226",
      "startCol": "7",
      "endLine": "226",
      "endCol": "102"
    },
    "1620": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "232",
      "startCol": "25",
      "endLine": "232",
      "endCol": "173"
    },
    "1621": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "233",
      "startCol": "29",
      "endLine": "233",
      "endCol": "71"
    },
    "1622": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "235",
      "startCol": "7",
      "endLine": "235",
      "endCol": "57"
    },
    "1623": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "237",
      "startCol": "7",
      "endLine": "237",
      "endCol": "61"
    },
    "1624": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "238",
      "startCol": "38",
      "endLine": "238",
      "endCol": "89"
    },
    "1625": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "239",
      "startCol": "7",
      "endLine": "239",
      "endCol": "102"
    },
    "1626": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "241",
      "startCol": "7",
      "endLine": "241",
      "endCol": "127"
    },
    "1627": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "242",
      "startCol": "7",
      "endLine": "242",
      "endCol": "79"
    },
    "1628": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "253",
      "startCol": "37",
      "endLine": "253",
      "endCol": "157"
    },
    "1629": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "255",
      "startCol": "7",
      "endLine": "255",
      "endCol": "129"
    },
    "1630": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "271",
      "startCol": "7",
      "endLine": "271",
      "endCol": "33"
    },
    "1631": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "275",
      "startCol": "28",
      "endLine": "275",
      "endCol": "90"
    },
    "1632": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "280",
      "startCol": "7",
      "endLine": "280",
      "endCol": "54"
    },
    "1633": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "281",
      "startCol": "7",
      "endLine": "281",
      "endCol": "57"
    },
    "1634": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "282",
      "startCol": "7",
      "endLine": "282",
      "endCol": "99"
    },
    "1635": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "283",
      "startCol": "7",
      "endLine": "283",
      "endCol": "56"
    },
    "1636": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "284",
      "startCol": "7",
      "endLine": "284",
      "endCol": "57"
    },
    "1637": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "286",
      "startCol": "7",
      "endLine": "286",
      "endCol": "32"
    },
    "1638": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "291",
      "startCol": "28",
      "endLine": "291",
      "endCol": "85"
    },
    "1639": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "294",
      "startCol": "7",
      "endLine": "294",
      "endCol": "69"
    },
    "1640": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "296",
      "startCol": "26",
      "endLine": "297",
      "endCol": "92"
    },
    "1641": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "300",
      "startCol": "7",
      "endLine": "300",
      "endCol": "32"
    },
    "1642": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "302",
      "startCol": "29",
      "endLine": "302",
      "endCol": "86"
    },
    "1643": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "304",
      "startCol": "7",
      "endLine": "304",
      "endCol": "56"
    },
    "1644": {
      "patternID": "pattern3",
      "file": "test/source/tests/settings.ts",
      "startLine": "305",
      "startCol": "7",
      "endLine": "305",
      "endCol": "33"
    },
    "1645": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "38",
      "startCol": "7",
      "endLine": "38",
      "endCol": "55"
    },
    "1646": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "218",
      "startCol": "7",
      "endLine": "218",
      "endCol": "84"
    },
    "1647": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "220",
      "startCol": "7",
      "endLine": "220",
      "endCol": "160"
    },
    "1648": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "303",
      "startCol": "7",
      "endLine": "303",
      "endCol": "54"
    },
    "1649": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "304",
      "startCol": "14",
      "endLine": "304",
      "endCol": "58"
    },
    "1650": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "305",
      "startCol": "14",
      "endLine": "305",
      "endCol": "53"
    },
    "1651": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "306",
      "startCol": "14",
      "endLine": "306",
      "endCol": "53"
    },
    "1652": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "377",
      "startCol": "7",
      "endLine": "377",
      "endCol": "96"
    },
    "1653": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "379",
      "startCol": "7",
      "endLine": "379",
      "endCol": "65"
    },
    "1654": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "380",
      "startCol": "70",
      "endLine": "380",
      "endCol": "157"
    },
    "1655": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "394",
      "startCol": "7",
      "endLine": "394",
      "endCol": "70"
    },
    "1656": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "395",
      "startCol": "7",
      "endLine": "395",
      "endCol": "93"
    },
    "1657": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "396",
      "startCol": "27",
      "endLine": "396",
      "endCol": "83"
    },
    "1658": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "406",
      "startCol": "7",
      "endLine": "406",
      "endCol": "60"
    },
    "1659": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "407",
      "startCol": "7",
      "endLine": "407",
      "endCol": "108"
    },
    "1660": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "414",
      "startCol": "7",
      "endLine": "414",
      "endCol": "55"
    },
    "1661": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "415",
      "startCol": "7",
      "endLine": "415",
      "endCol": "32"
    },
    "1662": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "426",
      "startCol": "7",
      "endLine": "426",
      "endCol": "97"
    },
    "1663": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "427",
      "startCol": "7",
      "endLine": "427",
      "endCol": "94"
    },
    "1664": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "428",
      "startCol": "7",
      "endLine": "428",
      "endCol": "50"
    },
    "1665": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "437",
      "startCol": "7",
      "endLine": "437",
      "endCol": "64"
    },
    "1666": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "441",
      "startCol": "7",
      "endLine": "441",
      "endCol": "54"
    },
    "1667": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "442",
      "startCol": "14",
      "endLine": "442",
      "endCol": "58"
    },
    "1668": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "449",
      "startCol": "7",
      "endLine": "449",
      "endCol": "127"
    },
    "1669": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "458",
      "startCol": "7",
      "endLine": "458",
      "endCol": "64"
    },
    "1670": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "462",
      "startCol": "7",
      "endLine": "462",
      "endCol": "54"
    },
    "1671": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "463",
      "startCol": "14",
      "endLine": "463",
      "endCol": "58"
    },
    "1672": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "473",
      "startCol": "7",
      "endLine": "473",
      "endCol": "64"
    },
    "1673": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "477",
      "startCol": "7",
      "endLine": "477",
      "endCol": "54"
    },
    "1674": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "480",
      "startCol": "17",
      "endLine": "480",
      "endCol": "53"
    },
    "1675": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "481",
      "startCol": "14",
      "endLine": "481",
      "endCol": "58"
    },
    "1676": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "482",
      "startCol": "14",
      "endLine": "482",
      "endCol": "61"
    },
    "1677": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "489",
      "startCol": "7",
      "endLine": "489",
      "endCol": "127"
    },
    "1678": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "506",
      "startCol": "7",
      "endLine": "506",
      "endCol": "125"
    },
    "1679": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "508",
      "startCol": "14",
      "endLine": "508",
      "endCol": "70"
    },
    "1680": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "509",
      "startCol": "7",
      "endLine": "509",
      "endCol": "62"
    },
    "1681": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "510",
      "startCol": "7",
      "endLine": "510",
      "endCol": "62"
    },
    "1682": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "512",
      "startCol": "23",
      "endLine": "512",
      "endCol": "75"
    },
    "1683": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "539",
      "startCol": "9",
      "endLine": "539",
      "endCol": "82"
    },
    "1684": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "540",
      "startCol": "9",
      "endLine": "540",
      "endCol": "52"
    },
    "1685": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "553",
      "startCol": "9",
      "endLine": "553",
      "endCol": "56"
    },
    "1686": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "556",
      "startCol": "19",
      "endLine": "556",
      "endCol": "55"
    },
    "1687": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "557",
      "startCol": "16",
      "endLine": "557",
      "endCol": "60"
    },
    "1688": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "559",
      "startCol": "16",
      "endLine": "559",
      "endCol": "63"
    },
    "1689": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "569",
      "startCol": "9",
      "endLine": "569",
      "endCol": "127"
    },
    "1690": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "571",
      "startCol": "23",
      "endLine": "571",
      "endCol": "79"
    },
    "1691": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "574",
      "startCol": "9",
      "endLine": "574",
      "endCol": "64"
    },
    "1692": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "575",
      "startCol": "9",
      "endLine": "575",
      "endCol": "64"
    },
    "1693": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "577",
      "startCol": "25",
      "endLine": "577",
      "endCol": "77"
    },
    "1694": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "594",
      "startCol": "7",
      "endLine": "594",
      "endCol": "93"
    },
    "1695": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "595",
      "startCol": "7",
      "endLine": "595",
      "endCol": "87"
    },
    "1696": {
      "patternID": "pattern3",
      "file": "test/source/tests/setup.ts",
      "startLine": "606",
      "startCol": "9",
      "endLine": "607",
      "endCol": "116"
    },
    "1697": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/api.ts",
      "startLine": "22",
      "startCol": "12",
      "endLine": "22",
      "endCol": "83"
    },
    "1698": {
      "patternID": "pattern1",
      "file": "test/source/tests/tooling/api.ts",
      "startLine": "21",
      "startCol": "25",
      "endLine": "23",
      "endCol": "3"
    },
    "1699": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "16",
      "startCol": "26",
      "endLine": "16",
      "endCol": "79"
    },
    "1700": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "17",
      "startCol": "24",
      "endLine": "17",
      "endCol": "119"
    },
    "1701": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "19",
      "startCol": "5",
      "endLine": "19",
      "endCol": "109"
    },
    "1702": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "24",
      "startCol": "26",
      "endLine": "24",
      "endCol": "79"
    },
    "1703": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "25",
      "startCol": "24",
      "endLine": "25",
      "endCol": "119"
    },
    "1704": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "31",
      "startCol": "23",
      "endLine": "31",
      "endCol": "80"
    },
    "1705": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "32",
      "startCol": "5",
      "endLine": "32",
      "endCol": "37"
    },
    "1706": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "39",
      "startCol": "5",
      "endLine": "39",
      "endCol": "53"
    },
    "1707": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "46",
      "startCol": "5",
      "endLine": "46",
      "endCol": "56"
    },
    "1708": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "55",
      "startCol": "7",
      "endLine": "55",
      "endCol": "32"
    },
    "1709": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "60",
      "startCol": "87",
      "endLine": "60",
      "endCol": "182"
    },
    "1710": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "61",
      "startCol": "9",
      "endLine": "61",
      "endCol": "105"
    },
    "1711": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "67",
      "startCol": "87",
      "endLine": "67",
      "endCol": "182"
    },
    "1712": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "68",
      "startCol": "9",
      "endLine": "68",
      "endCol": "105"
    },
    "1713": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "73",
      "startCol": "7",
      "endLine": "73",
      "endCol": "32"
    },
    "1714": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "79",
      "startCol": "18",
      "endLine": "79",
      "endCol": "91"
    },
    "1715": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "81",
      "startCol": "7",
      "endLine": "81",
      "endCol": "168"
    },
    "1716": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "97",
      "startCol": "25",
      "endLine": "97",
      "endCol": "94"
    },
    "1717": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "98",
      "startCol": "26",
      "endLine": "98",
      "endCol": "70"
    },
    "1718": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "100",
      "startCol": "7",
      "endLine": "100",
      "endCol": "99"
    },
    "1719": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "102",
      "startCol": "5",
      "endLine": "102",
      "endCol": "56"
    },
    "1720": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "105",
      "startCol": "7",
      "endLine": "105",
      "endCol": "68"
    },
    "1721": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "108",
      "startCol": "11",
      "endLine": "108",
      "endCol": "76"
    },
    "1722": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "112",
      "startCol": "21",
      "endLine": "112",
      "endCol": "65"
    },
    "1723": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "126",
      "startCol": "26",
      "endLine": "126",
      "endCol": "66"
    },
    "1724": {
      "patternID": "pattern3",
      "file": "test/source/tests/tooling/browser-recipe.ts",
      "startLine": "134",
      "startCol": "5",
      "endLine": "134",
      "endCol": "29"
    },
    "1725": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-browser.ts",
      "startLine": "26",
      "startCol": "26",
      "endLine": "26",
      "endCol": "100"
    },
    "1726": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-browser.ts",
      "startLine": "28",
      "startCol": "9",
      "endLine": "28",
      "endCol": "128"
    },
    "1727": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-browser.ts",
      "startLine": "30",
      "startCol": "9",
      "endLine": "30",
      "endCol": "110"
    },
    "1728": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-browser.ts",
      "startLine": "42",
      "startCol": "19",
      "endLine": "42",
      "endCol": "70"
    },
    "1729": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "95",
      "startCol": "14",
      "endLine": "95",
      "endCol": "46"
    },
    "1730": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "100",
      "startCol": "14",
      "endLine": "100",
      "endCol": "48"
    },
    "1731": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "105",
      "startCol": "14",
      "endLine": "105",
      "endCol": "51"
    },
    "1732": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "110",
      "startCol": "14",
      "endLine": "110",
      "endCol": "51"
    },
    "1733": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "116",
      "startCol": "26",
      "endLine": "116",
      "endCol": "53"
    },
    "1734": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "122",
      "startCol": "19",
      "endLine": "122",
      "endCol": "62"
    },
    "1735": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "181",
      "startCol": "7",
      "endLine": "181",
      "endCol": "187"
    },
    "1736": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "185",
      "startCol": "7",
      "endLine": "185",
      "endCol": "167"
    },
    "1737": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "249",
      "startCol": "19",
      "endLine": "249",
      "endCol": "49"
    },
    "1738": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "321",
      "startCol": "19",
      "endLine": "321",
      "endCol": "52"
    },
    "1739": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "356",
      "startCol": "19",
      "endLine": "356",
      "endCol": "53"
    },
    "1740": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "420",
      "startCol": "30",
      "endLine": "420",
      "endCol": "86"
    },
    "1741": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "491",
      "startCol": "30",
      "endLine": "491",
      "endCol": "87"
    },
    "1742": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "501",
      "startCol": "30",
      "endLine": "501",
      "endCol": "92"
    },
    "1743": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "511",
      "startCol": "30",
      "endLine": "511",
      "endCol": "82"
    },
    "1744": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "520",
      "startCol": "19",
      "endLine": "520",
      "endCol": "62"
    },
    "1745": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "521",
      "startCol": "29",
      "endLine": "522",
      "endCol": "74"
    },
    "1746": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "608",
      "startCol": "19",
      "endLine": "608",
      "endCol": "42"
    },
    "1747": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "617",
      "startCol": "30",
      "endLine": "617",
      "endCol": "80"
    },
    "1748": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "629",
      "startCol": "22",
      "endLine": "629",
      "endCol": "55"
    },
    "1749": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "642",
      "startCol": "22",
      "endLine": "642",
      "endCol": "78"
    },
    "1750": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "644",
      "startCol": "25",
      "endLine": "644",
      "endCol": "86"
    },
    "1751": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "668",
      "startCol": "22",
      "endLine": "668",
      "endCol": "125"
    },
    "1752": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "689",
      "startCol": "22",
      "endLine": "689",
      "endCol": "125"
    },
    "1753": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "711",
      "startCol": "22",
      "endLine": "711",
      "endCol": "100"
    },
    "1754": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "718",
      "startCol": "20",
      "endLine": "718",
      "endCol": "115"
    },
    "1755": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "719",
      "startCol": "20",
      "endLine": "719",
      "endCol": "115"
    },
    "1756": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "720",
      "startCol": "20",
      "endLine": "720",
      "endCol": "51"
    },
    "1757": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "721",
      "startCol": "20",
      "endLine": "721",
      "endCol": "51"
    },
    "1758": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "723",
      "startCol": "24",
      "endLine": "723",
      "endCol": "119"
    },
    "1759": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "724",
      "startCol": "17",
      "endLine": "724",
      "endCol": "78"
    },
    "1760": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "725",
      "startCol": "23",
      "endLine": "725",
      "endCol": "55"
    },
    "1761": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "726",
      "startCol": "23",
      "endLine": "726",
      "endCol": "55"
    },
    "1762": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "728",
      "startCol": "15",
      "endLine": "728",
      "endCol": "47"
    },
    "1763": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "729",
      "startCol": "15",
      "endLine": "729",
      "endCol": "47"
    },
    "1764": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "734",
      "startCol": "26",
      "endLine": "734",
      "endCol": "66"
    },
    "1765": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "801",
      "startCol": "22",
      "endLine": "801",
      "endCol": "65"
    },
    "1766": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "802",
      "startCol": "7",
      "endLine": "802",
      "endCol": "47"
    },
    "1767": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "805",
      "startCol": "34",
      "endLine": "805",
      "endCol": "87"
    },
    "1768": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "812",
      "startCol": "24",
      "endLine": "812",
      "endCol": "58"
    },
    "1769": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "813",
      "startCol": "25",
      "endLine": "813",
      "endCol": "84"
    },
    "1770": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "814",
      "startCol": "22",
      "endLine": "814",
      "endCol": "74"
    },
    "1771": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "815",
      "startCol": "51",
      "endLine": "815",
      "endCol": "82"
    },
    "1772": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "816",
      "startCol": "25",
      "endLine": "816",
      "endCol": "98"
    },
    "1773": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "827",
      "startCol": "23",
      "endLine": "827",
      "endCol": "97"
    },
    "1774": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "827",
      "startCol": "46",
      "endLine": "827",
      "endCol": "92"
    },
    "1775": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "842",
      "startCol": "23",
      "endLine": "842",
      "endCol": "94"
    },
    "1776": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "842",
      "startCol": "46",
      "endLine": "842",
      "endCol": "89"
    },
    "1777": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "989",
      "startCol": "22",
      "endLine": "989",
      "endCol": "114"
    },
    "1778": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "989",
      "startCol": "45",
      "endLine": "989",
      "endCol": "105"
    },
    "1779": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1028",
      "startCol": "22",
      "endLine": "1028",
      "endCol": "114"
    },
    "1780": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1028",
      "startCol": "45",
      "endLine": "1028",
      "endCol": "105"
    },
    "1781": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1336",
      "startCol": "22",
      "endLine": "1336",
      "endCol": "106"
    },
    "1782": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1336",
      "startCol": "45",
      "endLine": "1336",
      "endCol": "97"
    },
    "1783": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1375",
      "startCol": "22",
      "endLine": "1375",
      "endCol": "101"
    },
    "1784": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1375",
      "startCol": "45",
      "endLine": "1375",
      "endCol": "96"
    },
    "1785": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1411",
      "startCol": "28",
      "endLine": "1411",
      "endCol": "88"
    },
    "1786": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1416",
      "startCol": "14",
      "endLine": "1416",
      "endCol": "56"
    },
    "1787": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1419",
      "startCol": "19",
      "endLine": "1419",
      "endCol": "49"
    },
    "1788": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1428",
      "startCol": "22",
      "endLine": "1428",
      "endCol": "82"
    },
    "1789": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1429",
      "startCol": "14",
      "endLine": "1429",
      "endCol": "50"
    },
    "1790": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1434",
      "startCol": "22",
      "endLine": "1434",
      "endCol": "82"
    },
    "1791": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1435",
      "startCol": "14",
      "endLine": "1435",
      "endCol": "50"
    },
    "1792": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1445",
      "startCol": "28",
      "endLine": "1445",
      "endCol": "80"
    },
    "1793": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1450",
      "startCol": "14",
      "endLine": "1450",
      "endCol": "56"
    },
    "1794": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1453",
      "startCol": "19",
      "endLine": "1453",
      "endCol": "49"
    },
    "1795": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1462",
      "startCol": "22",
      "endLine": "1462",
      "endCol": "74"
    },
    "1796": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1463",
      "startCol": "14",
      "endLine": "1463",
      "endCol": "50"
    },
    "1797": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1468",
      "startCol": "22",
      "endLine": "1468",
      "endCol": "74"
    },
    "1798": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1469",
      "startCol": "14",
      "endLine": "1469",
      "endCol": "50"
    },
    "1799": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1478",
      "startCol": "22",
      "endLine": "1478",
      "endCol": "63"
    },
    "1800": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1485",
      "startCol": "22",
      "endLine": "1485",
      "endCol": "63"
    },
    "1801": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1496",
      "startCol": "22",
      "endLine": "1496",
      "endCol": "81"
    },
    "1802": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1497",
      "startCol": "14",
      "endLine": "1497",
      "endCol": "50"
    },
    "1803": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1504",
      "startCol": "22",
      "endLine": "1504",
      "endCol": "81"
    },
    "1804": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1505",
      "startCol": "14",
      "endLine": "1505",
      "endCol": "50"
    },
    "1805": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1520",
      "startCol": "22",
      "endLine": "1520",
      "endCol": "55"
    },
    "1806": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1528",
      "startCol": "22",
      "endLine": "1528",
      "endCol": "59"
    },
    "1807": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1568",
      "startCol": "20",
      "endLine": "1568",
      "endCol": "53"
    },
    "1808": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1590",
      "startCol": "20",
      "endLine": "1590",
      "endCol": "53"
    },
    "1809": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1599",
      "startCol": "19",
      "endLine": "1599",
      "endCol": "70"
    },
    "1810": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1608",
      "startCol": "19",
      "endLine": "1608",
      "endCol": "79"
    },
    "1811": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1613",
      "startCol": "14",
      "endLine": "1613",
      "endCol": "47"
    },
    "1812": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1622",
      "startCol": "7",
      "endLine": "1624",
      "endCol": "108"
    },
    "1813": {
      "patternID": "pattern3",
      "file": "test/source/tests/unit-node.ts",
      "startLine": "1632",
      "startCol": "25",
      "endLine": "1632",
      "endCol": "55"
    },
    "1814": {
      "patternID": "pattern3",
      "file": "test/source/util/index.ts",
      "startLine": "74",
      "startCol": "12",
      "endLine": "78",
      "endCol": "9"
    },
    "1815": {
      "patternID": "pattern1",
      "file": "test/source/util/index.ts",
      "startLine": "73",
      "startCol": "30",
      "endLine": "79",
      "endCol": "3"
    },
    "1816": {
      "patternID": "pattern3",
      "file": "test/source/util/index.ts",
      "startLine": "76",
      "startCol": "24",
      "endLine": "76",
      "endCol": "56"
    },
    "1817": {
      "patternID": "pattern3",
      "file": "test/source/util/index.ts",
      "startLine": "77",
      "startCol": "21",
      "endLine": "77",
      "endCol": "52"
    },
    "1818": {
      "patternID": "pattern1",
      "file": "test/source/util/index.ts",
      "startLine": "85",
      "startCol": "25",
      "endLine": "87",
      "endCol": "3"
    },
    "1819": {
      "patternID": "pattern3",
      "file": "test/source/util/parse.ts",
      "startLine": "35",
      "startCol": "10",
      "endLine": "35",
      "endCol": "102"
    },
    "1820": {
      "patternID": "pattern1",
      "file": "test/source/util/parse.ts",
      "startLine": "34",
      "startCol": "32",
      "endLine": "36",
      "endCol": "1"
    }
  },
  "files": {
    "build/test/test/source/async-stack.js": "\"use strict\";\n/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n(() => {\n    const wait = () => new Promise(resolve => setTimeout(resolve, 100));\n    const acceptCb = (cb) => {\n        // nothing\n    };\n    acceptCb(async () => {\n        try {\n            await wait();\n        }\n        catch (t) {\n            if(t instanceof Error){t.stack+=\"\\n    at <async> <anonymous> (../test/source/async-stack.ts:13:12)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n        }\n    });\n    acceptCb(async () => {\n        try {\n            Math.random();\n        }\n        catch (t) {\n            if(t instanceof Error){t.stack+=\"\\n    at <async> <anonymous> (../test/source/async-stack.ts:17:12)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n        }\n    });\n    acceptCb(async () => {\n        try {\n            return await wait();\n        }\n        catch (t) {\n            if(t instanceof Error){t.stack+=\"\\n    at <async> <anonymous> (../test/source/async-stack.ts:21:12)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n        }\n    }); // test if will get replaced\n    acceptCb(async () => {\n        try {\n            return Math.random();\n        }\n        catch (t) {\n            if(t instanceof Error){t.stack+=\"\\n    at <async> <anonymous> (../test/source/async-stack.ts:23:12)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n        }\n    }); // test if will get replaced\n    const thisWillFail = (type) => {\n        if (type === 'error') {\n            throw new Error('this failed');\n        }\n        else if (type === 'object') {\n            throw { nonsense: 'yes' };\n        }\n    };\n    function func(type) {\n        thisWillFail(type);\n    }\n    class Class {\n        static staticFunc(type) {\n            Class.staticConstAttr(type);\n        }\n    }\n    Class.staticConstAttr = (type) => {\n        func(type);\n    };\n    const asyncArrowConst = async (type) => {\n        try {\n            await wait();\n            Class.staticFunc(type);\n            await wait();\n        }\n        catch (t) {\n            if(t instanceof Error){t.stack+=\"\\n    at <async> asyncArrowConst (../test/source/async-stack.ts:46:26)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n        }\n    };\n    async function asyncFunc(type) {\n        try {\n            await wait();\n            await asyncArrowConst(type);\n            await wait();\n        }\n        catch (t) {\n            if(t instanceof Error){t.stack+=\"\\n    at <async> asyncFunc (../test/source/async-stack.ts:50:5)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n        }\n    }\n    const obj = {\n        paramFunc: async (type) => {\n            try {\n                await asyncFunc(type);\n            }\n            catch (t) {\n                if(t instanceof Error){t.stack+=\"\\n    at <async> paramFunc (../test/source/async-stack.ts:59:15)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n            }\n        },\n    };\n    class ClassAsync {\n        static async staticAsyncFunc(type) {\n            try {\n                await wait();\n                await ClassAsync.staticConstAttrAsync(type);\n                await wait();\n            }\n            catch (t) {\n                if(t instanceof Error){t.stack+=\"\\n    at <async> staticAsyncFunc (../test/source/async-stack.ts:69:6)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n            }\n        }\n    }\n    ClassAsync.staticConstAttrAsync = async (type) => {\n        try {\n            await wait();\n            await obj.paramFunc(type);\n            await wait();\n        }\n        catch (t) {\n            if(t instanceof Error){t.stack+=\"\\n    at <async> staticConstAttrAsync (../test/source/async-stack.ts:65:41)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n        }\n    };\n    (async () => {\n        try {\n            const doTestWith = async (type, expectedStackStatements) => {\n                try {\n                    try {\n                        await ClassAsync.staticAsyncFunc(type);\n                    }\n                    catch (e) {\n                        if (!(e instanceof Error)) {\n                            console.error(`Thrown was unexpectedly not an error for type ${type}`, e);\n                            return process.exit(1);\n                        }\n                        for (const statement of expectedStackStatements) {\n                            if ((e.stack || '').indexOf(statement) === -1) {\n                                console.error(`Unexpected stack format for type ${type}:\\n${e.stack}\\n\\n\\nExpected to include:\\n${expectedStackStatements.join('\\n')}`);\n                                process.exit(1);\n                            }\n                        }\n                        if (type === 'object' && JSON.stringify(e.thrown) !== '{\"nonsense\":\"yes\"}') {\n                            console.error(`Unexpected e.throw for type ${type}:\\n${JSON.stringify(e.thrown)}`);\n                            process.exit(1);\n                        }\n                        return;\n                    }\n                    console.error(`Fail - expected Error to be thrown for type ${type}`);\n                    return process.exit(1);\n                }\n                catch (t) {\n                    if(t instanceof Error){t.stack+=\"\\n    at <async> doTestWith (../test/source/async-stack.ts:79:23)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n                }\n            };\n            try {\n                await doTestWith('error', [\n                    'Error: this failed',\n                    ' at thisWillFail ',\n                    ' at func ',\n                    ' at Function.Class.staticConstAttr ',\n                    ' at Function.staticFunc ',\n                    ' at asyncArrowConst ',\n                    ' at <async> asyncArrowConst ',\n                    ' at <async> asyncFunc ',\n                    ' at <async> paramFunc ',\n                    ' at <async> staticConstAttrAsync ',\n                    ' at <async> staticAsyncFunc ',\n                ]);\n                await doTestWith('object', [\n                    'Error: Thrown[object][object Object]',\n                    ' at asyncArrowConst ',\n                    ' at <async> asyncFunc ',\n                    ' at <async> paramFunc ',\n                    ' at <async> staticConstAttrAsync ',\n                    ' at <async> staticAsyncFunc ',\n                ]);\n                process.exit(0);\n            }\n            catch (e) {\n                console.error(e);\n                return process.exit(1);\n            }\n        }\n        catch (t) {\n            if(t instanceof Error){t.stack+=\"\\n    at <async> <anonymous> (../test/source/async-stack.ts:77:4)\";throw t}const e=new Error(\"Thrown[\"+typeof t+\"]\"+t);e.thrown=t;throw e;\n        }\n    })().catch(e => {\n        console.error(e);\n        process.exit(1);\n    });\n})();\n//# sourceMappingURL=async-stack.js.map",
    "extension/js/background_page/bg-handlers.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Api } from '../common/api/shared/api.js';\nimport { BgUtils } from './bgutils.js';\nimport { Bm } from '../common/browser/browser-msg.js';\nimport { Gmail } from '../common/api/email-provider/gmail/gmail.js';\nimport { GlobalStore } from '../common/platform/store/global-store.js';\nimport { ContactStore } from '../common/platform/store/contact-store.js';\n\nexport class BgHandlers {\n\n  public static openSettingsPageHandler: Bm.AsyncResponselessHandler = async ({ page, path, pageUrlParams, addNewAcct, acctEmail }: Bm.Settings) => {\n    await BgUtils.openSettingsPage(path, acctEmail, page, pageUrlParams, addNewAcct === true);\n  }\n\n  public static dbOperationHandler = async (db: IDBDatabase, request: Bm.Db): Promise<Bm.Res.Db> => {\n    if (!db) {\n      console.info(`db corrupted, skipping: ${request.f}`);\n      return await new Promise(() => undefined); // never resolve, error was already shown\n    }\n    const dbFunc = (ContactStore as any)[request.f] as (db: IDBDatabase, ...args: any[]) => Promise<Bm.Res.Db>; // due to https://github.com/Microsoft/TypeScript/issues/6480\n    if (request.f === 'obj') {\n      return await dbFunc(request.args[0] as any); // db not needed, it goes through background because openpgp.js may not be available in the frame\n    }\n    return await dbFunc(db, ...request.args);\n  }\n\n  public static ajaxHandler = async (r: Bm.Ajax): Promise<Bm.Res.Ajax> => {\n    return await Api.ajax(r.req, r.stack); // tslint:disable-line:no-direct-ajax\n  }\n\n  public static ajaxGmailAttachmentGetChunkHandler = async (r: Bm.AjaxGmailAttachmentGetChunk): Promise<Bm.Res.AjaxGmailAttachmentGetChunk> => {\n    return { chunk: await new Gmail(r.acctEmail).attachmentGetChunk(r.msgId, r.attachmentId) };\n  }\n\n  public static updateUninstallUrl: Bm.AsyncResponselessHandler = async () => {\n    const acctEmails = await GlobalStore.acctEmailsGet();\n    if (typeof chrome.runtime.setUninstallURL !== 'undefined') {\n      const email = acctEmails?.length ? acctEmails[0] : undefined;\n      chrome.runtime.setUninstallURL(`https://flowcrypt.com/leaving.htm#${JSON.stringify({ email, metrics: null })}`); // tslint:disable-line:no-null-keyword\n    }\n  }\n\n  public static getActiveTabInfo: Bm.AsyncRespondingHandler = () => new Promise((resolve, reject) => {\n    chrome.tabs.query({ active: true, currentWindow: true, url: [\"*://mail.google.com/*\", \"*://inbox.google.com/*\"] }, (activeTabs) => {\n      if (activeTabs.length) {\n        if (activeTabs[0].id !== undefined) {\n          type ScriptRes = { acctEmail: string | undefined, sameWorld: boolean | undefined }[];\n          chrome.tabs.executeScript(activeTabs[0].id!, { code: 'var r = {acctEmail: window.account_email_global, sameWorld: window.same_world_global}; r' }, (result: ScriptRes) => {\n            resolve({ provider: 'gmail', acctEmail: result[0].acctEmail, sameWorld: result[0].sameWorld === true });\n          });\n        } else {\n          reject(new Error('tabs[0].id is undefined'));\n        }\n      } else {\n        resolve({ provider: undefined, acctEmail: undefined, sameWorld: undefined });\n      }\n    });\n  })\n\n  public static respondWithSenderTabId = async (r: unknown, sender: Bm.Sender): Promise<Bm.Res._tab_> => {\n    if (sender === 'background') {\n      return { tabId: null };  // tslint:disable-line:no-null-keyword\n    } else if (sender.tab) {\n      return { tabId: `${sender.tab.id}:${sender.frameId}` };\n    } else {\n      // sender.tab: \"This property will only be present when the connection was opened from a tab (including content scripts)\"\n      // https://developers.chrome.com/extensions/runtime#type-MessageSender\n      // MDN says the same - thus this is most likely a background script, through browser message passing\n      return { tabId: null }; // tslint:disable-line:no-null-keyword\n    }\n  }\n\n}\n",
    "extension/js/common/browser/ui.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { ApiErr } from '../api/shared/api-error.js';\nimport { Catch } from '../platform/catch.js';\nimport { Dict, Url } from '../core/common.js';\nimport Swal from 'sweetalert2';\nimport { Xss } from '../platform/xss.js';\n\ntype NamedSels = Dict<JQuery<HTMLElement>>;\ntype ProvidedEventHandler = (e: HTMLElement, event: JQuery.Event<HTMLElement, null>) => void | Promise<void>;\n\nexport type SelCache = { cached: (name: string) => JQuery<HTMLElement>; now: (name: string) => JQuery<HTMLElement>; sel: (name: string) => string; };\nexport type PreventableEventName = 'double' | 'parallel' | 'spree' | 'slowspree' | 'veryslowspree';\nexport type BrowserEventErrHandler = { auth?: () => Promise<void>, authPopup?: () => Promise<void>, network?: () => Promise<void>, other?: (e: any) => Promise<void> };\n\nexport class Ui {\n\n  public static EVENT_DOUBLE_MS = 1000;\n  public static EVENT_SPREE_MS = 50;\n  public static EVENT_SLOW_SPREE_MS = 200;\n  public static EVENT_VERY_SLOW_SPREE_MS = 500;\n\n  public static event = {\n    clicked: (selector: string | JQuery<HTMLElement>): Promise<HTMLElement> => new Promise(resolve => $(selector as string).one('click', function () { resolve(this); })),\n    stop: () => (e: JQuery.Event) => { // returns a function\n      e.preventDefault();\n      e.stopPropagation();\n      return false;\n    },\n    protect: () => {\n      // prevent events that could potentially leak information about sensitive info from bubbling above the frame\n      $('body').on('keyup keypress keydown click drag drop dragover dragleave dragend submit', e => {\n        // don't ask me how come Chrome allows it to bubble cross-domain\n        // should be used in embedded frames where the parent cannot be trusted (eg parent is webmail)\n        // should be further combined with iframe type=content + sandboxing, but these could potentially be changed by the parent frame\n        // so this indeed seems like the only defense\n        // happened on only one machine, but could potentially happen to other users as well\n        // if you know more than I do about the hows and whys of events bubbling out of iframes on different domains, let me know\n        e.stopPropagation();\n      });\n    },\n    handle: (cb: ProvidedEventHandler, errHandlers?: BrowserEventErrHandler, originalThis?: unknown) => {\n      return function uiEventHandle(this: HTMLElement, event: JQuery.Event<HTMLElement, null>) {\n        try {\n          const r = cb.bind(originalThis)(this, event) as void | Promise<void>; // tslint:disable-line:no-unsafe-any\n          if (typeof r === 'object' && typeof r.catch === 'function') { // tslint:disable-line:no-unbound-method - only testing if exists\n            r.catch(e => Ui.event._dispatchErr(e, errHandlers));\n          }\n        } catch (e) {\n          Ui.event._dispatchErr(e, errHandlers);\n        }\n      };\n    },\n    _dispatchErr: (e: any, errHandlers?: BrowserEventErrHandler) => {\n      if (ApiErr.isNetErr(e) && errHandlers && errHandlers.network) {\n        errHandlers.network().catch(Catch.reportErr);\n      } else if (ApiErr.isAuthErr(e) && errHandlers && errHandlers.auth) {\n        errHandlers.auth().catch(Catch.reportErr);\n      } else if (errHandlers && errHandlers.other) {\n        errHandlers.other(e).catch(Catch.reportErr);\n      } else {\n        Catch.reportErr(e);\n      }\n    },\n    prevent: <THIS extends HTMLElement | void>(\n      evName: PreventableEventName,\n      cb: (el: HTMLElement, event: Event | undefined, resetTimer: () => void) => void | Promise<void>,\n      errHandler?: BrowserEventErrHandler,\n      originalThis?: unknown\n    ) => {\n      let eventTimer: number | undefined;\n      let eventFiredOn: number | undefined;\n      const cbResetTimer = () => {\n        eventTimer = undefined;\n        eventFiredOn = undefined;\n      };\n      const cbWithErrsHandled = (el: HTMLElement) => {\n        try {\n          const r = cb.bind(originalThis)(el, event, cbResetTimer) as void | Promise<void>; // tslint:disable-line:no-unsafe-any\n          if (typeof r === 'object' && typeof r.catch === 'function') { // tslint:disable-line:no-unbound-method - only testing if exists\n            r.catch(e => Ui.event._dispatchErr(e, errHandler));\n          }\n        } catch (e) {\n          Ui.event._dispatchErr(e, errHandler);\n        }\n      };\n      return function (this: THIS) {\n        if (evName === 'spree') {\n          clearTimeout(eventTimer);\n          eventTimer = Catch.setHandledTimeout(() => cbWithErrsHandled(this as HTMLElement), Ui.EVENT_SPREE_MS);\n        } else if (evName === 'slowspree') {\n          clearTimeout(eventTimer);\n          eventTimer = Catch.setHandledTimeout(() => cbWithErrsHandled(this as HTMLElement), Ui.EVENT_SLOW_SPREE_MS);\n        } else if (evName === 'veryslowspree') {\n          clearTimeout(eventTimer);\n          eventTimer = Catch.setHandledTimeout(() => cbWithErrsHandled(this as HTMLElement), Ui.EVENT_VERY_SLOW_SPREE_MS);\n        } else {\n          if (eventFiredOn) {\n            if (evName === 'parallel') {\n              // event handling is still being processed. Do not call back\n            } else if (evName === 'double') {\n              if (Date.now() - eventFiredOn > Ui.EVENT_DOUBLE_MS) {\n                eventFiredOn = Date.now();\n                cbWithErrsHandled(this as HTMLElement);\n              }\n            }\n          } else {\n            eventFiredOn = Date.now();\n            cbWithErrsHandled(this as HTMLElement);\n          }\n        }\n      };\n    }\n  };\n\n  public static time = {\n    wait: (untilThisFunctionEvalsTrue: () => boolean | undefined): Promise<void> => new Promise((success, error) => {\n      const interval = Catch.setHandledInterval(() => {\n        const result = untilThisFunctionEvalsTrue();\n        if (result === true) {\n          clearInterval(interval);\n          if (success) {\n            success();\n          }\n        } else if (result === false) {\n          clearInterval(interval);\n          if (error) {\n            error();\n          }\n        }\n      }, 50);\n    }),\n    sleep: (ms: number, setCustomTimeout: (code: () => void, t: number) => void = Catch.setHandledTimeout): Promise<void> => new Promise(resolve => setCustomTimeout(resolve, ms)),\n  };\n\n  public static modal = {\n    info: async (text: string, isHTML: boolean = false): Promise<void> => {\n      text = isHTML ? Xss.htmlSanitize(text) : Xss.escape(text).replace(/\\n/g, '<br>');\n      await Ui.swal().fire({\n        html: text,\n        allowOutsideClick: false,\n        customClass: {\n          popup: 'ui-modal-info',\n          confirmButton: 'ui-modal-info-confirm',\n        },\n      });\n      Ui.activateModalPageLinkTags(); // in case the page itself has data-swal-page links\n    },\n    warning: async (text: string, footer?: string): Promise<void> => {\n      await Ui.swal().fire({\n        html: `<span class=\"orange\">${Xss.escape(text).replace(/\\n/g, '<br>')}</span>`,\n        footer: footer ? Xss.htmlSanitize(footer) : '',\n        allowOutsideClick: false,\n        customClass: {\n          popup: 'ui-modal-warning',\n          confirmButton: 'ui-modal-warning-confirm',\n        },\n      });\n      Ui.activateModalPageLinkTags(); // in case the page itself has data-swal-page links\n    },\n    error: async (text: string, isHTML: boolean = false, footer?: string): Promise<void> => {\n      text = isHTML ? Xss.htmlSanitize(text) : Xss.escape(text).replace(/\\n/g, '<br>');\n      await Ui.swal().fire({\n        html: `<span class=\"red\">${text}</span>`,\n        footer: footer ? Xss.htmlSanitize(footer) : '',\n        allowOutsideClick: false,\n        customClass: {\n          popup: 'ui-modal-error',\n          confirmButton: 'ui-modal-error-confirm',\n        },\n      });\n      Ui.activateModalPageLinkTags(); // in case the page itself has data-swal-page links\n    },\n    /**\n     * Presents a modal where user can respond with confirm or cancel.\n     * Awaiting this will give you the users choice as a boolean.\n     */\n    confirm: async (text: string, isHTML: boolean = false, footer?: string): Promise<boolean> => {\n      const html = isHTML ? Xss.htmlSanitize(text) : Xss.escape(text).replace(/\\n/g, '<br>');\n      const userResponsePromise = Ui.swal().fire({\n        html,\n        footer: footer ? Xss.htmlSanitize(footer) : '',\n        allowOutsideClick: false,\n        showCancelButton: true,\n        customClass: {\n          popup: 'ui-modal-confirm',\n          confirmButton: 'ui-modal-confirm-confirm',\n          cancelButton: 'ui-modal-confirm-cancel',\n        },\n      });\n      Ui.activateModalPageLinkTags(); // in case the page itself has data-swal-page links\n      const { dismiss } = await userResponsePromise;\n      return typeof dismiss === 'undefined';\n    },\n    confirmWithCheckbox: async (label: string, html: string = ''): Promise<boolean> => {\n      const userResponsePromise = Ui.swal().fire({\n        html,\n        input: 'checkbox',\n        inputPlaceholder: label,\n        allowOutsideClick: false,\n        customClass: {\n          popup: 'ui-modal-confirm-checkbox',\n          confirmButton: 'ui-modal-confirm-checkbox-confirm',\n          cancelButton: 'ui-modal-confirm-checkbox-cancel',\n          input: 'ui-modal-confirm-checkbox-input',\n        },\n        didOpen: () => {\n          const input = Swal.getInput()!;\n          const confirmButton = Swal.getConfirmButton()!;\n          $(confirmButton).prop('disabled', true);\n          $(input).on('change', () => {\n            $(confirmButton).prop('disabled', !input.checked);\n          });\n        }\n      });\n      Ui.activateModalPageLinkTags(); // in case the page itself has data-swal-page links\n      const { dismiss } = await userResponsePromise;\n      return typeof dismiss === 'undefined';\n    },\n    page: async (htmlUrl: string, replaceNewlines = false): Promise<void> => {\n      let html = await (await fetch(htmlUrl)).text();\n      html = Xss.htmlSanitize(html);\n      if (replaceNewlines) {\n        html = html.replace(/\\n/g, '<br>');\n      }\n      await Ui.swal().fire({\n        didOpen: () => {\n          Swal.getCloseButton()!.blur();\n        },\n        html,\n        width: 750,\n        showCloseButton: true,\n        scrollbarPadding: true,\n        showConfirmButton: false,\n        customClass: {\n          container: 'ui-modal-page',\n          popup: 'ui-modal-iframe'\n        }\n      });\n      Ui.activateModalPageLinkTags(); // in case the page itself has data-swal-page links\n    },\n    iframe: async (iframeUrl: string, iframeWidth: number, iframeHeight: number): Promise<void> => {\n      await Ui.swal().fire({\n        didOpen: () => {\n          $(Swal.getPopup()!).attr('data-test', 'dialog');\n          $(Swal.getCloseButton()!).attr('data-test', 'dialog-close').blur();\n        },\n        willClose: () => {\n          const urlWithoutPageParam = Url.removeParamsFromUrl(window.location.href, ['page']);\n          window.history.pushState('', '', urlWithoutPageParam);\n        },\n        keydownListenerCapture: true,\n        html: `<iframe src=\"${Xss.escape(iframeUrl)}\" width=\"${iframeWidth}\" height=\"${iframeHeight}\" style=\"border: 0\"></iframe>`,\n        width: 'auto',\n        backdrop: 'rgba(0, 0, 0, 0.6)',\n        showCloseButton: true,\n        scrollbarPadding: true,\n        showConfirmButton: false,\n        customClass: {\n          popup: 'ui-modal-iframe'\n        }\n      });\n    },\n    fullscreen: async (html: string): Promise<void> => {\n      await Ui.swal().fire({\n        didOpen: () => {\n          $(Swal.getPopup()!).attr('data-test', 'dialog');\n        },\n        html: Xss.htmlSanitize(html),\n        grow: 'fullscreen',\n        showConfirmButton: false,\n        customClass: {\n          container: 'ui-modal-fullscreen'\n        }\n      });\n    },\n    attachmentPreview: async (iframeUrl: string): Promise<void> => {\n      await Ui.swal().fire({\n        didOpen: () => {\n          $(Swal.getPopup()!).attr('data-test', 'attachment-dialog');\n          $(Swal.getCloseButton()!).attr('data-test', 'dialog-close');\n        },\n        html: `<iframe src=\"${Xss.escape(iframeUrl)}\" style=\"border: 0\" sandbox=\"allow-scripts allow-same-origin allow-downloads\"></iframe>`,\n        showConfirmButton: false,\n        showCloseButton: true,\n        grow: 'fullscreen',\n        customClass: {\n          container: 'ui-modal-attachment'\n        }\n      });\n    },\n  };\n\n\n  public static testCompatibilityLink = '<a href=\"/chrome/settings/modules/compatibility.htm\" target=\"_blank\">Test your OpenPGP key compatibility</a>';\n\n  public static activateModalPageLinkTags = () => {\n    $('[data-swal-page]').click(Ui.event.handle(async (target) => {\n      await Ui.modal.page($(target).data('swal-page') as string);\n    }));\n  }\n\n  public static retryLink = (caption: string = 'retry') => {\n    return `<a href=\"${Xss.escape(window.location.href)}\" data-test=\"action-retry-by-reloading\">${Xss.escape(caption)}</a>`;\n  }\n\n  public static delay = async (ms: number): Promise<void> => {\n    return await new Promise(resolve => Catch.setHandledTimeout(resolve, ms));\n  }\n\n  public static spinner = (color: string, placeholderCls: \"small_spinner\" | \"large_spinner\" = 'small_spinner') => {\n    const path = `/img/svgs/spinner-${color}-small.svg`;\n    const url = typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.getURL ? chrome.runtime.getURL(path) : path;\n    return `<i class=\"${placeholderCls}\" data-test=\"spinner\"><img src=\"${url}\" /></i>`;\n  }\n\n  public static renderOverlayPromptAwaitUserChoice = async (btns: Dict<{ title?: string, color?: string }>, prompt: string, details?: string): Promise<string> => {\n    return await new Promise(resolve => {\n      const getEscapedColor = (id: string) => Xss.escape(btns[id].color || 'green');\n      const getEscapedTitle = (id: string) => Xss.escape(btns[id].title || id.replace(/_/g, ' '));\n      const formatBtn = (id: string) => {\n        return `<button class=\"button ${getEscapedColor(id)} overlay_action_${Xss.escape(id)}\" data-test=\"action-overlay-${Xss.escape(id)}\">${getEscapedTitle(id)}</button>`;\n      };\n      const formattedBtns = Object.keys(btns).map(formatBtn).join('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');\n      if (details) {\n        const a = `<a href=\"#\" class=\"action-show-overlay-details\" data-test=\"action-show-overlay-details\" style=\"display:block;text-align:center;\">Show technical details</a>`;\n        details = `${a}<pre style=\"font-size:10px;width:900px;overflow-x:scroll;margin:0 auto;\" class=\"display_none\" data-test=\"container-overlay-details\">\n          ${details.replace(/\\n/g, '<br>')}\n        </pre>`;\n      }\n      // tslint:disable-next-line:no-floating-promises\n      Ui.modal.fullscreen(`\n        <div class=\"line\" data-test=\"container-overlay-prompt-text\">${prompt.replace(/\\n/g, '<br>')}</div>\n        <div class=\"line\">${formattedBtns}</div>\n        <div class=\"line\">&nbsp;</div>\n        <div style=\"font-size:12px;\">${details || ''}</div>\n        <div class=\"line\">&nbsp;</div>\n        <div class=\"line\">Email human@flowcrypt.com if you need assistance.</div>\n      `);\n      const overlay = $(Swal.getHtmlContainer()!);\n      overlay.find('.action-show-overlay-details').one('click', Ui.event.handle(target => {\n        $(target).hide().siblings('pre').show();\n      }));\n      for (const id of Object.keys(btns)) {\n        overlay.find(`.overlay_action_${id}`).one('click', Ui.event.handle(() => {\n          Swal.close();\n          resolve(id);\n        }));\n      }\n    });\n  }\n\n  public static escape = (callback: () => void) => {\n    return (e: JQuery.Event<HTMLElement, null>) => { // returns a function\n      if (!e.metaKey && !e.ctrlKey && e.key === 'Escape') {\n        callback();\n      }\n    };\n  }\n\n  public static tab = (callback: (e: JQuery.Event<HTMLElement>) => void) => {\n    return (e: JQuery.Event<HTMLElement>) => { // returns a function\n      if (!e.metaKey && !e.ctrlKey && !e.shiftKey && e.key === 'Tab') {\n        callback(e);\n      }\n    };\n  }\n\n  public static shiftTab = (callback: (e: JQuery.Event<HTMLElement>) => void) => {\n    return (e: JQuery.Event<HTMLElement>) => { // returns a function\n      if (!e.metaKey && !e.ctrlKey && e.shiftKey && e.key === 'Tab') {\n        callback(e);\n      }\n    };\n  }\n\n  public static enter = (callback: () => void) => {\n    return (e: JQuery.Event<HTMLElement, null>) => { // returns a function\n      if (!e.metaKey && !e.ctrlKey && e.key === 'Enter') {\n        callback();\n      }\n    };\n  }\n\n  public static ctrlEnter = (callback: () => void) => {\n    return (e: JQuery.Event<HTMLElement, null>) => { // returns a function\n      if (\n        (e.metaKey || e.ctrlKey) &&\n        (e.key === 'Enter' || e.keyCode === 10) // https://bugs.chromium.org/p/chromium/issues/detail?id=79407\n      ) {\n        callback();\n      }\n    };\n  }\n\n  public static setTestState = (state: 'ready' | 'working' | 'waiting') => {\n    $('body').attr('data-test-state', state); // for automated tests\n  }\n\n  public static buildJquerySels = (sels: Dict<string>): SelCache => {\n    const cache: NamedSels = {};\n    return {\n      cached: (name: string) => {\n        if (!cache[name]) {\n          if (typeof sels[name] === 'undefined') {\n            Catch.report('unknown selector name: ' + name);\n          }\n          cache[name] = $(sels[name]);\n        }\n        return cache[name];\n      },\n      now: (name: string) => {\n        if (typeof sels[name] === 'undefined') {\n          Catch.report('unknown selector name: ' + name);\n        }\n        return $(sels[name]);\n      },\n      sel: (name: string) => {\n        if (typeof sels[name] === 'undefined') {\n          Catch.report('unknown selector name: ' + name);\n        }\n        return sels[name];\n      }\n    };\n  }\n\n  public static scroll = (sel: string | JQuery<HTMLElement>, repeat: number[] = []) => {\n    const el = $(sel as string).first()[0]; // as string due to JQuery TS quirk. Do not convert to String() as this may actually be JQuery<HTMLElement>\n    if (el) {\n      el.scrollIntoView();\n      for (const delay of repeat) { // useful if mobile keyboard is about to show up\n        Catch.setHandledTimeout(() => el.scrollIntoView(), delay);\n      }\n    }\n  }\n\n  public static e(name: string, attrs: Dict<string>) {\n    return $(`<${name}/>`, attrs)[0].outerHTML; // xss-tested: jquery escapes attributes\n  }\n\n  public static toast = (msg: string, seconds = 2) => {\n    // tslint:disable-next-line:no-floating-promises\n    Ui.swal().fire({\n      toast: true,\n      title: msg,\n      showConfirmButton: false,\n      position: 'bottom',\n      timer: seconds * 1000,\n      timerProgressBar: true,\n      customClass: {\n        container: 'ui-toast-container',\n        popup: 'ui-toast',\n        title: 'ui-toast-title'\n      },\n      didOpen: (toast) => {\n        toast.addEventListener('mouseenter', Swal.stopTimer);\n        toast.addEventListener('mouseleave', Swal.resumeTimer);\n      }\n    });\n  }\n\n  private static swal = () => Swal.mixin({\n    showClass: { popup: 'swal2-noanimation', backdrop: 'swal2-noanimation' },\n    hideClass: { popup: '', backdrop: '' },\n  })\n}\n",
    "test/source/async-stack.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n(() => {\n\n  type Type = 'error' | 'object';\n\n  const wait = (): Promise<void> => new Promise(resolve => setTimeout(resolve, 100));\n\n  const acceptCb = (cb: () => Promise<number | void>) => { // eslint-disable-line @typescript-eslint/no-unused-vars\n    // nothing\n  };\n\n  acceptCb(async () => { // test if will get replaced\n    await wait();\n  });\n\n  acceptCb(async () => { // test if will get replaced\n    Math.random();\n  });\n\n  acceptCb(async () => await wait()); // test if will get replaced\n\n  acceptCb(async () => Math.random()); // test if will get replaced\n\n  const thisWillFail = (type: Type) => {\n    if (type === 'error') {\n      throw new Error('this failed');\n    } else if (type === 'object') {\n      throw { nonsense: 'yes' };\n    }\n  };\n\n  function func(type: Type) {\n    thisWillFail(type);\n  }\n\n  class Class {\n    public static staticConstAttr = (type: Type) => {\n      func(type);\n    }\n    public static staticFunc(type: Type) {\n      Class.staticConstAttr(type);\n    }\n  }\n\n  const asyncArrowConst = async (type: Type) => {\n    await wait();\n    Class.staticFunc(type);\n    await wait();\n  };\n\n  async function asyncFunc(type: Type) {\n    await wait();\n    await asyncArrowConst(type);\n    await wait();\n  }\n\n  const obj = {\n    paramFunc: async (type: Type) => {\n      await asyncFunc(type);\n    },\n  };\n\n  class ClassAsync {\n    public static staticConstAttrAsync = async (type: Type) => {\n      await wait();\n      await obj.paramFunc(type);\n      await wait();\n    }\n    public static async staticAsyncFunc(type: Type) {\n      await wait();\n      await ClassAsync.staticConstAttrAsync(type);\n      await wait();\n    }\n  }\n\n  (async () => {\n\n    const doTestWith = async (type: Type, expectedStackStatements: string[]) => {\n      try {\n        await ClassAsync.staticAsyncFunc(type);\n      } catch (e) {\n        if (!(e instanceof Error)) {\n          console.error(`Thrown was unexpectedly not an error for type ${type}`, e);\n          return process.exit(1);\n        }\n        for (const statement of expectedStackStatements) {\n          if ((e.stack || '').indexOf(statement) === -1) {\n            console.error(`Unexpected stack format for type ${type}:\\n${e.stack}\\n\\n\\nExpected to include:\\n${expectedStackStatements.join('\\n')}`);\n            process.exit(1);\n          }\n        }\n        if (type === 'object' && JSON.stringify((e as any).thrown) !== '{\"nonsense\":\"yes\"}') {\n          console.error(`Unexpected e.throw for type ${type}:\\n${JSON.stringify((e as any).thrown)}`);\n          process.exit(1);\n        }\n        return;\n      }\n      console.error(`Fail - expected Error to be thrown for type ${type}`);\n      return process.exit(1);\n    };\n\n    try {\n      await doTestWith('error', [\n        'Error: this failed',\n        ' at thisWillFail ',\n        ' at func ',\n        ' at Function.Class.staticConstAttr ',\n        ' at Function.staticFunc ',\n        ' at asyncArrowConst ',\n        ' at <async> asyncArrowConst ',\n        ' at <async> asyncFunc ',\n        ' at <async> paramFunc ',\n        ' at <async> staticConstAttrAsync ',\n        ' at <async> staticAsyncFunc ',\n      ]);\n      await doTestWith('object', [\n        'Error: Thrown[object][object Object]',\n        ' at asyncArrowConst ',\n        ' at <async> asyncFunc ',\n        ' at <async> paramFunc ',\n        ' at <async> staticConstAttrAsync ',\n        ' at <async> staticAsyncFunc ',\n      ]);\n      process.exit(0);\n    } catch (e) {\n      console.error(e);\n      return process.exit(1);\n    }\n\n  })().catch(e => {\n    console.error(e);\n    process.exit(1);\n  });\n\n})();\n",
    "test/source/browser/browser-handle.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { Browser, EvaluateFn, Page, Target } from 'puppeteer';\nimport { Util, Config } from '../util';\nimport { ControllablePage } from './controllable';\nimport { Semaphore } from './browser-pool';\nimport { TIMEOUT_ELEMENT_APPEAR } from '.';\nimport { AvaContext } from '../tests/tooling';\n\nexport class BrowserHandle {\n\n  public pages: ControllablePage[] = [];\n  public browser: Browser;\n  private semaphore: Semaphore;\n  private viewport: { height: number, width: number };\n\n  constructor(browser: Browser, semaphore: Semaphore, height: number, width: number) {\n    this.browser = browser;\n    this.semaphore = semaphore;\n    this.viewport = { height, width };\n  }\n\n  public newPage = async (t: AvaContext, url?: string, initialScript?: EvaluateFn): Promise<ControllablePage> => {\n    const page = await this.browser.newPage();\n    await page.setViewport(this.viewport);\n    const controllablePage = new ControllablePage(t, page);\n    if (url) {\n      if (initialScript) {\n        await page.evaluateOnNewDocument(initialScript);\n      }\n      await controllablePage.goto(url);\n    }\n    this.pages.push(controllablePage);\n    if (url && url.includes(Config.extensionId)) {\n      await controllablePage.waitUntilViewLoaded();\n    }\n    return controllablePage;\n  }\n\n  public newPageTriggeredBy = async (t: AvaContext, triggeringAction: () => Promise<void>): Promise<ControllablePage> => {\n    const page = await this.doAwaitTriggeredPage(triggeringAction) as Page;\n    const url = page.url();\n    const controllablePage = new ControllablePage(t, page);\n    try {\n      await page.setViewport(this.viewport);\n      this.pages.push(controllablePage);\n      if (url.includes(Config.extensionId)) {\n        await controllablePage.waitUntilViewLoaded();\n      }\n      return controllablePage;\n    } catch (e) {\n      if (String(e).includes('page has been closed') && url.includes('localhost') && url.includes('/o/oauth2/auth')) {\n        // the extension may close the auth page after success before we had a chance to evaluate it\n        return controllablePage; // returning already closed auth page\n      }\n      throw e;\n    }\n  }\n\n  public closeAllPages = async () => {\n    for (const page of await this.browser.pages()) {\n      if (page.url() !== 'about:blank') {\n        await page.close();\n      }\n    }\n    this.pages = [];\n  }\n\n  public close = async () => {\n    await this.browser.close();\n    this.semaphore.release();\n  }\n\n  public release = () => {\n    this.semaphore.release();\n  }\n\n  public debugPagesHtml = async (t: AvaContext, alsoLogToConsole: boolean) => {\n    let html = '';\n    for (let i = 0; i < this.pages.length; i++) {\n      const cPage = this.pages[i];\n      const url = await Promise.race([cPage.page.url(), new Promise(resolve => setTimeout(() => resolve('(url get timeout)'), 10 * 1000)) as Promise<string>]);\n      const consoleMsgs = await cPage.console(t, alsoLogToConsole);\n      const alerts = cPage.alerts.map(a => `${a.active ? `<b class=\"c-error\">ACTIVE ${a.target.type()}</b>` : a.target.type()}: ${a.target.message()}`).join('\\n');\n      html += '<div class=\"page\">';\n      html += `<pre title=\"url\">Page ${i} (${cPage.page.isClosed() ? 'closed' : 'active'}) ${Util.htmlEscape(url)}</pre>`;\n      html += `<pre title=\"console\">${consoleMsgs || '(no console messages)'}</pre>`;\n      html += `<pre title=\"alerts\">${alerts || '(no alerts)'}</pre>`;\n      if (url !== 'about:blank' && !cPage.page.isClosed()) {\n        try {\n          html += `<img src=\"data:image/png;base64,${await cPage.screenshot()}\"><br>`;\n        } catch (e) {\n          html += `<div style=\"border:1px solid white;\">Could not get screen shot: ${Util.htmlEscape(e instanceof Error ? e.stack || String(e) : String(e))}</div>`;\n        }\n        try {\n          html += `<pre style=\"height:300px;overflow:auto;\">${Util.htmlEscape(await cPage.html())}</pre>`;\n        } catch (e) {\n          html += `<pre>Could not get page HTML: ${Util.htmlEscape(e instanceof Error ? e.stack || String(e) : String(e))}</pre>`;\n        }\n      }\n      html += '</div>';\n    }\n    return html;\n  }\n\n  private doAwaitTriggeredPage = (triggeringAction: () => Promise<void>): Promise<Page | null> => {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => reject(new Error('Action did not trigger a new page within timeout period')), TIMEOUT_ELEMENT_APPEAR * 1000);\n      let resolved = 0;\n      const listener = async (target: Target) => {\n        if (target.type() === 'page') {\n          if (!resolved++) {\n            this.browser.removeListener('targetcreated', listener);\n            target.page().then(resolve, reject);\n          }\n        }\n      };\n      this.browser.on('targetcreated', listener);\n      triggeringAction().catch(console.error);\n    });\n  }\n\n}\n",
    "test/source/browser/browser-pool.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { Util } from \"../util\";\nimport { BrowserHandle } from './browser-handle';\nimport { Consts } from '../test';\nimport { TIMEOUT_DESTROY_UNEXPECTED_ALERT } from '.';\nimport { launch } from \"puppeteer\";\nimport { addDebugHtml, AvaContext, newWithTimeoutsFunc } from '../tests/tooling';\n\nclass TimeoutError extends Error { }\n\nexport class BrowserPool {\n\n  private semaphore: Semaphore;\n  private browsersForReuse: BrowserHandle[] = [];\n\n  constructor(\n    public poolSize: number,\n    public name: string,\n    private reuse: boolean,\n    private extensionBuildDir: string,\n    private isMock: boolean,\n    private width = 1280,\n    private height = 850,\n    private debug = false,\n  ) {\n    this.semaphore = new Semaphore(poolSize, name);\n  }\n\n  public newBrowserHandle = async (t: AvaContext, closeInitialPage = true) => {\n    await this.semaphore.acquire();\n    // ext frames in gmail: https://github.com/GoogleChrome/puppeteer/issues/2506 https://github.com/GoogleChrome/puppeteer/issues/2548\n    const args = [\n      '--no-sandbox', // make it work in travis-ci\n      '--disable-setuid-sandbox',\n      '--disable-features=site-per-process',\n      `--disable-extensions-except=${this.extensionBuildDir}`,\n      `--load-extension=${this.extensionBuildDir}`,\n      `--window-size=${this.width + 10},${this.height + 132}`,\n    ];\n    if (this.isMock) {\n      args.push('--ignore-certificate-errors');\n      args.push('--allow-insecure-localhost');\n    }\n    const slowMo = this.isMock ? 60 : 60;\n    const browser = await launch({ args, ignoreHTTPSErrors: this.isMock, headless: false, devtools: false, slowMo });\n    const handle = new BrowserHandle(browser, this.semaphore, this.height, this.width);\n    if (closeInitialPage) {\n      try {\n        const initialPage = await handle.newPageTriggeredBy(t, () => Promise.resolve()); // the page triggered on its own\n        await initialPage.waitAll('@initial-page'); // first page opened by flowcrypt\n        await initialPage.close();\n      } catch (e) {\n        if (String(e).includes('Action did not trigger a new page within timeout period')) { // could have opened before we had a chance to add a handler above\n          const pages = await handle.browser.pages();\n          const initialPage = pages.find(p => p.url().includes('chrome/settings/initial.htm'));\n          if (!initialPage) {\n            throw e;\n          }\n          await initialPage.close();\n        } else {\n          throw e;\n        }\n      }\n    }\n    return handle;\n  }\n\n  public getExtensionId = async (t: AvaContext): Promise<string> => {\n    const browser = await this.newBrowserHandle(t, false);\n    for (const i of [1, 2, 3, 4, 5]) {\n      await Util.sleep(2);\n      const pages = await browser.browser.pages();\n      const urls = pages.map(page => page.url());\n      const extensionUrl = urls.find(url => url !== 'about:blank');\n      if (extensionUrl) {\n        const match = extensionUrl.match(/[a-z]{32}/);\n        if (match !== null) {\n          await browser.close();\n          return match[0];\n        }\n      }\n      if (i === 5) {\n        await browser.close();\n        throw new Error(`Cannot determine extension id from urls |${urls.join('|')}|`);\n      }\n    }\n    await browser.close();\n    throw new Error(`Cannot determine extension id from urls.`);\n  }\n\n  public close = async () => {\n    while (this.browsersForReuse.length) {\n      await this.browsersForReuse.pop()!.close();\n    }\n  }\n\n  public openOrReuseBrowser = async (t: AvaContext): Promise<BrowserHandle> => {\n    if (!this.reuse) {\n      return await this.newBrowserHandle(t);\n    }\n    await this.semaphore.acquire();\n    return this.browsersForReuse.pop()!;\n  }\n\n  public doneUsingBrowser = async (browser: BrowserHandle) => {\n    if (this.reuse) {\n      await browser.closeAllPages();\n      this.browsersForReuse.push(browser);\n      browser.release();\n    } else {\n      await browser.close();\n    }\n  }\n\n  public getPooledBrowser = async (cb: (t: AvaContext, browser: BrowserHandle) => void, t: AvaContext) => {\n    const browser = await this.openOrReuseBrowser(t);\n    try {\n      await cb(t, browser);\n    } finally {\n      await Util.sleep(1);\n      await this.doneUsingBrowser(browser);\n    }\n  }\n\n  public cbWithTimeout = (cb: () => Promise<void>, timeout: number): Promise<void> => {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => reject(new TimeoutError(`Test timed out after ${timeout}ms`)), timeout); // reject in\n      cb().then(resolve, reject);\n    });\n  }\n\n  public withNewBrowserTimeoutAndRetry = async (cb: (t: AvaContext, browser: BrowserHandle) => void, t: AvaContext, consts: Consts, flag?: 'FAILING') => {\n    const withTimeouts = newWithTimeoutsFunc(consts);\n    const attemptDebugHtmls: string[] = [];\n    t.totalAttempts = flag === 'FAILING' ? 1 : consts.ATTEMPTS;\n    for (let attemptNumber = 1; attemptNumber <= t.totalAttempts; attemptNumber++) {\n      t.attemptNumber = attemptNumber;\n      t.attemptText = `(attempt ${t.attemptNumber} of ${t.totalAttempts})`;\n      try {\n        const browser = await withTimeouts(this.newBrowserHandle(t));\n        try {\n          await withTimeouts(this.cbWithTimeout(async () => await cb(t, browser), consts.TIMEOUT_EACH_RETRY));\n          await this.throwOnRetryFlagAndReset(t);\n          if (attemptDebugHtmls.length && flag !== 'FAILING') { // don't debug known failures\n            addDebugHtml(`<h1>Test (later succeeded): ${Util.htmlEscape(t.title)}</h1>${attemptDebugHtmls.join('')}`);\n          }\n          return;\n        } catch (err) {\n          attemptDebugHtmls.push(await this.testFailSingleAttemptDebugHtml(t, browser, err));\n          throw err;\n        } finally {\n          await Util.sleep(1);\n          await browser.close();\n        }\n      } catch (err) {\n        this.processTestError(err, t, attemptDebugHtmls, flag);\n      }\n    }\n  }\n\n  private processTestError = (err: any, t: AvaContext, attemptHtmls: string[], flag?: 'FAILING') => {\n    t.retry = undefined;\n    if (t.attemptNumber! < t.totalAttempts!) {\n      t.log(`${t.attemptText} Retrying: ${String(err)}`);\n    } else {\n      if (flag !== 'FAILING') { // don't debug known failures\n        addDebugHtml(`<h1>Test: ${Util.htmlEscape(t.title)}</h1>${attemptHtmls.join('')}`);\n      }\n      t.log(`${t.attemptText} Failed:   ${err instanceof Error ? err.stack : String(err)}`);\n      t.fail(`[ALL RETRIES FAILED for ${t.title}]`);\n    }\n  }\n\n  private testFailSingleAttemptDebugHtml = async (t: AvaContext, browser: BrowserHandle, err: any): Promise<string> => {\n    return `\n    <div class=\"attempt\">\n      <div style=\"display:none;\">\n        <pre title=\"err.stack\">${Util.htmlEscape((err instanceof Error ? err.stack : String(err)) || String(err))}</pre>\n        ${await browser.debugPagesHtml(t, this.debug)}\n      </div>\n      <a href=\"#\" onclick=\"this.style.display='none';this.parentNode.firstElementChild.style = '';\">${String(err)}</a>\n    </div>\n    `;\n  }\n\n  private throwOnRetryFlagAndReset = async (t: AvaContext) => {\n    await Util.sleep(TIMEOUT_DESTROY_UNEXPECTED_ALERT + 1); // in case there was an unexpected alert, don't let that affect next round\n    if (t.retry) {\n      t.retry = undefined;\n      const e = new Error(`last attempt marked for retry`);\n      e.stack = e.message; // stack is not interesting here, too much clutter would be printed\n      throw e;\n    }\n  }\n\n}\n\nexport class Semaphore {\n\n  private availableLocks: number;\n  private name: string;\n  private debug = false;\n\n  constructor(poolSize: number, name = 'semaphore') {\n    this.availableLocks = poolSize;\n    this.name = name;\n  }\n\n  public acquire = async () => {\n    let i = 0;\n    while (this.availableLocks < 1) {\n      if (this.debug) {\n        console.info(`[${this.name}] waiting for semaphore attempt ${i++}, now available: ${this.availableLocks}`);\n      }\n      await this.wait();\n    }\n    if (this.debug) {\n      console.info(`[${this.name}] acquiring, semaphors available: ${this.availableLocks}`);\n    }\n    this.availableLocks--;\n    if (this.debug) {\n      console.info(`[${this.name}] acquired, now avaialbe: ${this.availableLocks}`);\n    }\n  }\n\n  public release = () => {\n    if (this.debug) {\n      console.info(`[${this.name}] releasing semaphore, previously available: ${this.availableLocks}`);\n    }\n    this.availableLocks++;\n    if (this.debug) {\n      console.info(`[${this.name}] released semaphore, now available: ${this.availableLocks}`);\n    }\n  }\n\n  private wait = () => {\n    return new Promise(resolve => setTimeout(resolve, 1000 + Math.round(Math.random() * 2000))); // wait 1-3s\n  }\n\n}\n",
    "test/source/mock/google/google-data.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { AddressObject, ParsedMail, StructuredHeader } from 'mailparser';\n\nimport { Util } from '../../util/index';\nimport { readFile, readdir } from 'fs';\n\ntype GmailMsg$header = { name: string, value: string };\ntype GmailMsg$payload$body = { attachmentId?: string, size: number, data?: string };\ntype GmailMsg$payload$part = { partId?: string, body?: GmailMsg$payload$body, filename?: string, mimeType?: string, headers?: GmailMsg$header[], parts?: GmailMsg$payload$part[] };\ntype GmailMsg$payload = { partId?: string, filename?: string, parts?: GmailMsg$payload$part[], headers?: GmailMsg$header[], mimeType?: string, body?: GmailMsg$payload$body };\ntype GmailMsg$labelId = 'INBOX' | 'UNREAD' | 'CATEGORY_PERSONAL' | 'IMPORTANT' | 'SENT' | 'CATEGORY_UPDATES' | 'DRAFT';\ntype GmailThread = { historyId: string; id: string; snippet: string; };\ntype Label = { id: string, name: \"CATEGORY_SOCIAL\", messageListVisibility: \"hide\", labelListVisibility: \"labelHide\", type: 'system' };\ntype AcctDataFile = { messages: GmailMsg[]; drafts: GmailMsg[], attachments: { [id: string]: { data: string, size: number, filename?: string } }, labels: Label[] };\ntype ExportedMsg = { acctEmail: string, full: GmailMsg, raw: GmailMsg, attachments: { [id: string]: { data: string, size: number } } };\n\nexport class GmailMsg {\n\n  public id: string;\n  public historyId: string;\n  public sizeEstimate?: number;\n  public threadId: string | null;\n  public payload?: GmailMsg$payload;\n  public internalDate?: number | string;\n  public labelIds?: GmailMsg$labelId[];\n  public snippet?: string;\n  public raw?: string;\n\n  constructor(msg: { id: string, labelId: GmailMsg$labelId, raw: string, mimeMsg: ParsedMail }) {\n    this.id = msg.id;\n    this.historyId = msg.id;\n    this.threadId = msg.id;\n    this.labelIds = [msg.labelId];\n    this.raw = msg.raw;\n    const contentTypeHeader = msg.mimeMsg.headers.get('content-type')! as StructuredHeader;\n    const toHeader = msg.mimeMsg.headers.get('to')! as AddressObject;\n    const fromHeader = msg.mimeMsg.headers.get('from')! as AddressObject;\n    const subjectHeader = msg.mimeMsg.headers.get('subject')! as string;\n    const dateHeader = msg.mimeMsg.headers.get('date')! as Date;\n    const messageIdHeader = msg.mimeMsg.headers.get('message-id')! as string;\n    const mimeVersionHeader = msg.mimeMsg.headers.get('mime-version')! as string;\n    let body;\n    if (msg.mimeMsg.text) {\n      const textBase64 = Buffer.from(msg.mimeMsg.text, 'utf-8').toString('base64');\n      body = { attachmentId: '', size: textBase64.length, data: textBase64 };\n    } else if (typeof msg.mimeMsg.html === 'string') {\n      const htmlBase64 = Buffer.from(msg.mimeMsg.html, 'utf-8').toString('base64');\n      body = { attachmentId: '', size: htmlBase64.length, data: htmlBase64 };\n    }\n    this.payload = {\n      mimeType: contentTypeHeader.value,\n      headers: [\n        { name: \"Content-Type\", value: `${contentTypeHeader.value}; boundary=\\\"${contentTypeHeader.params.boundary}\\\"` },\n        { name: \"Message-Id\", value: messageIdHeader },\n        { name: \"Mime-Version\", value: mimeVersionHeader }\n      ],\n      body\n    };\n    if (toHeader) {\n      this.payload.headers!.push({ name: 'To', value: toHeader.value.map(a => a.address).join(',') });\n    }\n    if (fromHeader) {\n      this.payload.headers!.push({ name: 'From', value: fromHeader.value[0].address! });\n    }\n    if (subjectHeader) {\n      this.payload.headers!.push({ name: 'Subject', value: subjectHeader });\n    }\n    if (dateHeader) {\n      this.payload.headers!.push({ name: 'Date', value: dateHeader.toString() });\n    }\n  }\n}\n\nexport class GmailParser {\n\n  public static findHeader = (apiGmailMsgObj: GmailMsg | GmailMsg$payload, headerName: string) => {\n    const node: GmailMsg$payload = apiGmailMsgObj.hasOwnProperty('payload') ? (apiGmailMsgObj as GmailMsg).payload! : apiGmailMsgObj as GmailMsg$payload;\n    if (typeof node.headers !== 'undefined') {\n      for (const header of node.headers) {\n        if (header.name.toLowerCase() === headerName.toLowerCase()) {\n          return header.value;\n        }\n      }\n    }\n    return undefined;\n  }\n\n}\n\nconst DATA: { [acct: string]: AcctDataFile } = {};\n\n/**\n * This class is badly designed - it acts like a class (whose object should contain its own data),\n *   but the data is shared globally across objects. Would be more appropriate to make this a static class.\n *   Either that, or have each instance hold data independently (unless it turns out there are memory issues)\n */\nexport class GoogleData {\n\n  /**\n   * This is the proper way to add messages to mock api for testing:\n   *   1) log into flowcrypt.compatibility@gmail.com\n   *   2) go to Settings -> Inbox and find your message\n   *   3) click \"download api export\"\n   *   4) save the json file to exported-messages folder\n   */\n  private static exportedMsgsPath = './test/source/mock/google/exported-messages/';\n\n  private exludePplSearchQuery = /(?:-from|-to):\"?([a-zA-Z0-9@.\\-_]+)\"?/g;\n  private includePplSearchQuery = /(?:from|to):\"?([a-zA-Z0-9@.\\-_]+)\"?/g;\n\n  public static withInitializedData = async (acct: string): Promise<GoogleData> => {\n    if (typeof DATA[acct] === 'undefined') {\n      const acctData: AcctDataFile = { drafts: [], messages: [], attachments: {}, labels: [] };\n      const dir = GoogleData.exportedMsgsPath;\n      const filenames: string[] = await new Promise((res, rej) => readdir(dir, (e, f) => e ? rej(e) : res(f)));\n      const filePromises = filenames.map(f => new Promise((res, rej) => readFile(dir + f, (e, d) => e ? rej(e) : res(d))));\n      const files = await Promise.all(filePromises) as Uint8Array[];\n      for (const file of files) {\n        const utfStr = new TextDecoder().decode(file);\n        const json = JSON.parse(utfStr) as ExportedMsg;\n        if (json.acctEmail === acct) {\n          Object.assign(acctData.attachments, json.attachments);\n          json.full.raw = json.raw.raw;\n          if (json.full.labelIds && json.full.labelIds.includes('DRAFT')) {\n            acctData.drafts.push(json.full);\n          } else {\n            acctData.messages.push(json.full);\n          }\n        }\n      }\n      DATA[acct] = acctData;\n    }\n    return new GoogleData(acct);\n  }\n\n  public static fmtMsg = (m: GmailMsg, format: 'raw' | 'full' | 'metadata' | string) => {\n    format = format || 'full';\n    if (!['raw', 'full', 'metadata'].includes(format)) {\n      throw new Error(`Unknown format: ${format}`);\n    }\n    const msgCopy = JSON.parse(JSON.stringify(m)) as GmailMsg;\n    if (format === 'raw') {\n      if (!msgCopy.raw) {\n        throw new Error(`MOCK: format=raw missing data for message id ${m.id}. Solution: add them to ./test/source/mock/data/acct.json`);\n      }\n    } else {\n      msgCopy.raw = undefined;\n    }\n    if (format === 'metadata' || format === 'raw') {\n      msgCopy.payload!.body = undefined;\n      msgCopy.payload!.parts = undefined;\n    }\n    return msgCopy;\n  }\n\n  private static msgSubject = (m: GmailMsg): string => {\n    const subjectHeader = m.payload && m.payload.headers && m.payload.headers.find(h => h.name === 'Subject');\n    return (subjectHeader && subjectHeader.value) || '';\n  }\n\n  private static msgPeople = (m: GmailMsg): string => {\n    return String(m.payload && m.payload.headers && m.payload.headers.filter(h => h.name === 'To' || h.name === 'From').map(h => h.value!).filter(h => !!h).join(','));\n  }\n\n  constructor(private acct: string) {\n    if (!DATA[acct]) {\n      throw new Error('Missing DATA: use withInitializedData instead of direct constructor');\n    }\n  }\n\n  public storeSentMessage = (parsedMail: ParsedMail, base64Msg: string): string => {\n    let bodyContentAtt: { data: string; size: number; filename?: string; id: string } | undefined;\n    for (const attachment of parsedMail.attachments || []) {\n      const attId = Util.lousyRandom();\n      const gmailAtt = { data: attachment.content.toString('base64'), size: attachment.size, filename: attachment.filename, id: attId };\n      DATA[this.acct].attachments[attId] = gmailAtt;\n      if (attachment.filename === 'encrypted.asc') {\n        bodyContentAtt = gmailAtt;\n      }\n    }\n    let body: GmailMsg$payload$body;\n    const htmlOrText = parsedMail.html || parsedMail.text;\n    if (htmlOrText) {\n      body = { data: htmlOrText, size: htmlOrText.length };\n    } else if (bodyContentAtt) {\n      body = { attachmentId: bodyContentAtt.id, size: bodyContentAtt.size };\n    } else {\n      throw new Error('MOCK storeSentMessage: no parsedMail body, no appropriate bodyContentAtt');\n    }\n    const barebonesGmailMsg: GmailMsg = { // todo - could be improved - very barebones\n      id: `msg_id_${Util.lousyRandom()}`,\n      threadId: null, // tslint:disable-line:no-null-keyword\n      historyId: '',\n      labelIds: ['SENT' as GmailMsg$labelId],\n      payload: {\n        headers: [{ name: 'Subject', value: parsedMail.subject || '' }],\n        body\n      },\n      raw: base64Msg\n    };\n    DATA[this.acct].messages.push(barebonesGmailMsg);\n    return barebonesGmailMsg.id;\n  }\n\n  public getMessage = (id: string): GmailMsg | undefined => {\n    return DATA[this.acct].messages.find(m => m.id === id);\n  }\n\n  public getMessageBySubject = (subject: string): GmailMsg | undefined => {\n    return DATA[this.acct].messages.find(m => {\n      if (m.payload?.headers) {\n        const subjectHeader = m.payload.headers.find(x => x.name === 'Subject');\n        if (subjectHeader) {\n          return subjectHeader.value.includes(subject);\n        }\n      }\n      return false;\n    });\n  }\n\n  public getMessagesByThread = (threadId: string) => {\n    return DATA[this.acct].messages.filter(m => m.threadId === threadId);\n  }\n\n  public searchMessages = (q: string) => {\n    const subject = (q.match(/subject:\"([^\"]+)\"/) || [])[1];\n    if (subject) {\n      // if any subject query found, all else is ignored\n      // messages just filtered by subject\n      return this.searchMessagesBySubject(subject);\n    }\n    const excludePeople = (q.match(this.exludePplSearchQuery) || []).map(e => e.replace(/^(-from|-to):/, '').replace(/\"/g, ''));\n    q = q.replace(this.exludePplSearchQuery, ' ');\n    const includePeople = (q.match(this.includePplSearchQuery) || []).map(e => e.replace(/^(from|to):/, '').replace(/\"/g, ''));\n    if (includePeople.length || excludePeople.length) {\n      // if any to,from query found, all such queries are collected\n      // no distinction made between to and from, just searches headers\n      // to: and from: are joined with OR\n      // -to: and -from: are joined with AND\n      // rest of query ignored\n      return this.searchMessagesByPeople(includePeople, excludePeople);\n    }\n    return [];\n  }\n\n  public addDraft = (id: string, raw: string, mimeMsg: ParsedMail) => {\n    const draft = new GmailMsg({ labelId: 'DRAFT', id, raw, mimeMsg });\n    const index = DATA[this.acct].drafts.findIndex(d => d.id === draft.id);\n    if (index === -1) {\n      DATA[this.acct].drafts.push(draft);\n    } else {\n      DATA[this.acct].drafts[index] = draft;\n    }\n  }\n\n  public getDraft = (id: string): GmailMsg | undefined => {\n    return DATA[this.acct].drafts.find(d => d.id === id);\n  }\n\n  public getAttachment = (attachmentId: string) => {\n    return DATA[this.acct].attachments[attachmentId];\n  }\n\n  public getLabels = () => {\n    return DATA[this.acct].labels;\n  }\n\n  public getThreads = () => {\n    const threads: GmailThread[] = [];\n    for (const thread of DATA[this.acct].messages.map(m => ({ historyId: m.historyId, id: m.threadId!, snippet: `MOCK SNIPPET: ${GoogleData.msgSubject(m)}` }))) {\n      if (thread.id && !threads.map(t => t.id).includes(thread.id)) {\n        threads.push(thread);\n      }\n    }\n    return threads;\n  }\n\n  private searchMessagesBySubject = (subject: string) => {\n    subject = subject.trim().toLowerCase();\n    const messages = DATA[this.acct].messages.filter(m => GoogleData.msgSubject(m).toLowerCase().includes(subject));\n    return messages;\n  }\n\n  private searchMessagesByPeople = (includePeople: string[], excludePeople: string[]) => {\n    includePeople = includePeople.map(person => person.trim().toLowerCase());\n    excludePeople = excludePeople.map(person => person.trim().toLowerCase());\n    return DATA[this.acct].messages.filter(m => {\n      const msgPeople = GoogleData.msgPeople(m).toLowerCase();\n      let shouldInclude = false;\n      let shouldExclude = false;\n      if (includePeople.length) { // filter who to include\n        for (const includePerson of includePeople) {\n          if (msgPeople.includes(includePerson)) {\n            shouldInclude = true;\n            break;\n          }\n        }\n      } else { // do not filter who to include - include any\n        shouldInclude = true;\n      }\n      if (excludePeople.length) { // filter who to exclude\n        for (const excludePerson of excludePeople) {\n          if (msgPeople.includes(excludePerson)) {\n            shouldExclude = true;\n            break;\n          }\n        }\n      } else { // don't exclude anyone\n        shouldExclude = false;\n      }\n      return shouldInclude && !shouldExclude;\n    });\n  }\n\n}\n",
    "test/source/mock/lib/api.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as https from 'https';\nimport * as http from 'http';\nimport { Util } from '../../util';\nimport { readFileSync } from 'fs';\n// tslint:disable:await-returned-promise\n\nexport class HttpAuthErr extends Error { }\nexport class HttpClientErr extends Error {\n  constructor(message: string, public statusCode = 400) {\n    super(message);\n  }\n}\n\nexport enum Status {\n  OK = 200,\n  CREATED = 201,\n  BAD_REQUEST = 400,\n  UNAUTHORIZED = 401,\n  FORBIDDEN = 403,\n  NOT_FOUND = 404,\n  CONFLICT = 409, // conflicts with key on record - request needs to be verified\n  SERVER_ERROR = 500,\n  NOT_IMPLEMENTED = 501,\n}\n\nexport type RequestHandler<REQ, RES> = (parsedReqBody: REQ, req: http.IncomingMessage) => Promise<RES>;\nexport type Handlers<REQ, RES> = { [request: string]: RequestHandler<REQ, RES> };\n\nexport class Api<REQ, RES> {\n\n  public server: https.Server;\n  protected apiName: string;\n  protected maxRequestSizeMb = 0;\n  protected maxRequestSizeBytes = 0;\n  protected throttleChunkMsUpload = 0;\n  protected throttleChunkMsDownload = 0;\n\n  constructor(apiName: string, protected handlers: Handlers<REQ, RES>, protected urlPrefix = '') {\n    this.apiName = apiName;\n    const opt = { key: readFileSync(`./test/mock_cert/key.pem.mock`), cert: readFileSync(`./test/mock_cert/cert.pem.mock`) };\n    this.server = https.createServer(opt, (request, response) => {\n      const start = Date.now();\n      this.handleReq(request, response).then(data => this.throttledResponse(response, data)).then(() => {\n        try {\n          this.log(Date.now() - start, request, response);\n        } catch (e) {\n          console.error(e);\n          process.exit(1);\n        }\n      }).catch((e) => {\n        if (e instanceof HttpAuthErr) {\n          response.statusCode = Status.UNAUTHORIZED;\n          response.setHeader('WWW-Authenticate', `Basic realm=\"${this.apiName}\"`);\n          e.stack = undefined;\n        } else if (e instanceof HttpClientErr) {\n          response.statusCode = e.statusCode;\n          e.stack = undefined;\n        } else {\n          response.statusCode = Status.SERVER_ERROR;\n          if (e instanceof Error && e.message.toLowerCase().includes('intentional error')) {\n            // don't log this, intentional error\n          } else {\n            console.error(`url:${request.method}:${request.url}`, e);\n          }\n        }\n        response.setHeader('Access-Control-Allow-Origin', '*');\n        response.setHeader('content-type', 'application/json');\n        const formattedErr = this.fmtErr(e);\n        response.end(formattedErr);\n        try {\n          this.log(Date.now() - start, request, response, formattedErr);\n        } catch (e) {\n          console.error('error logging req', e);\n        }\n      });\n    });\n  }\n\n  public listen = (port: number, host = '127.0.0.1', maxMb = 100): Promise<void> => {\n    return new Promise((resolve, reject) => {\n      try {\n        this.maxRequestSizeMb = maxMb;\n        this.maxRequestSizeBytes = maxMb * 1024 * 1024;\n        this.server.listen(port, host);\n        this.server.on('listening', () => {\n          const address = this.server.address();\n          const msg = `${this.apiName} listening on ${typeof address === 'object' && address ? address.port : address}`;\n          console.log(msg);\n          resolve();\n        });\n        this.server.on('error', (e) => {\n          console.error('failed to start mock server', e);\n          reject(e);\n        });\n      } catch (e) {\n        console.error('exception when starting mock server', e);\n        reject(e);\n      }\n    });\n  }\n\n  public close = (): Promise<void> => {\n    return new Promise((resolve, reject) => this.server.close((err: any) => err ? reject(err) : resolve()));\n  }\n\n  protected log = (ms: number, req: http.IncomingMessage, res: http.ServerResponse, errRes?: Buffer) => { // eslint-disable-line @typescript-eslint/no-unused-vars\n    return undefined as void;\n  }\n\n  protected handleReq = async (req: http.IncomingMessage, res: http.ServerResponse): Promise<Buffer> => {\n    if (req.method === 'OPTIONS') {\n      res.setHeader('Access-Control-Allow-Origin', '*');\n      res.setHeader('Access-Control-Allow-Headers', '*');\n      res.setHeader('Access-Control-Allow-Methods', 'GET,HEAD,POST,PUT,DELETE,OPTIONS');\n      return this.fmtRes({});\n    }\n    const handler = this.chooseHandler(req);\n    if (handler) {\n      return this.fmtHandlerRes(await handler(this.parseReqBody(await this.collectReq(req), req), req), res);\n    }\n    if ((req.url === '/' || req.url === `${this.urlPrefix}/`) && (req.method === 'GET' || req.method === 'HEAD')) {\n      res.setHeader('content-type', 'application/json');\n      return this.fmtRes({ app_name: this.apiName });\n    }\n    if ((req.url === '/alive' || req.url === `${this.urlPrefix}/alive`) && (req.method === 'GET' || req.method === 'HEAD')) {\n      res.setHeader('content-type', 'application/json');\n      return this.fmtRes({ alive: true });\n    }\n    throw new HttpClientErr(`unknown MOCK path ${req.url}`);\n  }\n\n  protected chooseHandler = (req: http.IncomingMessage): RequestHandler<REQ, RES> | undefined => {\n    if (!req.url) {\n      throw new Error('no url');\n    }\n    if (this.handlers[req.url]) { // direct handler name match\n      return this.handlers[req.url];\n    }\n    const url = req.url.split('?')[0];\n    if (this.handlers[url]) { // direct handler name match - ignoring query\n      return this.handlers[url];\n    }\n    // handler match where definition url ends with \"/?\" - incomplete path definition\n    for (const handlerPathDefinition of Object.keys(this.handlers).filter(def => /\\/\\?$/.test(def))) {\n      if (req.url.startsWith(handlerPathDefinition.replace(/\\?$/, ''))) {\n        return this.handlers[handlerPathDefinition];\n      }\n    }\n  }\n\n  protected fmtErr = (e: any): Buffer => {\n    if (String(e).includes('invalid_grant')) {\n      return Buffer.from(JSON.stringify({ \"error\": \"invalid_grant\", \"error_description\": \"Bad Request\" }));\n    }\n    return Buffer.from(JSON.stringify({ \"error\": { \"message\": e instanceof Error ? e.message : String(e), stack: e instanceof Error ? e.stack : '' } }));\n  }\n\n  protected fmtHandlerRes = (handlerRes: RES, serverRes: http.ServerResponse): Buffer => {\n    if (typeof handlerRes === 'string' && handlerRes.match(/^<!DOCTYPE HTML><html>/)) {\n      serverRes.setHeader('content-type', 'text/html');\n    } else if (typeof handlerRes === 'object' || (typeof handlerRes === 'string' && handlerRes.match(/^\\{/) && handlerRes.match(/\\}$/))) {\n      serverRes.setHeader('content-type', 'application/json');\n    } else if (typeof handlerRes === 'string') {\n      serverRes.setHeader('content-type', 'text/plain');\n    } else {\n      throw new Error(`Don't know how to decide mock response content-type header`);\n    }\n    serverRes.setHeader('Access-Control-Allow-Origin', '*');\n    return this.fmtRes(handlerRes);\n  }\n\n  protected fmtRes = (response: {} | string): Buffer => {\n    if (response instanceof Buffer) {\n      return response;\n    } else if (typeof response === 'string') {\n      return Buffer.from(response);\n    }\n    const json = JSON.stringify(response);\n    return Buffer.from(json);\n  }\n\n  protected collectReq = (req: http.IncomingMessage): Promise<Buffer> => {\n    return new Promise((resolve, reject) => {\n      const body: Buffer[] = [];\n      let byteLength = 0;\n      req.on('data', (chunk: Buffer) => {\n        byteLength += chunk.length;\n        if (this.maxRequestSizeBytes && byteLength > this.maxRequestSizeBytes) {\n          reject(new HttpClientErr(`Message over ${this.maxRequestSizeMb} MB`));\n        } else {\n          body.push(chunk);\n        }\n        if (this.throttleChunkMsUpload && body.length > 2) {\n          req.pause(); // slow down accepting data by a certain amount of ms per chunk\n          setTimeout(() => req.resume(), this.throttleChunkMsUpload);\n        }\n      });\n      req.on('end', () => {\n        try {\n          resolve(Buffer.concat(body));\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n\n  protected parseReqBody = (body: Buffer, req: http.IncomingMessage): REQ => {\n    let parsedBody: string | undefined;\n    if (body.length) {\n      if (req.url!.startsWith('/upload/') || req.url!.startsWith('/api/message/upload') || (req.url!.startsWith('/attester/pub/') && req.method === 'POST')) {\n        parsedBody = body.toString();\n      } else {\n        parsedBody = JSON.parse(body.toString());\n      }\n    }\n    return { query: this.parseUrlQuery(req.url!), body: parsedBody } as unknown as REQ;\n  }\n\n  private throttledResponse = async (response: http.ServerResponse, data: Buffer) => {\n    const chunkSize = 100 * 1024;\n    for (let i = 0; i < data.length; i += chunkSize) {\n      const chunk = data.slice(i, i + chunkSize);\n      response.write(chunk);\n      if (i > 0) {\n        await Util.sleep(this.throttleChunkMsDownload / 1000);\n      }\n    }\n    response.end();\n  }\n\n  private parseUrlQuery = (url: string): { [k: string]: string } => {\n    const queryIndex = url.indexOf('?');\n    if (!queryIndex) {\n      return {};\n    }\n    const queryStr = url.substring(queryIndex + 1);\n    const valuePairs = queryStr.split('&');\n    const params: { [k: string]: string } = {};\n    for (const valuePair of valuePairs) {\n      if (valuePair) {\n        const equalSignSeparatedParts = valuePair.split('=');\n        params[equalSignSeparatedParts.shift()!] = decodeURIComponent(equalSignSeparatedParts.join('='));\n      }\n    }\n    return params;\n  }\n\n}\n",
    "test/source/tests/tooling/index.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as ava from 'ava';\n\nimport { Consts } from '../../test';\n\nexport type AvaContext = ava.ExecutionContext<unknown> & { retry?: true, attemptNumber?: number, totalAttempts?: number, attemptText?: string };\n\nconst MAX_ATT_SIZE = 5 * 1024 * 1024;\n\nconst debugHtmls: string[] = [];\nconst debugHtmlStyle = `\n<style>\n  h1 { margin-top: 50px; margin-left: 20px; }\n  pre { border:1px dotted #ddd; background-color:#fafafa; margin-left: 0px; overflow-x: auto; }\n  div.attempt { padding: 20px; margin: 20px; border-left: 4px solid red; }\n  div.attempt > a { text-decoration: none; font-size: 13px; color: black; }\n  div.attempt .page { padding: 20px; margin: 20px; margin-left: 0px; background: #AAA; }\n  div.attempt .page img { margin: 8px; margin-left: 0; border: 1px solid white; }\n  .c-error { color:red }\n  .c-warning { color:orange }\n  .c-log { color:darkgray }\n  .c-info { color:gray }\n  ul { margin: 0; padding-left: 20px; display: inline-block; }\n</style>\n`;\n\nexport const addDebugHtml = (html: string) => {\n  debugHtmls.push(html);\n};\n\nexport const getDebugHtmlAtts = (testId: string, mockApiLogs: string[]): string[] => {\n  if (debugHtmls.length && mockApiLogs.length) {\n    debugHtmls.push(`<h1>Google Mock API logs</h1><pre>${mockApiLogs.join('\\n')}</pre>`);\n  }\n  const debugAtts: string[] = [];\n  let currentDebugAtt = '';\n  for (const debugHtml of debugHtmls) {\n    currentDebugAtt += debugHtml;\n    if (currentDebugAtt.length > MAX_ATT_SIZE) {\n      debugAtts.push(currentDebugAtt);\n      currentDebugAtt = '';\n    }\n  }\n  if (currentDebugAtt.length) {\n    debugAtts.push(currentDebugAtt);\n  }\n  const formattedDebugAtts: string[] = [];\n  for (let i = 0; i < debugAtts.length; i++) {\n    formattedDebugAtts[i] = `${debugHtmlStyle}<h1>${testId} ${i + 1}/${debugAtts.length}</h1><hr><br>${debugAtts[i]}`;\n  }\n  return formattedDebugAtts;\n};\n\nexport const standaloneTestTimeout = (t: AvaContext, ms: number, name: string) => setTimeout(() => { t.fail(`Standalone timeout exceeded (${name})`); }, ms);\n\nexport const newWithTimeoutsFunc = (consts: Consts): <T>(actionPromise: Promise<T>) => Promise<T> => { // returns a function\n  const timeoutAllRetries = new Promise((_, reject) => setTimeout(() => reject(new Error(`TIMEOUT_ALL_RETRIES`)), consts.TIMEOUT_ALL_RETRIES)) as Promise<never>;\n  return <T>(actionPromise: Promise<T>) => Promise.race([\n    actionPromise, // the actual action being performed\n    timeoutAllRetries, // timeout for all test retries\n    consts.PROMISE_TIMEOUT_OVERALL, // overall timeout for the whole test process / sequence\n  ]);\n};\n\nexport const newTimeoutPromise = (name: string, seconds = 20): Promise<never> => {\n  return new Promise((resolve, reject) => setTimeout(() => reject(new Error(`Timeout: ${name}`)), seconds * 1000));\n};\n\nexport const minutes = (count: number) => count * 60 * 1000;\n",
    "tooling/release.js": "\n// @ts-check\n\n// todo - could one day be switched to .ts and compiled with the rest of tooling\n\nconst { readFileSync } = require('fs');\nconst originalExec = require('child_process').exec;\n\nconst version = JSON.parse(readFileSync('./package.json').toString()).version;\n\nconst CHROME_CONSUMER = 'chrome-consumer';\nconst CHROME_ENTERPRISE = 'chrome-enterprise';\n\nconst releaseZip = (buildType) => `../release/${buildType}/flowcrypt-${buildType}-${version.replace(/\\./g, '-')}.zip`;\n\nconst exec = (shell_command) => new Promise((resolve, reject) => {\n  let subprocess = originalExec(shell_command, (err) => err === null ? resolve() : reject(err));\n  subprocess.stdout.pipe(process.stdout);\n  subprocess.stderr.pipe(process.stderr);\n});\n\n(async () => {\n  await exec(`cd ./build; rm -f ${releaseZip(CHROME_CONSUMER)}; zip -rq ${releaseZip(CHROME_CONSUMER)} ./${CHROME_CONSUMER}/*`);\n  await exec(`cd ./build; rm -f ${releaseZip(CHROME_ENTERPRISE)}; zip -rq ${releaseZip(CHROME_ENTERPRISE)} ./${CHROME_ENTERPRISE}/*`);\n  for (const i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].reverse()) {\n    console.log(`running firefox release in ${i} seconds...`);\n    await new Promise(resolve => setTimeout(resolve, 1000));\n  }\n  await exec('../flowcrypt-script/browser/firefox_release');\n})().catch(e => {\n  console.error(e);\n  process.exit(1);\n});\n",
    "extension/chrome/dev/export.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { GmailParser, GmailRes } from '../../js/common/api/email-provider/gmail/gmail-parser.js';\n\nimport { ApiErr } from '../../js/common/api/shared/api-error.js';\nimport { Assert } from '../../js/common/assert.js';\nimport { Attachment } from '../../js/common/core/attachment.js';\nimport { Browser } from '../../js/common/browser/browser.js';\nimport { Buf } from '../../js/common/core/buf.js';\nimport { Catch } from '../../js/common/platform/catch.js';\nimport { Gmail } from '../../js/common/api/email-provider/gmail/gmail.js';\nimport { Ui } from '../../js/common/browser/ui.js';\nimport { Url } from '../../js/common/core/common.js';\nimport { opgp } from '../../js/common/core/crypto/pgp/openpgpjs-custom.js';\n\nCatch.try(async () => {\n\n  const uncheckedUrlParams = Url.parse(['acctEmail']);\n  const acctEmail = Assert.urlParamRequire.string(uncheckedUrlParams, 'acctEmail');\n  const gmail = new Gmail(acctEmail);\n\n  if (!confirm('This is page is meant for debugging. It will download messages from your inbox and save them to your device. Continue?')) {\n    window.close();\n    return;\n  }\n\n  const print = (line: string) => $('pre').text($('pre').text() + '\\n' + line);\n\n  const censor = (value: string) => {\n    value = value.replace(/[a-z0-9.\\-_]+@[a-z0-9.\\-_]+\\.[a-z0-9.\\-_]+/g, foundEmail => {\n      if (foundEmail !== acctEmail && !foundEmail.includes('@flowcrypt.com')) {\n        return 'censored@email.com';\n      }\n      return foundEmail;\n    });\n    value = value.replace(/[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+/g, '1.1.1.1');\n    return value;\n  };\n\n  const save = (data: Uint8Array) => {\n    Browser.saveToDownloads(new Attachment({ data, name: `${acctEmail.replace(/[^a-z0-9+]/g, '')}.json`, type: 'application/pgp-encrypted' }));\n  };\n\n  try {\n    print('starting');\n    const msgMetas: GmailRes.GmailMsgList$message[] = [];\n    let nextCyclePageToken: string | undefined;\n    while (true) {\n      const { messages, resultSizeEstimate, nextPageToken } = await gmail.msgList('is:inbox OR is:sent', false, nextCyclePageToken);\n      print(`msgList: ${(messages || []).length} msgs, resultSizeEstimate:${resultSizeEstimate}, nextPageToken: ${nextPageToken}`);\n      msgMetas.push(...(messages || []));\n      if (!messages || !messages.length || !nextPageToken) {\n        break;\n      }\n      nextCyclePageToken = nextPageToken;\n    }\n    print(`found in inbox: ${(msgMetas || []).length} msgs`);\n    const fullMsgIdsList = (msgMetas || []).map(m => m.id);\n    print(`downloading full..`);\n    const msgsFull = await gmail.msgsGet(fullMsgIdsList, 'full');\n    print(`downloading full done. waiting 5 seconds..`);\n    await Ui.time.sleep(5000);\n    print(`waiting done. Downloading raw..`);\n    const msgsRaw = await gmail.msgsGet(fullMsgIdsList, 'raw');\n    print(`downloading raw done. Joining results..`);\n    for (const msg of msgsFull) {\n      for (const msgRaw of msgsRaw) {\n        if (msgRaw.id === msg.id) {\n          if (msgRaw.raw!.length < 1024 * 1024 * 7) {\n            msg.raw = msgRaw.raw!;\n          } else {\n            print(`skipping message ${msg.id} raw because too big: ${msgRaw.raw!.length}`);\n          }\n          break;\n        }\n      }\n    }\n    const messages: GmailRes.GmailMsg[] = [...msgsFull];\n    print(`joining done. Downloading labels..`);\n    const { labels } = await gmail.labelsGet();\n    print('labels done. waiting 5s..');\n    await Ui.time.sleep(5000);\n    print('waiting done. Downloading attachments..');\n    const fetchableAttachments: Attachment[] = [];\n    const skippedAttachments: Attachment[] = [];\n    for (const msg of messages) {\n      for (const attachment of GmailParser.findAttachments(msg)) {\n        if (attachment.length > 1024 * 1024 * 7) { // over 7 mb - attachment too big\n          skippedAttachments.push(new Attachment({ data: Buf.fromUtfStr(`MOCK: ATTACHMENT STRIPPED - ORIGINAL SIZE ${attachment.length}`), id: attachment.id, msgId: msg.id }));\n        } else {\n          fetchableAttachments.push(attachment);\n        }\n      }\n    }\n    await gmail.fetchAttachments(fetchableAttachments, percent => print(`Percent attachments done: ${percent}`));\n    const attachments: { [id: string]: { data: string, size: number } } = {};\n    for (const attachment of fetchableAttachments.concat(skippedAttachments)) {\n      attachments[attachment.id!] = { data: attachment.getData().toBase64UrlStr(), size: attachment.getData().length };\n    }\n    print(`done. found ${messages.length} messages, ${fetchableAttachments.length} downloaded and ${skippedAttachments.length} skipped attachments, ${labels.length} labels`);\n    print('censoring..');\n    for (const msg of messages) {\n      for (const h of msg.payload!.headers!) {\n        h.value = censor(h.value);\n      }\n    }\n    const data = Buf.fromUtfStr(JSON.stringify({ messages, attachments, labels }));\n    print(`export size: ${data.length / (1024 * 1024)} MB`);\n    const pwd = prompt('Please enter encryption password');\n    if (pwd) {\n      print('encrypting..');\n      const encrypted = await opgp.encrypt({ armor: false, message: opgp.message.fromBinary(data), passwords: [pwd] });\n      save(encrypted.message.packets.write());\n    } else {\n      save(data);\n    }\n  } catch (e) {\n    print(ApiErr.eli5(e));\n    print(String(e));\n    if (e instanceof Error) {\n      print(e.stack || 'no stack');\n    }\n  }\n\n})();\n",
    "extension/chrome/elements/add_pubkey.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { KeyImportUi, UserAlert, } from '../../js/common/ui/key-import-ui.js';\n\nimport { Assert } from '../../js/common/assert.js';\nimport { AttachmentUI } from '../../js/common/ui/attachment-ui.js';\nimport { Browser } from '../../js/common/browser/browser.js';\nimport { BrowserMsg } from '../../js/common/browser/browser-msg.js';\nimport { Catch } from '../../js/common/platform/catch.js';\nimport { FetchKeyUI } from '../../js/common/ui/fetch-key-ui.js';\nimport { Ui } from '../../js/common/browser/ui.js';\nimport { Url } from '../../js/common/core/common.js';\nimport { View } from '../../js/common/view.js';\nimport { Xss } from '../../js/common/platform/xss.js';\nimport { ContactStore } from '../../js/common/platform/store/contact-store.js';\nimport { KeyUtil } from '../../js/common/core/crypto/key.js';\n\nView.run(class AddPubkeyView extends View {\n  private readonly acctEmail: string;\n  private readonly parentTabId: string;\n  private readonly missingPubkeyEmails: string[];\n  private readonly fetchKeyUi = new FetchKeyUI();\n  private readonly attachmentUI = new AttachmentUI(() => Promise.resolve({ size_mb: 5, size: 5 * 1024 * 1024, count: 1 }));\n\n  constructor() {\n    super();\n    const uncheckedUrlParams = Url.parse(['acctEmail', 'parentTabId', 'emails']);\n    this.acctEmail = Assert.urlParamRequire.string(uncheckedUrlParams, 'acctEmail');\n    this.parentTabId = Assert.urlParamRequire.string(uncheckedUrlParams, 'parentTabId');\n    this.missingPubkeyEmails = Assert.urlParamRequire.string(uncheckedUrlParams, 'emails').split(',');\n  }\n\n  public render = async () => {\n    Ui.event.protect();\n    for (const missingPubkeyEmail of this.missingPubkeyEmails) {\n      Xss.sanitizeAppend('select.email', `<option value=\"${Xss.escape(missingPubkeyEmail)}\">${Xss.escape(missingPubkeyEmail)}</option>`);\n    }\n    for (const contact of await ContactStore.search(undefined, { hasPgp: true })) {\n      Xss.sanitizeAppend('select.copy_from_email', `<option value=\"${Xss.escape(contact.email)}\">${Xss.escape(contact.email)}</option>`);\n    }\n    this.fetchKeyUi.handleOnPaste($('.pubkey'));\n    $('.action_settings').click(this.setHandler(async () => await Browser.openSettingsPage('index.htm', this.acctEmail, '/chrome/settings/modules/contacts.htm')));\n  }\n\n  public setHandlers = () => {\n    this.attachmentUI.initAttachmentDialog('fineuploader', 'fineuploader_button', {\n      attachmentAdded: async (file) => {\n        this.attachmentUI.clearAllAttachments();\n        const { keys, errs } = await KeyUtil.readMany(file.getData());\n        if (keys.length) {\n          if (errs.length) {\n            await Ui.modal.warning(`some keys could not be processed due to errors:\\n${errs.map(e => `-> ${e.message}\\n`).join('')}`);\n          }\n          $('.pubkey').val(String(KeyUtil.armor(keys[0])));\n          $('.action_ok').trigger('click');\n        } else if (errs.length) {\n          await Ui.modal.error(`error processing public keys:\\n${errs.map(e => `-> ${e.message}\\n`).join('')}`);\n        }\n      }\n    });\n    $('select.copy_from_email').change(this.setHandler((el) => this.copyFromEmailHandler(el)));\n    $('.action_ok').click(this.setHandler(() => this.submitHandler()));\n    $('.action_close').click(this.setHandler(() => this.closeDialog()));\n  }\n\n  private closeDialog = () => {\n    BrowserMsg.send.closeDialog(this.parentTabId);\n  }\n\n  private copyFromEmailHandler = async (fromSelect: HTMLElement) => {\n    if ($(fromSelect).val()) {\n      const [contact] = await ContactStore.get(undefined, [String($(fromSelect).val())]);\n      if (contact?.pubkey) {\n        $('.pubkey').val(KeyUtil.armor(contact.pubkey)).prop('disabled', true);\n      } else {\n        Catch.report('Contact unexpectedly not found when copying pubkey by email in add_pubkey.htm');\n        await Ui.modal.error('Contact not found.');\n      }\n    } else {\n      $('.pubkey').val('').prop('disabled', false);\n    }\n  }\n\n  private submitHandler = async () => {\n    try {\n      const keyImportUi = new KeyImportUi({ checkEncryption: true });\n      const normalized = await keyImportUi.checkPub(String($('.pubkey').val()));\n      await ContactStore.save(undefined, await ContactStore.obj({ email: String($('select.email').val()), pubkey: normalized }));\n      this.closeDialog();\n    } catch (e) {\n      if (e instanceof UserAlert) {\n        await Ui.modal.warning(e.message);\n      } else {\n        Catch.reportErr(e);\n        await Ui.modal.error(`Error happened when processing the public key: ${e instanceof Error ? e.message : String(e)}`);\n      }\n    }\n  }\n});\n",
    "extension/chrome/elements/attachment.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Bm, BrowserMsg } from '../../js/common/browser/browser-msg.js';\nimport { DecryptErrTypes, MsgUtil } from '../../js/common/core/crypto/pgp/msg-util.js';\nimport { PromiseCancellation, Url } from '../../js/common/core/common.js';\nimport { Api } from '../../js/common/api/shared/api.js';\nimport { ApiErr } from '../../js/common/api/shared/api-error.js';\nimport { Assert } from '../../js/common/assert.js';\nimport { Attachment } from '../../js/common/core/attachment.js';\nimport { Browser } from '../../js/common/browser/browser.js';\nimport { Catch } from '../../js/common/platform/catch.js';\nimport { Gmail } from '../../js/common/api/email-provider/gmail/gmail.js';\nimport { Ui } from '../../js/common/browser/ui.js';\nimport { View } from '../../js/common/view.js';\nimport { Xss } from '../../js/common/platform/xss.js';\nimport { KeyStore } from '../../js/common/platform/store/key-store.js';\nimport { PassphraseStore } from '../../js/common/platform/store/passphrase-store.js';\nimport { XssSafeFactory } from '../../js/common/xss-safe-factory.js';\n\nexport class AttachmentDownloadView extends View {\n  protected readonly acctEmail: string;\n  protected readonly parentTabId: string;\n  protected readonly frameId: string;\n  protected readonly origNameBasedOnFilename: string;\n  protected readonly isEncrypted: boolean;\n  protected readonly errorDetailsOpened: boolean;\n  protected readonly type: string | undefined;\n  protected readonly msgId: string | undefined;\n  protected readonly id: string | undefined;\n  protected readonly name: string | undefined;\n  protected readonly url: string | undefined;\n  protected readonly gmail: Gmail;\n  protected attachment!: Attachment;\n  protected ppChangedPromiseCancellation: PromiseCancellation = { cancel: false };\n\n  private size: number | undefined;\n  private downloadButton = $('#download');\n  private header = $('#header');\n  private originalButtonHTML: string | undefined;\n  private canClickOnAttachment: boolean = false;\n  private downloadInProgress = false;\n  private tabId!: string;\n\n  constructor() {\n    super();\n    const uncheckedUrlParams = Url.parse([\n      'acctEmail', 'msgId', 'attachmentId', 'name', 'type', 'size', 'url', 'parentTabId', 'content', 'decrypted', 'frameId', 'isEncrypted', 'errorDetailsOpened'\n    ]);\n    this.acctEmail = Assert.urlParamRequire.string(uncheckedUrlParams, 'acctEmail');\n    this.parentTabId = Assert.urlParamRequire.string(uncheckedUrlParams, 'parentTabId');\n    this.frameId = Assert.urlParamRequire.string(uncheckedUrlParams, 'frameId');\n    this.origNameBasedOnFilename = uncheckedUrlParams.name ? String(uncheckedUrlParams.name).replace(/\\.(pgp|gpg)$/ig, '') : 'noname';\n    this.isEncrypted = uncheckedUrlParams.isEncrypted === true;\n    this.errorDetailsOpened = uncheckedUrlParams.errorDetailsOpened === true;\n    this.size = uncheckedUrlParams.size ? parseInt(String(uncheckedUrlParams.size)) : undefined;\n    this.type = Assert.urlParamRequire.optionalString(uncheckedUrlParams, 'type');\n    this.msgId = Assert.urlParamRequire.optionalString(uncheckedUrlParams, 'msgId');\n    this.id = Assert.urlParamRequire.optionalString(uncheckedUrlParams, 'attachmentId');\n    this.name = Assert.urlParamRequire.optionalString(uncheckedUrlParams, 'name');\n    // url contains either actual url of remote content or objectUrl for direct content, either way needs to be downloaded\n    this.url = Assert.urlParamRequire.optionalString(uncheckedUrlParams, 'url');\n    this.gmail = new Gmail(this.acctEmail);\n  }\n\n  public render = async () => {\n    this.tabId = await BrowserMsg.requiredTabId();\n    try {\n      this.attachment = new Attachment({ name: this.origNameBasedOnFilename, type: this.type, msgId: this.msgId, id: this.id, url: this.url });\n    } catch (e) {\n      Catch.reportErr(e);\n      $('body.attachment').text(`Error processing params: ${String(e)}. Contact human@flowcrypt.com`);\n      return;\n    }\n    $('#type').text(this.type || 'unknown type');\n    $('#name').text(this.name || 'noname');\n    this.renderHeader();\n    $('#name').attr('title', this.name || '');\n    $('img#file-format').attr('src', this.getFileIconSrc());\n    if (!this.size && this.url) { // download url of a file that has an unknown size\n      this.getUrlFileSize(this.url!).then(fileSize => {\n        if (typeof fileSize !== 'undefined') {\n          this.size = fileSize;\n        }\n      }).catch(ApiErr.reportIfSignificant);\n    }\n    try {\n      this.canClickOnAttachment = ! await this.processAsPublicKeyAndHideAttachmentIfAppropriate();\n    } catch (e) {\n      this.renderErr(e);\n    }\n    Ui.setTestState('ready');\n  }\n\n  public setHandlers = () => {\n    Ui.event.protect();\n    if (this.canClickOnAttachment) {\n      this.downloadButton.click(this.setHandlerPrevent('double', () => this.downloadButtonClickedHandler()));\n      this.downloadButton.click((e) => e.stopPropagation());\n      $('body').click(async () => {\n        if ($('body').attr('id') !== 'attachment-preview' && !$('body').hasClass('error-occured')) {\n          await this.previewAttachmentClickedHandler();\n        }\n      });\n    }\n    BrowserMsg.addListener('passphrase_entry', async ({ entered }: Bm.PassphraseEntry) => {\n      if (!entered) {\n        this.downloadInProgress = false;\n        this.downloadButton.show();\n        this.ppChangedPromiseCancellation.cancel = true; // update original object which is monitored by a promise\n        this.ppChangedPromiseCancellation = { cancel: false }; // set to a new, not yet used object\n        BrowserMsg.send.closeSwal(this.parentTabId); // attachment preview\n      }\n    });\n    BrowserMsg.listen(this.tabId);\n  }\n\n  protected downloadDataIfNeeded = async () => {\n    if (this.attachment.hasData()) {\n      return;\n    }\n    if (this.attachment.url) { // when content was downloaded and decrypted\n      this.attachment.setData(await Api.download(this.attachment.url, this.renderProgress));\n    } else if (this.attachment.id && this.attachment.msgId) { // gmail attId\n      const { data } = await this.gmail.attachmentGet(this.attachment.msgId, this.attachment.id, this.renderProgress);\n      this.attachment.setData(data);\n    } else {\n      throw new Error('File is missing both id and url - this should be fixed');\n    }\n  }\n\n  protected renderErr = (e: any) => {\n    if (ApiErr.isAuthErr(e)) {\n      BrowserMsg.send.notificationShowAuthPopupNeeded(this.parentTabId, { acctEmail: this.acctEmail });\n      Xss.sanitizeRender('body', `Error downloading file - google auth needed. ${Ui.retryLink()}`);\n    } else if (ApiErr.isNetErr(e)) {\n      Xss.sanitizeRender('body', `Error downloading file - no internet. ${Ui.retryLink()}`);\n    } else if (ApiErr.isDecryptErr(e)) {\n      Xss.sanitizeRender('body', `\n        Failed to decrypt.\n        <details ${this.errorDetailsOpened ? 'open' : ''}>\n          <summary>see error details</summary>\n          <pre data-test=\"error-details\">${e.stack}\\n\\nDecryptError:\\n${JSON.stringify(e.decryptError, undefined, 2)}</pre>\n        </details>\n      `);\n    } else {\n      Catch.reportErr(e);\n      Xss.sanitizeRender('body', `Error downloading file - ${String(e)}. ${Ui.retryLink()}`);\n    }\n    $('body').addClass('error-occured').attr('title', '');\n  }\n\n  private renderHeader = () => {\n    const span = $(`<span>${this.isEncrypted ? 'ENCRYPTED\\n' : 'PLAIN\\n'} FILE</span>`);\n    this.header.empty().append(span); // xss-escaped\n  }\n\n  private getFileIconSrc = () => {\n    const icon = (name: string) => `/img/fileformat/${name}.png`;\n    const nameSplit = this.origNameBasedOnFilename.split('.');\n    const extension = nameSplit[nameSplit.length - 1].toLowerCase();\n    if (['jpg', 'jpeg'].includes(extension)) {\n      return icon('jpg');\n    } else if (['xls', 'xlsx'].includes(extension)) {\n      return icon('excel');\n    } else if (['doc', 'docx'].includes(extension)) {\n      return icon('word');\n    } else if (extension === 'png') {\n      return icon('png');\n    } else {\n      return icon('generic');\n    }\n  }\n\n  private getUrlFileSize = async (url: string): Promise<number | undefined> => {\n    console.info('trying to figure out figetUrlFileSizee size');\n    if (url.indexOf('docs.googleusercontent.getUrlFileSizeom/docs/securesc') !== -1) {\n      try {\n        const googleDriveFileId = url.split('/').pop()!.split('?').shift(); // try and catch any errors below if structure is not as expected\n        url = googleDriveFileId ? `https://drive.google.com/uc?export=download&id=${googleDriveFileId}` : url; // attempt to get length headers from Google Drive file if available\n      } catch (e) {\n        // leave url as is\n      }\n    }\n    return await new Promise(resolve => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('HEAD', url, true);\n      xhr.onreadystatechange = function () {\n        if (this.readyState === this.DONE) {\n          const contentLength = xhr.getResponseHeader('Content-Length');\n          if (contentLength !== null) {\n            resolve(parseInt(contentLength));\n          } else {\n            console.info('was not able to find out file size');\n            resolve(undefined);\n          }\n        }\n      };\n      xhr.send();\n    });\n  }\n\n  private processAsPublicKeyAndHideAttachmentIfAppropriate = async () => {\n    if (this.attachment.msgId && this.attachment.id && this.attachment.treatAs() === 'publicKey') { // this is encrypted public key - download && decrypt & parse & render\n      const { data } = await this.gmail.attachmentGet(this.attachment.msgId, this.attachment.id);\n      const decrRes = await MsgUtil.decryptMessage({ kisWithPp: await KeyStore.getAllWithOptionalPassPhrase(this.acctEmail), encryptedData: data });\n      if (decrRes.success && decrRes.content) {\n        const openpgpType = await MsgUtil.type({ data: decrRes.content });\n        if (openpgpType && openpgpType.type === 'publicKey' && openpgpType.armored) { // 'openpgpType.armored': could potentially process unarmored pubkey files, maybe later\n          BrowserMsg.send.renderPublicKeys(this.parentTabId, { afterFrameId: this.frameId, traverseUp: 2, publicKeys: [decrRes.content.toUtfStr()] }); // render pubkey\n          BrowserMsg.send.setCss(this.parentTabId, { selector: `#${this.frameId}`, traverseUp: 1, css: { display: 'none' } }); // hide attachment\n          $('body').text('');\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private downloadButtonClickedHandler = async () => {\n    if (this.downloadInProgress) {\n      return;\n    }\n    this.downloadInProgress = true;\n    this.downloadButton.hide();\n    try {\n      this.originalButtonHTML = this.downloadButton.html();\n      Xss.sanitizeRender(this.header, `${Ui.spinner('green', 'large_spinner')}<span class=\"download_progress\"></span>`);\n      await this.recoverMissingAttachmentIdIfNeeded();\n      await this.downloadDataIfNeeded();\n      if (!this.isEncrypted) {\n        Browser.saveToDownloads(this.attachment);\n      } else {\n        await this.decryptAndSaveAttachmentToDownloads();\n      }\n      this.renderHeader();\n    } catch (e) {\n      this.renderErr(e);\n    } finally {\n      this.downloadInProgress = false;\n      this.downloadButton.show();\n    }\n  }\n\n  private previewAttachmentClickedHandler = async (errorDetailsOpened = false) => {\n    if (!this.attachment.length) {\n      this.attachment.length = this.size!;\n    }\n    const factory = new XssSafeFactory(this.acctEmail, this.parentTabId);\n    const iframeUrl = factory.srcPgpAttachmentIframe(this.attachment, this.isEncrypted, undefined, 'chrome/elements/attachment_preview.htm', errorDetailsOpened);\n    BrowserMsg.send.showAttachmentPreview(this.parentTabId, { iframeUrl });\n  }\n\n  private decryptAndSaveAttachmentToDownloads = async () => {\n    const result = await MsgUtil.decryptMessage({ kisWithPp: await KeyStore.getAllWithOptionalPassPhrase(this.acctEmail), encryptedData: this.attachment.getData() });\n    Xss.sanitizeRender(this.downloadButton, this.originalButtonHTML || '');\n    if (result.success) {\n      if (!result.filename || ['msg.txt', 'null'].includes(result.filename)) {\n        result.filename = this.attachment.name;\n      }\n      Browser.saveToDownloads(new Attachment({ name: result.filename, type: this.attachment.type, data: result.content }));\n    } else if (result.error.type === DecryptErrTypes.needPassphrase) {\n      BrowserMsg.send.passphraseDialog(this.parentTabId, { type: 'attachment', longids: result.longids.needPassphrase });\n      if (! await PassphraseStore.waitUntilPassphraseChanged(this.acctEmail, result.longids.needPassphrase, 1000, this.ppChangedPromiseCancellation)) {\n        return;\n      }\n      await this.decryptAndSaveAttachmentToDownloads();\n    } else {\n      $('body.attachment')\n        .html(`<div>Failed to decrypt:</div><a href=\"#\" data-test=\"decrypt-error-details\" class=\"see-error-details\">see error details</a><br><div>Downloading original…`) // xss-escaped\n        .addClass('error-occured')\n        .attr('title', '');\n      $('.see-error-details').click(async () => {\n        await this.previewAttachmentClickedHandler(true);\n      });\n      const name = this.attachment.name;\n      Browser.saveToDownloads(new Attachment({ name, type: this.type, data: this.attachment.getData() })); // won't work in ff, possibly neither on some chrome versions (on webmail)\n    }\n  }\n\n  private renderProgress = (percent: number, received: number, fileSize: number) => {\n    this.size = fileSize || this.size;\n    const progressEl = $('.download_progress');\n    if (!percent && this.size) {\n      percent = Math.floor(((received * 0.75) / this.size) * 100);\n    }\n    if (percent) {\n      progressEl.text(`${Math.min(100, percent)}%`);\n    }\n  }\n\n  private recoverMissingAttachmentIdIfNeeded = async () => {\n    if (!this.attachment.url && !this.attachment.id && this.attachment.msgId) {\n      const result = await this.gmail.msgGet(this.attachment.msgId, 'full');\n      if (result && result.payload && result.payload.parts) {\n        for (const attMeta of result.payload.parts) {\n          if (attMeta.filename === name && attMeta.body && attMeta.body.size === this.size && attMeta.body.attachmentId) {\n            this.attachment.id = attMeta.body.attachmentId;\n            return;\n          }\n        }\n      } else {\n        throw new Error('Could not recover missing attachmentId');\n      }\n    }\n  }\n\n}\n\nView.run(AttachmentDownloadView);\n",
    "extension/chrome/elements/attachment_preview.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Attachment } from '../../js/common/core/attachment.js';\nimport { AttachmentDownloadView } from './attachment.js';\nimport { AttachmentPreviewPdf } from '../../js/common/ui/attachment_preview_pdf.js';\nimport { Browser } from '../../js/common/browser/browser.js';\nimport { BrowserMsg } from '../../js/common/browser/browser-msg.js';\nimport { KeyStore } from '../../js/common/platform/store/key-store.js';\nimport { PDFDocumentProxy } from '../../types/pdf.js';\nimport { MsgUtil, DecryptError, DecryptErrTypes, DecryptSuccess, DecryptionError } from '../../js/common/core/crypto/pgp/msg-util.js';\nimport { PassphraseStore } from '../../js/common/platform/store/passphrase-store.js';\nimport { View } from '../../js/common/view.js';\nimport { Xss } from '../../js/common/platform/xss.js';\nimport { Ui } from '../../js/common/browser/ui.js';\n\ntype AttachmentType = 'img' | 'txt' | 'pdf';\n\ndeclare const pdfjsLib: any; // tslint:disable-line:ban-types\n\nView.run(class AttachmentPreviewView extends AttachmentDownloadView {\n  private attachmentPreviewContainer = $('#attachment-preview-container');\n\n  constructor() {\n    super();\n  }\n\n  public render = async () => {\n    try {\n      Xss.sanitizeRender(this.attachmentPreviewContainer, `${Ui.spinner('green', 'large_spinner')}<span class=\"download_progress\"></span>`);\n      this.attachment = new Attachment({ name: this.origNameBasedOnFilename, type: this.type, msgId: this.msgId, id: this.id, url: this.url });\n      await this.downloadDataIfNeeded();\n      const result = this.isEncrypted ? await this.decrypt() : this.attachment.getData();\n      if (result) {\n        const blob = new Blob([result], { type: this.type });\n        const url = window.URL.createObjectURL(blob);\n        const attachmentType = this.getAttachmentType(this.origNameBasedOnFilename);\n        const attachmentForSave = new Attachment({ name: this.origNameBasedOnFilename, type: this.type, data: result });\n        if (attachmentType) {\n          if (attachmentType === 'img') { // image\n            this.attachmentPreviewContainer.html(`<img src=\"${url}\" class=\"attachment-preview-img\" alt=\"${Xss.escape(this.origNameBasedOnFilename)}\">`); // xss-escaped\n          } else if (attachmentType === 'txt') { // text\n            this.attachmentPreviewContainer.html(`<div class=\"attachment-preview-txt\">${Xss.escape(result.toString()).replace(/\\n/g, '<br>')}</div>`); // xss-escaped\n          } else if (attachmentType === 'pdf') { // PDF\n            pdfjsLib.getDocument({ data: result }).promise.then(async (pdf: PDFDocumentProxy) => { // tslint:disable-line:no-unsafe-any\n              const previewPdf = new AttachmentPreviewPdf(this.attachmentPreviewContainer, pdf);\n              await previewPdf.render();\n            });\n          }\n        } else { // no preview available, download button\n          this.attachmentPreviewContainer.html('<div class=\"attachment-preview-unavailable\"></div>'); // xss-escaped\n          $('.attachment-preview-unavailable').prepend('No preview available'); // xss-escaped\n          $('#attachment-preview-download').appendTo('.attachment-preview-unavailable');\n        }\n        $('body').click((e) => {\n          if (e.target === document.body || $('body').children().toArray().indexOf(e.target) !== -1) {\n            BrowserMsg.send.closeSwal(this.parentTabId);\n          }\n        });\n        $('#attachment-preview-download').css('display', 'flex').click((e) => {\n          e.stopPropagation();\n          Browser.saveToDownloads(attachmentForSave);\n        });\n      }\n    } catch (e) {\n      this.renderErr(e);\n    }\n  }\n\n  private getAttachmentType = (filename: string): AttachmentType | undefined => {\n    const nameSplit = filename.split('.');\n    const extension = nameSplit[nameSplit.length - 1].toLowerCase();\n    if (['jpg', 'jpeg', 'png', 'gif'].includes(extension)) {\n      return 'img';\n    } else if (extension === 'txt') {\n      return 'txt';\n    } else if (extension === 'pdf') {\n      return 'pdf';\n    }\n    return undefined;\n  }\n\n  private decrypt = async () => {\n    const result = await MsgUtil.decryptMessage({ kisWithPp: await KeyStore.getAllWithOptionalPassPhrase(this.acctEmail), encryptedData: this.attachment.getData() });\n    if ((result as DecryptSuccess).content) {\n      return result.content;\n    } else if ((result as DecryptError).error.type === DecryptErrTypes.needPassphrase) {\n      BrowserMsg.send.passphraseDialog(this.parentTabId, { type: 'attachment', longids: (result as DecryptError).longids.needPassphrase });\n      if (! await PassphraseStore.waitUntilPassphraseChanged(this.acctEmail, (result as DecryptError).longids.needPassphrase, 1000, this.ppChangedPromiseCancellation)) {\n        return;\n      }\n      return await this.render();\n    }\n    throw new DecryptionError(result as DecryptError);\n  }\n});\n",
    "extension/chrome/elements/backup.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Assert } from '../../js/common/assert.js';\nimport { Browser } from '../../js/common/browser/browser.js';\nimport { BrowserMsg } from '../../js/common/browser/browser-msg.js';\nimport { KeyInfo, KeyUtil } from '../../js/common/core/crypto/key.js';\nimport { Ui } from '../../js/common/browser/ui.js';\nimport { Url, Str } from '../../js/common/core/common.js';\nimport { View } from '../../js/common/view.js';\nimport { initPassphraseToggle } from '../../js/common/ui/passphrase-ui.js';\nimport { KeyStore } from '../../js/common/platform/store/key-store.js';\n\nView.run(class BackupView extends View {\n\n  private readonly acctEmail: string;\n  private readonly parentTabId: string;\n  private readonly frameId: string;\n  private readonly armoredPrvBackup: string;\n  private storedPrvWithMatchingLongid: KeyInfo | undefined;\n\n  constructor() {\n    super();\n    const uncheckedUrlParams = Url.parse(['acctEmail', 'armoredPrvBackup', 'parentTabId', 'frameId']);\n    this.acctEmail = Assert.urlParamRequire.string(uncheckedUrlParams, 'acctEmail');\n    this.parentTabId = Assert.urlParamRequire.string(uncheckedUrlParams, 'parentTabId');\n    this.frameId = Assert.urlParamRequire.string(uncheckedUrlParams, 'frameId');\n    this.armoredPrvBackup = Assert.urlParamRequire.string(uncheckedUrlParams, 'armoredPrvBackup');\n  }\n\n  public render = async () => {\n    Ui.event.protect();\n    await initPassphraseToggle(['pass_phrase']);\n    const prvBackup = await KeyUtil.parse(this.armoredPrvBackup);\n    const fingerprint = prvBackup.id;\n    if (!fingerprint) {\n      throw new Error('Missing backup key fingerprint');\n    }\n    if (prvBackup) {\n      $('.line.fingerprints .fingerprint').text(Str.spaced(fingerprint));\n      if (prvBackup.usableForEncryption && prvBackup.usableForSigning) {\n        $('.line.add_contact').addClass('bad').text('This private key looks correctly formatted, but cannot be used for encryption.');\n        $('.line.fingerprints').css({ display: 'none', visibility: 'hidden' });\n      }\n    } else {\n      $('.line.fingerprints').css({ display: 'none' });\n    }\n    [this.storedPrvWithMatchingLongid] = await KeyStore.get(this.acctEmail, [fingerprint]);\n    if (this.storedPrvWithMatchingLongid) {\n      $('.line .private_key_status').text('This Private Key is already imported.');\n    } else {\n      $('.line .private_key_status')\n        .text('This private key was not imported yet. We suggest to import all backups so that you can read all incoming encrypted emails.')\n        .after('<div class=\"line\"><button class=\"button green\" id=\"action_import_key\">Import Missing Private Key</button></div>');\n    }\n    this.sendResizeMsg();\n  }\n\n  public setHandlers = () => {\n    if (!this.storedPrvWithMatchingLongid) {\n      $(\"#action_import_key\").click(this.setHandler(async () => await Browser.openSettingsPage('index.htm', this.acctEmail, '/chrome/settings/modules/add_key.htm')));\n    }\n    $('.action_test_pass').click(this.setHandler(async () => this.testPassphraseHandler()));\n    $('#pass_phrase').keydown(this.setEnterHandlerThatClicks('.action_test_pass'));\n  }\n\n  private sendResizeMsg = () => {\n    const desiredHeight = $('#backup_block').height()!;\n    BrowserMsg.send.setCss(this.parentTabId, { selector: `iframe#${this.frameId}`, css: { height: `${desiredHeight}px` } });\n  }\n\n  private testPassphraseHandler = async () => {\n    if (await KeyUtil.checkPassPhrase(this.armoredPrvBackup, String($('#pass_phrase').val())) === true) {\n      await Ui.modal.info('Success - your pass phrase matches this backup!');\n    } else {\n      await Ui.modal.warning('Pass phrase did not match. Please try again. If you forgot your pass phrase, please change it, so that you don\\'t get' +\n        ' locked out of your encrypted messages.');\n    }\n    $('#pass_phrase').val('');\n  }\n});\n",
    "extension/chrome/elements/compose-modules/compose-draft-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Mime, MimeContent, MimeProccesedMsg } from '../../../js/common/core/mime.js';\nimport { AjaxErr } from '../../../js/common/api/shared/api-error.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Buf } from '../../../js/common/core/buf.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { EncryptedMsgMailFormatter } from './formatters/encrypted-mail-msg-formatter.js';\nimport { Env } from '../../../js/common/browser/env.js';\nimport { GmailRes } from '../../../js/common/api/email-provider/gmail/gmail-parser.js';\nimport { MsgBlockParser } from '../../../js/common/core/msg-block-parser.js';\nimport { NewMsgData } from './compose-types.js';\nimport { MsgUtil } from '../../../js/common/core/crypto/pgp/msg-util.js';\nimport { storageLocalGet, storageLocalSet, storageLocalRemove } from '../../../js/common/browser/chrome.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Url } from '../../../js/common/core/common.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\nimport { KeyUtil } from '../../../js/common/core/crypto/key.js';\nimport { SendableMsg } from '../../../js/common/api/email-provider/sendable-msg.js';\n\nexport class ComposeDraftModule extends ViewModule<ComposeView> {\n\n  public wasMsgLoadedFromDraft = false;\n  public localNewMessageDraftId = 'local-draft-';\n\n  private currentlySavingDraft = false;\n  private saveDraftInterval?: number;\n  private lastDraftBody?: string;\n  private lastDraftSubject = '';\n  private SAVE_DRAFT_FREQUENCY = 3000;\n  private localDraftPrefix = 'local-draft-';\n\n  constructor(composer: ComposeView) {\n    super(composer);\n    if (!this.view.disableDraftSaving) {\n      this.saveDraftInterval = Catch.setHandledInterval(() => this.draftSave(), this.SAVE_DRAFT_FREQUENCY);\n    }\n  }\n\n  public setHandlers = () => {\n    $('.delete_draft').click(this.view.setHandler(() => this.deleteDraftClickHandler(), this.view.errModule.handle('delete draft')));\n    this.view.recipientsModule.onRecipientAdded(async () => await this.draftSave(true));\n  }\n\n  /**\n   * Returns true when a draft was loaded\n   */\n  public initialDraftLoad = async (draftId: string): Promise<boolean> => {\n    if (this.view.isReplyBox) {\n      Xss.sanitizeRender(this.view.S.cached('prompt'), `Loading draft.. ${Ui.spinner('green')}`);\n    }\n    try {\n      const draftGetRes = this.isLocalDraftId(draftId) ? await this.localDraftGet(draftId) : await this.view.emailProvider.draftGet(draftId, 'raw');\n      if (!draftGetRes) {\n        await this.abortAndRenderReplyMsgComposeTableIfIsReplyBox('!draftGetRes');\n        return false;\n      }\n      const decoded = await Mime.decode(Buf.fromBase64UrlStr(draftGetRes.message.raw!));\n      const processed = Mime.processDecoded(decoded);\n      await this.fillAndRenderDraftHeaders(decoded);\n      await this.decryptAndRenderDraft(processed);\n      return true;\n    } catch (e) {\n      if (ApiErr.isNetErr(e)) {\n        Xss.sanitizeRender('body', `Failed to load draft. ${Ui.retryLink()}`);\n      } else if (ApiErr.isAuthErr(e)) {\n        BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n        Xss.sanitizeRender('body', `Failed to load draft - FlowCrypt needs to be re-connected to Gmail. ${Ui.retryLink()}`);\n      } else if (this.view.isReplyBox && ApiErr.isNotFound(e)) {\n        console.info('about to reload reply_message automatically: get draft 404', this.view.acctEmail);\n        await Ui.time.sleep(500);\n        await this.view.storageModule.draftMetaDelete(this.view.threadId); // delete the legacy draft from storage if there is one, TODO: remove in #3329\n        console.info('Above red message means that there used to be a draft, but was since deleted. (not an error)');\n        this.view.draftId = '';\n        window.location.href = Url.create(Env.getUrlNoParams(), this.urlParams());\n      } else {\n        Catch.reportErr(e);\n        await this.abortAndRenderReplyMsgComposeTableIfIsReplyBox('exception');\n      }\n    }\n    return false;\n  }\n\n  public draftDelete = async () => {\n    clearInterval(this.saveDraftInterval);\n    await Ui.time.wait(() => !this.currentlySavingDraft ? true : undefined);\n    if (this.view.draftId) {\n      try {\n        this.isLocalDraftId(this.view.draftId) ? await storageLocalRemove([this.view.draftId]) : await this.view.emailProvider.draftDelete(this.view.draftId);\n        this.view.draftId = '';\n      } catch (e) {\n        if (ApiErr.isAuthErr(e)) {\n          BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n        } else if (ApiErr.isNotFound(e)) {\n          console.info(`draftDelete: ${e.message}`);\n        } else if (!ApiErr.isNetErr(e)) {\n          Catch.reportErr(e);\n        }\n      }\n    }\n  }\n\n  public draftSave = async (forceSave: boolean = false): Promise<void> => {\n    if (this.hasBodyChanged(this.view.inputModule.squire.getHTML()) || this.hasSubjectChanged(String(this.view.S.cached('input_subject').val())) || forceSave) {\n      this.currentlySavingDraft = true;\n      try {\n        const msgData = this.view.inputModule.extractAll();\n        const primaryKi = await this.view.storageModule.getKey(msgData.from);\n        const pubkeys = [{ isMine: true, email: msgData.from, pubkey: await KeyUtil.parse(primaryKi.public) }];\n        msgData.pwd = undefined; // not needed for drafts\n        const sendable = await new EncryptedMsgMailFormatter(this.view, true).sendableMsg(msgData, pubkeys);\n        if (this.view.replyParams?.inReplyTo) {\n          sendable.headers.References = this.view.replyParams.inReplyTo;\n          sendable.headers['In-Reply-To'] = this.view.replyParams.inReplyTo;\n        }\n        this.view.S.cached('send_btn_note').text('Saving');\n        this.draftSetPrefixIntoBody(sendable);\n        const mimeMsg = await sendable.toMime();\n        // If a draft was loaded from the local storage, once a user is back online, the local draft will be moved to the email provider\n        if (!this.view.draftId || this.isLocalDraftId(this.view.draftId)) {\n          const draftId = await this.doUploadDraftWithLocalStorageFallback(mimeMsg, msgData, async () => {\n            const { id } = await this.view.emailProvider.draftCreate(mimeMsg, this.view.threadId);\n            if (this.isLocalDraftId(this.view.draftId)) { // delete local draft if there is one\n              await storageLocalRemove([this.view.draftId]);\n            }\n            this.view.S.cached('send_btn_note').text('Saved');\n            return id;\n          });\n          this.view.draftId = draftId;\n          // recursing one more time, because we need the draftId we get from this reply in the message itself\n          // essentially everytime we save draft for the first time, we have to save it twice\n          // currentlySavingDraft will remain true for now\n          if (!this.isLocalDraftId(this.view.draftId)) {\n            await this.draftSave(true); // forceSave = true\n          }\n        } else {\n          await this.doUploadDraftWithLocalStorageFallback(mimeMsg, msgData, async () => {\n            await this.view.emailProvider.draftUpdate(this.view.draftId, mimeMsg, this.view.threadId);\n            this.view.S.cached('send_btn_note').text('Saved');\n            return this.view.draftId;\n          });\n        }\n      } catch (e) {\n        if (ApiErr.isAuthErr(e)) {\n          BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n          this.view.S.cached('send_btn_note').text('Not saved (reconnect)');\n        } else if (e instanceof Error && e.message.indexOf('Could not find valid key packet for encryption in key') !== -1) {\n          this.view.S.cached('send_btn_note').text('Not saved (bad key)');\n        } else if (this.view.draftId && (ApiErr.isNotFound(e) || (e instanceof AjaxErr && e.status === 400 && e.responseText.indexOf('Message not a draft') !== -1))) {\n          // not found - updating draft that was since deleted\n          // not a draft - updating draft that was since sent as a message (in another window), and is not a draft anymore\n          this.view.draftId = ''; // forget there was a draftId - next step will create a new draftId\n          await this.draftSave(true); // forceSave=true to not skip\n        } else if (!this.view.draftId && ApiErr.isNotFound(e)) {\n          // not found - creating draft on a thread that does not exist\n          this.view.threadId = ''; // forget there was a threadId\n          await this.draftSave(true); // forceSave=true to not skip\n        } else {\n          Catch.reportErr(e);\n          this.view.S.cached('send_btn_note').text('Not saved (error)');\n          Ui.toast(`Draft not saved: ${e}`, 5);\n        }\n      }\n      this.currentlySavingDraft = false;\n    }\n  }\n\n  private draftSetPrefixIntoBody = (sendable: SendableMsg) => {\n    let prefix: string;\n    if (this.view.threadId) { // reply draft\n      prefix = `[flowcrypt:link:draft_reply:${this.view.draftId}]\\n\\n`;\n    } else if (this.view.draftId) { // new message compose draft with known draftId\n      prefix = `[flowcrypt:link:draft_compose:${this.view.draftId}]\\n\\n`;\n    } else {\n      prefix = `(saving of this draft was interrupted - to decrypt it, send it to yourself)\\n\\n`;\n    }\n    if (sendable.body['encrypted/buf']) {\n      sendable.body['encrypted/buf'] = Buf.concat([Buf.fromUtfStr(prefix), sendable.body['encrypted/buf']]);\n    }\n    if (sendable.body['text/plain']) {\n      sendable.body['text/plain'] = `${prefix}${sendable.body['text/plain'] || ''}`;\n    }\n  }\n\n  private doUploadDraftWithLocalStorageFallback = async (mimeMsg: string, msgData: NewMsgData, callback: () => Promise<string>) => {\n    let draftId: string;\n    try {\n      draftId = await callback();\n    } catch (e) {\n      if (ApiErr.isNetErr(e)) {\n        draftId = await this.localDraftCreate(mimeMsg, this.view.threadId);\n        this.view.S.cached('send_btn_note').text('Draft saved locally (offline)');\n      } else {\n        throw e;\n      }\n    }\n    return draftId;\n  }\n\n  private isLocalDraftId = (draftId: string) => {\n    return !!draftId.match(this.localDraftPrefix);\n  }\n\n  private localDraftCreate = async (mimeMsg: string, threadId: string) => {\n    const draftId = `${this.localDraftPrefix}${threadId}`;\n    await storageLocalSet({ [draftId]: { message: { raw: Buf.fromUtfStr(mimeMsg).toBase64UrlStr(), threadId } } });\n    return draftId;\n  }\n\n  private localDraftGet = async (draftId: string) => {\n    const { [draftId]: localDraft } = await storageLocalGet([draftId]);\n    if (this.isValidLocalDraft(localDraft)) {\n      return localDraft;\n    }\n    return undefined;\n  }\n\n  private isValidLocalDraft = (localDraft: unknown): localDraft is GmailRes.GmailDraftGet => {\n    return !!localDraft && typeof (localDraft as GmailRes.GmailDraftGet).message === 'object';\n  }\n\n  private deleteDraftClickHandler = async () => {\n    await this.draftDelete();\n    if (this.view.isReplyBox && !this.view.removeAfterClose) { // reload iframe so we don't leave users without a reply UI\n      this.view.skipClickPrompt = false;\n      window.location.href = Url.create(Env.getUrlNoParams(), this.urlParams());\n    } else { // close new msg\n      this.view.renderModule.closeMsg();\n    }\n  }\n\n  private fillAndRenderDraftHeaders = async (decoded: MimeContent) => {\n    await this.view.recipientsModule.addRecipientsAndShowPreview({ to: decoded.to, cc: decoded.cc, bcc: decoded.bcc });\n    if (decoded.from) {\n      this.view.S.now('input_from').val(decoded.from);\n    }\n    if (decoded.subject) {\n      this.view.S.cached('input_subject').val(decoded.subject);\n    }\n  }\n\n  private decryptAndRenderDraft = async (encrypted: MimeProccesedMsg): Promise<void> => {\n    const rawBlock = encrypted.blocks.find(b => b.type === 'encryptedMsg' || b.type === 'signedMsg');\n    if (!rawBlock) {\n      return await this.abortAndRenderReplyMsgComposeTableIfIsReplyBox('!rawBlock');\n    }\n    const encryptedData = rawBlock.content instanceof Buf ? rawBlock.content : Buf.fromUtfStr(rawBlock.content);\n    const passphrase = await this.view.storageModule.passphraseGet();\n    if (typeof passphrase !== 'undefined') {\n      const decrypted = await MsgUtil.decryptMessage({ kisWithPp: await KeyStore.getAllWithOptionalPassPhrase(this.view.acctEmail), encryptedData });\n      if (!decrypted.success) {\n        return await this.abortAndRenderReplyMsgComposeTableIfIsReplyBox('!decrypted.success');\n      }\n      this.wasMsgLoadedFromDraft = true;\n      this.view.S.cached('prompt').css({ display: 'none' });\n      const { blocks, isRichText } = await MsgBlockParser.fmtDecryptedAsSanitizedHtmlBlocks(decrypted.content, 'IMG-KEEP');\n      const sanitizedContent = blocks.find(b => b.type === 'decryptedHtml')?.content;\n      if (!sanitizedContent) {\n        return await this.abortAndRenderReplyMsgComposeTableIfIsReplyBox('!sanitizedContent');\n      }\n      if (isRichText) {\n        this.view.sendBtnModule.popover.toggleItemTick($('.action-toggle-richtext-sending-option'), 'richtext', true);\n      }\n      this.view.inputModule.inputTextHtmlSetSafely(sanitizedContent.toString());\n      this.view.inputModule.squire.focus();\n    } else {\n      await this.renderPPDialogAndWaitWhenPPEntered();\n      await this.decryptAndRenderDraft(encrypted);\n    }\n  }\n\n  private hasBodyChanged = (msgBody: string) => {\n    if (this.lastDraftBody === undefined) { // first check\n      this.lastDraftBody = msgBody;\n      return false;\n    }\n    if (msgBody && msgBody !== this.lastDraftBody) {\n      this.lastDraftBody = msgBody;\n      return true;\n    }\n    return false;\n  }\n\n  private hasSubjectChanged = (subject: string) => {\n    if (this.view.isReplyBox) { // user cannot change reply subject\n      return false; // this helps prevent unwanted empty drafts\n    }\n    if (subject && subject !== this.lastDraftSubject) {\n      this.lastDraftSubject = subject;\n      return true;\n    }\n    return false;\n  }\n\n  private renderPPDialogAndWaitWhenPPEntered = async () => {\n    const promptText = `Waiting for <a href=\"#\" class=\"action_open_passphrase_dialog\">pass phrase</a> to open draft..`;\n    if (this.view.isReplyBox) {\n      Xss.sanitizeRender(this.view.S.cached('prompt'), promptText).css({ display: 'block' });\n      this.view.sizeModule.resizeComposeBox();\n    } else {\n      Xss.sanitizeRender(this.view.S.cached('prompt'), `${promptText}<br><br><a href=\"#\" class=\"action_close\">close</a>`).css({ display: 'block', height: '100%' });\n    }\n    this.view.S.cached('prompt').find('a.action_open_passphrase_dialog').click(this.view.setHandler(async () => {\n      const primaryKi = await KeyStore.getFirstRequired(this.view.acctEmail);\n      BrowserMsg.send.passphraseDialog(this.view.parentTabId, { type: 'draft', longids: [primaryKi.longid] });\n    }));\n    this.view.S.cached('prompt').find('a.action_close').click(this.view.setHandler(() => this.view.renderModule.closeMsg()));\n    await this.view.storageModule.whenMasterPassphraseEntered();\n  }\n\n  private abortAndRenderReplyMsgComposeTableIfIsReplyBox = async (reason: string) => {\n    console.info(`gmail.initialDraftLoad: ${reason}`);\n    if (this.view.isReplyBox) {\n      await this.view.renderModule.renderReplyMsgComposeTable();\n    }\n  }\n\n  private urlParams = () => { // used to reload the frame with updated params\n    return {\n      acctEmail: this.view.acctEmail, draftId: this.view.draftId, threadId: this.view.threadId, replyMsgId: this.view.replyMsgId,\n      ...this.view.replyParams, frameId: this.view.frameId, tabId: this.view.tabId, isReplyBox: this.view.isReplyBox,\n      skipClickPrompt: this.view.skipClickPrompt, parentTabId: this.view.parentTabId, disableDraftSaving: this.view.disableDraftSaving,\n      debug: this.view.debug, removeAfterClose: this.view.removeAfterClose, replyPubkeyMismatch: this.view.replyPubkeyMismatch,\n    };\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/compose-err-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Browser } from '../../../js/common/browser/browser.js';\nimport { BrowserEventErrHandler, Ui } from '../../../js/common/browser/ui.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { NewMsgData, SendBtnTexts } from './compose-types.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { BrowserExtension } from '../../../js/common/browser/browser-extension.js';\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { KeyInfo } from '../../../js/common/core/crypto/key.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport { Str } from '../../../js/common/core/common.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\nimport { AjaxErrMsgs } from '../../../js/common/api/shared/api-error.js';\n\nexport class ComposerUserError extends Error { }\nclass ComposerNotReadyError extends ComposerUserError { }\nexport class ComposerResetBtnTrigger extends Error { }\n\nexport const PUBKEY_LOOKUP_RESULT_FAIL: 'fail' = 'fail';\nexport const PUBKEY_LOOKUP_RESULT_WRONG: 'wrong' = 'wrong';\n\nexport class ComposeErrModule extends ViewModule<ComposeView> {\n\n  private debugId = Str.sloppyRandom();\n\n  public handle = (couldNotDoWhat: string): BrowserEventErrHandler => {\n    return {\n      network: async () => await Ui.modal.info(`Could not ${couldNotDoWhat} (network error). Please try again.`),\n      auth: async () => Settings.offerToLoginWithPopupShowModalOnErr(this.view.acctEmail, undefined, `Could not ${couldNotDoWhat}.\\n`),\n      other: async (e: any) => {\n        if (e instanceof Error) {\n          e.stack = (e.stack || '') + `\\n\\n[compose action: ${couldNotDoWhat}]`;\n        } else if (typeof e === 'object' && e && typeof (e as any).stack === 'undefined') {\n          try {\n            (e as any).stack = `[compose action: ${couldNotDoWhat}]`;\n          } catch (e) {\n            // no need\n          }\n        }\n        Catch.reportErr(e);\n        await Ui.modal.info(`Could not ${couldNotDoWhat} (unknown error). If this repeats, please contact human@flowcrypt.com.\\n\\n(${String(e)})`);\n      },\n    };\n  }\n\n  public debugFocusEvents = (...selNames: string[]) => {\n    for (const selName of selNames) {\n      this.view.S.cached(selName)\n        .focusin(e => this.debug(`** ${selName} receiving focus from(${e.relatedTarget ? e.relatedTarget.outerHTML : undefined})`))\n        .focusout(e => this.debug(`** ${selName} giving focus to(${e.relatedTarget ? e.relatedTarget.outerHTML : undefined})`));\n    }\n  }\n\n  public debug = (msg: string) => {\n    if (this.view.debug) {\n      console.log(`[${this.debugId}] ${msg}`);\n    }\n  }\n\n  public handleSendErr = async (e: any) => {\n    if (ApiErr.isNetErr(e)) {\n      let netErrMsg = 'Could not send message due to network error. Please check your internet connection and try again.\\n';\n      netErrMsg += '(This may also be caused by <a href=\"https://flowcrypt.com/docs/help/network-error.html\">missing extension permissions</a>).)';\n      await Ui.modal.error(netErrMsg);\n    } else if (ApiErr.isAuthErr(e)) {\n      BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n      Settings.offerToLoginWithPopupShowModalOnErr(this.view.acctEmail);\n    } else if (ApiErr.isReqTooLarge(e)) {\n      await Ui.modal.error(`Could not send: message or attachments too large.`);\n    } else if (ApiErr.isBadReq(e)) {\n      if (e.resMsg === AjaxErrMsgs.GOOGLE_INVALID_TO_HEADER || e.resMsg === AjaxErrMsgs.GOOGLE_RECIPIENT_ADDRESS_REQUIRED) {\n        await Ui.modal.error('Error from google: Invalid recipients\\n\\nPlease remove recipients, add them back and re-send the message.');\n      } else {\n        if (await Ui.modal.confirm(`Google returned an error when sending message. Please help us improve FlowCrypt by reporting the error to us.`)) {\n          const page = '/chrome/settings/modules/help.htm';\n          const pageUrlParams = { bugReport: BrowserExtension.prepareBugReport(`composer: send: bad request (errMsg: ${e.resMsg})`, {}, e) };\n          await Browser.openSettingsPage('index.htm', this.view.acctEmail, page, pageUrlParams);\n        }\n      }\n    } else if (e instanceof ComposerUserError) {\n      await Ui.modal.error(e.message, true);\n    } else {\n      if (!(e instanceof ComposerResetBtnTrigger || e instanceof ComposerNotReadyError)) {\n        Catch.reportErr(e);\n        await Ui.modal.error(`Failed to send message due to: ${String(e)}`);\n      }\n    }\n    if (!(e instanceof ComposerNotReadyError)) {\n      this.view.sendBtnModule.resetSendBtn(100);\n    }\n  }\n\n  public throwIfFormNotReady = (): void => {\n    if (this.view.S.cached('triple_dot').hasClass('progress')) {\n      throw new ComposerNotReadyError('Retrieving previous message, please wait.');\n    }\n    const btnReadyTexts = [\n      SendBtnTexts.BTN_ENCRYPT_AND_SEND,\n      SendBtnTexts.BTN_SIGN_AND_SEND,\n      SendBtnTexts.BTN_ENCRYPT_SIGN_AND_SEND,\n      SendBtnTexts.BTN_PLAIN_SEND\n    ];\n    const recipients = this.view.recipientsModule.getRecipients();\n    if (btnReadyTexts.includes(this.view.S.now('send_btn_text').text().trim()) && recipients.length) {\n      return; // all good\n    }\n    if (this.view.S.now('send_btn_text').text().trim() === SendBtnTexts.BTN_WRONG_ENTRY) {\n      throw new ComposerUserError('Please re-enter recipients marked in red color.');\n    }\n    if (!recipients.length) {\n      throw new ComposerUserError('Please add a recipient first');\n    }\n    throw new ComposerNotReadyError('Still working, please wait.');\n  }\n\n  public throwIfFormValsInvalid = async ({ subject, plaintext, from }: NewMsgData) => {\n    if (!subject && ! await Ui.modal.confirm('Send without a subject?')) {\n      throw new ComposerResetBtnTrigger();\n    }\n    let footer = await this.view.footerModule.getFooterFromStorage(from);\n    if (footer) { // format footer the way it would be in outgoing plaintext\n      footer = Xss.htmlUnescape(Xss.htmlSanitizeAndStripAllTags(this.view.footerModule.createFooterHtml(footer), '\\n')).trim();\n    }\n    if ((!plaintext.trim() || (footer && plaintext.trim() === footer.trim())) && ! await Ui.modal.confirm('Send empty message?')) {\n      throw new ComposerResetBtnTrigger();\n    }\n  }\n\n  public throwIfEncryptionPasswordInvalid = async (senderKi: KeyInfo, { subject, pwd }: { subject: string, pwd?: string }) => {\n    if (pwd) {\n      const pp = await this.view.storageModule.passphraseGet(senderKi);\n      if (pp && pwd.toLowerCase() === pp.toLowerCase()) {\n        throw new ComposerUserError('Please do not use your private key pass phrase as a password for this message.\\n\\n' +\n          'You should come up with some other unique password that you can share with recipient.');\n      }\n      if (subject.toLowerCase().includes(pwd.toLowerCase())) {\n        throw new ComposerUserError(`Please do not include the password in the email subject. ` +\n          `Sharing password over email undermines password based encryption.\\n\\n` +\n          `You can ask the recipient to also install FlowCrypt, messages between FlowCrypt users don't need a password.`);\n      }\n      const intro = this.view.S.cached('input_intro').length ? this.view.inputModule.extract('text', 'input_intro') : '';\n      if (intro.toLowerCase().includes(pwd.toLowerCase())) {\n        throw new ComposerUserError('Please do not include the password in the email intro. ' +\n          `Sharing password over email undermines password based encryption.\\n\\n` +\n          `You can ask the recipient to also install FlowCrypt, messages between FlowCrypt users don't need a password.`);\n      }\n    } else {\n      this.view.S.cached('input_password').focus();\n      throw new ComposerUserError('Some recipients don\\'t have encryption set up. Please add a password.');\n    }\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/compose-input-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { NewMsgData, RecipientElement } from './compose-types.js';\nimport { CursorEvent, SquireEditor, WillPasteEvent } from '../../../types/squire.js';\n\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { Recipients } from '../../../js/common/api/email-provider/email-provider-api.js';\nimport { Str } from '../../../js/common/core/common.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\n\nexport class ComposeInputModule extends ViewModule<ComposeView> {\n\n  public squire = new window.Squire(this.view.S.cached('input_text').get(0));\n\n  public setHandlers = () => {\n    this.view.S.cached('add_intro').click(this.view.setHandler(el => this.actionAddIntroHandler(el), this.view.errModule.handle(`add intro`)));\n    this.handlePaste();\n    this.handlePasteImages();\n    this.initShortcuts();\n    this.resizeReplyBox();\n    this.scrollIntoView();\n    this.handleRTL();\n    this.squire.setConfig({ addLinks: this.isRichText() });\n    if (this.view.debug) {\n      this.insertDebugElements();\n    }\n  }\n\n  public addRichTextFormatting = () => {\n    this.squire.setConfig({ addLinks: true });\n  }\n\n  public removeRichTextFormatting = () => {\n    this.squire.setHTML(Xss.htmlSanitizeAndStripAllTags(this.squire.getHTML(), '<br>'));\n    this.squire.setConfig({ addLinks: false });\n  }\n\n  public inputTextHtmlSetSafely = (html: string) => {\n    this.squire.setHTML(\n      Xss.htmlSanitize(Xss.htmlSanitizeKeepBasicTags(html, 'IMG-KEEP'))\n    );\n  }\n\n  public extract = (type: 'text' | 'html', elSel: 'input_text' | 'input_intro', flag?: 'SKIP-ADDONS') => {\n    let html = this.view.S.cached(elSel)[0].innerHTML;\n    if (elSel === 'input_text' && flag !== 'SKIP-ADDONS') {\n      html += this.view.quoteModule.getTripleDotSanitizedFormattedHtmlContent();\n    }\n    if (type === 'html') {\n      return Xss.htmlSanitizeKeepBasicTags(html, 'IMG-KEEP');\n    }\n    return Xss.htmlUnescape(Xss.htmlSanitizeAndStripAllTags(html, '\\n')).trim();\n  }\n\n  public extractAttachments = () => {\n    return this.view.S.cached('fineuploader').find('.qq-upload-file').toArray().map((el) => $(el).text().trim());\n  }\n\n  public extractAll = (): NewMsgData => {\n    const recipientElements = this.view.recipientsModule.getRecipients();\n    const recipients = this.mapRecipients(recipientElements);\n    const subject = this.view.isReplyBox && this.view.replyParams ? this.view.replyParams.subject : String($('#input_subject').val() || '');\n    const plaintext = this.view.inputModule.extract('text', 'input_text');\n    const plainhtml = this.view.inputModule.extract('html', 'input_text');\n    const password = this.view.S.cached('input_password').val();\n    const pwd = typeof password === 'string' && password ? password : undefined;\n    const from = this.view.senderModule.getSender();\n    return { recipients, subject, plaintext, plainhtml, pwd, from };\n  }\n\n  public isRichText = () => {\n    return this.view.sendBtnModule.popover.choices.richtext;\n  }\n\n  private handlePaste = () => {\n    this.squire.addEventListener('willPaste', (e: WillPasteEvent) => {\n      const div = document.createElement('div');\n      div.appendChild(e.fragment);\n      const html = div.innerHTML;\n      const sanitized = this.isRichText() ? Xss.htmlSanitizeKeepBasicTags(html, 'IMG-KEEP') : Xss.htmlSanitizeAndStripAllTags(html, '<br>');\n      Xss.setElementContentDANGEROUSLY(div, sanitized); // xss-sanitized\n      e.fragment.appendChild(div);\n    });\n  }\n\n  private handlePasteImages = () => {\n    this.squire.addEventListener('drop', (ev: DragEvent) => {\n      try {\n        if (!this.isRichText()) {\n          return;\n        }\n        if (!ev.dataTransfer?.files.length) {\n          return;\n        }\n        const file = ev.dataTransfer.files[0];\n        const reader = new FileReader();\n        reader.onload = () => {\n          try {\n            this.squire.insertImage(reader.result as ArrayBuffer, { name: file.name, title: file.name });\n            this.view.draftModule.draftSave().catch(Catch.reportErr);\n          } catch (e) {\n            Catch.reportErr(e);\n          }\n        };\n        reader.readAsDataURL(file);\n      } catch (e) {\n        Catch.reportErr(e);\n      }\n    });\n    this.squire.addEventListener('dragover', (e: DragEvent) => {\n      e.preventDefault(); // this is needed for 'drop' event to fire\n    });\n  }\n\n  private handleRTL = () => {\n    const checkRTL = () => {\n      let container = $(this.squire.getSelection().commonAncestorContainer);\n      if (container.prop('tagName') !== 'DIV') { // commonAncestorContainer might be a text node\n        container = container.closest('div');\n      }\n      const ltrCheck = new RegExp('^[' + Str.ltrChars + ']');\n      const rtlCheck = new RegExp('^[' + Str.rtlChars + ']');\n      if (ltrCheck.test(container.text()) && container.attr('dir') !== 'ltr') { // Switch to LTR\n        container.attr('dir', 'ltr');\n      } else if (rtlCheck.test(container.text()) && container.attr('dir') !== 'rtl') { // Switch to RTL\n        container.attr('dir', 'rtl');\n      } else {\n        // keep the previous direction for digits, punctuation marks, and other characters\n      }\n    };\n    this.squire.addEventListener('input', checkRTL);\n  }\n\n  private initShortcuts = () => {\n    try {\n      const isMac = /Mac OS X/.test(navigator.userAgent);\n      const ctrlKey = isMac ? 'meta-' : 'ctrl-';\n      const mapKeyToFormat = (tag: string) => {\n        return (self: SquireEditor, event: Event) => {\n          try {\n            event.preventDefault();\n            if (!this.isRichText()) {\n              return;\n            }\n            const range = self.getSelection();\n            if (self.hasFormat(tag)) {\n              self.changeFormat(null, { tag }, range); // tslint:disable-line:no-null-keyword\n            } else {\n              self.changeFormat({ tag }, null, range); // tslint:disable-line:no-null-keyword\n            }\n          } catch (e) {\n            Catch.reportErr(e);\n          }\n        };\n      };\n      const noop = (self: SquireEditor, event: Event) => {\n        event.preventDefault();\n      };\n      const removeFormatting = (self: SquireEditor) => {\n        self.removeAllFormatting();\n      };\n      this.squire.setKeyHandler(ctrlKey + 'b', mapKeyToFormat('B'));\n      this.squire.setKeyHandler(ctrlKey + 'u', mapKeyToFormat('U'));\n      this.squire.setKeyHandler(ctrlKey + 'i', mapKeyToFormat('I'));\n      this.squire.setKeyHandler(ctrlKey + '\\\\', removeFormatting);\n      this.squire.setKeyHandler(ctrlKey + 'shift-7', noop); // default is 'S'\n      this.squire.setKeyHandler(ctrlKey + 'shift-5', noop); // default is 'SUB', { tag: 'SUP' }\n      this.squire.setKeyHandler(ctrlKey + 'shift-6', noop); // default is 'SUP', { tag: 'SUB' }\n      this.squire.setKeyHandler(ctrlKey + 'shift-8', noop); // default is 'makeUnorderedList'\n      this.squire.setKeyHandler(ctrlKey + 'shift-9', noop); // default is 'makeOrderedList'\n      this.squire.setKeyHandler(ctrlKey + '[', noop); // default is 'decreaseQuoteLevel'\n      this.squire.setKeyHandler(ctrlKey + ']', noop); // default is 'increaseQuot\n    } catch (e) {\n      Catch.reportErr(e);\n    }\n  }\n\n  private resizeReplyBox = () => {\n    this.squire.addEventListener('cursor', (e: CursorEvent) => {\n      if (this.view.isReplyBox) {\n        const cursorContainer = e.range.commonAncestorContainer as HTMLElement;\n        this.view.sizeModule.resizeComposeBox(0, cursorContainer?.offsetTop);\n      }\n    });\n  }\n\n  // https://github.com/FlowCrypt/flowcrypt-browser/issues/2400\n  private scrollIntoView = () => {\n    this.squire.addEventListener('cursor', () => {\n      try {\n        const inputText = this.view.S.cached('input_text').get(0);\n        const offsetBottom = this.squire.getCursorPosition().bottom - inputText.getBoundingClientRect().top;\n        const editorRootHeight = this.view.S.cached('input_text').height() || 0;\n        if (offsetBottom > editorRootHeight) {\n          const scrollBy = offsetBottom - editorRootHeight;\n          inputText.scrollBy(0, Math.round(scrollBy));\n        }\n      } catch (e) {\n        Catch.reportErr(e);\n      }\n    });\n  }\n\n  private actionAddIntroHandler = (addIntroBtn: HTMLElement) => {\n    $(addIntroBtn).css('display', 'none');\n    this.view.S.cached('intro_container').css('display', 'table-row');\n    this.view.S.cached('input_intro').focus();\n    this.view.sizeModule.setInputTextHeightManuallyIfNeeded();\n  }\n\n  private mapRecipients = (recipients: RecipientElement[]) => {\n    const result: Recipients = { to: [], cc: [], bcc: [] };\n    for (const recipient of recipients) {\n      switch (recipient.sendingType) {\n        case \"to\":\n          result.to!.push(recipient.email);\n          break;\n        case \"cc\":\n          result.cc!.push(recipient.email);\n          break;\n        case \"bcc\":\n          result.bcc!.push(recipient.email);\n          break;\n      }\n    }\n    return result;\n  }\n\n  // We need this method to test images in drafts because we can't paste them dirctly in tests.\n  private insertDebugElements = () => {\n    this.view.S.cached('body').append('<input type=\"hidden\" id=\"test_insertImage\" data-test=\"action-insert-image\" />'); // xss-direct\n    $('#test_insertImage').on('click', this.view.setHandler(async (input) => {\n      this.squire.insertImage(String($(input).val()), {});\n      await this.view.draftModule.draftSave();\n    }));\n  }\n}\n",
    "extension/chrome/elements/compose-modules/compose-my-pubkey-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { KeyInfo, KeyUtil } from '../../../js/common/core/crypto/key.js';\nimport { Lang } from '../../../js/common/lang.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\nimport { Str } from '../../../js/common/core/common.js';\n\nexport class ComposeMyPubkeyModule extends ViewModule<ComposeView> {\n\n  private toggledManually = false;\n  private wkdFingerprints: { [acctEmail: string]: string[] } = {};\n\n  public setHandlers = () => {\n    this.view.S.cached('icon_pubkey').attr('title', Lang.compose.includePubkeyIconTitle);\n    this.view.S.cached('icon_pubkey').click(this.view.setHandler((el) => this.iconPubkeyClickHandler(el), this.view.errModule.handle(`set/unset pub attachment`)));\n  }\n\n  public iconPubkeyClickHandler = (target: HTMLElement) => {\n    this.toggledManually = true;\n    const includePub = !$(target).is('.active'); // evaluating what the state of the icon was BEFORE clicking\n    Ui.toast(`${includePub ? 'Attaching' : 'Removing'} your Public Key`);\n    this.setAttachPreference(includePub);\n  }\n\n  public shouldAttach = () => {\n    return this.view.S.cached('icon_pubkey').is('.active');\n  }\n\n  public chooseMyPublicKeyBySenderEmail = async (keys: KeyInfo[], email: string) => {\n    for (const key of keys) {\n      if (key.emails?.includes(email.toLowerCase())) {\n        return key;\n      }\n    }\n    return undefined;\n  }\n\n  public reevaluateShouldAttachOrNot = () => {\n    if (this.toggledManually) { // leave it as is if toggled manually before\n      return;\n    }\n    (async () => {\n      const senderEmail = this.view.senderModule.getSender();\n      const senderKi = await this.view.storageModule.getKey(senderEmail);\n      const primaryFingerprint = (await KeyUtil.parse(senderKi.private)).id;\n      // if we have cashed this fingerprint, setAttachPreference(false) rightaway and return\n      const cached = this.wkdFingerprints[senderEmail];\n      if (Array.isArray(cached) && cached.includes(primaryFingerprint)) {\n        this.setAttachPreference(false);\n        return;\n      }\n      const myDomain = Str.getDomainFromEmailAddress(senderEmail);\n      const foreignRecipients = this.view.recipientsModule.getRecipients().map(r => r.email)\n        .filter(Boolean)\n        .filter(email => myDomain !== Str.getDomainFromEmailAddress(email));\n      if (foreignRecipients.length > 0) {\n        if (!Array.isArray(cached)) {\n          // slow operation -- test WKD for our own key and cache the result\n          const { keys } = await this.view.pubLookup.wkd.rawLookupEmail(senderEmail);\n          const fingerprints = keys.map(key => key.id);\n          this.wkdFingerprints[senderEmail] = fingerprints;\n          if (fingerprints.includes(primaryFingerprint)) {\n            this.setAttachPreference(false);\n            return;\n          }\n        }\n        for (const recipient of foreignRecipients) {\n          // new message, and my key is not uploaded where the recipient would look for it\n          if (! await this.view.recipientsModule.doesRecipientHaveMyPubkey(recipient)) {\n            // they do need pubkey\n            this.setAttachPreference(true);\n            return;\n          }\n        }\n        this.setAttachPreference(false);\n      }\n    })().catch(ApiErr.reportIfSignificant);\n  }\n\n  private setAttachPreference = (includePubkey: boolean) => {\n    if (includePubkey) {\n      this.view.S.cached('icon_pubkey').addClass('active').attr('title', Lang.compose.includePubkeyIconTitleActive);\n    } else {\n      this.view.S.cached('icon_pubkey').removeClass('active').attr('title', Lang.compose.includePubkeyIconTitle);\n    }\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/compose-pwd-or-pubkey-container-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\n\nimport { RecipientStatus, SendBtnTexts } from './compose-types.js';\nimport { KeyImportUi } from '../../../js/common/ui/key-import-ui.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { Str } from '../../../js/common/core/common.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\nimport { AcctStore } from '../../../js/common/platform/store/acct-store.js';\n\nexport class ComposePwdOrPubkeyContainerModule extends ViewModule<ComposeView> {\n\n  private MSG_EXPIRE_DAYS_DEFAULT = 3; // todo - update to 7 (needs backend work)\n  private keyImportUI = new KeyImportUi({});\n  private rmPwdStrengthValidationElements: (() => void) | undefined;\n\n  constructor(view: ComposeView, hideMsgPwd: boolean | undefined) {\n    super(view);\n    if (hideMsgPwd) {\n      this.view.S.cached('input_password').attr('type', 'password');\n    }\n  }\n\n  public setHandlers = () => {\n    this.view.S.cached('input_password').keyup(this.view.setHandlerPrevent('spree', () => this.showHideContainerAndColorSendBtn()));\n    this.view.S.cached('input_password').focus(this.view.setHandlerPrevent('spree', () => this.inputPwdFocusHandler()));\n    this.view.S.cached('input_password').blur(this.view.setHandler(() => this.inputPwdBlurHandler()));\n    this.view.S.cached('expiration_note').find('#expiration_note_settings_link').click(this.view.setHandler(async (el, e) => {\n      e.preventDefault();\n      await this.view.renderModule.openSettingsWithDialog('security');\n    }, this.view.errModule.handle(`render settings dialog`)));\n  }\n\n  public inputPwdFocusHandler = () => {\n    const passwordContainerHeight = this.view.S.cached('password_or_pubkey').outerHeight() || 0;\n    const footerHeight = this.view.S.cached('footer').outerHeight() || 0;\n    this.view.S.cached('expiration_note').css({ bottom: (passwordContainerHeight + footerHeight) + 'px' });\n    this.view.S.cached('expiration_note').fadeIn();\n    this.showHideContainerAndColorSendBtn(); // tslint:disable-line:no-floating-promises\n  }\n\n  public inputPwdBlurHandler = () => {\n    Catch.setHandledTimeout(() => { // timeout here is needed so <a> will be visible once clicked\n      this.view.S.cached('expiration_note').fadeOut();\n    }, 100);\n    this.showHideContainerAndColorSendBtn(); // tslint:disable-line:no-floating-promises\n  }\n\n  public showHideContainerAndColorSendBtn = async () => {\n    this.view.sendBtnModule.resetSendBtn();\n    this.view.S.cached('send_btn_note').text('');\n    this.view.S.cached('send_btn').removeAttr('title');\n    const wasPreviouslyVisible = this.view.S.cached('password_or_pubkey').css('display') === 'table-row';\n    if (!this.view.recipientsModule.getRecipients().length || !this.view.sendBtnModule.popover.choices.encrypt) {\n      this.hideMsgPwdUi(); // Hide 'Add Pasword' prompt if there are no recipients or message is not encrypted\n      this.view.sendBtnModule.enableBtn();\n    } else if (this.view.recipientsModule.getRecipients().find(r => [RecipientStatus.NO_PGP, RecipientStatus.REVOKED].includes(r.status))) {\n      await this.showMsgPwdUiAndColorBtn(\n        this.view.recipientsModule.getRecipients().some(r => r.status === RecipientStatus.NO_PGP),\n        this.view.recipientsModule.getRecipients().some(r => r.status === RecipientStatus.REVOKED),\n      ).catch(Catch.reportErr);\n    } else if (this.view.recipientsModule.getRecipients().find(r => [RecipientStatus.FAILED, RecipientStatus.WRONG].includes(r.status))) {\n      this.view.S.now('send_btn_text').text(SendBtnTexts.BTN_WRONG_ENTRY);\n      this.view.S.cached('send_btn').attr('title', 'Notice the recipients marked in red: please remove them and try to enter them egain.');\n      this.view.sendBtnModule.disableBtn();\n    } else {\n      this.hideMsgPwdUi();\n      this.view.sendBtnModule.enableBtn();\n    }\n    if (this.view.isReplyBox) {\n      if (!wasPreviouslyVisible && this.view.S.cached('password_or_pubkey').css('display') === 'table-row') {\n        this.view.sizeModule.resizeComposeBox((this.view.S.cached('password_or_pubkey').first().height() || 66) + 20);\n      } else {\n        this.view.sizeModule.resizeComposeBox();\n      }\n    }\n    this.view.sizeModule.setInputTextHeightManuallyIfNeeded();\n  }\n\n  public isVisible = () => {\n    return !this.view.S.cached('password_or_pubkey').is(':hidden');\n  }\n\n  private showMsgPwdUiAndColorBtn = async (anyNopgp: boolean, anyRevoked: boolean) => {\n    if (!this.isVisible()) {\n      const authInfo = await AcctStore.authInfo(this.view.acctEmail);\n      const expirationTextEl = this.view.S.cached('expiration_note').find('#expiration_note_message_expire');\n      if (!authInfo) {\n        expirationTextEl.text(Str.pluralize(this.MSG_EXPIRE_DAYS_DEFAULT, 'day'));\n      } else {\n        try {\n          const response = await this.view.acctServer.accountGetAndUpdateLocalStore(authInfo);\n          expirationTextEl.text(Str.pluralize(response.account.default_message_expire, 'day'));\n        } catch (e) {\n          ApiErr.reportIfSignificant(e);\n          expirationTextEl.text(`(unknown days: ${ApiErr.eli5(e)})`);\n        }\n      }\n      this.view.S.cached('password_or_pubkey').css('display', 'table-row');\n    }\n    if (this.view.S.cached('input_password').val() || this.view.S.cached('input_password').is(':focus')) {\n      this.view.S.cached('password_label').css('display', 'inline-block');\n      this.view.S.cached('input_password').attr('placeholder', '');\n    } else {\n      this.view.S.cached('password_label').css('display', 'none');\n      this.view.S.cached('input_password').attr('placeholder', 'message password');\n    }\n    if (this.view.S.cached('input_intro').is(':visible')) {\n      this.view.S.cached('add_intro').css('display', 'none');\n    } else {\n      this.view.S.cached('add_intro').css('display', 'block');\n    }\n    this.view.S.cached('warning_nopgp').css('display', anyNopgp ? 'inline-block' : 'none');\n    this.view.S.cached('warning_revoked').css('display', anyRevoked ? 'inline-block' : 'none');\n    this.view.sizeModule.setInputTextHeightManuallyIfNeeded();\n    if (!this.rmPwdStrengthValidationElements) {\n      const { removeValidationElements } = this.keyImportUI.renderPassPhraseStrengthValidationInput($(\"#input_password\"), undefined, 'pwd');\n      this.rmPwdStrengthValidationElements = removeValidationElements;\n    }\n  }\n\n  private hideMsgPwdUi = () => {\n    this.view.S.cached('password_or_pubkey').css('display', 'none');\n    this.view.S.cached('input_password').val('');\n    this.view.S.cached('add_intro').css('display', 'none');\n    this.view.S.cached('input_intro').text('');\n    this.view.S.cached('intro_container').css('display', 'none');\n    if (this.rmPwdStrengthValidationElements) {\n      this.rmPwdStrengthValidationElements();\n      this.rmPwdStrengthValidationElements = undefined;\n    }\n    this.view.sizeModule.setInputTextHeightManuallyIfNeeded();\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/compose-quote-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Bm, BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { FormatError, MsgUtil, DecryptErrTypes } from '../../../js/common/core/crypto/pgp/msg-util.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Buf } from '../../../js/common/core/buf.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { Mime } from '../../../js/common/core/mime.js';\nimport { MsgBlock } from '../../../js/common/core/msg-block.js';\nimport { MsgBlockParser } from '../../../js/common/core/msg-block-parser.js';\nimport { Str } from '../../../js/common/core/common.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\nimport { MessageToReplyOrForward } from './compose-types.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\n\nexport class ComposeQuoteModule extends ViewModule<ComposeView> {\n\n  public tripleDotSanitizedHtmlContent: { quote: string | undefined, footer: string | undefined } | undefined;\n  public messageToReplyOrForward: MessageToReplyOrForward | undefined;\n\n  public getTripleDotSanitizedFormattedHtmlContent = (): string => { // email content order: [myMsg, myFooter, theirQuote]\n    if (this.tripleDotSanitizedHtmlContent) {\n      return '<br />' + (this.tripleDotSanitizedHtmlContent.footer || '') + (this.tripleDotSanitizedHtmlContent.quote || '');\n    }\n    return '';\n  }\n\n  public addTripleDotQuoteExpandFooterOnlyBtn = async () => {\n    const textFooter = await this.view.footerModule.getFooterFromStorage(this.view.senderModule.getSender());\n    if (!textFooter) {\n      this.view.S.cached('triple_dot').hide();\n      return;\n    }\n    const sanitizedFooter = textFooter && !this.view.draftModule.wasMsgLoadedFromDraft ? this.view.footerModule.createFooterHtml(textFooter) : undefined;\n    this.tripleDotSanitizedHtmlContent = { footer: sanitizedFooter, quote: undefined };\n    this.view.S.cached('triple_dot').click(this.view.setHandler(el => this.actionRenderTripleDotContentHandle(el)));\n  }\n\n  public addTripleDotQuoteExpandFooterAndQuoteBtn = async (msgId: string, method: 'reply' | 'forward') => {\n    if (!this.messageToReplyOrForward) {\n      this.view.S.cached('triple_dot').addClass('progress');\n      Xss.sanitizeAppend(this.view.S.cached('triple_dot'), '<div id=\"loader\">0%</div>');\n      this.view.sizeModule.resizeComposeBox();\n      try {\n        this.messageToReplyOrForward = await this.getAndDecryptMessage(msgId, method);\n      } catch (e) {\n        ApiErr.reportIfSignificant(e);\n        await Ui.modal.error(`Could not load quoted content, please try again.\\n\\n${ApiErr.eli5(e)}`);\n      }\n      this.view.S.cached('triple_dot').find('#loader').remove();\n      this.view.S.cached('triple_dot').removeClass('progress');\n    }\n    let sanitizedQuote = '';\n    if (this.messageToReplyOrForward?.text) {\n      const sentDate = new Date(String(this.messageToReplyOrForward.headers.date));\n      if (this.messageToReplyOrForward.headers.from && this.messageToReplyOrForward.headers.date) {\n        sanitizedQuote += `<br><br>${this.generateHtmlPreviousMsgQuote(this.messageToReplyOrForward.text, sentDate, this.messageToReplyOrForward.headers.from)}`;\n      }\n      if (method === 'forward' && this.messageToReplyOrForward.decryptedFiles.length) {\n        for (const file of this.messageToReplyOrForward.decryptedFiles) {\n          this.view.attachmentsModule.attachment.addFile(file);\n        }\n      }\n    }\n    const textFooter = await this.view.footerModule.getFooterFromStorage(this.view.senderModule.getSender());\n    const sanitizedFooter = textFooter && !this.view.draftModule.wasMsgLoadedFromDraft ? this.view.footerModule.createFooterHtml(textFooter) : undefined;\n    if (!sanitizedQuote && !sanitizedFooter) {\n      this.view.S.cached('triple_dot').hide();\n      return;\n    }\n    this.tripleDotSanitizedHtmlContent = { footer: sanitizedFooter, quote: sanitizedQuote };\n    if (method === 'forward') {\n      this.actionRenderTripleDotContentHandle(this.view.S.cached('triple_dot')[0]);\n    } else {\n      this.view.S.cached('triple_dot').click(this.view.setHandler(el => this.actionRenderTripleDotContentHandle(el)));\n    }\n  }\n\n  private getAndDecryptMessage = async (msgId: string, method: 'reply' | 'forward'): Promise<MessageToReplyOrForward | undefined> => {\n    try {\n      const { raw } = await this.view.emailProvider.msgGet(msgId, 'raw', (progress) => this.setQuoteLoaderProgress(progress));\n      this.setQuoteLoaderProgress('processing...');\n      const decoded = await Mime.decode(Buf.fromBase64UrlStr(raw!));\n      const headers = {\n        date: String(decoded.headers.date), from: decoded.from,\n        references: String(decoded.headers.references || ''),\n        'message-id': String(decoded.headers['message-id'] || ''),\n      };\n      const message = decoded.rawSignedContent ? await Mime.process(Buf.fromUtfStr(decoded.rawSignedContent)) : Mime.processDecoded(decoded);\n      const readableBlockTypes = ['encryptedMsg', 'plainText', 'plainHtml', 'signedMsg'];\n      const decryptedBlockTypes = ['decryptedHtml'];\n      if (method === 'forward') {\n        readableBlockTypes.push(...['encryptedAttachment', 'plainAttachment']);\n        decryptedBlockTypes.push('decryptedAttachment');\n      }\n      const readableBlocks: MsgBlock[] = [];\n      for (const block of message.blocks.filter(b => readableBlockTypes.includes(b.type))) {\n        if (['encryptedMsg', 'signedMsg'].includes(block.type)) {\n          this.setQuoteLoaderProgress('decrypting...');\n          const decrypted = await this.decryptMessage(Buf.fromUtfStr(block.content.toString()));\n          const msgBlocks = await MsgBlockParser.fmtDecryptedAsSanitizedHtmlBlocks(Buf.fromUtfStr(decrypted));\n          readableBlocks.push(...msgBlocks.blocks.filter(b => decryptedBlockTypes.includes(b.type)));\n        } else {\n          readableBlocks.push(block);\n        }\n      }\n      const decryptedAndFormatedContent: string[] = [];\n      const decryptedFiles: File[] = [];\n      for (const block of readableBlocks) {\n        const stringContent = block.content.toString();\n        if (block.type === 'decryptedHtml') {\n          const htmlParsed = Xss.htmlSanitizeAndStripAllTags(block ? block.content.toString() : 'No Content', '\\n');\n          decryptedAndFormatedContent.push(Xss.htmlUnescape(htmlParsed));\n        } else if (block.type === 'plainHtml') {\n          decryptedAndFormatedContent.push(Xss.htmlUnescape(Xss.htmlSanitizeAndStripAllTags(stringContent, '\\n')));\n        } else if (['encryptedAttachment', 'decryptedAttachment', 'plainAttachment'].includes(block.type)) {\n          if (block.attachmentMeta?.data) {\n            let attachmentMeta: { content: Buf, filename?: string } | undefined;\n            if (block.type === 'encryptedAttachment') {\n              this.setQuoteLoaderProgress('decrypting...');\n              const result = await MsgUtil.decryptMessage({ kisWithPp: await KeyStore.getAllWithOptionalPassPhrase(this.view.acctEmail), encryptedData: block.attachmentMeta.data });\n              if (result.success) {\n                attachmentMeta = { content: result.content, filename: result.filename };\n              }\n            } else {\n              attachmentMeta = { content: Buf.fromUint8(block.attachmentMeta.data), filename: block.attachmentMeta.name };\n            }\n            if (attachmentMeta) {\n              const file = new File([attachmentMeta.content], attachmentMeta.filename || '');\n              decryptedFiles.push(file);\n            }\n          }\n        } else {\n          decryptedAndFormatedContent.push(stringContent);\n        }\n      }\n      return {\n        headers,\n        text: decryptedAndFormatedContent.join('\\n').trim(),\n        isOnlySigned: !!(decoded.rawSignedContent || (message.blocks.length > 0 && message.blocks[0].type === 'signedMsg')),\n        decryptedFiles\n      };\n    } catch (e) {\n      if (e instanceof FormatError) {\n        Xss.sanitizeAppend(this.view.S.cached('input_text'), `<br/>\\n<br/>\\n<br/>\\n${Xss.escape(e.data)}`);\n      } else if (ApiErr.isNetErr(e)) {\n        // todo: retry\n      } else if (ApiErr.isAuthErr(e)) {\n        BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n      } else {\n        Catch.reportErr(e);\n      }\n      return;\n    }\n  }\n\n  private decryptMessage = async (encryptedData: Buf): Promise<string> => {\n    const decryptRes = await MsgUtil.decryptMessage({ kisWithPp: await KeyStore.getAllWithOptionalPassPhrase(this.view.acctEmail), encryptedData });\n    if (decryptRes.success) {\n      return decryptRes.content.toUtfStr();\n    } else if (decryptRes.error && decryptRes.error.type === DecryptErrTypes.needPassphrase) {\n      BrowserMsg.send.passphraseDialog(this.view.parentTabId, { type: 'quote', longids: decryptRes.longids.needPassphrase });\n      const wasPpEntered: boolean = await new Promise(resolve => {\n        BrowserMsg.addListener('passphrase_entry', async (response: Bm.PassphraseEntry) => resolve(response.entered));\n        BrowserMsg.listen(this.view.parentTabId);\n      });\n      if (wasPpEntered) {\n        return await this.decryptMessage(encryptedData); // retry with pp\n      }\n      return `\\n(Skipping previous message quote)\\n`;\n    } else {\n      return `\\n(Failed to decrypt quote from previous message because: ${decryptRes.error.type}: ${decryptRes.error.message})\\n`;\n    }\n  }\n\n  private quoteText = (text: string) => {\n    return text.split('\\n').map(l => '<br>&gt; ' + l).join('\\n');\n  }\n\n  private generateHtmlPreviousMsgQuote = (text: string, date: Date, from: string) => {\n    let onDateUserWrote = `On ${Str.fromDate(date).replace(' ', ' at ')}, ${from} wrote:`;\n    const rtl = text.match(new RegExp('[' + Str.rtlChars + ']'));\n    if (rtl) {\n      onDateUserWrote = `<div dir=\"ltr\">${onDateUserWrote}</div>`;\n    }\n    const sanitizedQuote = Xss.htmlSanitize(onDateUserWrote + this.quoteText(Xss.escape(text)));\n    return `<blockquote${rtl ? ' dir=\"rtl\"' : ''}>${sanitizedQuote}</blockquote>`;\n  }\n\n  private actionRenderTripleDotContentHandle = (el: HTMLElement) => {\n    $(el).remove();\n    Xss.sanitizeAppend(this.view.S.cached('input_text'), this.getTripleDotSanitizedFormattedHtmlContent());\n    this.tripleDotSanitizedHtmlContent = undefined;\n    this.view.sizeModule.resizeComposeBox();\n  }\n\n  private setQuoteLoaderProgress = (percentOrString: string | number | undefined): void => {\n    if (percentOrString) {\n      this.view.S.cached('triple_dot').find('#loader').text(typeof percentOrString === 'number' ? `${percentOrString}%` : percentOrString);\n    }\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/compose-recipients-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { ChunkedCb, EmailProviderContact, RecipientType } from '../../../js/common/api/shared/api.js';\nimport { Contact } from '../../../js/common/core/crypto/key.js';\nimport { PUBKEY_LOOKUP_RESULT_FAIL, PUBKEY_LOOKUP_RESULT_WRONG } from './compose-err-module.js';\nimport { ProviderContactsQuery, Recipients } from '../../../js/common/api/email-provider/email-provider-api.js';\nimport { RecipientElement, RecipientStatus } from './compose-types.js';\nimport { Str } from '../../../js/common/core/common.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Bm, BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { Google } from '../../../js/common/api/email-provider/gmail/google.js';\nimport { GoogleAuth } from '../../../js/common/api/email-provider/gmail/google-auth.js';\nimport { Lang } from '../../../js/common/lang.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { moveElementInArray } from '../../../js/common/platform/util.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\nimport { AcctStore } from '../../../js/common/platform/store/acct-store.js';\nimport { ContactPreview, ContactStore, ContactUpdate } from '../../../js/common/platform/store/contact-store.js';\n\n/**\n * todo - this class is getting too big\n * split into ComposeRecipientsModule and ComposeContactSearchModule\n */\nexport class ComposeRecipientsModule extends ViewModule<ComposeView> {\n\n  private readonly failedLookupEmails: string[] = [];\n\n  private addedRecipients: RecipientElement[] = [];\n  private BTN_LOADING = 'Loading..';\n\n  private readonly MAX_CONTACTS_LENGTH = 8;\n\n  private contactSearchInProgress = false;\n  private addedPubkeyDbLookupInterval?: number;\n\n  private onRecipientAddedCallbacks: ((rec: RecipientElement[]) => void)[] = [];\n\n  private dragged: Element | undefined = undefined;\n\n  private canSearchContacts: boolean;\n  private canReadEmails: boolean;\n\n  constructor(view: ComposeView) {\n    super(view);\n    this.canSearchContacts = this.view.scopes.readContacts;\n    this.canReadEmails = this.view.scopes.read || this.view.scopes.modify;\n  }\n\n  public setHandlers = (): void => {\n    let preventSearchContacts = false;\n    const inputs = this.view.S.cached('recipients_inputs');\n    inputs.on('keyup', this.view.setHandlerPrevent('veryslowspree', async (target) => {\n      if (!preventSearchContacts) {\n        await this.searchContacts($(target));\n      }\n    }));\n    inputs.on('keydown', this.view.setHandler(async (target, e) => {\n      preventSearchContacts = this.recipientInputKeydownHandler(e);\n    }));\n    inputs.on('blur', this.view.setHandler((target, e) => this.inputsBlurHandler(target, e)));\n    inputs.on('dragenter', this.view.setHandler((target) => this.inputsDragEnterHandler(target)));\n    inputs.on('dragleave', this.view.setHandler((target) => this.inputsDragLeaveHandler(target)));\n    inputs.on('dragover', (e) => e.preventDefault());\n    inputs.on('drop', this.view.setHandler((target) => this.inputsDropHandler(target)));\n    this.view.S.now('cc').click(this.view.setHandler((target) => {\n      const newContainer = this.view.S.cached('input_addresses_container_outer').find(`#input-container-cc`);\n      this.copyCcBccActionsClickHandler(target, newContainer);\n    }));\n    this.view.S.now('bcc').click(this.view.setHandler((target) => {\n      const newContainer = this.view.S.cached('input_addresses_container_outer').find(`#input-container-bcc`);\n      this.copyCcBccActionsClickHandler(target, newContainer);\n    }));\n    this.view.S.cached('recipients_placeholder').click(this.view.setHandler(() => {\n      this.view.S.cached('input_to').focus();\n    }));\n    this.view.S.cached('input_to').focus(this.view.setHandler(() => this.focusRecipients()));\n    this.view.S.cached('cc').focus(this.view.setHandler(() => this.focusRecipients()));\n    this.view.S.cached('bcc').focus(this.view.setHandler(() => this.focusRecipients()));\n    this.view.S.cached('compose_table').click(this.view.setHandler(() => this.hideContacts(), this.view.errModule.handle(`hide contact box`)));\n    this.view.S.cached('add_their_pubkey').click(this.view.setHandler(() => this.addTheirPubkeyClickHandler(), this.view.errModule.handle('add pubkey')));\n    BrowserMsg.addListener('addToContacts', this.checkReciepientsKeys);\n    BrowserMsg.addListener('reRenderRecipient', async ({ contact }: Bm.ReRenderRecipient) => await this.reRenderRecipientFor(contact));\n    BrowserMsg.listen(this.view.parentTabId);\n  }\n\n  public getRecipients = () => {\n    return this.addedRecipients;\n  }\n\n  public validateEmails = (uncheckedEmails: string[]): { valid: string[], invalid: string[] } => {\n    const valid: string[] = [];\n    const invalid: string[] = [];\n    for (const email of uncheckedEmails) {\n      const parsed = Str.parseEmail(email).email;\n      if (parsed) {\n        valid.push(parsed);\n      } else {\n        invalid.push(email);\n      }\n    }\n    return { valid, invalid };\n  }\n\n  public parseRenderRecipients = async (inputs: JQuery<HTMLElement>, force?: boolean, uncheckedEmails?: string[]): Promise<void> => {\n    this.view.errModule.debug(`parseRenderRecipients(force: ${force})`);\n    for (const inputElem of inputs) {\n      const input = $(inputElem);\n      const sendingType = input.data('sending-type') as RecipientType;\n      this.view.errModule.debug(`parseRenderRecipients(force: ${force}) - sending type - ${sendingType}`);\n      uncheckedEmails = uncheckedEmails || String(input.val()).split(/,/g);\n      this.view.errModule.debug(`parseRenderRecipients(force: ${force}) - emails to check(${uncheckedEmails.join(',')})`);\n      const validationResult = this.validateEmails(uncheckedEmails);\n      let recipientsToEvaluate: RecipientElement[] = [];\n      const container = input.parent();\n      if (validationResult.valid.length) {\n        this.view.errModule.debug(`parseRenderRecipients(force: ${force}) - valid emails(${validationResult.valid.join(',')})`);\n        recipientsToEvaluate = this.createRecipientsElements(container, validationResult.valid, sendingType, RecipientStatus.EVALUATING);\n      }\n      const invalidEmails = validationResult.invalid.filter(em => !!em); // remove empty strings\n      this.view.errModule.debug(`parseRenderRecipients(force: ${force}) - invalid emails(${validationResult.invalid.join(',')})`);\n      if (force && invalidEmails.length) {\n        this.view.errModule.debug(`parseRenderRecipients(force: ${force}) - force add invalid recipients`);\n        recipientsToEvaluate = [...recipientsToEvaluate, ...this.createRecipientsElements(container, invalidEmails, sendingType, RecipientStatus.WRONG)];\n        input.val('');\n      } else {\n        this.view.errModule.debug(`parseRenderRecipients(force: ${force}) - setting inputTo with invalid emails`);\n        input.val(validationResult.invalid.join(','));\n      }\n      this.view.errModule.debug(`parseRenderRecipients(force: ${force}).2`);\n      this.view.sizeModule.resizeInput(input);\n      if (recipientsToEvaluate.length) {\n        await this.evaluateRecipients(recipientsToEvaluate);\n        this.view.errModule.debug(`parseRenderRecipients(force: ${force}).3`);\n        this.view.sizeModule.resizeInput(input);\n        this.view.errModule.debug(`parseRenderRecipients(force: ${force}).4`);\n      }\n    }\n  }\n\n  public addRecipients = async (recipients: Recipients, triggerCallback: boolean = true) => {\n    let newRecipients: RecipientElement[] = [];\n    for (const key in recipients) {\n      if (recipients.hasOwnProperty(key) && ['to', 'cc', 'bcc'].includes(key)) {\n        const sendingType = key as RecipientType;\n        if (recipients[sendingType] && recipients[sendingType]!.length) {\n          const recipientsContainer = this.view.S.cached('input_addresses_container_outer').find(`#input-container-${sendingType}`);\n          newRecipients = newRecipients.concat(this.createRecipientsElements(recipientsContainer, recipients[sendingType]!, sendingType, RecipientStatus.EVALUATING));\n          this.view.S.cached('input_addresses_container_outer').find(`#input-container-${sendingType}`).css('display', '');\n          this.view.sizeModule.resizeInput(this.view.S.cached('input_addresses_container_outer').find(`#input-container-${sendingType} input`));\n        }\n      }\n    }\n    await this.evaluateRecipients(newRecipients, triggerCallback);\n  }\n\n  public deleteRecipientsBySendingType = (types: ('to' | 'cc' | 'bcc')[]) => {\n    for (const recipient of this.addedRecipients.filter(r => types.includes(r.sendingType))) {\n      this.removeRecipient(recipient.element);\n    }\n  }\n\n  public hideContacts = () => {\n    this.view.S.cached('contacts').css('display', 'none');\n    this.view.S.cached('contacts').children().not('ul').remove();\n  }\n\n  public addRecipientsAndShowPreview = async (recipients: Recipients) => {\n    this.view.recipientsModule.addRecipients(recipients).catch(Catch.reportErr);\n    this.view.recipientsModule.showHideCcAndBccInputsIfNeeded();\n    await this.view.recipientsModule.setEmailsPreview(this.getRecipients());\n  }\n\n  public reEvaluateRecipients = async (recipients: RecipientElement[]) => {\n    for (const recipient of recipients) {\n      $(recipient.element).empty().removeClass();\n      Xss.sanitizeAppend(recipient.element, `${Xss.escape(recipient.email)} ${Ui.spinner('green')}`);\n    }\n    await this.evaluateRecipients(recipients);\n  }\n\n  public evaluateRecipients = async (recipients: RecipientElement[], triggerCallback: boolean = true) => {\n    this.view.errModule.debug(`evaluateRecipients`);\n    $('body').attr('data-test-state', 'working');\n    for (const recipient of recipients) {\n      this.view.errModule.debug(`evaluateRecipients.email(${String(recipient.email)})`);\n      this.view.S.now('send_btn_text').text(this.BTN_LOADING);\n      this.view.sizeModule.setInputTextHeightManuallyIfNeeded();\n      recipient.evaluating = (async () => {\n        let pubkeyLookupRes: Contact | 'fail' | 'wrong';\n        if (recipient.status !== RecipientStatus.WRONG) {\n          pubkeyLookupRes = await this.view.storageModule.lookupPubkeyFromDbOrKeyserverAndUpdateDbIfneeded(recipient.email, undefined);\n        } else {\n          pubkeyLookupRes = 'wrong';\n        }\n        await this.renderPubkeyResult(recipient, pubkeyLookupRes);\n        recipient.evaluating = undefined; // Clear promise when it finished\n      })();\n    }\n    await Promise.all(recipients.map(r => r.evaluating));\n    if (triggerCallback) {\n      for (const callback of this.onRecipientAddedCallbacks) {\n        callback(recipients);\n      }\n    }\n    $('body').attr('data-test-state', 'ready');\n    this.view.sizeModule.setInputTextHeightManuallyIfNeeded();\n  }\n\n  /**\n  * Generate content for emails preview in some container\n  * when recipient inputs are collapsed.\n  * e.g. 'test@test.com, test2@test.com [3 more]'\n  *\n  * @param container - HTMLElement where emails have to be inserted\n  * @param recipients - Recipients that should be previewed\n  */\n  public setEmailsPreview = async (recipients: RecipientElement[]): Promise<void> => {\n    const orderedRecipients = recipients.sort(this.orderRecipientsBySendingType);\n    if (orderedRecipients.length) {\n      this.view.S.cached('recipients_placeholder').find('.placeholder').css('display', 'none');\n    } else {\n      this.view.S.cached('recipients_placeholder').find('.placeholder').css('display', 'block');\n      this.view.S.cached('recipients_placeholder').find('.email_preview').empty();\n      return;\n    }\n    const container = this.view.S.cached('recipients_placeholder').find('.email_preview');\n    if (orderedRecipients.find(r => r.status === RecipientStatus.EVALUATING)) {\n      container.append(`<span id=\"r_loader\">Loading Reciepients ${Ui.spinner('green')}</span>`); // xss-direct\n      await Promise.all(orderedRecipients.filter(r => r.evaluating).map(r => r.evaluating!));\n      container.find('r_loader').remove();\n    }\n    Xss.sanitizeRender(container, '<span class=\"rest\"><span id=\"rest_number\"></span> more</span>');\n    const maxWidth = container.parent().width()!;\n    const rest = container.find('.rest');\n    let processed = 0;\n    while (container.width()! <= maxWidth && orderedRecipients.length >= processed + 1) {\n      const recipient = orderedRecipients[processed];\n      const escapedTitle = Xss.escape(recipient.element.getAttribute('title') || '');\n      const emailHtml = `<span class=\"email_address ${recipient.element.className}\" title=\"${escapedTitle}\">${Xss.escape(recipient.email)}</span>`;\n      $(emailHtml).insertBefore(rest); // xss-escaped\n      processed++;\n    }\n    if (container.width()! > maxWidth) {\n      container.find('.email_address').last().remove();\n      const restRecipients = orderedRecipients.slice(processed - 1);\n      rest.find('#rest_number').text(restRecipients.length);\n      const orderedByStatus = restRecipients.sort((a: RecipientElement, b: RecipientElement) => {\n        return a.status - b.status;\n      });\n      const last = orderedByStatus[orderedByStatus.length - 1]; // Last element has the worst status\n      rest.addClass(last.element.className);\n    } else {\n      rest.remove();\n    }\n  }\n\n  public showHideCcAndBccInputsIfNeeded = () => {\n    const isThere = { cc: false, bcc: false };\n    for (const recipient of this.addedRecipients) {\n      if (isThere.cc && isThere.bcc) {\n        break;\n      }\n      if (recipient.sendingType === 'cc') {\n        isThere.cc = true;\n      } else if (recipient.sendingType === 'bcc') {\n        isThere.bcc = true;\n      }\n    }\n    this.view.S.cached('input_addresses_container_outer').find(`#input-container-cc`).css('display', isThere.cc ? '' : 'none');\n    this.view.S.cached('cc').css('display', isThere.cc ? 'none' : '');\n    this.view.S.cached('input_addresses_container_outer').find(`#input-container-bcc`).css('display', isThere.bcc ? '' : 'none');\n    this.view.S.cached('bcc').css('display', isThere.bcc ? 'none' : '');\n    this.view.S.cached('input_addresses_container_outer').children(`:not([style=\"display: none;\"])`).last().append(this.view.S.cached('container_cc_bcc_buttons')); // xss-reinsert\n  }\n\n  public collapseInputsIfNeeded = async (relatedTarget?: HTMLElement | null) => { // TODO: fix issue when loading no-pgp email and user starts typing\n    if (!relatedTarget || (!this.view.S.cached('input_addresses_container_outer')[0].contains(relatedTarget)\n      && !this.view.S.cached('contacts')[0].contains(relatedTarget))) {\n      await Promise.all(this.addedRecipients.map(r => r.evaluating)); // Wait untill all recipients loaded.\n      if (this.view.S.cached('recipients_inputs').is(':focus')) { // We don't need to colapse it if some input is on focus again.\n        return;\n      }\n      this.showHideCcAndBccInputsIfNeeded();\n      this.view.S.cached('input_addresses_container_outer').addClass('invisible');\n      this.view.S.cached('recipients_placeholder').css('display', 'flex');\n      await this.setEmailsPreview(this.addedRecipients);\n      this.hideContacts();\n      this.view.sizeModule.setInputTextHeightManuallyIfNeeded();\n    }\n  }\n\n  public onRecipientAdded = (callback: (rec: RecipientElement[]) => void) => {\n    this.onRecipientAddedCallbacks.push(callback);\n  }\n\n  // todo: shouldn't we check longid?\n  public doesRecipientHaveMyPubkey = async (theirEmailUnchecked: string): Promise<boolean | undefined> => {\n    const theirEmail = Str.parseEmail(theirEmailUnchecked).email;\n    if (!theirEmail) {\n      return false;\n    }\n    const storage = await AcctStore.get(this.view.acctEmail, ['pubkey_sent_to']);\n    if (storage.pubkey_sent_to && storage.pubkey_sent_to.includes(theirEmail)) {\n      return true;\n    }\n    if (!this.canReadEmails) {\n      return undefined;\n    }\n    const qSentPubkey = `is:sent to:${theirEmail} \"BEGIN PGP PUBLIC KEY\" \"END PGP PUBLIC KEY\"`;\n    const qReceivedMsg = `from:${theirEmail} \"BEGIN PGP MESSAGE\" \"END PGP MESSAGE\"`;\n    try {\n      const response = await this.view.emailProvider.msgList(`(${qSentPubkey}) OR (${qReceivedMsg})`, true);\n      if (response.messages && response.messages.length > 0) {\n        await AcctStore.set(this.view.acctEmail, { pubkey_sent_to: (storage.pubkey_sent_to || []).concat(theirEmail) });\n        return true;\n      } else {\n        return false;\n      }\n    } catch (e) {\n      if (ApiErr.isAuthErr(e)) {\n        BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n      } else if (!ApiErr.isNetErr(e)) {\n        Catch.reportErr(e);\n      }\n      return undefined;\n    }\n  }\n\n  public reRenderRecipientFor = async (contact: Contact): Promise<void> => {\n    for (const recipient of this.addedRecipients.filter(r => r.email === contact.email)) {\n      this.view.errModule.debug(`re-rendering recipient: ${contact.email}`);\n      await this.renderPubkeyResult(recipient, contact);\n      this.view.recipientsModule.showHideCcAndBccInputsIfNeeded();\n      await this.view.recipientsModule.setEmailsPreview(this.getRecipients());\n    }\n  }\n\n  private inputsBlurHandler = async (target: HTMLElement, e: JQuery.Event<HTMLElement, null>) => {\n    if (this.dragged) { // blur while drag&drop\n      return;\n    }\n    if (e.relatedTarget === this.view.S.cached('contacts').get(0)) { // user selected contact in #contacts list, do nothing here\n      return;\n    }\n    this.view.errModule.debug(`input_to.blur -> parseRenderRecipients start causedBy(${e.relatedTarget ? e.relatedTarget.outerHTML : undefined})`);\n    this.hideContacts();\n    await this.parseRenderRecipients($(target));\n    // If thereis no related target or related target isn't in recipients functionality\n    // then we need to collapse inputs\n    await this.collapseInputsIfNeeded(e.relatedTarget);\n    this.view.errModule.debug(`input_to.blur -> parseRenderRecipients done`);\n  }\n\n  private inputsDragEnterHandler = (target: HTMLElement) => {\n    if (Catch.browser().name === 'firefox') {\n      this.insertCursorBefore(target.previousElementSibling!, true);\n    } else {\n      target.focus();\n    }\n  }\n\n  private inputsDragLeaveHandler = (target: HTMLElement) => {\n    if (Catch.browser().name === 'firefox') {\n      this.removeCursor(target.previousElementSibling! as HTMLElement);\n    } else {\n      target.blur();\n    }\n  }\n\n  private inputsDropHandler = (target: HTMLElement) => {\n    if (Catch.browser().name === 'firefox') {\n      this.removeCursor(target.previousElementSibling as HTMLElement);\n    }\n    if (this.dragged) {\n      const previousInput = this.dragged.parentElement!.nextElementSibling!;\n      this.dragged.parentElement!.removeChild(this.dragged);\n      const sendingType = target.getAttribute('data-sending-type') as RecipientType;\n      const jqueryTarget = $(target);\n      jqueryTarget.siblings('.recipients').append(this.dragged); // xss-safe-value\n      const draggableElementIndex = this.addedRecipients.findIndex(r => r.element === this.dragged);\n      this.addedRecipients[draggableElementIndex].sendingType = sendingType;\n      this.addedRecipients = moveElementInArray(this.addedRecipients, draggableElementIndex, this.addedRecipients.length - 1);\n      this.view.sizeModule.resizeInput(jqueryTarget.add(previousInput));\n      target.focus();\n    }\n  }\n\n  private copyCcBccActionsClickHandler = (target: HTMLElement, newContainer: JQuery<HTMLElement>) => {\n    const buttonsContainer = target.parentElement!;\n    const curentContainer = buttonsContainer.parentElement!;\n    const input = newContainer.find('input');\n    curentContainer.removeChild(buttonsContainer);\n    newContainer.append(buttonsContainer); // xss-safe-value\n    newContainer.css('display', 'block');\n    target.style.display = 'none';\n    input.focus();\n    this.view.sizeModule.resizeComposeBox();\n    this.view.sizeModule.setInputTextHeightManuallyIfNeeded();\n  }\n\n  private addTheirPubkeyClickHandler = () => {\n    const noPgpRecipients = this.addedRecipients.filter(r => r.element.className.includes('no_pgp'));\n    this.view.renderModule.renderAddPubkeyDialog(noPgpRecipients.map(r => r.email));\n    clearInterval(this.addedPubkeyDbLookupInterval); // todo - get rid of Catch.set_interval. just supply tabId and wait for direct callback\n    this.addedPubkeyDbLookupInterval = Catch.setHandledInterval(async () => {\n      const recipientsHasPgp: RecipientElement[] = [];\n      for (const recipient of noPgpRecipients) {\n        const [contact] = await ContactStore.get(undefined, [recipient.email]);\n        if (contact && contact.hasPgp) {\n          $(recipient.element).removeClass('no_pgp').find('i').remove();\n          clearInterval(this.addedPubkeyDbLookupInterval);\n          recipientsHasPgp.push(recipient);\n        }\n      }\n      await this.evaluateRecipients(recipientsHasPgp);\n      await this.setEmailsPreview(this.getRecipients());\n    }, 1000);\n  }\n\n  /**\n   * Keyboard navigation in search results.\n   *\n   * Arrows: select next/prev result\n   * Enter: choose result\n   * Esc: close search results dropdown\n   *\n   * Returns the boolean value which indicates if this.searchContacts() should be\n   * prevented from triggering (in keyup handler)\n   */\n  private recipientInputKeydownHandler = (e: JQuery.Event<HTMLElement, null>): boolean => {\n    const currentActive = this.view.S.cached('contacts').find('ul li.select_contact.active');\n    if (e.key === 'Backspace') {\n      if (!$(e.target).val()) {\n        const sendingType = e.target.getAttribute('data-sending-type') as RecipientType;\n        const lastRecipient = this.addedRecipients.reverse().find(r => r.sendingType === sendingType);\n        if (lastRecipient) {\n          this.removeRecipient(lastRecipient.element);\n        }\n      }\n      return false;\n    } else if (e.keyCode === 32) { // Handle 'Space' key\n      const target = $(e.target);\n      const emails = String(target.val()).split(/[,\\s]/g).filter(e => !!e);\n      if (!emails.find(e => !Str.isEmailValid(e))) {\n        this.parseRenderRecipients($(e.target), false, emails).catch(Catch.reportErr);\n        e.preventDefault();\n      } else if (target.val() === '') {\n        e.preventDefault();\n      }\n    } else if (e.key === 'Enter') {\n      if (currentActive.length) { // If he pressed enter when contacts popover is shown\n        currentActive.click(); // select contact\n        currentActive.removeClass('active');\n      } else { // We need to force add recipient even it's invalid\n        this.parseRenderRecipients($(e.target), true).catch(Catch.reportErr);\n      }\n      e.target.focus();\n      return true;\n    } else if (this.view.S.cached('contacts').is(':hidden')) { // Next will affect contacts popover\n      return false;\n    } else if (e.key === 'Escape') {\n      e.stopPropagation();\n      this.hideContacts();\n      this.view.S.cached('input_to').focus();\n      return true;\n    } else if (!currentActive.length) {\n      return false; // all following code operates on selected currentActive element\n    } else if (e.key === 'Tab') {\n      e.preventDefault(); // don't switch inputs\n      e.stopPropagation(); // don't switch inputs\n      currentActive.click(); // select contact\n      currentActive.removeClass('active');\n      return true;\n    } else if (e.key === 'ArrowUp') {\n      e.preventDefault();\n      let prev = currentActive.prev('.select_contact');\n      if (!prev.length) {\n        prev = this.view.S.cached('contacts').find('ul li.select_contact').last();\n      }\n      currentActive.removeClass('active');\n      prev.addClass('active');\n      return true;\n    } else if (e.key === 'ArrowDown') {\n      e.preventDefault();\n      let next = currentActive.next('.select_contact');\n      if (!next.length) {\n        next = this.view.S.cached('contacts').find('ul li.select_contact').first();\n      }\n      currentActive.removeClass('active');\n      next.addClass('active');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * todo - contactSearch should be refactored, plus split into a separate module\n   * That way things regarding searching contacts would be separate from more general recipients behavior\n   */\n  private searchContacts = async (input: JQuery<HTMLElement>): Promise<void> => {\n    try {\n      this.contactSearchInProgress = true;\n      this.view.errModule.debug(`searchContacts`);\n      const substring = Str.parseEmail(String(input.val()), 'DO-NOT-VALIDATE').email;\n      this.view.errModule.debug(`searchContacts.query.substring(${JSON.stringify(substring)})`);\n      if (!substring) {\n        this.view.errModule.debug(`searchContacts 1`);\n        this.hideContacts(); // todo - show suggestions of most contacted ppl etc\n        return;\n      }\n      const contacts: ContactPreview[] = await ContactStore.search(undefined, { substring });\n      this.view.errModule.debug(`searchContacts substring: ${substring}`);\n      this.view.errModule.debug(`searchContacts db count: ${contacts.length}`);\n      this.renderSearchRes(input, contacts, { substring });\n      if (contacts.length >= this.MAX_CONTACTS_LENGTH || !(this.canReadEmails || this.canSearchContacts)) {\n        this.view.errModule.debug(`searchContacts 2, count: ${contacts.length}`);\n        return;\n      }\n      this.view.errModule.debug(`searchContacts 3`);\n      const foundOnGoogle = await this.searchContactsOnGoogle(substring, contacts);\n      await this.addApiLoadedContactsToDb(foundOnGoogle);\n      contacts.push(...foundOnGoogle.map(c => ContactStore.previewObj({ email: c.email, name: c.name })));\n      this.renderSearchRes(input, contacts, { substring });\n      if (contacts.length >= this.MAX_CONTACTS_LENGTH) {\n        this.view.errModule.debug(`searchContacts 3.b, count: ${contacts.length}`);\n        return;\n      }\n      this.view.errModule.debug(`searchContacts 4`);\n      if (this.canReadEmails && !foundOnGoogle.length) {\n        this.view.errModule.debug(`searchContacts (Gmail Sent Messages) 6.b`);\n        await this.guessContactsFromSentEmails(substring, contacts, async guessed => {\n          await this.addApiLoadedContactsToDb(guessed.new);\n          contacts.push(...guessed.new.map(c => ContactStore.previewObj({ email: c.email, name: c.name })));\n          this.renderSearchRes(input, contacts, { substring });\n        });\n      }\n    } catch (e) {\n      Ui.toast(`Error searching contacts: ${ApiErr.eli5(e)}`, 5);\n      throw e;\n    } finally {\n      this.view.errModule.debug('searchContacts 7 - finishing');\n      this.contactSearchInProgress = false;\n      this.renderSearchResultsLoadingDone();\n    }\n  }\n\n  private guessContactsFromSentEmails = async (query: string, knownContacts: ContactPreview[], multiCb: ChunkedCb) => {\n    this.view.errModule.debug('guessContactsFromSentEmails start');\n    await this.view.emailProvider.guessContactsFromSentEmails(query, knownContacts.map(c => c.email).filter(e => Str.isEmailValid(e)), multiCb).catch(e => {\n      if (ApiErr.isAuthErr(e)) {\n        BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n      } else if (ApiErr.isNetErr(e)) {\n        Ui.toast(`Network error - cannot search contacts`);\n      } else if (ApiErr.isMailOrAcctDisabledOrPolicy(e)) {\n        Ui.toast(`Cannot search contacts - account disabled or forbidden by admin policy`);\n      } else {\n        Catch.reportErr(e);\n        Ui.toast(`Error searching contacts: ${ApiErr.eli5(e)}`);\n      }\n    });\n    this.view.errModule.debug('guessContactsFromSentEmails end');\n  }\n\n  private searchContactsOnGoogle = async (query: string, knownContacts: ContactPreview[]): Promise<EmailProviderContact[]> => {\n    if (this.canSearchContacts) {\n      this.view.errModule.debug(`searchContacts (Google API) 5`);\n      const contactsGoogle = await Google.contactsGet(this.view.acctEmail, query, undefined, this.MAX_CONTACTS_LENGTH);\n      if (contactsGoogle && contactsGoogle.length) {\n        return contactsGoogle.filter(cGmail => !knownContacts.find(c => c.email === cGmail.email));\n      }\n    }\n    return [];\n  }\n\n  private renderSearchRes = (input: JQuery<HTMLElement>, contacts: ContactPreview[], query: ProviderContactsQuery) => {\n    if ((input.val() as string).toLowerCase() !== query.substring.toLowerCase()) { // the input value has changed meanwhile\n      return;\n    }\n    this.view.errModule.debug(`renderSearchRes len: ${contacts.length}`);\n    // have pgp on top, no pgp bottom. Sort each groups by last use\n    const sortedContacts = contacts.sort((a: ContactPreview, b: ContactPreview) => {\n      if (a.hasPgp && !b.hasPgp) {\n        return -1;\n      }\n      if (!a.hasPgp && b.hasPgp) {\n        return 1;\n      }\n      if ((a.lastUse || 0) > (b.lastUse || 0)) {\n        return -1;\n      }\n      if ((a.lastUse || 0) < (b.lastUse || 0)) {\n        return 1;\n      }\n      return 0;\n    });\n    const renderableContacts = sortedContacts.slice(0, this.MAX_CONTACTS_LENGTH);\n    if ((renderableContacts.length > 0 || this.contactSearchInProgress) || !this.canSearchContacts) {\n      let ulHtml = '';\n      for (const contact of renderableContacts) {\n        ulHtml += `<li class=\"select_contact\" email=\"${Xss.escape(contact.email.replace(/<\\/?b>/g, ''))}\">`;\n        if (contact.hasPgp) {\n          ulHtml += '<img class=\"lock-icon\" src=\"/img/svgs/locked-icon-green.svg\" />';\n        } else {\n          ulHtml += '<img class=\"lock-icon\" src=\"/img/svgs/locked-icon-gray.svg\" />';\n        }\n        let displayEmail;\n        if (contact.email.length < 40) {\n          displayEmail = contact.email;\n        } else {\n          const parts = contact.email.split('@');\n          displayEmail = parts[0].replace(/<\\/?b>/g, '').substr(0, 10) + '...@' + parts[1];\n        }\n        displayEmail = '<div class=\"select_contact_email\" data-test=\"action-select-contact-email\">' + Xss.escape(displayEmail) + '</div>';\n        if (contact.name) {\n          ulHtml += '<div class=\"select_contact_name\" data-test=\"action-select-contact-name\">' + Xss.escape(contact.name) + displayEmail + '</div>';\n        } else {\n          ulHtml += displayEmail;\n        }\n        ulHtml += '</li>';\n      }\n      if (this.contactSearchInProgress) {\n        ulHtml += '<li class=\"loading\" data-test=\"container-contacts-loading\">loading...</li>';\n      }\n      Xss.sanitizeRender(this.view.S.cached('contacts').find('ul'), ulHtml);\n      if (!this.canSearchContacts) {\n        if (!contacts.length) {\n          this.view.S.cached('contacts').find('ul').append('<li>No Contacts Found</li>'); // xss-direct\n        }\n        this.addBtnToAllowSearchContactsFromGoogle(input);\n      }\n      const contactItems = this.view.S.cached('contacts').find('ul li.select_contact');\n      contactItems.first().addClass('active');\n      contactItems.click(this.view.setHandlerPrevent('double', async (target: HTMLElement) => {\n        const email = Str.parseEmail($(target).attr('email') || '').email;\n        if (email) {\n          await this.selectContact(input, email, query);\n        }\n      }, this.view.errModule.handle(`select contact`)));\n      contactItems.hover(function () {\n        contactItems.removeClass('active');\n        $(this).addClass('active');\n      });\n      this.view.S.cached('contacts').find('ul li.auth_contacts').click(this.view.setHandler(() =>\n        this.authContacts(this.view.acctEmail), this.view.errModule.handle(`authorize contact search`)));\n      const offset = input.offset()!;\n      const inputToPadding = parseInt(input.css('padding-left'));\n      let leftOffset: number;\n      if (this.view.S.cached('body').width()! < offset.left + inputToPadding + this.view.S.cached('contacts').width()!) {\n        // Here we need to align contacts popover by right side\n        leftOffset = offset.left + inputToPadding + input.width()! - this.view.S.cached('contacts').width()!;\n      } else {\n        leftOffset = offset.left + inputToPadding;\n      }\n      const offsetTop = $('#recipients_row').height()! + offset.top; // both are in the template\n      const bottomGap = 10;\n      this.view.S.cached('contacts').css({\n        display: 'block',\n        left: leftOffset,\n        top: offsetTop,\n        maxHeight: `calc(100% - ${offsetTop + bottomGap}px)`,\n      });\n    }\n  }\n\n  private addBtnToAllowSearchContactsFromGoogle = (input: JQuery<HTMLElement>) => {\n    if (this.view.S.cached('contacts').find('.allow-google-contact-search').length) {\n      return;\n    }\n    this.view.S.cached('contacts')\n      .append('<div class=\"allow-google-contact-search\" data-test=\"action-auth-with-contacts-scope\"><img src=\"/img/svgs/gmail.svg\" />Enable Google Contact Search</div>') // xss-direct\n      .find('.allow-google-contact-search')\n      .click(this.view.setHandler(async () => {\n        const authResult = await BrowserMsg.send.bg.await.reconnectAcctAuthPopup({ acctEmail: this.view.acctEmail, scopes: GoogleAuth.defaultScopes('contacts') });\n        if (authResult.result === 'Success') {\n          this.canSearchContacts = true;\n          this.hideContacts();\n          await this.searchContacts(input);\n        } else if (authResult.result !== 'Closed') {\n          await Ui.modal.error(`Could not enable Google Contact search. Please write us at human@flowcrypt.com\\n\\n[${authResult.result}] ${authResult.error}`);\n        }\n      }));\n  }\n\n  private selectContact = async (input: JQuery<HTMLElement>, email: string, fromQuery: ProviderContactsQuery) => {\n    this.view.errModule.debug(`selectContact 1`);\n    const possiblyBogusRecipient = input.siblings('.recipients span.wrong').last();\n    const possiblyBogusAddr = Str.parseEmail(possiblyBogusRecipient.text()).email;\n    this.view.errModule.debug(`selectContact 2`);\n    const q = Str.parseEmail(fromQuery.substring).email;\n    if (possiblyBogusAddr && q && (possiblyBogusAddr === q || possiblyBogusAddr.includes(q))) {\n      possiblyBogusRecipient.remove();\n    }\n    this.view.errModule.debug(`selectContact -> parseRenderRecipients start`);\n    this.parseRenderRecipients(input, false, [email]).catch(Catch.reportErr);\n    input.focus();\n    this.hideContacts();\n  }\n\n  private createRecipientsElements = (container: JQuery<HTMLElement>, emails: string[], sendingType: RecipientType, status: RecipientStatus): RecipientElement[] => {\n    const result = [];\n    for (const rawEmail of emails) {\n      const { email } = Str.parseEmail(rawEmail);\n      const recipientId = this.generateRecipientId();\n      const recipientsHtml = `<span tabindex=\"0\" id=\"${recipientId}\" data-test=\"${recipientId}\"><span>${Xss.escape(email || rawEmail)}</span> ${Ui.spinner('green')}</span>`;\n      Xss.sanitizeAppend(container.find('.recipients'), recipientsHtml);\n      const element = document.getElementById(recipientId);\n      if (element) { // if element wasn't created this means that Composer is used by another component\n        $(element).on('blur', this.view.setHandler(async (elem, event) => {\n          if (!this.dragged) {\n            await this.collapseInputsIfNeeded(event.relatedTarget);\n          }\n        }));\n        $(element).on('keydown', this.view.setHandler((el, ev) => {\n          if (ev.key === 'Delete' || ev.key === 'Backspace') {\n            this.removeRecipient(element);\n          }\n        }, this.view.errModule.handle('remove recipient with keyboard')));\n        this.addDraggableEvents(element);\n        const recipient = { email: email || rawEmail, element, id: recipientId, sendingType, status: email ? status : RecipientStatus.WRONG };\n        this.addedRecipients.push(recipient);\n        result.push(recipient);\n      }\n    }\n    return result;\n  }\n\n  private addApiLoadedContactsToDb = async (newContacts: EmailProviderContact[]) => {\n    this.view.errModule.debug('addApiLoadedContactsToDb 1');\n    if (!newContacts.length) {\n      return;\n    }\n    const toLookup: Contact[] = [];\n    for (const input of newContacts) {\n      const contact = await ContactStore.obj({ email: input.email, name: input.name });\n      const [storedContact] = await ContactStore.get(undefined, [contact.email]);\n      if (storedContact) {\n        if (!storedContact.name && contact.name) {\n          await ContactStore.update(undefined, contact.email, { name: contact.name } as ContactUpdate);\n        }\n      } else if (!this.failedLookupEmails.includes(contact.email)) {\n        toLookup.push(contact);\n      }\n    }\n    await Promise.all(toLookup.map(c => this.view.storageModule.ksLookupUnknownContactPubAndSaveToDb(c.email, c.name || undefined, undefined).then(lookupRes => {\n      if (lookupRes === 'fail') {\n        this.failedLookupEmails.push(c.email);\n      }\n    })));\n  }\n\n  private renderSearchResultsLoadingDone = () => {\n    this.view.S.cached('contacts').find('ul li.loading').remove();\n    if (!this.view.S.cached('contacts').find('ul li').length) {\n      this.hideContacts();\n    }\n  }\n\n  private orderRecipientsBySendingType = (a: RecipientElement, b: RecipientElement) => {\n    if (a.sendingType === b.sendingType) {\n      return 0;\n    }\n    if (a.sendingType === 'to' && b.sendingType !== 'to') {\n      return -1;\n    }\n    if (a.sendingType === 'cc' && b.sendingType === 'bcc') {\n      return -1;\n    }\n    return 1;\n  }\n\n  private authContacts = async (acctEmail: string) => {\n    const connectToGoogleRecipientLine = this.addedRecipients[this.addedRecipients.length - 1];\n    this.view.S.cached('input_to').val(connectToGoogleRecipientLine.email);\n    this.removeRecipient(connectToGoogleRecipientLine.element);\n    const authRes = await GoogleAuth.newAuthPopup({ acctEmail, scopes: GoogleAuth.defaultScopes('contacts') });\n    if (authRes.result === 'Success') {\n      this.canSearchContacts = true;\n      this.canReadEmails = true;\n      this.view.scopes.readContacts = true;\n      this.view.scopes.read = true;\n      await this.searchContacts(this.view.S.cached('input_to'));\n    } else if (authRes.result === 'Denied' || authRes.result === 'Closed') {\n      await Ui.modal.error('FlowCrypt needs this permission to search your contacts on Gmail. Without it, FlowCrypt will keep a separate contact list.');\n    } else {\n      await Ui.modal.error(Lang.general.somethingWentWrongTryAgain);\n    }\n  }\n\n  private checkReciepientsKeys = async () => {\n    for (const recipientEl of this.addedRecipients.filter(r => r.element.className.includes('no_pgp'))) {\n      const email = $(recipientEl).text().trim();\n      const [dbContact] = await ContactStore.get(undefined, [email]);\n      if (dbContact) {\n        recipientEl.element.classList.remove('no_pgp');\n        await this.renderPubkeyResult(recipientEl, dbContact);\n      }\n    }\n  }\n\n  private renderPubkeyResult = async (recipient: RecipientElement, contact: Contact | 'fail' | 'wrong') => {\n    const el = recipient.element;\n    this.view.errModule.debug(`renderPubkeyResult.emailEl(${String(recipient.email)})`);\n    this.view.errModule.debug(`renderPubkeyResult.email(${recipient.email})`);\n    this.view.errModule.debug(`renderPubkeyResult.contact(${JSON.stringify(contact)})`);\n    $(el).children('img, i').remove();\n    const contentHtml = '<img src=\"/img/svgs/close-icon.svg\" alt=\"close\" class=\"close-icon svg\" />' +\n      '<img src=\"/img/svgs/close-icon-black.svg\" alt=\"close\" class=\"close-icon svg display_when_sign\" />';\n    Xss.sanitizeAppend(el, contentHtml)\n      .find('img.close-icon')\n      .click(this.view.setHandler(target => this.removeRecipient(target.parentElement!), this.view.errModule.handle('remove recipient')));\n    $(el).removeClass(['failed', 'wrong', 'has_pgp', 'no_pgp', 'expired']);\n    if (contact === PUBKEY_LOOKUP_RESULT_FAIL) {\n      recipient.status = RecipientStatus.FAILED;\n      $(el).attr('title', 'Failed to load, click to retry');\n      $(el).addClass(\"failed\");\n      Xss.sanitizeReplace($(el).children('img:visible'), '<img src=\"/img/svgs/repeat-icon.svg\" class=\"repeat-icon action_retry_pubkey_fetch\">' +\n        '<img src=\"/img/svgs/close-icon-black.svg\" class=\"close-icon-black svg remove-reciepient\">');\n      $(el).find('.action_retry_pubkey_fetch').click(this.view.setHandler(async () => await this.refreshRecipients(), this.view.errModule.handle('refresh recipient')));\n      $(el).find('.remove-reciepient').click(this.view.setHandler(element => this.removeRecipient(element.parentElement!), this.view.errModule.handle('remove recipient')));\n    } else if (contact === PUBKEY_LOOKUP_RESULT_WRONG) {\n      recipient.status = RecipientStatus.WRONG;\n      this.view.errModule.debug(`renderPubkeyResult: Setting email to wrong / misspelled in harsh mode: ${recipient.email}`);\n      $(el).attr('title', 'This email address looks misspelled. Please try again.');\n      $(el).addClass(\"wrong\");\n    } else if (contact.pubkey && ((contact.expiresOn || Infinity) <= Date.now() || contact.pubkey.usableForEncryptionButExpired)) {\n      recipient.status = RecipientStatus.EXPIRED;\n      $(el).addClass(\"expired\");\n      Xss.sanitizePrepend(el, '<img src=\"/img/svgs/expired-timer.svg\" class=\"revoked-or-expired\">');\n      $(el).attr('title', 'Does use encryption but their public key is expired. You should ask them to send ' +\n        'you an updated public key.' + this.recipientKeyIdText(contact));\n    } else if (contact.revoked) {\n      recipient.status = RecipientStatus.REVOKED;\n      $(el).addClass(\"revoked\");\n      Xss.sanitizePrepend(el, '<img src=\"/img/svgs/revoked.svg\" class=\"revoked-or-expired\">');\n      $(el).attr('title', 'Does use encryption but their public key is revoked. You should ask them to send ' +\n        'you an updated public key.' + this.recipientKeyIdText(contact));\n    } else if (contact.pubkey) {\n      recipient.status = RecipientStatus.HAS_PGP;\n      $(el).addClass('has_pgp');\n      Xss.sanitizePrepend(el, '<img class=\"lock-icon\" src=\"/img/svgs/locked-icon.svg\" />');\n      $(el).attr('title', 'Does use encryption' + this.recipientKeyIdText(contact));\n    } else {\n      recipient.status = RecipientStatus.NO_PGP;\n      $(el).addClass(\"no_pgp\");\n      Xss.sanitizePrepend(el, '<img class=\"lock-icon\" src=\"/img/svgs/locked-icon.svg\" />');\n      $(el).attr('title', 'Could not verify their encryption setup. You can encrypt the message with a password below. Alternatively, add their pubkey.');\n    }\n    this.view.pwdOrPubkeyContainerModule.showHideContainerAndColorSendBtn(); // tslint:disable-line:no-floating-promises\n    this.view.myPubkeyModule.reevaluateShouldAttachOrNot();\n  }\n\n  private removeRecipient = (element: HTMLElement) => {\n    const index = this.addedRecipients.findIndex(r => r.element.isEqualNode(element));\n    this.addedRecipients[index].element.remove();\n    const container = element.parentElement?.parentElement; // Get Container, e.g. '.input-container-cc'\n    if (container) {\n      this.view.sizeModule.resizeInput($(container).find('input'));\n    }\n    this.view.S.cached('input_addresses_container_outer').find(`#input-container-${this.addedRecipients[index].sendingType} input`).focus();\n    this.addedRecipients.splice(index, 1);\n    this.view.pwdOrPubkeyContainerModule.showHideContainerAndColorSendBtn(); // tslint:disable-line:no-floating-promises\n    this.view.myPubkeyModule.reevaluateShouldAttachOrNot();\n  }\n\n  private refreshRecipients = async () => {\n    const failedRecipients = this.addedRecipients.filter(r => r.element.className.includes('failed'));\n    await this.reEvaluateRecipients(failedRecipients);\n  }\n\n  private recipientKeyIdText = (contact: Contact) => {\n    if (contact.fingerprint) {\n      return `\\n\\nRecipient public key fingerprint:\\n${Str.spaced(contact.fingerprint)}`;\n    } else {\n      return '';\n    }\n  }\n\n  private generateRecipientId = (): string => {\n    return `recipient_${this.addedRecipients.length}`;\n  }\n\n  private addDraggableEvents = (element: HTMLElement) => {\n    element.draggable = true;\n    element.ondragstart = (event) => {\n      event.dataTransfer!.setData('text/plain', 'FlowCrypt Drag&Drop'); // Firefox requires to run the dataTransfer.setData function in the event.\n      this.dragged = element;\n    };\n    element.ondragenter = () => {\n      if (this.dragged !== element) {\n        this.insertCursorBefore(element);\n      }\n    };\n    element.ondragleave = () => {\n      if (this.dragged !== element) {\n        this.removeCursor(element.parentElement!);\n      }\n    };\n    element.ondragover = (ev) => {\n      ev.preventDefault();\n    };\n    element.ondrop = () => {\n      this.removeCursor(element.parentElement!);\n      // The position won't be changed so we don't need to do any manipulations\n      if (!this.dragged || this.dragged === element || this.dragged.nextElementSibling === element) {\n        this.dragged = undefined;\n        return;\n      }\n      const previousInput = this.dragged.parentElement!.nextElementSibling!;\n      this.dragged.parentElement!.removeChild(this.dragged);\n      element.parentElement!.insertBefore(this.dragged, element);  // xss-reinsert\n      const draggableElementIndex = this.addedRecipients.findIndex(r => r.element === this.dragged);\n      const sendingType = this.addedRecipients.find(r => r.element === element)!.sendingType;\n      this.addedRecipients[draggableElementIndex].sendingType = sendingType;\n      // Sync the Recipients array with HTML\n      this.addedRecipients = moveElementInArray(this.addedRecipients, draggableElementIndex, this.addedRecipients.findIndex(r => r.element === element));\n      const newInput = this.view.S.cached('input_addresses_container_outer').find(`#input-container-${sendingType} input`);\n      this.view.sizeModule.resizeInput(newInput.add(previousInput));\n      this.dragged = undefined;\n      newInput.focus();\n    };\n    element.ondragend = () => Catch.setHandledTimeout(() => this.dragged = undefined, 0);\n  }\n\n  private insertCursorBefore = (element: HTMLElement | Element, append?: boolean) => {\n    const cursor = document.createElement('i');\n    cursor.classList.add('drag-cursor');\n    if (!append) {\n      if (!element.parentElement) {\n        return false;\n      }\n      element.parentElement!.insertBefore(cursor, element); // xss-reinsert\n    } else {\n      element.appendChild(cursor);\n    }\n    return true;\n  }\n\n  private removeCursor = (element: HTMLElement) => {\n    for (const child of element.children) {\n      if (child.classList.contains('drag-cursor')) {\n        child.parentElement!.removeChild(child);\n        break;\n      }\n    }\n  }\n\n  private focusRecipients = () => {\n    this.view.S.cached('recipients_placeholder').hide();\n    this.view.S.cached('input_addresses_container_outer').removeClass('invisible');\n    this.view.sizeModule.resizeComposeBox();\n    if (this.view.isReplyBox) {\n      this.view.sizeModule.resizeInput();\n    }\n    this.view.sizeModule.setInputTextHeightManuallyIfNeeded();\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/compose-render-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Attachment } from '../../../js/common/core/attachment.js';\nimport { Browser } from '../../../js/common/browser/browser.js';\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { KeyImportUi } from '../../../js/common/ui/key-import-ui.js';\nimport { Lang } from '../../../js/common/lang.js';\nimport { RecipientType } from '../../../js/common/api/shared/api.js';\nimport { Recipients } from '../../../js/common/api/email-provider/email-provider-api.js';\nimport { SendableMsg } from '../../../js/common/api/email-provider/sendable-msg.js';\nimport { Str } from '../../../js/common/core/common.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { GmailParser } from '../../../js/common/api/email-provider/gmail/gmail-parser.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\nimport { ContactStore } from '../../../js/common/platform/store/contact-store.js';\nimport { KeyUtil } from '../../../js/common/core/crypto/key.js';\n\nexport class ComposeRenderModule extends ViewModule<ComposeView> {\n\n  public responseMethod: 'reply' | 'forward' | undefined;\n\n  public initComposeBox = async () => {\n    if (this.view.isReplyBox) {\n      this.responseMethod = 'reply';\n    }\n    this.initComposeBoxStyles();\n    if (this.view.draftId) {\n      const draftLoaded = await this.view.draftModule.initialDraftLoad(this.view.draftId);\n      if (draftLoaded) {\n        this.view.S.cached('triple_dot').remove(); // if it's draft, footer and quote should already be included in the draft\n      }\n      if (this.view.isReplyBox) {\n        await this.view.renderModule.renderReplyMsgComposeTable();\n      }\n    } else {\n      if (this.view.isReplyBox && this.view.replyParams) {\n        const recipients: Recipients = { to: this.view.replyParams.to, cc: this.view.replyParams.cc, bcc: this.view.replyParams.bcc };\n        this.view.recipientsModule.addRecipients(recipients, false).catch(Catch.reportErr);\n        // await this.view.composerContacts.addRecipientsAndShowPreview(recipients);\n        if (this.view.skipClickPrompt) { // TODO: fix issue when loading recipients\n          await this.renderReplyMsgComposeTable();\n        } else {\n          $('#a_reply,#a_reply_all,#a_forward')\n            .click(this.view.setHandler((el) => this.actionActivateReplyBoxHandler(el), this.view.errModule.handle(`activate repply box`)));\n        }\n      }\n    }\n    if (this.view.isReplyBox) {\n      $(document).ready(() => this.view.sizeModule.resizeComposeBox());\n    } else {\n      this.view.S.cached('body').css('overflow', 'hidden'); // do not enable this for replies or automatic resize won't work\n      await this.renderComposeTable();\n      await this.view.recipientsModule.setEmailsPreview(this.view.recipientsModule.getRecipients());\n    }\n    this.view.sendBtnModule.resetSendBtn();\n    await this.view.sendBtnModule.popover.render();\n    this.loadRecipientsThenSetTestStateReady().catch(Catch.reportErr);\n  }\n\n  public renderReplyMsgComposeTable = async (): Promise<void> => {\n    this.view.S.cached('prompt').css({ display: 'none' });\n    this.view.recipientsModule.showHideCcAndBccInputsIfNeeded();\n    await this.view.recipientsModule.setEmailsPreview(this.view.recipientsModule.getRecipients());\n    await this.renderComposeTable();\n    if (this.view.replyParams) {\n      const thread = await this.view.emailProvider.threadGet(this.view.threadId, 'metadata');\n      const inReplyToMessage = thread.messages?.find((message) => message.id === this.view.replyMsgId);\n      if (inReplyToMessage) {\n        this.view.replyParams.inReplyTo = inReplyToMessage.payload?.headers?.find((header) => header.name === 'Message-Id')?.value;\n      }\n      this.view.replyParams.subject = `${(this.responseMethod === 'reply' ? 'Re' : 'Fwd')}: ${this.view.replyParams.subject}`;\n    }\n    if (!this.view.draftModule.wasMsgLoadedFromDraft) { // if there is a draft, don't attempt to pull quoted content. It's assumed to be already present in the draft\n      (async () => { // not awaited because can take a long time & blocks rendering\n        await this.view.quoteModule.addTripleDotQuoteExpandFooterAndQuoteBtn(this.view.replyMsgId, this.responseMethod!);\n        if (this.view.quoteModule.messageToReplyOrForward) {\n          const msgId = this.view.quoteModule.messageToReplyOrForward.headers['message-id'];\n          this.view.sendBtnModule.additionalMsgHeaders['In-Reply-To'] = msgId;\n          this.view.sendBtnModule.additionalMsgHeaders.References = this.view.quoteModule.messageToReplyOrForward.headers.references + ' ' + msgId;\n          if (this.view.replyPubkeyMismatch) {\n            await this.renderReplyMsgAsReplyPubkeyMismatch();\n          } else if (this.view.quoteModule.messageToReplyOrForward.isOnlySigned) {\n            this.view.sendBtnModule.popover.toggleItemTick($('.action-toggle-encrypt-sending-option'), 'encrypt', false); // don't encrypt\n            this.view.sendBtnModule.popover.toggleItemTick($('.action-toggle-sign-sending-option'), 'sign', true); // do sign\n          }\n        }\n      })().catch(Catch.reportErr);\n    }\n    this.view.sizeModule.resizeComposeBox();\n    if (this.responseMethod === 'forward') {\n      this.view.S.cached('recipients_placeholder').click();\n    }\n    BrowserMsg.send.scrollToReplyBox(this.view.parentTabId, { replyMsgId: `#${this.view.frameId}` });\n  }\n\n  public renderPrompt = () => {\n    this.view.S.cached('prompt').css('display', 'block');\n    if (this.view.replyParams) {\n      const recipientsNumber = this.view.replyParams.to.length + this.view.replyParams.cc.length + this.view.replyParams.bcc.length;\n      if (recipientsNumber > 1) {\n        $('#a_reply_all').css('display', 'inline-flex');\n      }\n    }\n  }\n\n  public renderReplySuccess = (msg: SendableMsg, msgId: string) => {\n    this.view.renderModule.renderReinsertReplyBox(msgId);\n    if (!this.view.sendBtnModule.popover.choices.encrypt) {\n      this.view.S.cached('replied_body').removeClass('pgp_secure');\n      if (this.view.sendBtnModule.popover.choices.sign) {\n        this.view.S.cached('replied_body').addClass('pgp_neutral');\n      }\n    }\n    this.view.S.cached('replied_body').css('width', ($('table#compose').width() || 500) - 30);\n    this.view.S.cached('compose_table').css('display', 'none');\n    this.view.S.cached('reply_msg_successful').find('div.replied_from').text(this.view.senderModule.getSender());\n    this.view.S.cached('reply_msg_successful').find('div.replied_to span').text(msg.headers.To.replace(/,/g, ', '));\n    const repliedBodyEl = this.view.S.cached('reply_msg_successful').find('div.replied_body');\n    if (this.view.inputModule.isRichText()) {\n      const sanitized = Xss.htmlSanitizeKeepBasicTags(this.view.inputModule.extract('html', 'input_text', 'SKIP-ADDONS'), 'IMG-KEEP');\n      Xss.setElementContentDANGEROUSLY(repliedBodyEl.get(0), sanitized); // xss-sanitized\n      this.renderReplySuccessMimeAttachments(this.view.inputModule.extractAttachments());\n    } else {\n      Xss.sanitizeRender(repliedBodyEl, Str.escapeTextAsRenderableHtml(this.view.inputModule.extract('text', 'input_text', 'SKIP-ADDONS')));\n      this.renderReplySuccessAttachments(msg.attachments, msgId, this.view.sendBtnModule.popover.choices.encrypt);\n    }\n    const t = new Date();\n    const time = ((t.getHours() !== 12) ? (t.getHours() % 12) : 12) + ':' + (t.getMinutes() < 10 ? '0' : '') + t.getMinutes() + ((t.getHours() >= 12) ? ' PM ' : ' AM ') + '(0 minutes ago)';\n    this.view.S.cached('reply_msg_successful').find('div.replied_time').text(time);\n    this.view.S.cached('reply_msg_successful').css('display', 'block');\n    this.view.sizeModule.resizeComposeBox();\n  }\n\n  public renderReinsertReplyBox = (msgId: string) => {\n    BrowserMsg.send.reinsertReplyBox(this.view.parentTabId, { replyMsgId: msgId });\n  }\n\n  public renderAddPubkeyDialog = (emails: string[]) => {\n    BrowserMsg.send.addPubkeyDialog(this.view.parentTabId, { emails });\n  }\n\n  public closeMsg = () => {\n    $('body').attr('data-test-state', 'closed'); // used by automated tests\n    if (this.view.isReplyBox) {\n      BrowserMsg.send.closeReplyMessage(this.view.parentTabId, { frameId: this.view.frameId });\n    } else {\n      BrowserMsg.send.closeNewMessage(this.view.parentTabId);\n    }\n  }\n\n  public openSettingsWithDialog = async (settingsModule: string) => {\n    await Browser.openSettingsPage('index.htm', this.view.acctEmail, `/chrome/settings/modules/${settingsModule}.htm`);\n  }\n\n  public fetchReplyMeta = async (aliases: string[]): Promise<void> => {\n    Xss.sanitizePrepend('#new_message', Ui.e('div', { id: 'loader', html: `Loading secure reply box..${Ui.spinner('green')}` }));\n    try {\n      const gmailMsg = await this.view.emailProvider.msgGet(this.view.replyMsgId!, 'metadata');\n      this.view.replyParams = GmailParser.determineReplyMeta(this.view.acctEmail, aliases, gmailMsg);\n      this.view.threadId = gmailMsg.threadId || '';\n    } catch (e) {\n      if (ApiErr.isAuthErr(e)) {\n        BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n      }\n      if (e instanceof Error) {\n        e.message = `Cannot get reply data for the message you are replying to.`;\n      }\n      throw e;\n    } finally {\n      $('#loader').remove();\n    }\n  }\n\n  private initComposeBoxStyles = () => {\n    if (this.view.isReplyBox) {\n      this.view.S.cached('body').addClass('reply_box');\n      this.view.S.cached('header').remove();\n      this.view.S.cached('subject').remove();\n      this.view.S.cached('contacts').css('top', '39px');\n      this.view.S.cached('compose_table').css({ 'border-bottom': '1px solid #cfcfcf', 'border-top': '1px solid #cfcfcf' });\n      this.view.S.cached('input_text').css('overflow-y', 'hidden');\n      if (!this.view.skipClickPrompt && !this.view.draftId) {\n        this.renderPrompt();\n      }\n    } else {\n      this.view.S.cached('compose_table').css({ 'height': '100%' });\n    }\n  }\n\n  private actionActivateReplyBoxHandler = async (target: HTMLElement) => {\n    const typesToDelete: RecipientType[] = [];\n    const method = $(target).attr('id');\n    if (method === 'a_forward') {\n      this.responseMethod = 'forward';\n      typesToDelete.push('to');\n      typesToDelete.push('cc');\n      typesToDelete.push('bcc');\n    } else if (method === 'a_reply') {\n      typesToDelete.push('cc');\n      typesToDelete.push('bcc');\n    }\n    this.view.recipientsModule.deleteRecipientsBySendingType(typesToDelete);\n    await this.renderReplyMsgComposeTable();\n  }\n\n  private renderReplyMsgAsReplyPubkeyMismatch = async () => {\n    this.view.inputModule.inputTextHtmlSetSafely(`Hello,\n      <br><br>I was not able to read your encrypted message because it was encrypted for a wrong key.\n      <br><br>My current public key is attached below. Please update your records and send me a new encrypted message.\n      <br><br>Thank you</div>`);\n    const primaryKi = await KeyStore.getFirstRequired(this.view.acctEmail);\n    const attachment = Attachment.keyinfoAsPubkeyAttachment(primaryKi);\n    this.view.attachmentsModule.attachment.addFile(new File([attachment.getData()], attachment.name));\n    this.view.sendBtnModule.popover.toggleItemTick($('.action-toggle-encrypt-sending-option'), 'encrypt', false); // don't encrypt\n    this.view.sendBtnModule.popover.toggleItemTick($('.action-toggle-sign-sending-option'), 'sign', false); // don't sign\n  }\n\n  private getFocusableEls = () => {\n    return this.view.S.cached('compose_table').find('[tabindex]:not([tabindex=\"-1\"]):visible').toArray().sort((a, b) => {\n      const tabindexA = parseInt(a.getAttribute('tabindex') || '');\n      const tabindexB = parseInt(b.getAttribute('tabindex') || '');\n      if (tabindexA > tabindexB) { // sort according to tabindex\n        return 1;\n      } else if (tabindexA < tabindexB) {\n        return -1;\n      }\n      return 0;\n    });\n  }\n\n  private renderComposeTable = async () => {\n    this.view.errModule.debugFocusEvents('input_text', 'send_btn', 'input_to', 'input_subject');\n    this.view.S.cached('compose_table').css('display', 'table');\n    await this.addComposeTableHandlers();\n    await this.view.senderModule.renderSendFromOrChevron();\n    if (this.view.isReplyBox) {\n      if (this.view.replyParams?.to.length) {\n        // Firefox will not always respond to initial automatic $input_text.blur(): recipients may be left unrendered, as standard text, with a trailing comma\n        await this.view.recipientsModule.parseRenderRecipients(this.view.S.cached('input_to')); // this will force firefox to render them on load\n      }\n    } else {\n      $('.close_new_message').click(this.view.setHandler(() => this.actionCloseHandler(), this.view.errModule.handle(`close message`)));\n      this.view.S.cached('header').find('#header_title').click(() => $('.minimize_new_message').click());\n      await this.view.quoteModule.addTripleDotQuoteExpandFooterOnlyBtn();\n      this.view.sizeModule.setInputTextHeightManuallyIfNeeded();\n    }\n    // Firefox needs an iframe to be focused before focusing its content\n    this.view.errModule.debug(`renderComposeTable: focusing this iframe`);\n    BrowserMsg.send.focusFrame(this.view.parentTabId, { frameId: this.view.frameId });\n    Catch.setHandledTimeout(() => { // Chrome needs async focus: https://github.com/FlowCrypt/flowcrypt-browser/issues/2056\n      const toCount = this.view.replyParams?.to.length;\n      const focusId = this.view.isReplyBox && this.responseMethod !== 'forward' && toCount ? 'input_text' : 'input_to';\n      this.view.errModule.debug(`renderComposeTable: focusing ${focusId} isReplyBox=${this.view.isReplyBox},responseMethod=${this.responseMethod},toCount=${toCount}`);\n      document.getElementById(focusId)!.focus(); // jQuery no longer worked as of 3.6.0\n    }, 100);\n    this.view.sizeModule.onComposeTableRender();\n  }\n\n  private addComposeTableHandlers = async () => {\n    this.view.S.cached('body').keydown(this.view.setHandler((el, ev) => this.onBodyKeydownHandler(el, ev)));\n    this.view.S.cached('input_to').bind('paste', this.view.setHandler((el, ev) => this.onRecipientPasteHandler(el, ev)));\n    this.view.inputModule.squire.addEventListener('keyup', () => this.view.S.cached('send_btn_note').text(''));\n    this.view.S.cached('input_addresses_container_inner').click(this.view.setHandler(() => this.onRecipientsClickHandler(), this.view.errModule.handle(`focus recipients`)));\n    this.view.S.cached('input_addresses_container_inner').children().click(() => false);\n    this.view.S.cached('input_subject').bind('input', this.view.setHandler((el: HTMLInputElement) => this.subjectRTLHandler(el))).trigger('input');\n  }\n\n  private subjectRTLHandler = (el: HTMLInputElement) => {\n    const rtlCheck = new RegExp('^[' + Str.rtlChars + ']');\n    if (el.value.match(rtlCheck)) {\n      $(el).attr('dir', 'rtl');\n    } else {\n      $(el).removeAttr('dir');\n    }\n  }\n\n  private actionCloseHandler = async () => {\n    if (!this.view.sendBtnModule.isSendMessageInProgres() || await Ui.modal.confirm(Lang.compose.abortSending)) {\n      this.view.renderModule.closeMsg();\n    }\n  }\n\n  private onRecipientsClickHandler = () => {\n    if (!this.view.S.cached('input_to').is(':focus')) {\n      this.view.errModule.debug(`input_addresses_container_inner.click -> calling input_to.focus() when input_to.val(${this.view.S.cached('input_to').val()})`);\n      this.view.S.cached('input_to').focus();\n    }\n  }\n\n  private onRecipientPasteHandler = async (elem: HTMLElement, event: JQuery.Event<HTMLElement>) => {\n    if (event.originalEvent instanceof ClipboardEvent && event.originalEvent.clipboardData) {\n      const textData = event.originalEvent.clipboardData.getData('text/plain');\n      const keyImportUi = new KeyImportUi({ checkEncryption: true });\n      let normalizedPub: string;\n      try {\n        normalizedPub = await keyImportUi.checkPub(textData);\n      } catch (e) {\n        return; // key is invalid\n      }\n      const key = await KeyUtil.parse(normalizedPub);\n      if (!key.emails.length) { // no users is not desired\n        await Ui.modal.warning(`There are no email addresses listed in this Public Key - don't know who this key belongs to.`);\n        return;\n      }\n      if (! await ContactStore.get(undefined, [key.emails[0]])) {\n        await ContactStore.save(undefined, await ContactStore.obj({\n          email: key.emails[0],\n          name: Str.parseEmail(key.identities[0]).name,\n          pubkey: normalizedPub,\n          lastCheck: Date.now(),\n        }));\n      }\n      this.view.S.cached('input_to').val(key.emails[0]);\n      await this.view.recipientsModule.parseRenderRecipients(this.view.S.cached('input_to'));\n    }\n  }\n\n  private onBodyKeydownHandler = (_: HTMLElement, e: JQuery.Event<HTMLElement>) => {\n    if (this.view.sizeModule.composeWindowIsMinimized) {\n      return e.preventDefault();\n    }\n    Ui.escape(() => !this.view.isReplyBox && $('.close_new_message').click())(e);\n    const focusableEls = this.getFocusableEls();\n    const focusIndex = focusableEls.indexOf(e.target);\n    if (focusIndex !== -1) { // Focus trap (Tab, Shift+Tab)\n      Ui.tab((e) => { // rollover to first item or focus next\n        focusableEls[focusIndex === focusableEls.length - 1 ? 0 : focusIndex + 1].focus();\n        e.preventDefault();\n      })(e);\n      Ui.shiftTab((e) => { // rollover to last item or focus prev\n        focusableEls[focusIndex === 0 ? focusableEls.length - 1 : focusIndex - 1].focus();\n        e.preventDefault();\n      })(e);\n    }\n  }\n\n  private loadRecipientsThenSetTestStateReady = async () => {\n    await Promise.all(this.view.recipientsModule.getRecipients().filter(r => r.evaluating).map(r => r.evaluating));\n    $('body').attr('data-test-state', 'ready');  // set as ready so that automated tests can evaluate results\n  }\n\n  private renderReplySuccessAttachments = (attachments: Attachment[], msgId: string, isEncrypted: boolean) => {\n    const hideAttachmentTypes = this.view.sendBtnModule.popover.choices.richtext ? ['hidden', 'encryptedMsg', 'signature', 'publicKey'] : ['publicKey'];\n    const renderableAttachments = attachments.filter(attachment => !hideAttachmentTypes.includes(attachment.treatAs()));\n    if (renderableAttachments.length) {\n      this.view.S.cached('replied_attachments').html(renderableAttachments.map(attachment => { // xss-safe-factory\n        attachment.msgId = msgId;\n        return this.view.factory!.embeddedAttachment(attachment, isEncrypted, this.view.parentTabId);\n      }).join('')).css('display', 'block');\n    }\n  }\n\n  private renderReplySuccessMimeAttachments = (attachmentsFilenames: string[]) => {\n    const attachments = $('<div id=\"attachments\"></div>');\n    for (const index in attachmentsFilenames) {\n      if (attachmentsFilenames.hasOwnProperty(index)) {\n        const filename = Xss.escape(attachmentsFilenames[index]);\n        attachments.append(`<button class=\"attachment\" index=\"${index}\" title=\"${filename}\"><b>${filename}</b></button>`); // xss-escaped\n      }\n    }\n    this.view.S.cached('replied_body').append(attachments); // xss-escaped\n  }\n}\n",
    "extension/chrome/elements/compose-modules/compose-send-btn-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport * as DOMPurify from 'dompurify';\n\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Attachment } from '../../../js/common/core/attachment.js';\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Buf } from '../../../js/common/core/buf.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { ComposerUserError } from './compose-err-module.js';\nimport { ComposeSendBtnPopoverModule } from './compose-send-btn-popover-module.js';\nimport { GeneralMailFormatter } from './formatters/general-mail-formatter.js';\nimport { GmailRes } from '../../../js/common/api/email-provider/gmail/gmail-parser.js';\nimport { KeyInfo, Key, KeyUtil } from '../../../js/common/core/crypto/key.js';\nimport { SendBtnTexts } from './compose-types.js';\nimport { SendableMsg } from '../../../js/common/api/email-provider/sendable-msg.js';\nimport { Str } from '../../../js/common/core/common.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\nimport { AcctStore } from '../../../js/common/platform/store/acct-store.js';\nimport { ContactStore } from '../../../js/common/platform/store/contact-store.js';\n\nexport class ComposeSendBtnModule extends ViewModule<ComposeView> {\n\n  public additionalMsgHeaders: { [key: string]: string } = {};\n  public btnUpdateTimeout?: number;\n  public popover: ComposeSendBtnPopoverModule;\n\n  private isSendMessageInProgress = false;\n\n  constructor(view: ComposeView) {\n    super(view);\n    this.popover = new ComposeSendBtnPopoverModule(view);\n  }\n\n  public setHandlers = (): void => {\n    const ctrlEnterHandler = Ui.ctrlEnter(() => !this.view.sizeModule.composeWindowIsMinimized && this.extractProcessSendMsg());\n    this.view.S.cached('subject').add(this.view.S.cached('compose')).keydown(ctrlEnterHandler);\n    this.view.S.cached('send_btn').click(this.view.setHandlerPrevent('double', () => this.extractProcessSendMsg()));\n    this.popover.setHandlers();\n  }\n\n  public isSendMessageInProgres = (): boolean => {\n    return this.isSendMessageInProgress;\n  }\n\n  public resetSendBtn = (delay?: number) => {\n    const doReset = () => {\n      Xss.sanitizeRender(this.view.S.cached('send_btn_text'), `<i></i>${this.btnText()}`);\n      this.view.S.cached('send_btn').addClass('green').removeClass('gray').prop('disabled', false);\n      this.view.S.cached('toggle_send_options').addClass('green').removeClass('gray').show();\n    };\n    if (typeof this.btnUpdateTimeout !== 'undefined') {\n      clearTimeout(this.btnUpdateTimeout);\n    }\n    if (!delay) {\n      doReset();\n    } else {\n      Catch.setHandledTimeout(doReset, delay);\n    }\n  }\n\n  public disableBtn = () => {\n    this.view.S.cached('send_btn').removeClass('green').addClass('gray').prop('disabled', true);\n    this.view.S.cached('toggle_send_options').removeClass('green').addClass('gray').prop('disabled', true);\n  }\n\n  public enableBtn = () => {\n    this.view.S.cached('send_btn').removeClass('gray').addClass('green').prop('disabled', false);\n    this.view.S.cached('toggle_send_options').removeClass('gray').addClass('green').prop('disabled', false);\n  }\n\n  public renderUploadProgress = (progress: number | undefined, progressRepresents: 'FIRST-HALF' | 'SECOND-HALF' | 'EVERYTHING') => {\n    if (progress && this.view.attachmentsModule.attachment.hasAttachment()) {\n      if (progressRepresents === 'FIRST-HALF') {\n        progress = Math.floor(progress / 2); // show 0-50% instead of 0-100%\n      } else if (progressRepresents === 'SECOND-HALF') {\n        progress = Math.floor(50 + progress / 2); // show 50-100% instead of 0-100%\n      } else {\n        progress = Math.floor(progress); // show 0-100%\n      }\n      this.view.S.now('send_btn_text').text(`${SendBtnTexts.BTN_SENDING} ${progress < 100 ? `${progress}%` : ''}`);\n    }\n  }\n\n  private btnText = (): string => {\n    if (this.popover.choices.encrypt && this.popover.choices.sign) {\n      return SendBtnTexts.BTN_ENCRYPT_SIGN_AND_SEND;\n    } else if (this.popover.choices.encrypt) {\n      return SendBtnTexts.BTN_ENCRYPT_AND_SEND;\n    } else if (this.popover.choices.sign) {\n      return SendBtnTexts.BTN_SIGN_AND_SEND;\n    } else {\n      return SendBtnTexts.BTN_PLAIN_SEND;\n    }\n  }\n\n  private extractProcessSendMsg = async () => {\n    if (this.view.S.cached('reply_msg_successful').is(':visible')) {\n      return;\n    }\n    this.view.sendBtnModule.disableBtn();\n    this.view.S.cached('toggle_send_options').hide();\n    try {\n      this.view.errModule.throwIfFormNotReady();\n      this.view.S.now('send_btn_text').text('Loading...');\n      Xss.sanitizeRender(this.view.S.now('send_btn_i'), Ui.spinner('white'));\n      this.view.S.cached('send_btn_note').text('');\n      const newMsgData = this.view.inputModule.extractAll();\n      await this.view.errModule.throwIfFormValsInvalid(newMsgData);\n      const senderKi = await this.view.storageModule.getKey(this.view.senderModule.getSender());\n      let signingPrv: Key | undefined;\n      if (this.popover.choices.sign) {\n        signingPrv = await this.decryptSenderKey(senderKi);\n        if (!signingPrv) {\n          return; // user has canceled the pass phrase dialog, or didn't respond to it in time\n        }\n      }\n      await ContactStore.update(undefined, Array.prototype.concat.apply([], Object.values(newMsgData.recipients)), { lastUse: Date.now() });\n      const msgObj = await GeneralMailFormatter.processNewMsg(this.view, newMsgData, senderKi, signingPrv);\n      await this.finalizeSendableMsg(msgObj, senderKi);\n      await this.doSendMsg(msgObj);\n    } catch (e) {\n      await this.view.errModule.handleSendErr(e);\n    } finally {\n      this.view.sendBtnModule.enableBtn();\n      this.view.S.cached('toggle_send_options').show();\n    }\n  }\n\n  private finalizeSendableMsg = async (msg: SendableMsg, senderKi: KeyInfo) => {\n    const choices = this.view.sendBtnModule.popover.choices;\n    for (const k of Object.keys(this.additionalMsgHeaders)) {\n      msg.headers[k] = this.additionalMsgHeaders[k];\n    }\n    if (choices.encrypt && !choices.richtext) {\n      for (const a of msg.attachments) {\n        a.type = 'application/octet-stream'; // so that Enigmail+Thunderbird does not attempt to display without decrypting\n      }\n    }\n    if (choices.richtext && !choices.encrypt && !choices.sign && msg.body['text/html']) {\n      // extract inline images of plain rich-text messages (#3256)\n      // todo - also apply to rich text signed-only messages\n      const { htmlWithCidImages, imgAttachments } = this.extractInlineImagesToAttachments(msg.body['text/html']);\n      msg.body['text/html'] = htmlWithCidImages;\n      msg.attachments.push(...imgAttachments);\n    }\n    if (this.view.myPubkeyModule.shouldAttach()) {\n      msg.attachments.push(Attachment.keyinfoAsPubkeyAttachment(senderKi));\n    }\n    await this.addNamesToMsg(msg);\n  }\n\n  private extractInlineImagesToAttachments = (html: string) => {\n    const imgAttachments: Attachment[] = [];\n    DOMPurify.addHook('afterSanitizeAttributes', (node) => {\n      if (!node) {\n        return;\n      }\n      if ('src' in node) {\n        const img: Element = node;\n        const src = img.getAttribute('src') as string;\n        const { mimeType, data } = this.parseInlineImageSrc(src);\n        if (mimeType && data) {\n          const imgAttachment = new Attachment({\n            cid: Attachment.attachmentId(),\n            name: img.getAttribute('name') || '',\n            type: mimeType,\n            data: Buf.fromBase64Str(data),\n            inline: true\n          });\n          img.setAttribute('src', `cid:${imgAttachment.cid}`);\n          imgAttachments.push(imgAttachment);\n        } else {\n          throw new ComposerUserError(`\n            Unable to parse an inline image <details>\n              <summary>See error details</summary>\n              src=\"${Xss.escape(src)}\"\n            </details>\n          `);\n        }\n      }\n    });\n    const htmlWithCidImages = DOMPurify.sanitize(html);\n    DOMPurify.removeAllHooks();\n    return { htmlWithCidImages, imgAttachments };\n  }\n\n  private parseInlineImageSrc = (src: string) => {\n    let mimeType;\n    let data = '';\n    const parts = src.split(/[:;,]/);\n    if (parts.length === 4 && parts[0] === 'data' && parts[1].match(/^image\\/\\w+/) && parts[2] === 'base64') {\n      mimeType = parts[1];\n      data = parts[3];\n    }\n    return { mimeType, data };\n  }\n\n\n  private doSendMsg = async (msg: SendableMsg) => {\n    // if this is a password-encrypted message, then we've already shown progress for uploading to backend\n    // and this requests represents second half of uploadable effort. Else this represents all (no previous heavy requests)\n    const progressRepresents = this.view.pwdOrPubkeyContainerModule.isVisible() ? 'SECOND-HALF' : 'EVERYTHING';\n    let msgSentRes: GmailRes.GmailMsgSend;\n    try {\n      this.isSendMessageInProgress = true;\n      msgSentRes = await this.view.emailProvider.msgSend(msg, (p) => this.renderUploadProgress(p, progressRepresents));\n    } catch (e) {\n      if (msg.thread && ApiErr.isNotFound(e) && this.view.threadId) { // cannot send msg because threadId not found - eg user since deleted it\n        msg.thread = undefined;\n        msgSentRes = await this.view.emailProvider.msgSend(msg, (p) => this.renderUploadProgress(p, progressRepresents));\n      } else {\n        this.isSendMessageInProgress = false;\n        throw e;\n      }\n    }\n    BrowserMsg.send.notificationShow(this.view.parentTabId, { notification: `Your ${this.view.isReplyBox ? 'reply' : 'message'} has been sent.` });\n    BrowserMsg.send.focusBody(this.view.parentTabId); // Bring focus back to body so Gmails shortcuts will work\n    await this.view.draftModule.draftDelete();\n    this.isSendMessageInProgress = false;\n    if (this.view.isReplyBox) {\n      this.view.renderModule.renderReplySuccess(msg, msgSentRes.id);\n    } else {\n      this.view.renderModule.closeMsg();\n    }\n  }\n\n  private decryptSenderKey = async (senderKi: KeyInfo): Promise<Key | undefined> => {\n    const prv = await KeyUtil.parse(senderKi.private);\n    const passphrase = await this.view.storageModule.passphraseGet(senderKi);\n    if (typeof passphrase === 'undefined' && !prv.fullyDecrypted) {\n      BrowserMsg.send.passphraseDialog(this.view.parentTabId, { type: 'sign', longids: [senderKi.longid] });\n      if ((typeof await this.view.storageModule.whenMasterPassphraseEntered(60)) !== 'undefined') { // pass phrase entered\n        return await this.decryptSenderKey(senderKi);\n      } else { // timeout - reset - no passphrase entered\n        this.resetSendBtn();\n        return undefined;\n      }\n    } else {\n      if (!prv.fullyDecrypted) {\n        await KeyUtil.decrypt(prv, passphrase!); // checked !== undefined above\n      }\n      return prv;\n    }\n  }\n\n  private addNamesToMsg = async (msg: SendableMsg): Promise<void> => {\n    const { sendAs } = await AcctStore.get(this.view.acctEmail, ['sendAs']);\n    const addNameToEmail = async (emails: string[]): Promise<string[]> => {\n      return await Promise.all(emails.map(async email => {\n        let name: string | undefined;\n        if (sendAs && sendAs[email]?.name) {\n          name = sendAs[email].name!;\n        } else {\n          const [contact] = await ContactStore.get(undefined, [email]);\n          if (contact?.name) {\n            name = contact.name;\n          }\n        }\n        const fixedEmail = Str.parseEmail(email).email;\n        if (!fixedEmail) {\n          throw new Error(`Recipient email ${email} is not valid`);\n        }\n        return name ? `${Str.rmSpecialCharsKeepUtf(name, 'ALLOW-SOME')} <${fixedEmail}>` : fixedEmail;\n      }));\n    };\n    msg.recipients.to = await addNameToEmail(msg.recipients.to || []);\n    msg.recipients.cc = await addNameToEmail(msg.recipients.cc || []);\n    msg.recipients.bcc = await addNameToEmail(msg.recipients.bcc || []);\n    msg.from = (await addNameToEmail([msg.from]))[0];\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/compose-sender-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\nimport { AcctStore } from '../../../js/common/platform/store/acct-store.js';\n\nexport class ComposeSenderModule extends ViewModule<ComposeView> {\n\n  public getSender = (): string => {\n    if (this.view.S.now('input_from').length) {\n      return String(this.view.S.now('input_from').val());\n    }\n    if (this.view.replyParams?.from) {\n      return this.view.replyParams.from;\n    }\n    return this.view.acctEmail;\n  }\n\n  public renderSendFromOrChevron = async () => {\n    if (this.view.isReplyBox) {\n      const { sendAs } = await AcctStore.get(this.view.acctEmail, ['sendAs']);\n      if (Object.keys(sendAs!).length > 1) {\n        const showAliasChevronHtml = '<img tabindex=\"22\" id=\"render_send_from\" src=\"/img/svgs/chevron-left.svg\" title=\"Choose sending address\">';\n        const inputAddrContainer = this.view.S.cached('container_cc_bcc_buttons');\n        Xss.sanitizeAppend(inputAddrContainer, showAliasChevronHtml);\n        inputAddrContainer.find('#render_send_from').click(this.view.setHandler(() => this.renderSendFromIfMoreThanOneAlias(), this.view.errModule.handle(`render send-from`)));\n      }\n    } else {\n      await this.renderSendFromIfMoreThanOneAlias();\n    }\n  }\n\n  public checkEmailAliases = async () => {\n    try {\n      const refreshResult = await Settings.refreshSendAs(this.view.acctEmail);\n      if (refreshResult) {\n        if (refreshResult.aliasesChanged || refreshResult.defaultEmailChanged) {\n          await this.renderSendFromIfMoreThanOneAlias();\n        }\n        if (refreshResult.footerChanged && !this.view.draftModule.wasMsgLoadedFromDraft) {\n          const sendAsAlias = refreshResult.sendAs[this.getSender()];\n          if (sendAsAlias && !this.view.isReplyBox) {\n            this.view.footerModule.onFooterUpdated(sendAsAlias.footer || undefined);\n          }\n        }\n      }\n    } catch (e) {\n      if (ApiErr.isAuthErr(e)) {\n        BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n      }\n      ApiErr.reportIfSignificant(e);\n    }\n  }\n\n  private renderSendFromIfMoreThanOneAlias = async () => {\n    const { sendAs } = await AcctStore.get(this.view.acctEmail, ['sendAs']);\n    $('#render_send_from').remove(); // created in renderSendFromChevron, if any\n    const emailAliases = Object.keys(sendAs!);\n    const inputAddrContainer = $('.recipients-inputs');\n    inputAddrContainer.find('#input_from').remove();\n    if (emailAliases.length > 1) {\n      inputAddrContainer.addClass('show_send_from');\n      Xss.sanitizeAppend(inputAddrContainer, '<select id=\"input_from\" tabindex=\"1\" data-test=\"input-from\"></select>');\n      const fmtOpt = (addr: string) => `<option value=\"${Xss.escape(addr)}\" ${this.getSender() === addr ? 'selected' : ''}>${Xss.escape(addr)}</option>`;\n      emailAliases.sort((a, b) => (sendAs![a].isDefault === sendAs![b].isDefault) ? 0 : sendAs![a].isDefault ? -1 : 1);\n      Xss.sanitizeAppend(inputAddrContainer.find('#input_from'), emailAliases.map(fmtOpt).join('')).change(() => this.view.myPubkeyModule.reevaluateShouldAttachOrNot());\n      this.view.S.now('input_from').change(this.view.setHandler(() => this.actionInputFromChangeHanlder()));\n      if (this.view.isReplyBox) {\n        this.view.sizeModule.resizeComposeBox();\n      }\n    }\n  }\n\n  private actionInputFromChangeHanlder = async () => {\n    await this.view.recipientsModule.reEvaluateRecipients(this.view.recipientsModule.getRecipients());\n    await this.view.recipientsModule.setEmailsPreview(this.view.recipientsModule.getRecipients());\n    this.view.footerModule.onFooterUpdated(await this.view.footerModule.getFooterFromStorage(this.view.senderModule.getSender()));\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/compose-size-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\n\nexport class ComposeSizeModule extends ViewModule<ComposeView> {\n\n  public composeWindowIsMinimized = false;\n\n  private composeWindowIsMaximized = false;\n  private FULL_WINDOW_CLASS = 'full_window';\n  private lastReplyBoxTableHeight = 0;\n  private refBodyHeight?: number;\n\n  public setHandlers = () => {\n    $('body').click(event => {\n      if (this.composeWindowIsMaximized && $(event.target).is($('body'))) {\n        this.minimizeComposerWindow();\n      }\n    });\n    if (!this.view.isReplyBox) {\n      $('.minimize_new_message').click(this.view.setHandler(() => this.minimizeComposerWindow()));\n      $('.popout').click(this.view.setHandler(() => this.popoutClickHandler()));\n    }\n  }\n\n  public popoutClickHandler = async () => {\n    this.view.S.cached('body').hide(); // Need to hide because it seems laggy on some devices\n    await this.toggleFullScreen();\n    this.view.S.cached('body').show();\n  }\n\n  public onComposeTableRender = () => {\n    Catch.setHandledTimeout(() => { // delay automatic resizing until a second later\n      // we use veryslowspree for reply box because hand-resizing the main window will cause too many events\n      // we use spree (faster) for new messages because rendering of window buttons on top right depend on it, else visible lag shows\n      $(window).resize(this.view.setHandlerPrevent(this.view.isReplyBox ? 'veryslowspree' : 'spree', () => { this.windowResized().catch(Catch.reportErr); }));\n      this.view.inputModule.squire.addEventListener('keyup', () => this.view.setHandlerPrevent('slowspree', () => { this.windowResized().catch(Catch.reportErr); }));\n    }, 1000);\n  }\n\n  public resizeComposeBox = (addExtra: number = 0, cursorOffsetTop?: number) => {\n    if (this.view.isReplyBox) {\n      this.view.S.cached('input_text').css('max-width', (this.view.S.cached('body').width()! - 20) + 'px'); // body should always be present\n      let minHeight = 0;\n      let currentHeight = 0;\n      if (this.view.S.cached('compose_table').is(':visible')) {\n        currentHeight = this.view.S.cached('compose_table').outerHeight() || 0;\n        minHeight = 260;\n      } else if (this.view.S.cached('reply_msg_successful').is(':visible')) {\n        currentHeight = this.view.S.cached('reply_msg_successful').outerHeight() || 0;\n      } else {\n        currentHeight = this.view.S.cached('prompt').outerHeight() || 0;\n      }\n      if (currentHeight !== this.lastReplyBoxTableHeight && Math.abs(currentHeight - this.lastReplyBoxTableHeight) > 2) { // more then two pixel difference compared to last time\n        this.lastReplyBoxTableHeight = currentHeight;\n        BrowserMsg.send.setCss(this.view.parentTabId, {\n          selector: `iframe#${this.view.frameId}`,\n          css: { height: `${(Math.max(minHeight, currentHeight) + addExtra)}px` }\n        });\n      }\n      if (cursorOffsetTop) {\n        BrowserMsg.send.scrollToCursorInReplyBox(this.view.parentTabId, { replyMsgId: `#${this.view.frameId}`, cursorOffsetTop });\n      }\n    } else {\n      this.view.S.cached('input_text').css('max-width', '');\n      this.resizeInput();\n      this.view.S.cached('input_text').css('max-width', $('.text_container').width()! - 8 + 'px');\n    }\n  }\n\n  /**\n   * On Firefox, we have to manage textbox height manually. Only applies to composing new messages\n   * (else ff will keep expanding body element beyond frame view)\n   * A decade old firefox bug is the culprit: https://bugzilla.mozilla.org/show_bug.cgi?id=202081\n   *\n   * @param updateRefBodyHeight - set to true to take a new snapshot of intended html body height\n   */\n  public setInputTextHeightManuallyIfNeeded = (updateRefBodyHeight: boolean = false) => {\n    if (!this.view.isReplyBox && Catch.browser().name === 'firefox') {\n      this.view.S.cached('input_text').css('height', '0');\n      let cellHeightExceptText = 0;\n      for (const cell of this.view.S.cached('all_cells_except_text')) {\n        cellHeightExceptText += $(cell).is(':visible') ? ($(cell).parent('tr').height() || 0) + 1 : 0; // add a 1px border height for each table row\n      }\n      if (updateRefBodyHeight || !this.refBodyHeight) {\n        this.refBodyHeight = this.view.S.cached('body').height() || 605;\n      }\n      const attachmentListHeight = this.view.S.cached('fineuploader').height() || 0;\n      const inputTextVerticalPadding = parseInt(this.view.S.cached('input_text').css('padding-top')) + parseInt(this.view.S.cached('input_text').css('padding-bottom'));\n      const iconShowPrevMsgHeight = this.view.S.cached('triple_dot').outerHeight(true) || 0;\n      this.view.S.cached('input_text').css('height', this.refBodyHeight - cellHeightExceptText - attachmentListHeight - inputTextVerticalPadding - iconShowPrevMsgHeight);\n    }\n  }\n\n  public resizeInput = (inputs?: JQuery<HTMLElement>) => {\n    if (!inputs) {\n      inputs = this.view.S.cached('recipients_inputs'); // Resize All Inputs\n    }\n    inputs.css('width', '100%'); // this indeed seems to effect the line below (noticeable when maximizing / back to default)\n    for (const inputElement of inputs) {\n      const jqueryElem = $(inputElement);\n      const containerWidth = Math.floor(jqueryElem.parent().innerWidth()!);\n      let additionalWidth = Math.ceil(Number(jqueryElem.css('padding-left').replace('px', '')) + Number(jqueryElem.css('padding-right').replace('px', '')));\n      const minInputWidth = 150;\n      let offset = 0;\n      if (jqueryElem.next().length) {\n        additionalWidth += Math.ceil(jqueryElem.next().outerWidth()!);\n      }\n      const lastRecipient = jqueryElem.siblings('.recipients').children().last();\n      if (lastRecipient.length && lastRecipient.position().left + lastRecipient.outerWidth()! + minInputWidth + additionalWidth < containerWidth) {\n        offset = Math.ceil(lastRecipient.position().left + lastRecipient.outerWidth()!);\n      }\n      jqueryElem.css('width', (containerWidth - offset - additionalWidth - 11) + 'px');\n    }\n  }\n\n  private windowResized = async () => {\n    this.resizeComposeBox();\n    this.setInputTextHeightManuallyIfNeeded(true);\n    if (this.view.S.cached('recipients_placeholder').is(':visible')) {\n      await this.view.recipientsModule.setEmailsPreview(this.view.recipientsModule.getRecipients());\n    }\n  }\n\n  private minimizeComposerWindow = () => {\n    if (this.composeWindowIsMaximized) {\n      this.addOrRemoveFullScreenStyles(this.composeWindowIsMinimized);\n    }\n    BrowserMsg.send.setCss(this.view.parentTabId, {\n      selector: `iframe#${this.view.frameId}, div#new_message`,\n      css: { height: this.composeWindowIsMinimized ? '' : this.view.S.cached('header').css('height') },\n    });\n    this.composeWindowIsMinimized = !this.composeWindowIsMinimized;\n  }\n\n  private toggleFullScreen = async () => {\n    if (this.composeWindowIsMinimized) {\n      this.minimizeComposerWindow();\n    }\n    this.addOrRemoveFullScreenStyles(!this.composeWindowIsMaximized);\n    if (!this.composeWindowIsMaximized) {\n      this.view.S.cached('icon_popout').attr('src', '/img/svgs/exit-full-screen.svg').attr('title', 'Exit full screen');\n    } else {\n      this.view.S.cached('icon_popout').attr('src', '/img/svgs/maximize.svg').attr('title', 'Full screen');\n    }\n    if (this.view.S.cached('recipients_placeholder').is(':visible')) {\n      await this.view.recipientsModule.setEmailsPreview(this.view.recipientsModule.getRecipients());\n    }\n    this.composeWindowIsMaximized = !this.composeWindowIsMaximized;\n  }\n\n  private addOrRemoveFullScreenStyles = (add: boolean) => {\n    if (add) {\n      this.view.S.cached('body').addClass(this.FULL_WINDOW_CLASS);\n      BrowserMsg.send.addClass(this.view.parentTabId, { class: this.FULL_WINDOW_CLASS, selector: 'div#new_message' });\n    } else {\n      this.view.S.cached('body').removeClass(this.FULL_WINDOW_CLASS);\n      BrowserMsg.send.removeClass(this.view.parentTabId, { class: this.FULL_WINDOW_CLASS, selector: 'div#new_message' });\n    }\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/compose-storage-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Bm, BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Contact, KeyInfo, KeyUtil, Key } from '../../../js/common/core/crypto/key.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Assert } from '../../../js/common/assert.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { CollectPubkeysResult } from './compose-types.js';\nimport { PUBKEY_LOOKUP_RESULT_FAIL } from './compose-err-module.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { ComposeView } from '../compose.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\nimport { AcctStore } from '../../../js/common/platform/store/acct-store.js';\nimport { ContactStore, ContactUpdate } from '../../../js/common/platform/store/contact-store.js';\nimport { PassphraseStore } from '../../../js/common/platform/store/passphrase-store.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\n\nexport class ComposeStorageModule extends ViewModule<ComposeView> {\n\n  private passphraseInterval: number | undefined;\n  private ksLookupsByEmail: { [key: string]: Key } = {};\n\n  public setHandlers = () => {\n    BrowserMsg.addListener('passphrase_entry', async ({ entered }: Bm.PassphraseEntry) => {\n      if (!entered) {\n        clearInterval(this.passphraseInterval);\n        this.view.sendBtnModule.resetSendBtn();\n      }\n    });\n  }\n\n  public getKey = async (senderEmail: string): Promise<KeyInfo> => {\n    const keys = await KeyStore.get(this.view.acctEmail);\n    let result = await this.view.myPubkeyModule.chooseMyPublicKeyBySenderEmail(keys, senderEmail);\n    if (!result) {\n      this.view.errModule.debug(`ComposerStorage.getKey: could not find key based on senderEmail: ${senderEmail}, using primary instead`);\n      result = keys[0];\n      Assert.abortAndRenderErrorIfKeyinfoEmpty(result);\n    } else {\n      this.view.errModule.debug(`ComposerStorage.getKey: found key based on senderEmail: ${senderEmail}`);\n    }\n    this.view.errModule.debug(`ComposerStorage.getKey: returning key longid: ${result!.longid}`);\n    return result!;\n  }\n\n  // TODO: remove in #3329\n  public draftMetaDelete = async (threadId: string) => {\n    const draftStorage = await AcctStore.get(this.view.acctEmail, ['drafts_reply']);\n    const drafts = draftStorage.drafts_reply || {};\n    delete drafts[threadId];\n    await AcctStore.set(this.view.acctEmail, { drafts_reply: drafts });\n  }\n\n  public collectAllAvailablePublicKeys = async (senderEmail: string, senderKi: KeyInfo, recipients: string[]): Promise<CollectPubkeysResult> => {\n    const contacts = await ContactStore.get(undefined, recipients);\n    const armoredPubkeys = [{ pubkey: await KeyUtil.parse(senderKi.public), email: senderEmail, isMine: true }];\n    const emailsWithoutPubkeys = [];\n    for (const i of contacts.keys()) {\n      const contact = contacts[i];\n      if (contact && contact.hasPgp && contact.pubkey) {\n        armoredPubkeys.push({ pubkey: contact.pubkey, email: contact.email, isMine: false });\n      } else if (contact && this.ksLookupsByEmail[contact.email]) {\n        armoredPubkeys.push({ pubkey: this.ksLookupsByEmail[contact.email], email: contact.email, isMine: false });\n      } else {\n        emailsWithoutPubkeys.push(recipients[i]);\n      }\n    }\n    return { armoredPubkeys, emailsWithoutPubkeys };\n  }\n\n  public passphraseGet = async (senderKi?: KeyInfo) => {\n    if (!senderKi) {\n      senderKi = await KeyStore.getFirstRequired(this.view.acctEmail);\n    }\n    return await PassphraseStore.get(this.view.acctEmail, senderKi.fingerprints[0]);\n  }\n\n  public lookupPubkeyFromDbOrKeyserverAndUpdateDbIfneeded = async (email: string, name: string | undefined): Promise<Contact | \"fail\"> => {\n    const [storedContact] = await ContactStore.get(undefined, [email]);\n    if (storedContact && storedContact.hasPgp && storedContact.pubkey && !storedContact.revoked) {\n      // Potentially check if pubkey was updated - async. By the time user finishes composing, newer version would have been updated in db.\n      // If sender didn't pull a particular pubkey for a long time and it has since expired, but there actually is a newer version on attester, this may unnecessarily show \"bad pubkey\",\n      //      -> until next time user tries to pull it. This could be fixed by attempting to fix up the rendered recipient inside the async function below.\n      this.checkKeyserverForNewerVersionOfKnownPubkeyIfNeeded(storedContact).catch(Catch.reportErr);\n      return storedContact;\n    }\n    return await this.ksLookupUnknownContactPubAndSaveToDb(email, name, storedContact);\n  }\n\n  public ksLookupUnknownContactPubAndSaveToDb = async (email: string, name: string | undefined, existingContact: Contact | undefined): Promise<Contact | \"fail\"> => {\n    try {\n      const lookupResult = await this.view.pubLookup.lookupEmail(email);\n      if (lookupResult && email) {\n        const pubkeys: Key[] = [];\n        for (const pubkey of lookupResult.pubkeys) {\n          const key = await KeyUtil.parse(pubkey);\n          if (!key.usableForEncryption && !key.revoked && !KeyUtil.expired(key)) { // Not to skip expired and revoked keys\n            console.info('Dropping found+parsed key because getEncryptionKeyPacket===null', { for: email, fingerprint: key.id });\n            Ui.toast(`Public Key retrieved for email ${email} with id ${key.id} was ignored because it's not usable for encryption.`, 5);\n          } else {\n            pubkeys.push(key);\n          }\n        }\n        // save multiple pubkeys as separate operations\n        // todo: add a convenient method to storage?\n        const updates: ContactUpdate[] = [];\n        if (!pubkeys.length) {\n          if (name) {\n            // update just name\n            updates.push({ name } as ContactUpdate);\n          } else {\n            // No public key found. Returning early, nothing to update in local store below.\n            return existingContact ?? await ContactStore.obj({ email });\n          }\n        }\n        for (const pubkey of pubkeys) {\n          updates.push({ name, pubkey, pubkeyLastCheck: Date.now() });\n        }\n        if (updates.length) {\n          await Promise.all(updates.map(async (update) => await ContactStore.update(undefined, email, update)));\n        }\n        const [preferred] = await ContactStore.get(undefined, [email]);\n        return preferred ?? PUBKEY_LOOKUP_RESULT_FAIL;\n      } else {\n        return PUBKEY_LOOKUP_RESULT_FAIL;\n      }\n    } catch (e) {\n      if (!ApiErr.isNetErr(e) && !ApiErr.isServerErr(e)) {\n        Catch.reportErr(e);\n      }\n      return PUBKEY_LOOKUP_RESULT_FAIL;\n    }\n  }\n\n  public checkKeyserverForNewerVersionOfKnownPubkeyIfNeeded = async (contact: Contact) => {\n    try {\n      if (!contact.pubkey || !contact.fingerprint) {\n        return;\n      }\n      const lastCheckOverWeekAgoOrNever = !contact.pubkeyLastCheck || new Date(contact.pubkeyLastCheck).getTime() < Date.now() - (1000 * 60 * 60 * 24 * 7);\n      const isExpired = contact.expiresOn && contact.expiresOn < Date.now();\n      if (lastCheckOverWeekAgoOrNever || isExpired) {\n        const { pubkey: fetchedPubkeyArmored } = await this.view.pubLookup.lookupFingerprint(contact.fingerprint);\n        if (fetchedPubkeyArmored) {\n          const fetchedPubkey = await KeyUtil.parse(fetchedPubkeyArmored);\n          if (fetchedPubkey.lastModified && (!contact.pubkey.lastModified || fetchedPubkey.lastModified >= contact.pubkey.lastModified)) {\n            // the fetched pubkey has at least the same or newer signature\n            // the \"same or newer\" was due to a bug we encountered earlier where keys were badly recorded in db\n            // sometime in Oct 2020 we could turn the \">=\" back to \">\" above\n            await ContactStore.update(undefined, contact.email, { pubkey: fetchedPubkey, lastUse: Date.now(), pubkeyLastCheck: Date.now() });\n            const [updatedPubkey] = await ContactStore.get(undefined, [contact.email]);\n            if (!updatedPubkey) {\n              throw new Error(\"Cannot retrieve Contact right after updating it\");\n            }\n            await this.view.recipientsModule.reRenderRecipientFor(updatedPubkey);\n            return;\n          }\n        }\n      }\n      await ContactStore.update(undefined, contact.email, { pubkey: contact.pubkey, pubkeyLastCheck: Date.now() });\n      // we checked for newer key and it did not result in updating the key, don't check again for another week\n    } catch (e) {\n      ApiErr.reportIfSignificant(e);\n    }\n  }\n\n  public whenMasterPassphraseEntered = async (secondsTimeout?: number): Promise<string | undefined> => {\n    clearInterval(this.passphraseInterval);\n    const timeoutAt = secondsTimeout ? Date.now() + secondsTimeout * 1000 : undefined;\n    return await new Promise(resolve => {\n      this.passphraseInterval = Catch.setHandledInterval(async () => {\n        const passphrase = await this.passphraseGet();\n        if (typeof passphrase !== 'undefined') {\n          clearInterval(this.passphraseInterval);\n          resolve(passphrase);\n        } else if (timeoutAt && Date.now() > timeoutAt) {\n          clearInterval(this.passphraseInterval);\n          resolve(undefined);\n        }\n      }, 1000);\n    });\n  }\n\n  public refreshAccountAndSubscriptionIfLoggedIn = async () => {\n    const auth = await AcctStore.authInfo(this.view.acctEmail);\n    if (auth.uuid) {\n      try {\n        await this.view.acctServer.accountGetAndUpdateLocalStore(auth); // updates storage\n      } catch (e) {\n        if (ApiErr.isAuthErr(e)) {\n          Settings.offerToLoginWithPopupShowModalOnErr(\n            this.view.acctEmail,\n            () => this.refreshAccountAndSubscriptionIfLoggedIn().catch(ApiErr.reportIfSignificant), // retry this after re-auth\n            `Could not get account information from backend.\\n`\n          );\n          return;\n        }\n        throw e;\n      }\n    }\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/formatters/encrypted-mail-msg-formatter.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { BaseMailFormatter } from './base-mail-formatter.js';\nimport { ComposerResetBtnTrigger } from '../compose-err-module.js';\nimport { Mime, SendableMsgBody } from '../../../../js/common/core/mime.js';\nimport { NewMsgData } from '../compose-types.js';\nimport { Str, Url, Value } from '../../../../js/common/core/common.js';\nimport { ApiErr } from '../../../../js/common/api/shared/api-error.js';\nimport { Attachment } from '../../../../js/common/core/attachment.js';\nimport { Buf } from '../../../../js/common/core/buf.js';\nimport { Catch } from '../../../../js/common/platform/catch.js';\nimport { Lang } from '../../../../js/common/lang.js';\nimport { PubkeyResult, Key, KeyUtil } from '../../../../js/common/core/crypto/key.js';\nimport { MsgUtil, PgpMsgMethod } from '../../../../js/common/core/crypto/pgp/msg-util.js';\nimport { SendableMsg } from '../../../../js/common/api/email-provider/sendable-msg.js';\nimport { Settings } from '../../../../js/common/settings.js';\nimport { Ui } from '../../../../js/common/browser/ui.js';\nimport { Xss } from '../../../../js/common/platform/xss.js';\nimport { AcctStore } from '../../../../js/common/platform/store/acct-store.js';\nimport { FcUuidAuth } from '../../../../js/common/api/account-servers/flowcrypt-com-api.js';\nimport { SmimeKey } from '../../../../js/common/core/crypto/smime/smime-key.js';\n\nexport class EncryptedMsgMailFormatter extends BaseMailFormatter {\n\n  public sendableMsg = async (newMsg: NewMsgData, pubkeys: PubkeyResult[], signingPrv?: Key): Promise<SendableMsg> => {\n    if (newMsg.pwd && !this.isDraft) { // password-protected message, temporarily uploaded (encrypted) to FlowCrypt servers, to be served to recipient through web\n      const msgUrl = await this.prepareAndUploadPwdEncryptedMsg(newMsg); // encrypted for pwd only, pubkeys ignored\n      newMsg.pwd = undefined;\n      return await this.sendablePwdMsg(newMsg, pubkeys, msgUrl, signingPrv); // encrypted for pubkeys only, pwd ignored\n    } else if (this.richtext) { // rich text: PGP/MIME - https://tools.ietf.org/html/rfc3156#section-4\n      return await this.sendableRichTextMsg(newMsg, pubkeys, signingPrv);\n    } else { // simple text: PGP/Inline with attachments in separate files\n      return await this.sendableSimpleTextMsg(newMsg, pubkeys, signingPrv);\n    }\n  }\n\n  private prepareAndUploadPwdEncryptedMsg = async (newMsg: NewMsgData): Promise<string> => {\n    // PGP/MIME + included attachments (encrypted for password only)\n    const authInfo = await AcctStore.authInfo(this.acctEmail);\n    const msgBodyWithReplyToken = await this.getPwdMsgSendableBodyWithOnlineReplyMsgToken(authInfo, newMsg);\n    const pgpMimeWithAttachments = await Mime.encode(msgBodyWithReplyToken, { Subject: newMsg.subject }, await this.view.attachmentsModule.attachment.collectAttachments());\n    const { data: pwdEncryptedWithAttachments } = await this.encryptDataArmor(Buf.fromUtfStr(pgpMimeWithAttachments), newMsg.pwd, []); // encrypted only for pwd, not signed\n    const { url } = await this.view.acctServer.messageUpload(\n      authInfo.uuid ? authInfo : undefined,\n      pwdEncryptedWithAttachments,\n      (p) => this.view.sendBtnModule.renderUploadProgress(p, 'FIRST-HALF'), // still need to upload to Gmail later, this request represents first half of progress\n    );\n    return url;\n  }\n\n  private sendablePwdMsg = async (newMsg: NewMsgData, pubs: PubkeyResult[], msgUrl: string, signingPrv?: Key) => {\n    // encoded as: PGP/MIME-like structure but with attachments as external files due to email size limit (encrypted for pubkeys only)\n    const msgBody = this.richtext ? { 'text/plain': newMsg.plaintext, 'text/html': newMsg.plainhtml } : { 'text/plain': newMsg.plaintext };\n    const pgpMimeNoAttachments = await Mime.encode(msgBody, { Subject: newMsg.subject }, []); // no attachments, attached to email separately\n    const { data: pubEncryptedNoAttachments } = await this.encryptDataArmor(Buf.fromUtfStr(pgpMimeNoAttachments), undefined, pubs, signingPrv); // encrypted only for pubs\n    const attachments = this.createPgpMimeAttachments(pubEncryptedNoAttachments).\n      concat(await this.view.attachmentsModule.attachment.collectEncryptAttachments(pubs)); // encrypted only for pubs\n    const emailIntroAndLinkBody = await this.formatPwdEncryptedMsgBodyLink(msgUrl);\n    return await SendableMsg.createPwdMsg(this.acctEmail, this.headers(newMsg), emailIntroAndLinkBody, attachments, { isDraft: this.isDraft });\n  }\n\n  private sendableSimpleTextMsg = async (newMsg: NewMsgData, pubs: PubkeyResult[], signingPrv?: Key): Promise<SendableMsg> => {\n    // todo - choosePubsBasedOnKeyTypeCombinationForPartialSmimeSupport is called later inside encryptDataArmor, could be refactored\n    const pubsForEncryption = KeyUtil.choosePubsBasedOnKeyTypeCombinationForPartialSmimeSupport(pubs);\n    const x509certs = pubsForEncryption.filter(pub => pub.type === 'x509');\n    if (x509certs.length) { // s/mime\n      const attachments: Attachment[] = this.isDraft ? [] : await this.view.attachmentsModule.attachment.collectAttachments(); // collects attachments\n      const msgBody = this.richtext ? { 'text/plain': newMsg.plaintext, 'text/html': newMsg.plainhtml } : { 'text/plain': newMsg.plaintext };\n      const mimeEncodedPlainMessage = await Mime.encode(msgBody, { Subject: newMsg.subject }, attachments);\n      const encryptedMessage = await SmimeKey.encryptMessage({ pubkeys: x509certs, data: Buf.fromUtfStr(mimeEncodedPlainMessage) });\n      const data = encryptedMessage.data;\n      return await SendableMsg.createSMime(this.acctEmail, this.headers(newMsg), data, { isDraft: this.isDraft });\n    } else { // openpgp\n      const attachments: Attachment[] = this.isDraft ? [] : await this.view.attachmentsModule.attachment.collectEncryptAttachments(pubs);\n      const encrypted = await this.encryptDataArmor(Buf.fromUtfStr(newMsg.plaintext), undefined, pubs, signingPrv);\n      return await SendableMsg.createPgpInline(this.acctEmail, this.headers(newMsg), Buf.fromUint8(encrypted.data).toUtfStr(), attachments, { isDraft: this.isDraft });\n    }\n  }\n\n  private sendableRichTextMsg = async (newMsg: NewMsgData, pubs: PubkeyResult[], signingPrv?: Key) => {\n    const plainAttachments = this.isDraft ? [] : await this.view.attachmentsModule.attachment.collectAttachments();\n    if (this.isDraft) { // this patch is needed as gmail makes it hard (or impossible) to render messages saved as https://tools.ietf.org/html/rfc3156\n      const pgpMimeToEncrypt = await Mime.encode({ 'text/plain': newMsg.plaintext, 'text/html': newMsg.plainhtml }, { Subject: newMsg.subject }, plainAttachments);\n      const { data: encrypted } = await this.encryptDataArmor(Buf.fromUtfStr(pgpMimeToEncrypt), undefined, pubs, signingPrv);\n      return await SendableMsg.createPgpInline(this.acctEmail, this.headers(newMsg), Buf.fromUint8(encrypted).toUtfStr(), plainAttachments, { isDraft: this.isDraft });\n    }\n    const pgpMimeToEncrypt = await Mime.encode({ 'text/plain': newMsg.plaintext, 'text/html': newMsg.plainhtml }, { Subject: newMsg.subject }, plainAttachments);\n    const { data: encrypted } = await this.encryptDataArmor(Buf.fromUtfStr(pgpMimeToEncrypt), undefined, pubs, signingPrv);\n    const attachments = this.createPgpMimeAttachments(encrypted);\n    return await SendableMsg.createPgpMime(this.acctEmail, this.headers(newMsg), attachments, { isDraft: this.isDraft });\n  }\n\n  private createPgpMimeAttachments = (data: Uint8Array) => {\n    const attachments: Attachment[] = [];\n    attachments.push(new Attachment({ data: Buf.fromUtfStr('Version: 1'), type: 'application/pgp-encrypted', contentDescription: 'PGP/MIME version identification' }));\n    attachments.push(new Attachment({ data, type: 'application/octet-stream', contentDescription: 'OpenPGP encrypted message', name: 'encrypted.asc', inline: true }));\n    return attachments;\n  }\n\n  private encryptDataArmor = async (data: Buf, pwd: string | undefined, pubs: PubkeyResult[], signingPrv?: Key): Promise<PgpMsgMethod.EncryptAnyArmorResult> => {\n    const pgpPubs = pubs.filter(pub => pub.pubkey.type === 'openpgp');\n    const encryptAsOfDate = await this.encryptMsgAsOfDateIfSomeAreExpiredAndUserConfirmedModal(pgpPubs);\n    const pubsForEncryption = KeyUtil.choosePubsBasedOnKeyTypeCombinationForPartialSmimeSupport(pubs);\n    return await MsgUtil.encryptMessage({ pubkeys: pubsForEncryption, signingPrv, pwd, data, armor: true, date: encryptAsOfDate }) as PgpMsgMethod.EncryptAnyArmorResult;\n  }\n\n  private getPwdMsgSendableBodyWithOnlineReplyMsgToken = async (authInfo: FcUuidAuth, newMsgData: NewMsgData): Promise<SendableMsgBody> => {\n    if (!authInfo.uuid) {\n      return { 'text/plain': newMsgData.plaintext, 'text/html': newMsgData.plainhtml };\n    }\n    const recipients = Array.prototype.concat.apply([], Object.values(newMsgData.recipients));\n    try {\n      const response = await this.view.acctServer.messageToken(authInfo);\n      const infoDiv = Ui.e('div', {\n        'style': 'display: none;',\n        'class': 'cryptup_reply',\n        'cryptup-data': Str.htmlAttrEncode({\n          sender: newMsgData.from,\n          recipient: Value.arr.withoutVal(Value.arr.withoutVal(recipients, newMsgData.from), this.acctEmail),\n          subject: newMsgData.subject,\n          token: response.token,\n        })\n      });\n      return { 'text/plain': newMsgData.plaintext + '\\n\\n' + infoDiv, 'text/html': newMsgData.plainhtml + '<br /><br />' + infoDiv };\n    } catch (msgTokenErr) {\n      if (ApiErr.isAuthErr(msgTokenErr)) {\n        Settings.offerToLoginWithPopupShowModalOnErr(this.acctEmail);\n        throw new ComposerResetBtnTrigger();\n      } else if (ApiErr.isNetErr(msgTokenErr)) {\n        throw msgTokenErr;\n      }\n      throw Catch.rewrapErr(msgTokenErr, 'There was a token error sending this message. Please try again. Let us know at human@flowcrypt.com if this happens repeatedly.');\n    }\n  }\n\n  private encryptMsgAsOfDateIfSomeAreExpiredAndUserConfirmedModal = async (pubs: PubkeyResult[]): Promise<Date | undefined> => {\n    if (!pubs.length) {\n      return undefined;\n    }\n    const usableUntil: number[] = [];\n    const usableFrom: number[] = [];\n    for (const armoredPubkey of pubs) {\n      const oneSecondBeforeExpiration = KeyUtil.dateBeforeExpirationIfAlreadyExpired(armoredPubkey.pubkey);\n      usableFrom.push(armoredPubkey.pubkey.created);\n      if (typeof oneSecondBeforeExpiration !== 'undefined') { // key is expired\n        usableUntil.push(oneSecondBeforeExpiration.getTime());\n      }\n    }\n    if (!usableUntil.length) { // none of the keys are expired\n      return undefined;\n    }\n    if (Math.max(...usableUntil) > Date.now()) { // all keys either don't expire or expire in the future\n      return undefined;\n    }\n    for (const myKey of pubs.filter(ap => ap.isMine)) {\n      if (myKey.pubkey.usableForEncryptionButExpired) {\n        const path = Url.create(chrome.runtime.getURL('chrome/settings/index.htm'), {\n          acctEmail: myKey.email,\n          page: '/chrome/settings/modules/my_key_update.htm',\n          pageUrlParams: JSON.stringify({ fingerprint: myKey.pubkey.id }),\n        });\n        const errModalLines = [\n          'This message could not be encrypted because your own Private Key is expired.',\n          '',\n          'You can extend expiration of this key in other OpenPGP software (such as gnupg), then re-import updated key ' +\n          `<a href=\"${path}\" id=\"action_update_prv\" target=\"_blank\">here</a>.`\n        ];\n        await Ui.modal.error(errModalLines.join('\\n'), true);\n        throw new ComposerResetBtnTrigger();\n      }\n    }\n    const usableTimeFrom = Math.max(...usableFrom);\n    const usableTimeUntil = Math.min(...usableUntil);\n    if (usableTimeFrom > usableTimeUntil) { // used public keys have no intersection of usable dates\n      await Ui.modal.error('The public key of one of your recipients has been expired for too long.\\n\\nPlease ask the recipient to send you an updated Public Key.');\n      throw new ComposerResetBtnTrigger();\n    }\n    if (! await Ui.modal.confirm(Lang.compose.pubkeyExpiredConfirmCompose)) {\n      throw new ComposerResetBtnTrigger();\n    }\n    return new Date(usableTimeUntil); // latest date none of the keys were expired\n  }\n\n  private formatPwdEncryptedMsgBodyLink = async (msgUrl: string): Promise<SendableMsgBody> => {\n    const storage = await AcctStore.get(this.acctEmail, ['outgoing_language']);\n    const lang = storage.outgoing_language || 'EN';\n    const aStyle = `padding: 2px 6px; background: #2199e8; color: #fff; display: inline-block; text-decoration: none;`;\n    const a = `<a href=\"${Xss.escape(msgUrl)}\" style=\"${aStyle}\">${Lang.compose.openMsg[lang]}</a>`;\n    const intro = this.view.S.cached('input_intro').length ? this.view.inputModule.extract('text', 'input_intro') : undefined;\n    const text = [];\n    const html = [];\n    if (intro) {\n      text.push(intro + '\\n');\n      html.push(Xss.escape(intro).replace(/\\n/g, '<br>') + '<br><br>');\n    }\n    text.push(Lang.compose.msgEncryptedText[lang] + msgUrl + '\\n\\n');\n    html.push(`${Lang.compose.msgEncryptedHtml[lang] + a}<br/><br/>${Lang.compose.alternativelyCopyPaste[lang] + Xss.escape(msgUrl)}<br/><br/>`);\n    return { 'text/plain': text.join('\\n'), 'text/html': html.join('\\n') };\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/formatters/general-mail-formatter.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { EncryptedMsgMailFormatter } from './encrypted-mail-msg-formatter.js';\nimport { KeyInfo, Key } from \"../../../../js/common/core/crypto/key.js\";\nimport { NewMsgData } from \"../compose-types.js\";\nimport { PlainMsgMailFormatter } from './plain-mail-msg-formatter.js';\nimport { SendableMsg } from '../../../../js/common/api/email-provider/sendable-msg.js';\nimport { SignedMsgMailFormatter } from './signed-msg-mail-formatter.js';\nimport { ComposeView } from '../../compose.js';\n\nexport class GeneralMailFormatter {\n\n  public static processNewMsg = async (view: ComposeView, newMsgData: NewMsgData, senderKi: KeyInfo, signingPrv?: Key): Promise<SendableMsg> => {\n    const choices = view.sendBtnModule.popover.choices;\n    const recipientsEmails = Array.prototype.concat.apply([], Object.values(newMsgData.recipients).filter(arr => !!arr)) as string[];\n    if (!choices.encrypt && !choices.sign) { // plain\n      return await new PlainMsgMailFormatter(view).sendableMsg(newMsgData);\n    }\n    if (!choices.encrypt && choices.sign) { // sign only\n      view.S.now('send_btn_text').text('Signing...');\n      return await new SignedMsgMailFormatter(view).sendableMsg(newMsgData, signingPrv!);\n    }\n    // encrypt (optionally sign)\n    const { armoredPubkeys, emailsWithoutPubkeys } = await view.storageModule.collectAllAvailablePublicKeys(newMsgData.from, senderKi, recipientsEmails);\n    if (emailsWithoutPubkeys.length) {\n      await view.errModule.throwIfEncryptionPasswordInvalid(senderKi, newMsgData);\n    }\n    view.S.now('send_btn_text').text('Encrypting...');\n    return await new EncryptedMsgMailFormatter(view).sendableMsg(newMsgData, armoredPubkeys, signingPrv);\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/formatters/plain-mail-msg-formatter.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { BaseMailFormatter } from './base-mail-formatter.js';\nimport { NewMsgData, SendBtnTexts } from '../compose-types.js';\nimport { SendableMsg } from '../../../../js/common/api/email-provider/sendable-msg.js';\nimport { SendableMsgBody } from '../../../../js/common/core/mime.js';\n\nexport class PlainMsgMailFormatter extends BaseMailFormatter {\n\n  public sendableMsg = async (newMsg: NewMsgData): Promise<SendableMsg> => {\n    this.view.S.now('send_btn_text').text(SendBtnTexts.BTN_SENDING);\n    const attachments = this.isDraft ? [] : await this.view.attachmentsModule.attachment.collectAttachments();\n    const body: SendableMsgBody = { 'text/plain': newMsg.plaintext };\n    if (this.richtext) {\n      body['text/html'] = newMsg.plainhtml;\n    }\n    return await SendableMsg.createPlain(this.acctEmail, this.headers(newMsg), body, attachments);\n  }\n\n}\n",
    "extension/chrome/elements/compose-modules/formatters/signed-msg-mail-formatter.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { BaseMailFormatter } from './base-mail-formatter.js';\nimport { BrowserWindow } from '../../../../js/common/browser/browser-window.js';\nimport { Catch } from '../../../../js/common/platform/catch.js';\nimport { NewMsgData } from '../compose-types.js';\nimport { Key } from '../../../../js/common/core/crypto/key.js';\nimport { MsgUtil } from '../../../../js/common/core/crypto/pgp/msg-util.js';\nimport { SendableMsg } from '../../../../js/common/api/email-provider/sendable-msg.js';\nimport { SendableMsgBody } from '../../../../js/common/core/mime.js';\nimport { ContactStore } from '../../../../js/common/platform/store/contact-store.js';\n\nexport class SignedMsgMailFormatter extends BaseMailFormatter {\n\n  public sendableMsg = async (newMsg: NewMsgData, signingPrv: Key): Promise<SendableMsg> => {\n    this.view.errModule.debug(`SignedMsgMailFormatter.sendableMsg signing with key: ${signingPrv.id}`);\n    const attachments = this.isDraft ? [] : await this.view.attachmentsModule.attachment.collectAttachments();\n    if (!this.richtext) {\n      // Folding the lines or GMAIL WILL RAPE THE TEXT, regardless of what encoding is used\n      // https://mathiasbynens.be/notes/gmail-plain-text applies to API as well\n      // resulting in.. wait for it.. signatures that don't match\n      // if you are reading this and have ideas about better solutions which:\n      //  - don't involve text/html ( Enigmail refuses to fix: https://sourceforge.net/p/enigmail/bugs/218/ - Patrick Brunschwig - 2017-02-12 )\n      //  - don't require text to be sent as an attachment\n      //  - don't require all other clients to support PGP/MIME\n      // then please const me know. Eagerly waiting! In the meanwhile..\n      newMsg.plaintext = (window as unknown as BrowserWindow)['emailjs-mime-codec'].foldLines(newMsg.plaintext, 76, true); // tslint:disable-line:no-unsafe-any\n      // Gmail will also remove trailing spaces on the end of each line in transit, causing signatures that don't match\n      // Removing them here will prevent Gmail from screwing up the signature\n      newMsg.plaintext = newMsg.plaintext.split('\\n').map(l => l.replace(/\\s+$/g, '')).join('\\n').trim();\n      const signedData = await MsgUtil.sign(signingPrv, newMsg.plaintext);\n      const allContacts = [...newMsg.recipients.to || [], ...newMsg.recipients.cc || [], ...newMsg.recipients.bcc || []];\n      ContactStore.update(undefined, allContacts, { lastUse: Date.now() }).catch(Catch.reportErr);\n      return await SendableMsg.createPgpInline(this.acctEmail, this.headers(newMsg), signedData, attachments);\n    }\n    // pgp/mime detached signature - it must be signed later, while being mime-encoded\n    // prepare a sign function first, which will be used by Mime.encodePgpMimeSigned later\n    const body: SendableMsgBody = { 'text/plain': newMsg.plaintext, 'text/html': newMsg.plainhtml };\n    const signMethod = (signable: string) => MsgUtil.sign(signingPrv, signable, true);\n    return await SendableMsg.createPgpMimeSigned(this.acctEmail, this.headers(newMsg), body, attachments, signMethod);\n  }\n\n}\n",
    "extension/chrome/elements/compose.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { EmailProviderInterface, ReplyParams } from '../../js/common/api/email-provider/email-provider-api.js';\nimport { ApiErr } from '../../js/common/api/shared/api-error.js';\nimport { Assert } from '../../js/common/assert.js';\nimport { BrowserMsg } from '../../js/common/browser/browser-msg.js';\nimport { Gmail } from '../../js/common/api/email-provider/gmail/gmail.js';\nimport { Ui } from '../../js/common/browser/ui.js';\nimport { Url } from '../../js/common/core/common.js';\nimport { View } from '../../js/common/view.js';\nimport { XssSafeFactory } from '../../js/common/xss-safe-factory.js';\nimport { opgp } from '../../js/common/core/crypto/pgp/openpgpjs-custom.js';\nimport { ComposeAttachmentsModule } from './compose-modules/compose-attachments-module.js';\nimport { ComposeDraftModule } from './compose-modules/compose-draft-module.js';\nimport { ComposeErrModule } from './compose-modules/compose-err-module.js';\nimport { ComposeFooterModule } from './compose-modules/compose-footer-module.js';\nimport { ComposeInputModule } from './compose-modules/compose-input-module.js';\nimport { ComposeMyPubkeyModule } from './compose-modules/compose-my-pubkey-module.js';\nimport { ComposePwdOrPubkeyContainerModule } from './compose-modules/compose-pwd-or-pubkey-container-module.js';\nimport { ComposeQuoteModule } from './compose-modules/compose-quote-module.js';\nimport { ComposeRecipientsModule } from './compose-modules/compose-recipients-module.js';\nimport { ComposeRenderModule } from './compose-modules/compose-render-module.js';\nimport { ComposeSendBtnModule } from './compose-modules/compose-send-btn-module.js';\nimport { ComposeSenderModule } from './compose-modules/compose-sender-module.js';\nimport { ComposeSizeModule } from './compose-modules/compose-size-module.js';\nimport { ComposeStorageModule } from './compose-modules/compose-storage-module.js';\nimport { Catch } from '../../js/common/platform/catch.js';\nimport { OrgRules } from '../../js/common/org-rules.js';\nimport { PubLookup } from '../../js/common/api/pub-lookup.js';\nimport { Scopes, AcctStore } from '../../js/common/platform/store/acct-store.js';\nimport { AccountServer } from '../../js/common/api/account-server.js';\n\nexport class ComposeView extends View {\n\n  public readonly acctEmail: string;\n  public readonly parentTabId: string;\n  public readonly frameId: string;\n  public readonly ignoreDraft: boolean;\n  public readonly removeAfterClose: boolean;\n  public readonly disableDraftSaving: boolean;\n  public readonly debug: boolean;\n  public readonly isReplyBox: boolean;\n  public readonly replyMsgId: string;\n  public readonly replyPubkeyMismatch: boolean;\n  public skipClickPrompt: boolean;\n  public draftId: string;\n  public threadId: string = '';\n\n  public scopes!: Scopes;\n  public tabId!: string;\n  public factory!: XssSafeFactory;\n  public replyParams: ReplyParams | undefined;\n  public emailProvider: EmailProviderInterface;\n  public orgRules!: OrgRules;\n  public pubLookup!: PubLookup;\n  public acctServer: AccountServer;\n\n  public quoteModule!: ComposeQuoteModule;\n  public sendBtnModule!: ComposeSendBtnModule;\n  public draftModule!: ComposeDraftModule;\n  public recipientsModule!: ComposeRecipientsModule;\n  public pwdOrPubkeyContainerModule!: ComposePwdOrPubkeyContainerModule;\n  public sizeModule!: ComposeSizeModule;\n  public senderModule!: ComposeSenderModule;\n  public footerModule!: ComposeFooterModule;\n  public attachmentsModule!: ComposeAttachmentsModule;\n  public errModule!: ComposeErrModule;\n  public inputModule!: ComposeInputModule;\n  public renderModule!: ComposeRenderModule;\n  public myPubkeyModule!: ComposeMyPubkeyModule;\n  public storageModule!: ComposeStorageModule;\n\n  public S = Ui.buildJquerySels({\n    body: 'body',\n    compose_table: 'table#compose',\n    header: '#section_header',\n    subject: '#section_subject',\n    compose: '#section_compose',\n    footer: '#section_footer',\n    title: '#header_title',\n    input_text: 'div#input_text',\n    input_to: '#input_to',\n    input_from: '#input_from',\n    input_subject: '#input_subject',\n    input_password: '#input_password',\n    expiration_note: '#expiration_note',\n    input_intro: '.input_intro',\n    recipients_placeholder: '#recipients_placeholder',\n    all_cells_except_text: 'table#compose > tbody > tr > :not(.text)',\n    add_intro: '.action_add_intro',\n    add_their_pubkey: '.add_pubkey',\n    intro_container: '.intro_container',\n    password_or_pubkey: '#password_or_pubkey_container',\n    password_label: '.label_password',\n    warning_nopgp: '.warning_nopgp',\n    warning_revoked: '.warning_revoked',\n    send_btn_note: '#send_btn_note',\n    send_btn_i: '#send_btn i',\n    send_btn: '#send_btn',\n    send_btn_text: '#send_btn_text',\n    toggle_send_options: '#toggle_send_options',\n    icon_pubkey: '.icon.action_include_pubkey',\n    icon_help: '.action_feedback',\n    icon_popout: '.popout img',\n    triple_dot: '.action_show_prev_msg',\n    prompt: 'div#initial_prompt',\n    reply_msg_successful: '#reply_message_successful_container',\n    replied_body: '.replied_body',\n    replied_attachments: '#attachments',\n    fineuploader: '#fineuploader',\n    recipients: 'span.recipients',\n    contacts: '#contacts',\n    input_addresses_container_outer: '#input_addresses_container',\n    input_addresses_container_inner: '#input_addresses_container > div:first',\n    recipients_inputs: '#input_addresses_container input',\n    attached_files: 'table#compose #fineuploader .qq-upload-list li',\n    container_cc_bcc_buttons: '#input_addresses_container .container-cc-bcc-buttons',\n    cc: '#cc',\n    bcc: '#bcc',\n    sending_options_container: '#sending-options-container'\n  });\n\n  constructor() {\n    super();\n    Ui.event.protect();\n    const uncheckedUrlParams = Url.parse(['acctEmail', 'parentTabId', 'draftId', 'frameId',\n      'replyMsgId', 'skipClickPrompt', 'ignoreDraft', 'debug', 'removeAfterClose', 'replyPubkeyMismatch']);\n    this.acctEmail = Assert.urlParamRequire.string(uncheckedUrlParams, 'acctEmail');\n    this.parentTabId = Assert.urlParamRequire.string(uncheckedUrlParams, 'parentTabId');\n    this.frameId = Assert.urlParamRequire.string(uncheckedUrlParams, 'frameId');\n    this.skipClickPrompt = uncheckedUrlParams.skipClickPrompt === true;\n    this.ignoreDraft = uncheckedUrlParams.ignoreDraft === true;\n    this.removeAfterClose = uncheckedUrlParams.removeAfterClose === true;\n    this.disableDraftSaving = false;\n    this.debug = uncheckedUrlParams.debug === true;\n    this.replyPubkeyMismatch = uncheckedUrlParams.replyPubkeyMismatch === true;\n    this.draftId = Assert.urlParamRequire.optionalString(uncheckedUrlParams, 'draftId') || '';\n    this.replyMsgId = Assert.urlParamRequire.optionalString(uncheckedUrlParams, 'replyMsgId') || '';\n    this.isReplyBox = !!this.replyMsgId;\n    this.emailProvider = new Gmail(this.acctEmail);\n    this.acctServer = new AccountServer(this.acctEmail);\n  }\n\n  public render = async () => {\n    const storage = await AcctStore.get(this.acctEmail, ['sendAs', 'hide_message_password', 'drafts_reply']);\n    this.orgRules = await OrgRules.newInstance(this.acctEmail);\n    if (this.orgRules.shouldHideArmorMeta()) {\n      opgp.config.show_comment = false;\n      opgp.config.show_version = false;\n    }\n    opgp.initWorker({ path: '/lib/openpgp.worker.js' });\n    this.pubLookup = new PubLookup(this.orgRules);\n    this.tabId = await BrowserMsg.requiredTabId();\n    this.factory = new XssSafeFactory(this.acctEmail, this.tabId);\n    this.scopes = await AcctStore.getScopes(this.acctEmail);\n    this.draftModule = new ComposeDraftModule(this);\n    this.quoteModule = new ComposeQuoteModule(this);\n    this.recipientsModule = new ComposeRecipientsModule(this);\n    this.sendBtnModule = new ComposeSendBtnModule(this);\n    this.pwdOrPubkeyContainerModule = new ComposePwdOrPubkeyContainerModule(this, storage.hide_message_password);\n    this.sizeModule = new ComposeSizeModule(this);\n    this.senderModule = new ComposeSenderModule(this);\n    this.footerModule = new ComposeFooterModule(this);\n    this.attachmentsModule = new ComposeAttachmentsModule(this);\n    this.errModule = new ComposeErrModule(this);\n    this.inputModule = new ComposeInputModule(this);\n    this.renderModule = new ComposeRenderModule(this);\n    this.myPubkeyModule = new ComposeMyPubkeyModule(this);\n    this.storageModule = new ComposeStorageModule(this);\n    if (!this.isReplyBox) {\n      await Assert.abortAndRenderErrOnUnprotectedKey(this.acctEmail);\n    }\n    this.storageModule.refreshAccountAndSubscriptionIfLoggedIn().catch(ApiErr.reportIfSignificant);\n    if (this.replyMsgId) {\n      await this.renderModule.fetchReplyMeta(Object.keys(storage.sendAs!));\n    }\n    if (this.isReplyBox) { // reply, legacy, TODO: remove in #3329\n      if (this.threadId && !this.draftId && !this.ignoreDraft && storage.drafts_reply && storage.drafts_reply[this.threadId]) {\n        this.draftId = storage.drafts_reply[this.threadId]; // there may be a legacy draft we want to load\n      }\n    } else { // compose\n      if (!this.draftId) {\n        this.draftId = this.draftModule.localNewMessageDraftId;\n      }\n    }\n    BrowserMsg.listen(this.tabId!);\n    await this.renderModule.initComposeBox();\n    this.senderModule.checkEmailAliases().catch(Catch.reportErr);\n  }\n\n  public setHandlers = () => {\n    this.S.cached('icon_help').click(this.setHandler(async () => await this.renderModule.openSettingsWithDialog('help'), this.errModule.handle(`help dialog`)));\n    this.attachmentsModule.setHandlers();\n    this.inputModule.setHandlers();\n    this.myPubkeyModule.setHandlers();\n    this.pwdOrPubkeyContainerModule.setHandlers();\n    this.sizeModule.setHandlers();\n    this.storageModule.setHandlers();\n    this.recipientsModule.setHandlers();\n    this.sendBtnModule.setHandlers();\n    this.draftModule.setHandlers(); // must be the last one so that 'onRecipientAdded/draftSave' to works properly\n  }\n\n}\n\nView.run(ComposeView);\n",
    "extension/chrome/elements/pgp_block_modules/pgp-block-decrypt-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Buf } from '../../../js/common/core/buf.js';\nimport { DecryptErrTypes } from '../../../js/common/core/crypto/pgp/msg-util.js';\nimport { GmailResponseFormat } from '../../../js/common/api/email-provider/gmail/gmail.js';\nimport { Lang } from '../../../js/common/lang.js';\nimport { Mime } from '../../../js/common/core/mime.js';\nimport { PgpBlockView } from '../pgp_block.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\nimport { PassphraseStore } from '../../../js/common/platform/store/passphrase-store.js';\n\nexport class PgpBlockViewDecryptModule {\n\n  public canReadEmails: undefined | boolean;\n\n  private msgFetchedFromApi: false | GmailResponseFormat = false;\n  private isPwdMsgBasedOnMsgSnippet: boolean | undefined;\n\n  constructor(private view: PgpBlockView) {\n  }\n\n  public initialize = async (forcePullMsgFromApi = false) => {\n    try {\n      if (this.canReadEmails && this.view.signature === true && this.view.msgId) {\n        this.view.renderModule.renderText('Loading signed message...');\n        const { raw } = await this.view.gmail.msgGet(this.view.msgId, 'raw');\n        this.msgFetchedFromApi = 'raw';\n        const mimeMsg = Buf.fromBase64UrlStr(raw!); // used 'raw' above\n        const parsed = await Mime.decode(mimeMsg);\n        if (parsed && typeof parsed.rawSignedContent === 'string' && parsed.signature) {\n          this.view.signature = parsed.signature;\n          await this.decryptAndRender(Buf.fromUtfStr(parsed.rawSignedContent));\n        } else {\n          await this.view.errorModule.renderErr('Error: could not properly parse signed message', parsed.rawSignedContent || parsed.text || parsed.html || mimeMsg.toUtfStr());\n        }\n      } else if (this.view.encryptedMsgUrlParam && !forcePullMsgFromApi) { // ascii armored message supplied\n        this.view.renderModule.renderText(this.view.signature ? 'Verifying..' : 'Decrypting...');\n        await this.decryptAndRender(this.view.encryptedMsgUrlParam);\n      } else {  // need to fetch the inline signed + armored or encrypted +armored message block from gmail api\n        if (!this.view.msgId) {\n          Xss.sanitizeRender('#pgp_block', `Missing msgId to fetch message in pgp_block. If this happens repeatedly, please report the issue to human@flowcrypt.com`);\n          this.view.renderModule.resizePgpBlockFrame();\n        } else {\n          this.view.renderModule.renderText('Retrieving message...');\n          const format: GmailResponseFormat = (!this.msgFetchedFromApi) ? 'full' : 'raw';\n          const { armored, subject, isPwdMsg } = await this.view.gmail.extractArmoredBlock(this.view.msgId, format, (progress) => {\n            this.view.renderModule.renderText(`Retrieving message... ${progress}%`);\n          });\n          this.isPwdMsgBasedOnMsgSnippet = isPwdMsg;\n          this.view.renderModule.renderText('Decrypting...');\n          this.msgFetchedFromApi = format;\n          await this.decryptAndRender(Buf.fromUtfStr(armored), undefined, subject);\n        }\n      }\n    } catch (e) {\n      await this.view.errorModule.handleInitializeErr(e);\n    }\n  }\n\n  private decryptAndRender = async (encryptedData: Buf, optionalPwd?: string, plainSubject?: string) => {\n    if (typeof this.view.signature !== 'string') {\n      const kisWithPp = await KeyStore.getAllWithOptionalPassPhrase(this.view.acctEmail);\n      const result = await BrowserMsg.send.bg.await.pgpMsgDecrypt({ kisWithPp, encryptedData });\n      if (typeof result === 'undefined') {\n        await this.view.errorModule.renderErr(Lang.general.restartBrowserAndTryAgain, undefined);\n      } else if (result.success) {\n        if (result.signature?.contact && !result.signature.match && this.canReadEmails && this.msgFetchedFromApi !== 'raw' && !result.signature.isErrFatal) {\n          console.info(`re-fetching message ${this.view.msgId} from api because failed signature check: ${!this.msgFetchedFromApi ? 'full' : 'raw'}`);\n          await this.initialize(true);\n        } else {\n          await this.view.renderModule.decideDecryptedContentFormattingAndRender(result.content, Boolean(result.isEncrypted), result.signature,\n            async () => {\n              const decryptResult = await BrowserMsg.send.bg.await.pgpMsgDecrypt({ kisWithPp, encryptedData });\n              if (!decryptResult.success) {\n                return undefined;\n              } else {\n                return decryptResult.signature;\n              }\n            }, plainSubject);\n        }\n      } else if (result.error.type === DecryptErrTypes.format) {\n        if (this.canReadEmails && this.msgFetchedFromApi !== 'raw') {\n          console.info(`re-fetching message ${this.view.msgId} from api because looks like bad formatting: ${!this.msgFetchedFromApi ? 'full' : 'raw'}`);\n          await this.initialize(true);\n        } else {\n          await this.view.errorModule.renderErr(Lang.pgpBlock.badFormat + '\\n\\n' + result.error.message, encryptedData.toUtfStr());\n        }\n      } else if (result.longids.needPassphrase.length) {\n        const enterPp = `<a href=\"#\" class=\"enter_passphrase\" data-test=\"action-show-passphrase-dialog\">${Lang.pgpBlock.enterPassphrase}</a> ${Lang.pgpBlock.toOpenMsg}`;\n        await this.view.errorModule.renderErr(enterPp, undefined);\n        $('.enter_passphrase').click(this.view.setHandler(() => {\n          Ui.setTestState('waiting');\n          BrowserMsg.send.passphraseDialog(this.view.parentTabId, { type: 'message', longids: result.longids.needPassphrase });\n        }));\n        await PassphraseStore.waitUntilPassphraseChanged(this.view.acctEmail, result.longids.needPassphrase);\n        this.view.renderModule.renderText('Decrypting...');\n        await this.decryptAndRender(encryptedData, optionalPwd);\n      } else {\n        const primaryKi = await KeyStore.getFirstOptional(this.view.acctEmail);\n        if (!result.longids.chosen && !primaryKi) {\n          await this.view.errorModule.renderErr(Lang.pgpBlock.notProperlySetUp + this.view.errorModule.btnHtml('FlowCrypt settings', 'green settings'), undefined);\n        } else if (result.error.type === DecryptErrTypes.keyMismatch) {\n          await this.view.errorModule.handlePrivateKeyMismatch(kisWithPp.map(ki => ki.public), encryptedData, this.isPwdMsgBasedOnMsgSnippet === true);\n        } else if (result.error.type === DecryptErrTypes.wrongPwd || result.error.type === DecryptErrTypes.usePassword) {\n          await this.view.errorModule.renderErr(Lang.pgpBlock.pwdMsgAskSenderUsePubkey, undefined);\n        } else if (result.error.type === DecryptErrTypes.noMdc) {\n          await this.view.errorModule.renderErr(result.error.message, result.content!.toUtfStr()); // missing mdc - only render the result after user confirmation\n        } else if (result.error) {\n          await this.view.errorModule.renderErr(`${Lang.pgpBlock.cantOpen}\\n\\n<em>${result.error.type}: ${result.error.message}</em>`, encryptedData.toUtfStr());\n        } else { // should generally not happen\n          await this.view.errorModule.renderErr(Lang.pgpBlock.cantOpen + Lang.pgpBlock.writeMe + '\\n\\nDiagnostic info: \"' + JSON.stringify(result) + '\"', encryptedData.toUtfStr());\n        }\n      }\n    } else { // this.view.signature is string\n      // sometimes signatures come wrongly percent-encoded. Here we check for typical \"=3Dabcd\" at the end\n      const sigText = Buf.fromUtfStr(this.view.signature.replace('\\n=3D', '\\n='));\n      const signatureResult = await BrowserMsg.send.bg.await.pgpMsgVerifyDetached({ plaintext: encryptedData, sigText });\n      await this.view.renderModule.decideDecryptedContentFormattingAndRender(encryptedData, false, signatureResult,\n        async () => { return await BrowserMsg.send.bg.await.pgpMsgVerifyDetached({ plaintext: encryptedData, sigText }); });\n    }\n  }\n\n}\n",
    "extension/chrome/elements/pgp_block_modules/pgp-block-error-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Browser } from '../../../js/common/browser/browser.js';\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { FormatError } from '../../../js/common/core/crypto/pgp/msg-util.js';\nimport { Lang } from '../../../js/common/lang.js';\nimport { PgpBlockView } from '../pgp_block.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\n\nexport class PgpBlockViewErrorModule {\n\n  constructor(private view: PgpBlockView) {\n  }\n\n  public renderErr = async (errBoxContent: string, renderRawMsg: string | undefined) => {\n    this.view.renderModule.setFrameColor('red');\n    const showRawMsgPrompt = renderRawMsg ? '<a href=\"#\" class=\"action_show_raw_pgp_block\">show original message</a>' : '';\n    await this.view.renderModule.renderContent(`<div class=\"error\">${errBoxContent.replace(/\\n/g, '<br>')}</div>${showRawMsgPrompt}`, true);\n    $('.action_show_raw_pgp_block').click(this.view.setHandler(async () => { // this may contain content missing MDC\n      Xss.sanitizeAppend('#pgp_block', `<div class=\"raw_pgp_block\">${Xss.escape(renderRawMsg!)}</div>`); // therefore the .escape is crucial\n    }));\n    $('.button.settings_keyserver').click(this.view.setHandler(async () => await Browser.openSettingsPage('index.htm', this.view.acctEmail, '/chrome/settings/modules/keyserver.htm')));\n    $('.button.settings').click(this.view.setHandler(async () => await Browser.openSettingsPage('index.htm', this.view.acctEmail)));\n    $('.button.settings_add_key').click(this.view.setHandler(async () => await Browser.openSettingsPage('index.htm', this.view.acctEmail, '/chrome/settings/modules/add_key.htm')));\n    $('.button.reply_pubkey_mismatch').click(this.view.setHandler(() => BrowserMsg.send.replyPubkeyMismatch(this.view.parentTabId)));\n    Ui.setTestState('ready');\n  }\n\n  public handlePrivateKeyMismatch = async (armoredPubs: string[], message: Uint8Array, isPwdMsg: boolean) => { // todo - make it work for multiple stored keys\n    const msgDiagnosis = await BrowserMsg.send.bg.await.pgpMsgDiagnosePubkeys({ armoredPubs, message });\n    if (msgDiagnosis.found_match) {\n      await this.renderErr(Lang.pgpBlock.cantOpen + Lang.pgpBlock.encryptedCorrectlyFileBug, undefined);\n    } else if (isPwdMsg) {\n      await this.renderErr(Lang.pgpBlock.pwdMsgOnlyReadableOnWeb + this.btnHtml('ask sender to re-send', 'gray2 short reply_pubkey_mismatch'), undefined);\n    } else {\n      const startText = msgDiagnosis.receivers === 1 ? Lang.pgpBlock.cantOpen + Lang.pgpBlock.singleSender + Lang.pgpBlock.askResend : Lang.pgpBlock.yourKeyCantOpenImportIfHave;\n      await this.renderErr(startText + this.btnHtml('import missing key', 'gray2 settings_add_key') + '&nbsp; &nbsp;'\n        + this.btnHtml('ask sender to update', 'gray2 short reply_pubkey_mismatch') + '&nbsp; &nbsp;' + this.btnHtml('settings', 'gray2 settings_keyserver'), undefined);\n    }\n  }\n\n  public handleInitializeErr = async (e: any) => {\n    if (ApiErr.isNetErr(e)) {\n      await this.renderErr(`Could not load message due to network error. ${Ui.retryLink()}`, undefined);\n    } else if (ApiErr.isAuthErr(e)) {\n      BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n      await this.renderErr(`Could not load message due to missing auth. ${Ui.retryLink()}`, undefined);\n    } else if (e instanceof FormatError) {\n      await this.renderErr(Lang.pgpBlock.cantOpen + Lang.pgpBlock.badFormat + Lang.pgpBlock.dontKnowHowOpen, e.data);\n    } else if (ApiErr.isInPrivateMode(e)) {\n      await this.renderErr(`FlowCrypt does not work in a Firefox Private Window (or when Firefox Containers are used). Please try in a standard window.`, undefined);\n    } else {\n      Catch.reportErr(e);\n      await this.renderErr(Xss.escape(String(e)), this.view.encryptedMsgUrlParam ? this.view.encryptedMsgUrlParam.toUtfStr() : undefined);\n    }\n  }\n\n  public btnHtml = (text: string, addClasses: string) => {\n    return `<button class=\"button long ${addClasses}\" style=\"margin:30px 0;\" target=\"cryptup\">${text}</button>`;\n  }\n\n}\n",
    "extension/chrome/elements/pgp_block_modules/pgp-block-quote-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { PgpBlockView } from '../pgp_block.js';\nimport { Str } from '../../../js/common/core/common.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\n\nexport class PgpBlockViewQuoteModule {\n\n  constructor(private view: PgpBlockView) {\n  }\n\n  public separateQuotedContentAndRenderText = async (decryptedContent: string, isHtml: boolean) => {\n    if (isHtml) {\n      const message = $('<div>').html(Xss.htmlSanitizeKeepBasicTags(decryptedContent, 'IMG-TO-LINK')); // xss-sanitized\n      let htmlBlockQuoteExists: boolean = false;\n      const shouldBeQuoted: Array<Element> = [];\n      for (let i = message[0].children.length - 1; i >= 0; i--) {\n        if (['BLOCKQUOTE', 'BR', 'PRE'].includes(message[0].children[i].nodeName)) {\n          shouldBeQuoted.push(message[0].children[i]);\n          if (message[0].children[i].nodeName === 'BLOCKQUOTE') {\n            htmlBlockQuoteExists = true;\n            break;\n          }\n          continue;\n        } else {\n          break;\n        }\n      }\n      if (htmlBlockQuoteExists) {\n        let quotedHtml = '';\n        for (let i = shouldBeQuoted.length - 1; i >= 0; i--) {\n          message[0].removeChild(shouldBeQuoted[i]);\n          quotedHtml += shouldBeQuoted[i].outerHTML;\n        }\n        await this.view.renderModule.renderContent(message.html(), false);\n        this.appendCollapsedQuotedContentButton(quotedHtml, true);\n      } else {\n        await this.view.renderModule.renderContent(decryptedContent, false);\n      }\n    } else {\n      const lines = decryptedContent.trim().split(/\\r?\\n/);\n      const linesQuotedPart: string[] = [];\n      while (lines.length) {\n        const lastLine = lines.pop()!; // lines.length above ensures there is a line\n        if (lastLine[0] === '>' || !lastLine.length) { // look for lines starting with '>' or empty lines, from last line up (sometimes quoted content may have empty lines in it)\n          linesQuotedPart.unshift(lastLine);\n        } else { // found first non-quoted part from the bottom\n          if (lastLine.startsWith('On ') && lastLine.endsWith(' wrote:')) { // on the very top of quoted content, looks like qote header\n            linesQuotedPart.unshift(lastLine);\n          } else { // no quote header, just regular content from here onwards\n            lines.push(lastLine);\n          }\n          break;\n        }\n      }\n      if (linesQuotedPart.length && !lines.length) { // only got quoted part, no real text -> show everything as real text, without quoting\n        lines.push(...linesQuotedPart.splice(0, linesQuotedPart.length));\n      }\n      await this.view.renderModule.renderContent(Str.escapeTextAsRenderableHtml(lines.join('\\n')), false);\n      if (linesQuotedPart.length) {\n        this.appendCollapsedQuotedContentButton(linesQuotedPart.join('\\n'));\n      }\n    }\n  }\n\n  private appendCollapsedQuotedContentButton = (message: string, isHtml: boolean = false) => {\n    const pgpBlk = $(\"#pgp_block\");\n    pgpBlk.append('<div id=\"action_show_quoted_content\" data-test=\"action-show-quoted-content\" class=\"three_dots\"><img src=\"/img/svgs/three-dots.svg\" /></div>'); // xss-direct\n    const messageHtml = isHtml ? message : Str.escapeTextAsRenderableHtml(message);\n    pgpBlk.append(`<div class=\"quoted_content\">${Xss.htmlSanitizeKeepBasicTags(messageHtml, 'IMG-TO-LINK')}</div>`); // xss-sanitized\n    pgpBlk.find('#action_show_quoted_content').click(this.view.setHandler(() => {\n      $(\".quoted_content\").css('display', $(\".quoted_content\").css('display') === 'none' ? 'block' : 'none');\n      this.view.renderModule.resizePgpBlockFrame();\n    }));\n  }\n\n}\n",
    "extension/chrome/elements/pgp_block_modules/pgp-block-render-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { VerifyRes } from '../../../js/common/core/crypto/pgp/msg-util.js';\nimport { Attachment } from '../../../js/common/core/attachment.js';\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Buf } from '../../../js/common/core/buf.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { Mime } from '../../../js/common/core/mime.js';\nimport { MsgBlock } from '../../../js/common/core/msg-block.js';\nimport { PgpBlockView } from '../pgp_block.js';\nimport { Str } from '../../../js/common/core/common.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { MsgBlockParser } from '../../../js/common/core/msg-block-parser.js';\nimport { AcctStore } from '../../../js/common/platform/store/acct-store.js';\n\nexport class PgpBlockViewRenderModule {\n  public doNotSetStateAsReadyYet = false;\n\n  private heightHist: number[] = [];\n\n  constructor(private view: PgpBlockView) {\n  }\n\n  public renderText = (text: string) => {\n    document.getElementById('pgp_block')!.innerText = text;\n  }\n\n  public resizePgpBlockFrame = () => {\n    const origHeight = $('#pgp_block').height();\n    if (!origHeight) { // https://github.com/FlowCrypt/flowcrypt-browser/issues/3519\n      // unsure why this happens. Sometimes height will come in as exactly 0 after the iframe was already properly sized\n      // that then causes to default to 20 + 40 = 60px for height, hiding contents of the message if it in fact is taller\n      return;\n    }\n    let height = Math.max(origHeight, 20) + 40;\n    this.heightHist.push(height);\n    const len = this.heightHist.length;\n    if (len >= 4 && this.heightHist[len - 1] === this.heightHist[len - 3] && this.heightHist[len - 2] === this.heightHist[len - 4] && this.heightHist[len - 1] !== this.heightHist[len - 2]) {\n      console.info('pgp_block.js: repetitive resize loop prevented'); // got repetitive, eg [70, 80, 200, 250, 200, 250]\n      height = Math.max(this.heightHist[len - 1], this.heightHist[len - 2]); // pick the larger number to stop if from oscillating\n    }\n    BrowserMsg.send.setCss(this.view.parentTabId, { selector: `iframe#${this.view.frameId}`, css: { height: `${height}px` } });\n  }\n\n  public renderContent = async (htmlContent: string, isErr: boolean) => {\n    if (!isErr && !this.view.isOutgoing) { // successfully opened incoming message\n      await AcctStore.set(this.view.acctEmail, { successfully_received_at_leat_one_message: true });\n    }\n    if (!isErr) { // rendering message content\n      const pgpBlock = $('#pgp_block').html(Xss.htmlSanitizeKeepBasicTags(htmlContent, 'IMG-TO-LINK')); // xss-sanitized\n      pgpBlock.find('a.image_src_link').one('click', this.view.setHandler((el, ev) => this.displayImageSrcLinkAsImg(el as HTMLAnchorElement, ev as JQuery.Event<HTMLAnchorElement, null>)));\n    } else { // rendering our own ui\n      Xss.sanitizeRender('#pgp_block', htmlContent);\n    }\n    if (isErr) {\n      $('.action_show_raw_pgp_block').click(this.view.setHandler(target => {\n        $('.raw_pgp_block').css('display', 'block');\n        $(target).css('display', 'none');\n        this.resizePgpBlockFrame();\n      }));\n    }\n    this.resizePgpBlockFrame(); // resize window now\n    Catch.setHandledTimeout(() => { $(window).resize(this.view.setHandlerPrevent('spree', () => this.resizePgpBlockFrame())); }, 1000); // start auto-resizing the window after 1s\n  }\n\n  public setFrameColor = (color: 'red' | 'green' | 'gray') => {\n    if (color === 'red') {\n      $('#pgp_background').removeClass('pgp_secure').removeClass('pgp_neutral').addClass('pgp_insecure');\n    } else if (color === 'green') {\n      $('#pgp_background').removeClass('pgp_neutral').removeClass('pgp_insecure').addClass('pgp_secure');\n    } else {\n      $('#pgp_background').removeClass('pgp_secure').removeClass('pgp_insecure').addClass('pgp_neutral');\n    }\n  }\n\n  public decideDecryptedContentFormattingAndRender = async (decryptedBytes: Buf, isEncrypted: boolean, sigResult: VerifyRes | undefined,\n    retryVerification: () => Promise<VerifyRes | undefined>, plainSubject?: string) => {\n    this.setFrameColor(isEncrypted ? 'green' : 'gray');\n    this.view.signatureModule.renderPgpSignatureCheckResult(sigResult, retryVerification);\n    const publicKeys: string[] = [];\n    let renderableAttachments: Attachment[] = [];\n    let decryptedContent = decryptedBytes.toUtfStr();\n    let isHtml: boolean = false;\n    // todo - replace with MsgBlockParser.fmtDecryptedAsSanitizedHtmlBlocks, then the extract/strip methods could be private?\n    if (!Mime.resemblesMsg(decryptedBytes)) {\n      const fcAttachmentBlocks: MsgBlock[] = [];\n      decryptedContent = MsgBlockParser.extractFcAttachments(decryptedContent, fcAttachmentBlocks);\n      decryptedContent = MsgBlockParser.stripFcTeplyToken(decryptedContent);\n      decryptedContent = MsgBlockParser.stripPublicKeys(decryptedContent, publicKeys);\n      if (fcAttachmentBlocks.length) {\n        renderableAttachments = fcAttachmentBlocks.map(attachmentBlock => new Attachment(attachmentBlock.attachmentMeta!));\n      }\n    } else {\n      this.renderText('Formatting...');\n      const decoded = await Mime.decode(decryptedBytes);\n      if (typeof decoded.html !== 'undefined') {\n        decryptedContent = decoded.html;\n        isHtml = true;\n      } else if (typeof decoded.text !== 'undefined') {\n        decryptedContent = decoded.text;\n      } else {\n        decryptedContent = '';\n      }\n      if (decoded.subject && isEncrypted && (!plainSubject || !Mime.subjectWithoutPrefixes(plainSubject).includes(Mime.subjectWithoutPrefixes(decoded.subject)))) {\n        // there is an encrypted subject + (either there is no plain subject or the plain subject does not contain what's in the encrypted subject)\n        decryptedContent = this.getEncryptedSubjectText(decoded.subject, isHtml) + decryptedContent; // render encrypted subject in message\n      }\n      for (const attachment of decoded.attachments) {\n        if (attachment.treatAs() !== 'publicKey') {\n          renderableAttachments.push(attachment);\n        } else {\n          publicKeys.push(attachment.getData().toUtfStr());\n        }\n      }\n    }\n    await this.view.quoteModule.separateQuotedContentAndRenderText(decryptedContent, isHtml);\n    if (Str.mostlyRTL(Xss.htmlSanitizeAndStripAllTags(decryptedContent, '\\n'))) {\n      $('#pgp_signature').addClass('rtl');\n    }\n    if (isEncrypted && publicKeys.length) {\n      BrowserMsg.send.renderPublicKeys(this.view.parentTabId, { afterFrameId: this.view.frameId, publicKeys });\n    }\n    if (renderableAttachments.length) {\n      this.view.attachmentsModule.renderInnerAttachments(renderableAttachments, isEncrypted);\n    }\n    this.resizePgpBlockFrame();\n    if (!this.doNotSetStateAsReadyYet) { // in case async tasks are still being worked at\n      Ui.setTestState('ready');\n    }\n  }\n\n  private displayImageSrcLinkAsImg = (a: HTMLAnchorElement, event: JQuery.Event<HTMLAnchorElement, null>) => {\n    const img = document.createElement('img');\n    img.setAttribute('style', a.getAttribute('style') || '');\n    img.style.background = 'none';\n    img.style.border = 'none';\n    img.addEventListener('load', () => this.resizePgpBlockFrame());\n    if (a.href.startsWith('cid:')) { // image included in the email\n      const contentId = a.href.replace(/^cid:/g, '');\n      const content = this.view.attachmentsModule.includedAttachments.filter(a => a.type.indexOf('image/') === 0 && a.cid === `<${contentId}>`)[0];\n      if (content) {\n        img.src = `data:${a.type};base64,${content.getData().toBase64Str()}`;\n        Xss.replaceElementDANGEROUSLY(a, img.outerHTML); // xss-safe-value - img.outerHTML was built using dom node api\n      } else {\n        Xss.replaceElementDANGEROUSLY(a, Xss.escape(`[broken link: ${a.href}]`)); // xss-escaped\n      }\n    } else if (a.href.startsWith('https://') || a.href.startsWith('http://')) { // image referenced as url\n      img.src = a.href;\n      Xss.replaceElementDANGEROUSLY(a, img.outerHTML); // xss-safe-value - img.outerHTML was built using dom node api\n    } else if (a.href.startsWith('data:image/')) { // image directly inlined\n      img.src = a.href;\n      Xss.replaceElementDANGEROUSLY(a, img.outerHTML); // xss-safe-value - img.outerHTML was built using dom node api\n    } else {\n      Xss.replaceElementDANGEROUSLY(a, Xss.escape(`[broken link: ${a.href}]`)); // xss-escaped\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    event.stopImmediatePropagation();\n  }\n\n  private getEncryptedSubjectText = (subject: string, isHtml: boolean) => {\n    if (isHtml) {\n      return `<div style=\"font-size: 14px; border-bottom: 1px #cacaca\"> Encrypted Subject:\n                <b> ${subject}</b>\n              </div>\n              <hr/>`;\n    } else {\n      return `Encrypted Subject: ${subject}\\n----------------------------------------------------------------------------------------------------\\n`;\n    }\n  }\n\n}\n",
    "extension/chrome/elements/pgp_block_modules/pgp-block-signature-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { PgpBlockView } from '../pgp_block';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { VerifyRes } from '../../../js/common/core/crypto/pgp/msg-util.js';\nimport { ContactStore } from '../../../js/common/platform/store/contact-store.js';\nimport { Str } from '../../../js/common/core/common.js';\n\nexport class PgpBlockViewSignatureModule {\n\n  private static setSigner = (signature: VerifyRes): void => {\n    const signerEmail = signature.signer?.primaryUserId ? Str.parseEmail(signature.signer.primaryUserId).email : undefined;\n    $('#pgp_signature > .cursive > span').text(signerEmail || 'Unknown Signer');\n  }\n\n  constructor(private view: PgpBlockView) {\n  }\n\n  public renderPgpSignatureCheckResult = (signature: VerifyRes | undefined, retryVerification?: () => Promise<VerifyRes | undefined>) => {\n    this.view.renderModule.doNotSetStateAsReadyYet = true; // so that body state is not marked as ready too soon - automated tests need to know when to check results\n    if (signature?.signer && !signature.contact) {\n      this.renderPgpSignatureCheckMissingPubkeyOptions(signature.signer.longid, this.view.senderEmail, retryVerification).then((newSignature) => { // async so that it doesn't block rendering\n        if (newSignature) {\n          return this.renderPgpSignatureCheckResult(newSignature, undefined);\n        }\n        PgpBlockViewSignatureModule.setSigner(signature);\n        this.view.renderModule.doNotSetStateAsReadyYet = false;\n        Ui.setTestState('ready');\n        $('#pgp_block').css('min-height', '100px'); // signature fail can have a lot of text in it to render\n        this.view.renderModule.resizePgpBlockFrame();\n      }).catch(Catch.reportErr);\n    } else {\n      if (!signature) {\n        $('#pgp_signature').addClass('bad');\n        $('#pgp_signature > .cursive').remove();\n        $('#pgp_signature > .result').text('Message Not Signed');\n      } else if (signature.error) {\n        $('#pgp_signature').addClass('bad');\n        $('#pgp_signature > .result').text(signature.error);\n        this.view.renderModule.setFrameColor('red');\n      } else if (signature.match && signature.signer && signature.contact) {\n        $('#pgp_signature').addClass('good');\n        $('#pgp_signature > .result').text('matching signature');\n      } else {\n        $('#pgp_signature').addClass('bad');\n        $('#pgp_signature > .result').text('signature does not match');\n        this.view.renderModule.setFrameColor('red');\n      }\n      if (signature) {\n        PgpBlockViewSignatureModule.setSigner(signature);\n      }\n      this.view.renderModule.doNotSetStateAsReadyYet = false;\n      Ui.setTestState('ready');\n    }\n    // $('#pgp_signature').css('block');\n  }\n\n  /**\n   * don't have appropriate pubkey by longid in contacts\n   */\n  private renderPgpSignatureCheckMissingPubkeyOptions = async (signerLongid: string, senderEmail: string,\n    retryVerification?: () => Promise<VerifyRes | undefined>): Promise<VerifyRes | undefined> => {\n    const render = (note: string, action: () => void) => $('#pgp_signature').addClass('neutral').find('.result').text(note).click(this.view.setHandler(action));\n    try {\n      if (senderEmail) { // we know who sent it\n        const [senderContactByEmail] = await ContactStore.get(undefined, [senderEmail]);\n        if (senderContactByEmail && senderContactByEmail.pubkey) {\n          const foundId = senderContactByEmail.pubkey.id;\n          render(`Fetched the right pubkey ${signerLongid} from keyserver, but will not use it because you have conflicting pubkey ${foundId} loaded.`, () => undefined);\n          return undefined;\n        }\n        // ---> and user doesn't have pubkey for that email addr\n        const { pubkeys } = await this.view.pubLookup.lookupEmail(senderEmail);\n        if (!pubkeys.length) {\n          render(`Missing pubkey ${signerLongid}`, () => undefined);\n          return undefined;\n        }\n        // ---> and pubkey found on keyserver by sender email\n        const { key: pubkey } = await BrowserMsg.send.bg.await.keyMatch({ pubkeys, longid: signerLongid });\n        if (!pubkey) {\n          render(`Fetched ${pubkeys.length} sender's pubkeys but message was signed with a different key: ${signerLongid}, will not verify.`, () => undefined);\n          return undefined;\n        }\n        // ---> and longid it matches signature\n        await ContactStore.update(undefined, senderEmail, { pubkey }); // <= TOFU auto-import\n        if (retryVerification) {\n          const newResult = await retryVerification();\n          if (newResult) {\n            return newResult;\n          }\n        }\n        render('Fetched pubkey, click to verify', () => window.location.reload());\n      } else { // don't know who sent it\n        render('Cannot verify: missing pubkey, missing sender info', () => undefined);\n        // todo - try to fetch pubkey by longid, offer to import it, show warning explaining what it means\n      }\n    } catch (e) {\n      if (ApiErr.isSignificant(e)) {\n        Catch.reportErr(e);\n        render(`Could not load sender pubkey ${signerLongid} due to an error.`, () => undefined);\n      } else {\n        render(`Could not look up sender's pubkey due to network error, click to retry.`, () => window.location.reload());\n      }\n    }\n    return undefined;\n  }\n\n}\n",
    "extension/chrome/settings/inbox/inbox-modules/inbox-active-thread-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Bm, BrowserMsg } from '../../../../js/common/browser/browser-msg.js';\nimport { FactoryReplyParams, XssSafeFactory } from '../../../../js/common/xss-safe-factory.js';\nimport { GmailParser, GmailRes } from '../../../../js/common/api/email-provider/gmail/gmail-parser.js';\nimport { Url, UrlParams } from '../../../../js/common/core/common.js';\n\nimport { ApiErr } from '../../../../js/common/api/shared/api-error.js';\nimport { BrowserMsgCommonHandlers } from '../../../../js/common/browser/browser-msg-common-handlers.js';\nimport { Buf } from '../../../../js/common/core/buf.js';\nimport { Catch } from '../../../../js/common/platform/catch.js';\nimport { InboxView } from '../inbox.js';\nimport { Lang } from '../../../../js/common/lang.js';\nimport { Mime } from '../../../../js/common/core/mime.js';\nimport { Ui } from '../../../../js/common/browser/ui.js';\nimport { ViewModule } from '../../../../js/common/view-module.js';\nimport { Xss } from '../../../../js/common/platform/xss.js';\nimport { Browser } from '../../../../js/common/browser/browser.js';\nimport { Attachment } from '../../../../js/common/core/attachment.js';\n\nexport class InboxActiveThreadModule extends ViewModule<InboxView> {\n\n  private threadId: string | undefined;\n  private threadHasPgpBlock: boolean = false;\n  private debugEmails = ['flowcrypt.compatibility@gmail.com', 'ci.tests.gmail@flowcrypt.dev']; // adds debugging ui, useful for creating automated tests\n\n  public render = async (threadId: string, thread?: GmailRes.GmailThread) => {\n    this.threadId = threadId;\n    this.view.displayBlock('thread', 'Loading..');\n    try {\n      thread = thread || await this.view.gmail.threadGet(threadId, 'metadata');\n      if (!thread.messages) {\n        Xss.sanitizeRender('.thread', `<br>No messages in this thread. ${Ui.retryLink()}`);\n        return;\n      }\n      const subject = GmailParser.findHeader(thread.messages[0], 'subject') || '(no subject)';\n      this.updateUrlWithoutRedirecting(`${subject} - FlowCrypt Inbox`, { acctEmail: this.view.acctEmail, threadId });\n      this.view.displayBlock('thread', Xss.escape(subject));\n      for (const m of thread.messages) {\n        await this.renderMsg(m);\n      }\n      if (this.threadHasPgpBlock) {\n        $(\".action_see_original_message\").css('display', 'inline-block');\n        if (this.view.showOriginal) {\n          $(\".action_see_original_message\").text('See Decrypted');\n        }\n      }\n      const lastMsg = thread.messages[thread.messages.length - 1];\n      if (lastMsg) {\n        this.renderReplyBox(lastMsg.id);\n      }\n      this.setHandlers();\n      // await gmail.threadModify(acctEmail, threadId, [LABEL.UNREAD], []); // missing permission https://github.com/FlowCrypt/flowcrypt-browser/issues/1304\n    } catch (e) {\n      if (ApiErr.isNetErr(e)) {\n        Xss.sanitizeRender('.thread', `<br>Failed to load thread - network error. ${Ui.retryLink()}`);\n      } else if (ApiErr.isAuthErr(e)) {\n        this.view.inboxNotificationModule.renderAndHandleAuthPopupNotification();\n      } else if (ApiErr.isMailOrAcctDisabledOrPolicy(e)) {\n        this.view.inboxNotificationModule.showNotification(Lang.account.googleAcctDisabledOrPolicy);\n      } else {\n        Catch.reportErr(e);\n        const printable = Xss.escape(e instanceof Error ? e.stack || e.message : JSON.stringify(e, undefined, 2));\n        Xss.sanitizeRender('.thread', `<br>Failed to load thread due to the following error: <pre>${printable}</pre>`);\n      }\n    }\n  }\n\n  public setHandlers = () => {\n    if (this.threadHasPgpBlock) {\n      $(\".action_see_original_message\").click(this.view.setHandler(() => this.view.redirectToUrl({\n        acctEmail: this.view.acctEmail, threadId: this.threadId, showOriginal: !this.view.showOriginal\n      })));\n    }\n    BrowserMsg.addListener('close_reply_message', async ({ frameId }: Bm.CloseReplyMessage) => {\n      $(`iframe#${frameId}`).remove();\n    });\n    BrowserMsg.addListener('reinsert_reply_box', async ({ replyMsgId }: Bm.ReinsertReplyBox) => {\n      this.renderReplyBox(replyMsgId);\n    });\n    BrowserMsg.addListener('scroll_to_bottom_of_conversation', async () => {\n      const scrollableEl = $('.thread').get(0);\n      scrollableEl.scrollTop = scrollableEl.scrollHeight; // scroll to the bottom of conversation where the reply box is\n    });\n    BrowserMsg.addListener('render_public_keys', async ({ traverseUp, afterFrameId, publicKeys }: Bm.RenderPublicKeys) => {\n      const traverseUpLevels = traverseUp || 0;\n      let appendAfter = $(`iframe#${afterFrameId}`);\n      for (let i = 0; i < traverseUpLevels; i++) {\n        appendAfter = appendAfter.parent();\n      }\n      for (const armoredPubkey of publicKeys) {\n        appendAfter.after(this.view.factory.embeddedPubkey(armoredPubkey, false));\n      }\n    });\n    BrowserMsg.addListener('reply_pubkey_mismatch', BrowserMsgCommonHandlers.replyPubkeyMismatch);\n  }\n\n  private renderMsg = async (message: GmailRes.GmailMsg) => {\n    const htmlId = this.replyMsgId(message.id);\n    const from = GmailParser.findHeader(message, 'from') || 'unknown';\n    try {\n      const { raw } = await this.view.gmail.msgGet(message.id, 'raw');\n      const mimeMsg = Buf.fromBase64UrlStr(raw!);\n      const { blocks, headers } = await Mime.process(mimeMsg);\n      let r = '';\n      let renderedAttachments = '';\n      for (const block of blocks) {\n        if (block.type === 'encryptedMsg' || block.type === 'publicKey' || block.type === 'privateKey' || block.type === 'signedMsg') {\n          this.threadHasPgpBlock = true;\n        }\n        if (r) {\n          r += '<br><br>';\n        }\n        if (['encryptedAttachment', 'plainAttachment'].includes(block.type)) {\n          renderedAttachments += XssSafeFactory.renderableMsgBlock(this.view.factory, block, message.id, from, this.view.storage.sendAs && !!this.view.storage.sendAs[from]);\n        } else if (this.view.showOriginal) {\n          r += Xss.escape(block.content.toString()).replace(/\\n/g, '<br>');\n        } else {\n          r += XssSafeFactory.renderableMsgBlock(this.view.factory, block, message.id, from, this.view.storage.sendAs && !!this.view.storage.sendAs[from]);\n        }\n      }\n      if (renderedAttachments) {\n        r += `<div class=\"attachments\">${renderedAttachments}</div>`;\n      }\n      const exportBtn = this.debugEmails.includes(this.view.acctEmail) ? '<a href=\"#\" class=\"action-export\">download api export</a>' : '';\n      r = `<p class=\"message_header\" data-test=\"container-msg-header\">From: ${Xss.escape(from)} <span style=\"float:right;\">${headers.date} ${exportBtn}</p>` + r;\n      $('.thread').append(this.wrapMsg(htmlId, r)); // xss-safe-factory\n      if (exportBtn) {\n        $('.action-export').click(this.view.setHandler(() => this.exportMsgForDebug(message.id)));\n      }\n    } catch (e) {\n      if (ApiErr.isNetErr(e)) {\n        Xss.sanitizeAppend('.thread', this.wrapMsg(htmlId, `Failed to load a message (network error), skipping. ${Ui.retryLink()}`));\n      } else if (ApiErr.isAuthErr(e)) {\n        this.view.inboxNotificationModule.renderAndHandleAuthPopupNotification();\n      } else if (ApiErr.isMailOrAcctDisabledOrPolicy(e)) {\n        this.view.inboxNotificationModule.showNotification(Lang.account.googleAcctDisabledOrPolicy);\n      } else {\n        Catch.reportErr(e);\n        const printable = Xss.escape(e instanceof Error ? e.stack || e.message : JSON.stringify(e, undefined, 2));\n        Xss.sanitizeAppend('.thread', this.wrapMsg(htmlId, `Failed to load a message due to the following error: <pre>${printable}</pre>`));\n      }\n    }\n  }\n\n  private exportMsgForDebug = async (msgId: string) => {\n    const full = await this.view.gmail.msgGet(msgId, 'full');\n    const raw = await this.view.gmail.msgGet(msgId, 'raw');\n    const existingAttachments = GmailParser.findAttachments(full);\n    await this.view.gmail.fetchAttachments(existingAttachments);\n    this.redactExportMsgHeaders(full);\n    this.redactExportMsgHeaders(raw);\n    const attachments: { [id: string]: { data: string, size: number } } = {};\n    for (const attachment of existingAttachments) {\n      attachments[attachment.id!] = { data: attachment.getData().toBase64UrlStr(), size: attachment.getData().length };\n    }\n    const combined = { acctEmail: this.view.acctEmail, full, attachments, raw };\n    const json = JSON.stringify(combined, undefined, 2);\n    Browser.saveToDownloads(new Attachment({ data: Buf.fromUtfStr(json), type: 'application/json', name: `message-export-${msgId}.json` }));\n  }\n\n  private redactExportMsgHeaders = (msg: GmailRes.GmailMsg) => {\n    const exclude = ['received', 'dkim', 'authentication', 'feedback', 'ip', 'mailgun', 'unsubscribe', 'return',\n      'arc', 'google', 'delivered', 'precedence', 'message-id'];\n    if (msg.payload) {\n      msg.payload.headers = msg.payload.headers?.filter(h => {\n        const hn = h.name.toLowerCase();\n        for (const excludable of exclude) {\n          if (hn.includes(excludable)) {\n            return false;\n          }\n        }\n        if (hn === 'to') {\n          h.value = 'flowcrypt.compatibility@gmail.com'; // you can edit this manually in the export if you need a specific value\n        }\n        if (hn === 'sender' || hn === 'from') {\n          h.value = 'sender@domain.com'; // you can edit this manually in the export if you need a specific value\n        }\n        return true;\n      });\n    }\n  }\n\n  private replyMsgId = (msgId: string) => {\n    return 'message_id_' + msgId;\n  }\n\n  private renderReplyBox = (replyMsgId: string) => {\n    const params: FactoryReplyParams = { replyMsgId };\n    this.view.S.cached('thread').append(Ui.e('div', { class: 'reply line', html: this.view.factory.embeddedReply(params, false, false) })); // xss-safe-factory\n  }\n\n  private updateUrlWithoutRedirecting = (title: string, params: UrlParams) => {\n    const newUrlSearch = Url.create('', params);\n    if (newUrlSearch !== window.location.search) {\n      window.history.pushState({}, title, newUrlSearch);\n    }\n  }\n\n  private wrapMsg = (id: string, html: string) => {\n    return Ui.e('div', { id, class: 'message line', html });\n  }\n\n}\n",
    "extension/chrome/settings/inbox/inbox-modules/inbox-list-threads-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { ApiErr } from '../../../../js/common/api/shared/api-error.js';\nimport { Catch } from '../../../../js/common/platform/catch.js';\nimport { GmailParser } from '../../../../js/common/api/email-provider/gmail/gmail-parser.js';\nimport { InboxView } from '../inbox.js';\nimport { Lang } from '../../../../js/common/lang.js';\nimport { Str } from '../../../../js/common/core/common.js';\nimport { Ui } from '../../../../js/common/browser/ui.js';\nimport { ViewModule } from '../../../../js/common/view-module.js';\nimport { Xss } from '../../../../js/common/platform/xss.js';\n\nexport class InboxListThreadsModule extends ViewModule<InboxView> {\n\n  public render = async (labelId: string) => {\n    this.view.displayBlock('inbox', `Messages in ${Xss.escape(this.view.inboxMenuModule.getLabelName(labelId))}`);\n    try {\n      const { threads } = await this.view.gmail.threadList(labelId);\n      if (threads?.length) {\n        await Promise.all(threads.map(t => this.renderInboxItem(t.id)));\n      } else {\n        Xss.sanitizeRender('.threads', `<p>No encrypted messages in ${Xss.escape(labelId)} yet. ${Ui.retryLink()}</p>`);\n      }\n    } catch (e) {\n      if (ApiErr.isNetErr(e)) {\n        this.view.inboxNotificationModule.showNotification(`Connection error trying to get list of messages ${Ui.retryLink()}`);\n      } else if (ApiErr.isAuthErr(e)) {\n        this.view.inboxNotificationModule.renderAndHandleAuthPopupNotification();\n      } else if (ApiErr.isMailOrAcctDisabledOrPolicy(e)) {\n        this.view.inboxNotificationModule.showNotification(Lang.account.googleAcctDisabledOrPolicy);\n      } else if (ApiErr.isInsufficientPermission(e)) {\n        this.view.inboxNotificationModule.renderAndHandleAuthPopupNotification(true);\n      } else {\n        Catch.reportErr(e);\n        await Ui.modal.error(`Error trying to get list of folders: ${ApiErr.eli5(e)}\\n\\n${String(e)}`);\n        window.location.reload();\n      }\n    }\n  }\n\n  private renderInboxItem = async (threadId: string) => {\n    this.inboxThreadItemAdd(threadId);\n    const threadItem = $('.threads #' + this.threadListItemId(threadId));\n    try {\n      const thread = await this.view.gmail.threadGet(threadId, 'metadata');\n      if (!thread.messages?.length) {\n        threadItem.find('.loading').text('Could not find item');\n        return;\n      }\n      const firstMsg = thread.messages[0];\n      const lastMsg = thread.messages[thread.messages.length - 1];\n      threadItem.find('.subject').text(GmailParser.findHeader(firstMsg, 'subject') || '(no subject)');\n      Xss.sanitizeAppend(threadItem.find('.subject'), this.view.inboxMenuModule.renderableLabels(firstMsg.labelIds || [], 'messages'));\n      const fromHeaderVal = GmailParser.findHeader(firstMsg, 'from');\n      if (fromHeaderVal) {\n        const from = Str.parseEmail(fromHeaderVal);\n        threadItem.find('.from').text(from.name || from.email || from.full);\n      }\n      threadItem.find('.loading').text('');\n      threadItem.find('.date').text(this.formatDate(lastMsg.internalDate));\n      threadItem.addClass('loaded').click(this.view.setHandler(() => this.view.inboxActiveThreadModule.render(thread.id, thread)));\n      if (lastMsg.labelIds?.includes(this.view.inboxMenuModule.LABEL.UNREAD)) {\n        threadItem.css({ 'font-weight': 'bold', 'background': 'white' });\n      }\n      if (thread.messages.length > 1) {\n        threadItem.find('.msg_count').text(`(${thread.messages.length})`);\n      }\n    } catch (e) {\n      if (ApiErr.isNetErr(e)) {\n        Xss.sanitizeRender(threadItem.find('.loading'), 'Failed to load (network) <a href=\"#\">retry</a>').find('a').click(this.view.setHandler(() => this.renderInboxItem(threadId)));\n      } else if (ApiErr.isAuthErr(e)) {\n        this.view.inboxNotificationModule.renderAndHandleAuthPopupNotification();\n      } else if (ApiErr.isMailOrAcctDisabledOrPolicy(e)) {\n        this.view.inboxNotificationModule.showNotification(Lang.account.googleAcctDisabledOrPolicy);\n      } else {\n        Catch.reportErr(e);\n        threadItem.find('.loading').text('Failed to load');\n      }\n    }\n  }\n\n  private inboxThreadItemAdd = (threadId: string) => {\n    const content = `\n      <span class=\"from_container\">\n        <span class=\"from\"></span>\n        <span class=\"msg_count\"></span></span>\n      <span class=\"subject\" data-test=\"container-subject\"></span>\n      <span class=\"date\"></span>\n    `;\n    Xss.sanitizeAppend(this.view.S.cached('threads'), Ui.e('div', {\n      class: 'line',\n      id: this.threadListItemId(threadId),\n      html: `<span class=\"loading\">${Ui.spinner('green')}loading..</span>${content}`,\n    }));\n  }\n\n  private threadListItemId = (threadId: string) => {\n    return 'list_thread_id_' + threadId;\n  }\n\n  private formatDate = (dateFromApi: string | number | undefined): string => {\n    const date = new Date(Number(dateFromApi));\n    if (date.toLocaleDateString() === new Date().toLocaleDateString()) {\n      return date.toLocaleTimeString();\n    }\n    return date.toLocaleDateString();\n  }\n\n}\n",
    "extension/chrome/settings/inbox/inbox-modules/inbox-menu-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Catch } from '../../../../js/common/platform/catch.js';\nimport { Dict } from '../../../../js/common/core/common.js';\nimport { GmailRes } from '../../../../js/common/api/email-provider/gmail/gmail-parser.js';\nimport { Google } from '../../../../js/common/api/email-provider/gmail/google.js';\nimport { InboxView } from '../inbox.js';\nimport { ViewModule } from '../../../../js/common/view-module.js';\nimport { Xss } from '../../../../js/common/platform/xss.js';\n\nexport class InboxMenuModule extends ViewModule<InboxView> {\n\n  public readonly LABEL: Dict<GmailRes.GmailMsg$labelId> = {\n    INBOX: 'INBOX', UNREAD: 'UNREAD', CATEGORY_PERSONAL: 'CATEGORY_PERSONAL', IMPORTANT: 'IMPORTANT', SENT: 'SENT', CATEGORY_UPDATES: 'CATEGORY_UPDATES'\n  };\n\n  private readonly FOLDERS = ['INBOX', 'STARRED', 'SENT', 'DRAFT', 'TRASH']; // 'UNREAD', 'SPAM'\n  private allLabels!: GmailRes.GmailLabels$label[];\n\n  public render = async () => {\n    await this.renderNavbartTop();\n    this.allLabels = (await this.view.gmail.labelsGet()).labels;\n    this.renderMenuAndLabelStyles();\n    this.setHandlers();\n  }\n\n  public getLabelName = (labelId: string) => {\n    if (labelId === 'ALL') {\n      return 'all folders';\n    }\n    const label = this.allLabels?.find(l => l.id === labelId);\n    if (label) {\n      return label.name;\n    }\n    return `UNKNOWN LABEL: ${labelId}`;\n  }\n\n  public renderableLabels = (labelIds: (GmailRes.GmailMsg$labelId | string)[], placement: 'messages' | 'menu' | 'labels') => {\n    return labelIds.map(id => this.renderableLabel(id, placement)).join('');\n  }\n\n  private setHandlers = () => {\n    $('.action_open_secure_compose_window').click(this.view.setHandler(() => this.view.injector.openComposeWin()));\n    $('.menu > .label').click(this.view.setHandler(this.renderFolder));\n  }\n\n  private renderMenuAndLabelStyles = () => {\n    this.addLabelStyles(this.allLabels);\n    Xss.sanitizeAppend('.menu', `<br>${this.renderableLabels(this.FOLDERS, 'menu')}<button class=\"button gray2 label label_ALL\">ALL MAIL</button><br>`);\n    Xss.sanitizeAppend('.menu', '<br>' + this.renderableLabels(this.allLabels.sort((a, b) => {\n      if (a.name > b.name) {\n        return 1;\n      } else if (a.name < b.name) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }).map(l => l.id), 'labels'));\n  }\n\n  private addLabelStyles = (labels: GmailRes.GmailLabels$label[]) => {\n    let style = '';\n    for (const label of labels) {\n      if (label.color) {\n        const id = Xss.escape(label.id);\n        const bg = Xss.escape(label.color.backgroundColor);\n        const fg = Xss.escape(label.color.textColor);\n        style += `.label.label_${id} {color: ${fg}; background-color: ${bg};} `;\n      }\n    }\n    $('body').append(`<style>${style}</style>`); // xss-escaped\n  }\n\n  private renderableLabel = (labelId: string, placement: 'messages' | 'menu' | 'labels') => {\n    const label = this.allLabels?.find(l => l.id === labelId);\n    if (!label) {\n      return '';\n    }\n    if (placement === 'messages' && label.messageListVisibility !== 'show') {\n      return '';\n    }\n    if (placement === 'labels' && (label.labelListVisibility !== 'labelShow' || label.id === this.LABEL.INBOX)) {\n      return '';\n    }\n    const id = Xss.escape(labelId);\n    const name = Xss.escape(label.name);\n    if (placement === 'menu') {\n      const unread = Number(label.messagesUnread);\n      return `<button class=\"button gray2 label label_${id}\" ${unread ? 'style=\"font-weight: bold;\"' : ''}>${name}${unread ? ` (${unread})` : ''}</button><br>`;\n    } else if (placement === 'labels') {\n      return `<span class=\"label label_${id}\">${name}</span><br>`;\n    } else {\n      return `<span class=\"label label_${id}\">${name}</span>`;\n    }\n  }\n\n  private renderNavbartTop = async () => {\n    $('.action_open_webmail').attr('href', Google.webmailUrl(this.view.acctEmail));\n    $('.action_choose_account').get(0).title = this.view.acctEmail;\n    if (this.view.storage.picture) {\n      $('img.main-profile-img').attr('src', this.view.storage.picture).on('error', this.view.setHandler(self => {\n        $(self).off().attr('src', '/img/svgs/profile-icon.svg');\n      }));\n    }\n    await this.view.webmailCommon.addOrRemoveEndSessionBtnIfNeeded();\n    Catch.setHandledTimeout(() => { $('#banner a').css('color', 'red'); }, 500);\n    Catch.setHandledTimeout(() => { $('#banner a').css('color', ''); }, 1000);\n    Catch.setHandledTimeout(() => { $('#banner a').css('color', 'red'); }, 1500);\n    Catch.setHandledTimeout(() => { $('#banner a').css('color', ''); }, 2000);\n  }\n\n  private renderFolder = (labelEl: HTMLSpanElement) => {\n    for (const cls of labelEl.classList) {\n      const labelId = (cls.match(/^label_([a-zA-Z0-9_]+)$/) || [])[1];\n      if (labelId) {\n        this.view.redirectToUrl({ acctEmail: this.view.acctEmail, labelId });\n        return;\n      }\n    }\n    this.view.redirectToUrl({ acctEmail: this.view.acctEmail });\n  }\n\n}\n",
    "extension/chrome/settings/inbox/inbox.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { SelCache, Ui } from '../../../js/common/browser/ui.js';\nimport { Url, UrlParams } from '../../../js/common/core/common.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Assert } from '../../../js/common/assert.js';\nimport { Browser } from '../../../js/common/browser/browser.js';\nimport { BrowserMsg, Bm } from '../../../js/common/browser/browser-msg.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { Gmail } from '../../../js/common/api/email-provider/gmail/gmail.js';\nimport { InboxActiveThreadModule } from './inbox-modules/inbox-active-thread-module.js';\nimport { InboxListThreadsModule } from './inbox-modules/inbox-list-threads-module.js';\nimport { InboxMenuModule } from './inbox-modules/inbox-menu-module.js';\nimport { InboxNotificationModule } from './inbox-modules/inbox-notification-module.js';\nimport { Injector } from '../../../js/common/inject.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport Swal from 'sweetalert2';\nimport { View } from '../../../js/common/view.js';\nimport { WebmailCommon } from \"../../../js/common/webmail.js\";\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { XssSafeFactory } from '../../../js/common/xss-safe-factory.js';\nimport { AcctStore, AcctStoreDict } from '../../../js/common/platform/store/acct-store.js';\n\nexport class InboxView extends View {\n\n  public readonly inboxMenuModule: InboxMenuModule;\n  public readonly inboxNotificationModule: InboxNotificationModule;\n  public readonly inboxActiveThreadModule: InboxActiveThreadModule;\n  public readonly inboxListThreadsModule: InboxListThreadsModule;\n\n  public readonly acctEmail: string;\n  public readonly labelId: string;\n  public readonly threadId: string | undefined;\n  public readonly showOriginal: boolean;\n  public readonly S: SelCache;\n  public readonly gmail: Gmail;\n\n  public injector!: Injector;\n  public webmailCommon!: WebmailCommon;\n  public factory!: XssSafeFactory;\n  public storage!: AcctStoreDict;\n  public tabId!: string;\n\n  constructor() {\n    super();\n    const uncheckedUrlParams = Url.parse(['acctEmail', 'labelId', 'threadId', 'showOriginal']);\n    this.acctEmail = Assert.urlParamRequire.string(uncheckedUrlParams, 'acctEmail');\n    this.labelId = uncheckedUrlParams.labelId ? String(uncheckedUrlParams.labelId) : 'INBOX';\n    this.threadId = Assert.urlParamRequire.optionalString(uncheckedUrlParams, 'threadId');\n    this.showOriginal = uncheckedUrlParams.showOriginal === true;\n    this.S = Ui.buildJquerySels({ threads: '.threads', thread: '.thread', body: 'body' });\n    this.gmail = new Gmail(this.acctEmail);\n    this.inboxMenuModule = new InboxMenuModule(this);\n    this.inboxNotificationModule = new InboxNotificationModule(this);\n    this.inboxActiveThreadModule = new InboxActiveThreadModule(this);\n    this.inboxListThreadsModule = new InboxListThreadsModule(this);\n  }\n\n  public render = async () => {\n    this.tabId = await BrowserMsg.requiredTabId();\n    this.factory = new XssSafeFactory(this.acctEmail, this.tabId);\n    this.injector = new Injector('settings', undefined, this.factory);\n    this.webmailCommon = new WebmailCommon(this.acctEmail, this.injector);\n    this.storage = await AcctStore.get(this.acctEmail, ['email_provider', 'picture', 'sendAs']);\n    this.inboxNotificationModule.render();\n    const emailProvider = this.storage.email_provider || 'gmail';\n    try {\n      await Settings.populateAccountsMenu('inbox.htm');\n      if (emailProvider !== 'gmail') {\n        $('body').text('Not supported for ' + emailProvider);\n      } else {\n        await this.inboxMenuModule.render();\n        if (this.threadId) {\n          await this.inboxActiveThreadModule.render(this.threadId);\n        } else {\n          await this.inboxListThreadsModule.render(this.labelId);\n        }\n      }\n    } catch (e) {\n      ApiErr.reportIfSignificant(e);\n      if (ApiErr.isAuthErr(e)) {\n        await Ui.modal.warning(`FlowCrypt must be re-connected to your Google account.`);\n        await Settings.newGoogleAcctAuthPromptThenAlertOrForward(this.tabId, this.acctEmail);\n      } else {\n        await Ui.modal.error(`${ApiErr.eli5(e)}\\n\\n${String(e)}`);\n      }\n    }\n  }\n\n  public setHandlers = () => {\n    // BrowserMsg.addPgpListeners(); // todo - re-allow when https://github.com/FlowCrypt/flowcrypt-browser/issues/2560 fixed\n    BrowserMsg.listen(this.tabId);\n    Catch.setHandledInterval(this.webmailCommon.addOrRemoveEndSessionBtnIfNeeded, 30000);\n    $('.action_open_settings').click(this.setHandler(async () => await Browser.openSettingsPage('index.htm', this.acctEmail)));\n    $(\".action-toggle-accounts-menu\").click(this.setHandler((target, event) => {\n      event.stopPropagation();\n      $(\"#alt-accounts\").toggleClass(\"active\");\n    }));\n    $('.action_add_account').click(this.setHandlerPrevent('double', async () => await Settings.newGoogleAcctAuthPromptThenAlertOrForward(this.tabId)));\n    this.addBrowserMsgListeners();\n  }\n\n  public redirectToUrl = (params: UrlParams) => {\n    const newUrlSearch = Url.create('', params);\n    if (newUrlSearch !== window.location.search) {\n      window.location.search = newUrlSearch;\n    } else {\n      window.location.reload();\n    }\n  }\n\n  public displayBlock = (name: string, title: string) => {\n    this.S.cached('threads').css('display', name === 'thread' ? 'none' : 'block');\n    this.S.cached('thread').css('display', name === 'thread' ? 'block' : 'none');\n    Xss.sanitizeRender('h1', `${title}`);\n  }\n\n  private addBrowserMsgListeners = () => {\n    BrowserMsg.addListener('add_end_session_btn', () => this.injector.insertEndSessionBtn(this.acctEmail));\n    BrowserMsg.addListener('close_new_message', async () => {\n      $('div.new_message').remove();\n    });\n    BrowserMsg.addListener('passphrase_dialog', async ({ longids, type }: Bm.PassphraseDialog) => {\n      if (!$('#cryptup_dialog').length) {\n        $('body').append(this.factory.dialogPassphrase(longids, type))  // xss-safe-factory;\n          .click(this.setHandler(() => { // click on the area outside the iframe\n            BrowserMsg.send.passphraseEntry('broadcast', { entered: false });\n            $('#cryptup_dialog').remove();\n          }));\n      }\n    });\n    BrowserMsg.addListener('add_pubkey_dialog', async ({ emails }: Bm.AddPubkeyDialog) => {\n      if (!$('#cryptup_dialog').length) {\n        $('body').append(this.factory.dialogAddPubkey(emails)); // xss-safe-factory\n      }\n    });\n    BrowserMsg.addListener('close_dialog', async () => {\n      $('#cryptup_dialog').remove();\n    });\n    BrowserMsg.addListener('close_swal', async () => {\n      Swal.close();\n    });\n    BrowserMsg.addListener('show_attachment_preview', async ({ iframeUrl }: Bm.ShowAttachmentPreview) => {\n      await Ui.modal.attachmentPreview(iframeUrl);\n    });\n  }\n\n}\n\nView.run(InboxView);\n",
    "extension/chrome/settings/index.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Bm, BrowserMsg } from '../../js/common/browser/browser-msg.js';\nimport { Ui } from '../../js/common/browser/ui.js';\nimport { KeyInfo, KeyUtil } from '../../js/common/core/crypto/key.js';\nimport { Str, Url, UrlParams } from '../../js/common/core/common.js';\nimport { ApiErr } from '../../js/common/api/shared/api-error.js';\nimport { Assert } from '../../js/common/assert.js';\n\nimport { Catch } from '../../js/common/platform/catch.js';\nimport { Env } from '../../js/common/browser/env.js';\nimport { Gmail } from '../../js/common/api/email-provider/gmail/gmail.js';\nimport { Lang } from '../../js/common/lang.js';\nimport { Notifications } from '../../js/common/notifications.js';\nimport { OrgRules } from '../../js/common/org-rules.js';\nimport { Settings } from '../../js/common/settings.js';\nimport { VERSION } from '../../js/common/core/const.js';\nimport { View } from '../../js/common/view.js';\nimport { Xss } from '../../js/common/platform/xss.js';\nimport { XssSafeFactory } from '../../js/common/xss-safe-factory.js';\nimport { AcctStore, EmailProvider } from '../../js/common/platform/store/acct-store.js';\nimport { KeyStore } from '../../js/common/platform/store/key-store.js';\nimport { GlobalStore } from '../../js/common/platform/store/global-store.js';\nimport { PassphraseStore } from '../../js/common/platform/store/passphrase-store.js';\nimport Swal from 'sweetalert2';\nimport { FlowCryptWebsite } from '../../js/common/api/flowcrypt-website.js';\nimport { AccountServer } from '../../js/common/api/account-server.js';\nimport { SubscriptionInfo } from '../../js/common/api/account-servers/flowcrypt-com-api.js';\n\nView.run(class SettingsView extends View {\n\n  private readonly acctEmail: string | undefined;\n  private readonly page: string | undefined;\n  private readonly pageUrlParams: UrlParams | undefined;\n  private readonly addNewAcct: boolean;\n  private readonly advanced: boolean;\n\n  private readonly gmail: Gmail | undefined;\n  private tabId!: string;\n  private notifications!: Notifications;\n  private orgRules: OrgRules | undefined;\n  private acctServer: AccountServer | undefined;\n\n  private altAccounts: JQuery<HTMLElement>;\n\n  constructor() {\n    super();\n    const uncheckedUrlParams = Url.parse(['acctEmail', 'page', 'pageUrlParams', 'advanced', 'addNewAcct']);\n    this.acctEmail = Assert.urlParamRequire.optionalString(uncheckedUrlParams, 'acctEmail');\n    this.page = Assert.urlParamRequire.optionalString(uncheckedUrlParams, 'page');\n    if (this.page && !/^(\\/chrome|modules)/.test!(this.page as string)) {\n      Ui.modal.error('An unexpected value was found for the page parameter')\n        .catch(err => console.log(err));\n      this.page = undefined;\n    }\n    this.page = (this.page === 'undefined') ? undefined : this.page; // in case an \"undefined\" string slipped in\n    this.pageUrlParams = (typeof uncheckedUrlParams.pageUrlParams === 'string') ? JSON.parse(uncheckedUrlParams.pageUrlParams) as UrlParams : undefined;\n    this.addNewAcct = uncheckedUrlParams.addNewAcct === true;\n    this.advanced = uncheckedUrlParams.advanced === true;\n    if (this.acctEmail) {\n      this.acctEmail = this.acctEmail.toLowerCase().trim();\n      this.gmail = new Gmail(this.acctEmail);\n      this.acctServer = new AccountServer(this.acctEmail);\n    }\n    this.altAccounts = $('#alt-accounts');\n  }\n\n  public render = async () => {\n    $('#status-row #status_version').text(`v:${VERSION}`);\n    for (const webmailLName of await Env.webmails()) {\n      $('.signin_button.' + webmailLName).css('display', 'inline-block');\n    }\n    this.tabId = await BrowserMsg.requiredTabId();\n    this.notifications = new Notifications();\n    if (this.acctEmail) {\n      this.orgRules = await OrgRules.newInstance(this.acctEmail);\n    }\n    if (this.orgRules && !this.orgRules.canSubmitPubToAttester()) {\n      $('.public_profile_indicator_container').hide(); // contact page is useless if user cannot submit to attester\n    }\n    if (this.orgRules && this.orgRules.usesKeyManager()) {\n      $(\".add_key\").hide(); // users which a key manager should not be adding keys manually\n    }\n    $('#status-row #status_version').click(this.setHandler(async () => {\n      await Ui.modal.page('/changelog.txt', true);\n    }));\n    await this.initialize();\n    await Assert.abortAndRenderErrOnUnprotectedKey(this.acctEmail, this.tabId);\n    if (this.page) {\n      Settings.renderSubPage(this.acctEmail, this.tabId, this.page, this.pageUrlParams).catch(Catch.reportErr);\n    }\n    await Settings.populateAccountsMenu('index.htm');\n    Ui.setTestState('ready');\n  }\n\n  public setHandlers = () => {\n    BrowserMsg.addListener('open_page', async ({ page, addUrlText }: Bm.OpenPage) => {\n      await Settings.renderSubPage(this.acctEmail, this.tabId, page, addUrlText);\n    });\n    BrowserMsg.addListener('redirect', async ({ location }: Bm.Redirect) => {\n      window.location.href = location;\n    });\n    BrowserMsg.addListener('close_page', async () => {\n      Swal.close();\n    });\n    BrowserMsg.addListener('reload', async ({ advanced }: Bm.Reload) => {\n      Swal.close();\n      this.reload(advanced);\n    });\n    BrowserMsg.addListener('add_pubkey_dialog', async ({ emails }: Bm.AddPubkeyDialog) => {\n      // todo: use #cryptup_dialog just like passphrase_dialog does\n      const factory = new XssSafeFactory(this.acctEmail!, this.tabId);\n      window.open(factory.srcAddPubkeyDialog(emails, 'settings'), '_blank', 'height=680,left=100,menubar=no,status=no,toolbar=no,top=30,width=660');\n    });\n    BrowserMsg.addListener('notification_show', async ({ notification }: Bm.NotificationShow) => {\n      this.notifications!.show(notification);\n      let cleared = false;\n      const clear = () => {\n        if (!cleared) {\n          this.notifications!.clear();\n          cleared = true;\n        }\n      };\n      Catch.setHandledTimeout(clear, 10000);\n      $('.webmail_notifications').one('click', clear);\n    });\n    BrowserMsg.addListener('open_google_auth_dialog', async ({ acctEmail, scopes }: Bm.OpenGoogleAuthDialog) => {\n      await Settings.newGoogleAcctAuthPromptThenAlertOrForward(this.tabId, acctEmail, scopes);\n    });\n    BrowserMsg.addListener('passphrase_dialog', async ({ longids, type }: Bm.PassphraseDialog) => {\n      if (!$('#cryptup_dialog').length) {\n        const factory = new XssSafeFactory(this.acctEmail!, this.tabId);\n        $('body').append(factory.dialogPassphrase(longids, type)); // xss-safe-factory\n      }\n    });\n    BrowserMsg.addListener('notification_show_auth_popup_needed', async ({ acctEmail }: Bm.NotificationShowAuthPopupNeeded) => {\n      this.notifications!.showAuthPopupNeeded(acctEmail);\n    });\n    BrowserMsg.addListener('close_dialog', async () => {\n      $('#cryptup_dialog').remove();\n    });\n    BrowserMsg.listen(this.tabId);\n    $('.show_settings_page').click(this.setHandler(async target => {\n      const page = $(target).attr('page');\n      if (page) {\n        await Settings.renderSubPage(this.acctEmail!, this.tabId, page, $(target).attr('addurltext') || '');\n      } else {\n        Catch.report(`Unknown target page in element: ${target.outerHTML}`);\n      }\n    }));\n    $('.action_open_public_key_page').click(this.setHandler(async () => {\n      const ki = await KeyStore.getFirstRequired(this.acctEmail!);\n      const escapedFp = Xss.escape(ki.fingerprints[0]);\n      await Settings.renderSubPage(this.acctEmail!, this.tabId, 'modules/my_key.htm', `&fingerprint=${escapedFp}`);\n    }));\n    $('.action_show_encrypted_inbox').click(this.setHandler(() => {\n      window.location.href = Url.create('/chrome/settings/inbox/inbox.htm', { acctEmail: this.acctEmail! });\n    }));\n    $('.action_add_account').click(this.setHandlerPrevent('double', async () => await Settings.newGoogleAcctAuthPromptThenAlertOrForward(this.tabId)));\n    $('.action_google_auth').click(this.setHandlerPrevent('double', async () => await Settings.newGoogleAcctAuthPromptThenAlertOrForward(this.tabId, this.acctEmail)));\n    // $('.action_microsoft_auth').click(this.setHandlerPrevent('double', function() {\n    //   new_microsoft_account_authentication_prompt(account_email);\n    // }));\n    $('body').click(this.setHandler(() => {\n      this.altAccounts.removeClass('visible');\n      $(\".ion-ios-arrow-down\").removeClass(\"up\");\n      $(\".add-account\").removeClass(\"hidden\");\n    }));\n    $(\".toggle-settings\").click(this.setHandler(() => {\n      $(\"#settings\").toggleClass(\"advanced\");\n    }));\n    let preventAccountsMenuMouseenter = false;\n    $(\".action-toggle-accounts-menu\").click(this.setHandler((target, event) => {\n      event.stopPropagation();\n      if (this.altAccounts.hasClass('visible')) {\n        this.altAccounts.removeClass('visible');\n      } else {\n        this.altAccounts.addClass('visible');\n        this.altAccounts.find('a').first().focus();\n      }\n      $(\".ion-ios-arrow-down\").toggleClass(\"up\");\n      $(\".add-account\").toggleClass(\"hidden\");\n      preventAccountsMenuMouseenter = true; // prevent mouse events when menu is animated with fadeInDown\n      Catch.setHandledTimeout(() => {\n        preventAccountsMenuMouseenter = false;\n      }, 500);\n    }));\n    this.altAccounts.keydown(this.setHandler((el, ev) => this.accountsMenuKeydownHandler(ev)));\n    this.altAccounts.find('a').on('mouseenter', Ui.event.handle((target) => {\n      if (!preventAccountsMenuMouseenter) {\n        $(target).focus();\n      }\n    }));\n    $('#status-row #status_google').click(this.setHandler(async () => await Settings.renderSubPage(this.acctEmail!, this.tabId, 'modules/debug_api.htm', { which: 'google_account' })));\n    $('#status-row #status_local_store').click(this.setHandler(async () => await Settings.renderSubPage(this.acctEmail!, this.tabId, 'modules/debug_api.htm', { which: 'local_store' })));\n    Ui.activateModalPageLinkTags();\n  }\n\n  private accountsMenuKeydownHandler = (e: JQuery.Event<HTMLElement, null>): void => {\n    const currentActive = this.altAccounts.find(':focus');\n    const accounts = this.altAccounts.find('a');\n    if (e.key === 'Escape') {\n      e.stopPropagation();\n      this.altAccounts.removeClass('visible');\n    } else if (e.key === 'ArrowUp') {\n      e.preventDefault();\n      let prev = currentActive.prev();\n      if (!prev.length) {\n        prev = accounts.last();\n      }\n      prev.focus();\n    } else if (e.key === 'ArrowDown') {\n      e.preventDefault();\n      let next = currentActive.next();\n      if (!next.length) {\n        next = accounts.first();\n      }\n      next.focus();\n    }\n  }\n\n  private displayOrig = (selector: string) => {\n    const filterable = $(selector);\n    filterable.filter('a, b, i, img, span, input, label, select').css('display', 'inline-block');\n    filterable.filter('table').css('display', 'table');\n    filterable.filter('tr').css('display', 'table-row');\n    filterable.filter('td').css('display', 'table-cell');\n    filterable.filter('.row').css('display', 'flex');\n    filterable.not('a, b, i, img, span, input, label, select, table, tr, td, .row').css('display', 'block');\n  }\n\n  private initialize = async () => {\n    if (this.addNewAcct) {\n      $('.show_if_setup_not_done').css('display', 'initial');\n      $('.hide_if_setup_not_done').css('display', 'none');\n      await Settings.newGoogleAcctAuthPromptThenAlertOrForward(this.tabId);\n    } else if (this.acctEmail) {\n      $('.email-address').text(this.acctEmail);\n      const storage = await AcctStore.get(this.acctEmail, ['setup_done', 'email_provider', 'picture']);\n      if (storage.setup_done) {\n        const rules = await OrgRules.newInstance(this.acctEmail);\n        if (!rules.canBackupKeys()) {\n          $('.show_settings_page[page=\"modules/backup.htm\"]').parent().remove();\n        }\n        this.checkGoogleAcct().catch(Catch.reportErr);\n        this.checkFcAcctAndSubscriptionAndContactPage().catch(Catch.reportErr);\n        if (storage.picture) {\n          $('img.main-profile-img').attr('src', storage.picture).on('error', this.setHandler(self => {\n            $(self).off().attr('src', '/img/svgs/profile-icon.svg');\n          }));\n        }\n        await this.renderNotificationBanners(storage.email_provider || 'gmail', rules);\n        this.displayOrig('.hide_if_setup_not_done');\n        $('.show_if_setup_not_done').css('display', 'none');\n        if (this.advanced) {\n          $(\"#settings\").toggleClass(\"advanced\");\n        }\n        const privateKeys = await KeyStore.get(this.acctEmail);\n        if (privateKeys.length > 4) {\n          $('.key_list').css('overflow-y', 'scroll');\n        }\n        await this.addKeyRowsHtml(privateKeys);\n      } else {\n        this.displayOrig('.show_if_setup_not_done');\n        $('.hide_if_setup_not_done').css('display', 'none');\n      }\n    } else {\n      const acctEmails = await GlobalStore.acctEmailsGet();\n      if (acctEmails && acctEmails[0]) {\n        window.location.href = Url.create('index.htm', { acctEmail: acctEmails[0] });\n      } else {\n        $('.show_if_setup_not_done').css('display', 'initial');\n        $('.hide_if_setup_not_done').css('display', 'none');\n      }\n    }\n    $('body').addClass('initialized');\n    FlowCryptWebsite.retrieveBlogPosts().then(posts => { // do not await because may take a while\n      for (const post of posts) {\n        const html = `<div class=\"line\"><a href=\"https://flowcrypt.com${Xss.escape(post.url)}\" target=\"_blank\">${Xss.escape(post.title.trim())}</a> ${Xss.escape(post.date.trim())}</div>`;\n        Xss.sanitizeAppend('.blog_post_list', html);\n      }\n    }).catch(ApiErr.reportIfSignificant);\n  }\n\n  private renderNotificationBanners = async (emailProvider: EmailProvider, rules: OrgRules) => {\n    if (!this.acctEmail) {\n      return;\n    }\n    const globalStorage = await GlobalStore.get(['install_mobile_app_notification_dismissed']);\n    if (!globalStorage.install_mobile_app_notification_dismissed && rules.canBackupKeys() && rules.canCreateKeys() && !rules.usesKeyManager()) {\n      // only show this notification if user is allowed to:\n      //   - backup keys: when not allowed, company typically has other forms of backup\n      //   - create keys: when not allowed, key must have been imported from some other system that already takes care of backups\n      // and doesn't use custom key manager, because backups are then taken care of\n      $('.install_app_notification').removeClass('hidden');\n    }\n    $('.dismiss_install_app_notification').click(this.setHandler(async () => {\n      await GlobalStore.set({ install_mobile_app_notification_dismissed: true });\n      $('.install_app_notification').remove();\n    }));\n  }\n\n  private checkFcAcctAndSubscriptionAndContactPage = async () => {\n    const statusContainer = $('.public_profile_indicator_container');\n    const authInfo = await AcctStore.authInfo(this.acctEmail!);\n    if (authInfo.uuid) { // have auth email set\n      try {\n        const acctRes = await this.acctServer!.accountGetAndUpdateLocalStore(authInfo);\n        $('#status-row #status_flowcrypt').text(`fc:ok`);\n        if (acctRes?.account?.alias) {\n          statusContainer.find('.status-indicator-text').css('display', 'none');\n          statusContainer.find('.status-indicator').addClass('active');\n        } else {\n          statusContainer.find('.status-indicator').addClass('inactive');\n        }\n        this.renderSubscriptionStatusHeader(acctRes.subscription);\n      } catch (e) {\n        if (ApiErr.isAuthErr(e)) {\n          const authNeededLink = $('<a class=\"bad\" href=\"#\">Auth Needed</a>');\n          authNeededLink.click(this.setHandler(async () => {\n            await Settings.loginWithPopupShowModalOnErr(this.acctEmail!, () => window.location.reload());\n          }));\n          statusContainer.empty().append(authNeededLink); // xss-direct\n          $('#status-row #status_flowcrypt').text(`fc:auth`).addClass('bad');\n          Settings.offerToLoginWithPopupShowModalOnErr(this.acctEmail!, () => window.location.reload());\n        } else if (ApiErr.isNetErr(e)) {\n          Xss.sanitizeRender(statusContainer, '<a href=\"#\">Network Error - Retry</a>')\n            .find('a').one('click', this.setHandler(() => this.checkFcAcctAndSubscriptionAndContactPage()));\n          $('#status-row #status_flowcrypt').text(`fc:offline`);\n        } else {\n          statusContainer.text('ecp error');\n          $('#status-row #status_flowcrypt').text(`fc:error`).attr('title', `FlowCrypt Account Error: ${Xss.escape(String(e))}`);\n          Catch.reportErr(e);\n        }\n      }\n    } else { // never set up\n      statusContainer.find('.status-indicator').addClass('inactive');\n      $('#status-row #status_flowcrypt').text(`fc:none`);\n    }\n    statusContainer.css('visibility', 'visible');\n  }\n\n  private resolveChangedGoogleAcct = async (newAcctEmail: string) => {\n    try {\n      await Settings.refreshSendAs(this.acctEmail!);\n      await Settings.acctStorageChangeEmail(this.acctEmail!, newAcctEmail);\n      await Ui.modal.info(`Email address changed to ${newAcctEmail}. You should now check that your public key is properly submitted.`);\n      window.location.href = Url.create('index.htm', { acctEmail: newAcctEmail, page: '/chrome/settings/modules/keyserver.htm' });\n    } catch (e) {\n      if (ApiErr.isNetErr(e)) {\n        await Ui.modal.error('There was a network error, please try again.');\n      } else if (ApiErr.isMailOrAcctDisabledOrPolicy(e)) {\n        await Ui.modal.error(Lang.account.googleAcctDisabledOrPolicy);\n      } else if (ApiErr.isAuthErr(e)) {\n        await Ui.modal.warning('New authorization needed. Please try Additional Settings -> Experimental -> Force Google Account email change');\n      } else {\n        Catch.reportErr(e);\n        await Ui.modal.error(`There was an error changing google account, please write human@flowcrypt.com\\n\\n${ApiErr.eli5(e)}\\n\\n${String(e)}`);\n      }\n    }\n  }\n\n  private checkGoogleAcct = async () => {\n    try {\n      const { sendAs } = await this.gmail!.fetchAcctAliases();\n      const primary = sendAs.find(addr => addr.isPrimary === true);\n      if (!primary) {\n        await Ui.modal.warning(`Your account sendAs does not have any primary sendAsEmail`);\n        return;\n      }\n      const googleAcctEmailAddr = primary.sendAsEmail;\n      $('#status-row #status_google').text(`g:${googleAcctEmailAddr}:ok`);\n      if (googleAcctEmailAddr !== this.acctEmail) {\n        $('#status-row #status_google').text(`g:${googleAcctEmailAddr}:changed`).addClass('bad').attr('title', 'Account email address has changed');\n        if (googleAcctEmailAddr && this.acctEmail) {\n          const acctChangedTxt = `Your Google Account address seems to have changed from ${this.acctEmail} to ${googleAcctEmailAddr}. FlowCrypt Settings need to be updated accordingly.`;\n          if (await Ui.modal.confirm(acctChangedTxt)) {\n            await this.resolveChangedGoogleAcct(googleAcctEmailAddr);\n          }\n        }\n      }\n    } catch (e) {\n      if (ApiErr.isAuthErr(e)) {\n        $('#status-row #status_google').text(`g:?:auth`).addClass('bad');\n        if (await Ui.modal.confirm(`FlowCrypt must be re-connected to your Google account.`)) {\n          await Settings.newGoogleAcctAuthPromptThenAlertOrForward(this.tabId, this.acctEmail);\n        }\n      } else if (ApiErr.isMailOrAcctDisabledOrPolicy(e)) {\n        await Ui.modal.error(Lang.account.googleAcctDisabledOrPolicy);\n      } else if (ApiErr.isNetErr(e)) {\n        $('#status-row #status_google').text(`g:?:offline`);\n      } else {\n        $('#status-row #status_google').text(`g:?:err`).addClass('bad').attr('title', `Cannot determine Google account: ${Xss.escape(String(e))}`);\n        Catch.reportErr(e);\n      }\n    }\n  }\n\n  private renderSubscriptionStatusHeader = (subscription: SubscriptionInfo) => {\n    const isActive = subscription.level && !subscription.expired;\n    const activeOrNotStr = isActive ? 'active' : 'inactive';\n    $('#status-row #status_subscription').text(`s:${activeOrNotStr}`);\n    if (isActive) {\n      $('.logo-row .subscription .level').text('advanced').css('display', 'inline-block');\n    } else {\n      $('.logo-row .subscription .level').text('free forever').css('display', 'inline-block');\n      if (subscription.level && subscription.expired) {\n        $('.logo-row .subscription .expire').text('expired').css('display', 'inline-block');\n      }\n    }\n  }\n\n  private addKeyRowsHtml = async (privateKeys: KeyInfo[]) => {\n    let html = '';\n    const canRemoveKey = !this.orgRules || !this.orgRules.usesKeyManager();\n    for (let i = 0; i < privateKeys.length; i++) {\n      const ki = privateKeys[i];\n      const prv = await KeyUtil.parse(ki.private);\n      const created = new Date(prv.created);\n      const date = Str.monthName(created.getMonth()) + ' ' + created.getDate() + ', ' + created.getFullYear();\n      const escapedFp = Xss.escape(ki.fingerprints[0]);\n      let removeKeyBtn = '';\n      if (canRemoveKey && privateKeys.length > 1) {\n        removeKeyBtn = `(<a href=\"#\" class=\"action_remove_key\" data-test=\"action-remove-key\" fingerprint=\"${escapedFp}\">remove</a>)`;\n      }\n      const escapedEmail = Xss.escape(prv.emails[0] || '');\n      const escapedLink = `<a href=\"#\" data-test=\"action-show-key-${i}\" class=\"action_show_key\" page=\"modules/my_key.htm\" addurltext=\"&fingerprint=${escapedFp}\">${escapedEmail}</a>`;\n      const fpHtml = `fingerprint:&nbsp;<span class=\"good\">${Str.spaced(escapedFp)}</span>`;\n      const space = `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`;\n      html += `<div class=\"row key-content-row key_${escapedFp}\">`;\n      html += `  <div class=\"col-12\">${escapedLink} from ${Xss.escape(date)}${space}${fpHtml}${space}${removeKeyBtn}</div>`;\n      html += `</div>`;\n    }\n    Xss.sanitizeAppend('.key_list', html);\n    $('.action_show_key').click(this.setHandler(async target => {\n      // the UI below only gets rendered when account_email is available\n      await Settings.renderSubPage(this.acctEmail!, this.tabId, $(target).attr('page')!, $(target).attr('addurltext') || ''); // all such elements do have page attr\n    }));\n    if (canRemoveKey) {\n      $('.action_remove_key').click(this.setHandler(async target => {\n        // the UI below only gets rendered when account_email is available\n        await KeyStore.remove(this.acctEmail!, $(target).attr('fingerprint')!);\n        await PassphraseStore.set('local', this.acctEmail!, $(target).attr('fingerprint')!, undefined);\n        await PassphraseStore.set('session', this.acctEmail!, $(target).attr('fingerprint')!, undefined);\n        this.reload(true);\n      }));\n    }\n  }\n\n  private reload = (advanced = false) => {\n    if (advanced) {\n      window.location.href = Url.create('/chrome/settings/index.htm', { acctEmail: this.acctEmail, advanced: true });\n    } else {\n      window.location.reload();\n    }\n  }\n\n});\n",
    "extension/chrome/settings/modules/add_key.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { KeyCanBeFixed, KeyImportUi, UserAlert } from '../../../js/common/ui/key-import-ui.js';\nimport { Url } from '../../../js/common/core/common.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Assert } from '../../../js/common/assert.js';\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { Gmail } from '../../../js/common/api/email-provider/gmail/gmail.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { View } from '../../../js/common/view.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { initPassphraseToggle } from '../../../js/common/ui/passphrase-ui.js';\nimport { PassphraseStore } from '../../../js/common/platform/store/passphrase-store.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\nimport { UnexpectedKeyTypeError } from '../../../js/common/core/crypto/key.js';\n\nView.run(class AddKeyView extends View {\n\n  private readonly acctEmail: string;\n  private readonly parentTabId: string;\n  private readonly keyImportUi = new KeyImportUi({ rejectKnown: true });\n  private readonly gmail: Gmail;\n\n  constructor() {\n    super();\n    const uncheckedUrlParams = Url.parse(['acctEmail', 'parentTabId']);\n    this.acctEmail = Assert.urlParamRequire.string(uncheckedUrlParams, 'acctEmail');\n    this.parentTabId = Assert.urlParamRequire.string(uncheckedUrlParams, 'parentTabId');\n    this.gmail = new Gmail(this.acctEmail);\n  }\n\n  public render = async () => {\n    await initPassphraseToggle(['input_passphrase']);\n    this.keyImportUi.initPrvImportSrcForm(this.acctEmail, this.parentTabId);\n    Xss.sanitizeRender('#spinner_container', Ui.spinner('green') + ' loading..');\n    await this.loadAndRenderKeyBackupsOrRenderError();\n    $('.source_selector').css('display', 'block');\n    $('#spinner_container').text('');\n  }\n\n  public setHandlers = () => {\n    $('.action_add_private_key').click(this.setHandlerPrevent('double', this.addPrivateKeyHandler));\n    $('#input_passphrase').keydown(this.setEnterHandlerThatClicks('.action_add_private_key'));\n  }\n\n  private loadAndRenderKeyBackupsOrRenderError = async () => {\n    try {\n      const backups = await this.gmail.fetchKeyBackups();\n      if (!backups.longids.backups.length) {\n        $('label[for=source_backup]').text('Load from backup (no backups found)').css('color', '#AAA');\n        $('#source_backup').prop('disabled', true);\n      } else if (backups.longids.backupsNotImported.length) {\n        $('label[for=source_backup]').text(`Load from backup (${backups.longids.backupsNotImported.length} new to import)`);\n      } else {\n        $('label[for=source_backup]').text(`Load from backup (${backups.longids.backups.length} already loaded)`).css('color', '#AAA');\n        $('#source_backup').prop('disabled', true);\n      }\n    } catch (e) {\n      if (ApiErr.isAuthErr(e)) {\n        BrowserMsg.send.notificationShowAuthPopupNeeded(this.parentTabId, { acctEmail: this.acctEmail });\n      }\n      $('label[for=source_backup]').text('Load from backup (error checking backups)').css('color', '#AAA');\n      $('#source_backup').prop('disabled', true);\n    }\n  }\n\n  private addPrivateKeyHandler = async (submitBtn: HTMLElement) => {\n    if (submitBtn.className.includes('gray')) {\n      await Ui.modal.warning('Please double check the pass phrase input field for any issues.');\n      return;\n    }\n    try {\n      const checked = await this.keyImportUi.checkPrv(this.acctEmail, String($('.input_private_key').val()), String($('.input_passphrase').val()));\n      if (checked) {\n        await KeyStore.add(this.acctEmail, checked.encrypted); // resulting new_key checked above\n        await PassphraseStore.set($('.input_passphrase_save').prop('checked') ? 'local' : 'session', this.acctEmail,\n          checked.fingerprint, checked.passphrase);\n        BrowserMsg.send.reload(this.parentTabId, { advanced: true });\n      }\n    } catch (e) {\n      if (e instanceof UserAlert) {\n        return await Ui.modal.warning(e.message, Ui.testCompatibilityLink);\n      } else if (e instanceof KeyCanBeFixed) {\n        return await Ui.modal.error(`This type of key cannot be set as non-primary yet. Please write human@flowcrypt.com`, false, Ui.testCompatibilityLink);\n      } else if (e instanceof UnexpectedKeyTypeError) {\n        return await Ui.modal.warning(`This does not appear to be a validly formatted key.\\n\\n${e.message}`);\n      } else {\n        Catch.reportErr(e);\n        return await Ui.modal.error(`An error happened when processing the key: ${String(e)}\\nPlease write at human@flowcrypt.com`, false, Ui.testCompatibilityLink);\n      }\n    }\n  }\n});\n",
    "extension/chrome/settings/modules/backup-automatic-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Lang } from '../../../js/common/lang.js';\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { BackupView } from './backup.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport { UnreportableError } from '../../../js/common/platform/catch.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { GoogleAuth } from '../../../js/common/api/email-provider/gmail/google-auth.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\nimport { KeyUtil } from '../../../js/common/core/crypto/key.js';\n\nexport class BackupAutomaticModule extends ViewModule<BackupView> {\n\n  public simpleSetupAutoBackupRetryUntilSuccessful = async () => {\n    try {\n      await this.setupCreateSimpleAutomaticInboxBackup();\n    } catch (e) {\n      return await Settings.promptToRetry(e, Lang.setup.failedToBackUpKey, this.setupCreateSimpleAutomaticInboxBackup);\n    }\n  }\n\n  private setupCreateSimpleAutomaticInboxBackup = async () => {\n    const primaryKi = await KeyStore.getFirstRequired(this.view.acctEmail);\n    if (!(await KeyUtil.parse(primaryKi.private)).fullyEncrypted) {\n      await Ui.modal.warning('Key not protected with a pass phrase, skipping');\n      throw new UnreportableError('Key not protected with a pass phrase, skipping');\n    }\n    try {\n      await this.view.manualModule.doBackupOnEmailProvider(primaryKi.private);\n      await this.view.renderBackupDone();\n    } catch (e) {\n      if (ApiErr.isAuthErr(e)) {\n        await Ui.modal.info(\"Authorization Error. FlowCrypt needs to reconnect your Gmail account\");\n        const connectResult = await GoogleAuth.newAuthPopup({ acctEmail: this.view.acctEmail });\n        if (!connectResult.error) {\n          await this.setupCreateSimpleAutomaticInboxBackup();\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n}\n",
    "extension/chrome/settings/modules/backup-manual-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { BackupView } from './backup.js';\nimport { Attachment } from '../../../js/common/core/attachment.js';\nimport { SendableMsg } from '../../../js/common/api/email-provider/sendable-msg.js';\nimport { GMAIL_RECOVERY_EMAIL_SUBJECTS } from '../../../js/common/core/const.js';\nimport { KeyInfo, KeyUtil } from '../../../js/common/core/crypto/key.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { BrowserMsg, Bm } from '../../../js/common/browser/browser-msg.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { Browser } from '../../../js/common/browser/browser.js';\nimport { Url, PromiseCancellation } from '../../../js/common/core/common.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport { Buf } from '../../../js/common/core/buf.js';\nimport { PassphraseStore } from '../../../js/common/platform/store/passphrase-store.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\n\nexport class BackupManualActionModule extends ViewModule<BackupView> {\n\n  private ppChangedPromiseCancellation: PromiseCancellation = { cancel: false };\n  private readonly proceedBtn = $('#module_manual .action_manual_backup');\n\n  constructor(view: BackupView) {\n    super(view);\n    BrowserMsg.addListener('passphrase_entry', async ({ entered }: Bm.PassphraseEntry) => {\n      if (!entered) {\n        this.ppChangedPromiseCancellation.cancel = true; // update original object which is monitored by a promise\n        this.ppChangedPromiseCancellation = { cancel: false }; // set to a new, not yet used object\n      }\n    });\n    BrowserMsg.listen(this.view.tabId);\n  }\n\n  public setHandlers = () => {\n    $('#module_manual input[name=input_backup_choice]').click(this.view.setHandler(el => this.actionSelectBackupMethodHandler(el)));\n    this.proceedBtn.click(this.view.setHandlerPrevent('double', () => this.actionManualBackupHandler()));\n  }\n\n  public doBackupOnEmailProvider = async (armoredKey: string) => {\n    const emailMsg = String(await $.get({ url: '/chrome/emails/email_intro.template.htm', dataType: 'html' }));\n    const emailAttachments = [this.asBackupFile(armoredKey)];\n    const headers = { from: this.view.acctEmail, recipients: { to: [this.view.acctEmail] }, subject: GMAIL_RECOVERY_EMAIL_SUBJECTS[0] };\n    const msg = await SendableMsg.createPlain(this.view.acctEmail, headers, { 'text/html': emailMsg }, emailAttachments);\n    if (this.view.emailProvider === 'gmail') {\n      return await this.view.gmail.msgSend(msg);\n    } else {\n      throw Error(`Backup method not implemented for ${this.view.emailProvider}`);\n    }\n  }\n\n  private actionManualBackupHandler = async () => {\n    const selected = $('input[type=radio][name=input_backup_choice]:checked').val();\n    const primaryKi = await KeyStore.getFirstRequired(this.view.acctEmail);\n    if (! await this.isPrivateKeyEncrypted(primaryKi)) {\n      await Ui.modal.error('Sorry, cannot back up private key because it\\'s not protected with a pass phrase.');\n      return;\n    }\n    if (selected === 'inbox') {\n      await this.backupOnEmailProviderAndUpdateUi(primaryKi);\n    } else if (selected === 'file') {\n      await this.backupAsFile(primaryKi);\n    } else if (selected === 'print') {\n      await this.backupByBrint();\n    } else {\n      await this.backupRefused();\n    }\n  }\n\n  private asBackupFile = (armoredKey: string) => {\n    return new Attachment({ name: `flowcrypt-backup-${this.view.acctEmail.replace(/[^A-Za-z0-9]+/g, '')}.key`, type: 'application/pgp-keys', data: Buf.fromUtfStr(armoredKey) });\n  }\n\n  private backupOnEmailProviderAndUpdateUi = async (primaryKi: KeyInfo) => {\n    const pp = await PassphraseStore.get(this.view.acctEmail, primaryKi.fingerprints[0]);\n    if (!this.view.parentTabId) {\n      await Ui.modal.error(`Missing parentTabId. Please restart your browser and try again.`);\n      return;\n    }\n    if (!pp) {\n      BrowserMsg.send.passphraseDialog(this.view.parentTabId, { type: 'backup', longids: [primaryKi.longid] });\n      if (! await PassphraseStore.waitUntilPassphraseChanged(this.view.acctEmail, [primaryKi.longid], 1000, this.ppChangedPromiseCancellation)) {\n        return;\n      }\n      await this.backupOnEmailProviderAndUpdateUi(primaryKi);\n      return;\n    }\n    if (!this.isPassPhraseStrongEnough(primaryKi, pp)) {\n      await Ui.modal.warning('Your key is not protected with strong pass phrase.\\n\\nYou should change your pass phrase.');\n      window.location.href = Url.create('/chrome/settings/modules/change_passphrase.htm', { acctEmail: this.view.acctEmail, parentTabId: this.view.parentTabId });\n      return;\n    }\n    const origBtnText = this.proceedBtn.text();\n    Xss.sanitizeRender(this.proceedBtn, Ui.spinner('white'));\n    try {\n      await this.doBackupOnEmailProvider(primaryKi.private);\n    } catch (e) {\n      if (ApiErr.isNetErr(e)) {\n        return await Ui.modal.warning('Need internet connection to finish. Please click the button again to retry.');\n      } else if (ApiErr.isAuthErr(e)) {\n        BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n        return await Ui.modal.warning('Account needs to be re-connected first. Please try later.');\n      } else {\n        Catch.reportErr(e);\n        return await Ui.modal.error(`Error happened: ${String(e)}`);\n      }\n    } finally {\n      this.proceedBtn.text(origBtnText);\n    }\n    await this.view.renderBackupDone();\n  }\n\n  private backupAsFile = async (primaryKi: KeyInfo) => { // todo - add a non-encrypted download option\n    const attachment = this.asBackupFile(primaryKi.private);\n    Browser.saveToDownloads(attachment);\n    await Ui.modal.info('Downloading private key backup file..');\n    await this.view.renderBackupDone();\n  }\n\n  private backupByBrint = async () => { // todo - implement + add a non-encrypted print option\n    throw new Error('not implemented');\n  }\n\n  private backupRefused = async () => {\n    await this.view.renderBackupDone(false);\n  }\n\n  private isPassPhraseStrongEnough = async (ki: KeyInfo, passphrase: string) => {\n    const prv = await KeyUtil.parse(ki.private);\n    if (!prv.fullyEncrypted) {\n      return false;\n    }\n    if (!passphrase) {\n      const pp = prompt('Please enter your pass phrase:');\n      if (!pp) {\n        return false;\n      }\n      if (await KeyUtil.decrypt(prv, pp) !== true) {\n        await Ui.modal.warning('Pass phrase did not match, please try again.');\n        return false;\n      }\n      passphrase = pp;\n    }\n    if (Settings.evalPasswordStrength(passphrase).word.pass === true) {\n      return true;\n    }\n    await Ui.modal.warning('Please change your pass phrase first.\\n\\nIt\\'s too weak for this backup method.');\n    return false;\n  }\n\n  private isPrivateKeyEncrypted = async (ki: KeyInfo) => {\n    const prv = await KeyUtil.parse(ki.private);\n    if (await KeyUtil.decrypt(prv, '', undefined, 'OK-IF-ALREADY-DECRYPTED') === true) {\n      return false;\n    }\n    return prv.fullyEncrypted;\n  }\n\n  private actionSelectBackupMethodHandler = (target: HTMLElement) => {\n    if ($(target).val() === 'inbox') {\n      this.proceedBtn.text('back up as email');\n      this.proceedBtn.removeClass('red').addClass('green');\n    } else if ($(target).val() === 'file') {\n      this.proceedBtn.text('back up as a file');\n      this.proceedBtn.removeClass('red').addClass('green');\n    } else if ($(target).val() === 'print') {\n      this.proceedBtn.text('back up on paper');\n      this.proceedBtn.removeClass('red').addClass('green');\n    } else {\n      this.proceedBtn.text('try my luck');\n      this.proceedBtn.removeClass('green').addClass('red');\n    }\n  }\n\n}\n",
    "extension/chrome/settings/modules/backup-status-module.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { ViewModule } from '../../../js/common/view-module.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { BackupView } from './backup.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Browser } from '../../../js/common/browser/browser.js';\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Backups } from '../../../js/common/api/email-provider/email-provider-api.js';\nimport { KeyInfo } from '../../../js/common/core/crypto/key.js';\nimport { Str } from '../../../js/common/core/common.js';\n\nexport class BackupStatusModule extends ViewModule<BackupView> {\n\n  public setHandlers = () => { // is run after checkAndRenderBackupStatus, which renders (some of) these fields first\n    $('#module_status .action_go_manual').click(this.view.setHandler(() => this.actionShowManualBackupHandler()));\n    $('#module_status .action_go_add_key').click(this.view.setHandler(async () => await this.goTo('add_key.htm')));\n  }\n\n  public checkAndRenderBackupStatus = async () => {\n    try {\n      const backups = await this.view.gmail.fetchKeyBackups();\n      this.view.displayBlock('module_status');\n      this.renderBackupSummaryAndActionButtons(backups);\n      this.renderBackupDetailsText(backups);\n    } catch (e) {\n      if (ApiErr.isNetErr(e)) {\n        Xss.sanitizeRender('#content', `Could not check for backups: no internet. ${Ui.retryLink()}`);\n      } else if (ApiErr.isAuthErr(e)) {\n        if (this.view.parentTabId) {\n          BrowserMsg.send.notificationShowAuthPopupNeeded(this.view.parentTabId, { acctEmail: this.view.acctEmail });\n        }\n        Xss.sanitizeRender('#content', `Could not check for backups: account needs to be re-connected. ${Ui.retryLink()}`);\n      } else {\n        ApiErr.reportIfSignificant(e);\n        Xss.sanitizeRender('#content', `Could not check for backups: ${ApiErr.eli5(e)} (${String(e)}). ${Ui.retryLink()}`);\n      }\n    }\n  }\n\n  private renderBackupSummaryAndActionButtons = (backups: Backups) => {\n    if (!backups.longids.backups.length) {\n      $('.status_summary').text('No backups found on this account. If you lose your device, or it stops working, you will not be able to read your encrypted email.');\n      Xss.sanitizeRender('#module_status .container', '<button class=\"button long green action_go_manual\">BACK UP MY KEY</button>');\n    } else if (backups.longids.importedNotBackedUp.length) {\n      $('.status_summary').text('Some of your keys have not been backed up.');\n      // todo - this would not yet work because currently only backing up first key\n      // Xss.sanitizeRender('#module_status .container', '<button class=\"button long green action_go_manual\">BACK UP MY KEY</button>');\n    } else if (backups.longids.backupsNotImported.length) {\n      $('.status_summary').text('Some of your backups have not been loaded. This may cause incoming encrypted email to not be readable.');\n      Xss.sanitizeRender('#module_status .container', '<button class=\"button long green action_go_add_key\">IMPORT MISSING BACKUPS</button>');\n    } else {\n      $('.status_summary').text('Your account keys are backed up and loaded correctly.');\n      Xss.sanitizeRender('#module_status .container', '<button class=\"button long green action_go_manual\">SEE BACKUP OPTIONS</button>');\n    }\n  }\n\n  private renderBackupDetailsText = (backups: Backups) => {\n    const detailLines = [\n      `Backups total: ${this.describeBackupCounts(backups.longids.backups, backups.keyinfos.backups)}`,\n      `Backups imported: ${backups.longids.backupsImported.length}`,\n    ];\n    if (backups.keyinfos.backupsNotImported.length) {\n      detailLines.push(`Backups left to import: ${this.describeBackupCounts(backups.longids.backupsNotImported, backups.keyinfos.backupsNotImported)}`);\n    }\n    if (backups.keyinfos.importedNotBackedUp.length) {\n      detailLines.push(`Keys missing backup: ${backups.keyinfos.importedNotBackedUp.length}`);\n    }\n    $('pre.status_details').text(detailLines.join('\\n'));\n  }\n\n  private describeBackupCounts = (longids: string[], keyinfos: KeyInfo[]) => {\n    let text = `${longids.length}`;\n    if (keyinfos.length !== longids.length) {\n      text += ` keys represented by ${Str.pluralize(keyinfos.length, 'backup')}`;\n    }\n    return text;\n  }\n\n  private actionShowManualBackupHandler = async () => {\n    this.view.displayBlock('module_manual');\n    $('h1').text('Back up your private key');\n  }\n\n  private goTo = async (page: string) => {\n    await Browser.openSettingsPage('index.htm', this.view.acctEmail, `/chrome/settings/modules/${page}`);\n  }\n\n}\n",
    "extension/chrome/settings/modules/keyserver.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Dict, Url } from '../../../js/common/core/common.js';\n\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Assert } from '../../../js/common/assert.js';\nimport { BrowserMsg } from '../../../js/common/browser/browser-msg.js';\nimport { Lang } from '../../../js/common/lang.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { View } from '../../../js/common/view.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { PubLookup } from '../../../js/common/api/pub-lookup.js';\nimport { OrgRules } from '../../../js/common/org-rules.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\nimport { AcctStore } from '../../../js/common/platform/store/acct-store.js';\nimport { KeyUtil } from '../../../js/common/core/crypto/key.js';\n\ntype AttesterKeyserverDiagnosis = { hasPubkeyMissing: boolean, hasPubkeyMismatch: boolean, results: Dict<{ pubkey?: string, match: boolean }> };\n\nView.run(class KeyserverView extends View {\n\n  private acctEmail: string;\n  private parentTabId: string;\n  private pubLookup!: PubLookup;\n  private orgRules!: OrgRules;\n\n  constructor() {\n    super();\n    const uncheckedUrlParams = Url.parse(['acctEmail', 'parentTabId']);\n    this.acctEmail = Assert.urlParamRequire.string(uncheckedUrlParams, 'acctEmail');\n    this.parentTabId = Assert.urlParamRequire.string(uncheckedUrlParams, 'parentTabId');\n  }\n\n  public render = async () => {\n    this.orgRules = await OrgRules.newInstance(this.acctEmail);\n    this.pubLookup = new PubLookup(this.orgRules);\n    $('.email-address').text(this.acctEmail);\n    Xss.sanitizeRender('.summary', '<br><br><br><br>Loading from keyserver<br><br>' + Ui.spinner('green'));\n    (async () => {\n      const isRefreshed = await Settings.refreshSendAs(this.acctEmail);\n      if (isRefreshed && await Ui.modal.confirm(Lang.general.emailAliasChangedAskForReload)) {\n        window.location.reload();\n      }\n    })().catch(ApiErr.reportIfSignificant);\n    const diagnosis = await this.diagnoseKeyserverPubkeys();\n    $('.summary').text('');\n    for (const email of Object.keys(diagnosis.results)) {\n      const result = diagnosis.results[email];\n      let note, action, color;\n      if (!result.pubkey) {\n        note = 'Missing record. Your contacts will not know you have encryption set up.';\n        action = `<button class=\"button gray2 small action_submit_key\" data-test=\"action-submit-pub\" email=\"${Xss.escape(email)}\">Submit public key</button>`;\n        color = 'orange';\n      } else if (result.match) {\n        note = 'Submitted correctly, can receive encrypted email.';\n        action = '';\n        color = 'green';\n      } else {\n        note = 'Wrong public key recorded. Your incoming email may be unreadable when encrypted.';\n        // todo - pass public key and email in\n        action = `<button class=\"button gray2 small action_replace_pubkey\" email=\"${Xss.escape(email)}\">Correct public records</button>`;\n        color = 'red';\n      }\n      Xss.sanitizeAppend('#content', `<div class=\"line left\">${Xss.escape(email)}: <span class=\"${color}\">${note}</span> ${action}</div>`);\n    }\n  }\n\n  public setHandlers = () => {\n    $('.action_submit_key').click(this.setHandlerPrevent('double', this.submitPublicKeyHandler));\n    $('.action_replace_pubkey').click(this.setHandlerPrevent('double', this.replacePublicKeyHandler));\n  }\n\n  // -- PRIVATE\n\n  private submitPublicKeyHandler = async (target: HTMLElement) => {\n    if (!this.orgRules.canSubmitPubToAttester()) {\n      return await Ui.modal.error('Disallowed by your organisation rules');\n    }\n    Xss.sanitizeRender(target, Ui.spinner('white'));\n    const primaryKi = await KeyStore.getFirstRequired(this.acctEmail);\n    try {\n      await this.pubLookup.attester.initialLegacySubmit(String($(target).attr('email')), primaryKi.public);\n    } catch (e) {\n      ApiErr.reportIfSignificant(e);\n      await Ui.modal.error(ApiErr.eli5(e));\n    } finally {\n      window.location.reload();\n    }\n  }\n\n  private replacePublicKeyHandler = async (target: HTMLElement) => {\n    if (!this.orgRules.canSubmitPubToAttester()) {\n      return await Ui.modal.error('Disallowed by your organisation rules');\n    }\n    Xss.sanitizeRender(target, Ui.spinner('white'));\n    const primaryKi = await KeyStore.getFirstRequired(this.acctEmail);\n    try {\n      const responseText = await this.pubLookup.attester.replacePubkey(String($(target).attr('email')), primaryKi.public);\n      await Ui.modal.info(responseText);\n      BrowserMsg.send.closePage(this.parentTabId);\n    } catch (e) {\n      ApiErr.reportIfSignificant(e);\n      await Ui.modal.error(ApiErr.eli5(e));\n      window.location.reload();\n    }\n  }\n\n  private diagnoseKeyserverPubkeys = async (): Promise<AttesterKeyserverDiagnosis> => {\n    const diagnosis: AttesterKeyserverDiagnosis = { hasPubkeyMissing: false, hasPubkeyMismatch: false, results: {} };\n    const { sendAs } = await AcctStore.get(this.acctEmail, ['sendAs']);\n    const storedKeys = await KeyStore.get(this.acctEmail);\n    const storedKeysIds = storedKeys.map(ki => ki.fingerprints[0]);\n    const results = await this.pubLookup.attester.lookupEmails(sendAs ? Object.keys(sendAs) : [this.acctEmail]);\n    for (const email of Object.keys(results)) {\n      const pubkeySearchResult = results[email];\n      if (!pubkeySearchResult.pubkey) {\n        diagnosis.hasPubkeyMissing = true;\n        diagnosis.results[email] = { pubkey: undefined, match: false };\n      } else {\n        const pub = await KeyUtil.parse(pubkeySearchResult.pubkey);\n        let match = true;\n        if (!storedKeysIds.includes(pub.id)) {\n          diagnosis.hasPubkeyMismatch = true;\n          match = false;\n        }\n        diagnosis.results[email] = { pubkey: pubkeySearchResult.pubkey, match };\n      }\n    }\n    return diagnosis;\n  }\n\n});\n",
    "extension/chrome/settings/modules/my_key.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Assert } from '../../../js/common/assert.js';\nimport { Attachment } from '../../../js/common/core/attachment.js';\nimport { Browser } from '../../../js/common/browser/browser.js';\nimport { Buf } from '../../../js/common/core/buf.js';\nimport { KeyInfo, Key, KeyUtil } from '../../../js/common/core/crypto/key.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Url, Str } from '../../../js/common/core/common.js';\nimport { View } from '../../../js/common/view.js';\nimport { initPassphraseToggle } from '../../../js/common/ui/passphrase-ui.js';\nimport { PubLookup } from '../../../js/common/api/pub-lookup.js';\nimport { OrgRules } from '../../../js/common/org-rules.js';\nimport { PassphraseStore } from '../../../js/common/platform/store/passphrase-store.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { FlowCryptWebsite } from '../../../js/common/api/flowcrypt-website.js';\n\ndeclare const ClipboardJS: any;\n\nView.run(class MyKeyView extends View {\n\n  private readonly acctEmail: string;\n  private readonly fingerprint: string;\n  private readonly myKeyUserIdsUrl: string;\n  private readonly myKeyUpdateUrl: string;\n  private keyInfo!: KeyInfo;\n  private pubKey!: Key;\n  private orgRules!: OrgRules;\n  private pubLookup!: PubLookup;\n\n  constructor() {\n    super();\n    const uncheckedUrlParams = Url.parse(['acctEmail', 'fingerprint', 'parentTabId']);\n    this.acctEmail = Assert.urlParamRequire.string(uncheckedUrlParams, 'acctEmail');\n    this.fingerprint = Assert.urlParamRequire.string(uncheckedUrlParams, 'fingerprint');\n    this.myKeyUserIdsUrl = Url.create('my_key_user_ids.htm', uncheckedUrlParams);\n    this.myKeyUpdateUrl = Url.create('my_key_update.htm', uncheckedUrlParams);\n  }\n\n  public render = async () => {\n    this.orgRules = await OrgRules.newInstance(this.acctEmail);\n    this.pubLookup = new PubLookup(this.orgRules);\n    [this.keyInfo] = await KeyStore.get(this.acctEmail, [this.fingerprint]);\n    Assert.abortAndRenderErrorIfKeyinfoEmpty(this.keyInfo);\n    this.pubKey = await KeyUtil.parse(this.keyInfo.public);\n    $('.action_view_user_ids').attr('href', this.myKeyUserIdsUrl);\n    $('.action_view_update').attr('href', this.myKeyUpdateUrl);\n    $('.fingerprint').text(Str.spaced(this.keyInfo.fingerprints[0]));\n    Xss.sanitizeRender('.email', this.pubKey.emails.map(email => `<span>${Xss.escape(email)}</span>`).join(', '));\n    const expiration = this.pubKey.expiration;\n    $('.key_expiration').text(expiration && expiration !== Infinity ? Str.datetimeToDate(Str.fromDate(new Date(expiration))) : 'Key does not expire');\n    await this.renderPubkeyShareableLink();\n    await initPassphraseToggle(['input_passphrase']);\n  }\n\n  public setHandlers = () => {\n    $('.action_download_pubkey').click(this.setHandlerPrevent('double', () => this.downloadPubKeyHandler()));\n    $('.action_download_prv').click(this.setHandlerPrevent('double', () => this.downloadPrvKeyHandler()));\n    $('.action_download_revocation_cert').click(this.setHandlerPrevent('double', () => this.downloadRevocationCert()));\n    $('.action_continue_download').click(this.setHandlerPrevent('double', () => this.downloadRevocationCert(String($('#input_passphrase').val()))));\n    $('#input_passphrase').on('keydown', this.setEnterHandlerThatClicks('.action_continue_download'));\n    $('.action_cancel_download_cert').click(this.setHandler(() => { $('.enter_pp').hide(); }));\n    const clipboardOpts = { text: () =>  this.keyInfo.public };\n    new ClipboardJS('.action_copy_pubkey', clipboardOpts); // tslint:disable-line:no-unused-expression no-unsafe-any\n  }\n\n  private renderPubkeyShareableLink = async () => {\n    try {\n      const result = await this.pubLookup.attester.lookupEmail(this.acctEmail);\n      const url = FlowCryptWebsite.url('pubkey', this.acctEmail);\n      if (result.pubkey && (await KeyUtil.parse(result.pubkey)).id === this.keyInfo.fingerprints[0]) {\n        $('.pubkey_link_container a').text(url.replace('https://', '')).attr('href', url).parent().css('display', '');\n      } else {\n        $('.pubkey_link_container').remove();\n      }\n    } catch (e) {\n      ApiErr.reportIfSignificant(e);\n      $('.pubkey_link_container').remove();\n    }\n  }\n\n  private downloadRevocationCert = async (enteredPP?: string) => {\n    const prv = await KeyUtil.parse(this.keyInfo.private);\n    if (!prv.fullyDecrypted) {\n      const passphrase = await PassphraseStore.get(this.acctEmail, this.keyInfo.fingerprints[0]) || enteredPP;\n      if (passphrase) {\n        if (! await KeyUtil.decrypt(prv, passphrase) && enteredPP) {\n          await Ui.modal.error('Pass phrase did not match, please try again.');\n          return;\n        }\n      } else {\n        $('.enter_pp').show();\n        return;\n      }\n    }\n    $('.enter_pp').hide();\n    $('#input_passphrase').val('');\n    let revokeConfirmMsg = `Revocation cert is used when you want to revoke your Public Key (meaning you are asking others to stop using it).\\n\\n`;\n    revokeConfirmMsg += `You can save it do your hard drive, and use it later in case you ever need it.\\n\\n`;\n    revokeConfirmMsg += `Would you like to generate and save a revocation cert now?`;\n    if (! await Ui.modal.confirm(revokeConfirmMsg)) {\n      return;\n    }\n    const revokedArmored = await KeyUtil.revoke(prv);\n    if (!revokedArmored) {\n      await Ui.modal.error(`Could not produce revocation cert (empty)`);\n      return;\n    }\n    const name = `${this.acctEmail.replace(/[^a-z0-9]+/g, '')}-0x${this.keyInfo.longid}.revocation-cert.asc`;\n    const prvKeyAttachment = new Attachment({ data: Buf.fromUtfStr(revokedArmored), type: 'application/pgp-keys', name });\n    Browser.saveToDownloads(prvKeyAttachment);\n  }\n\n  private downloadPubKeyHandler = () => {\n    Browser.saveToDownloads(Attachment.keyinfoAsPubkeyAttachment(this.keyInfo));\n  }\n\n  private downloadPrvKeyHandler = () => {\n    const name = `flowcrypt-backup-${this.acctEmail.replace(/[^A-Za-z0-9]+/g, '')}-0x${this.keyInfo.longid}.asc`;\n    const prvKeyAttachment = new Attachment({ data: Buf.fromUtfStr(this.keyInfo.private), type: 'application/pgp-keys', name });\n    Browser.saveToDownloads(prvKeyAttachment);\n  }\n\n});\n",
    "extension/chrome/settings/modules/my_key_update.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Assert } from '../../../js/common/assert.js';\nimport { KeyInfo, Key, KeyUtil } from '../../../js/common/core/crypto/key.js';\nimport { Lang } from '../../../js/common/lang.js';\nimport { PgpArmor } from '../../../js/common/core/crypto/pgp/pgp-armor.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Url, Str } from '../../../js/common/core/common.js';\nimport { View } from '../../../js/common/view.js';\nimport { OrgRules } from '../../../js/common/org-rules.js';\nimport { PubLookup } from '../../../js/common/api/pub-lookup.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\nimport { PassphraseStore } from '../../../js/common/platform/store/passphrase-store.js';\n\nView.run(class MyKeyUpdateView extends View {\n\n  private readonly acctEmail: string;\n  private readonly fingerprint: string;\n  private readonly showKeyUrl: string;\n  private readonly inputPrivateKey = $('.input_private_key');\n  private readonly prvHeaders = PgpArmor.headers('privateKey');\n  private primaryKi: KeyInfo | undefined;\n  private orgRules!: OrgRules;\n  private pubLookup!: PubLookup;\n\n  constructor() {\n    super();\n    const uncheckedUrlParams = Url.parse(['acctEmail', 'fingerprint', 'parentTabId']);\n    this.acctEmail = Assert.urlParamRequire.string(uncheckedUrlParams, 'acctEmail');\n    this.fingerprint = Assert.urlParamRequire.string(uncheckedUrlParams, 'fingerprint');\n    this.showKeyUrl = Url.create('my_key.htm', uncheckedUrlParams);\n  }\n\n  public render = async () => {\n    this.orgRules = await OrgRules.newInstance(this.acctEmail);\n    this.pubLookup = new PubLookup(this.orgRules);\n    [this.primaryKi] = await KeyStore.get(this.acctEmail, [this.fingerprint]);\n    Assert.abortAndRenderErrorIfKeyinfoEmpty(this.primaryKi);\n    $('.action_show_public_key').attr('href', this.showKeyUrl);\n    $('.email').text(this.acctEmail);\n    $('.fingerprint').text(Str.spaced(this.primaryKi.fingerprints[0]));\n    this.inputPrivateKey.attr('placeholder', this.inputPrivateKey.attr('placeholder') + ' (' + this.primaryKi.fingerprints[0] + ')');\n  }\n\n  public setHandlers = () => {\n    $('.action_update_private_key').click(this.setHandlerPrevent('double', () => this.updatePrivateKeyHandler()));\n    $('.input_passphrase').keydown(this.setEnterHandlerThatClicks('.action_update_private_key'));\n  }\n\n  private storeUpdatedKeyAndPassphrase = async (updatedPrv: Key, updatedPrvPassphrase: string) => {\n    const storedPassphrase = await PassphraseStore.get(this.acctEmail, this.primaryKi!.fingerprints[0], true);\n    await KeyStore.add(this.acctEmail, updatedPrv);\n    await PassphraseStore.set('local', this.acctEmail, this.primaryKi!.fingerprints[0], typeof storedPassphrase !== 'undefined' ? updatedPrvPassphrase : undefined);\n    await PassphraseStore.set('session', this.acctEmail, this.primaryKi!.fingerprints[0], typeof storedPassphrase !== 'undefined' ? undefined : updatedPrvPassphrase);\n    if (this.orgRules.canSubmitPubToAttester() && await Ui.modal.confirm('Public and private key updated locally.\\n\\nUpdate public records with new Public Key?')) {\n      try {\n        await Ui.modal.info(await this.pubLookup.attester.updatePubkey(this.primaryKi!.longid, KeyUtil.armor(await KeyUtil.asPublicKey(updatedPrv))));\n      } catch (e) {\n        ApiErr.reportIfSignificant(e);\n        await Ui.modal.error(`Error updating public records:\\n\\n${ApiErr.eli5(e)}\\n\\n(but local update was successful)`);\n      }\n    }\n    window.location.href = this.showKeyUrl;\n  }\n\n  private updatePrivateKeyHandler = async () => {\n    const updatedKey = await KeyUtil.parse(String(this.inputPrivateKey.val()));\n    const updatedKeyEncrypted = await KeyUtil.parse(String(this.inputPrivateKey.val()));\n    const uddatedKeyPassphrase = String($('.input_passphrase').val());\n    if (typeof updatedKey === 'undefined') {\n      await Ui.modal.warning(Lang.setup.keyFormattedWell(this.prvHeaders.begin, String(this.prvHeaders.end)), Ui.testCompatibilityLink);\n    } else if (updatedKey.isPublic) {\n      await Ui.modal.warning('This was a public key. Please insert a private key instead. It\\'s a block of text starting with \"' + this.prvHeaders.begin + '\"');\n    } else if (updatedKey.id !== (await KeyUtil.parse(this.primaryKi!.public)).id) {\n      await Ui.modal.warning(`This key ${Str.spaced(updatedKey.id || 'err')} does not match your current key ${Str.spaced(this.primaryKi!.fingerprints[0])}`);\n    } else if (await KeyUtil.decrypt(updatedKey, uddatedKeyPassphrase) !== true) {\n      await Ui.modal.error('The pass phrase does not match.\\n\\nPlease enter pass phrase of the newly updated key.');\n    } else {\n      if (updatedKey.usableForEncryption) {\n        await this.storeUpdatedKeyAndPassphrase(updatedKeyEncrypted, uddatedKeyPassphrase);\n        return;\n      }\n      // cannot get a valid encryption key packet\n      if (await KeyUtil.isWithoutSelfCertifications(updatedKey) || updatedKey.usableForEncryptionButExpired) { // known issues - key can be fixed\n        const fixedEncryptedPrv = await Settings.renderPrvCompatFixUiAndWaitTilSubmittedByUser(\n          this.acctEmail, '.compatibility_fix_container', updatedKeyEncrypted, uddatedKeyPassphrase, this.showKeyUrl\n        );\n        await this.storeUpdatedKeyAndPassphrase(fixedEncryptedPrv, uddatedKeyPassphrase);\n      } else {\n        await Ui.modal.warning(\n          'Key update: This looks like a valid key but it cannot be used for encryption. Email human@flowcrypt.com to see why is that. We\\'re prompt to respond.',\n          Ui.testCompatibilityLink\n        );\n        window.location.href = this.showKeyUrl;\n      }\n    }\n  }\n\n});\n",
    "extension/chrome/settings/setup/setup-create-key.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { SetupOptions, SetupView } from '../setup.js';\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { Lang } from '../../../js/common/lang.js';\nimport { KeyAlgo, KeyUtil } from '../../../js/common/core/crypto/key.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Url } from '../../../js/common/core/common.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { shouldPassPhraseBeHidden } from '../../../js/common/ui/passphrase-ui.js';\nimport { AcctStore } from '../../../js/common/platform/store/acct-store.js';\nimport { OpenPGPKey } from '../../../js/common/core/crypto/pgp/openpgp-key.js';\n\nexport class SetupCreateKeyModule {\n\n  constructor(private view: SetupView) {\n  }\n\n  public actionCreateKeyHandler = async () => {\n    await Settings.forbidAndRefreshPageIfCannot('CREATE_KEYS', this.view.orgRules);\n    if (! await this.isCreatePrivateFormInputCorrect()) {\n      return;\n    }\n    try {\n      $('#step_2a_manual_create input').prop('disabled', true);\n      Xss.sanitizeRender('#step_2a_manual_create .action_create_private', Ui.spinner('white') + 'just a minute');\n      const opts: SetupOptions = {\n        passphrase: String($('#step_2a_manual_create .input_password').val()),\n        passphrase_save: Boolean($('#step_2a_manual_create .input_passphrase_save').prop('checked')),\n        submit_main: this.view.shouldSubmitPubkey('#step_2a_manual_create .input_submit_key'),\n        submit_all: this.view.shouldSubmitPubkey('#step_2a_manual_create .input_submit_all'),\n        recovered: false,\n      };\n      const keyAlgo = this.view.orgRules.getEnforcedKeygenAlgo() || $('#step_2a_manual_create .key_type').val() as KeyAlgo;\n      await this.createSaveKeyPair(opts, keyAlgo);\n      if (this.view.orgRules.canBackupKeys()) {\n        await this.view.preFinalizeSetup(opts);\n        const action = $('#step_2a_manual_create .input_backup_inbox').prop('checked') ? 'setup_automatic' : 'setup_manual';\n        // only finalize after backup is done. backup.htm will redirect back to this page with ?action=finalize\n        window.location.href = Url.create('modules/backup.htm', { action, acctEmail: this.view.acctEmail, idToken: this.view.idToken });\n      } else {\n        await this.view.submitPublicKeysAndFinalizeSetup(opts);\n        await this.view.setupRender.renderSetupDone();\n      }\n    } catch (e) {\n      Catch.reportErr(e);\n      await Ui.modal.error(`There was an error, please try again.\\n\\n(${String(e)})`);\n      $('#step_2a_manual_create .action_create_private').text('CREATE AND SAVE');\n    }\n  }\n\n  public actionShowAdvancedSettingsHandle = async (target: HTMLElement) => {\n    const advancedCreateSettings = $('#step_2a_manual_create .advanced_create_settings');\n    const container = $('#step_2a_manual_create .advanced_create_settings_container');\n    if (advancedCreateSettings.is(':visible')) {\n      advancedCreateSettings.hide('fast');\n      $(target).find('span').text('Show Advanced Settings');\n      container.css('width', '360px');\n    } else {\n      advancedCreateSettings.show('fast');\n      $(target).find('span').text('Hide Advanced Settings');\n      container.css('width', 'auto');\n    }\n  }\n\n  public createSaveKeyPair = async (options: SetupOptions, keyAlgo: KeyAlgo) => {\n    await Settings.forbidAndRefreshPageIfCannot('CREATE_KEYS', this.view.orgRules);\n    const { full_name } = await AcctStore.get(this.view.acctEmail, ['full_name']);\n    const pgpUids = [{ name: full_name || '', email: this.view.acctEmail }]; // todo - add all addresses?\n    const expireMonths = this.view.orgRules.getEnforcedKeygenExpirationMonths();\n    try {\n      const key = await OpenPGPKey.create(pgpUids, keyAlgo, options.passphrase, expireMonths);\n      const prv = await KeyUtil.parse(key.private);\n      await this.view.saveKeysAndPassPhrase([prv], options);\n    } catch (e) {\n      Catch.reportErr(e);\n      Xss.sanitizeRender('#step_2_easy_generating, #step_2a_manual_create', Lang.setup.fcDidntSetUpProperly);\n    }\n  }\n\n  private isCreatePrivateFormInputCorrect = async () => {\n    const password1 = $('#step_2a_manual_create .input_password');\n    const password2 = $('#step_2a_manual_create .input_password2');\n    if (!password1.val()) {\n      await Ui.modal.warning('Pass phrase is needed to protect your private email. Please enter a pass phrase.');\n      password1.focus();\n      return false;\n    }\n    if ($('#step_2a_manual_create .action_create_private').hasClass('gray')) {\n      await Ui.modal.warning('Pass phrase is not strong enough. Please make it stronger, by adding a few words.');\n      password1.focus();\n      return false;\n    }\n    if (password1.val() !== password2.val()) {\n      await Ui.modal.warning('The pass phrases do not match. Please try again.');\n      password2.val('').focus();\n      return false;\n    }\n    let notePp = String(password1.val());\n    if (await shouldPassPhraseBeHidden()) {\n      notePp = notePp.substring(0, 2) + notePp.substring(2, notePp.length - 2).replace(/[^ ]/g, '*') + notePp.substring(notePp.length - 2, notePp.length);\n    }\n    const paperPassPhraseStickyNote = `\n      <div style=\"font-size: 1.2em\">\n        Please write down your pass phrase and store it in safe place or even two.\n        It is needed in order to access your FlowCrypt account.\n      </div>\n      <div class=\"passphrase-sticky-note\">${notePp}</div>\n    `;\n    return await Ui.modal.confirmWithCheckbox('Yes, I wrote it down', paperPassPhraseStickyNote);\n  }\n\n}\n",
    "extension/chrome/settings/setup/setup-import-key.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { KeyCanBeFixed, UserAlert } from '../../../js/common/ui/key-import-ui.js';\nimport { SetupOptions, SetupView } from '../setup.js';\n\nimport { Catch } from '../../../js/common/platform/catch.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { Key, UnexpectedKeyTypeError } from '../../../js/common/core/crypto/key.js';\n\nexport class SetupImportKeyModule {\n\n  constructor(private view: SetupView) {\n  }\n\n  public actionImportPrivateKeyHandle = async (button: HTMLElement) => {\n    if (button.className.includes('gray')) {\n      await Ui.modal.warning('Please double check the pass phrase input field for any issues.');\n      return;\n    }\n    const options: SetupOptions = {\n      passphrase: String($('#step_2b_manual_enter .input_passphrase').val()),\n      submit_main: this.view.shouldSubmitPubkey('#step_2b_manual_enter .input_submit_key'),\n      submit_all: this.view.shouldSubmitPubkey('#step_2b_manual_enter .input_submit_all'),\n      passphrase_save: Boolean($('#step_2b_manual_enter .input_passphrase_save').prop('checked')),\n      recovered: false,\n    };\n    try {\n      const checked = await this.view.keyImportUi.checkPrv(this.view.acctEmail, String($('#step_2b_manual_enter .input_private_key').val()), options.passphrase);\n      Xss.sanitizeRender('#step_2b_manual_enter .action_add_private_key', Ui.spinner('white'));\n      await this.view.saveKeysAndPassPhrase([checked.encrypted], options);\n      await this.view.preFinalizeSetup(options);\n      await this.view.submitPublicKeysAndFinalizeSetup(options);\n      await this.view.setupRender.renderSetupDone();\n    } catch (e) {\n      if (e instanceof UserAlert) {\n        return await Ui.modal.warning(e.message, Ui.testCompatibilityLink);\n      } else if (e instanceof KeyCanBeFixed) {\n        return await this.renderCompatibilityFixBlockAndFinalizeSetup(e.encrypted, options);\n      } else if (e instanceof UnexpectedKeyTypeError) {\n        return await Ui.modal.warning(`This does not appear to be a validly formatted key.\\n\\n${e.message}`);\n      } else {\n        Catch.reportErr(e);\n        return await Ui.modal.error(`An error happened when processing the key: ${String(e)}\\nPlease write at human@flowcrypt.com`, false, Ui.testCompatibilityLink);\n      }\n    }\n  }\n\n  public renderCompatibilityFixBlockAndFinalizeSetup = async (origPrv: Key, options: SetupOptions) => {\n    this.view.setupRender.displayBlock('step_3_compatibility_fix');\n    let fixedPrv;\n    try {\n      fixedPrv = await Settings.renderPrvCompatFixUiAndWaitTilSubmittedByUser(\n        this.view.acctEmail, '#step_3_compatibility_fix', origPrv, options.passphrase, window.location.href.replace(/#$/, ''));\n    } catch (e) {\n      Catch.reportErr(e);\n      await Ui.modal.error(`Failed to fix key (${String(e)}). Please write us at human@flowcrypt.com, we are very prompt to fix similar issues.`, false, Ui.testCompatibilityLink);\n      this.view.setupRender.displayBlock('step_2b_manual_enter');\n      return;\n    }\n    await this.view.saveKeysAndPassPhrase([fixedPrv], options);\n    await this.view.preFinalizeSetup(options);\n    await this.view.submitPublicKeysAndFinalizeSetup(options);\n    await this.view.setupRender.renderSetupDone();\n  }\n}\n",
    "extension/chrome/settings/setup/setup-key-manager-autogen.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { SetupOptions, SetupView } from '../setup.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Url } from '../../../js/common/core/common.js';\nimport { AcctStore } from '../../../js/common/platform/store/acct-store.js';\nimport { Buf } from '../../../js/common/core/buf.js';\nimport { PgpPwd } from '../../../js/common/core/crypto/pgp/pgp-password.js';\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Api } from '../../../js/common/api/shared/api.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport { KeyUtil } from '../../../js/common/core/crypto/key.js';\nimport { OpenPGPKey } from '../../../js/common/core/crypto/pgp/openpgp-key.js';\n\nexport class SetupWithEmailKeyManagerModule {\n\n  constructor(private view: SetupView) {\n  }\n\n  public setupWithEkmThenRenderSetupDone = async () => {\n    if (!this.view.orgRules.mustAutogenPassPhraseQuietly()) {\n      const notSupportedErr = 'Combination of org rules not yet supported: PRV_AUTOIMPORT_OR_AUTOGEN cannot yet be used without PASS_PHRASE_QUIET_AUTOGEN.';\n      await Ui.modal.error(`${notSupportedErr}\\n\\nPlease write human@flowcrypt.com to add support.`);\n      window.location.href = Url.create('index.htm', { acctEmail: this.view.acctEmail });\n      return;\n    }\n    const passphrase = PgpPwd.random(); // mustAutogenPassPhraseQuietly\n    const setupOptions: SetupOptions = { passphrase_save: true, submit_main: this.view.orgRules.canSubmitPubToAttester(), submit_all: false, passphrase };\n    try {\n      const { privateKeys } = await this.view.keyManager!.getPrivateKeys(this.view.idToken!);\n      if (privateKeys.length) {\n        // keys already exist on keyserver, auto-import\n        await this.processAndStoreKeysFromEkmLocally(privateKeys, setupOptions);\n      } else {\n        // generate keys on client and store them on key manager\n        await this.autoGenerateKeyAndStoreBothLocallyAndToEkm(setupOptions);\n      }\n      await this.view.submitPublicKeysAndFinalizeSetup(setupOptions);\n      await this.view.setupRender.renderSetupDone();\n    } catch (e) {\n      if (ApiErr.isNetErr(e) && await Api.isInternetAccessible()) { // frendly message when key manager is down, helpful during initial infrastructure setup\n        e.message = `FlowCrypt Email Key Manager at ${this.view.orgRules.getKeyManagerUrlForPrivateKeys()} is down, please inform your network admin.`;\n      }\n      throw e;\n    }\n  }\n\n  private processAndStoreKeysFromEkmLocally = async (privateKeys: { decryptedPrivateKey: string }[], setupOptions: SetupOptions) => {\n    const { keys } = await KeyUtil.readMany(Buf.fromUtfStr(privateKeys.map(pk => pk.decryptedPrivateKey).join('\\n')));\n    if (!keys.length) {\n      throw new Error(`Could not parse any valid keys from Key Manager response for user ${this.view.acctEmail}`);\n    }\n    for (const prv of keys) {\n      if (!prv.isPrivate) {\n        throw new Error(`Key ${prv.id} for user ${this.view.acctEmail} is not a private key`);\n      }\n      if (!prv.fullyDecrypted) {\n        throw new Error(`Key ${prv.id} for user ${this.view.acctEmail} from FlowCrypt Email Key Manager is not fully decrypted`);\n      }\n      await KeyUtil.encrypt(prv, setupOptions.passphrase);\n    }\n    await this.view.saveKeysAndPassPhrase(keys, setupOptions);\n  }\n\n  private autoGenerateKeyAndStoreBothLocallyAndToEkm = async (setupOptions: SetupOptions) => {\n    const keygenAlgo = this.view.orgRules.getEnforcedKeygenAlgo();\n    if (!keygenAlgo) {\n      const notSupportedErr = 'Combination of org rules not yet supported: PRV_AUTOIMPORT_OR_AUTOGEN cannot yet be used without enforce_keygen_algo.';\n      await Ui.modal.error(`${notSupportedErr}\\n\\nPlease write human@flowcrypt.com to add support.`);\n      window.location.href = Url.create('index.htm', { acctEmail: this.view.acctEmail });\n      return;\n    }\n    const { full_name } = await AcctStore.get(this.view.acctEmail, ['full_name']);\n    const expireInMonths = this.view.orgRules.getEnforcedKeygenExpirationMonths();\n    const pgpUids = [{ name: full_name || '', email: this.view.acctEmail }];\n    const generated = await OpenPGPKey.create(pgpUids, keygenAlgo, setupOptions.passphrase, expireInMonths);\n    const decryptablePrv = await KeyUtil.parse(generated.private);\n    if (! await KeyUtil.decrypt(decryptablePrv, setupOptions.passphrase)) {\n      throw new Error('Unexpectedly cannot decrypt newly generated key');\n    }\n    const pubArmor = KeyUtil.armor(await KeyUtil.asPublicKey(decryptablePrv));\n    const storePrvOnKm = async () => this.view.keyManager!.storePrivateKey(this.view.idToken!, KeyUtil.armor(decryptablePrv), pubArmor);\n    await Settings.retryUntilSuccessful(storePrvOnKm, 'Failed to store newly generated key on FlowCrypt Email Key Manager');\n    await this.view.saveKeysAndPassPhrase([await KeyUtil.parse(generated.private)], setupOptions); // store encrypted key + pass phrase locally\n  }\n\n}\n",
    "extension/chrome/settings/setup/setup-recover-key.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { SetupOptions, SetupView } from '../setup.js';\n\nimport { ApiErr } from '../../../js/common/api/shared/api-error.js';\nimport { Lang } from '../../../js/common/lang.js';\nimport { Key, KeyUtil } from '../../../js/common/core/crypto/key.js';\nimport { Ui } from '../../../js/common/browser/ui.js';\nimport { Url } from '../../../js/common/core/common.js';\nimport { Xss } from '../../../js/common/platform/xss.js';\nimport { AcctStore } from '../../../js/common/platform/store/acct-store.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\n\nexport class SetupRecoverKeyModule {\n\n  constructor(private view: SetupView) {\n  }\n\n  public actionRecoverAccountHandler = async () => {\n    try {\n      const passphrase = String($('#recovery_pasword').val());\n      const newlyMatchingKeys: Key[] = [];\n      if (passphrase && this.view.mathingPassphrases.includes(passphrase)) {\n        await Ui.modal.warning(Lang.setup.tryDifferentPassPhraseForRemainingBackups);\n        return;\n      }\n      if (!passphrase) {\n        await Ui.modal.warning('Please enter the pass phrase you used when you first set up FlowCrypt, so that we can recover your original keys.');\n        return;\n      }\n      let matchedPreviouslyRecoveredKey = false;\n      for (const fetchedKey of this.view.fetchedKeyBackups) {\n        if (await KeyUtil.checkPassPhrase(fetchedKey.private, passphrase) === true) {\n          if (!this.view.mathingPassphrases.includes(passphrase)) {\n            this.view.mathingPassphrases.push(passphrase);\n          }\n          if (!this.view.importedKeysUniqueLongids.includes(fetchedKey.longid)) {\n            const prv = await KeyUtil.parse(fetchedKey.private);\n            newlyMatchingKeys.push(prv);\n            this.view.importedKeysUniqueLongids.push(fetchedKey.longid);\n          } else {\n            matchedPreviouslyRecoveredKey = true;\n          }\n        }\n      }\n      if (!newlyMatchingKeys.length) {\n        if (matchedPreviouslyRecoveredKey) {\n          $('#recovery_pasword').val('');\n          await Ui.modal.warning('This is a correct pass phrase, but it matches a key that was already recovered. Please try another pass phrase.');\n        } else if (this.view.fetchedKeyBackupsUniqueLongids.length > 1) {\n          await Ui.modal.warning(`This pass phrase did not match any of your ${this.view.fetchedKeyBackupsUniqueLongids.length} backed up keys. Please try again.`);\n        } else {\n          await Ui.modal.warning('This pass phrase did not match your original setup. Please try again.');\n        }\n        return;\n      }\n      const options: SetupOptions = {\n        submit_main: false, // todo - reevaluate submitting when recovering\n        submit_all: false,\n        passphrase,\n        passphrase_save: true, // todo - reevaluate saving passphrase when recovering\n        recovered: true,\n      };\n      await this.view.saveKeysAndPassPhrase(newlyMatchingKeys, options);\n      const { setup_done } = await AcctStore.get(this.view.acctEmail, ['setup_done']);\n      if (!setup_done) { // normal situation - fresh setup\n        await this.view.preFinalizeSetup(options);\n        await this.view.submitPublicKeysAndFinalizeSetup(options);\n        await this.view.setupRender.renderSetupDone();\n      } else { // setup was finished before, just added more keys now\n        await this.view.setupRender.renderSetupDone();\n      }\n    } catch (e) {\n      ApiErr.reportIfSignificant(e);\n      await Ui.modal.error(`Error setting up FlowCrypt:\\n\\n${ApiErr.eli5(e)} (${String(e)})\\n\\nPlease write human@flowcrypt.com if this happens repeatedly.`);\n    }\n  }\n\n  public actionRecoverRemainingKeysHandler = async () => {\n    this.view.setupRender.displayBlock('step_2_recovery');\n    $('#recovery_pasword').val('');\n    const nImported = (await KeyStore.get(this.view.acctEmail)).length;\n    const nFetched = this.view.fetchedKeyBackupsUniqueLongids.length;\n    const txtKeysTeft = (nFetched - nImported > 1) ? `are ${nFetched - nImported} backups` : 'is one backup';\n    if (this.view.action !== 'add_key') {\n      Xss.sanitizeRender('#step_2_recovery .recovery_status', Lang.setup.nBackupsAlreadyRecoveredOrLeft(nImported, nFetched, txtKeysTeft));\n      Xss.sanitizeReplace('#step_2_recovery .line_skip_recovery', Ui.e('div', { class: 'line', html: Ui.e('a', { href: '#', class: 'skip_recover_remaining', html: 'Skip this step' }) }));\n      $('#step_2_recovery .skip_recover_remaining').click(this.view.setHandler(() => { window.location.href = Url.create('index.htm', { acctEmail: this.view.acctEmail }); }));\n    } else {\n      Xss.sanitizeRender('#step_2_recovery .recovery_status', `There ${txtKeysTeft} left to recover.<br><br>Try different pass phrases to unlock all backups.`);\n      $('#step_2_recovery .line_skip_recovery').css('display', 'none');\n    }\n  }\n\n  public actionSkipRecoveryHandler = async () => {\n    if (await Ui.modal.confirm(Lang.setup.confirmSkipRecovery)) {\n      this.view.fetchedKeyBackups = [];\n      this.view.fetchedKeyBackupsUniqueLongids = [];\n      this.view.mathingPassphrases = [];\n      this.view.importedKeysUniqueLongids = [];\n      this.view.setupRender.displayBlock('step_1_easy_or_manual');\n    }\n  }\n\n  public renderAddKeyFromBackup = async () => { // at this point, account is already set up, and this page is showing in a lightbox after selecting \"from backup\" in add_key.htm\n    $('.profile-row, .skip_recover_remaining, .action_send, .action_account_settings, .action_skip_recovery').css({ display: 'none', visibility: 'hidden', opacity: 0 });\n    Xss.sanitizeRender($('h1').parent(), '<h1>Recover key from backup</h1>');\n    $('.action_recover_account').text('load key from backup');\n    try {\n      const backups = await this.view.gmail.fetchKeyBackups();\n      this.view.fetchedKeyBackups = backups.keyinfos.backups;\n      this.view.fetchedKeyBackupsUniqueLongids = backups.longids.backups;\n    } catch (e) {\n      window.location.href = Url.create('modules/add_key.htm', { acctEmail: this.view.acctEmail, parentTabId: this.view.parentTabId });\n      return;\n    }\n    if (this.view.fetchedKeyBackupsUniqueLongids.length) {\n      const storedKeys = await KeyStore.get(this.view.acctEmail);\n      this.view.importedKeysUniqueLongids = storedKeys.map(ki => ki.longid);\n      await this.view.setupRender.renderSetupDone();\n      $('#step_4_more_to_recover .action_recover_remaining').click();\n    } else {\n      window.location.href = Url.create('modules/add_key.htm', { acctEmail: this.view.acctEmail, parentTabId: this.view.parentTabId });\n    }\n  }\n\n}\n",
    "extension/chrome/settings/setup/setup-render.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Value } from '../../../js/common/core/common.js';\nimport { Lang } from '../../../js/common/lang.js';\nimport { Settings } from '../../../js/common/settings.js';\nimport { SetupView } from '../setup.js';\nimport { AcctStore } from '../../../js/common/platform/store/acct-store.js';\nimport { KeyStore } from '../../../js/common/platform/store/key-store.js';\n\nexport class SetupRenderModule {\n\n  public readonly emailDomainsToSkip = ['yahoo', 'live', 'outlook'];\n\n  constructor(private view: SetupView) {\n  }\n\n  public renderInitial = async (): Promise<void> => {\n    $('h1').text(this.view.orgRules.mustAutoImportOrAutogenPrvWithKeyManager() ? 'Setting up FlowCrypt, please wait...' : 'Set Up FlowCrypt');\n    $('.email-address').text(this.view.acctEmail);\n    $('#button-go-back').css('visibility', 'hidden');\n    if (this.view.storage!.email_provider === 'gmail') { // show alternative account addresses in setup form + save them for later\n      try {\n        await Settings.refreshSendAs(this.view.acctEmail);\n        const { sendAs } = await AcctStore.get(this.view.acctEmail, ['sendAs']);\n        this.saveAndFillSubmitPubkeysOption(Object.keys(sendAs!));\n      } catch (e) {\n        return await Settings.promptToRetry(e, Lang.setup.failedToLoadEmailAliases, () => this.renderInitial());\n      }\n    }\n    if (this.view.storage!.setup_done) {\n      if (this.view.action !== 'add_key') {\n        await this.renderSetupDone();\n      } else if (this.view.orgRules.mustAutoImportOrAutogenPrvWithKeyManager()) {\n        throw new Error('Manual add_key is not supported when PRV_AUTOIMPORT_OR_AUTOGEN org rule is in use');\n      } else {\n        await this.view.setupRecoverKey.renderAddKeyFromBackup();\n      }\n    } else if (this.view.action === 'finalize') {\n      const { tmp_submit_all, tmp_submit_main } = await AcctStore.get(this.view.acctEmail, ['tmp_submit_all', 'tmp_submit_main']);\n      if (typeof tmp_submit_all === 'undefined' || typeof tmp_submit_main === 'undefined') {\n        $('#content').text(`Setup session expired. To set up FlowCrypt, please click the FlowCrypt icon on top right.`);\n        return;\n      }\n      await this.view.submitPublicKeysAndFinalizeSetup({ submit_all: tmp_submit_all, submit_main: tmp_submit_main });\n      await this.renderSetupDone();\n    } else if (this.view.orgRules.mustAutoImportOrAutogenPrvWithKeyManager()) {\n      await this.view.setupWithEmailKeyManager.setupWithEkmThenRenderSetupDone();\n    } else {\n      await this.renderSetupDialog();\n    }\n  }\n\n  public renderSetupDone = async () => {\n    const storedKeys = await KeyStore.get(this.view.acctEmail);\n    if (this.view.fetchedKeyBackupsUniqueLongids.length > storedKeys.length) { // recovery where not all keys were processed: some may have other pass phrase\n      this.displayBlock('step_4_more_to_recover');\n      $('h1').text('More keys to recover');\n      $('.email').text(this.view.acctEmail);\n      $('.private_key_count').text(storedKeys.length);\n      $('.backups_count').text(this.view.fetchedKeyBackupsUniqueLongids.length);\n    } else { // successful and complete setup\n      this.displayBlock(this.view.action !== 'add_key' ? 'step_4_done' : 'step_4_close');\n      $('h1').text(this.view.action !== 'add_key' ? 'You\\'re all set!' : 'Recovered all keys!');\n      $('.email').text(this.view.acctEmail);\n    }\n  }\n\n  public displayBlock = (name: string) => {\n    const blocks = [\n      'loading',\n      'step_0_found_key',\n      'step_1_easy_or_manual',\n      'step_2a_manual_create', 'step_2b_manual_enter', 'step_2_easy_generating', 'step_2_recovery',\n      'step_3_compatibility_fix',\n      'step_4_more_to_recover',\n      'step_4_done',\n      'step_4_close',\n    ];\n    if (name) {\n      $('#' + blocks.join(', #')).css('display', 'none');\n      $('#' + name).css('display', 'block');\n      $('#button-go-back').css('visibility', ['step_2b_manual_enter', 'step_2a_manual_create'].includes(name) ? 'visible' : 'hidden');\n      if (name === 'step_2_recovery') {\n        $('.backups_count_words').text(this.view.fetchedKeyBackupsUniqueLongids.length > 1 ? `${this.view.fetchedKeyBackupsUniqueLongids.length} backups` : 'a backup');\n        $('#step_2_recovery input').focus();\n      }\n    }\n  }\n\n  public renderSetupDialog = async (): Promise<void> => {\n    let keyserverRes;\n    try {\n      keyserverRes = await this.view.pubLookup.lookupEmail(this.view.acctEmail);\n    } catch (e) {\n      return await Settings.promptToRetry(e, Lang.setup.failedToCheckIfAcctUsesEncryption, () => this.renderSetupDialog());\n    }\n    if (keyserverRes.pubkeys.length) {\n      if (!this.view.orgRules.canBackupKeys()) {\n        // they already have a key recorded on attester, but no backups allowed on the domain. They should enter their prv manually\n        this.displayBlock('step_2b_manual_enter');\n      } else if (this.view.storage!.email_provider === 'gmail' && (this.view.scopes!.read || this.view.scopes!.modify)) {\n        try {\n          const backups = await this.view.gmail.fetchKeyBackups();\n          this.view.fetchedKeyBackups = backups.keyinfos.backups;\n          this.view.fetchedKeyBackupsUniqueLongids = backups.longids.backups;\n        } catch (e) {\n          return await Settings.promptToRetry(e, Lang.setup.failedToCheckAccountBackups, () => this.renderSetupDialog());\n        }\n        if (this.view.fetchedKeyBackupsUniqueLongids.length) {\n          this.displayBlock('step_2_recovery');\n        } else {\n          this.displayBlock('step_0_found_key');\n        }\n      } else { // cannot read gmail to find a backup, or this is outlook\n        throw new Error('Not able to load backups from inbox due to missing permissions');\n      }\n    } else { // no indication that the person used pgp before\n      if (this.view.orgRules.canCreateKeys()) {\n        this.displayBlock('step_1_easy_or_manual');\n      } else {\n        this.displayBlock('step_2b_manual_enter');\n      }\n    }\n  }\n\n  private saveAndFillSubmitPubkeysOption = (addresses: string[]) => {\n    this.view.submitKeyForAddrs = this.filterAddressesForSubmittingKeys(addresses);\n    if (this.view.submitKeyForAddrs.length > 1) {\n      $('.addresses').text(Value.arr.withoutVal(this.view.submitKeyForAddrs, this.view.acctEmail).join(', '));\n      $('.manual .input_submit_all').prop({ checked: true, disabled: false }).closest('div.line').css('display', 'block');\n    }\n  }\n\n  private filterAddressesForSubmittingKeys = (addresses: string[]): string[] => {\n    const filterAddrRegEx = new RegExp(`@(${this.emailDomainsToSkip.join('|')})`);\n    return addresses.filter(e => !filterAddrRegEx.test(e));\n  }\n\n}\n",
    "extension/chrome/settings/setup.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Bm, BrowserMsg } from '../../js/common/browser/browser-msg.js';\nimport { Url } from '../../js/common/core/common.js';\nimport { ApiErr } from '../../js/common/api/shared/api-error.js';\nimport { Assert } from '../../js/common/assert.js';\nimport { Catch } from '../../js/common/platform/catch.js';\nimport { Contact, KeyInfo, Key, KeyUtil } from '../../js/common/core/crypto/key.js';\nimport { Gmail } from '../../js/common/api/email-provider/gmail/gmail.js';\nimport { Google } from '../../js/common/api/email-provider/gmail/google.js';\nimport { KeyImportUi } from '../../js/common/ui/key-import-ui.js';\nimport { Lang } from '../../js/common/lang.js';\nimport { opgp } from '../../js/common/core/crypto/pgp/openpgpjs-custom.js';\nimport { OrgRules } from '../../js/common/org-rules.js';\nimport { Settings } from '../../js/common/settings.js';\nimport { SetupCreateKeyModule } from './setup/setup-create-key.js';\nimport { SetupImportKeyModule } from './setup/setup-import-key.js';\nimport { SetupRecoverKeyModule } from './setup/setup-recover-key.js';\nimport { SetupRenderModule } from './setup/setup-render.js';\nimport { Ui } from '../../js/common/browser/ui.js';\nimport { View } from '../../js/common/view.js';\nimport { Xss } from '../../js/common/platform/xss.js';\nimport { initPassphraseToggle } from '../../js/common/ui/passphrase-ui.js';\nimport { PubLookup } from '../../js/common/api/pub-lookup.js';\nimport { Scopes, AcctStoreDict, AcctStore } from '../../js/common/platform/store/acct-store.js';\nimport { KeyStore } from '../../js/common/platform/store/key-store.js';\nimport { PassphraseStore } from '../../js/common/platform/store/passphrase-store.js';\nimport { ContactStore } from '../../js/common/platform/store/contact-store.js';\nimport { KeyManager } from '../../js/common/api/key-server/key-manager.js';\nimport { SetupWithEmailKeyManagerModule } from './setup/setup-key-manager-autogen.js';\nimport Swal from 'sweetalert2';\n\nexport interface SetupOptions {\n  passphrase: string;\n  passphrase_save: boolean;\n  submit_main: boolean;\n  submit_all: boolean;\n  recovered?: boolean;\n}\n\nexport class SetupView extends View {\n\n  public readonly acctEmail: string;\n  public readonly parentTabId: string | undefined;\n  public readonly action: 'add_key' | 'finalize' | undefined;\n  public readonly idToken: string | undefined; // only needed for initial setup, not for add_key or 'finalize'\n\n  public readonly keyImportUi = new KeyImportUi({ checkEncryption: true });\n  public readonly gmail: Gmail;\n  public readonly setupRecoverKey: SetupRecoverKeyModule;\n  public readonly setupCreateKey: SetupCreateKeyModule;\n  public readonly setupImportKey: SetupImportKeyModule;\n  public readonly setupRender: SetupRenderModule;\n  public readonly setupWithEmailKeyManager: SetupWithEmailKeyManagerModule;\n\n  public tabId!: string;\n  public scopes!: Scopes;\n  public storage!: AcctStoreDict;\n  public orgRules!: OrgRules;\n  public pubLookup!: PubLookup;\n  public keyManager: KeyManager | undefined; // not set if no url in org rules\n\n  public fetchedKeyBackups: KeyInfo[] = [];\n  public fetchedKeyBackupsUniqueLongids: string[] = [];\n  public importedKeysUniqueLongids: string[] = [];\n  public mathingPassphrases: string[] = [];\n  public submitKeyForAddrs: string[];\n\n  constructor() {\n    super();\n    const uncheckedUrlParams = Url.parse(['acctEmail', 'action', 'idToken', 'parentTabId']);\n    this.acctEmail = Assert.urlParamRequire.string(uncheckedUrlParams, 'acctEmail');\n    this.action = Assert.urlParamRequire.oneof(uncheckedUrlParams, 'action', ['add_key', 'finalize', undefined]) as 'add_key' | 'finalize' | undefined;\n    if (this.action === 'add_key') {\n      this.parentTabId = Assert.urlParamRequire.string(uncheckedUrlParams, 'parentTabId');\n    } else {\n      this.idToken = Assert.urlParamRequire.string(uncheckedUrlParams, 'idToken');\n    }\n    if (this.acctEmail) {\n      BrowserMsg.send.bg.updateUninstallUrl();\n    } else {\n      window.location.href = 'index.htm';\n    }\n    this.submitKeyForAddrs = [this.acctEmail];\n    this.keyImportUi.initPrvImportSrcForm(this.acctEmail, this.parentTabId); // for step_2b_manual_enter, if user chooses so\n    this.keyImportUi.onBadPassphrase = () => $('#step_2b_manual_enter .input_passphrase').val('').focus();\n    this.keyImportUi.renderPassPhraseStrengthValidationInput($('.input_password'), $('.action_create_private'));\n    this.gmail = new Gmail(this.acctEmail);\n    // modules\n    this.setupRecoverKey = new SetupRecoverKeyModule(this);\n    this.setupCreateKey = new SetupCreateKeyModule(this);\n    this.setupImportKey = new SetupImportKeyModule(this);\n    this.setupRender = new SetupRenderModule(this);\n    this.setupWithEmailKeyManager = new SetupWithEmailKeyManagerModule(this);\n  }\n\n  public render = async () => {\n    await initPassphraseToggle(['step_2b_manual_enter_passphrase'], 'hide');\n    await initPassphraseToggle(['step_2a_manual_create_input_password', 'step_2a_manual_create_input_password2', 'recovery_pasword']);\n    this.storage = await AcctStore.get(this.acctEmail, ['setup_done', 'email_provider']);\n    this.scopes = await AcctStore.getScopes(this.acctEmail);\n    this.storage.email_provider = this.storage.email_provider || 'gmail';\n    this.orgRules = await OrgRules.newInstance(this.acctEmail);\n    if (this.orgRules.shouldHideArmorMeta() && typeof opgp !== 'undefined') {\n      opgp.config.show_comment = false;\n      opgp.config.show_version = false;\n    }\n    this.pubLookup = new PubLookup(this.orgRules);\n    if (this.orgRules.usesKeyManager() && this.idToken) {\n      this.keyManager = new KeyManager(this.orgRules.getKeyManagerUrlForPrivateKeys()!);\n    }\n    if (!this.orgRules.canCreateKeys()) {\n      const forbidden = `${Lang.setup.creatingKeysNotAllowedPleaseImport} <a href=\"${Xss.escape(window.location.href)}\">Back</a>`;\n      Xss.sanitizeRender('#step_2a_manual_create, #step_2_easy_generating', `<div class=\"aligncenter\"><div class=\"line\">${forbidden}</div></div>`);\n      $('#button-go-back').remove(); // back button would allow users to choose other options (eg create - not allowed)\n    }\n    if (this.orgRules.mustSubmitToAttester() || !this.orgRules.canSubmitPubToAttester()) {\n      $('.remove_if_pubkey_submitting_not_user_configurable').remove();\n    }\n    if (this.orgRules.rememberPassPhraseByDefault()) {\n      $('#step_2a_manual_create .input_passphrase_save').prop('checked', true);\n      $('#step_2b_manual_enter .input_passphrase_save').prop('checked', true);\n    }\n    if (this.orgRules.getEnforcedKeygenAlgo()) {\n      $('.key_type').val(this.orgRules.getEnforcedKeygenAlgo()!).prop('disabled', true);\n    }\n    if (!this.orgRules.canBackupKeys()) {\n      $('.input_backup_inbox').prop('checked', false).prop('disabled', true);\n      $('.remove_if_backup_not_allowed').remove();\n    }\n    this.tabId = await BrowserMsg.requiredTabId();\n    await this.setupRender.renderInitial();\n  }\n\n  public setHandlers = () => {\n    BrowserMsg.addListener('close_page', async () => { Swal.close(); });\n    BrowserMsg.addListener('notification_show', async ({ notification }: Bm.NotificationShow) => { await Ui.modal.info(notification); });\n    BrowserMsg.listen(this.tabId);\n    $('.action_send').attr('href', Google.webmailUrl(this.acctEmail));\n    $('.action_show_help').click(this.setHandler(async () => await Settings.renderSubPage(this.acctEmail, this.tabId!, '/chrome/settings/modules/help.htm')));\n    $('#button-go-back').off().click(this.setHandler(() => this.actionBackHandler()));\n    $('#step_2_recovery .action_recover_account').click(this.setHandlerPrevent('double', () => this.setupRecoverKey.actionRecoverAccountHandler()));\n    $('#step_4_more_to_recover .action_recover_remaining').click(this.setHandler(() => this.setupRecoverKey.actionRecoverRemainingKeysHandler()));\n    $('.action_skip_recovery').click(this.setHandler(() => this.setupRecoverKey.actionSkipRecoveryHandler()));\n    $('.action_account_settings').click(this.setHandler(() => { window.location.href = Url.create('index.htm', { acctEmail: this.acctEmail }); }));\n    $('.input_submit_key').click(this.setHandler(el => this.actionSubmitPublicKeyToggleHandler(el)));\n    $('#step_0_found_key .action_manual_create_key, #step_1_easy_or_manual .action_manual_create_key').click(this.setHandler(() => this.setupRender.displayBlock('step_2a_manual_create')));\n    $('#step_0_found_key .action_manual_enter_key, #step_1_easy_or_manual .action_manual_enter_key').click(this.setHandler(() => this.setupRender.displayBlock('step_2b_manual_enter')));\n    $('#step_2b_manual_enter .action_add_private_key').click(this.setHandler(el => this.setupImportKey.actionImportPrivateKeyHandle(el)));\n    $('#step_2a_manual_create .action_create_private').click(this.setHandlerPrevent('double', () => this.setupCreateKey.actionCreateKeyHandler()));\n    $('#step_2a_manual_create .action_show_advanced_create_settings').click(this.setHandler(el => this.setupCreateKey.actionShowAdvancedSettingsHandle(el)));\n    $('#step_4_close .action_close').click(this.setHandler(() => this.actionCloseHandler())); // only rendered if action=add_key which means parentTabId was used\n    $('.input_password').on('keydown', this.setEnterHandlerThatClicks('#step_2a_manual_create .action_create_private'));\n    $('.input_password2').on('keydown', this.setEnterHandlerThatClicks('#step_2a_manual_create .action_create_private'));\n    $(\"#recovery_pasword\").on('keydown', this.setEnterHandlerThatClicks('#step_2_recovery .action_recover_account'));\n  }\n\n  public actionBackHandler = () => {\n    $('h1').text('Set Up');\n    this.setupRender.displayBlock('step_1_easy_or_manual');\n  }\n\n  public actionSubmitPublicKeyToggleHandler = (target: HTMLElement) => {\n    // will be hidden / ignored / forced true when rules.mustSubmitToAttester() === true (for certain orgs)\n    const inputSubmitAll = $(target).closest('.manual').find('.input_submit_all').first();\n    if ($(target).prop('checked')) {\n      if (inputSubmitAll.closest('div.line').css('visibility') === 'visible') {\n        inputSubmitAll.prop({ checked: true, disabled: false });\n      }\n    } else {\n      inputSubmitAll.prop({ checked: false, disabled: true });\n    }\n  }\n\n  public actionCloseHandler = () => {\n    if (this.parentTabId) {\n      BrowserMsg.send.redirect(this.parentTabId, { location: Url.create('index.htm', { acctEmail: this.acctEmail, advanced: true }) });\n    } else {\n      Catch.report('setup.ts missing parentTabId');\n    }\n  }\n\n  public preFinalizeSetup = async (options: SetupOptions): Promise<void> => {\n    await AcctStore.set(this.acctEmail, { tmp_submit_main: options.submit_main, tmp_submit_all: options.submit_all });\n  }\n\n  public submitPublicKeysAndFinalizeSetup = async ({ submit_main, submit_all }: { submit_main: boolean, submit_all: boolean }): Promise<void> => {\n    const primaryKi = await KeyStore.getFirstRequired(this.acctEmail);\n    try {\n      await this.submitPublicKeyIfNeeded(primaryKi.public, { submit_main, submit_all });\n    } catch (e) {\n      return await Settings.promptToRetry(e, Lang.setup.failedToSubmitToAttester, () => this.submitPublicKeysAndFinalizeSetup({ submit_main, submit_all }));\n    }\n    await AcctStore.set(this.acctEmail, { setup_date: Date.now(), setup_done: true, cryptup_enabled: true });\n    await AcctStore.remove(this.acctEmail, ['tmp_submit_main', 'tmp_submit_all']);\n  }\n\n  public saveKeysAndPassPhrase = async (prvs: Key[], options: SetupOptions) => {\n    for (const prv of prvs) {\n      const fingerprint = prv.id;\n      if (!fingerprint) {\n        await Ui.modal.error('Cannot save keys to storage because at least one of them is not valid.');\n        return;\n      }\n      await KeyStore.add(this.acctEmail, prv);\n      await PassphraseStore.set(options.passphrase_save ? 'local' : 'session', this.acctEmail, fingerprint, options.passphrase);\n    }\n    const myOwnEmailAddrsAsContacts: Contact[] = [];\n    const { full_name: name } = await AcctStore.get(this.acctEmail, ['full_name']);\n    for (const email of this.submitKeyForAddrs) {\n      myOwnEmailAddrsAsContacts.push(await ContactStore.obj({ email, name, pubkey: KeyUtil.armor(await KeyUtil.asPublicKey(prvs[0])) }));\n    }\n    await ContactStore.save(undefined, myOwnEmailAddrsAsContacts);\n  }\n\n  public shouldSubmitPubkey = (checkboxSelector: string) => {\n    if (this.orgRules.mustSubmitToAttester() && !this.orgRules.canSubmitPubToAttester()) {\n      throw new Error('Organisation rules are misconfigured: ENFORCE_ATTESTER_SUBMIT not compatible with NO_ATTESTER_SUBMIT');\n    }\n    if (!this.orgRules.canSubmitPubToAttester()) {\n      return false;\n    }\n    if (this.orgRules.mustSubmitToAttester()) {\n      return true;\n    }\n    return Boolean($(checkboxSelector).prop('checked'));\n  }\n\n  private submitPublicKeyIfNeeded = async (armoredPubkey: string, options: { submit_main: boolean, submit_all: boolean }) => {\n    if (!options.submit_main) {\n      return;\n    }\n    if (!this.orgRules.canSubmitPubToAttester()) {\n      await Ui.modal.error('Not submitting public key to Attester - disabled for your org');\n      return;\n    }\n    const pub = await KeyUtil.parse(armoredPubkey);\n    if (pub.usableForEncryption) {\n      this.pubLookup.attester.testWelcome(this.acctEmail, armoredPubkey).catch(ApiErr.reportIfSignificant);\n    }\n    let addresses;\n    if (this.submitKeyForAddrs.length && options.submit_all) {\n      addresses = [...this.submitKeyForAddrs];\n    } else {\n      addresses = [this.acctEmail];\n    }\n    await this.submitPubkeys(addresses, armoredPubkey);\n  }\n\n  private submitPubkeys = async (addresses: string[], pubkey: string) => {\n    if (this.orgRules.useLegacyAttesterSubmit()) {\n      // this will generally ignore errors if conflicting key already exists, except for certain orgs\n      await this.pubLookup.attester.initialLegacySubmit(this.acctEmail, pubkey);\n    } else {\n      // this will actually replace the submitted public key if there was a conflict, better ux\n      await this.pubLookup.attester.submitPrimaryEmailPubkey(this.acctEmail, pubkey, this.idToken!);\n    }\n    const aliases = addresses.filter(a => a !== this.acctEmail);\n    if (aliases.length) {\n      await Promise.all(aliases.map(a => this.pubLookup.attester.initialLegacySubmit(a, pubkey)));\n    }\n  }\n\n}\n\nView.run(SetupView);\n",
    "extension/js/background_page/bgutils.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Catch, UnreportableError } from '../common/platform/catch.js';\nimport { Dict, Url, UrlParam } from '../common/core/common.js';\nimport { StoreCorruptedError, StoreDeniedError, StoreFailedError } from '../common/platform/store/abstract-store.js';\nimport { GlobalStore } from '../common/platform/store/global-store.js';\n\nexport class BgUtils {\n\n  public static openSettingsPage = async (path: string = 'index.htm', acctEmail?: string, page: string = '', rawPageUrlParams?: Dict<UrlParam>, addNewAcct = false) => {\n    const basePath = chrome.runtime.getURL(`chrome/settings/${path}`);\n    const pageUrlParams = rawPageUrlParams ? JSON.stringify(rawPageUrlParams) : undefined;\n    if (acctEmail || path === 'fatal.htm') {\n      await BgUtils.openExtensionTab(Url.create(basePath, { acctEmail, page, pageUrlParams }));\n    } else if (addNewAcct) {\n      await BgUtils.openExtensionTab(Url.create(basePath, { addNewAcct }));\n    } else {\n      const acctEmails = await GlobalStore.acctEmailsGet();\n      await BgUtils.openExtensionTab(Url.create(basePath, { acctEmail: acctEmails[0], page, pageUrlParams }));\n    }\n  }\n\n  public static openExtensionTab = async (url: string) => {\n    const openedTab = await BgUtils.getFcSettingsTabIdIfOpen();\n    if (!openedTab) {\n      chrome.tabs.create({ url });\n    } else {\n      chrome.tabs.update(openedTab, { url, active: true });\n    }\n  }\n\n  public static getFcSettingsTabIdIfOpen = async (): Promise<number | undefined> => {\n    return await new Promise(resolve => {\n      chrome.tabs.query({ currentWindow: true }, tabs => {\n        const extensionUrl = chrome.runtime.getURL('/');\n        for (const tab of tabs) {\n          if (tab.url && tab.url.includes(extensionUrl)) {\n            resolve(tab.id);\n            return;\n          }\n        }\n        resolve(undefined);\n      });\n    });\n  }\n\n  public static handleStoreErr = async (e: any, reason?: 'storage_undefined' | 'db_corrupted' | 'db_denied' | 'db_failed') => {\n    if (!reason) {\n      if (e instanceof StoreCorruptedError) {\n        reason = 'db_corrupted';\n      } else if (e instanceof StoreDeniedError) {\n        reason = 'db_denied';\n      } else if (e instanceof StoreFailedError) {\n        reason = 'db_failed';\n      } else {\n        Catch.reportErr(e);\n        reason = 'db_failed';\n      }\n    }\n    await BgUtils.openSettingsPage(Url.create('fatal.htm', { reason, stack: e instanceof Error ? e.stack : Catch.stackTrace() }));\n    throw new UnreportableError();\n  }\n\n}\n",
    "extension/js/background_page/migrations.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { KeyInfo, KeyUtil } from '../common/core/crypto/key.js';\nimport { SmimeKey } from '../common/core/crypto/smime/smime-key.js';\nimport { ContactStore, ContactUpdate, Email, Pubkey } from '../common/platform/store/contact-store.js';\nimport { GlobalStore } from '../common/platform/store/global-store.js';\nimport { KeyStore } from '../common/platform/store/key-store.js';\n\n// contact entity prior to version 4\ntype ContactV3 = {\n  email: string;\n  name: string | null;\n  pubkey: { rawArmored: string, raw: string } | string | null;\n  has_pgp: 0 | 1;\n  fingerprint: string | null;\n  last_use: number | null;\n  pubkey_last_check: number | null;\n  expiresOn: number | null;\n};\n\ntype PubkeyMigrationData = {\n  emailsToUpdate: { [email: string]: Email };\n  pubkeysToDelete: string[];\n  pubkeysToSave: Pubkey[];\n};\n\nconst addKeyInfoFingerprints = async () => {\n  for (const acctEmail of await GlobalStore.acctEmailsGet()) {\n    const originalKis = await KeyStore.get(acctEmail);\n    const updated: KeyInfo[] = [];\n    for (const originalKi of originalKis) {\n      updated.push(await KeyUtil.keyInfoObj(await KeyUtil.parse(originalKi.private)));\n    }\n    await KeyStore.set(acctEmail, updated);\n  }\n};\n\nexport const migrateGlobal = async () => {\n  const globalStore = await GlobalStore.get(['key_info_store_fingerprints_added']);\n  if (!globalStore.key_info_store_fingerprints_added) {\n    console.info('migrating KeyStorage to add fingerprints and emails of each key...');\n    await addKeyInfoFingerprints();\n    await GlobalStore.set({ key_info_store_fingerprints_added: true });\n    console.info('done migrating');\n  }\n};\n\nconst processSmimeKey = (pubkey: Pubkey, tx: IDBTransaction, data: PubkeyMigrationData, next: () => void) => {\n  if (KeyUtil.getKeyType(pubkey.armoredKey) !== 'x509') {\n    next();\n    return;\n  }\n  const key = SmimeKey.parse(pubkey.armoredKey);\n  const newPubkeyEntity = ContactStore.pubkeyObj(key, pubkey.lastCheck);\n  data.pubkeysToDelete.push(pubkey.fingerprint);\n  const req = tx.objectStore('emails').index('index_fingerprints').getAll(pubkey.fingerprint!);\n  ContactStore.setReqPipe(req,\n    (emailEntities: Email[]) => {\n      if (emailEntities.length) {\n        data.pubkeysToSave.push(newPubkeyEntity);\n      }\n      for (const emailEntity of emailEntities) {\n        const cachedEmail = data.emailsToUpdate[emailEntity.email];\n        if (!cachedEmail) {\n          data.emailsToUpdate[emailEntity.email] = emailEntity;\n        }\n        const entityToUpdate = cachedEmail ?? emailEntity;\n        entityToUpdate.fingerprints = entityToUpdate.fingerprints.filter(fp => fp !== pubkey.fingerprint && fp !== newPubkeyEntity.fingerprint);\n        entityToUpdate.fingerprints.push(newPubkeyEntity.fingerprint);\n      }\n      next();\n    });\n};\n\nexport const updateX509FingerprintsAndLongids = async (db: IDBDatabase): Promise<void> => {\n  const globalStore = await GlobalStore.get(['contact_store_x509_fingerprints_and_longids_updated']);\n  if (globalStore.contact_store_x509_fingerprints_and_longids_updated) {\n    return;\n  }\n  console.info('updating ContactStorage to correct longids and fingerprints of X.509 certificates...');\n  const tx = db.transaction(['emails', 'pubkeys'], 'readwrite');\n  await new Promise((resolve, reject) => {\n    ContactStore.setTxHandlers(tx, resolve, reject);\n    const data: PubkeyMigrationData = { emailsToUpdate: {}, pubkeysToDelete: [], pubkeysToSave: [] };\n    const search = tx.objectStore('pubkeys').openCursor();\n    ContactStore.setReqPipe(search,\n      (cursor: IDBCursorWithValue) => {\n        if (!cursor) {\n          // do updates\n          for (const fp of data.pubkeysToDelete.filter(fp => !data.pubkeysToSave.some(x => x.fingerprint === fp))) {\n            // console.log(`Deleting pubkey ${fp}`);\n            tx.objectStore('pubkeys').delete(fp);\n          }\n          for (const pubkey of data.pubkeysToSave) {\n            // console.log(`Updating pubkey ${pubkey.fingerprint}`);\n            tx.objectStore('pubkeys').put(pubkey);\n          }\n          for (const email of Object.values(data.emailsToUpdate)) {\n            // console.log(`Updating email ${email.email}`);\n            tx.objectStore('emails').put(email);\n          }\n        } else {\n          processSmimeKey(cursor.value as Pubkey, tx, data, () => cursor.continue());\n        }\n      });\n  });\n  await GlobalStore.set({ contact_store_x509_fingerprints_and_longids_updated: true });\n  console.info('done updating');\n};\n\nexport const updateOpgpRevocations = async (db: IDBDatabase): Promise<void> => {\n  const globalStore = await GlobalStore.get(['contact_store_opgp_revoked_flags_updated']);\n  if (globalStore.contact_store_opgp_revoked_flags_updated) {\n    return;\n  }\n  console.info('updating ContactStorage to revoked flags of OpenPGP keys...');\n  const tx = db.transaction(['pubkeys'], 'readonly');\n  const pubkeys: Pubkey[] = await new Promise((resolve, reject) => {\n    const search = tx.objectStore('pubkeys').getAll();\n    ContactStore.setReqPipe(search, resolve, reject);\n  });\n  const revokedKeys = (await Promise.all(pubkeys.filter(entity => KeyUtil.getKeyType(entity.armoredKey) === 'openpgp').\n    map(async (entity) => await KeyUtil.parse(entity.armoredKey)))).\n    filter(k => k.revoked);\n  const txUpdate = db.transaction(['revocations'], 'readwrite');\n  await new Promise((resolve, reject) => {\n    ContactStore.setTxHandlers(txUpdate, resolve, reject);\n    const revocationsStore = txUpdate.objectStore('revocations');\n    for (const revokedKey of revokedKeys) {\n      revocationsStore.put(ContactStore.revocationObj(revokedKey));\n    }\n  });\n  await GlobalStore.set({ contact_store_opgp_revoked_flags_updated: true });\n  console.info('done updating');\n};\n\nexport const moveContactsToEmailsAndPubkeys = async (db: IDBDatabase): Promise<void> => {\n  if (!db.objectStoreNames.contains('contacts')) {\n    return;\n  }\n  console.info('migrating contacts of ContactStore to emails and pubkeys...');\n  const batchSize = 50;\n  try {\n    while (await moveContactsBatchToEmailsAndPubkeys(db, batchSize)) {\n      console.info('proceeding to the next batch');\n    }\n    console.info('migrating contacts of ContactStore is complete');\n  } catch (e) {\n    console.error(`Error happened when converting contacts: ${e instanceof Error ? e.message : String(e)}`);\n  }\n};\n\nconst moveContactsBatchToEmailsAndPubkeys = async (db: IDBDatabase, count?: number | undefined): Promise<number> => {\n  const entries: ContactV3[] = [];\n  {\n    const tx = db.transaction(['contacts'], 'readonly');\n    await new Promise((resolve, reject) => {\n      ContactStore.setTxHandlers(tx, resolve, reject);\n      const contacts = tx.objectStore('contacts');\n      const search = contacts.getAll(undefined, count);\n      ContactStore.setReqPipe(search, (result: ContactV3[]) => {\n        entries.push(...result);\n      });\n    });\n    if (!entries.length) {\n      return 0;\n    }\n  }\n  console.info(`Processing a batch of ${entries.length}.`);\n  // transform\n  const converted = await Promise.all(entries.map(async (entry) => {\n    const armoredPubkey = (entry.pubkey && typeof entry.pubkey === 'object')\n      ? (entry.pubkey.rawArmored ?? entry.pubkey.raw) : entry.pubkey as string;\n    // parse again to re-calculate expiration-related fields etc.\n    const pubkey = armoredPubkey ? await KeyUtil.parse(armoredPubkey) : undefined;\n    return {\n      email: entry.email,\n      update: {\n        name: entry.name,\n        pubkey,\n        lastUse: entry.last_use,\n        pubkeyLastCheck: pubkey ? entry.pubkey_last_check : undefined\n      } as ContactUpdate\n    };\n  }));\n  {\n    const tx = db.transaction(['contacts', 'emails', 'pubkeys', 'revocations'], 'readwrite');\n    await new Promise((resolve, reject) => {\n      ContactStore.setTxHandlers(tx, resolve, reject);\n      for (const item of converted) {\n        ContactStore.updateTx(tx, item.email, item.update);\n        tx.objectStore('contacts').delete(item.email);\n      }\n    });\n  }\n  return converted.length;\n};\n",
    "extension/js/common/api/account-server.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { AcctStore } from '../platform/store/acct-store.js';\nimport { EnterpriseServer } from './account-servers/enterprise-server.js';\nimport { BackendRes, FcUuidAuth, FlowCryptComApi, ProfileUpdate } from './account-servers/flowcrypt-com-api.js';\nimport { Api, ProgressCb } from './shared/api.js';\n\n/**\n * This may be calling to FlowCryptComApi or Enterprise Server (FES, customer on-prem) depending on\n *   whether FES is deployed on the customer domain or not.\n */\nexport class AccountServer extends Api {\n\n  constructor(private acctEmail: string) {\n    super();\n  }\n\n  public loginWithOpenid = async (acctEmail: string, uuid: string, idToken: string): Promise<void> => {\n    if (await this.isFesUsed()) {\n      const fes = new EnterpriseServer(this.acctEmail);\n      await fes.getAccessTokenAndUpdateLocalStore(idToken);\n    } else {\n      await FlowCryptComApi.loginWithOpenid(acctEmail, uuid, idToken);\n    }\n  }\n\n  public accountGetAndUpdateLocalStore = async (fcAuth: FcUuidAuth): Promise<BackendRes.FcAccountGet> => {\n    if (await this.isFesUsed()) {\n      const fes = new EnterpriseServer(this.acctEmail);\n      return await fes.getAccountAndUpdateLocalStore();\n    } else {\n      return await FlowCryptComApi.accountGetAndUpdateLocalStore(fcAuth);\n    }\n  }\n\n  public accountUpdate = async (fcAuth: FcUuidAuth, profileUpdate: ProfileUpdate): Promise<void> => {\n    if (await this.isFesUsed()) {\n      const fes = new EnterpriseServer(this.acctEmail);\n      await fes.accountUpdate(profileUpdate);\n    } else {\n      await FlowCryptComApi.accountUpdate(fcAuth, profileUpdate);\n    }\n  }\n\n  public messageUpload = async (fcAuth: FcUuidAuth | undefined, encryptedDataBinary: Uint8Array, progressCb: ProgressCb): Promise<BackendRes.FcMsgUpload> => {\n    return await FlowCryptComApi.messageUpload(fcAuth, encryptedDataBinary, progressCb);\n  }\n\n  public messageToken = async (fcAuth: FcUuidAuth): Promise<BackendRes.FcMsgToken> => {\n    return await FlowCryptComApi.messageToken(fcAuth);\n  }\n\n  private isFesUsed = async (): Promise<boolean> => {\n    const { fesUrl } = await AcctStore.get(this.acctEmail, ['fesUrl']);\n    return Boolean(fesUrl);\n  }\n}\n",
    "extension/js/common/api/account-servers/enterprise-server.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n// tslint:disable:oneliner-object-literal\n// tslint:disable:no-null-keyword\n\n'use strict';\n\nimport { Api, ReqMethod } from '../shared/api.js';\nimport { AcctStore } from '../../platform/store/acct-store.js';\nimport { BackendRes, FlowCryptComApi, ProfileUpdate } from './flowcrypt-com-api.js';\nimport { Dict } from '../../core/common.js';\nimport { ErrorReport, UnreportableError } from '../../platform/catch.js';\nimport { ApiErr } from '../shared/api-error.js';\nimport { FLAVOR } from '../../core/const.js';\n\n// todo - decide which tags to use\ntype EventTag = 'compose' | 'decrypt' | 'setup' | 'settings' | 'import-pub' | 'import-prv';\n\nexport namespace FesRes {\n  export type AccessToken = { accessToken: string };\n  export type ServiceInfo = { vendor: string, service: string, orgId: string, version: string, apiVersion: string }\n}\n\n/**\n * FlowCrypt Enterprise Server (FES) may be deployed on-prem by enterprise customers.\n * This gives them more control. All OrgRules, log collectors, etc (as implemented) would then be handled by the FES.\n * Once fully integrated, this will allow customers to be fully independent of flowcrypt.com/api\n *\n * WIP - currently unused\n */\n// ts-prune-ignore-next\nexport class EnterpriseServer extends Api {\n\n  public url: string\n\n  private domain: string\n  private apiVersion = 'v1';\n  private domainsThatUseLaxFesCheckEvenOnEnterprise = ['dmFsZW8uY29t'];\n\n  constructor(private acctEmail: string) {\n    super();\n    this.domain = acctEmail.toLowerCase().split('@').pop()!;\n    this.url = `https://fes.${this.domain}`;\n  }\n\n  /**\n   * This is run during user/extension setup to figure out if this extension should be using FES or not.\n   */\n  public isFesInstalledAndAvailable = async (): Promise<boolean> => {\n    if (['gmail.com', 'yahoo.com', 'outlook.com', 'live.com'].includes(this.domain)) {\n      // no FES expected on fes.gmail.com and similar\n      return false;\n    }\n    try {\n      // regardless if this is enterprise or consumer flavor, if FES is available, return yes\n      return (await this.getServiceInfo()).service === 'enterprise-server';\n    } catch (e) { // FES not available\n      if (ApiErr.isNotFound(e)) {\n        return false; // a 404 returned where FES should be is an affirmative no - FES will not be used\n      }\n      if (FLAVOR === 'consumer') {\n        // this is a consumer flavor. Consumers are not expected to run FES, therefore\n        //   a server not responding (or returning an error) is considered as no FES\n        return false;\n      } else if (this.domainsThatUseLaxFesCheckEvenOnEnterprise.includes(btoa(this.domain)) && ApiErr.isNetErr(e)) {\n        // on some domains we don't expect FES running. This allows even enterprise flavor\n        //   extension to skip FES integration on these domains.\n        return false;\n      } else if (this.domain.endsWith('.test')) {\n        // enterprise flavor on a test domain should not require FES running (to satisfy tests)\n        return false;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  public getServiceInfo = async (): Promise<FesRes.ServiceInfo> => {\n    return await this.request<FesRes.ServiceInfo>('GET', `/api/`);\n  }\n\n  public getAccessTokenAndUpdateLocalStore = async (idToken: string): Promise<void> => {\n    const response = await this.request<FesRes.AccessToken>('GET', `/api/${this.apiVersion}/account/access-token`, { Authorization: `Bearer ${idToken}` });\n    await AcctStore.set(this.acctEmail, { fesAccessToken: response.accessToken });\n  }\n\n  public getAccountAndUpdateLocalStore = async (): Promise<BackendRes.FcAccountGet> => {\n    const r = await this.request<BackendRes.FcAccountGet>('GET', `/api/${this.apiVersion}/account/`, await this.authHdr());\n    await AcctStore.set(this.acctEmail, { rules: r.domain_org_rules });\n    return r;\n  }\n\n  public reportException = async (errorReport: ErrorReport): Promise<void> => {\n    await this.request<void>('POST', `/api/${this.apiVersion}/log-collector/exception`, await this.authHdr(), errorReport);\n  }\n\n  public reportEvent = async (tags: EventTag[], message: string, details?: string): Promise<void> => {\n    await this.request<void>('POST', `/api/${this.apiVersion}/log-collector/exception`, await this.authHdr(), { tags, message, details });\n  }\n\n  public accountUpdate = async (profileUpdate: ProfileUpdate): Promise<BackendRes.FcAccountUpdate> => {\n    console.log('profile update ignored', profileUpdate);\n    throw new UnreportableError('Account update not implemented when using FlowCrypt Enterprise Server');\n  }\n\n  private authHdr = async (): Promise<Dict<string>> => {\n    const { fesAccessToken } = await AcctStore.get(this.acctEmail, ['fesAccessToken']);\n    return { Authorization: `Bearer ${fesAccessToken}` };\n  }\n\n  private request = async <RT>(method: ReqMethod, path: string, headers: Dict<string> = {}, vals?: Dict<any>): Promise<RT> => {\n    return await FlowCryptComApi.apiCall(this.url, path, vals, method === 'GET' ? undefined : 'JSON', undefined, headers, 'json', method);\n  }\n\n}\n",
    "extension/js/common/api/account-servers/flowcrypt-com-api.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n// tslint:disable:oneliner-object-literal\n// tslint:disable:no-null-keyword\n\n'use strict';\n\nimport { Api, ProgressCb, ProgressCbs, ReqFmt } from '../shared/api.js';\nimport { Dict } from '../../core/common.js';\nimport { Attachment } from '../../core/attachment.js';\nimport { BackendAuthErr } from '../shared/api-error.js';\nimport { DomainRulesJson } from '../../org-rules.js';\nimport { AcctStore } from '../../platform/store/acct-store.js';\nimport { FlowCryptWebsite } from '../flowcrypt-website.js';\n\nexport type ProfileUpdate = { alias?: string, name?: string, photo?: string, intro?: string, web?: string, phone?: string, default_message_expire?: number };\nexport type SubscriptionLevel = 'pro' | null;\nexport type FcUuidAuth = { account: string, uuid: string | undefined };\nexport type SubscriptionInfo = { level?: SubscriptionLevel; expired?: boolean };\n\nexport namespace BackendRes {\n  export type FcAccountLogin = { registered: boolean, verified: boolean };\n  export type FcAccount$info = { alias: string, email: string, intro: string, name: string, photo: string, default_message_expire: number };\n  export type FcAccountGet = { account: FcAccount$info, subscription: SubscriptionInfo, domain_org_rules: DomainRulesJson };\n  export type FcAccountUpdate = { result: FcAccount$info, updated: boolean };\n  export type FcAccountSubscribe = { subscription: SubscriptionInfo };\n  export type FcAccountCheck = { email: string | null, subscription: SubscriptionInfo | null };\n  export type FcMsgToken = { token: string };\n  export type FcMsgUpload = { url: string };\n  export type FcLinkMsg = { expire: string, deleted: boolean, url: string, expired: boolean };\n  export type FcLinkMe$profile = {\n    alias: string | null, name: string | null, photo: string | null, intro: string | null, web: string | null,\n    phone: string | null, token: string | null, subscription_level: string | null, subscription_method: string | null, email: string | null\n  };\n  export type ApirFcMsgExpiration = { updated: boolean };\n}\n\nexport class FlowCryptComApi extends Api {\n\n  public static loginWithOpenid = async (acctEmail: string, uuid: string, idToken: string): Promise<void> => {\n    const response = await FlowCryptComApi.request<BackendRes.FcAccountLogin>('account/login', {\n      account: acctEmail,\n      uuid,\n      token: null, // tslint:disable-line:no-null-keyword\n    }, undefined, { Authorization: `Bearer ${idToken}` });\n    if (response.verified !== true) {\n      throw new Error('account_login with id_token did not result in successful verificaion');\n    }\n    await AcctStore.set(acctEmail, { uuid });\n  }\n\n  public static accountUpdate = async (fcAuth: FcUuidAuth, profileUpdate: ProfileUpdate): Promise<BackendRes.FcAccountUpdate> => {\n    FlowCryptComApi.throwIfMissingUuid(fcAuth);\n    return await FlowCryptComApi.request<BackendRes.FcAccountUpdate>('account/update', {\n      ...fcAuth,\n      ...profileUpdate\n    });\n  }\n\n  public static accountGetAndUpdateLocalStore = async (fcAuth: FcUuidAuth): Promise<BackendRes.FcAccountGet> => {\n    FlowCryptComApi.throwIfMissingUuid(fcAuth);\n    const r = await FlowCryptComApi.request<BackendRes.FcAccountGet>('account/get', fcAuth);\n    await AcctStore.set(fcAuth.account, { rules: r.domain_org_rules });\n    return r;\n  }\n\n  public static messageUpload = async (fcAuth: FcUuidAuth | undefined, encryptedDataBinary: Uint8Array, progressCb: ProgressCb): Promise<BackendRes.FcMsgUpload> => {\n    const content = new Attachment({ name: 'cryptup_encrypted_message.asc', type: 'text/plain', data: encryptedDataBinary });\n    const rawResponse = await FlowCryptComApi.request<{ short: string }>('message/upload', { content, ...(fcAuth || {}) }, 'FORM', undefined, { upload: progressCb });\n    if (!rawResponse.short) {\n      throw new Error('Unexpectedly missing message upload short id');\n    }\n    // careful - this API request returns `url` as well, but that is URL of the S3 object, not of web portal page\n    // therefore we are constructing URL ourselves to point to web portal\n    return { url: `https://flowcrypt.com/${rawResponse.short}` };\n  }\n\n  public static messageToken = async (fcAuth: FcUuidAuth): Promise<BackendRes.FcMsgToken> => {\n    FlowCryptComApi.throwIfMissingUuid(fcAuth);\n    return await FlowCryptComApi.request<BackendRes.FcMsgToken>('message/token', { ...fcAuth });\n  }\n\n  private static request = async <RT>(path: string, vals: Dict<any>, fmt: ReqFmt = 'JSON', addHeaders: Dict<string> = {}, progressCbs?: ProgressCbs): Promise<RT> => {\n    return await FlowCryptComApi.apiCall(FlowCryptWebsite.url('api'), path, vals, fmt, progressCbs, { 'api-version': '3', ...addHeaders });\n  }\n\n  private static throwIfMissingUuid = (fcAuth: FcUuidAuth) => {\n    if (!fcAuth.uuid) {\n      throw new BackendAuthErr('Please log into FlowCrypt account first');\n    }\n  }\n\n}\n",
    "extension/js/common/api/email-provider/gmail/gmail.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { AddrParserResult, BrowserWindow } from '../../../browser/browser-window.js';\nimport { ChunkedCb, ProgressCb, EmailProviderContact } from '../../shared/api.js';\nimport { Dict, Str, Value } from '../../../core/common.js';\nimport { EmailProviderApi, EmailProviderInterface, Backups } from '../email-provider-api.js';\nimport { GOOGLE_API_HOST, gmailBackupSearchQuery } from '../../../core/const.js';\nimport { GmailParser, GmailRes } from './gmail-parser.js';\nimport { AjaxErr } from '../../shared/api-error.js';\nimport { Attachment } from '../../../core/attachment.js';\nimport { BrowserMsg } from '../../../browser/browser-msg.js';\nimport { Buf } from '../../../core/buf.js';\nimport { Catch } from '../../../platform/catch.js';\nimport { KeyUtil } from '../../../core/crypto/key.js';\nimport { Env } from '../../../browser/env.js';\nimport { FormatError } from '../../../core/crypto/pgp/msg-util.js';\nimport { Google } from './google.js';\nimport { GoogleAuth } from './google-auth.js';\nimport { Mime } from '../../../core/mime.js';\nimport { PgpArmor } from '../../../core/crypto/pgp/pgp-armor.js';\nimport { SendableMsg } from '../sendable-msg.js';\nimport { Xss } from '../../../platform/xss.js';\nimport { KeyStore } from '../../../platform/store/key-store.js';\n\nexport type GmailResponseFormat = 'raw' | 'full' | 'metadata';\n\nexport class Gmail extends EmailProviderApi implements EmailProviderInterface {\n\n  private readonly GMAIL_USELESS_CONTACTS_FILTER = '-to:txt.voice.google.com -to:craigslist.org';\n  private readonly GMAIL_SEARCH_QUERY_LENGTH_LIMIT = 1400;\n\n  public privatebuildSearchQueryOr = (arr: string[], quoted: boolean = false) => {\n    if (quoted) {\n      return '(\"' + arr.join('\") OR (\"') + '\")';\n    } else {\n      return '(' + arr.join(') OR (') + ')';\n    }\n  }\n\n  public threadGet = async (threadId: string, format?: GmailResponseFormat, progressCb?: ProgressCb): Promise<GmailRes.GmailThread> => {\n    return await Google.gmailCall<GmailRes.GmailThread>(this.acctEmail, 'GET', `threads/${threadId}`, { format }, { download: progressCb });\n  }\n\n  public threadList = async (labelId: string): Promise<GmailRes.GmailThreadList> => {\n    return await Google.gmailCall<GmailRes.GmailThreadList>(this.acctEmail, 'GET', `threads`, {\n      labelIds: labelId !== 'ALL' ? labelId : undefined,\n      includeSpamTrash: Boolean(labelId === 'SPAM' || labelId === 'TRASH'),\n      // pageToken: page_token,\n      // q,\n      // maxResults\n    });\n  }\n\n  public threadModify = async (id: string, rmLabels: string[], addLabels: string[]): Promise<GmailRes.GmailThread> => {\n    return await Google.gmailCall<GmailRes.GmailThread>(this.acctEmail, 'POST', `threads/${id}/modify`, {\n      removeLabelIds: rmLabels || [], // todo - insufficient permission - need https://github.com/FlowCrypt/flowcrypt-browser/issues/1304\n      addLabelIds: addLabels || [],\n    });\n  }\n\n  public draftCreate = async (mimeMsg: string, threadId: string): Promise<GmailRes.GmailDraftCreate> => {\n    return await Google.gmailCall<GmailRes.GmailDraftCreate>(this.acctEmail, 'POST', 'drafts', { message: { raw: Buf.fromUtfStr(mimeMsg).toBase64UrlStr(), threadId } });\n  }\n\n  public draftDelete = async (id: string): Promise<GmailRes.GmailDraftDelete> => {\n    return await Google.gmailCall<GmailRes.GmailDraftDelete>(this.acctEmail, 'DELETE', 'drafts/' + id, undefined);\n  }\n\n  public draftUpdate = async (id: string, mimeMsg: string, threadId: string): Promise<GmailRes.GmailDraftUpdate> => {\n    return await Google.gmailCall<GmailRes.GmailDraftUpdate>(this.acctEmail, 'PUT', `drafts/${id}`, { message: { raw: Buf.fromUtfStr(mimeMsg).toBase64UrlStr(), threadId } });\n  }\n\n  public draftGet = async (id: string, format: GmailResponseFormat = 'full'): Promise<GmailRes.GmailDraftGet> => {\n    return await Google.gmailCall<GmailRes.GmailDraftGet>(this.acctEmail, 'GET', `drafts/${id}`, { format });\n  }\n\n  public draftList = async (): Promise<GmailRes.GmailDraftList> => {\n    return await Google.gmailCall<GmailRes.GmailDraftList>(this.acctEmail, 'GET', 'drafts', undefined);\n  }\n\n  public draftSend = async (id: string): Promise<GmailRes.GmailDraftSend> => {\n    return await Google.gmailCall<GmailRes.GmailDraftSend>(this.acctEmail, 'POST', 'drafts/send', { id });\n  }\n\n  public msgSend = async (sendableMsg: SendableMsg, progressCb?: ProgressCb): Promise<GmailRes.GmailMsgSend> => {\n    const cbs = { upload: progressCb || Value.noop };\n    const jsonPart = JSON.stringify({ threadId: sendableMsg.thread });\n    const mimeMsg = await sendableMsg.toMime();\n    const request = Google.encodeAsMultipartRelated({ 'application/json; charset=UTF-8': jsonPart, 'message/rfc822': mimeMsg });\n    return await Google.gmailCall<GmailRes.GmailMsgSend>(this.acctEmail, 'POST', 'messages/send', request.body, cbs, request.contentType);\n  }\n\n  public msgList = async (q: string, includeDeleted: boolean = false, pageToken?: string): Promise<GmailRes.GmailMsgList> => {\n    return await Google.gmailCall<GmailRes.GmailMsgList>(this.acctEmail, 'GET', 'messages', { q, includeSpamTrash: includeDeleted, pageToken });\n  }\n\n  /**\n   * Attempting to `msgGet format:raw` from within content scripts would likely fail if the mime message is 1MB or larger,\n   * because strings over 1 MB may fail to get to/from bg page. A way to mitigate that would be to pass `R.GmailMsg$raw` prop\n   * as a Buf instead of a string.\n   */\n  public msgGet = async (msgId: string, format: GmailResponseFormat, progressCb?: ProgressCb): Promise<GmailRes.GmailMsg> => {\n    return await Google.gmailCall<GmailRes.GmailMsg>(this.acctEmail, 'GET', `messages/${msgId}`, { format: format || 'full' }, { download: progressCb });\n  }\n\n  public msgsGet = async (msgIds: string[], format: GmailResponseFormat): Promise<GmailRes.GmailMsg[]> => {\n    return await Promise.all(msgIds.map(id => this.msgGet(id, format)));\n  }\n\n  public labelsGet = async (): Promise<GmailRes.GmailLabels> => {\n    return await Google.gmailCall<GmailRes.GmailLabels>(this.acctEmail, 'GET', `labels`, {});\n  }\n\n  public attachmentGet = async (msgId: string, attId: string, progressCb?: ProgressCb): Promise<GmailRes.GmailAttachment> => {\n    type RawGmailAttRes = { attachmentId: string, size: number, data: string };\n    const { attachmentId, size, data } = await Google.gmailCall<RawGmailAttRes>(this.acctEmail, 'GET', `messages/${msgId}/attachments/${attId}`, {}, { download: progressCb });\n    return { attachmentId, size, data: Buf.fromBase64UrlStr(data) }; // data should be a Buf for ease of passing to/from bg page\n  }\n\n  public attachmentGetChunk = async (msgId: string, attachmentId: string): Promise<Buf> => {\n    if (Env.isContentScript()) {\n      // content script CORS not allowed anymore, have to drag it through background page\n      // https://www.chromestatus.com/feature/5629709824032768\n      const { chunk } = await BrowserMsg.send.bg.await.ajaxGmailAttachmentGetChunk({ acctEmail: this.acctEmail, msgId, attachmentId });\n      return chunk;\n    }\n    const stack = Catch.stackTrace();\n    const minBytes = 1000;\n    let processed = 0;\n    return await new Promise((resolve, reject) => {\n      const processChunkAndResolve = (chunk: string) => {\n        if (!processed++) {\n          // make json end guessing easier\n          chunk = chunk.replace(/[\\n\\s\\r]/g, '');\n          // the response is a chunk of json that may not have ended. One of:\n          // {\"length\":123,\"data\":\"kks\n          // {\"length\":123,\"data\":\"kksdwei\n          // {\"length\":123,\"data\":\"kksdwei\"\n          // {\"length\":123,\"data\":\"kksdwei\"}\n          if (chunk[chunk.length - 1] !== '\"' && chunk[chunk.length - 2] !== '\"') {\n            chunk += '\"}'; // json end\n          } else if (chunk[chunk.length - 1] !== '}') {\n            chunk += '}'; // json end\n          }\n          let parsedJsonDataField;\n          try {\n            parsedJsonDataField = JSON.parse(chunk).data; // tslint:disable-line:no-unsafe-any\n          } catch (e) {\n            console.info(e);\n            reject(new Error(\"Chunk response could not be parsed\"));\n            return;\n          }\n          for (let i = 0; parsedJsonDataField && i < 50; i++) {\n            try {\n              resolve(Buf.fromBase64UrlStr(parsedJsonDataField)); // tslint:disable-line:no-unsafe-any\n              return;\n            } catch (e) {\n              // the chunk of data may have been cut at an inconvenient index\n              // shave off up to 50 trailing characters until it can be decoded\n              parsedJsonDataField = parsedJsonDataField.slice(0, -1); // tslint:disable-line:no-unsafe-any\n            }\n          }\n          reject(new Error(\"Chunk response could not be decoded\"));\n        }\n      };\n      GoogleAuth.googleApiAuthHeader(this.acctEmail).then(authToken => {\n        const r = new XMLHttpRequest();\n        const method = 'GET';\n        const url = `${GOOGLE_API_HOST}/gmail/v1/users/me/messages/${msgId}/attachments/${attachmentId}`;\n        r.open(method, url, true);\n        r.setRequestHeader('Authorization', authToken);\n        r.send();\n        let status: number;\n        const responsePollInterval = Catch.setHandledInterval(() => {\n          if (status >= 200 && status <= 299 && r.responseText.length >= minBytes) {\n            window.clearInterval(responsePollInterval);\n            processChunkAndResolve(r.responseText);\n            r.abort();\n          }\n        }, 10);\n        r.onreadystatechange = () => {\n          if (r.readyState === 2 || r.readyState === 3) { // headers, loading\n            status = r.status;\n            if (status >= 300) {\n              reject(AjaxErr.fromXhr({ status, readyState: r.readyState }, { method, url }, stack));\n              window.clearInterval(responsePollInterval);\n              r.abort();\n            }\n          }\n          if (r.readyState === 3 || r.readyState === 4) { // loading, done\n            if (status >= 200 && status <= 299 && r.responseText.length >= minBytes) { // done as a success - resolve in case response_poll didn't catch this yet\n              processChunkAndResolve(r.responseText);\n              window.clearInterval(responsePollInterval);\n              if (r.readyState === 3) {\n                r.abort();\n              }\n            } else { // done as a fail - reject\n              reject(AjaxErr.fromXhr({ status, readyState: r.readyState }, { method, url }, stack));\n              window.clearInterval(responsePollInterval);\n            }\n          }\n        };\n      }).catch(reject);\n    });\n  }\n\n  public fetchAttachments = async (attachments: Attachment[], progressCb?: ProgressCb) => {\n    if (!attachments.length) {\n      return;\n    }\n    let lastProgressPercent = -1;\n    const loadedAr: Array<number> = [];\n    // 1.33 is approximate ratio of downloaded data to what we expected, likely due to encoding\n    const total = attachments.map(x => x.length).reduce((a, b) => a + b) * 1.33;\n    const responses = await Promise.all(attachments.map((a, index) => this.attachmentGet(a.msgId!, a.id!, (_, loaded) => {\n      if (progressCb) {\n        loadedAr[index] = loaded || 0;\n        const totalLoaded = loadedAr.reduce((a, b) => a + b);\n        const progressPercent = Math.round((totalLoaded * 100) / total);\n        if (progressPercent !== lastProgressPercent) {\n          lastProgressPercent = progressPercent;\n          progressCb(progressPercent, totalLoaded, total);\n        }\n      }\n    })));\n    for (const i of responses.keys()) {\n      attachments[i].setData(responses[i].data);\n    }\n  }\n\n  /**\n   * This will keep triggering callback with new emails as they are being discovered\n   */\n  public guessContactsFromSentEmails = async (userQuery: string, knownEmails: string[], chunkedCb: ChunkedCb): Promise<void> => {\n    userQuery = userQuery.toLowerCase();\n    let gmailQuery = `is:sent ${this.GMAIL_USELESS_CONTACTS_FILTER} `;\n    const needles: string[] = [];\n    if (userQuery) {\n      needles.push(...userQuery.split(/[ .]/g).filter(v => !['com', 'org', 'net'].includes(v)));\n      if (!needles.includes(userQuery)) {\n        needles.push(userQuery);\n      }\n      gmailQuery += '(';\n      for (let i = 0; i < needles.length; i++) {\n        const needle = needles[i];\n        gmailQuery += `to:${needle}`;\n        if (gmailQuery.length > this.GMAIL_SEARCH_QUERY_LENGTH_LIMIT) {\n          break;\n        }\n        if (i < needles.length - 1) {\n          gmailQuery += ' OR ';\n        }\n      }\n      gmailQuery += ')';\n    }\n    for (const email of knownEmails) {\n      if (gmailQuery.length > this.GMAIL_SEARCH_QUERY_LENGTH_LIMIT) {\n        break;\n      }\n      gmailQuery += ` -to:${email}`;\n    }\n    await this.apiGmailLoopThroughEmailsToCompileContacts(needles, gmailQuery, chunkedCb);\n  }\n\n  /**\n   * Extracts the encrypted message from gmail api. Sometimes it's sent as a text, sometimes html, sometimes attachments in various forms.\n   */\n  public extractArmoredBlock = async (msgId: string, format: GmailResponseFormat, progressCb?: ProgressCb): Promise<{ armored: string, subject?: string, isPwdMsg: boolean }> => {\n    // only track progress in this call if we are getting RAW mime, because these tend to be big, while 'full' and 'metadata' are tiny\n    // since we often do full + get attachments below, the user would see 100% after the first short request,\n    //   and then again 0% when attachments start downloading, which would be confusing\n    const gmailMsg = await this.msgGet(msgId, format, format === 'raw' ? progressCb : undefined);\n    const isPwdMsg = /https:\\/\\/flowcrypt\\.com\\/[a-zA-Z0-9]{10}$/.test(gmailMsg.snippet || '');\n    const subject = gmailMsg.payload ? GmailParser.findHeader(gmailMsg.payload, 'subject') : undefined;\n    if (format === 'full') {\n      const bodies = GmailParser.findBodies(gmailMsg);\n      const attachments = GmailParser.findAttachments(gmailMsg);\n      const fromTextBody = PgpArmor.clip(Buf.fromBase64UrlStr(bodies['text/plain'] || '').toUtfStr());\n      if (fromTextBody) {\n        return { armored: fromTextBody, subject, isPwdMsg };\n      }\n      const fromHtmlBody = PgpArmor.clip(Xss.htmlSanitizeAndStripAllTags(Buf.fromBase64UrlStr(bodies['text/html'] || '').toUtfStr(), '\\n'));\n      if (fromHtmlBody) {\n        return { armored: fromHtmlBody, subject, isPwdMsg };\n      }\n      if (attachments.length) {\n        for (const attachment of attachments) {\n          if (attachment.treatAs() === 'encryptedMsg') {\n            await this.fetchAttachments([attachment], progressCb);\n            const armoredMsg = PgpArmor.clip(attachment.getData().toUtfStr());\n            if (!armoredMsg) {\n              throw new FormatError('Problem extracting armored message', attachment.getData().toUtfStr());\n            }\n            return { armored: armoredMsg, subject, isPwdMsg };\n          }\n        }\n        throw new FormatError('Armored message not found', JSON.stringify(gmailMsg.payload, undefined, 2));\n      } else {\n        throw new FormatError('No attachments', JSON.stringify(gmailMsg.payload, undefined, 2));\n      }\n    } else { // format === raw\n      const mimeMsg = Buf.fromBase64UrlStr(gmailMsg.raw!);\n      const decoded = await Mime.decode(mimeMsg);\n      if (decoded.text !== undefined) {\n        const armoredMsg = PgpArmor.clip(decoded.text); // todo - the message might be in attachments\n        if (armoredMsg) {\n          return { armored: armoredMsg, subject, isPwdMsg };\n        } else {\n          throw new FormatError('Could not find armored message in parsed raw mime', mimeMsg.toUtfStr());\n        }\n      } else {\n        throw new FormatError('No text in parsed raw mime', mimeMsg.toUtfStr());\n      }\n    }\n  }\n\n  public fetchAcctAliases = async (): Promise<GmailRes.GmailAliases> => {\n    const res = await Google.gmailCall<GmailRes.GmailAliases>(this.acctEmail, 'GET', 'settings/sendAs', {}) as GmailRes.GmailAliases;\n    for (const sendAs of res.sendAs) {\n      sendAs.sendAsEmail = sendAs.sendAsEmail.toLowerCase();\n    }\n    return res;\n  }\n\n  public fetchMsgsHeadersBasedOnQuery = async (q: string, headerNames: string[], msgLimit: number) => {\n    const { messages } = await this.msgList(q, false);\n    return await this.extractHeadersFromMsgs(messages || [], headerNames, msgLimit);\n  }\n\n  public fetchKeyBackups = async (): Promise<Backups> => {\n    const res = await this.msgList(gmailBackupSearchQuery(this.acctEmail), true);\n    const msgIds = (res.messages || []).map(m => m.id);\n    const msgs = await this.msgsGet(msgIds, 'full');\n    const attachments: Attachment[] = [];\n    for (const msg of msgs) {\n      attachments.push(...GmailParser.findAttachments(msg));\n    }\n    await this.fetchAttachments(attachments);\n    const { keys: foundBackupKeys } = await KeyUtil.readMany(Buf.fromUtfStr(attachments.map(a => a.getData().toUtfStr()).join('\\n')));\n    const backups = await Promise.all(foundBackupKeys.map(k => KeyUtil.keyInfoObj(k)));\n    const imported = await KeyStore.get(this.acctEmail);\n    const importedLongids = imported.map(ki => ki.longid);\n    const backedUpLongids = backups.map(ki => ki.longid);\n    const keyinfos = {\n      backups,\n      backupsImported: backups.filter(backupKi => importedLongids.includes(backupKi.longid)),\n      backupsNotImported: backups.filter(backupKi => !importedLongids.includes(backupKi.longid)),\n      importedNotBackedUp: imported.filter(importedKi => !backedUpLongids.includes(importedKi.longid)),\n    };\n    const longids = {\n      backups: Value.arr.unique(keyinfos.backups.map(ki => ki.longid)),\n      backupsImported: Value.arr.unique(keyinfos.backupsImported.map(ki => ki.longid)),\n      backupsNotImported: Value.arr.unique(keyinfos.backupsNotImported.map(ki => ki.longid)),\n      importedNotBackedUp: Value.arr.unique(keyinfos.importedNotBackedUp.map(ki => ki.longid)),\n    };\n    return { keyinfos, longids };\n  }\n\n  private apiGmailBuildFilteredQuery = (query: string, allRawEmails: string[]) => {\n    let filteredQuery = query;\n    for (const rawEmail of allRawEmails) {\n      filteredQuery += ` -to:\"${rawEmail}\"`;\n      if (filteredQuery.length > this.GMAIL_SEARCH_QUERY_LENGTH_LIMIT) {\n        return filteredQuery;\n      }\n    }\n    return filteredQuery;\n  }\n\n  private apiGmailGetNewUniqueRecipientsFromHeaders = async (toHeaders: string[], allResults: EmailProviderContact[], allRawEmails: string[]): Promise<EmailProviderContact[]> => {\n    if (!toHeaders.length) {\n      return [];\n    }\n    const rawParsedResults: AddrParserResult[] = [];\n    toHeaders = Value.arr.unique(toHeaders);\n    for (const to of toHeaders) {\n      rawParsedResults.push(...(window as unknown as BrowserWindow)['emailjs-addressparser'].parse(to));\n    }\n    for (const rawParsedRes of rawParsedResults) {\n      if (rawParsedRes.address && allRawEmails.indexOf(rawParsedRes.address) === -1) {\n        allRawEmails.push(rawParsedRes.address);\n      }\n    }\n    const rawValidEmails = rawParsedResults.filter(r => r.address && Str.isEmailValid(r.address));\n    const newValidResults: EmailProviderContact[] = await Promise.all(rawValidEmails.map((a) => { return { email: a.address!, name: a.name } as EmailProviderContact; }));\n    const uniqueNewValidResults: EmailProviderContact[] = [];\n    for (const newValidRes of newValidResults) {\n      if (allResults.map(c => c.email).indexOf(newValidRes.email) === -1) {\n        const foundIndex = uniqueNewValidResults.map(c => c.email).indexOf(newValidRes.email);\n        if (foundIndex === -1) {\n          uniqueNewValidResults.push(newValidRes);\n        } else if (newValidRes.name && !uniqueNewValidResults[foundIndex].name) {\n          uniqueNewValidResults[foundIndex].name = newValidRes.name; // prefer to also save name if first encountered result is missing it\n        }\n      }\n    }\n    return uniqueNewValidResults;\n  }\n\n  private apiGmailLoopThroughEmailsToCompileContacts = async (needles: string[], gmailQuery: string, chunkedCb: ChunkedCb) => {\n    const allResults: EmailProviderContact[] = [];\n    const allRawEmails: string[] = [];\n    const allMatchingResults: EmailProviderContact[] = [];\n    let lastFilteredQuery = '';\n    let continueSearching = true;\n    while (continueSearching) {\n      const filteredQuery = this.apiGmailBuildFilteredQuery(gmailQuery, allRawEmails);\n      if (filteredQuery === lastFilteredQuery) {\n        break;\n      }\n      if (filteredQuery.length > this.GMAIL_SEARCH_QUERY_LENGTH_LIMIT) {\n        continueSearching = false;\n      }\n      const headers = await this.fetchMsgsHeadersBasedOnQuery(filteredQuery, ['to'], 50);\n      lastFilteredQuery = filteredQuery;\n      const uniqueNewValidResults = await this.apiGmailGetNewUniqueRecipientsFromHeaders(headers.to, allResults, allRawEmails);\n      if (!uniqueNewValidResults.length) {\n        break;\n      }\n      allResults.push(...uniqueNewValidResults);\n      const uniqueNewValidMatchingResults = uniqueNewValidResults.filter(r => this.doesGmailsContactGuessResultMatchNeedles(needles, r));\n      if (uniqueNewValidMatchingResults.length) {\n        allMatchingResults.push(...uniqueNewValidMatchingResults);\n        await chunkedCb({ new: uniqueNewValidMatchingResults, all: allMatchingResults });\n      }\n    }\n    await chunkedCb({ new: [], all: allResults });\n  }\n\n  private doesGmailsContactGuessResultMatchNeedles = (needles: string[], contact: EmailProviderContact): boolean => {\n    if (!needles.length) {\n      return true; // no search query provided, so anything matches\n    }\n    const comparable = `${contact.email}\\n${contact.name || ''}`.toLowerCase();\n    return !!needles.find(needle => comparable.includes(needle));\n  }\n\n  private extractHeadersFromMsgs = async (msgsIds: GmailRes.GmailMsgList$message[], headerNames: string[], msgLimit: number): Promise<Dict<string[]>> => {\n    const headerVals: Dict<string[]> = {};\n    for (const headerName of headerNames) {\n      headerVals[headerName] = [];\n    }\n    for (const msg of await this.msgsGet(msgsIds.slice(0, msgLimit).map(m => m.id), 'metadata')) {\n      for (const headerName of headerNames) {\n        const value = GmailParser.findHeader(msg, headerName);\n        if (typeof value !== 'undefined') {\n          headerVals[headerName].push(value);\n        }\n      }\n    }\n    return headerVals;\n  }\n\n}\n",
    "extension/js/common/api/email-provider/gmail/google-auth.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\n// tslint:disable:no-direct-ajax\n// tslint:disable:oneliner-object-literal\n\nimport { GOOGLE_API_HOST, GOOGLE_OAUTH_SCREEN_HOST, FLAVOR } from '../../../core/const.js';\nimport { Str, Url, Value } from '../../../core/common.js';\nimport { tabsQuery, windowsCreate } from '../../../browser/chrome.js';\nimport { Api } from './../../shared/api.js';\nimport { ApiErr } from '../../shared/api-error.js';\n\nimport { Buf } from '../../../core/buf.js';\nimport { Catch } from '../../../platform/catch.js';\nimport { GmailRes } from './gmail-parser';\nimport { GoogleAuthErr } from '../../shared/api-error.js';\nimport { GoogleAuthWindowResult$result } from '../../../browser/browser-msg.js';\nimport { Ui } from '../../../browser/ui.js';\nimport { AcctStore, AcctStoreDict } from '../../../platform/store/acct-store.js';\nimport { AccountServer } from '../../account-server.js';\nimport { EnterpriseServer } from '../../account-servers/enterprise-server.js';\n\ntype GoogleAuthTokenInfo = { issued_to: string, audience: string, scope: string, expires_in: number, access_type: 'offline' };\ntype GoogleAuthTokensResponse = { access_token: string, expires_in: number, refresh_token?: string, id_token: string, token_type: 'Bearer' };\ntype AuthResultSuccess = { result: 'Success', acctEmail: string, id_token: string, error?: undefined };\ntype AuthResultError = { result: GoogleAuthWindowResult$result, acctEmail?: string, error?: string, id_token: undefined };\n\ntype AuthReq = { acctEmail?: string, scopes: string[], messageId?: string, csrfToken: string };\nexport type AuthRes = AuthResultSuccess | AuthResultError;\n\nexport class GoogleAuth {\n\n  public static OAUTH = {\n    client_id: '717284730244-ostjo2fdtr3ka4q9td69tdr9acmmru2p.apps.googleusercontent.com',\n    url_code: `${GOOGLE_OAUTH_SCREEN_HOST}/o/oauth2/auth`,\n    url_tokens: `${GOOGLE_API_HOST}/oauth2/v4/token`,\n    url_redirect: 'urn:ietf:wg:oauth:2.0:oob:auto',\n    state_header: 'CRYPTUP_STATE_',\n    scopes: {\n      email: 'email',\n      openid: 'openid',\n      profile: 'https://www.googleapis.com/auth/userinfo.profile', // needed so that `name` is present in `id_token`, which is required for key-server auth when in use\n      compose: 'https://www.googleapis.com/auth/gmail.compose',\n      modify: 'https://www.googleapis.com/auth/gmail.modify',\n      readContacts: 'https://www.googleapis.com/auth/contacts.readonly',\n    },\n    legacy_scopes: {\n      read: 'https://www.googleapis.com/auth/gmail.readonly', // deprecated in favor of modify, which also includes read\n      gmail: 'https://mail.google.com/', // causes a freakish oauth warn: \"can permannently delete all your email\" ...\n    }\n  };\n\n  public static defaultScopes = (group: 'default' | 'contacts' | 'openid' = 'default') => {\n    const { readContacts, compose, modify, openid, email, profile } = GoogleAuth.OAUTH.scopes;\n    console.info(`Not using scope ${modify} because not approved on oauth screen yet`);\n    const read = GoogleAuth.OAUTH.legacy_scopes.read; // todo - remove as soon as \"modify\" is approved by google\n    if (group === 'openid') {\n      return [openid, email, profile];\n    } else if (group === 'default') {\n      if (FLAVOR === 'consumer') {\n        // todo - replace \"read\" with \"modify\" when approved by google\n        return [openid, email, profile, compose, read]; // consumer may freak out that extension asks for their contacts early on\n      } else if (FLAVOR === 'enterprise') {\n        // todo - replace \"read\" with \"modify\" when approved by google\n        return [openid, email, profile, compose, read, readContacts]; // enterprise expects their contact search to work properly\n      } else {\n        throw new Error(`Unknown build ${FLAVOR}`);\n      }\n    } else if (group === 'contacts') {\n      // todo - replace \"read\" with \"modify\" when approved by google\n      return [openid, email, profile, compose, read, readContacts];\n    } else {\n      throw new Error(`Unknown scope group ${group}`);\n    }\n  }\n\n  public static googleApiAuthHeader = async (acctEmail: string, forceRefresh = false): Promise<string> => {\n    if (!acctEmail) {\n      throw new Error('missing account_email in api_gmail_call');\n    }\n    const storage = await AcctStore.get(acctEmail, ['google_token_access', 'google_token_expires', 'google_token_scopes', 'google_token_refresh']);\n    if (!storage.google_token_access || !storage.google_token_refresh) {\n      throw new GoogleAuthErr(`Account ${acctEmail} not connected to FlowCrypt Browser Extension`);\n    } else if (GoogleAuth.googleApiIsAuthTokenValid(storage) && !forceRefresh) {\n      return `Bearer ${storage.google_token_access}`;\n    } else { // refresh token\n      const refreshTokenRes = await GoogleAuth.googleAuthRefreshToken(storage.google_token_refresh);\n      await GoogleAuth.googleAuthCheckAccessToken(refreshTokenRes.access_token); // https://groups.google.com/forum/#!topic/oauth2-dev/QOFZ4G7Ktzg\n      await GoogleAuth.googleAuthSaveTokens(acctEmail, refreshTokenRes, storage.google_token_scopes || []);\n      const auth = await AcctStore.get(acctEmail, ['google_token_access', 'google_token_expires']);\n      if (GoogleAuth.googleApiIsAuthTokenValid(auth)) { // have a valid gmail_api oauth token\n        return `Bearer ${auth.google_token_access}`;\n      } else {\n        throw new GoogleAuthErr(`Could not refresh google auth token - did not become valid (access:${!!auth.google_token_access},expires:${auth.google_token_expires},now:${Date.now()})`);\n      }\n    }\n  }\n\n  public static apiGoogleCallRetryAuthErrorOneTime = async (acctEmail: string, request: JQuery.AjaxSettings): Promise<any> => {\n    try {\n      return await Api.ajax(request, Catch.stackTrace());\n    } catch (firstAttemptErr) {\n      if (ApiErr.isAuthErr(firstAttemptErr)) { // force refresh token\n        request.headers!.Authorization = await GoogleAuth.googleApiAuthHeader(acctEmail, true);\n        return await Api.ajax(request, Catch.stackTrace());\n      }\n      throw firstAttemptErr;\n    }\n  }\n\n  public static newAuthPopup = async ({ acctEmail, scopes, save }: { acctEmail?: string, scopes?: string[], save?: boolean }): Promise<AuthRes> => {\n    if (acctEmail) {\n      acctEmail = acctEmail.toLowerCase();\n    }\n    if (typeof save === 'undefined') {\n      save = true;\n    }\n    if (save || !scopes) { // if tokens will be saved (meaning also scopes should be pulled from storage) or if no scopes supplied\n      scopes = await GoogleAuth.apiGoogleAuthPopupPrepareAuthReqScopes(acctEmail, scopes || GoogleAuth.defaultScopes());\n    }\n    const authRequest: AuthReq = { acctEmail, scopes, csrfToken: `csrf-${Api.randomFortyHexChars()}` };\n    const url = GoogleAuth.apiGoogleAuthCodeUrl(authRequest);\n    const oauthWin = await windowsCreate({ url, left: 100, top: 50, height: 800, width: 550, type: 'popup' });\n    if (!oauthWin || !oauthWin.tabs || !oauthWin.tabs.length || !oauthWin.id) {\n      return { result: 'Error', error: 'No oauth window renturned after initiating it', acctEmail, id_token: undefined };\n    }\n    const authRes = await Promise.race([\n      GoogleAuth.waitForAndProcessOauthWindowResult(oauthWin.id, acctEmail, scopes, authRequest.csrfToken, save),\n      GoogleAuth.waitForOauthWindowClosed(oauthWin.id, acctEmail),\n    ]);\n    if (authRes.result === 'Success') {\n      chrome.windows.remove(oauthWin.id); // The prompt windows is removed when the user is authorized.\n      if (!authRes.id_token) {\n        return { result: 'Error', error: 'Grant was successful but missing id_token', acctEmail: authRes.acctEmail, id_token: undefined };\n      }\n      if (!authRes.acctEmail) {\n        return { result: 'Error', error: 'Grant was successful but missing acctEmail', acctEmail: authRes.acctEmail, id_token: undefined };\n      }\n      try {\n        const uuid = Api.randomFortyHexChars(); // for flowcrypt.com, if used. When FES is used, the access token is given to client.\n        const potentialFes = new EnterpriseServer(authRes.acctEmail);\n        if (await potentialFes.isFesInstalledAndAvailable()) {\n          await AcctStore.set(authRes.acctEmail, { fesUrl: potentialFes.url });\n        }\n        const acctServer = new AccountServer(authRes.acctEmail);\n        await acctServer.loginWithOpenid(authRes.acctEmail, uuid, authRes.id_token); // may be calling flowcrypt.com or FES\n        await acctServer.accountGetAndUpdateLocalStore({ account: authRes.acctEmail, uuid }); // stores OrgRules and subscription\n      } catch (e) {\n        if (GoogleAuth.isFesUnreachableErr(e, authRes.acctEmail)) {\n          const error = `Cannot reach your company's FlowCrypt Enterprise Server (FES). Contact human@flowcrypt.com when unsure. (${String(e)})`;\n          return { result: 'Error', error, acctEmail: authRes.acctEmail, id_token: undefined };\n        }\n        return { result: 'Error', error: `Grant successful but error accessing fc account: ${String(e)}`, acctEmail: authRes.acctEmail, id_token: undefined };\n      }\n    }\n    return authRes;\n  }\n\n  /**\n   * Happens on enterprise builds\n   */\n  public static isFesUnreachableErr = (e: any, email: string): boolean => {\n    const domain = Str.getDomainFromEmailAddress(email);\n    const errString = String(e);\n    if (errString.includes(`-1 when GET-ing https://fes.${domain}/api/ `)) { // the space is important to match the full url\n      return true; // err trying to reach FES itself at a predictable URL\n    }\n    return false;\n  }\n\n  public static newOpenidAuthPopup = async ({ acctEmail }: { acctEmail?: string }): Promise<AuthRes> => {\n    return await GoogleAuth.newAuthPopup({ acctEmail, scopes: GoogleAuth.defaultScopes('openid'), save: false });\n  }\n\n  private static waitForOauthWindowClosed = async (oauthWinId: number, acctEmail: string | undefined): Promise<AuthRes> => {\n    return await new Promise(resolve => {\n      const onOauthWinClosed = (closedWinId: number) => {\n        if (closedWinId === oauthWinId) {\n          chrome.windows.onRemoved.removeListener(onOauthWinClosed);\n          resolve({ result: 'Closed', acctEmail, id_token: undefined });\n        }\n      };\n      chrome.windows.onRemoved.addListener(onOauthWinClosed);\n    });\n  }\n\n  private static processOauthResTitle = (title: string): { result: GoogleAuthWindowResult$result, code?: string, error?: string, csrf?: string } => {\n    const parts = title.split(' ', 2);\n    const result = parts[0] as GoogleAuthWindowResult$result;\n    const params = Url.parse(['code', 'state', 'error'], parts[1]);\n    let authReq: AuthReq;\n    try {\n      authReq = GoogleAuth.apiGoogleAuthStateUnpack(String(params.state));\n    } catch (e) {\n      return { result: 'Error', error: `Wrong oauth state response: ${e}` };\n    }\n    if (!['Success', 'Denied', 'Error'].includes(result)) {\n      return { result: 'Error', error: `Unknown google auth result '${result}'` };\n    }\n    return { result, code: params.code ? String(params.code) : undefined, error: params.error ? String(params.error) : undefined, csrf: authReq.csrfToken };\n  }\n\n  /**\n   * Is the title actually just url of the page? (means real title not loaded yet)\n   */\n  private static isUrl = (title: string) => {\n    return title.match(/^(?:https?:\\/\\/)?accounts\\.google\\.com/) !== null\n      || title.startsWith(GOOGLE_OAUTH_SCREEN_HOST.replace(/^https?:\\/\\//, ''))\n      || title.startsWith(GOOGLE_OAUTH_SCREEN_HOST);\n  }\n\n  private static isForwarding = (title: string) => {\n    return title.match(/^Forwarding /) !== null;\n  }\n\n  private static waitForAndProcessOauthWindowResult = async (windowId: number, acctEmail: string | undefined, scopes: string[], csrfToken: string, save: boolean): Promise<AuthRes> => {\n    while (true) {\n      const [oauth] = await tabsQuery({ windowId });\n      if (oauth?.title && oauth.title.includes(GoogleAuth.OAUTH.state_header) && !GoogleAuth.isUrl(oauth.title) && !GoogleAuth.isForwarding(oauth.title)) {\n        const { result, error, code, csrf } = GoogleAuth.processOauthResTitle(oauth.title);\n        if (error === 'access_denied') {\n          return { acctEmail, result: 'Denied', error, id_token: undefined }; // sometimes it was coming in as {\"result\":\"Error\",\"error\":\"access_denied\"}\n        }\n        if (result === 'Success') {\n          if (!csrf || csrf !== csrfToken) {\n            return { acctEmail, result: 'Error', error: `Wrong oauth CSRF token. Please try again.`, id_token: undefined };\n          }\n          if (code) {\n            const { id_token } = save ? await GoogleAuth.retrieveAndSaveAuthToken(code, scopes) : await GoogleAuth.googleAuthGetTokens(code);\n            const { email } = GoogleAuth.parseIdToken(id_token);\n            if (!email) {\n              throw new Error('Missing email address in id_token');\n            }\n            return { acctEmail: email, result: 'Success', id_token };\n          }\n          return { acctEmail, result: 'Error', error: `Google auth result was 'Success' but no auth code`, id_token: undefined };\n        }\n        return { acctEmail, result, error: error ? error : '(no error provided)', id_token: undefined };\n      }\n      await Ui.time.sleep(250);\n    }\n  }\n\n  private static apiGoogleAuthCodeUrl = (authReq: AuthReq) => {\n    return Url.create(GoogleAuth.OAUTH.url_code, {\n      client_id: GoogleAuth.OAUTH.client_id,\n      response_type: 'code',\n      access_type: 'offline',\n      state: GoogleAuth.apiGoogleAuthStatePack(authReq),\n      redirect_uri: GoogleAuth.OAUTH.url_redirect,\n      scope: (authReq.scopes || []).join(' '),\n      login_hint: authReq.acctEmail,\n    });\n  }\n\n  private static apiGoogleAuthStatePack = (authReq: AuthReq) => {\n    return GoogleAuth.OAUTH.state_header + JSON.stringify(authReq);\n  }\n\n  private static apiGoogleAuthStateUnpack = (state: string): AuthReq => {\n    if (!state.startsWith(GoogleAuth.OAUTH.state_header)) {\n      throw new Error(`Missing oauth state header`);\n    }\n    return JSON.parse(state.replace(GoogleAuth.OAUTH.state_header, '')) as AuthReq;\n  }\n\n  private static googleAuthSaveTokens = async (acctEmail: string, tokensObj: GoogleAuthTokensResponse, scopes: string[]) => {\n    const openid = GoogleAuth.parseIdToken(tokensObj.id_token);\n    const { full_name, picture } = await AcctStore.get(acctEmail, ['full_name', 'picture']);\n    const toSave: AcctStoreDict = {\n      openid,\n      google_token_access: tokensObj.access_token,\n      google_token_expires: new Date().getTime() + (tokensObj.expires_in as number) * 1000,\n      google_token_scopes: scopes,\n      full_name: full_name || openid.name,\n      picture: picture || openid.picture,\n    };\n    if (typeof tokensObj.refresh_token !== 'undefined') {\n      toSave.google_token_refresh = tokensObj.refresh_token;\n    }\n    await AcctStore.set(acctEmail, toSave);\n  }\n\n  private static googleAuthGetTokens = async (code: string) => {\n    return await Api.ajax({\n      url: Url.create(GoogleAuth.OAUTH.url_tokens, { grant_type: 'authorization_code', code, client_id: GoogleAuth.OAUTH.client_id, redirect_uri: GoogleAuth.OAUTH.url_redirect }),\n      method: 'POST',\n      crossDomain: true,\n      async: true,\n    }, Catch.stackTrace()) as any as GoogleAuthTokensResponse;\n  }\n\n  private static googleAuthRefreshToken = async (refreshToken: string) => {\n    return await Api.ajax({\n      url: Url.create(GoogleAuth.OAUTH.url_tokens, { grant_type: 'refresh_token', refreshToken, client_id: GoogleAuth.OAUTH.client_id }),\n      method: 'POST',\n      crossDomain: true,\n      async: true,\n    }, Catch.stackTrace()) as any as GoogleAuthTokensResponse;\n  }\n\n  private static googleAuthCheckAccessToken = async (accessToken: string) => {\n    return await Api.ajax({\n      url: Url.create(`${GOOGLE_API_HOST}/oauth2/v1/tokeninfo`, { access_token: accessToken }),\n      crossDomain: true,\n      async: true,\n    }, Catch.stackTrace()) as any as GoogleAuthTokenInfo;\n  }\n\n  /**\n   * oauth token will be valid for another 2 min\n   */\n  private static googleApiIsAuthTokenValid = (s: AcctStoreDict) => {\n    return s.google_token_access && (!s.google_token_expires || s.google_token_expires > Date.now() + (120 * 1000));\n  }\n\n  // todo - would be better to use a TS type guard instead of the type cast when checking OpenId\n  // check for things we actually use: photo/name/locale\n  private static parseIdToken = (idToken: string): GmailRes.OpenId => {\n    const claims = JSON.parse(Buf.fromBase64UrlStr(idToken.split(/\\./g)[1]).toUtfStr()) as GmailRes.OpenId;\n    if (claims.email) {\n      claims.email = claims.email.toLowerCase();\n      if (!claims.email_verified) {\n        throw new Error(`id_token email_verified is false for email ${claims.email}`);\n      }\n    }\n    return claims;\n  }\n\n  private static retrieveAndSaveAuthToken = async (authCode: string, scopes: string[]): Promise<{ id_token: string }> => {\n    const tokensObj = await GoogleAuth.googleAuthGetTokens(authCode);\n    await GoogleAuth.googleAuthCheckAccessToken(tokensObj.access_token); // https://groups.google.com/forum/#!topic/oauth2-dev/QOFZ4G7Ktzg\n    const claims = GoogleAuth.parseIdToken(tokensObj.id_token);\n    if (!claims.email) {\n      throw new Error('Missing email address in id_token');\n    }\n    await GoogleAuth.googleAuthSaveTokens(claims.email, tokensObj, scopes);\n    return { id_token: tokensObj.id_token };\n  }\n\n  private static apiGoogleAuthPopupPrepareAuthReqScopes = async (acctEmail: string | undefined, addScopes: string[]): Promise<string[]> => {\n    if (acctEmail) {\n      const { google_token_scopes } = await AcctStore.get(acctEmail, ['google_token_scopes']);\n      addScopes.push(...(google_token_scopes || []));\n    }\n    addScopes = Value.arr.unique(addScopes);\n    if (addScopes.includes(GoogleAuth.OAUTH.legacy_scopes.read) && addScopes.includes(GoogleAuth.OAUTH.scopes.modify)) {\n      addScopes = Value.arr.withoutVal(addScopes, GoogleAuth.OAUTH.legacy_scopes.read); // modify scope is a superset of read scope\n    }\n    if (!addScopes.includes(GoogleAuth.OAUTH.scopes.email)) {\n      addScopes.push(GoogleAuth.OAUTH.scopes.email);\n    }\n    if (!addScopes.includes(GoogleAuth.OAUTH.scopes.openid)) {\n      addScopes.push(GoogleAuth.OAUTH.scopes.openid);\n    }\n    if (!addScopes.includes(GoogleAuth.OAUTH.scopes.profile)) {\n      addScopes.push(GoogleAuth.OAUTH.scopes.profile);\n    }\n    // todo - remove these following lines once \"modify\" scope is verified\n    if (addScopes.includes(GoogleAuth.OAUTH.scopes.modify)) {\n      addScopes = Value.arr.withoutVal(addScopes, GoogleAuth.OAUTH.scopes.modify);\n      addScopes.push(GoogleAuth.OAUTH.legacy_scopes.read);\n    }\n    return addScopes;\n  }\n\n}\n",
    "extension/js/common/api/email-provider/sendable-msg.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Dict, Str } from '../../core/common.js';\nimport { Mime, MimeEncodeType, SendableMsgBody } from '../../core/mime.js';\nimport { Attachment } from '../../core/attachment.js';\nimport { Buf } from '../../core/buf.js';\nimport { RecipientType } from '../shared/api.js';\nimport { KeyStore } from '../../platform/store/key-store.js';\n\ntype Recipients = { to?: string[], cc?: string[], bcc?: string[] };\n\ntype SendableMsgHeaders = {\n  headers?: Dict<string>;\n  from: string;\n  recipients: Recipients;\n  subject: string;\n  thread?: string;\n};\n\ntype SendableMsgOptions = {\n  type?: MimeEncodeType,\n  isDraft?: boolean;\n};\n\ntype SignMethod = (signable: string) => Promise<string>;\n\ntype SendableMsgDefinition = SendableMsgHeaders\n  & SendableMsgOptions\n  & {\n    body?: SendableMsgBody;\n    attachments?: Attachment[];\n  };\n\nexport class SendableMsg {\n\n  public sign?: (signable: string) => Promise<string>;\n\n  public static createSMime = async (acctEmail: string, headers: SendableMsgHeaders, data: Uint8Array, options: SendableMsgOptions): Promise<SendableMsg> => {\n    return await SendableMsg.createSendableMsg(acctEmail, headers, { \"encrypted/buf\": Buf.fromUint8(data) }, [], { type: 'smimeEncrypted', isDraft: options.isDraft });\n  }\n\n  public static createPlain = async (acctEmail: string, headers: SendableMsgHeaders, body: SendableMsgBody, attachments: Attachment[]): Promise<SendableMsg> => {\n    return await SendableMsg.createSendableMsg(acctEmail, headers, body, attachments, { type: undefined, isDraft: undefined });\n  }\n\n  public static createPgpInline = async (acctEmail: string, headers: SendableMsgHeaders, body: string, attachments: Attachment[], options?: SendableMsgOptions): Promise<SendableMsg> => {\n    return await SendableMsg.createSendableMsg(acctEmail, headers, { \"text/plain\": body }, attachments, options ? options : { type: undefined, isDraft: undefined });\n  }\n\n  public static createPwdMsg = async (\n    acctEmail: string,\n    headers: SendableMsgHeaders,\n    body: SendableMsgBody,\n    attachments: Attachment[],\n    options: SendableMsgOptions\n  ): Promise<SendableMsg> => {\n    return await SendableMsg.createSendableMsg(acctEmail, headers, body, attachments, { type: undefined, isDraft: options.isDraft });\n  }\n\n  public static createPgpMime = async (acctEmail: string, headers: SendableMsgHeaders, attachments: Attachment[], options?: SendableMsgOptions): Promise<SendableMsg> => {\n    return await SendableMsg.createSendableMsg(acctEmail, headers, {}, attachments, { type: (options ? 'pgpMimeEncrypted' : undefined), isDraft: (options ? options.isDraft : undefined) });\n  }\n\n  public static createPgpMimeSigned = async (\n    acctEmail: string,\n    headers: SendableMsgHeaders,\n    body: SendableMsgBody,\n    attachments: Attachment[],\n    signMethod: SignMethod\n  ): Promise<SendableMsg> => {\n    const sendableMsg = await SendableMsg.createSendableMsg(acctEmail, headers, body, attachments, { type: 'pgpMimeSigned', isDraft: undefined });\n    sendableMsg.sign = signMethod;\n    return sendableMsg;\n  }\n\n  private static createSendableMsg = async (\n    acctEmail: string,\n    headers: SendableMsgHeaders,\n    body: SendableMsgBody,\n    attachments: Attachment[],\n    options: SendableMsgOptions\n  ): Promise<SendableMsg> => {\n    const { from, recipients, subject, thread } = headers;\n    const { type, isDraft } = options;\n    return await SendableMsg.create(acctEmail, { from, recipients, subject, thread, body, attachments, type, isDraft });\n  }\n\n  private static create = async (acctEmail: string, { from, recipients, subject, thread, body, attachments, type, isDraft }: SendableMsgDefinition): Promise<SendableMsg> => {\n    const primaryKi = await KeyStore.getFirstRequired(acctEmail);\n    const headers: Dict<string> = primaryKi ? { OpenPGP: `id=${primaryKi.longid}` } : {}; // todo - use autocrypt format\n    return new SendableMsg(\n      acctEmail,\n      headers,\n      isDraft === true,\n      from,\n      recipients,\n      subject,\n      body || {},\n      attachments || [],\n      thread,\n      type\n    );\n  }\n\n  private constructor(\n    public acctEmail: string,\n    public headers: Dict<string>,\n    isDraft: boolean,\n    public from: string,\n    public recipients: Recipients,\n    public subject: string,\n    public body: SendableMsgBody,\n    public attachments: Attachment[],\n    public thread: string | undefined,\n    public type: MimeEncodeType,\n  ) {\n    const allEmails = [...recipients.to || [], ...recipients.cc || [], ...recipients.bcc || []];\n    if (!allEmails.length && !isDraft) {\n      throw new Error('The To: field is empty. Please add recipients and try again');\n    }\n    const invalidEmails = allEmails.filter(email => !Str.isEmailValid(email));\n    if (invalidEmails.length) {\n      throw new Error(`The To: field contains invalid emails: ${invalidEmails.join(', ')}\\n\\nPlease check recipients and try again.`);\n    }\n  }\n\n  public toMime = async () => {\n    this.headers.From = this.from;\n    for (const recipientTypeStr of Object.keys(this.recipients)) {\n      const recipientType = recipientTypeStr as RecipientType;\n      if (this.recipients[recipientType] && this.recipients[recipientType]!.length) {\n        // todo - properly escape/encode this header using emailjs\n        this.headers[recipientType[0].toUpperCase() + recipientType.slice(1)] = this.recipients[recipientType]!.map(h => h.replace(/[,]/g, '')).join(',');\n      }\n    }\n    this.headers.Subject = this.subject;\n    if (this.type === 'smimeEncrypted' && this.body['encrypted/buf']) {\n      return await Mime.encodeSmime(this.body['encrypted/buf'], this.headers);\n    } else if (this.type === 'pgpMimeSigned' && this.sign) {\n      return await Mime.encodePgpMimeSigned(this.body, this.headers, this.attachments, this.sign);\n    } else { // encrypted/buf is a Buf instance that is converted to single-part plain/text message\n      if (this.body['encrypted/buf']) {\n        this.body = { 'text/plain': this.body['encrypted/buf'].toString() };\n      }\n      return await Mime.encode(this.body, this.headers, this.attachments, this.type);\n    }\n  }\n\n}\n",
    "extension/js/common/api/flowcrypt-website.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n// tslint:disable:oneliner-object-literal\n// tslint:disable:no-null-keyword\n\n'use strict';\n\nimport { Api, ProgressCbs, ReqFmt } from './shared/api.js';\nimport { Dict } from '../core/common.js';\nimport { BACKEND_API_HOST } from '../core/const.js';\nimport { Catch } from '../platform/catch.js';\nimport { Browser } from '../browser/browser.js';\n\nnamespace FlowCryptWebsiteRes {\n  export type FcHelpFeedback = { sent: boolean };\n  export type FcBlogPost = { title: string, date: string, url: string };\n}\n\nexport class FlowCryptWebsite extends Api {\n\n  public static url = (type: 'api' | 'me' | 'pubkey' | 'decrypt' | 'web', resource = '') => {\n    return ({\n      api: BACKEND_API_HOST,\n      me: `https://flowcrypt.com/me/${resource}`,\n      pubkey: `https://flowcrypt.com/pub/${resource}`,\n      web: 'https://flowcrypt.com/',\n    } as Dict<string>)[type];\n  }\n\n  public static helpFeedback = async (acctEmail: string, message: string): Promise<FlowCryptWebsiteRes.FcHelpFeedback> => {\n    return await FlowCryptWebsite.request<FlowCryptWebsiteRes.FcHelpFeedback>('help/feedback', {\n      email: acctEmail,\n      message,\n    });\n  }\n\n  public static retrieveBlogPosts = async (): Promise<FlowCryptWebsiteRes.FcBlogPost[]> => {\n    const xml = await Api.ajax({ url: 'https://flowcrypt.com/blog/feed.xml', dataType: 'xml' }, Catch.stackTrace()) as XMLDocument; // tslint:disable-line:no-direct-ajax\n    const posts: FlowCryptWebsiteRes.FcBlogPost[] = [];\n    for (const post of Browser.arrFromDomNodeList(xml.querySelectorAll('entry'))) {\n      const children = Browser.arrFromDomNodeList(post.childNodes);\n      const title = children.find(n => n.nodeName.toLowerCase() === 'title')?.textContent;\n      const date = children.find(n => n.nodeName.toLowerCase() === 'published')?.textContent?.substr(0, 10);\n      const url = (children.find(n => n.nodeName.toLowerCase() === 'link') as HTMLAnchorElement).getAttribute('href');\n      if (title && date && url) {\n        posts.push({ title, date, url });\n      }\n    }\n    return posts.slice(0, 5);\n  }\n\n  private static request = async <RT>(path: string, vals: Dict<any>, fmt: ReqFmt = 'JSON', addHeaders: Dict<string> = {}, progressCbs?: ProgressCbs): Promise<RT> => {\n    return await FlowCryptWebsite.apiCall(FlowCryptWebsite.url('api'), path, vals, fmt, progressCbs, { 'api-version': '3', ...addHeaders });\n  }\n\n}\n",
    "extension/js/common/api/key-server/attester.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Api, ReqMethod } from './../shared/api.js';\nimport { Dict, Str } from '../../core/common.js';\nimport { PubkeySearchResult } from './../pub-lookup.js';\nimport { ApiErr } from '../shared/api-error.js';\nimport { OrgRules } from '../../org-rules.js';\nimport { ATTESTER_API_HOST } from '../../core/const.js';\n\ntype PubCallRes = { responseText: string, getResponseHeader: (n: string) => string | null };\n\nexport class Attester extends Api {\n\n  constructor(\n    private orgRules: OrgRules\n  ) {\n    super();\n  }\n\n  public lookupEmail = async (email: string): Promise<PubkeySearchResult> => {\n    if (!this.orgRules.canLookupThisRecipientOnAttester(email)) {\n      console.info(`Skipping attester lookup of ${email} because attester search on this domain is disabled.`);\n      return { pubkey: null }; // tslint:disable-line:no-null-keyword\n    }\n    try {\n      const r = await this.pubCall(`pub/${email}`);\n      // when requested from the content script, `getResponseHeader` will be missing because it's not a real XMLHttpRequest we are getting back\n      // because it had to go through background scripts, and objects are serialized when this happens\n      // the proper fix would be to send back headers from bg along with response text, and parse it here\n      if (!r.getResponseHeader) {\n        return { pubkey: r.responseText };\n      }\n      return { pubkey: r.responseText };\n    } catch (e) {\n      if (ApiErr.isNotFound(e)) {\n        return { pubkey: null }; // tslint:disable-line:no-null-keyword\n      }\n      throw e;\n    }\n  }\n\n  public lookupEmails = async (emails: string[]): Promise<Dict<PubkeySearchResult>> => {\n    const results: Dict<PubkeySearchResult> = {};\n    await Promise.all(emails.map(async (email: string) => {\n      results[email] = await this.lookupEmail(email);\n    }));\n    return results;\n  }\n\n  /**\n   * the actual api accepts either email, fingerprint or longid\n   */\n  public lookupFingerprint = async (fingerprintOrLongid: string) => {\n    return await this.lookupEmail(fingerprintOrLongid);\n  }\n\n  /**\n   * Set or replace public key with idToken as an auth mechanism\n   * Used during setup\n   * Can only be used for primary email because idToken does not contain info about aliases\n   */\n  public submitPrimaryEmailPubkey = async (email: string, pubkey: string, idToken: string): Promise<void> => {\n    if (!this.orgRules.canSubmitPubToAttester()) {\n      throw new Error('Cannot replace pubkey at attester because your organisation rules forbid it');\n    }\n    await this.pubCall(`pub/${email}`, 'POST', pubkey, { authorization: `Bearer ${idToken}` });\n  }\n\n  /**\n   * Request to replace pubkey that will be verified by clicking email\n   * Used when user manually chooses to replace key\n   * Can also be used for aliases\n   */\n  public replacePubkey = async (email: string, pubkey: string): Promise<string> => {\n    if (!this.orgRules.canSubmitPubToAttester()) {\n      throw new Error('Cannot replace pubkey at attester because your organisation rules forbid it');\n    }\n    const r = await this.pubCall(`pub/${email}`, 'POST', pubkey);\n    return r.responseText;\n  }\n\n  /**\n   * Update pubkey with a newer version of the same pubkey\n   * Does not need email verification, fingerprints compared, last signatures compared\n   */\n  public updatePubkey = async (longid: string, pubkey: string): Promise<string> => {\n    if (!this.orgRules.canSubmitPubToAttester()) {\n      throw new Error('Cannot update pubkey at attester because your organisation rules forbid it');\n    }\n    const r = await this.pubCall(`pub/${longid}`, 'PUT', pubkey);\n    return r.responseText;\n  }\n\n  /**\n   * Looking to deprecate this, but still used for some customers\n   */\n  public initialLegacySubmit = async (email: string, pubkey: string): Promise<{ saved: boolean }> => {\n    if (!this.orgRules.canSubmitPubToAttester()) {\n      throw new Error('Cannot submit pubkey to attester because your organisation rules forbid it');\n    }\n    return await this.jsonCall<{ saved: boolean }>('initial/legacy_submit', { email: Str.parseEmail(email).email, pubkey: pubkey.trim() });\n  }\n\n  public testWelcome = async (email: string, pubkey: string): Promise<{ sent: boolean }> => {\n    return await this.jsonCall<{ sent: boolean }>('test/welcome', { email, pubkey });\n  }\n\n  private jsonCall = async <RT>(path: string, values?: Dict<any>, method: ReqMethod = 'POST'): Promise<RT> => {\n    return await Api.apiCall(ATTESTER_API_HOST, path, values, 'JSON', undefined, { 'api-version': '3' }, 'json', method) as RT;\n  }\n\n  private pubCall = async (resource: string, method: ReqMethod = 'GET', data?: string | undefined, hdrs?: Dict<string>): Promise<PubCallRes> => {\n    return await Api.apiCall(ATTESTER_API_HOST, resource, data, typeof data === 'string' ? 'TEXT' : undefined, undefined, hdrs, 'xhr', method);\n  }\n\n}\n",
    "extension/js/common/api/key-server/key-manager.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n// tslint:disable:oneliner-object-literal\n// tslint:disable:no-null-keyword\n\n'use strict';\n\nimport { Api, ReqMethod } from './../shared/api.js';\nimport { Dict } from '../../core/common.js';\n\ntype LoadPrvRes = { privateKeys: { decryptedPrivateKey: string }[] };\ntype LoadPubRes = { publicKeys: { publicKey: string }[] };\n\nexport class KeyManager extends Api {\n\n  private url: string;\n\n  constructor(\n    url: string\n  ) {\n    super();\n    this.url = url.replace(/\\/$/, ''); // remove trailing space\n  }\n\n  public getPrivateKeys = async (idToken: string): Promise<LoadPrvRes> => {\n    return await this.request('GET', '/keys/private', undefined, idToken) as LoadPrvRes;\n  }\n\n  public storePrivateKey = async (idToken: string, decryptedPrivateKey: string, publicKey: string): Promise<void> => {\n    return await this.request('PUT', '/keys/private', { decryptedPrivateKey, publicKey }, idToken);\n  }\n\n  public lookupPublicKey = async (emailOrFingerprint: string): Promise<LoadPubRes> => {\n    return await this.request('GET', `/keys/public/${emailOrFingerprint}`);\n  }\n\n  private request = async <RT>(method: ReqMethod, path: string, vals?: Dict<any> | undefined, idToken?: string): Promise<RT> => {\n    return await Api.apiCall(this.url, path, vals, vals ? 'JSON' : undefined, undefined, idToken ? { Authorization: `Bearer ${idToken}` } : undefined, undefined, method);\n  }\n\n}\n",
    "extension/js/common/api/key-server/sks.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Api } from './../shared/api.js';\nimport { ApiErr } from '../shared/api-error.js';\nimport { PgpArmor } from '../../core/crypto/pgp/pgp-armor.js';\nimport { PubkeySearchResult } from './../pub-lookup.js';\n\nexport class Sks extends Api {\n\n  private static MR_VERSION_1 = 'info:1:';\n  private url: string;\n\n  constructor(\n    url: string\n  ) {\n    super();\n    this.url = url.replace(/\\/$/, ''); // remove trailing space\n  }\n\n  /**\n   * https://tools.ietf.org/html/draft-shaw-openpgp-hkp-00#section-5.1\n   *\n   * Todo - extract full fingerprint, not just longid\n   */\n  public lookupEmail = async (email: string): Promise<PubkeySearchResult> => {\n    const index = await this.get(`/pks/lookup?search=${encodeURIComponent(email)}&fingerprint=on&exact=on&options=mr&op=index`);\n    if (!index || !index.startsWith(Sks.MR_VERSION_1)) {\n      return { pubkey: null }; // tslint:disable-line:no-null-keyword\n    }\n    const foundUidsByLongid: { [longid: string]: string[] } = {};\n    let currentLongid = '';\n    for (const line of index.split('\\n').map(l => l.trim()).filter(l => !l.startsWith(Sks.MR_VERSION_1))) {\n      if (line.startsWith('pub:')) {\n        const match = line.match(/^pub:[A-F0-9]{24}([A-F0-9]{16}):[0-9:]+:$/); // in particular cannot end with :r, meaning revoked\n        if (!match) {\n          currentLongid = '';\n        } else {\n          currentLongid = match[1];\n          foundUidsByLongid[currentLongid] = [];\n        }\n      } else if (line.startsWith('uid:') && currentLongid) {\n        foundUidsByLongid[currentLongid].push(line.replace('uid:', '').split(':')[0].toLowerCase());\n      }\n    }\n    if (!Object.keys(foundUidsByLongid).length) {\n      return { pubkey: null }; // tslint:disable-line:no-null-keyword\n    }\n    for (const longid of Object.keys(foundUidsByLongid)) {\n      for (const uid of foundUidsByLongid[longid]) {\n        if (uid.includes(email)) {\n          // todo - use fingerprint here\n          return await this.lookupFingerprint(longid); // try to find first pubkey where uid matches what we search for\n        }\n      }\n    }\n    return await this.lookupFingerprint(Object.keys(foundUidsByLongid)[0]); // else return the first pubkey\n  }\n\n  public lookupFingerprint = async (fingerprintOrLongid: string): Promise<PubkeySearchResult> => {\n    const pubkey = await this.get(`/pks/lookup?op=get&search=0x${fingerprintOrLongid}&options=mr`);\n    if (!pubkey || !pubkey.includes(String(PgpArmor.headers('publicKey').end))) {\n      return { pubkey: null }; // tslint:disable-line:no-null-keyword\n    }\n    return { pubkey };\n  }\n\n  private get = async (path: string): Promise<string | undefined> => {\n    try {\n      const { responseText } = await Api.apiCall(this.url, path, undefined, undefined, undefined, undefined, 'xhr', 'GET') as XMLHttpRequest;\n      return responseText;\n    } catch (e) {\n      if (ApiErr.isNotFound(e)) {\n        return undefined;\n      }\n      throw e;\n    }\n  }\n\n}\n",
    "extension/js/common/api/key-server/wkd.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Api } from './../shared/api.js';\nimport { ApiErr } from '../shared/api-error.js';\nimport { opgp } from '../../core/crypto/pgp/openpgpjs-custom.js';\nimport { Buf } from '../../core/buf.js';\nimport { PubkeysSearchResult } from './../pub-lookup.js';\nimport { Key, KeyUtil } from '../../core/crypto/key.js';\n\n// tslint:disable:no-direct-ajax\n\nexport class Wkd extends Api {\n\n  // https://datatracker.ietf.org/doc/draft-koch-openpgp-webkey-service/?include_text=1\n  // https://www.sektioneins.de/en/blog/18-11-23-gnupg-wkd.html\n  // https://metacode.biz/openpgp/web-key-directory\n\n  public port: number | undefined;\n\n  // returns all the received keys\n  public rawLookupEmail = async (email: string): Promise<{ keys: Key[], errs: Error[] }> => {\n    // todo: should we return errs on network failures etc.?\n    const parts = email.split('@');\n    if (parts.length !== 2) {\n      return { keys: [], errs: [] };\n    }\n    const [user, recipientDomain] = parts;\n    if (!user || !recipientDomain) {\n      return { keys: [], errs: [] };\n    }\n    if (!opgp) {\n      // pgp_block.htm does not have openpgp loaded\n      // the particular usecase (auto-loading pubkeys to verify signatures) is not that important,\n      //    the user typically gets the key loaded from composing anyway\n      // the proper fix would be to run encodeZBase32 through background scripts\n      return { keys: [], errs: [] };\n    }\n    const directDomain = recipientDomain.toLowerCase();\n    const advancedDomainPrefix = (directDomain === 'localhost') ? '' : 'openpgpkey.';\n    const hu = opgp.util.encodeZBase32(await opgp.crypto.hash.digest(opgp.enums.hash.sha1, Buf.fromUtfStr(user.toLowerCase())));\n    const directHost = (typeof this.port === 'undefined') ? directDomain : `${directDomain}:${this.port}`;\n    const advancedHost = `${advancedDomainPrefix}${directHost}`;\n    const userPart = `hu/${hu}?l=${encodeURIComponent(user)}`;\n    const advancedUrl = `https://${advancedHost}/.well-known/openpgpkey/${directDomain}`;\n    const directUrl = `https://${directHost}/.well-known/openpgpkey`;\n    let response = await this.urlLookup(advancedUrl, userPart);\n    if (!response.buf && response.hasPolicy) {\n      return { keys: [], errs: [] }; // do not retry direct if advanced had a policy file\n    }\n    if (!response.buf) {\n      response = await this.urlLookup(directUrl, userPart);\n    }\n    if (!response.buf) {\n      return { keys: [], errs: [] }; // do not retry direct if advanced had a policy file\n    }\n    return await KeyUtil.readMany(response.buf);\n  }\n\n  public lookupEmail = async (email: string): Promise<PubkeysSearchResult> => {\n    const { keys, errs } = await this.rawLookupEmail(email);\n    if (errs.length) {\n      return { pubkeys: [] };\n    }\n    const pubkeys = keys.filter(key => key.emails.some(x => x.toLowerCase() === email.toLowerCase()));\n    if (!pubkeys.length) {\n      return { pubkeys: [] };\n    }\n    try {\n      return { pubkeys: pubkeys.map(pubkey => KeyUtil.armor(pubkey)) };\n    } catch (e) {\n      return { pubkeys: [] };\n    }\n  }\n\n  private urlLookup = async (methodUrlBase: string, userPart: string): Promise<{ hasPolicy: boolean, buf?: Buf }> => {\n    try {\n      await Wkd.download(`${methodUrlBase}/policy`, undefined, 4);\n    } catch (e) {\n      return { hasPolicy: false };\n    }\n    try {\n      const buf = await Wkd.download(`${methodUrlBase}/${userPart}`, undefined, 4);\n      if (buf.length) {\n        console.info(`Loaded WKD url ${methodUrlBase}/${userPart} and will try to extract Public Keys`);\n      }\n      return { hasPolicy: true, buf };\n    } catch (e) {\n      if (!ApiErr.isNotFound(e)) {\n        console.info(`Wkd.lookupEmail error retrieving key: ${String(e)}`);\n      }\n      return { hasPolicy: true };\n    }\n  }\n\n}\n",
    "extension/js/common/api/pub-lookup.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Attester } from './key-server/attester.js';\nimport { KeyManager } from './key-server/key-manager.js';\nimport { Sks } from './key-server/sks.js';\nimport { Wkd } from './key-server/wkd.js';\nimport { OrgRules } from '../org-rules.js';\n\nexport type PubkeySearchResult = { pubkey: string | null };\nexport type PubkeysSearchResult = { pubkeys: string[] };\n\n/**\n * Look up public keys.\n *\n * Some orgs may have a preference to use their own keyserver.\n * In such cases, results from their own keyserver will be preferred.\n */\nexport class PubLookup {\n\n  public attester: Attester; // attester is a publicly available public key server\n  public wkd: Wkd;\n  public keyManager: KeyManager | undefined; // key manager is a flowcrypt-provided internal company private and public key server\n  public internalSks: Sks | undefined; // this is an internal company pubkey server that has SKS-like interface\n\n  constructor(\n    private orgRules: OrgRules\n  ) {\n    const privateKeyManagerUrl = orgRules.getKeyManagerUrlForPublicKeys();\n    const internalSksUrl = this.orgRules.getCustomSksPubkeyServer();\n    this.attester = new Attester(orgRules);\n    this.wkd = new Wkd();\n    if (privateKeyManagerUrl) {\n      this.keyManager = new KeyManager(privateKeyManagerUrl);\n    }\n    if (internalSksUrl) {\n      this.internalSks = new Sks(internalSksUrl);\n    }\n  }\n\n  public lookupEmail = async (email: string): Promise<PubkeysSearchResult> => {\n    if (this.keyManager) {\n      const res = await this.keyManager.lookupPublicKey(email);\n      if (res.publicKeys.length) {\n        return { pubkeys: res.publicKeys.map(x => x.publicKey) };\n      }\n    }\n    const wkdRes = await this.wkd.lookupEmail(email);\n    if (wkdRes.pubkeys.length) {\n      return wkdRes;\n    }\n    if (this.internalSks) {\n      const res = await this.internalSks.lookupEmail(email);\n      if (res.pubkey) {\n        return { pubkeys: [res.pubkey] };\n      }\n    }\n    const attRes = await this.attester.lookupEmail(email);\n    if (attRes.pubkey) {\n      return { pubkeys: [attRes.pubkey] };\n    }\n    return { pubkeys: [] };\n  }\n\n  public lookupFingerprint = async (fingerprintOrLongid: string): Promise<PubkeySearchResult> => {\n    if (this.keyManager) {\n      const res = await this.keyManager.lookupPublicKey(fingerprintOrLongid);\n      if (res.publicKeys.length) {\n        return { pubkey: res.publicKeys[0].publicKey };\n      }\n    }\n    if (this.internalSks) {\n      const res = await this.internalSks.lookupFingerprint(fingerprintOrLongid);\n      if (res.pubkey) {\n        return res;\n      }\n    }\n    return await this.attester.lookupFingerprint(fingerprintOrLongid);\n  }\n\n}\n",
    "extension/js/common/api/shared/api.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\n// tslint:disable:no-direct-ajax\n\nimport { Attachment } from '../../core/attachment.js';\nimport { BrowserMsg } from '../../browser/browser-msg.js';\nimport { Buf } from '../../core/buf.js';\nimport { Catch } from '../../platform/catch.js';\nimport { Dict } from '../../core/common.js';\nimport { Env } from '../../browser/env.js';\nimport { secureRandomBytes } from '../../platform/util.js';\nimport { ApiErr, AjaxErr } from './api-error.js';\n\nexport type ReqFmt = 'JSON' | 'FORM' | 'TEXT';\nexport type RecipientType = 'to' | 'cc' | 'bcc';\ntype ResFmt = 'json' | 'xhr';\nexport type ReqMethod = 'POST' | 'GET' | 'DELETE' | 'PUT';\nexport type EmailProviderContact = {\n  email: string;\n  name?: string | null;\n}\ntype ProviderContactsResults = { new: EmailProviderContact[], all: EmailProviderContact[] };\ntype RawAjaxErr = {\n  // getAllResponseHeaders?: () => any,\n  // getResponseHeader?: (e: string) => any,\n  readyState: number,\n  responseText?: string,\n  status?: number,\n  statusText?: string,\n};\n\nexport type ChunkedCb = (r: ProviderContactsResults) => Promise<void>;\nexport type ProgressCb = (percent: number | undefined, loaded: number, total: number) => void;\nexport type ProgressCbs = { upload?: ProgressCb | null, download?: ProgressCb | null };\n\nexport class Api {\n\n  public static download = async (url: string, progress?: ProgressCb, timeout?: number): Promise<Buf> => {\n    return await new Promise((resolve, reject) => {\n      Api.throwIfApiPathTraversalAttempted(url);\n      const request = new XMLHttpRequest();\n      if (timeout) {\n        request.timeout = timeout * 1000;\n      }\n      request.open('GET', url, true);\n      request.responseType = 'arraybuffer';\n      if (typeof progress === 'function') {\n        request.onprogress = (evt) => progress(evt.lengthComputable ? Math.floor((evt.loaded / evt.total) * 100) : undefined, evt.loaded, evt.total);\n      }\n      const errHandler = (progressEvent: ProgressEvent<EventTarget>) => {\n        if (!progressEvent.target) {\n          reject(new Error(`Api.download(${url}) failed with a null progressEvent.target`));\n        } else {\n          const { readyState, status, statusText } = progressEvent.target as XMLHttpRequest;\n          reject(AjaxErr.fromXhr({ readyState, status, statusText }, { url, method: 'GET' }, Catch.stackTrace()));\n        }\n      };\n      request.onerror = errHandler;\n      request.ontimeout = errHandler;\n      request.onload = e => request.status <= 299 ? resolve(new Buf(request.response as ArrayBuffer)) : errHandler(e);\n      request.send();\n    });\n  }\n\n  public static ajax = async (req: JQueryAjaxSettings, stack: string): Promise<any | JQuery.jqXHR<any>> => {\n    if (Env.isContentScript()) {\n      // content script CORS not allowed anymore, have to drag it through background page\n      // https://www.chromestatus.com/feature/5629709824032768\n      return await BrowserMsg.send.bg.await.ajax({ req, stack });\n    }\n    try {\n      return await new Promise((resolve, reject) => {\n        Api.throwIfApiPathTraversalAttempted(req.url || '');\n        $.ajax({ ...req, dataType: req.dataType === 'xhr' ? undefined : req.dataType }).then((data, s, xhr) => {\n          if (req.dataType === 'xhr') {\n            // @ts-ignore -> prevent the xhr object from getting further \"resolved\" and processed by jQuery, below\n            xhr.then = xhr.promise = undefined;\n            resolve(xhr);\n          } else {\n            resolve(data as any);\n          }\n        }).catch(reject);\n      });\n    } catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      if (Api.isRawAjaxErr(e)) {\n        throw AjaxErr.fromXhr(e, req, stack);\n      }\n      throw new Error(`Unknown Ajax error (${String(e)}) type when calling ${req.url}`);\n    }\n  }\n\n  public static isInternetAccessible = async () => {\n    try {\n      await Api.download('https://google.com');\n      return true;\n    } catch (e) {\n      if (ApiErr.isNetErr(e)) {\n        return false;\n      }\n      throw e;\n    }\n  }\n\n  public static getAjaxProgressXhrFactory = (progressCbs?: ProgressCbs): (() => XMLHttpRequest) | undefined => {\n    if (Env.isContentScript() || Env.isBackgroundPage() || !progressCbs || !Object.keys(progressCbs).length) {\n      // xhr object would cause 'The object could not be cloned.' lastError during BrowserMsg passing\n      // thus no progress callbacks in bg or content scripts\n      // additionally no need to create this if there are no progressCbs defined\n      return undefined;\n    }\n    return () => { // returning a factory\n      let lastProgressPercent = -1;\n      const progressPeportingXhr = new XMLHttpRequest();\n      if (progressCbs && typeof progressCbs.upload === 'function') {\n        progressPeportingXhr.upload.addEventListener('progress', (evt: ProgressEvent) => {\n          const newProgressPercent = evt.lengthComputable ? Math.round((evt.loaded / evt.total) * 100) : undefined;\n          if (newProgressPercent && newProgressPercent !== lastProgressPercent) {\n            lastProgressPercent = newProgressPercent;\n            progressCbs.upload!(newProgressPercent, evt.loaded, evt.total); // checked ===function above\n          }\n        }, false);\n      }\n      if (progressCbs && typeof progressCbs.download === 'function') {\n        progressPeportingXhr.addEventListener('progress', (evt: ProgressEvent) => {\n          // 100 because if the request takes less time than 1-2 seconds browsers trigger this function only once and when it's completed\n          const newProgressPercent = evt.lengthComputable ? Math.floor((evt.loaded / evt.total) * 100) : undefined;\n          if (typeof newProgressPercent === 'undefined' || newProgressPercent !== lastProgressPercent) {\n            if (newProgressPercent) {\n              lastProgressPercent = newProgressPercent;\n            }\n            progressCbs.download!(newProgressPercent, evt.loaded, evt.total); // checked ===function above\n          }\n        });\n      }\n      return progressPeportingXhr;\n    };\n  }\n\n  public static randomFortyHexChars = (): string => {\n    const bytes = Array.from(secureRandomBytes(20));\n    return bytes.map(b => ('0' + (b & 0xFF).toString(16)).slice(-2)).join('');\n  }\n\n  protected static apiCall = async <RT>(\n    url: string,\n    path: string,\n    fields?: Dict<any> | string,\n    fmt?: ReqFmt,\n    progress?: ProgressCbs,\n    headers?: Dict<string>,\n    resFmt: ResFmt = 'json',\n    method: ReqMethod = 'POST'\n  ): Promise<RT> => {\n    progress = progress || {} as ProgressCbs;\n    let formattedData: FormData | string | undefined;\n    let contentType: string | false;\n    if (fmt === 'JSON' && fields) {\n      formattedData = JSON.stringify(fields);\n      contentType = 'application/json; charset=UTF-8';\n    } else if (fmt === 'TEXT' && typeof fields === 'string') {\n      formattedData = fields;\n      contentType = false;\n    } else if (fmt === 'FORM' && fields && typeof fields !== 'string') {\n      formattedData = new FormData();\n      for (const formFieldName of Object.keys(fields)) {\n        const a: Attachment | string = fields[formFieldName]; // tslint:disable-line:no-unsafe-any\n        if (a instanceof Attachment) {\n          formattedData.append(formFieldName, new Blob([a.getData()], { type: a.type }), a.name); // xss-none\n        } else {\n          formattedData.append(formFieldName, a); // xss-none\n        }\n      }\n      contentType = false;\n    } else if (!fmt && !fields && method === 'GET') {\n      formattedData = undefined;\n      contentType = false;\n    } else {\n      throw new Error('unknown format:' + String(fmt));\n    }\n    const req: JQueryAjaxSettings = {\n      xhr: Api.getAjaxProgressXhrFactory(progress),\n      url: url + path,\n      method,\n      data: formattedData,\n      dataType: resFmt,\n      crossDomain: true,\n      headers,\n      processData: false,\n      contentType,\n      async: true,\n      timeout: typeof progress!.upload === 'function' || typeof progress!.download === 'function' ? undefined : 20000, // substituted with {} above\n    };\n    const res = await Api.ajax(req, Catch.stackTrace());\n    return res as RT;\n  }\n\n  private static isRawAjaxErr = (e: any): e is RawAjaxErr => {\n    return e && typeof e === 'object' && typeof (e as RawAjaxErr).readyState === 'number'; // tslint:disable-line:no-unsafe-any\n  }\n\n  /**\n   * Security check, in case attacker modifies parameters which are then used in an url\n   * https://github.com/FlowCrypt/flowcrypt-browser/issues/2646\n   */\n  private static throwIfApiPathTraversalAttempted = (requestUrl: string) => {\n    if (requestUrl.includes('../') || requestUrl.includes('/..')) {\n      throw new Error(`API path traversal forbidden: ${requestUrl}`);\n    }\n  }\n\n}\n",
    "extension/js/common/browser/browser-msg.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { DecryptResult, DiagnoseMsgPubkeysResult, PgpMsgMethod, VerifyRes, PgpMsgTypeResult } from '../core/crypto/pgp/msg-util.js';\nimport { Dict, Str, UrlParams } from '../core/common.js';\nimport { AjaxErr } from '../api/shared/api-error.js';\nimport { AuthRes } from '../api/email-provider/gmail/google-auth.js';\nimport { Browser } from './browser.js';\nimport { BrowserMsgCommonHandlers } from './browser-msg-common-handlers.js';\nimport { Buf } from '../core/buf.js';\nimport { Catch } from '../platform/catch.js';\nimport { Env } from './env.js';\nimport { PassphraseDialogType } from '../xss-safe-factory.js';\nimport { PgpHash } from '../core/crypto/pgp/pgp-hash.js';\nimport { MsgUtil } from '../core/crypto/pgp/msg-util.js';\nimport { Ui } from './ui.js';\nimport { GlobalStoreDict, GlobalIndex } from '../platform/store/global-store.js';\nimport { AcctStoreDict, AccountIndex } from '../platform/store/acct-store.js';\nimport { Contact, Key, KeyUtil } from '../core/crypto/key.js';\nimport { OpenPGPKey } from '../core/crypto/pgp/openpgp-key.js';\n\nexport type GoogleAuthWindowResult$result = 'Success' | 'Denied' | 'Error' | 'Closed';\n\nexport namespace Bm {\n  export type Dest = string;\n  export type Sender = chrome.runtime.MessageSender | 'background';\n  export type Response = any;\n  export type RawResponse = { result: any, objUrls: { [name: string]: string }, exception?: Bm.ErrAsJson };\n  export type Raw = { name: string; data: { bm: AnyRequest | {}, objUrls: Dict<string> }; to: Dest | null; uid: string; stack: string };\n\n  export type SetCss = { css: Dict<string>, traverseUp?: number, selector: string; };\n  export type AddOrRemoveClass = { class: string, selector: string; };\n  export type Settings = { path?: string, page?: string, acctEmail?: string, pageUrlParams?: UrlParams, addNewAcct?: boolean };\n  export type PassphraseDialog = { type: PassphraseDialogType, longids: string[] };\n  export type ScrollToReplyBox = { replyMsgId: string };\n  export type ScrollToCursorInReplyBox = { replyMsgId: string, cursorOffsetTop: number };\n  export type NotificationShow = { notification: string, callbacks?: Dict<() => void> };\n  export type NotificationShowAuthPopupNeeded = { acctEmail: string };\n  export type RenderPublicKeys = { afterFrameId: string, publicKeys: string[], traverseUp?: number };\n  export type SubscribeDialog = { isAuthErr?: boolean };\n  export type FocusFrame = { frameId: string };\n  export type CloseReplyMessage = { frameId: string };\n  export type ReinsertReplyBox = { replyMsgId: string };\n  export type AddPubkeyDialog = { emails: string[] };\n  export type Reload = { advanced?: boolean };\n  export type Redirect = { location: string };\n  export type OpenGoogleAuthDialog = { acctEmail?: string, scopes?: string[] };\n  export type OpenPage = { page: string, addUrlText?: string | UrlParams };\n  export type StripeResult = { token: string };\n  export type PassphraseEntry = { entered: boolean; };\n  export type Db = { f: string, args: any[] };\n  export type StoreSessionSet = { acctEmail: string, key: string, value: string | undefined };\n  export type StoreSessionGet = { acctEmail: string, key: string };\n  export type StoreGlobalGet = { keys: GlobalIndex[]; };\n  export type StoreGlobalSet = { values: GlobalStoreDict; };\n  export type StoreAcctGet = { acctEmail: string, keys: AccountIndex[]; };\n  export type StoreAcctSet = { acctEmail: string, values: AcctStoreDict; };\n  export type ReconnectAcctAuthPopup = { acctEmail: string, scopes?: string[] };\n  export type PgpMsgDecrypt = PgpMsgMethod.Arg.Decrypt;\n  export type PgpMsgDiagnoseMsgPubkeys = PgpMsgMethod.Arg.DiagnosePubkeys;\n  export type PgpMsgVerifyDetached = PgpMsgMethod.Arg.VerifyDetached;\n  export type PgpHashChallengeAnswer = { answer: string };\n  export type PgpMsgType = PgpMsgMethod.Arg.Type;\n  export type KeyParse = { armored: string };\n  export type KeyMatch = { pubkeys: string[], longid: string };\n  export type Ajax = { req: JQueryAjaxSettings, stack: string };\n  export type AjaxGmailAttachmentGetChunk = { acctEmail: string, msgId: string, attachmentId: string };\n  export type ShowAttachmentPreview = { iframeUrl: string };\n  export type ReRenderRecipient = { contact: Contact };\n\n  export namespace Res {\n    export type GetActiveTabInfo = { provider: 'gmail' | undefined, acctEmail: string | undefined, sameWorld: boolean | undefined };\n    export type StoreSessionGet = string | null;\n    export type StoreSessionSet = void;\n    export type StoreGlobalGet = GlobalStoreDict;\n    export type StoreGlobalSet = void;\n    export type StoreAcctGet = AcctStoreDict;\n    export type StoreAcctSet = void;\n    export type ReconnectAcctAuthPopup = AuthRes;\n    export type PgpMsgDecrypt = DecryptResult;\n    export type PgpMsgDiagnoseMsgPubkeys = DiagnoseMsgPubkeysResult;\n    export type PgpMsgVerify = VerifyRes;\n    export type PgpMsgType = PgpMsgTypeResult;\n    export type PgpHashChallengeAnswer = { hashed: string };\n    export type KeyParse = { key: Key };\n    export type KeyMatch = { key: Key | undefined };\n    export type AjaxGmailAttachmentGetChunk = { chunk: Buf };\n    export type _tab_ = { tabId: string | null | undefined };\n    export type Db = any; // not included in Any below\n    export type Ajax = any; // not included in Any below\n\n    export type Any = GetActiveTabInfo | _tab_ | ReconnectAcctAuthPopup\n      | PgpMsgDecrypt | PgpMsgDiagnoseMsgPubkeys | PgpMsgVerify | PgpHashChallengeAnswer | PgpMsgType | KeyParse\n      | StoreSessionGet | StoreSessionSet | StoreAcctGet | StoreAcctSet | StoreGlobalGet | StoreGlobalSet\n      | AjaxGmailAttachmentGetChunk | KeyMatch;\n  }\n\n  export type AnyRequest = PassphraseEntry | StripeResult | OpenPage | OpenGoogleAuthDialog | Redirect | Reload |\n    AddPubkeyDialog | ReinsertReplyBox | CloseReplyMessage | ScrollToReplyBox | ScrollToCursorInReplyBox | SubscribeDialog |\n    RenderPublicKeys | NotificationShowAuthPopupNeeded |\n    NotificationShow | PassphraseDialog | PassphraseDialog | Settings | SetCss | AddOrRemoveClass | ReconnectAcctAuthPopup |\n    Db | StoreSessionSet | StoreSessionGet | StoreGlobalGet | StoreGlobalSet | StoreAcctGet | StoreAcctSet | KeyParse |\n    PgpMsgDecrypt | PgpMsgDiagnoseMsgPubkeys | PgpMsgVerifyDetached | PgpHashChallengeAnswer | PgpMsgType | Ajax | FocusFrame |\n    ShowAttachmentPreview | ReRenderRecipient | KeyMatch;\n\n  // export type RawResponselessHandler = (req: AnyRequest) => Promise<void>;\n  // export type RawRespoHandler = (req: AnyRequest) => Promise<void>;\n  export type RawBrowserMsgHandler = (req: AnyRequest, sender: Sender, respond: (r: RawResponse) => void) => void;\n  export type AsyncRespondingHandler = (req: AnyRequest, sender: Sender) => Promise<Res.Any>;\n  export type AsyncResponselessHandler = (req: AnyRequest, sender: Sender) => Promise<void>;\n\n  type StandardErrAsJson = { stack?: string; message: string, errorConstructor: 'Error' };\n  type AjaxErrDetails = { status: number, url: string, responseText: string, statusText: string, resMsg?: string, resDetails?: string };\n  type AjaxErrAsJson = { stack?: string; message: string, errorConstructor: 'AjaxErr', ajaxErrorDetails: AjaxErrDetails };\n  export type ErrAsJson = StandardErrAsJson | AjaxErrAsJson;\n}\n\ntype Handler = Bm.AsyncRespondingHandler | Bm.AsyncResponselessHandler;\ntype Handlers = Dict<Handler>;\n\nexport class BgNotReadyErr extends Error { }\n// ts-prune-ignore-next\nexport class TabIdRequiredError extends Error { }\n\nexport class BrowserMsg {\n\n  public static MAX_SIZE = 1024 * 1024; // 1MB\n\n  public static send = { // todo - may want to organise this differently, seems to always confuse me when sending a message\n    bg: {\n      settings: (bm: Bm.Settings) => BrowserMsg.sendCatch(undefined, 'settings', bm),\n      updateUninstallUrl: () => BrowserMsg.sendCatch(undefined, 'update_uninstall_url', {}),\n      await: {\n        reconnectAcctAuthPopup: (bm: Bm.ReconnectAcctAuthPopup) => BrowserMsg.sendAwait(undefined, 'reconnect_acct_auth_popup', bm, true) as Promise<Bm.Res.ReconnectAcctAuthPopup>,\n        getActiveTabInfo: () => BrowserMsg.sendAwait(undefined, 'get_active_tab_info', undefined, true) as Promise<Bm.Res.GetActiveTabInfo>,\n        storeSessionGet: (bm: Bm.StoreSessionGet) => BrowserMsg.sendAwait(undefined, 'session_get', bm, true) as Promise<Bm.Res.StoreSessionGet>,\n        storeSessionSet: (bm: Bm.StoreSessionSet) => BrowserMsg.sendAwait(undefined, 'session_set', bm, true) as Promise<Bm.Res.StoreSessionSet>,\n        storeGlobalGet: (bm: Bm.StoreGlobalGet) => BrowserMsg.sendAwait(undefined, 'storeGlobalGet', bm, true) as Promise<Bm.Res.StoreGlobalGet>,\n        storeGlobalSet: (bm: Bm.StoreGlobalSet) => BrowserMsg.sendAwait(undefined, 'storeGlobalSet', bm, true) as Promise<Bm.Res.StoreGlobalSet>,\n        storeAcctGet: (bm: Bm.StoreAcctGet) => BrowserMsg.sendAwait(undefined, 'storeAcctGet', bm, true) as Promise<Bm.Res.StoreAcctGet>,\n        storeAcctSet: (bm: Bm.StoreAcctSet) => BrowserMsg.sendAwait(undefined, 'storeAcctSet', bm, true) as Promise<Bm.Res.StoreAcctSet>,\n        db: (bm: Bm.Db): Promise<Bm.Res.Db> => BrowserMsg.sendAwait(undefined, 'db', bm, true) as Promise<Bm.Res.Db>,\n        ajax: (bm: Bm.Ajax): Promise<Bm.Res.Ajax> => BrowserMsg.sendAwait(undefined, 'ajax', bm, true) as Promise<Bm.Res.Ajax>,\n        ajaxGmailAttachmentGetChunk: (bm: Bm.AjaxGmailAttachmentGetChunk) => BrowserMsg.sendAwait(undefined, 'ajaxGmailAttachmentGetChunk',\n          bm, true) as Promise<Bm.Res.AjaxGmailAttachmentGetChunk>,\n        pgpMsgDiagnosePubkeys: (bm: Bm.PgpMsgDiagnoseMsgPubkeys) => BrowserMsg.sendAwait(undefined, 'pgpMsgDiagnosePubkeys', bm, true) as Promise<Bm.Res.PgpMsgDiagnoseMsgPubkeys>,\n        pgpHashChallengeAnswer: (bm: Bm.PgpHashChallengeAnswer) => BrowserMsg.sendAwait(undefined, 'pgpHashChallengeAnswer', bm, true) as Promise<Bm.Res.PgpHashChallengeAnswer>,\n        pgpMsgDecrypt: (bm: Bm.PgpMsgDecrypt) => BrowserMsg.sendAwait(undefined, 'pgpMsgDecrypt', bm, true) as Promise<Bm.Res.PgpMsgDecrypt>,\n        pgpMsgVerifyDetached: (bm: Bm.PgpMsgVerifyDetached) => BrowserMsg.sendAwait(undefined, 'pgpMsgVerifyDetached', bm, true) as Promise<Bm.Res.PgpMsgVerify>,\n        keyParse: (bm: Bm.KeyParse) => BrowserMsg.sendAwait(undefined, 'keyParse', bm, true) as Promise<Bm.Res.KeyParse>,\n        keyMatch: (bm: Bm.KeyMatch) => BrowserMsg.sendAwait(undefined, 'keyMatch', bm, true) as Promise<Bm.Res.KeyMatch>,\n        pgpMsgType: (bm: Bm.PgpMsgType) => BrowserMsg.sendAwait(undefined, 'pgpMsgType', bm, true) as Promise<Bm.Res.PgpMsgType>,\n      },\n    },\n    passphraseEntry: (dest: Bm.Dest, bm: Bm.PassphraseEntry) => BrowserMsg.sendCatch(dest, 'passphrase_entry', bm),\n    addEndSessionBtn: (dest: Bm.Dest) => BrowserMsg.sendCatch(dest, 'add_end_session_btn', {}),\n    stripeResult: (dest: Bm.Dest, bm: Bm.StripeResult) => BrowserMsg.sendCatch(dest, 'stripe_result', bm),\n    openPage: (dest: Bm.Dest, bm: Bm.OpenPage) => BrowserMsg.sendCatch(dest, 'open_page', bm),\n    setCss: (dest: Bm.Dest, bm: Bm.SetCss) => BrowserMsg.sendCatch(dest, 'set_css', bm),\n    addClass: (dest: Bm.Dest, bm: Bm.AddOrRemoveClass) => BrowserMsg.sendCatch(dest, 'add_class', bm),\n    removeClass: (dest: Bm.Dest, bm: Bm.AddOrRemoveClass) => BrowserMsg.sendCatch(dest, 'remove_class', bm),\n    closeDialog: (dest: Bm.Dest) => BrowserMsg.sendCatch(dest, 'close_dialog', {}),\n    closePage: (dest: Bm.Dest) => BrowserMsg.sendCatch(dest, 'close_page', {}),\n    closeNewMessage: (dest: Bm.Dest) => BrowserMsg.sendCatch(dest, 'close_new_message', {}),\n    closeSwal: (dest: Bm.Dest) => BrowserMsg.sendCatch(dest, 'close_swal', {}),\n    focusBody: (dest: Bm.Dest) => BrowserMsg.sendCatch(dest, 'focus_body', {}),\n    focusFrame: (dest: Bm.Dest, bm: Bm.FocusFrame) => BrowserMsg.sendCatch(dest, 'focus_frame', bm),\n    closeReplyMessage: (dest: Bm.Dest, bm: Bm.CloseReplyMessage) => BrowserMsg.sendCatch(dest, 'close_reply_message', bm),\n    openNewMessage: (dest: Bm.Dest) => BrowserMsg.sendCatch(dest, 'open_new_message', {}),\n    scrollToReplyBox: (dest: Bm.Dest, bm: Bm.ScrollToReplyBox) => BrowserMsg.sendCatch(dest, 'scroll_to_reply_box', bm),\n    scrollToCursorInReplyBox: (dest: Bm.Dest, bm: Bm.ScrollToCursorInReplyBox) => BrowserMsg.sendCatch(dest, 'scroll_to_cursor_in_reply_box', bm),\n    reinsertReplyBox: (dest: Bm.Dest, bm: Bm.ReinsertReplyBox) => BrowserMsg.sendCatch(dest, 'reinsert_reply_box', bm),\n    passphraseDialog: (dest: Bm.Dest, bm: Bm.PassphraseDialog) => BrowserMsg.sendCatch(dest, 'passphrase_dialog', bm),\n    notificationShow: (dest: Bm.Dest, bm: Bm.NotificationShow) => BrowserMsg.sendCatch(dest, 'notification_show', bm),\n    notificationShowAuthPopupNeeded: (dest: Bm.Dest, bm: Bm.NotificationShowAuthPopupNeeded) => BrowserMsg.sendCatch(dest, 'notification_show_auth_popup_needed', bm),\n    renderPublicKeys: (dest: Bm.Dest, bm: Bm.RenderPublicKeys) => BrowserMsg.sendCatch(dest, 'render_public_keys', bm),\n    replyPubkeyMismatch: (dest: Bm.Dest) => BrowserMsg.sendCatch(dest, 'reply_pubkey_mismatch', {}),\n    addPubkeyDialog: (dest: Bm.Dest, bm: Bm.AddPubkeyDialog) => BrowserMsg.sendCatch(dest, 'add_pubkey_dialog', bm),\n    reload: (dest: Bm.Dest, bm: Bm.Reload) => BrowserMsg.sendCatch(dest, 'reload', bm),\n    redirect: (dest: Bm.Dest, bm: Bm.Redirect) => BrowserMsg.sendCatch(dest, 'redirect', bm),\n    openGoogleAuthDialog: (dest: Bm.Dest, bm: Bm.OpenGoogleAuthDialog) => BrowserMsg.sendCatch(dest, 'open_google_auth_dialog', bm),\n    addToContacts: (dest: Bm.Dest) => BrowserMsg.sendCatch(dest, 'addToContacts', {}),\n    reRenderRecipient: (dest: Bm.Dest, bm: Bm.ReRenderRecipient) => BrowserMsg.sendCatch(dest, 'reRenderRecipient', bm),\n    showAttachmentPreview: (dest: Bm.Dest, bm: Bm.ShowAttachmentPreview) => BrowserMsg.sendCatch(dest, 'show_attachment_preview', bm),\n  };\n  private static HANDLERS_REGISTERED_BACKGROUND: Handlers = {};\n  private static HANDLERS_REGISTERED_FRAME: Handlers = {\n    set_css: BrowserMsgCommonHandlers.setCss,\n    add_class: BrowserMsgCommonHandlers.addClass,\n    remove_class: BrowserMsgCommonHandlers.removeClass,\n  };\n\n  public static renderFatalErrCorner = (message: string, style: 'GREEN-NOTIFICATION' | 'RED-RELOAD-PROMPT') => {\n    const div = document.createElement('div');\n    div.textContent = message;\n    div.style.position = 'fixed';\n    div.style.bottom = '0';\n    div.style.right = '0';\n    div.style.fontSize = '12px';\n    div.style.backgroundColor = '#31a217';\n    div.style.color = 'white';\n    div.style.padding = '1px 3px';\n    div.style.zIndex = '1000';\n    if (style === 'RED-RELOAD-PROMPT') {\n      div.style.fontSize = '14px';\n      div.style.backgroundColor = '#a44';\n      div.style.padding = '4px 6px';\n      const a = document.createElement('a');\n      a.href = window.location.href.split('#')[0];\n      a.textContent = 'RELOAD';\n      a.style.color = 'white';\n      a.style.fontWeight = 'bold';\n      a.style.marginLeft = '12px';\n      div.appendChild(a);\n    }\n    window.document.body.appendChild(div);\n  }\n\n  public static tabId = async (): Promise<string | null | undefined> => {\n    try {\n      const { tabId } = await BrowserMsg.sendAwait(undefined, '_tab_', undefined, true) as Bm.Res._tab_;\n      return tabId;\n    } catch (e) {\n      if (e instanceof BgNotReadyErr) {\n        return undefined;\n      }\n      throw e;\n    }\n  }\n\n  public static requiredTabId = async (attempts = 10, delay = 200): Promise<string> => {\n    let tabId;\n    for (let i = 0; i < attempts; i++) { // sometimes returns undefined right after browser start due to BgNotReadyErr\n      tabId = await BrowserMsg.tabId();\n      if (tabId) {\n        return tabId;\n      }\n      await Ui.time.sleep(delay);\n    }\n    throw new TabIdRequiredError(`tabId is required, but received '${String(tabId)}' after ${attempts} attempts`);\n  }\n\n  public static addPgpListeners = () => {\n    BrowserMsg.bgAddListener('pgpHashChallengeAnswer', async (r: Bm.PgpHashChallengeAnswer) => ({ hashed: await PgpHash.challengeAnswer(r.answer) }));\n    BrowserMsg.bgAddListener('pgpMsgDiagnosePubkeys', MsgUtil.diagnosePubkeys);\n    BrowserMsg.bgAddListener('pgpMsgDecrypt', MsgUtil.decryptMessage);\n    BrowserMsg.bgAddListener('pgpMsgVerifyDetached', MsgUtil.verifyDetached);\n    BrowserMsg.bgAddListener('pgpMsgType', MsgUtil.type);\n    BrowserMsg.bgAddListener('keyParse', async (r: Bm.KeyParse) => ({ key: await KeyUtil.parse(r.armored) }));\n    BrowserMsg.bgAddListener('keyMatch', async (r: Bm.KeyMatch) => ({\n      key:\n        (await Promise.all(r.pubkeys.map(async (pub) => await KeyUtil.parse(pub)))).\n          find(k => k.allIds.map(id => OpenPGPKey.fingerprintToLongid(id).includes(r.longid)))\n    }));\n  }\n\n  public static addListener = (name: string, handler: Handler) => {\n    BrowserMsg.HANDLERS_REGISTERED_FRAME[name] = handler;\n  }\n\n  public static listen = (listenForTabId: string) => {\n    const processed: string[] = [];\n    chrome.runtime.onMessage.addListener((msg: Bm.Raw, sender, rawRespond: (rawResponse: Bm.RawResponse) => void) => {\n      // console.debug(`listener(${listenForTabId}) new message: ${msg.name} to ${msg.to} with id ${msg.uid} from`, sender);\n      try {\n        if (msg.to === listenForTabId || msg.to === 'broadcast') {\n          if (!processed.includes(msg.uid)) {\n            processed.push(msg.uid);\n            if (typeof BrowserMsg.HANDLERS_REGISTERED_FRAME[msg.name] !== 'undefined') {\n              const handler: Bm.AsyncRespondingHandler = BrowserMsg.HANDLERS_REGISTERED_FRAME[msg.name];\n              BrowserMsg.replaceObjUrlWithBuf(msg.data.bm, msg.data.objUrls)\n                .then(bm => BrowserMsg.sendRawResponse(handler(bm, sender), rawRespond))\n                .catch(e => BrowserMsg.sendRawResponse(Promise.reject(e), rawRespond));\n              return true; // will respond\n            } else if (msg.name !== '_tab_' && msg.to !== 'broadcast') {\n              BrowserMsg.sendRawResponse(Promise.reject(new Error(`BrowserMsg.listen error: handler \"${msg.name}\" not set`)), rawRespond);\n              return true; // will respond\n            }\n          } else {\n            // sometimes received events get duplicated\n            // while first event is being processed, second even will arrive\n            // that's why we generate a unique id of each request (uid) and filter them above to identify truly unique requests\n            // if we got here, that means we are handing a duplicate request\n            // we'll indicate will respond = true, so that the processing of the actual request is not negatively affected\n            // leaving it at \"false\" would respond with null, which would throw an error back to the original BrowserMsg sender:\n            // \"Error: BrowserMsg.sendAwait(pgpMsgDiagnosePubkeys) returned(null) with lastError: (no lastError)\"\n            // the duplication is likely caused by our routing mechanism. Sometimes browser will deliver the message directly as well as through bg\n            return true;\n          }\n        }\n      } catch (e) {\n        BrowserMsg.sendRawResponse(Promise.reject(e), rawRespond);\n        return true; // will respond\n      }\n      return false; // will not respond\n    });\n  }\n\n  public static bgAddListener = (name: string, handler: Handler) => {\n    BrowserMsg.HANDLERS_REGISTERED_BACKGROUND[name] = handler;\n  }\n\n  public static bgListen = () => {\n    chrome.runtime.onMessage.addListener((msg: Bm.Raw, sender, rawRespond: (rawRes: Bm.RawResponse) => void) => {\n      const respondIfPageStillOpen = (response: Bm.RawResponse) => {\n        try { // avoiding unnecessary errors when target tab gets closed\n          rawRespond(response);\n        } catch (cannotRespondErr) {\n          if (cannotRespondErr instanceof Error && cannotRespondErr.message === 'Attempting to use a disconnected port object') {\n            // the page we're responding to is closed - ec when closing secure compose\n          } else {\n            if (cannotRespondErr instanceof Error) {\n              cannotRespondErr.stack += `\\n\\nOriginal msg sender stack: ${msg.stack}`;\n            }\n            Catch.reportErr(Catch.rewrapErr(cannotRespondErr, `BrowserMsg.bgListen.respondIfPageStillOpen:${msg.name}`));\n          }\n        }\n      };\n      try {\n        // console.debug(`bgListen: ${msg.name} from ${sender.tab?.id}:${sender.tab?.index} to ${msg.to}`);\n        if (BrowserMsg.shouldRelayMsgToOtherPage(sender, msg.to)) { // message that has to be relayed through bg\n          const { tab, frame } = BrowserMsg.browserMsgDestParse(msg.to);\n          if (!tab) {\n            BrowserMsg.sendRawResponse(Promise.reject(new Error(`BrowserMsg.bgListen:${msg.name}:cannot parse destination tab in ${msg.to}`)), respondIfPageStillOpen);\n          } else {\n            chrome.tabs.sendMessage(tab, msg, { frameId: frame }, respondIfPageStillOpen);\n          }\n          return true; // will respond\n        } else if (Object.keys(BrowserMsg.HANDLERS_REGISTERED_BACKGROUND).includes(msg.name)) { // standard or broadcast message\n          const handler: Bm.AsyncRespondingHandler = BrowserMsg.HANDLERS_REGISTERED_BACKGROUND[msg.name];\n          BrowserMsg.replaceObjUrlWithBuf(msg.data.bm, msg.data.objUrls)\n            .then(bm => BrowserMsg.sendRawResponse(handler(bm, sender), respondIfPageStillOpen))\n            .catch(e => BrowserMsg.sendRawResponse(Promise.reject(e), respondIfPageStillOpen));\n          return true; // will respond\n        } else if (!msg.to) { // message meant for bg that we don't have a handler for\n          BrowserMsg.sendRawResponse(Promise.reject(new Error(`BrowserMsg.bgListen:${msg.name}:no such handler`)), respondIfPageStillOpen);\n          return true; // will respond\n        } else { // broadcast message that backend does not have a handler for - ignored\n          return false; // no plans to respond\n        }\n      } catch (exception) {\n        BrowserMsg.sendRawResponse(Promise.reject(exception), respondIfPageStillOpen);\n        return true; // will respond\n      }\n    });\n  }\n\n  /**\n   * When sending message from iframe within extension page, the browser will deliver the message to BOTH\n   *    the parent frame as well as the background (when we ment to just send to parent).\n   *    In such situations, we don't have to relay this message from bg to that frame, it already got it.\n   * When sending message from iframe within content script page (mail.google.com), the parent will NOT get such message\n   *    directly, and it will only be delivered to background page, from where we have to relay it around.\n   */\n  private static shouldRelayMsgToOtherPage = (sender: chrome.runtime.MessageSender, destination: string | null) => {\n    if (!sender.tab || !destination) {\n      return false; // messages meant to bg, or from unknown sender, should not be relayed\n    }\n    if (Catch.browser().name !== 'chrome') {\n      return true; // only chrome sends messages directly to extension frame parent (in addition to sending to bg)\n    }\n    if (destination !== `${sender.tab.id}:0`) { // zero mains the main frame in a tab, the parent frame\n      return true; // not sending to a parent (must relay, browser does not send directly)\n    }\n    if (sender.url?.includes(chrome.runtime.id) && sender.tab.url?.startsWith('https://')) {\n      return true; // sending to a parent content script (must relay, browser does not send directly)\n    }\n    return false; // sending to a parent that is an extension frame (do not relay, browser does send directly)\n  }\n\n  private static sendCatch = (dest: Bm.Dest | undefined, name: string, bm: Dict<any>) => {\n    BrowserMsg.sendAwait(dest, name, bm).catch(Catch.reportErr);\n  }\n\n  private static sendAwait = async (destString: string | undefined, name: string, bm?: Dict<unknown>, awaitRes = false): Promise<Bm.Response> => {\n    bm = bm || {};\n    // console.debug(`sendAwait ${name} to ${destString || 'bg'}`, bm);\n    const isBackgroundPage = Env.isBackgroundPage();\n    if (isBackgroundPage && BrowserMsg.HANDLERS_REGISTERED_BACKGROUND && typeof destString === 'undefined') { // calling from bg script to bg script: skip messaging\n      const handler: Bm.AsyncRespondingHandler = BrowserMsg.HANDLERS_REGISTERED_BACKGROUND[name];\n      return await handler(bm, 'background');\n    }\n    return await new Promise((resolve, reject) => { // here browser messaging is used - msg has to be serializable - Buf instances need to be converted to object urls, and back upon receipt\n      const objUrls = BrowserMsg.replaceBufWithObjUrlInplace(bm);\n      const msg: Bm.Raw = { name, data: { bm: bm!, objUrls }, to: destString || null, uid: Str.sloppyRandom(10), stack: Catch.stackTrace() }; // tslint:disable-line:no-null-keyword\n      const processRawMsgResponse = (r: Bm.RawResponse) => {\n        if (!awaitRes) {\n          resolve(undefined);\n        } else if (!r || typeof r !== 'object') { // r can be null if we sent a message to a non-existent window id\n          const lastError = chrome.runtime.lastError ? chrome.runtime.lastError.message || '(empty lastError)' : '(no lastError)';\n          let e: Error;\n          if (typeof destString === 'undefined' && typeof r === 'undefined') {\n            if (lastError === 'The object could not be cloned.') {\n              e = new Error(`BrowserMsg.sendAwait(${name}) failed with lastError: ${lastError}`);\n            } else if (lastError === 'Could not establish connection. Receiving end does not exist.' || lastError === 'The message port closed before a response was received.') {\n              // \"The message port closed before a response was received.\" could also happen for otherwise working extension, if bg script\n              //    did not return `true` (indicating async response). That would be our own coding error in BrowserMsg.\n              e = new BgNotReadyErr(`BgNotReadyErr: BrowserMsg.sendAwait(${name}) failed with lastError: ${lastError}`);\n            } else {\n              e = new Error(`BrowserMsg.sendAwait(${name}) failed with unknown lastError: ${lastError}`);\n            }\n          } else {\n            e = new Error(`BrowserMsg.sendAwait(${name}) returned(${String(r)}) with lastError: ${lastError}`);\n          }\n          e.stack = `${msg.stack}\\n\\n${e.stack}`;\n          reject(e);\n        } else if (typeof r === 'object' && r.exception) {\n          reject(BrowserMsg.jsonToErr(r.exception, msg));\n        } else if (!r.result || typeof r.result !== 'object') {\n          resolve(r.result as Bm.Response);\n        } else {\n          BrowserMsg.replaceObjUrlWithBuf(r.result, r.objUrls).then(resolve).catch(reject);\n        }\n      };\n      try {\n        if (isBackgroundPage) {\n          const { tab, frame } = BrowserMsg.browserMsgDestParse(msg.to);\n          if (!tab) {\n            throw new Error(`Cannot parse tab in ${msg.to}: ${tab} when sending ${msg.name}`);\n          }\n          chrome.tabs.sendMessage(tab, msg, { frameId: frame }, processRawMsgResponse);\n        } else if (chrome.runtime) {\n          chrome.runtime.sendMessage(msg, processRawMsgResponse);\n        } else {\n          BrowserMsg.renderFatalErrCorner('Error: missing chrome.runtime', 'RED-RELOAD-PROMPT');\n        }\n      } catch (e) {\n        if (e instanceof Error && e.message === 'Extension context invalidated.') {\n          BrowserMsg.renderFatalErrCorner('Restart browser to re-enable FlowCrypt', 'GREEN-NOTIFICATION');\n        } else {\n          throw e;\n        }\n      }\n    });\n  }\n\n  /**\n   * Browser messages cannot send a lot of data per message. This will replace Buf objects (which can be large) with an ObjectURL\n   * Be careful when editting - the type system won't help you here and you'll likely make mistakes\n   * The requestOrResponse object will get directly updated in this function\n   */\n  private static replaceBufWithObjUrlInplace = (requestOrResponse: unknown): Dict<string> => {\n    const objUrls: Dict<string> = {};\n    if (requestOrResponse && typeof requestOrResponse === 'object' && requestOrResponse !== null) { // lgtm [js/comparison-between-incompatible-types]\n      for (const possibleBufName of Object.keys(requestOrResponse)) {\n        const possibleBufs = (requestOrResponse as any)[possibleBufName];\n        if (possibleBufs instanceof Uint8Array) {\n          objUrls[possibleBufName] = Browser.objUrlCreate(possibleBufs);\n          (requestOrResponse as any)[possibleBufName] = undefined;\n        }\n      }\n    }\n    return objUrls;\n  }\n\n  /**\n   * This method does the opposite of replaceBufWithObjUrlInplace so we end up with original message (or response) containing possibly a large Buf\n   * Be careful when editting - the type system won't help you here and you'll likely make mistakes\n   */\n  private static replaceObjUrlWithBuf = async <T>(requestOrResponse: T, objUrls: Dict<string>): Promise<T> => {\n    if (requestOrResponse && typeof requestOrResponse === 'object' && requestOrResponse !== null && objUrls) { // lgtm [js/comparison-between-incompatible-types]\n      for (const consumableObjUrlName of Object.keys(objUrls)) {\n        (requestOrResponse as any)[consumableObjUrlName] = await Browser.objUrlConsume(objUrls[consumableObjUrlName]);\n      }\n    }\n    return requestOrResponse;\n  }\n\n  private static errToJson = (e: any): Bm.ErrAsJson => {\n    if (e instanceof AjaxErr) {\n      const { message, stack, status, url, responseText, statusText, resMsg, resDetails } = e;\n      return { stack, message, errorConstructor: 'AjaxErr', ajaxErrorDetails: { status, url, responseText, statusText, resMsg, resDetails } };\n    }\n    const { stack, message } = Catch.rewrapErr(e, 'sendRawResponse');\n    return { stack, message, errorConstructor: 'Error' };\n  }\n\n  private static jsonToErr = (errAsJson: Bm.ErrAsJson, msg: Bm.Raw) => {\n    const stackInfo = `\\n\\n[callerStack]\\n${msg.stack}\\n[/callerStack]\\n\\n[responderStack]\\n${errAsJson.stack}\\n[/responderStack]\\n`;\n    if (errAsJson.errorConstructor === 'AjaxErr') {\n      const { status, url, responseText, statusText, resMsg, resDetails } = errAsJson.ajaxErrorDetails;\n      return new AjaxErr(`BrowserMsg(${msg.name}) ${errAsJson.message}`, stackInfo, status, url, responseText, statusText, resMsg, resDetails);\n    }\n    const e = new Error(`BrowserMsg(${msg.name}) ${errAsJson.message}`);\n    e.stack += stackInfo;\n    return e;\n  }\n\n  private static sendRawResponse = (handlerPromise: Promise<Bm.Res.Any>, rawRespond: (rawResponse: Bm.RawResponse) => void) => {\n    try {\n      handlerPromise.then(result => {\n        const objUrls = BrowserMsg.replaceBufWithObjUrlInplace(result); // this actually changes the result object\n        rawRespond({ result, exception: undefined, objUrls });\n      }).catch(e => {\n        rawRespond({ result: undefined, exception: BrowserMsg.errToJson(e), objUrls: {} });\n      });\n    } catch (e) {\n      rawRespond({ result: undefined, exception: BrowserMsg.errToJson(e), objUrls: {} });\n    }\n  }\n\n  private static browserMsgDestParse = (destString: string | null) => {\n    const parsed = { tab: undefined as undefined | number, frame: undefined as undefined | number };\n    if (destString) {\n      parsed.tab = Number(destString.split(':')[0]);\n      const parsedFrame = Number(destString.split(':')[1]);\n      parsed.frame = !isNaN(parsedFrame) ? parsedFrame : undefined;\n    }\n    return parsed;\n  }\n\n}\n",
    "extension/js/common/browser/chrome.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Catch } from '../platform/catch.js';\nimport { ContentScriptWindow } from './browser-window.js';\nimport { Env } from './env.js';\nimport { Ui } from './ui.js';\nimport { Url, Dict } from '../core/common.js';\nimport { AbstractStore } from '../platform/store/abstract-store.js';\n\nconst handleFatalErr = (reason: 'storage_undefined', error: Error) => {\n  try {\n    if (Env.isBackgroundPage()) {\n      throw error;\n    } else if (Env.isContentScript()) {\n      console.error('Incomplete extension environment in content script', error);\n    } else if (!chrome.runtime) {\n      console.error('Chrome.runtime missing, cannot continue', error);\n    } else { // extension pages\n      window.location.href = chrome.runtime.getURL(Url.create(`chrome/settings/fatal.htm`, { reason, stack: error.stack }));\n    }\n  } catch (e) {\n    if (e && e instanceof Error && e.message === 'Extension context invalidated.') {\n      console.info(`FlowCrypt cannot handle fatal error because: Extension context invalidated. Destroying.`, error);\n      (window as any as ContentScriptWindow).destroy();\n    } else {\n      throw e;\n    }\n  }\n};\n\nexport const tabsQuery = async (q: chrome.tabs.QueryInfo): Promise<chrome.tabs.Tab[]> => {\n  return await new Promise(resolve => chrome.tabs.query(q, resolve));\n};\n\nexport const windowsCreate = async (q: chrome.windows.CreateData): Promise<chrome.windows.Window | undefined> => {\n  return await new Promise(resolve => {\n    if (typeof chrome.windows !== 'undefined') {\n      chrome.windows.create(q, resolve);\n    } else {\n      Ui.modal.error('Your platform is not supported: browser does not support extension windows').catch(Catch.reportErr);\n    }\n  });\n};\n\nexport const storageLocalGet = async (keys: string[]): Promise<Dict<unknown>> => {\n  return await new Promise((resolve, reject) => {\n    if (typeof chrome.storage === 'undefined') {\n      handleFatalErr('storage_undefined', new Error('storage is undefined'));\n    } else {\n      chrome.storage.local.get(keys, result => {\n        if (typeof result !== 'undefined') {\n          resolve(result);\n        } else if (chrome.runtime.lastError) {\n          reject(AbstractStore.errCategorize(chrome.runtime.lastError));\n        } else {\n          reject(new Error(`storageLocalGet(${keys.join(',')}) produced undefined result without an error`));\n        }\n      });\n    }\n  });\n};\n\nexport const storageLocalGetAll = async (): Promise<{ [key: string]: any }> => {\n  return await new Promise((resolve) => {\n    if (typeof chrome.storage === 'undefined') {\n      handleFatalErr('storage_undefined', new Error('storage is undefined'));\n    } else {\n      chrome.storage.local.get(resolve);\n    }\n  });\n};\n\nexport const storageLocalSet = async (values: Dict<any>): Promise<void> => {\n  return await new Promise((resolve) => {\n    if (typeof chrome.storage === 'undefined') {\n      handleFatalErr('storage_undefined', new Error('storage is undefined'));\n    } else {\n      chrome.storage.local.set(values, resolve);\n    }\n  });\n};\n\nexport const storageLocalRemove = async (keys: string[]): Promise<void> => {\n  return await new Promise((resolve) => {\n    if (typeof chrome.storage === 'undefined') {\n      handleFatalErr('storage_undefined', new Error('storage is undefined'));\n    } else {\n      chrome.storage.local.remove(keys, resolve);\n    }\n  });\n};\n",
    "extension/js/common/core/crypto/key.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Buf } from '../buf.js';\nimport { Catch, UnreportableError } from '../../platform/catch.js';\nimport { MsgBlockParser } from '../msg-block-parser.js';\nimport { PgpArmor } from './pgp/pgp-armor.js';\nimport { opgp } from './pgp/openpgpjs-custom.js';\nimport { OpenPGPKey } from './pgp/openpgp-key.js';\nimport { SmimeKey } from './smime/smime-key.js';\nimport { MsgBlock } from '../msg-block.js';\n\n/**\n * This is a common Key interface for both OpenPGP and X.509 keys.\n *\n * Since Key objects are frequently JSON serialized (e.g. via message passing)\n * all dates are expressed as number of milliseconds since Unix Epoch.\n * This is what `Date.now()` returns and `new Date(x)` accepts.\n */\nexport interface Key {\n  type: 'openpgp' | 'x509';\n  id: string; // a fingerprint of the primary key in OpenPGP, and similarly a fingerprint of the actual cryptographic key (eg RSA fingerprint) in S/MIME\n  allIds: string[]; // a list of fingerprints, including those for subkeys\n  created: number;\n  revoked: boolean;\n  lastModified: number | undefined; // date of last signature, or undefined if never had valid signature\n  expiration: number | undefined; // number of millis of expiration or undefined if never expires\n  usableForEncryption: boolean;\n  usableForSigning: boolean;\n  usableForEncryptionButExpired: boolean;\n  usableForSigningButExpired: boolean;\n  missingPrivateKeyForSigning: boolean;\n  missingPrivateKeyForDecryption: boolean;\n  emails: string[];\n  identities: string[];\n  fullyDecrypted: boolean;\n  fullyEncrypted: boolean;\n  isPublic: boolean; // isPublic and isPrivate are mutually exclusive\n  isPrivate: boolean; // only one should be set to true\n  algo: {\n    algorithm: string,\n    curve?: string,\n    bits?: number,\n    algorithmId: number\n  };\n  issuerAndSerialNumber?: string | undefined; // DER-encoded IssuerAndSerialNumber of X.509 Certificate as raw string\n}\n\nexport type PubkeyResult = { pubkey: Key, email: string, isMine: boolean };\n\nexport type Contact = {\n  email: string;\n  name: string | null;\n  pubkey: Key | undefined;\n  hasPgp: 0 | 1;\n  fingerprint: string | null;\n  lastUse: number | null;\n  pubkeyLastCheck: number | null;\n  expiresOn: number | null;\n  revoked: boolean;\n};\n\nexport interface KeyInfo {\n  private: string;\n  public: string; // this cannot be Pubkey has it's being passed to localstorage\n  longid: string;\n  fingerprints: string[];\n  emails?: string[]; // todo - used to be missing - but migration was supposed to add it? setting back to optional for now\n}\n\nexport interface ExtendedKeyInfo extends KeyInfo {\n  passphrase?: string;\n  type: 'openpgp' | 'x509'\n}\n\nexport type KeyAlgo = 'curve25519' | 'rsa2048' | 'rsa4096';\n\nexport type PrvPacket = (OpenPGP.packet.SecretKey | OpenPGP.packet.SecretSubkey);\n\nexport class UnexpectedKeyTypeError extends Error { }\n\nexport class KeyUtil {\n\n  public static isWithoutSelfCertifications = async (key: Key) => {\n    // all non-OpenPGP keys are automatically considered to be not\n    // \"without self certifications\"\n    if (key.type !== 'openpgp') {\n      return false;\n    }\n    return await OpenPGPKey.isWithoutSelfCertifications(key);\n  }\n\n  /**\n   * Read many keys, could be armored or binary, in single armor or separately, useful for importing keychains of various formats\n   */\n  public static readMany = async (fileData: Buf): Promise<{ keys: Key[], errs: Error[] }> => {\n    const allKeys: Key[] = [];\n    const allErrs: Error[] = [];\n    const { blocks } = MsgBlockParser.detectBlocks(fileData.toUtfStr('ignore'));\n    const isImportable = (block: MsgBlock) => block.type === 'publicKey' || block.type === 'privateKey' || block.type === 'certificate';\n    const armoredPublicKeyBlocks = blocks.filter(isImportable);\n    const pushKeysAndErrs = async (content: string | Buf, isArmored: boolean) => {\n      try {\n        if (isArmored) {\n          allKeys.push(...await KeyUtil.parseMany(content.toString()));\n        } else {\n          const buf = typeof content === 'string' ? Buf.fromUtfStr(content) : content;\n          const { keys, err } = await KeyUtil.readBinary(buf);\n          allKeys.push(...keys);\n          allErrs.push(...err);\n        }\n      } catch (e) {\n        allErrs.push(e instanceof Error ? e : new Error(String(e)));\n      }\n    };\n    if (armoredPublicKeyBlocks.length) {\n      for (const block of blocks) {\n        await pushKeysAndErrs(block.content, true);\n      }\n    } else {\n      await pushKeysAndErrs(fileData, false);\n    }\n    return { keys: allKeys, errs: allErrs };\n  }\n\n  public static parse = async (text: string): Promise<Key> => {\n    return (await KeyUtil.parseMany(text))[0];\n  }\n\n  public static parseMany = async (text: string): Promise<Key[]> => {\n    const keyType = KeyUtil.getKeyType(text);\n    if (keyType === 'openpgp') {\n      return await OpenPGPKey.parseMany(text);\n    } else if (keyType === 'x509') {\n      // TODO: No support for parsing multiple S/MIME keys for now\n      return [SmimeKey.parse(text)];\n    }\n    throw new UnexpectedKeyTypeError(`Key type is ${keyType}, expecting OpenPGP or x509 S/MIME`);\n  }\n\n  public static readBinary = async (key: Uint8Array, passPhrase?: string | undefined): Promise<{ keys: Key[], err: Error[] }> => {\n    const allKeys: Key[] = [], allErr: Error[] = [];\n    try {\n      const { keys, err } = await opgp.key.read(key);\n      if (keys.length > 0) {\n        for (const key of keys) {\n          // we should decrypt them all here to have consistent behavior between pkcs12 files and PGP\n          // pkcs12 files must be decrypted during parsing\n          // then rename this method to parseDecryptBinary\n          const parsed = await OpenPGPKey.convertExternalLibraryObjToKey(key);\n          // if (await KeyUtil.decrypt(parsed, passPhrase, undefined, 'OK-IF-ALREADY-DECRYPTED')) {\n          allKeys.push(parsed);\n          // } else {\n          //   allErr.push(new Error(`Wrong pass phrase for OpenPGP key ${parsed.id} (${parsed.emails[0]})`));\n          // }\n        }\n      }\n      if (err) {\n        allErr.push(...err);\n      }\n    } catch (e) {\n      allErr.push(e as Error);\n    }\n    if (!allKeys.length) {\n      try {\n        allKeys.push(SmimeKey.parseDecryptBinary(key, passPhrase ?? ''));\n        return { keys: allKeys, err: [] };\n      } catch (e) {\n        allErr.push(e as Error);\n      }\n    }\n    return { keys: allKeys, err: allErr };\n  }\n\n  public static parseBinary = async (key: Uint8Array, passPhrase?: string | undefined): Promise<Key[]> => {\n    const { keys, err } = await KeyUtil.readBinary(key, passPhrase);\n    if (keys.length > 0) {\n      return keys;\n    }\n    throw new Error(err.length ? err.map((e, i) => (i + 1) + '. ' + e.message).join('\\n') : 'Should not happen: no keys and no errors.');\n  }\n\n  public static armor = (pubkey: Key): string => {\n    const armored = (pubkey as unknown as { rawArmored: string }).rawArmored;\n    if (!armored) {\n      throw new Error('The Key object has no rawArmored field.');\n    }\n    return armored;\n  }\n\n  public static diagnose = async (key: Key, passphrase: string): Promise<Map<string, string>> => {\n    let result = new Map<string, string>();\n    result.set(`Key type`, key.type);\n    if (key.type === 'openpgp') {\n      const opgpresult = await OpenPGPKey.diagnose(key, passphrase);\n      result = new Map<string, string>([...result, ...opgpresult]);\n    }\n    result.set(`expiration`, KeyUtil.formatResult(key.expiration));\n    result.set(`internal dateBeforeExpiration`, await KeyUtil.formatResultAsync(async () => KeyUtil.dateBeforeExpirationIfAlreadyExpired(key)));\n    result.set(`internal usableForEncryptionButExpired`, KeyUtil.formatResult(key.usableForEncryptionButExpired));\n    result.set(`internal usableForSigningButExpired`, KeyUtil.formatResult(key.usableForSigningButExpired));\n    return result;\n  }\n\n  public static formatResultAsync = async (f: () => Promise<unknown>): Promise<string> => {\n    try {\n      return KeyUtil.formatResult(await f());\n    } catch (e) {\n      return `[${String(e)}]`;\n    }\n  }\n\n  public static formatResult = (value: unknown): string => {\n    return `[-] ${String(value)}`;\n  }\n\n  public static asPublicKey = async (pubkey: Key): Promise<Key> => {\n    // TODO: Delegate to appropriate key type\n    if (pubkey.type === 'openpgp') {\n      return await OpenPGPKey.asPublicKey(pubkey);\n    }\n    // TODO: Assuming S/MIME keys are already public: this should be fixed.\n    return pubkey;\n  }\n\n  public static expired = (key: Key): boolean => {\n    const exp = key.expiration;\n    if (!exp) {\n      return false;\n    }\n    return Date.now() > exp;\n  }\n\n  public static dateBeforeExpirationIfAlreadyExpired = (key: Key): Date | undefined => {\n    const expiration = key.expiration;\n    return expiration && KeyUtil.expired(key) ? new Date(expiration - 1000) : undefined;\n  }\n\n  // todo - this should be made to tolerate smime keys\n  public static normalize = async (armored: string): Promise<{ normalized: string, keys: OpenPGP.key.Key[] }> => {\n    try {\n      let keys: OpenPGP.key.Key[] = [];\n      armored = PgpArmor.normalize(armored, 'key');\n      if (RegExp(PgpArmor.headers('publicKey', 're').begin).test(armored)) {\n        keys = (await opgp.key.readArmored(armored)).keys;\n      } else if (RegExp(PgpArmor.headers('privateKey', 're').begin).test(armored)) {\n        keys = (await opgp.key.readArmored(armored)).keys;\n      } else if (RegExp(PgpArmor.headers('encryptedMsg', 're').begin).test(armored)) {\n        keys = [new opgp.key.Key((await opgp.message.readArmored(armored)).packets)];\n      }\n      for (const k of keys) {\n        for (const u of k.users) {\n          u.otherCertifications = []; // prevent key bloat\n        }\n      }\n      return { normalized: keys.map(k => k.armor()).join('\\n'), keys };\n    } catch (error) {\n      Catch.reportErr(error);\n      return { normalized: '', keys: [] };\n    }\n  }\n\n  public static checkPassPhrase = async (pkey: string, passphrase: string): Promise<boolean> => {\n    // decrypt will change the key in place so it's important to parse the key here\n    // because passing an object from the caller could have unexpected consequences\n    const key = await KeyUtil.parse(pkey);\n    if (key.type !== 'openpgp') {\n      throw new Error('Checking password for this key type is not implemented: ' + key.type);\n    }\n    return await KeyUtil.decrypt(key, passphrase);\n  }\n\n  public static getKeyType = (pubkey: string): 'openpgp' | 'x509' | 'unknown' => {\n    if (pubkey.startsWith(PgpArmor.headers('certificate').begin)) {\n      return 'x509';\n    } else if (pubkey.startsWith(PgpArmor.headers('pkcs12').begin)) {\n      return 'x509';\n    } else if (pubkey.startsWith(PgpArmor.headers('publicKey').begin)) {\n      return 'openpgp';\n    } else if (pubkey.startsWith(PgpArmor.headers('privateKey').begin)) {\n      return 'openpgp';\n    } else {\n      return 'unknown';\n    }\n  }\n\n  public static choosePubsBasedOnKeyTypeCombinationForPartialSmimeSupport = (pubs: PubkeyResult[]): Key[] => {\n    const myPubs = pubs.filter(pub => pub.isMine); // currently this must be openpgp pub\n    const otherPgpPubs = pubs.filter(pub => !pub.isMine && pub.pubkey.type === 'openpgp');\n    const otherSmimePubs = pubs.filter(pub => !pub.isMine && pub.pubkey.type === 'x509');\n    if (otherPgpPubs.length && otherSmimePubs.length) {\n      let err = `Cannot use mixed OpenPGP (${otherPgpPubs.map(p => p.email).join(', ')}) and S/MIME (${otherSmimePubs.map(p => p.email).join(', ')}) public keys yet.`;\n      err += 'If you need to email S/MIME recipient, do not add any OpenPGP recipient at the same time.';\n      throw new UnreportableError(err);\n    }\n    if (otherPgpPubs.length) {\n      return myPubs.concat(...otherPgpPubs).map(p => p.pubkey);\n    }\n    if (otherSmimePubs.length) { // todo - currently skipping my own pgp keys when encrypting message for S/MIME\n      return otherSmimePubs.map(pub => pub.pubkey);\n    }\n    return myPubs.map(p => p.pubkey);\n  }\n\n  public static decrypt = async (key: Key, passphrase: string, optionalKeyid?: OpenPGP.Keyid, optionalBehaviorFlag?: 'OK-IF-ALREADY-DECRYPTED'): Promise<boolean> => {\n    if (key.type === 'openpgp') {\n      return await OpenPGPKey.decryptKey(key, passphrase, optionalKeyid, optionalBehaviorFlag);\n    } else {\n      throw new Error(`KeyUtil.decrypt does not support key type ${key.type}`);\n    }\n  }\n\n  public static encrypt = async (key: Key, passphrase: string) => {\n    if (key.type === 'openpgp') {\n      return await OpenPGPKey.encryptKey(key, passphrase);\n    } else {\n      throw new Error(`KeyUtil.encrypt does not support key type ${key.type}`);\n    }\n  }\n\n  public static reformatKey = async (privateKey: Key, passphrase: string, userIds: { email: string | undefined; name: string }[], expireSeconds: number) => {\n    if (privateKey.type === 'openpgp') {\n      return await OpenPGPKey.reformatKey(privateKey, passphrase, userIds, expireSeconds);\n    } else {\n      throw new Error(`KeyUtil.reformatKey does not support key type ${privateKey.type}`);\n    }\n  }\n\n  public static revoke = async (key: Key): Promise<string | undefined> => {\n    if (key.type === 'openpgp') {\n      return await OpenPGPKey.revoke(key);\n    } else {\n      throw new Error(`KeyUtil.revoke does not support key type ${key.type}`);\n    }\n  }\n\n  public static keyInfoObj = async (prv: Key): Promise<KeyInfo> => {\n    if (!prv.isPrivate) {\n      throw new Error('Key passed into KeyUtil.keyInfoObj must be a Private Key');\n    }\n    const pubkey = await KeyUtil.asPublicKey(prv);\n    return {\n      private: KeyUtil.armor(prv),\n      public: KeyUtil.armor(pubkey),\n      longid: KeyUtil.getPrimaryLongid(pubkey),\n      emails: prv.emails,\n      fingerprints: prv.allIds,\n    };\n  }\n\n  public static getPubkeyLongids = (pubkey: Key): string[] => {\n    if (pubkey.type !== 'x509') {\n      return pubkey.allIds.map(id => OpenPGPKey.fingerprintToLongid(id));\n    }\n    return [KeyUtil.getPrimaryLongid(pubkey)];\n  }\n\n  public static getPrimaryLongid = (pubkey: Key): string => {\n    if (pubkey.type !== 'x509') {\n      return OpenPGPKey.fingerprintToLongid(pubkey.id);\n    }\n    const encodedIssuerAndSerialNumber = 'X509-' + Buf.fromRawBytesStr(pubkey.issuerAndSerialNumber!).toBase64Str();\n    if (!encodedIssuerAndSerialNumber) {\n      throw new Error(`Cannot extract IssuerAndSerialNumber from the certificate for: ${pubkey.id}`);\n    }\n    return encodedIssuerAndSerialNumber;\n  }\n\n  public static getKeyInfoLongids = (ki: ExtendedKeyInfo): string[] => {\n    if (ki.type !== 'x509') {\n      return ki.fingerprints.map(fp => OpenPGPKey.fingerprintToLongid(fp));\n    }\n    return [ki.longid];\n  }\n}\n",
    "extension/js/common/core/crypto/pgp/msg-util.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\nimport { Contact, Key, KeyInfo, ExtendedKeyInfo, KeyUtil } from '../key.js';\nimport { MsgBlockType, ReplaceableMsgBlockType } from '../../msg-block.js';\nimport { Value } from '../../common.js';\nimport { Buf } from '../../buf.js';\nimport { Catch } from '../../../platform/catch.js';\nimport { PgpArmor, PreparedForDecrypt } from './pgp-armor.js';\nimport { opgp } from './openpgpjs-custom.js';\nimport { KeyCache } from '../../../platform/key-cache.js';\nimport { ContactStore } from '../../../platform/store/contact-store.js';\nimport { SmimeKey } from '../smime/smime-key.js';\nimport { OpenPGPKey } from './openpgp-key.js';\n\nexport class DecryptionError extends Error {\n  public decryptError: DecryptError;\n\n  constructor(decryptError: DecryptError) {\n    super(decryptError.error.message);\n    this.decryptError = decryptError;\n  }\n}\n\nexport namespace PgpMsgMethod {\n  export namespace Arg {\n    export type Encrypt = { pubkeys: Key[], signingPrv?: Key, pwd?: string, data: Uint8Array, filename?: string, armor: boolean, date?: Date };\n    export type Type = { data: Uint8Array | string };\n    export type Decrypt = { kisWithPp: ExtendedKeyInfo[], encryptedData: Uint8Array, msgPwd?: string };\n    export type DiagnosePubkeys = { armoredPubs: string[], message: Uint8Array };\n    export type VerifyDetached = { plaintext: Uint8Array, sigText: Uint8Array };\n  }\n  export type DiagnosePubkeys = (arg: Arg.DiagnosePubkeys) => Promise<DiagnoseMsgPubkeysResult>;\n  export type VerifyDetached = (arg: Arg.VerifyDetached) => Promise<VerifyRes>;\n  export type Decrypt = (arg: Arg.Decrypt) => Promise<DecryptSuccess | DecryptError>;\n  export type Type = (arg: Arg.Type) => Promise<PgpMsgTypeResult>;\n  export type Encrypt = (arg: Arg.Encrypt) => Promise<EncryptPgpResult | EncryptX509Result>;\n  export type EncryptPgpResult = EncryptPgpArmorResult | OpenPGP.EncryptBinaryResult;\n  export type EncryptAnyArmorResult = PgpMsgMethod.EncryptPgpArmorResult | EncryptX509Result;\n  export interface EncryptPgpArmorResult {\n    data: Uint8Array;\n    signature?: string;\n    type: 'openpgp';\n  }\n  export type EncryptX509Result = {\n    data: Uint8Array;\n    type: 'smime';\n  };\n}\n\ntype SortedKeysForDecrypt = {\n  verificationContacts: Contact[];\n  forVerification: OpenPGP.key.Key[];\n  encryptedFor: string[];\n  signedBy: string[];\n  prvMatching: ExtendedKeyInfo[];\n  prvForDecrypt: ExtendedKeyInfo[];\n  prvForDecryptDecrypted: { ki: ExtendedKeyInfo, decrypted: Key }[];\n  prvForDecryptWithoutPassphrases: KeyInfo[];\n};\n\nexport type DecryptSuccess = { success: true; signature?: VerifyRes; isEncrypted?: boolean, filename?: string, content: Buf };\ntype DecryptError$error = { type: DecryptErrTypes; message: string; };\ntype DecryptError$longids = { message: string[]; matching: string[]; chosen: string[]; needPassphrase: string[]; };\nexport type DecryptError = { success: false; error: DecryptError$error; longids: DecryptError$longids; content?: Buf; isEncrypted?: boolean; };\n\ntype OpenpgpMsgOrCleartext = OpenPGP.message.Message | OpenPGP.cleartext.CleartextMessage;\n\nexport type VerifyRes = {\n  signer?: { primaryUserId: string | undefined, longid: string };\n  contact?: Contact;\n  match: boolean | null;\n  error?: string;\n  isErrFatal?: boolean,\n  content?: Buf\n};\nexport type PgpMsgTypeResult = { armored: boolean, type: MsgBlockType } | undefined;\nexport type DecryptResult = DecryptSuccess | DecryptError;\nexport type DiagnoseMsgPubkeysResult = { found_match: boolean, receivers: number, };\nexport enum DecryptErrTypes {\n  keyMismatch = 'key_mismatch',\n  usePassword = 'use_password',\n  wrongPwd = 'wrong_password',\n  noMdc = 'no_mdc',\n  badMdc = 'bad_mdc',\n  needPassphrase = 'need_passphrase',\n  format = 'format',\n  other = 'other',\n}\n\nexport class FormatError extends Error {\n  public data: string;\n  constructor(message: string, data: string) {\n    super(message);\n    this.data = data;\n  }\n}\n\nexport class MsgUtil {\n\n  public static type: PgpMsgMethod.Type = async ({ data }) => { // promisified because used through bg script\n    if (!data || !data.length) {\n      return undefined;\n    }\n    if (typeof data === 'string') {\n      // Uint8Array sent over BrowserMsg gets converted to blobs on the sending side, and read on the receiving side\n      // Firefox blocks such blobs from content scripts to background, see: https://github.com/FlowCrypt/flowcrypt-browser/issues/2587\n      // that's why we add an option to send data as a base64 formatted string\n      data = Buf.fromBase64Str(data);\n    }\n    const firstByte = data[0];\n    // attempt to understand this as a binary PGP packet: https://tools.ietf.org/html/rfc4880#section-4.2\n    if ((firstByte & 0b10000000) === 0b10000000) { // 1XXX XXXX - potential pgp packet tag\n      let tagNumber = 0; // zero is a forbidden tag number\n      if ((firstByte & 0b11000000) === 0b11000000) { // 11XX XXXX - potential new pgp packet tag\n        tagNumber = firstByte & 0b00111111;  // 11TTTTTT where T is tag number bit\n      } else { // 10XX XXXX - potential old pgp packet tag\n        tagNumber = (firstByte & 0b00111100) / 4; // 10TTTTLL where T is tag number bit. Division by 4 in place of two bit shifts. I hate bit shifts.\n      }\n      if (Object.values(opgp.enums.packet).includes(tagNumber)) {\n        // Indeed a valid OpenPGP packet tag number\n        // This does not 100% mean it's OpenPGP message\n        // But it's a good indication that it may be\n        const t = opgp.enums.packet;\n        const msgTpes = [\n          t.symEncryptedIntegrityProtected, t.modificationDetectionCode,\n          t.symEncryptedAEADProtected, t.symmetricallyEncrypted, t.compressed\n        ];\n        return { armored: false, type: msgTpes.includes(tagNumber) ? 'encryptedMsg' : 'publicKey' };\n      }\n    }\n    const fiftyBytesUtf = new Buf(data.slice(0, 50)).toUtfStr().trim();\n    const armorTypes: ReplaceableMsgBlockType[] = ['encryptedMsg', 'privateKey', 'publicKey', 'signedMsg'];\n    for (const type of armorTypes) {\n      if (fiftyBytesUtf.includes(PgpArmor.headers(type).begin)) {\n        return { armored: true, type };\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns signed data if detached=false, armored\n   * Returns signature if detached=true, armored\n   */\n  public static sign = async (signingPrivate: Key, data: string, detached = false): Promise<string> => {\n    // TODO: Delegate to appropriate key type\n    return await OpenPGPKey.sign(signingPrivate, data, detached);\n  }\n\n  public static verify = async (msg: OpenpgpMsgOrCleartext, pubs: OpenPGP.key.Key[], contact?: Contact): Promise<VerifyRes> => {\n    const verifyRes: VerifyRes = { contact, match: null }; // tslint:disable-line:no-null-keyword\n    try {\n      // this is here to ensure execution order when 1) verify, 2) read data, 3) processing signatures\n      // Else it will hang trying to read a stream: https://github.com/openpgpjs/openpgpjs/issues/916#issuecomment-510620625\n      const verifications = await msg.verify(pubs); // first step\n      const stream = msg instanceof opgp.message.Message ? msg.getLiteralData() : msg.getText();\n      if (stream) { // encrypted message\n        const data = await opgp.stream.readToEnd(stream); // second step\n        verifyRes.content = data instanceof Uint8Array ? new Buf(data) : Buf.fromUtfStr(data);\n      }\n      // third step below\n      for (const verification of verifications) {\n        // todo - a valid signature is a valid signature, and should be surfaced. Currently, if any of the signatures are not valid, it's showing all as invalid\n        // .. as it is now this could allow an attacker to append bogus signatures to validly signed messages, making otherwise correct messages seem incorrect\n        // .. which is not really an issue - an attacker that can append signatures could have also just slightly changed the message, causing the same experience\n        // .. so for now #wontfix unless a reasonable usecase surfaces\n        verifyRes.match = (verifyRes.match === true || verifyRes.match === null) && await verification.verified;\n        if (!verifyRes.signer) {\n          // todo - currently only the first signer will be reported. Should we be showing all signers? How common is that?\n          verifyRes.signer = {\n            longid: OpenPGPKey.bytesToLongid(verification.keyid.bytes),\n            primaryUserId: await OpenPGPKey.getPrimaryUserId(pubs, verification.keyid)\n          };\n        }\n      }\n    } catch (verifyErr) {\n      verifyRes.match = null; // tslint:disable-line:no-null-keyword\n      if (verifyErr instanceof Error && verifyErr.message === 'Can only verify message with one literal data packet.') {\n        verifyRes.error = 'FlowCrypt is not equipped to verify this message';\n        verifyRes.isErrFatal = true; // don't try to re-fetch the message from API\n      } else if (verifyErr instanceof Error && verifyErr.message.startsWith('Insecure message hash algorithm:')) {\n        verifyRes.error = `Could not verify message: ${verifyErr.message}. Sender is using old, insecure OpenPGP software.`;\n        verifyRes.isErrFatal = true; // don't try to re-fetch the message from API\n      } else if (verifyErr instanceof Error && verifyErr.message === 'Signature is expired') {\n        verifyRes.error = verifyErr.message;\n        verifyRes.isErrFatal = true; // don't try to re-fetch the message from API\n      } else if (verifyErr instanceof Error && verifyErr.message === 'Message digest did not match') {\n        verifyRes.error = verifyErr.message;\n      } else {\n        verifyRes.error = `Error verifying this message: ${String(verifyErr)}`;\n        Catch.reportErr(verifyErr);\n      }\n    }\n    return verifyRes;\n  }\n\n  public static verifyDetached: PgpMsgMethod.VerifyDetached = async ({ plaintext, sigText }) => {\n    const message = opgp.message.fromText(Buf.fromUint8(plaintext).toUtfStr());\n    await message.appendSignature(Buf.fromUint8(sigText).toUtfStr());\n    const keys = await MsgUtil.getSortedKeys([], message);\n    return await MsgUtil.verify(message, keys.forVerification, keys.verificationContacts[0]);\n  }\n\n  public static decryptMessage: PgpMsgMethod.Decrypt = async ({ kisWithPp, encryptedData, msgPwd }) => {\n    const longids: DecryptError$longids = { message: [], matching: [], chosen: [], needPassphrase: [] };\n    let prepared: PreparedForDecrypt;\n    try {\n      prepared = await PgpArmor.cryptoMsgPrepareForDecrypt(encryptedData);\n    } catch (formatErr) {\n      return { success: false, error: { type: DecryptErrTypes.format, message: String(formatErr) }, longids };\n    }\n    const keys = await MsgUtil.getSortedKeys(kisWithPp, prepared.message);\n    longids.message = keys.encryptedFor;\n    longids.matching = keys.prvForDecrypt.map(ki => ki.longid);\n    longids.chosen = keys.prvForDecryptDecrypted.map(decrypted => decrypted.ki.longid);\n    longids.needPassphrase = keys.prvForDecryptWithoutPassphrases.map(ki => ki.longid);\n    const isEncrypted = !prepared.isCleartext;\n    if (!isEncrypted) {\n      const signature = await MsgUtil.verify(prepared.message, keys.forVerification, keys.verificationContacts[0]);\n      const content = signature.content || Buf.fromUtfStr('no content');\n      signature.content = undefined; // no need to duplicate data\n      return { success: true, content, isEncrypted, signature };\n    }\n    if (!keys.prvForDecryptDecrypted.length && !msgPwd) {\n      return { success: false, error: { type: DecryptErrTypes.needPassphrase, message: 'Missing pass phrase' }, longids, isEncrypted };\n    }\n    try {\n      const packets = (prepared.message as OpenPGP.message.Message).packets;\n      const isSymEncrypted = packets.filter(p => p.tag === opgp.enums.packet.symEncryptedSessionKey).length > 0;\n      const isPubEncrypted = packets.filter(p => p.tag === opgp.enums.packet.publicKeyEncryptedSessionKey).length > 0;\n      if (isSymEncrypted && !isPubEncrypted && !msgPwd) {\n        return { success: false, error: { type: DecryptErrTypes.usePassword, message: 'Use message password' }, longids, isEncrypted };\n      }\n      const passwords = msgPwd ? [msgPwd] : undefined;\n      const privateKeys = keys.prvForDecryptDecrypted.map(decrypted => decrypted.decrypted);\n      const decrypted = await OpenPGPKey.decryptMessage(prepared.message as OpenPGP.message.Message, privateKeys, passwords);\n      await MsgUtil.cryptoMsgGetSignedBy(decrypted, keys); // we can only figure out who signed the msg once it's decrypted\n      const signature = keys.signedBy.length ? await MsgUtil.verify(decrypted, keys.forVerification, keys.verificationContacts[0]) : undefined;\n      const content = signature?.content || new Buf(await opgp.stream.readToEnd(decrypted.getLiteralData()!));\n      if (signature?.content) {\n        signature.content = undefined; // already passed as \"content\" on the response object, don't need it duplicated\n      }\n      if (!prepared.isCleartext && (prepared.message as OpenPGP.message.Message).packets.filterByTag(opgp.enums.packet.symmetricallyEncrypted).length) {\n        const noMdc = 'Security threat!\\n\\nMessage is missing integrity checks (MDC). ' +\n          ' The sender should update their outdated software.\\n\\nDisplay the message at your own risk.';\n        return { success: false, content, error: { type: DecryptErrTypes.noMdc, message: noMdc }, longids, isEncrypted };\n      }\n      return { success: true, content, isEncrypted, filename: decrypted.getFilename() || undefined, signature };\n    } catch (e) {\n      return { success: false, error: MsgUtil.cryptoMsgDecryptCategorizeErr(e, msgPwd), longids, isEncrypted };\n    }\n  }\n\n  public static encryptMessage: PgpMsgMethod.Encrypt = async ({ pubkeys, signingPrv, pwd, data, filename, armor, date }) => {\n    const keyTypes = new Set(pubkeys.map(k => k.type));\n    if (keyTypes.has('openpgp') && keyTypes.has('x509')) {\n      throw new Error('Mixed key types are not allowed: ' + [...keyTypes]);\n    }\n    const input = { pubkeys, signingPrv, pwd, data, filename, armor, date };\n    if (keyTypes.has('x509')) {\n      return await SmimeKey.encryptMessage(input);\n    }\n    return await OpenPGPKey.encryptMessage(input);\n  }\n\n  public static diagnosePubkeys: PgpMsgMethod.DiagnosePubkeys = async ({ armoredPubs, message }) => {\n    const m = await opgp.message.readArmored(Buf.fromUint8(message).toUtfStr());\n    const msgKeyIds = m.getEncryptionKeyIds ? m.getEncryptionKeyIds() : [];\n    const localKeyIds: string[] = [];\n    for (const k of await Promise.all(armoredPubs.map(pub => KeyUtil.parse(pub)))) {\n      localKeyIds.push(...KeyUtil.getPubkeyLongids(k));\n    }\n    const diagnosis = { found_match: false, receivers: msgKeyIds.length };\n    for (const msgKeyId of msgKeyIds) {\n      for (const localKeyId of localKeyIds) {\n        if (msgKeyId.bytes === localKeyId) {\n          diagnosis.found_match = true;\n          return diagnosis;\n        }\n      }\n    }\n    return diagnosis;\n  }\n\n  private static cryptoMsgGetSignedBy = async (msg: OpenpgpMsgOrCleartext, keys: SortedKeysForDecrypt) => {\n    keys.signedBy = Value.arr.unique(msg.getSigningKeyIds ? msg.getSigningKeyIds().map(kid => OpenPGPKey.bytesToLongid(kid.bytes)) : []);\n    if (keys.signedBy.length && typeof ContactStore.get === 'function') {\n      const verificationContacts = await ContactStore.get(undefined, keys.signedBy);\n      keys.verificationContacts = verificationContacts.filter(contact => contact && contact.pubkey) as Contact[];\n      keys.forVerification = [];\n      for (const contact of keys.verificationContacts) {\n        const { keys: keysForVerification } = await opgp.key.readArmored(KeyUtil.armor(contact.pubkey!));\n        keys.forVerification.push(...keysForVerification);\n      }\n    }\n  }\n\n  private static getSortedKeys = async (kiWithPp: ExtendedKeyInfo[], msg: OpenpgpMsgOrCleartext): Promise<SortedKeysForDecrypt> => {\n    const keys: SortedKeysForDecrypt = {\n      verificationContacts: [],\n      forVerification: [],\n      encryptedFor: [],\n      signedBy: [],\n      prvMatching: [],\n      prvForDecrypt: [],\n      prvForDecryptDecrypted: [],\n      prvForDecryptWithoutPassphrases: [],\n    };\n    const encryptionKeyids = msg instanceof opgp.message.Message ? (msg as OpenPGP.message.Message).getEncryptionKeyIds() : [];\n    keys.encryptedFor = encryptionKeyids.map(kid => OpenPGPKey.bytesToLongid(kid.bytes));\n    await MsgUtil.cryptoMsgGetSignedBy(msg, keys);\n    if (keys.encryptedFor.length) {\n      keys.prvMatching = kiWithPp.filter(ki => KeyUtil.getKeyInfoLongids(ki).some(\n        longid => keys.encryptedFor.includes(longid)));\n      keys.prvForDecrypt = keys.prvMatching.length ? keys.prvMatching : kiWithPp;\n    } else { // prvs not needed for signed msgs\n      keys.prvForDecrypt = [];\n    }\n    for (const ki of keys.prvForDecrypt) {\n      const matchingKeyids = MsgUtil.matchingKeyids(KeyUtil.getKeyInfoLongids(ki), encryptionKeyids);\n      const cachedKey = KeyCache.getDecrypted(ki.longid);\n      if (cachedKey && MsgUtil.isKeyDecryptedFor(cachedKey, matchingKeyids)) {\n        keys.prvForDecryptDecrypted.push({ ki, decrypted: cachedKey });\n        continue;\n      }\n      const parsed = await KeyUtil.parse(ki.private);\n      // todo - the `ki.passphrase || ''` used to be `ki.passphrase!` which could have actually allowed an undefined to be passed\n      // as fixed currently it appears better, but it may be best to instead check `ki.passphrase && await MsgUtil.decryptKeyFor(...)`\n      // but that is a larger change that would require separate PR and testing\n      if (MsgUtil.isKeyDecryptedFor(parsed, matchingKeyids) || await MsgUtil.decryptKeyFor(parsed, ki.passphrase || '', matchingKeyids) === true) {\n        KeyCache.setDecrypted(parsed);\n        keys.prvForDecryptDecrypted.push({ ki, decrypted: parsed });\n      } else {\n        keys.prvForDecryptWithoutPassphrases.push(ki);\n      }\n    }\n    return keys;\n  }\n\n  private static matchingKeyids = (longids: string[], encryptedForKeyids: OpenPGP.Keyid[]): OpenPGP.Keyid[] => {\n    return encryptedForKeyids.filter(kid => longids.includes(OpenPGPKey.bytesToLongid(kid.bytes)));\n  }\n\n  private static decryptKeyFor = async (prv: Key, passphrase: string, matchingKeyIds: OpenPGP.Keyid[]): Promise<boolean> => {\n    if (!matchingKeyIds.length) { // we don't know which keyids match, decrypt all key packets\n      return await KeyUtil.decrypt(prv, passphrase, undefined, 'OK-IF-ALREADY-DECRYPTED');\n    }\n    for (const matchingKeyId of matchingKeyIds) { // we know which keyids match, decrypt only matching key packets\n      if (! await KeyUtil.decrypt(prv, passphrase, matchingKeyId, 'OK-IF-ALREADY-DECRYPTED')) {\n        return false; // failed to decrypt a particular needed key packet\n      }\n    }\n    return true;\n  }\n\n  private static isKeyDecryptedFor = (prv: Key, msgKeyIds: OpenPGP.Keyid[]): boolean => {\n    if (prv.fullyDecrypted) {\n      return true; // primary k + all subkeys decrypted, therefore it must be decrypted for any/every particular keyid\n    }\n    if (prv.fullyEncrypted) {\n      return false; // not decrypted at all\n    }\n    if (!msgKeyIds.length) {\n      return false; // we don't know which keyId to decrypt - must decrypt all (but key is only partially decrypted)\n    }\n    return msgKeyIds.filter(kid => OpenPGPKey.isPacketDecrypted(prv, kid)).length === msgKeyIds.length; // test if all needed key packets are decrypted\n  }\n\n  private static cryptoMsgDecryptCategorizeErr = (decryptErr: any, msgPwd?: string): DecryptError$error => {\n    const e = String(decryptErr).replace('Error: ', '').replace('Error decrypting message: ', '');\n    const keyMismatchErrStrings = ['Cannot read property \\'isDecrypted\\' of null', 'privateKeyPacket is null',\n      'TypeprivateKeyPacket is null', 'Session key decryption failed.', 'Invalid session key for decryption.'];\n    if (keyMismatchErrStrings.includes(e) && !msgPwd) {\n      return { type: DecryptErrTypes.keyMismatch, message: e };\n    } else if (msgPwd && ['Invalid enum value.', 'CFB decrypt: invalid key', 'Session key decryption failed.'].includes(e)) {\n      return { type: DecryptErrTypes.wrongPwd, message: e };\n    } else if (e === 'Decryption failed due to missing MDC in combination with modern cipher.' || e === 'Decryption failed due to missing MDC.') {\n      return { type: DecryptErrTypes.noMdc, message: e };\n    } else if (e === 'Decryption error') {\n      return { type: DecryptErrTypes.format, message: e };\n    } else if (e === 'Modification detected.') {\n      return { type: DecryptErrTypes.badMdc, message: `Security threat - opening this message is dangerous because it was modified in transit.` };\n    } else {\n      return { type: DecryptErrTypes.other, message: e };\n    }\n  }\n\n}\n",
    "extension/js/common/core/crypto/pgp/openpgp-key.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\nimport { Key, PrvPacket, KeyAlgo, KeyUtil, UnexpectedKeyTypeError } from '../key.js';\nimport { opgp } from './openpgpjs-custom.js';\nimport { Catch } from '../../../platform/catch.js';\nimport { Str } from '../../common.js';\nimport { PgpHash } from './pgp-hash.js';\nimport { Buf } from '../../buf.js';\nimport { PgpMsgMethod, MsgUtil } from './msg-util.js';\n\nconst internal = Symbol('internal openpgpjs library format key');\n\nexport class OpenPGPKey {\n\n  private static readonly encryptionText = 'This is the text we are encrypting!';\n\n  // mapping of algo names to required param count, lazy initialized\n  private static paramCountByAlgo: { [key: string]: number };\n\n  // mapping of algo names to required bits, lazy initialized\n  private static minimumBitsByAlgo: { [key: string]: number };\n\n  public static parse = async (text: string): Promise<Key> => {\n    // TODO: Should we throw if more keys are in the armor?\n    return (await OpenPGPKey.parseMany(text))[0];\n  }\n\n  public static parseMany = async (text: string): Promise<Key[]> => {\n    const result = await opgp.key.readArmored(text);\n    if (result.err) {\n      throw new Error('Cannot parse OpenPGP key: ' + result.err + ' for: ' + text);\n    }\n    const keys = [];\n    for (const key of result.keys) {\n      keys.push(await OpenPGPKey.convertExternalLibraryObjToKey(key));\n    }\n    return keys;\n  }\n\n  public static asPublicKey = async (pubkey: Key): Promise<Key> => {\n    if (pubkey.type !== 'openpgp') {\n      throw new UnexpectedKeyTypeError(`Key type is ${pubkey.type}, expecting OpenPGP`);\n    }\n    if (pubkey.isPrivate) {\n      return await OpenPGPKey.convertExternalLibraryObjToKey(OpenPGPKey.extractStrengthUncheckedExternalLibraryObjFromKey(pubkey).toPublic());\n    }\n    return pubkey;\n  }\n\n  public static decryptKey = async (key: Key, passphrase: string, optionalKeyid?: OpenPGP.Keyid, optionalBehaviorFlag?: 'OK-IF-ALREADY-DECRYPTED'): Promise<boolean> => {\n    const prv = OpenPGPKey.extractExternalLibraryObjFromKey(key);\n    if (!prv.isPrivate()) {\n      throw new Error(\"Nothing to decrypt in a public key\");\n    }\n    const chosenPrvPackets = prv.getKeys(optionalKeyid).map(k => k.keyPacket).filter(OpenPGPKey.isPacketPrivate) as PrvPacket[];\n    if (!chosenPrvPackets.length) {\n      throw new Error(`No private key packets selected of ${prv.getKeys().map(k => k.keyPacket).filter(OpenPGPKey.isPacketPrivate).length} prv packets available`);\n    }\n    for (const prvPacket of chosenPrvPackets) {\n      if (prvPacket.isDecrypted()) {\n        if (optionalBehaviorFlag === 'OK-IF-ALREADY-DECRYPTED') {\n          continue;\n        } else {\n          throw new Error(\"Decryption failed - key packet was already decrypted\");\n        }\n      }\n      try {\n        await prvPacket.decrypt(passphrase); // throws on password mismatch\n      } catch (e) {\n        if (e instanceof Error && e.message.toLowerCase().includes('incorrect key passphrase')) {\n          return false;\n        }\n        throw e;\n      }\n    }\n    await OpenPGPKey.convertExternalLibraryObjToKey(prv, key);\n    return true;\n  }\n\n  public static encryptKey = async (key: Key, passphrase: string) => {\n    const prv = OpenPGPKey.extractExternalLibraryObjFromKey(key);\n    if (!passphrase || passphrase === 'undefined' || passphrase === 'null') {\n      throw new Error(`Encryption passphrase should not be empty:${typeof passphrase}:${passphrase}`);\n    }\n    const secretPackets = prv.getKeys().map(k => k.keyPacket).filter(OpenPGPKey.isPacketPrivate);\n    const encryptedPacketCount = secretPackets.filter(p => !p.isDecrypted()).length;\n    if (!secretPackets.length) {\n      throw new Error(`No private key packets in key to encrypt. Is this a private key?`);\n    }\n    if (encryptedPacketCount) {\n      throw new Error(`Cannot encrypt a key that has ${encryptedPacketCount} of ${secretPackets.length} private packets still encrypted`);\n    }\n    await prv.encrypt(passphrase);\n    if (!prv.isFullyEncrypted()) {\n      throw new Error('Expected key to be fully encrypted after prv.encrypt');\n    }\n    await OpenPGPKey.convertExternalLibraryObjToKey(prv, key);\n  }\n\n  public static decryptMessage = async (message: OpenPGP.message.Message, privateKeys: Key[], passwords?: string[]) => {\n    return await message.decrypt(privateKeys.map(key => OpenPGPKey.extractExternalLibraryObjFromKey(key)), passwords, undefined, false);\n  }\n\n  public static encryptMessage: PgpMsgMethod.Encrypt = async ({ pubkeys, signingPrv, pwd, data, filename, armor, date }) => {\n    const message = opgp.message.fromBinary(data, filename, date);\n    const options: OpenPGP.EncryptOptions = { armor, message, date };\n    let usedChallenge = false;\n    if (pubkeys) {\n      options.publicKeys = [];\n      for (const pubkey of pubkeys) {\n        const { keys: publicKeys } = await opgp.key.readArmored(KeyUtil.armor(pubkey));\n        options.publicKeys.push(...publicKeys);\n        // TODO: Investigate why unwrapping doesn't work - probably the object\n        // came from the background page so it wasn't properly deserialized\n        // options.publicKeys.push(OpenPGPKey.unwrap(pubkey));\n      }\n    }\n    if (pwd) {\n      options.passwords = [await PgpHash.challengeAnswer(pwd)];\n      usedChallenge = true;\n    }\n    if (!pubkeys && !usedChallenge) {\n      throw new Error('no-pubkeys-no-challenge');\n    }\n    if (signingPrv) {\n      const openPgpPrv = OpenPGPKey.extractExternalLibraryObjFromKey(signingPrv);\n      if (typeof openPgpPrv.isPrivate !== 'undefined' && openPgpPrv.isPrivate()) { // tslint:disable-line:no-unbound-method - only testing if exists\n        options.privateKeys = [openPgpPrv];\n      }\n    }\n    const result = await opgp.encrypt(options);\n    if (typeof result.data === 'string') {\n      return { data: Buf.fromUtfStr(result.data), signature: result.signature, type: 'openpgp' };\n    } else {\n      return result as unknown as OpenPGP.EncryptBinaryResult;\n    }\n  }\n\n  public static isWithoutSelfCertifications = async (key: Key) => {\n    const opgpPrv = OpenPGPKey.extractExternalLibraryObjFromKey(key);\n    return await Catch.doesReject(opgpPrv.verifyPrimaryKey(), ['No self-certifications']);\n  }\n\n  public static reformatKey = async (privateKey: Key, passphrase: string, userIds: { email: string | undefined; name: string }[], expireSeconds: number) => {\n    const opgpPrv = OpenPGPKey.extractExternalLibraryObjFromKey(privateKey);\n    const keyPair = await opgp.reformatKey({ privateKey: opgpPrv, passphrase, userIds, keyExpirationTime: expireSeconds });\n    return await OpenPGPKey.convertExternalLibraryObjToKey(keyPair.key);\n  }\n\n  /**\n   * TODO: should be private, will change when readMany is rewritten\n   * @param opgpKey - original OpenPGP.js key\n   * @param keyToUpdate - an existing Key object to update, optional. Useful in encryptKey and decryptKey, because the operation\n   *    is done on the original supplied object.\n   */\n  public static convertExternalLibraryObjToKey = async (opgpKey: OpenPGP.key.Key, keyToUpdate?: Key): Promise<Key> => {\n    const { isPrimaryKeyStrong, keyWithoutWeakPackets } = OpenPGPKey.removeWeakKeyPackets(opgpKey);\n    let exp: null | Date | number;\n    try {\n      exp = await keyWithoutWeakPackets.getExpirationTime('encrypt');\n    } catch (e) {\n      // tslint:disable-next-line: no-null-keyword\n      exp = null;\n    }\n    const expired = () => {\n      if (exp === Infinity || !exp) {\n        return false;\n      }\n      // According to the documentation expiration is either undefined, Infinity\n      // (typeof number) or a Date object. So in this case `exp` should never\n      // be of type number.\n      if (typeof exp === 'number') {\n        throw new Error(`Got unexpected value for expiration: ${exp}`);\n      }\n      return Date.now() > exp.getTime();\n    };\n    const emails = keyWithoutWeakPackets.users\n      .map(user => user.userId)\n      .filter(userId => userId !== null)\n      .map((userId: OpenPGP.packet.Userid) => {\n        try {\n          return opgp.util.parseUserId(userId.userid).email || '';\n        } catch (e) {\n          // ignore bad user IDs\n        }\n        return '';\n      })\n      .map(email => email.trim())\n      .filter(email => email)\n      .map(email => email.toLowerCase());\n    let lastModified: undefined | number;\n    try {\n      lastModified = await OpenPGPKey.getLastSigTime(keyWithoutWeakPackets);\n    } catch (e) {\n      // never had any valid signature\n    }\n    const fingerprint = keyWithoutWeakPackets.getFingerprint();\n    if (!fingerprint) {\n      throw new Error('Key does not have a fingerprint and cannot be parsed.');\n    }\n    const algoInfo = keyWithoutWeakPackets.primaryKey.getAlgorithmInfo();\n    const key = keyToUpdate || {} as Key; // if no key to update, use empty object, will get props assigned below\n    // tslint:disable-next-line:no-unnecessary-initializer\n    const { encryptionKey = undefined, encryptionKeyIgnoringExpiration = undefined, signingKey = undefined, signingKeyIgnoringExpiration = undefined }\n      = isPrimaryKeyStrong ? await OpenPGPKey.getSigningAndEncryptionKeys(keyWithoutWeakPackets, exp, expired) : {};\n    const missingPrivateKeyForSigning = signingKeyIgnoringExpiration?.keyPacket ? OpenPGPKey.arePrivateParamsMissing(signingKeyIgnoringExpiration.keyPacket) : false;\n    const missingPrivateKeyForDecryption = encryptionKeyIgnoringExpiration?.keyPacket ? OpenPGPKey.arePrivateParamsMissing(encryptionKeyIgnoringExpiration.keyPacket) : false;\n    Object.assign(key, {\n      type: 'openpgp',\n      id: fingerprint.toUpperCase(),\n      allIds: keyWithoutWeakPackets.getKeys().map(k => k.getFingerprint().toUpperCase()),\n      usableForEncryption: encryptionKey ? true : false,\n      usableForEncryptionButExpired: !encryptionKey && !!encryptionKeyIgnoringExpiration,\n      usableForSigning: signingKey ? true : false,\n      usableForSigningButExpired: !signingKey && !!signingKeyIgnoringExpiration,\n      missingPrivateKeyForSigning,\n      missingPrivateKeyForDecryption,\n      // valid emails extracted from uids\n      emails,\n      // full uids that have valid emails in them\n      // tslint:disable-next-line: no-unsafe-any\n      identities: keyWithoutWeakPackets.users.map(u => u.userId).filter(u => !!u && u.userid && Str.parseEmail(u.userid).email).map(u => u!.userid).filter(Boolean) as string[],\n      lastModified,\n      expiration: exp instanceof Date ? exp.getTime() : undefined,\n      created: keyWithoutWeakPackets.getCreationTime().getTime(),\n      fullyDecrypted: keyWithoutWeakPackets.isPublic() ? true /* public keys are always decrypted */ : keyWithoutWeakPackets.isFullyDecrypted(),\n      fullyEncrypted: keyWithoutWeakPackets.isPublic() ? false /* public keys are never encrypted */ : keyWithoutWeakPackets.isFullyEncrypted(),\n      isPublic: keyWithoutWeakPackets.isPublic(),\n      isPrivate: keyWithoutWeakPackets.isPrivate(),\n      algo: {\n        algorithm: algoInfo.algorithm,\n        bits: algoInfo.bits,\n        curve: (algoInfo as any).curve as string | undefined,\n        algorithmId: opgp.enums.publicKey[algoInfo.algorithm]\n      },\n      revoked: keyWithoutWeakPackets.revocationSignatures.length > 0\n    } as Key);\n    (key as any)[internal] = keyWithoutWeakPackets;\n    (key as any).rawKey = opgpKey;\n    (key as any).rawArmored = opgpKey.armor();\n    return key;\n  }\n\n  /**\n   * Returns signed data if detached=false, armored\n   * Returns signature if detached=true, armored\n   */\n  public static sign = async (signingPrivate: Key, data: string, detached = false): Promise<string> => {\n    const signingPrv = OpenPGPKey.extractExternalLibraryObjFromKey(signingPrivate);\n    const message = opgp.cleartext.fromText(data);\n    const signRes = await opgp.sign({ message, armor: true, privateKeys: [signingPrv], detached });\n    if (detached) {\n      if (typeof signRes.signature !== 'string') {\n        throw new Error('signRes.signature unexpectedly not a string when creating detached signature');\n      }\n      return signRes.signature;\n    }\n    return await opgp.stream.readToEnd((signRes as OpenPGP.SignArmorResult).data);\n  }\n\n  public static revoke = async (key: Key): Promise<string | undefined> => {\n    let prv = OpenPGPKey.extractExternalLibraryObjFromKey(key);\n    if (! await prv.isRevoked()) {\n      prv = await prv.revoke({});\n    }\n    const certificate = await prv.getRevocationCertificate();\n    if (!certificate) {\n      return undefined;\n    } else if (typeof certificate === 'string') {\n      return certificate;\n    } else {\n      return await opgp.stream.readToEnd(certificate);\n    }\n  }\n\n  public static keyFlagsToString = (flags: OpenPGP.enums.keyFlags): string => {\n    const strs: string[] = [];\n    if (flags & opgp.enums.keyFlags.encrypt_communication) {\n      strs.push('encrypt_communication');\n    }\n    if (flags & opgp.enums.keyFlags.encrypt_storage) {\n      strs.push('encrypt_storage');\n    }\n    if (flags & opgp.enums.keyFlags.sign_data) {\n      strs.push('sign_data');\n    }\n    if (flags & opgp.enums.keyFlags.certify_keys) {\n      strs.push('certify_keys');\n    }\n    return '[' + strs.join(', ') + ']';\n  }\n\n  public static diagnose = async (pubkey: Key, passphrase: string): Promise<Map<string, string>> => {\n    const key = OpenPGPKey.extractExternalLibraryObjFromKey(pubkey);\n    const result = new Map<string, string>();\n    if (!key.isPrivate() && !key.isPublic()) {\n      result.set(`key is neither public or private!!`, '');\n      return result;\n    }\n    result.set(`Is Private?`, KeyUtil.formatResult(key.isPrivate()));\n    for (let i = 0; i < key.users.length; i++) {\n      result.set(`User id ${i}`, key.users[i].userId!.userid);\n    }\n    const user = await key.getPrimaryUser();\n    result.set(`Primary User`, user?.user?.userId?.userid || 'No primary user');\n    result.set(`Fingerprint`, Str.spaced(key.getFingerprint().toUpperCase() || 'err'));\n    // take subkeys from original key so we show subkeys disabled by #2715 too\n    const subKeys = OpenPGPKey.extractStrengthUncheckedExternalLibraryObjFromKey(pubkey)?.subKeys ?? key.subKeys;\n    result.set(`Subkeys`, KeyUtil.formatResult(subKeys ? subKeys.length : subKeys));\n    result.set(`Primary key algo`, KeyUtil.formatResult(key.primaryKey.algorithm));\n    const flags = await OpenPGPKey.getPrimaryKeyFlags(key);\n    result.set(`Usage flags`, KeyUtil.formatResult(OpenPGPKey.keyFlagsToString(flags)));\n    if (key.isPrivate() && !key.isFullyDecrypted()) {\n      result.set(`key decrypt`, await KeyUtil.formatResultAsync(async () => {\n        try {\n          await key.decrypt(passphrase); // throws on password mismatch\n          return true;\n        } catch (e) {\n          if (e instanceof Error && e.message.toLowerCase().includes('incorrect key passphrase')) {\n            return false;\n          } else {\n            throw e;\n          }\n        }\n      }));\n      result.set(`isFullyDecrypted`, KeyUtil.formatResult(key.isFullyDecrypted()));\n      result.set(`isFullyEncrypted`, KeyUtil.formatResult(key.isFullyEncrypted()));\n    }\n    result.set(`Primary key verify`, await KeyUtil.formatResultAsync(async () => {\n      await key.verifyPrimaryKey(); // throws\n      return `valid`;\n    }));\n    result.set(`Primary key creation?`, await KeyUtil.formatResultAsync(async () => OpenPGPKey.formatDate(await key.getCreationTime())));\n    result.set(`Primary key expiration?`, await KeyUtil.formatResultAsync(async () => OpenPGPKey.formatDate(await key.getExpirationTime())));\n    const encryptResult = await OpenPGPKey.testEncryptDecrypt(key);\n    await Promise.all(encryptResult.map(msg => result.set(`Encrypt/Decrypt test: ${msg}`, '')));\n    if (key.isPrivate()) {\n      result.set(`Sign/Verify test`, await KeyUtil.formatResultAsync(async () => await OpenPGPKey.testSignVerify(key)));\n    }\n    for (let subKeyIndex = 0; subKeyIndex < subKeys.length; subKeyIndex++) {\n      const subKey = subKeys[subKeyIndex];\n      const skn = `SK ${subKeyIndex} >`;\n      result.set(`${skn} LongId`, await KeyUtil.formatResultAsync(async () => OpenPGPKey.bytesToLongid(subKey.getKeyId().bytes)));\n      result.set(`${skn} Created`, await KeyUtil.formatResultAsync(async () => OpenPGPKey.formatDate(subKey.keyPacket.created)));\n      result.set(`${skn} Algo`, await KeyUtil.formatResultAsync(async () => `${subKey.getAlgorithmInfo().algorithm}`));\n      const flags = await OpenPGPKey.getSubKeySigningFlags(key, subKey) | await OpenPGPKey.getSubKeyEncryptionFlags(key, subKey);\n      result.set(`${skn} Usage flags`, KeyUtil.formatResult(OpenPGPKey.keyFlagsToString(flags)));\n      result.set(`${skn} Verify`, await KeyUtil.formatResultAsync(async () => {\n        await subKey.verify(key.primaryKey);\n        return 'OK';\n      }));\n      result.set(`${skn} Subkey tag`, await KeyUtil.formatResultAsync(async () => subKey.keyPacket.tag));\n      result.set(`${skn} Subkey getBitSize`, await KeyUtil.formatResultAsync(async () => subKey.getAlgorithmInfo().bits)); // No longer exists on object\n      result.set(`${skn} Subkey decrypted`, KeyUtil.formatResult(subKey.isDecrypted()));\n      result.set(`${skn} Binding signature length`, await KeyUtil.formatResultAsync(async () => subKey.bindingSignatures.length));\n      for (let sigIndex = 0; sigIndex < subKey.bindingSignatures.length; sigIndex++) {\n        const sig = subKey.bindingSignatures[sigIndex];\n        const sgn = `${skn} SIG ${sigIndex} >`;\n        result.set(`${sgn} Key flags`, await KeyUtil.formatResultAsync(async () => sig.keyFlags));\n        result.set(`${sgn} Tag`, await KeyUtil.formatResultAsync(async () => sig.tag));\n        result.set(`${sgn} Version`, await KeyUtil.formatResultAsync(async () => sig.version));\n        result.set(`${sgn} Public key algorithm`, await KeyUtil.formatResultAsync(async () => sig.publicKeyAlgorithm));\n        result.set(`${sgn} Sig creation time`, KeyUtil.formatResult(OpenPGPKey.formatDate(sig.created)));\n        result.set(`${sgn} Sig expiration time`, await KeyUtil.formatResultAsync(async () => {\n          if (!subKey.keyPacket.created) {\n            return 'unknown key creation time';\n          }\n          return OpenPGPKey.formatDate(subKey.keyPacket.created, sig.keyExpirationTime);\n        }));\n        result.set(`${sgn} Verified`, KeyUtil.formatResult(sig.verified));\n      }\n    }\n    return result;\n  }\n\n  public static bytesToLongid = (binaryString: string) => {\n    if (binaryString.length !== 8) {\n      throw new Error(`Unexpected keyid bytes format (len: ${binaryString.length}): \"${binaryString}\"`);\n    }\n    return opgp.util.str_to_hex(binaryString).toUpperCase();\n  }\n\n  public static fingerprintToLongid = (fingerprint: string) => {\n    if (fingerprint.length === 40) { // pgp keys\n      return fingerprint.substr(-16).toUpperCase();\n    }\n    throw new Error(`Unexpected fingerprint format (len: ${fingerprint.length}): \"${fingerprint}\"`);\n  }\n\n  /**\n   * todo - could return a Key\n   */\n  public static create = async (\n    userIds: { name: string, email: string }[], variant: KeyAlgo, passphrase: string, expireInMonths: number | undefined\n  ): Promise<{ private: string, public: string }> => {\n    const opt: OpenPGP.KeyOptions = { userIds, passphrase };\n    if (variant === 'curve25519') {\n      opt.curve = 'curve25519';\n    } else if (variant === 'rsa2048') {\n      opt.numBits = 2048;\n    } else {\n      opt.numBits = 4096;\n    }\n    if (expireInMonths) {\n      opt.keyExpirationTime = 60 * 60 * 24 * 30 * expireInMonths; // seconds from now\n    }\n    const k = await opgp.generateKey(opt);\n    return { public: k.publicKeyArmored, private: k.privateKeyArmored };\n  }\n\n  public static isPacketPrivate = (p: OpenPGP.packet.AnyKeyPacket): p is PrvPacket => {\n    return p.tag === opgp.enums.packet.secretKey || p.tag === opgp.enums.packet.secretSubkey;\n  }\n\n  public static isBaseKeyPacket = (p: OpenPGP.packet.BasePacket): p is OpenPGP.packet.BaseKeyPacket => {\n    return [opgp.enums.packet.secretKey, opgp.enums.packet.secretSubkey, opgp.enums.packet.publicKey, opgp.enums.packet.publicSubkey]\n      .includes(p.tag);\n  }\n\n  public static isPacketDecrypted = (pubkey: Key, keyid: OpenPGP.Keyid) => {\n    return OpenPGPKey.extractExternalLibraryObjFromKey(pubkey).isPacketDecrypted(keyid);\n  }\n\n  public static getPrimaryUserId = async (pubs: OpenPGP.key.Key[], keyid: OpenPGP.Keyid): Promise<string | undefined> => {\n    for (const opgpkey of pubs) {\n      const matchingKeys = await opgpkey.getKeys(keyid);\n      if (matchingKeys.length > 0) {\n        const primaryUser = await opgpkey.getPrimaryUser();\n        return primaryUser?.user?.userId?.userid;\n      }\n    }\n    return undefined;\n  }\n\n  // mimicks OpenPGP.helper.getLatestValidSignature\n  private static getLatestValidSignature = async (signatures: OpenPGP.packet.Signature[],\n    primaryKey: OpenPGP.packet.PublicKey | OpenPGP.packet.SecretKey,\n    signatureType: OpenPGP.enums.signature,\n    dataToVerify: any,\n    date = new Date()):\n    Promise<OpenPGP.packet.Signature | undefined> => {\n    let signature: OpenPGP.packet.Signature | undefined;\n    for (let i = signatures.length - 1; i >= 0; i--) {\n      try {\n        if (\n          (!signature || signatures[i].created >= signature.created) &&\n          // check binding signature is not expired (ie, check for V4 expiration time)\n          !signatures[i].isExpired(date) &&\n          // check binding signature is verified\n          (signatures[i].verified || await signatures[i].verify(primaryKey, signatureType, dataToVerify))\n        ) {\n          signature = signatures[i];\n        }\n      } catch (e) {\n        // skip signature with failed verification\n      }\n    }\n    return signature;\n  }\n\n  private static getValidEncryptionKeyPacketFlags = (keyPacket: OpenPGP.packet.PublicKey | OpenPGP.packet.SecretKey, signature: OpenPGP.packet.Signature): OpenPGP.enums.keyFlags => {\n    if (!signature.keyFlags || !signature.verified || signature.revoked !== false) { // Sanity check\n      return 0;\n    }\n    if ([\n      opgp.enums.publicKey.dsa,\n      opgp.enums.publicKey.rsa_sign,\n      opgp.enums.publicKey.ecdsa,\n      opgp.enums.publicKey.eddsa].includes(keyPacket.algorithm)) {\n      return 0; // disallow encryption for these algorithms\n    }\n    return signature.keyFlags[0] & (opgp.enums.keyFlags.encrypt_communication | opgp.enums.keyFlags.encrypt_storage);\n  }\n\n  private static getValidSigningKeyPacketFlags = (keyPacket: OpenPGP.packet.PublicKey | OpenPGP.packet.SecretKey,\n    signature: OpenPGP.packet.Signature): OpenPGP.enums.keyFlags => {\n    if (!signature.keyFlags || !signature.verified || signature.revoked !== false) { // Sanity check\n      return 0;\n    }\n    if ([\n      opgp.enums.publicKey.rsa_encrypt,\n      opgp.enums.publicKey.elgamal,\n      opgp.enums.publicKey.ecdh].includes(keyPacket.algorithm)) {\n      return 0; // disallow signing for these algorithms\n    }\n    return signature.keyFlags[0] & (opgp.enums.keyFlags.sign_data | opgp.enums.keyFlags.certify_keys);\n  }\n\n  private static getSubKeySigningFlags = async (key: OpenPGP.key.Key, subKey: OpenPGP.key.SubKey): Promise<OpenPGP.enums.keyFlags> => {\n    const primaryKey = key.keyPacket;\n    // await subKey.verify(primaryKey);\n    const dataToVerify = { key: primaryKey, bind: subKey.keyPacket };\n    const date = new Date();\n    const bindingSignature = await OpenPGPKey.getLatestValidSignature(subKey.bindingSignatures, primaryKey,\n      opgp.enums.signature.subkey_binding,\n      dataToVerify, date);\n    if (\n      bindingSignature &&\n      bindingSignature.embeddedSignature &&\n      await OpenPGPKey.getLatestValidSignature([bindingSignature.embeddedSignature], subKey.keyPacket, opgp.enums.signature.key_binding, dataToVerify, date)\n    ) {\n      return OpenPGPKey.getValidSigningKeyPacketFlags(subKey.keyPacket, bindingSignature);\n    }\n    return 0;\n  }\n\n  private static getSubKeyEncryptionFlags = async (key: OpenPGP.key.Key, subKey: OpenPGP.key.SubKey): Promise<OpenPGP.enums.keyFlags> => {\n    const primaryKey = key.keyPacket;\n    // await subKey.verify(primaryKey);\n    const dataToVerify = { key: primaryKey, bind: subKey.keyPacket };\n    const date = new Date();\n    const bindingSignature = await OpenPGPKey.getLatestValidSignature(subKey.bindingSignatures, primaryKey,\n      opgp.enums.signature.subkey_binding,\n      dataToVerify, date);\n    if (bindingSignature) {\n      return OpenPGPKey.getValidEncryptionKeyPacketFlags(subKey.keyPacket, bindingSignature);\n    }\n    return 0;\n  }\n\n  private static getPrimaryKeyFlags = async (key: OpenPGP.key.Key): Promise<OpenPGP.enums.keyFlags> => {\n    const primaryUser = await key.getPrimaryUser();\n    return OpenPGPKey.getValidEncryptionKeyPacketFlags(key.keyPacket, primaryUser.selfCertification)\n      | OpenPGPKey.getValidSigningKeyPacketFlags(key.keyPacket, primaryUser.selfCertification);\n  }\n\n  /**\n   * Get latest self-signature date, in utc millis.\n   * This is used to figure out how recently was key updated, and if one key is newer than other.\n   */\n  private static getLastSigTime = async (key: OpenPGP.key.Key): Promise<number> => {\n    await key.getExpirationTime(); // will force all sigs to be verified\n    const allSignatures: OpenPGP.packet.Signature[] = [];\n    for (const user of key.users) {\n      allSignatures.push(...user.selfCertifications);\n    }\n    for (const subKey of key.subKeys) {\n      allSignatures.push(...subKey.bindingSignatures);\n    }\n    allSignatures.sort((a, b) => b.created.getTime() - a.created.getTime());\n    const newestSig = allSignatures.find(sig => sig.verified === true);\n    if (newestSig) {\n      return newestSig.created.getTime();\n    }\n    throw new Error('No valid signature found in key');\n  }\n\n  private static extractExternalLibraryObjFromKey = (pubkey: Key) => {\n    if (pubkey.type !== 'openpgp') {\n      throw new UnexpectedKeyTypeError(`Key type is ${pubkey.type}, expecting OpenPGP`);\n    }\n    const opgpKey = (pubkey as unknown as { [internal]: OpenPGP.key.Key })[internal];\n    if (!opgpKey) {\n      throw new Error('Object has type == \"openpgp\" but no internal key.');\n    }\n    return opgpKey;\n  }\n\n  private static extractStrengthUncheckedExternalLibraryObjFromKey = (pubkey: Key) => {\n    if (pubkey.type !== 'openpgp') {\n      throw new UnexpectedKeyTypeError(`Key type is ${pubkey.type}, expecting OpenPGP`);\n    }\n    const raw = (pubkey as unknown as { rawKey: OpenPGP.key.Key });\n    return raw?.rawKey;\n  }\n\n  private static getKeyIgnoringExpiration = async (\n    getter: (keyid?: OpenPGP.Keyid | null, date?: Date, userId?: OpenPGP.UserId | null) => Promise<OpenPGP.key.Key | OpenPGP.key.SubKey | null>,\n    exp: Date | number | null,\n    expired: () => boolean): Promise<OpenPGP.key.Key | OpenPGP.key.SubKey | null> => {\n    const firstTry = await Catch.undefinedOnException(getter());\n    if (firstTry) {\n      return firstTry;\n    }\n    if (exp === null || typeof exp === 'number') {\n      // If key does not expire (exp == Infinity) the encryption key should be available.\n      return null; // tslint:disable-line:no-null-keyword\n    }\n    const oneSecondBeforeExpiration = exp && expired() ? new Date(exp.getTime() - 1000) : undefined;\n    if (typeof oneSecondBeforeExpiration === 'undefined') {\n      return null; // tslint:disable-line:no-null-keyword\n    }\n    const secondTry = await Catch.undefinedOnException(getter(undefined, oneSecondBeforeExpiration));\n    return secondTry ? secondTry : null; // tslint:disable-line:no-null-keyword\n  }\n\n  private static getSigningAndEncryptionKeys = async (key: OpenPGP.key.Key, exp: number | Date | null, expired: () => boolean) => {\n    const getEncryptionKey = (keyid?: OpenPGP.Keyid | null, date?: Date, userId?: OpenPGP.UserId | null) =>\n      key.getEncryptionKey(keyid, date, userId);\n    const encryptionKey = await Catch.undefinedOnException(getEncryptionKey());\n    const encryptionKeyIgnoringExpiration = encryptionKey ? encryptionKey : await OpenPGPKey.getKeyIgnoringExpiration(getEncryptionKey, exp, expired);\n    const getSigningKey = (keyid?: OpenPGP.Keyid | null, date?: Date, userId?: OpenPGP.UserId | null) =>\n      key.getSigningKey(keyid, date, userId);\n    const signingKey = await Catch.undefinedOnException(getSigningKey());\n    const signingKeyIgnoringExpiration = signingKey ? signingKey : await OpenPGPKey.getKeyIgnoringExpiration(getSigningKey, exp, expired);\n    return { encryptionKey, encryptionKeyIgnoringExpiration, signingKey, signingKeyIgnoringExpiration };\n  }\n\n  /**\n  * In order to prioritize strong subkeys over weak ones to solve #2715, we delete the weak ones\n  * and let OpenPGP.js decide based on remaining packets\n  * @param opgpKey - original OpenPGP.js key\n  * @return isPrimaryKeyStrong - true, if primary key is safe to use\n  *         keyWithoutWeakPackets - key with weak subkets removed\n  */\n  private static removeWeakKeyPackets = (opgpKey: OpenPGP.key.Key): { isPrimaryKeyStrong: boolean, keyWithoutWeakPackets: OpenPGP.key.Key } => {\n    let isPrimaryKeyStrong = true;\n    const packets = opgpKey.toPacketlist();\n    const newPacketList = new opgp.packet.List<OpenPGP.packet.BasePacket>();\n    for (const packet of packets) {\n      if (OpenPGPKey.isBaseKeyPacket(packet)) {\n        const { algorithm, bits } = packet.getAlgorithmInfo();\n        if (!OpenPGPKey.minimumBitsByAlgo) {\n          OpenPGPKey.minimumBitsByAlgo = {\n            [opgp.enums.read(opgp.enums.publicKey, opgp.enums.publicKey.rsa_encrypt)]: 2048,\n            [opgp.enums.read(opgp.enums.publicKey, opgp.enums.publicKey.rsa_encrypt_sign)]: 2048,\n            [opgp.enums.read(opgp.enums.publicKey, opgp.enums.publicKey.rsa_sign)]: 2048,\n          };\n        }\n        const minimumBits = OpenPGPKey.minimumBitsByAlgo[algorithm];\n        if (minimumBits && bits < minimumBits) {\n          if (packet === opgpKey.primaryKey) {\n            // the primary key packet should remain, otherwise the key can't be parsed\n            isPrimaryKeyStrong = false;\n          } else {\n            continue; // discard this packet as weak\n          }\n        }\n      }\n      newPacketList.push(packet);\n    }\n    if (packets.length !== newPacketList.length) {\n      return { isPrimaryKeyStrong, keyWithoutWeakPackets: new opgp.key.Key(newPacketList) };\n    }\n    return { isPrimaryKeyStrong, keyWithoutWeakPackets: opgpKey };\n  }\n\n  private static arePrivateParamsMissing = (packet: OpenPGP.packet.BaseKeyPacket): boolean => {\n    // detection of missing private params to solve #2887\n    if (!OpenPGPKey.paramCountByAlgo) {\n      OpenPGPKey.paramCountByAlgo = {\n        [opgp.enums.read(opgp.enums.publicKey, opgp.enums.publicKey.rsa_encrypt)]: 6,\n        [opgp.enums.read(opgp.enums.publicKey, opgp.enums.publicKey.rsa_encrypt_sign)]: 6,\n        [opgp.enums.read(opgp.enums.publicKey, opgp.enums.publicKey.rsa_sign)]: 6,\n        [opgp.enums.read(opgp.enums.publicKey, opgp.enums.publicKey.dsa)]: 5,\n        [opgp.enums.read(opgp.enums.publicKey, opgp.enums.publicKey.elgamal)]: 4,\n        [opgp.enums.read(opgp.enums.publicKey, opgp.enums.publicKey.ecdsa)]: 2,\n        [opgp.enums.read(opgp.enums.publicKey, opgp.enums.publicKey.ecdh)]: 3,\n        [opgp.enums.read(opgp.enums.publicKey, opgp.enums.publicKey.eddsa)]: 3,\n      };\n    }\n    return packet.algorithm\n      && !packet.isEncrypted // isDecrypted() returns false when isEncrypted is null\n      && OpenPGPKey.paramCountByAlgo[packet.algorithm] > packet.params?.length;\n  }\n\n  private static testEncryptDecrypt = async (key: OpenPGP.key.Key): Promise<string[]> => {\n    const output: string[] = [];\n    try {\n      const encryptedMsg = await opgp.encrypt({ message: opgp.message.fromText(OpenPGPKey.encryptionText), publicKeys: key.toPublic(), armor: true });\n      output.push(`Encryption with key was successful`);\n      if (key.isPrivate() && key.isFullyDecrypted()) {\n        const decryptedMsg = await opgp.decrypt({ message: await opgp.message.readArmored(encryptedMsg.data), privateKeys: key });\n        output.push(`Decryption with key ${decryptedMsg.data === OpenPGPKey.encryptionText ? 'succeeded' : 'failed!'}`);\n      } else {\n        output.push(`Skipping decryption because isPrivate:${key.isPrivate()} isFullyDecrypted:${key.isFullyDecrypted()}`);\n      }\n    } catch (err) {\n      output.push(`Got error performing encryption/decryption test: ${err}`);\n    }\n    return output;\n  }\n\n  private static testSignVerify = async (key: OpenPGP.key.Key): Promise<string> => {\n    const output: string[] = [];\n    try {\n      if (!key.isFullyDecrypted()) {\n        return 'skipped, not fully decrypted';\n      }\n      const signedMessage = await opgp.message.fromText(OpenPGPKey.encryptionText).sign([key]);\n      output.push('sign msg ok');\n      const verifyResult = await MsgUtil.verify(signedMessage, [key]);\n      if (verifyResult.error !== null && typeof verifyResult.error !== 'undefined') {\n        output.push(`verify failed: ${verifyResult.error}`);\n      } else {\n        if (verifyResult.match && verifyResult.signer?.longid === OpenPGPKey.bytesToLongid(key.getKeyId().bytes)) {\n          output.push('verify ok');\n        } else {\n          output.push(`verify mismatch: match[${verifyResult.match}] signer.uid[${verifyResult.signer?.primaryUserId}] signer.longid[${verifyResult.signer?.longid}]`);\n        }\n      }\n    } catch (e) {\n      output.push(`Exception: ${String(e)}`);\n    }\n    return output.join('|');\n  }\n\n  private static formatDate = (date: Date | number | null, expiresInSecondsFromDate?: number | null) => {\n    if (date === Infinity) {\n      return '-';\n    }\n    if (typeof date === 'number') {\n      return `UNEXPECTED FORMAT: ${date}`;\n    }\n    if (date === null) {\n      return `null (not applicable)`;\n    }\n    if (typeof expiresInSecondsFromDate === 'undefined') {\n      return `${date.getTime() / 1000} or ${date.toISOString()}`;\n    }\n    if (expiresInSecondsFromDate === null) {\n      return '-'; // no expiration\n    }\n    const expDate = new Date(date.getTime() + (expiresInSecondsFromDate * 1000));\n    return `${date.getTime() / 1000} + ${expiresInSecondsFromDate} seconds, which is: ${expDate.getTime() / 1000} or ${expDate.toISOString()}`;\n  }\n\n}\n",
    "extension/js/common/core/crypto/pgp/pgp-armor.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Buf } from '../../buf.js';\nimport { ReplaceableMsgBlockType } from '../../msg-block.js';\nimport { Str } from '../../common.js';\nimport { opgp } from './openpgpjs-custom.js';\nimport { Stream } from '../../stream.js';\n\nexport type PreparedForDecrypt = { isArmored: boolean, isCleartext: true, message: OpenPGP.cleartext.CleartextMessage | OpenPGP.message.Message }\n  | { isArmored: boolean, isCleartext: false, message: OpenPGP.message.Message };\n\ntype CryptoArmorHeaderDefinitions = { readonly [type in ReplaceableMsgBlockType | 'null' | 'signature']: CryptoArmorHeaderDefinition; };\ntype CryptoArmorHeaderDefinition = { begin: string, middle?: string, end: string | RegExp, replace: boolean };\n\nexport class PgpArmor {\n\n  public static ARMOR_HEADER_DICT: CryptoArmorHeaderDefinitions = { // general passwordMsg begin: /^[^\\n]+: (Open Message|Nachricht öffnen)/\n    null: { begin: '-----BEGIN', end: '-----END', replace: false },\n    publicKey: { begin: '-----BEGIN PGP PUBLIC KEY BLOCK-----', end: '-----END PGP PUBLIC KEY BLOCK-----', replace: true },\n    privateKey: { begin: '-----BEGIN PGP PRIVATE KEY BLOCK-----', end: '-----END PGP PRIVATE KEY BLOCK-----', replace: true },\n    pkcs12: { begin: '-----BEGIN PKCS12 FILE-----', end: '-----BEGIN PKCS12 FILE-----', replace: true }, // custom format - Base64 dump of pkcs12 file bytes\n    certificate: { begin: '-----BEGIN CERTIFICATE-----', end: '-----END CERTIFICATE-----', replace: true },\n    signedMsg: { begin: '-----BEGIN PGP SIGNED MESSAGE-----', middle: '-----BEGIN PGP SIGNATURE-----', end: '-----END PGP SIGNATURE-----', replace: true },\n    signature: { begin: '-----BEGIN PGP SIGNATURE-----', end: '-----END PGP SIGNATURE-----', replace: false },\n    encryptedMsg: { begin: '-----BEGIN PGP MESSAGE-----', end: '-----END PGP MESSAGE-----', replace: true },\n  };\n\n  public static clip = (text: string): string | undefined => {\n    if (text?.includes(PgpArmor.ARMOR_HEADER_DICT.null.begin) && text.includes(String(PgpArmor.ARMOR_HEADER_DICT.null.end))) {\n      const match = text.match(/(-----BEGIN PGP (MESSAGE|SIGNED MESSAGE|SIGNATURE|PUBLIC KEY BLOCK)-----[^]+-----END PGP (MESSAGE|SIGNATURE|PUBLIC KEY BLOCK)-----)/gm);\n      return (match && match.length) ? match[0] : undefined;\n    }\n    return undefined;\n  }\n\n  public static headers = (blockType: ReplaceableMsgBlockType | 'null', format = 'string'): CryptoArmorHeaderDefinition => {\n    const h = PgpArmor.ARMOR_HEADER_DICT[blockType];\n    return {\n      begin: (typeof h.begin === 'string' && format === 're') ? h.begin.replace(/ /g, '\\\\s') : h.begin,\n      end: (typeof h.end === 'string' && format === 're') ? h.end.replace(/ /g, '\\\\s') : h.end,\n      replace: h.replace,\n    };\n  }\n\n  public static normalize = (armored: string, type: ReplaceableMsgBlockType | 'key') => {\n    armored = Str.normalize(armored).replace(/\\n /g, '\\n');\n    if (['encryptedMsg', 'publicKey', 'privateKey', 'key'].includes(type)) {\n      armored = armored.replace(/\\r?\\n/g, '\\n').trim();\n      const nl2 = armored.match(/\\n\\n/g);\n      const nl3 = armored.match(/\\n\\n\\n/g);\n      const nl4 = armored.match(/\\n\\n\\n\\n/g);\n      const nl6 = armored.match(/\\n\\n\\n\\n\\n\\n/g);\n      if (nl3 && nl6 && nl3.length > 1 && nl6.length === 1) {\n        armored = armored.replace(/\\n\\n\\n/g, '\\n'); // newlines tripled: fix\n      } else if (nl2 && nl4 && nl2.length > 1 && nl4.length === 1) {\n        armored = armored.replace(/\\n\\n/g, '\\n'); // newlines doubled. GPA on windows does this, and sometimes message can get extracted this way from html\n      }\n    }\n    const lines = armored.split('\\n');\n    const h = PgpArmor.headers(type === 'key' ? 'null' : type);\n    // check for and fix missing a mandatory empty line\n    if (lines.length > 5 && lines[0].includes(h.begin) && lines[lines.length - 1].includes(String(h.end)) && !lines.includes('')) {\n      for (let i = 1; i < 5; i++) {\n        if (lines[i].match(/^[a-zA-Z0-9\\-_. ]+: .+$/)) {\n          continue; // skip comment lines, looking for first data line\n        }\n        if (lines[i].match(/^[a-zA-Z0-9\\/+]{32,77}$/)) { // insert empty line before first data line\n          armored = `${lines.slice(0, i).join('\\n')}\\n\\n${lines.slice(i).join('\\n')}`;\n          break;\n        }\n        break; // don't do anything if format not as expected\n      }\n    }\n    return armored;\n  }\n\n  public static cryptoMsgPrepareForDecrypt = async (encrypted: Uint8Array): Promise<PreparedForDecrypt> => {\n    if (!encrypted.length) {\n      throw new Error('Encrypted message could not be parsed because no data was provided');\n    }\n    const utfChunk = new Buf(encrypted.slice(0, 100)).toUtfStr('ignore'); // ignore errors - this may not be utf string, just testing\n    const isArmoredEncrypted = utfChunk.includes(PgpArmor.headers('encryptedMsg').begin);\n    const isArmoredSignedOnly = utfChunk.includes(PgpArmor.headers('signedMsg').begin);\n    const isArmored = isArmoredEncrypted || isArmoredSignedOnly;\n    if (isArmoredSignedOnly) {\n      return { isArmored, isCleartext: true, message: await opgp.cleartext.readArmored(new Buf(encrypted).toUtfStr()) };\n    } else if (isArmoredEncrypted) {\n      const message = await opgp.message.readArmored(new Buf(encrypted).toUtfStr());\n      const isCleartext = !!message.getLiteralData() && !!message.getSigningKeyIds().length && !message.getEncryptionKeyIds().length;\n      return { isArmored: true, isCleartext, message };\n    } else if (encrypted instanceof Uint8Array) {\n      return { isArmored, isCleartext: false, message: await opgp.message.read(encrypted) };\n    }\n    throw new Error('Message does not have armor headers');\n  }\n\n  public static dearmor = async (text: string): Promise<{ type: OpenPGP.enums.armor, data: Uint8Array }> => {\n    const decoded = await opgp.armor.decode(text);\n    const data = await Stream.readToEnd(decoded.data);\n    return { type: decoded.type, data };\n  }\n\n  public static armor = (messagetype: OpenPGP.enums.armor, body: object, partindex?: number, parttotal?: number, customComment?: string): string => {\n    return opgp.armor.encode(messagetype, body, partindex, parttotal, customComment);\n  }\n}\n",
    "extension/js/common/core/crypto/pgp/pgp-hash.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Buf } from '../../buf.js';\nimport { opgp } from './openpgpjs-custom.js';\n\nexport class PgpHash {\n\n  public static sha1UtfStr = async (string: string): Promise<string> => {\n    return opgp.util.Uint8Array_to_hex(await opgp.crypto.hash.digest(opgp.enums.hash.sha1, Buf.fromUtfStr(string)));\n  }\n\n  public static sha256UtfStr = async (string: string) => {\n    return opgp.util.Uint8Array_to_hex(await opgp.crypto.hash.digest(opgp.enums.hash.sha256, Buf.fromUtfStr(string)));\n  }\n\n  public static doubleSha1Upper = async (string: string) => {\n    return (await PgpHash.sha1UtfStr(await PgpHash.sha1UtfStr(string))).toUpperCase();\n  }\n\n  public static challengeAnswer = async (answer: string) => {\n    return await PgpHash.cryptoHashSha256Loop(answer);\n  }\n\n  private static cryptoHashSha256Loop = async (string: string, times = 100000) => {\n    for (let i = 0; i < times; i++) {\n      string = await PgpHash.sha256UtfStr(string);\n    }\n    return string;\n  }\n\n}\n",
    "extension/js/common/core/mime.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Dict, Str } from './common.js';\nimport { requireIso88592, requireMimeBuilder, requireMimeParser } from '../platform/require.js';\n\nimport { Attachment } from './attachment.js';\nimport { Buf } from './buf.js';\nimport { Catch } from '../platform/catch.js';\nimport { MimeParserNode } from './types/emailjs';\nimport { MsgBlock } from './msg-block.js';\nimport { MsgBlockParser } from './msg-block-parser.js';\nimport { PgpArmor } from './crypto/pgp/pgp-armor.js';\nimport { iso2022jpToUtf } from '../platform/util.js';\n\nconst MimeParser = requireMimeParser();  // tslint:disable-line:variable-name\nconst MimeBuilder = requireMimeBuilder();  // tslint:disable-line:variable-name\nconst Iso88592 = requireIso88592();  // tslint:disable-line:variable-name\n\ntype AddressHeader = { address: string; name: string; };\ntype MimeContentHeader = string | AddressHeader[];\nexport type MimeContent = {\n  headers: Dict<MimeContentHeader>;\n  attachments: Attachment[];\n  signature?: string;\n  rawSignedContent?: string;\n  subject?: string;\n  html?: string;\n  text?: string;\n  from?: string;\n  to: string[];\n  cc: string[];\n  bcc: string[];\n};\n\nexport type MimeEncodeType = 'pgpMimeEncrypted' | 'pgpMimeSigned' | 'smimeEncrypted' | undefined;\nexport type RichHeaders = Dict<string | string[]>;\nexport type SendableMsgBody = {\n  [key: string]: string | Buf | undefined;\n  'text/plain'?: string;\n  'text/html'?: string;\n  'encrypted/buf'?: Buf;\n};\nexport type MimeProccesedMsg = {\n  rawSignedContent: string | undefined,\n  headers: Dict<MimeContentHeader>,\n  blocks: MsgBlock[],\n  from: string | undefined,\n  to: string[]\n};\ntype SendingType = 'to' | 'cc' | 'bcc';\n\nexport class Mime {\n\n  public static processDecoded = (decoded: MimeContent): MimeProccesedMsg => {\n    const blocks: MsgBlock[] = [];\n    if (decoded.text) {\n      const blocksFromTextPart = MsgBlockParser.detectBlocks(Str.normalize(decoded.text)).blocks;\n      // if there are some encryption-related blocks found in the text section, which we can use, and not look at the html section\n      if (blocksFromTextPart.find(b => b.type === 'encryptedMsg' || b.type === 'signedMsg' || b.type === 'publicKey' || b.type === 'privateKey')) {\n        blocks.push(...blocksFromTextPart); // because the html most likely containt the same thing, just harder to parse pgp sections cause it's html\n      } else if (decoded.html) { // if no pgp blocks found in text part and there is html part, prefer html\n        blocks.push(MsgBlock.fromContent('plainHtml', decoded.html));\n      } else { // else if no html and just a plain text message, use that\n        blocks.push(...blocksFromTextPart);\n      }\n    } else if (decoded.html) {\n      blocks.push(MsgBlock.fromContent('plainHtml', decoded.html));\n    }\n    for (const file of decoded.attachments) {\n      const treatAs = file.treatAs();\n      if (treatAs === 'encryptedMsg') {\n        const armored = PgpArmor.clip(file.getData().toUtfStr());\n        if (armored) {\n          blocks.push(MsgBlock.fromContent('encryptedMsg', armored));\n        }\n      } else if (treatAs === 'signature') {\n        decoded.signature = decoded.signature || file.getData().toUtfStr();\n      } else if (treatAs === 'publicKey') {\n        blocks.push(...MsgBlockParser.detectBlocks(file.getData().toUtfStr()).blocks);\n      } else if (treatAs === 'privateKey') {\n        blocks.push(...MsgBlockParser.detectBlocks(file.getData().toUtfStr()).blocks);\n      } else if (treatAs === 'encryptedFile') {\n        blocks.push(MsgBlock.fromAttachment('encryptedAttachment', '', { name: file.name, type: file.type, length: file.getData().length, data: file.getData() }));\n      } else if (treatAs === 'plainFile') {\n        blocks.push(MsgBlock.fromAttachment('plainAttachment', '', {\n          name: file.name, type: file.type, length: file.getData().length, data: file.getData(), inline: file.inline, cid: file.cid\n        }));\n      }\n    }\n    if (decoded.signature) {\n      for (const block of blocks) {\n        if (block.type === 'plainText') {\n          block.type = 'signedText';\n          block.signature = decoded.signature;\n        } else if (block.type === 'plainHtml') {\n          block.type = 'signedHtml';\n          block.signature = decoded.signature;\n        }\n      }\n      if (!blocks.find(block => ['plainText', 'plainHtml', 'signedMsg', 'signedHtml', 'signedText'].includes(block.type))) { // signed an empty message\n        blocks.push(new MsgBlock(\"signedMsg\", \"\", true, decoded.signature));\n      }\n    }\n    return { headers: decoded.headers, blocks, from: decoded.from, to: decoded.to, rawSignedContent: decoded.rawSignedContent };\n  }\n\n  public static process = async (mimeMsg: Uint8Array): Promise<MimeProccesedMsg> => {\n    const decoded = await Mime.decode(mimeMsg);\n    return Mime.processDecoded(decoded);\n  }\n\n  public static isPlainImgAttachment = (b: MsgBlock) => {\n    return b.type === 'plainAttachment' && b.attachmentMeta && b.attachmentMeta.type && ['image/jpeg', 'image/jpg',\n      'image/bmp', 'image/png', 'image/svg+xml'].includes(b.attachmentMeta.type);\n  }\n\n  public static replyHeaders = (parsedMimeMsg: MimeContent) => {\n    const msgId = String(parsedMimeMsg.headers['message-id'] || '');\n    const refs = String(parsedMimeMsg.headers['in-reply-to'] || '');\n    return { 'in-reply-to': msgId, 'references': refs + ' ' + msgId };\n  }\n\n  public static resemblesMsg = (msg: Uint8Array) => {\n    const chunk = new Buf(msg.slice(0, 3000)).toUtfStr().toLowerCase().replace(/\\r\\n/g, '\\n');\n    const headers = chunk.split('\\n\\n')[0];\n    if (!headers) {\n      return false;\n    }\n    const contentType = headers.match(/content-type: +[0-9a-z\\-\\/]+/);\n    if (!contentType) {\n      return false;\n    }\n    if (headers.match(/;\\s+boundary=/) || headers.match(/;\\s+charset=/)) {\n      return true;\n    }\n    if (!headers.match(/boundary=/)) {\n      return false;\n    }\n    if (chunk.match(/\\ncontent-transfer-encoding: +[0-9a-z\\-\\/]+/) || chunk.match(/\\ncontent-disposition: +[0-9a-z\\-\\/]+/)) {\n      return true; // these tend to be inside body-part headers, after the first `\\n\\n` which we test above\n    }\n    return contentType.index === 0;\n  }\n\n  public static decode = async (mimeMsg: Uint8Array): Promise<MimeContent> => {\n    let mimeContent: MimeContent = { attachments: [], headers: {}, subject: undefined, text: undefined, html: undefined, signature: undefined, from: undefined, to: [], cc: [], bcc: [] };\n    const parser = new MimeParser();\n    const leafNodes: { [key: string]: MimeParserNode } = {};\n    parser.onbody = (node: MimeParserNode) => {\n      const path = String(node.path.join('.'));\n      if (typeof leafNodes[path] === 'undefined') {\n        leafNodes[path] = node;\n      }\n    };\n    return await new Promise((resolve, reject) => {\n      try {\n        parser.onend = () => {\n          try {\n            for (const name of Object.keys(parser.node.headers)) {\n              mimeContent.headers[name] = parser.node.headers[name][0].value;\n            }\n            mimeContent.rawSignedContent = Mime.retrieveRawSignedContent([parser.node]);\n            for (const node of Object.values(leafNodes)) {\n              if (Mime.getNodeType(node) === 'application/pgp-signature') {\n                mimeContent.signature = node.rawContent;\n              } else if (Mime.getNodeType(node) === 'text/html' && !Mime.getNodeFilename(node)) {\n                // html content may be broken up into smaller pieces by attachments in between\n                // AppleMail does this with inline attachments\n                mimeContent.html = (mimeContent.html || '') + Mime.getNodeContentAsUtfStr(node);\n              } else if (Mime.getNodeType(node) === 'text/plain' && (!Mime.getNodeFilename(node) || Mime.isNodeInline(node))) {\n                mimeContent.text = (mimeContent.text ? `${mimeContent.text}\\n\\n` : '') + Mime.getNodeContentAsUtfStr(node);\n              } else if (Mime.getNodeType(node) === 'text/rfc822-headers') {\n                if (node._parentNode && node._parentNode.headers.subject) {\n                  mimeContent.subject = node._parentNode.headers.subject[0].value;\n                }\n              } else {\n                mimeContent.attachments.push(Mime.getNodeAsAttachment(node));\n              }\n            }\n            const headers = Mime.headerGetAddress(mimeContent, ['from', 'to', 'cc', 'bcc']);\n            mimeContent.subject = String(mimeContent.subject || mimeContent.headers.subject || '');\n            mimeContent = Object.assign(mimeContent, headers);\n            resolve(mimeContent);\n          } catch (e) {\n            reject(e);\n          }\n        };\n        parser.write(mimeMsg);\n        parser.end();\n      } catch (e) { // todo - on Android we may want to fail when this happens, evaluate effect on browser extension\n        Catch.reportErr(e);\n        resolve(mimeContent);\n      }\n    });\n  }\n\n  public static encode = async (body: SendableMsgBody, headers: RichHeaders, attachments: Attachment[] = [], type?: MimeEncodeType): Promise<string> => {\n    const rootContentType = type !== 'pgpMimeEncrypted' ? 'multipart/mixed' : `multipart/encrypted; protocol=\"application/pgp-encrypted\";`;\n    const rootNode = new MimeBuilder(rootContentType, { includeBccInHeader: true }); // tslint:disable-line:no-unsafe-any\n    for (const key of Object.keys(headers)) {\n      rootNode.addHeader(key, headers[key]); // tslint:disable-line:no-unsafe-any\n    }\n    if (Object.keys(body).length) {\n      let contentNode: MimeParserNode;\n      if (Object.keys(body).length === 1) {\n        contentNode = Mime.newContentNode(MimeBuilder, Object.keys(body)[0], body[Object.keys(body)[0] as \"text/plain\" | \"text/html\"] || '');\n      } else {\n        contentNode = new MimeBuilder('multipart/alternative'); // tslint:disable-line:no-unsafe-any\n        for (const type of Object.keys(body)) {\n          contentNode.appendChild(Mime.newContentNode(MimeBuilder, type, body[type]!.toString())); // already present, that's why part of for loop\n        }\n      }\n      rootNode.appendChild(contentNode); // tslint:disable-line:no-unsafe-any\n    }\n    for (const attachment of attachments) {\n      rootNode.appendChild(Mime.createAttachmentNode(attachment)); // tslint:disable-line:no-unsafe-any\n    }\n    return rootNode.build(); // tslint:disable-line:no-unsafe-any\n  }\n\n  public static encodeSmime = async (body: Uint8Array, headers: RichHeaders): Promise<string> => {\n    const rootContentType = 'application/pkcs7-mime; name=\"smime.p7m\"; smime-type=enveloped-data';\n    const rootNode = new MimeBuilder(rootContentType, { includeBccInHeader: true }); // tslint:disable-line:no-unsafe-any\n    for (const key of Object.keys(headers)) {\n      rootNode.addHeader(key, headers[key]); // tslint:disable-line:no-unsafe-any\n    }\n    rootNode.setContent(body); // tslint:disable-line:no-unsafe-any\n    rootNode.addHeader('Content-Transfer-Encoding', 'base64'); // tslint:disable-line:no-unsafe-any\n    rootNode.addHeader('Content-Disposition', 'attachment; filename=\"smime.p7m\"'); // tslint:disable-line:no-unsafe-any\n    rootNode.addHeader('Content-Description', 'S/MIME Encrypted Message'); // tslint:disable-line:no-unsafe-any\n    return rootNode.build(); // tslint:disable-line:no-unsafe-any\n  }\n\n  public static subjectWithoutPrefixes = (subject: string): string => {\n    return subject.replace(/^((Re|Fwd): ?)+/g, '').trim();\n  }\n\n  public static encodePgpMimeSigned = async (body: SendableMsgBody, headers: RichHeaders, attachments: Attachment[] = [], sign: (data: string) => Promise<string>): Promise<string> => {\n    const sigPlaceholder = `SIG_PLACEHOLDER_${Str.sloppyRandom(10)}`;\n    const rootNode = new MimeBuilder(`multipart/signed; protocol=\"application/pgp-signature\";`, { includeBccInHeader: true }); // tslint:disable-line:no-unsafe-any\n    for (const key of Object.keys(headers)) {\n      rootNode.addHeader(key, headers[key]); // tslint:disable-line:no-unsafe-any\n    }\n    const bodyNodes = new MimeBuilder('multipart/alternative'); // tslint:disable-line:no-unsafe-any\n    for (const type of Object.keys(body)) {\n      bodyNodes.appendChild(Mime.newContentNode(MimeBuilder, type, body[type]!.toString())); // tslint:disable-line:no-unsafe-any\n    }\n    const signedContentNode = new MimeBuilder('multipart/mixed'); // tslint:disable-line:no-unsafe-any\n    signedContentNode.appendChild(bodyNodes); // tslint:disable-line:no-unsafe-any\n    for (const attachment of attachments) {\n      signedContentNode.appendChild(Mime.createAttachmentNode(attachment)); // tslint:disable-line:no-unsafe-any\n    }\n    const sigAttachmentPlaceholder = new Attachment({ data: Buf.fromUtfStr(sigPlaceholder), type: 'application/pgp-signature', name: 'signature.asc' });\n    const sigAttachmentPlaceholderNode = Mime.createAttachmentNode(sigAttachmentPlaceholder); // tslint:disable-line:no-unsafe-any\n    // https://tools.ietf.org/html/rfc3156#section-5 - signed content first, signature after\n    rootNode.appendChild(signedContentNode); // tslint:disable-line:no-unsafe-any\n    rootNode.appendChild(sigAttachmentPlaceholderNode); // tslint:disable-line:no-unsafe-any\n    const mimeStrWithPlaceholderSig = rootNode.build() as string; // tslint:disable-line:no-unsafe-any\n    const { rawSignedContent } = await Mime.decode(Buf.fromUtfStr(mimeStrWithPlaceholderSig));\n    if (!rawSignedContent) {\n      console.log(`mimeStrWithPlaceholderSig(placeholder:${sigPlaceholder}):\\n${mimeStrWithPlaceholderSig}`);\n      throw new Error('Could not find raw signed content immediately after mime-encoding a signed message');\n    }\n    const realSignature = await sign(rawSignedContent); // tslint:disable-line:no-unsafe-any\n    const pgpMimeSigned = mimeStrWithPlaceholderSig.replace(Buf.fromUtfStr(sigPlaceholder).toBase64Str(), Buf.fromUtfStr(realSignature).toBase64Str());\n    if (pgpMimeSigned === mimeStrWithPlaceholderSig) {\n      console.log(`pgpMimeSigned(placeholder:${sigPlaceholder}):\\n${pgpMimeSigned}`);\n      throw new Error('Replaced sigPlaceholder with realSignature but mime stayed the same');\n    }\n    return pgpMimeSigned;\n  }\n\n  private static headerGetAddress = (parsedMimeMsg: MimeContent, headersNames: Array<SendingType | 'from'>) => {\n    const result: { to: string[], cc: string[], bcc: string[] } = { to: [], cc: [], bcc: [] };\n    let from: string | undefined;\n    const getHdrValAsArr = (hdr: MimeContentHeader) => typeof hdr === 'string' ? [hdr].map(h => Str.parseEmail(h).email).filter(e => !!e) as string[] : hdr.map(h => h.address);\n    const getHdrValAsStr = (hdr: MimeContentHeader) => Str.parseEmail((Array.isArray(hdr) ? (hdr[0] || {}).address : String(hdr || '')) || '').email;\n    for (const hdrName of headersNames) {\n      const header = parsedMimeMsg.headers[hdrName];\n      if (header) {\n        if (hdrName === 'from') {\n          from = getHdrValAsStr(header);\n        } else {\n          result[hdrName] = [...result[hdrName], ...getHdrValAsArr(header)];\n        }\n      }\n    }\n    return { ...result, from };\n  }\n\n  private static retrieveRawSignedContent = (nodes: MimeParserNode[]): string | undefined => {\n    for (const node of nodes) {\n      if (!node._childNodes || !node._childNodes.length) {\n        continue; // signed nodes tend contain two children: content node, signature node. If no node, then this is not pgp/mime signed content\n      }\n      const isSigned = node._isMultipart === 'signed';\n      const isMixedWithSig = node._isMultipart === 'mixed' && node._childNodes.length === 2 && Mime.getNodeType(node._childNodes[1]) === 'application/pgp-signature';\n      if (isSigned || isMixedWithSig) {\n        // PGP/MIME signed content uses <CR><LF> as in // use CR-LF https://tools.ietf.org/html/rfc3156#section-5\n        // however emailjs parser will replace it to <LF>, so we fix it here\n        let rawSignedContent = node._childNodes[0].raw.replace(/\\r?\\n/g, '\\r\\n');\n        if (/--$/.test(rawSignedContent)) { // end of boundary without a mandatory newline\n          rawSignedContent += '\\r\\n'; // emailjs wrongly leaves out the last newline, fix it here\n        }\n        return rawSignedContent;\n      }\n      return Mime.retrieveRawSignedContent(node._childNodes);\n    }\n    return undefined;\n  }\n\n  private static createAttachmentNode = (attachment: Attachment): any => { // todo: MimeBuilder types\n    const type = `${attachment.type}; name=\"${attachment.name}\"`;\n    const id = attachment.cid || Attachment.attachmentId();\n    const header: Dict<string> = {};\n    if (attachment.contentDescription) {\n      header['Content-Description'] = attachment.contentDescription;\n    }\n    header['Content-Disposition'] = attachment.inline ? 'inline' : 'attachment';\n    header['X-Attachment-Id'] = id;\n    header['Content-ID'] = `<${id}>`;\n    header['Content-Transfer-Encoding'] = 'base64';\n    return new MimeBuilder(type, { filename: attachment.name }).setHeader(header).setContent(attachment.getData()); // tslint:disable-line:no-unsafe-any\n  }\n\n  private static getNodeType = (node: MimeParserNode, type: 'value' | 'initial' = 'value') => {\n    if (node.headers['content-type'] && node.headers['content-type'][0]) {\n      return node.headers['content-type'][0][type];\n    }\n    return undefined;\n  }\n\n  private static getNodeContentId = (node: MimeParserNode) => {\n    if (node.headers['content-id'] && node.headers['content-id'][0]) {\n      return node.headers['content-id'][0].value;\n    }\n    return undefined;\n  }\n\n  private static getNodeFilename = (node: MimeParserNode): string | undefined => {\n    if (node.headers['content-disposition'] && node.headers['content-disposition'][0]) {\n      const header = node.headers['content-disposition'][0];\n      if (header.params && header.params.filename) {\n        return String(header.params.filename);\n      }\n    }\n    if (node.headers['content-type'] && node.headers['content-type'][0]) {\n      const header = node.headers['content-type'][0];\n      if (header.params && header.params.name) {\n        return String(header.params.name);\n      }\n    }\n    return;\n  }\n\n  private static isNodeInline = (node: MimeParserNode): boolean => {\n    const cd = node.headers['content-disposition'];\n    return cd && cd[0] && cd[0].value === 'inline';\n  }\n\n  private static fromEqualSignNotationAsBuf = (str: string): Buf => {\n    return Buf.fromRawBytesStr(str.replace(/(=[A-F0-9]{2})+/g, equalSignUtfPart => {\n      const bytes = equalSignUtfPart.replace(/^=/, '').split('=').map(twoHexDigits => parseInt(twoHexDigits, 16));\n      return new Buf(bytes).toRawBytesStr();\n    }));\n  }\n\n  private static getNodeAsAttachment = (node: MimeParserNode): Attachment => {\n    return new Attachment({\n      name: Mime.getNodeFilename(node),\n      type: Mime.getNodeType(node),\n      data: node.contentTransferEncoding.value === 'quoted-printable' ? Mime.fromEqualSignNotationAsBuf(node.rawContent!) : node.content,\n      cid: Mime.getNodeContentId(node),\n    });\n  }\n\n  private static getNodeContentAsUtfStr = (node: MimeParserNode): string => {\n    if (node.charset && Iso88592.labels.includes(node.charset)) {\n      return Iso88592.decode(node.rawContent!); // tslint:disable-line:no-unsafe-any\n    }\n    let resultBuf: Buf;\n    if (node.charset === 'utf-8' && node.contentTransferEncoding.value === 'base64') {\n      resultBuf = Buf.fromUint8(node.content);\n    } else if (node.charset === 'utf-8' && node.contentTransferEncoding.value === 'quoted-printable') {\n      resultBuf = Mime.fromEqualSignNotationAsBuf(node.rawContent!);\n    } else {\n      resultBuf = Buf.fromRawBytesStr(node.rawContent!);\n    }\n    if (node.charset?.toUpperCase() === 'ISO-2022-JP' || (node.charset === 'utf-8' && Mime.getNodeType(node, 'initial')?.includes('ISO-2022-JP'))) {\n      return iso2022jpToUtf(resultBuf);\n    }\n    return resultBuf.toUtfStr();\n  }\n\n  // tslint:disable-next-line:variable-name\n  private static newContentNode = (MimeBuilder: any, type: string, content: string): MimeParserNode => {\n    const node: MimeParserNode = new MimeBuilder(type).setContent(content); // tslint:disable-line:no-unsafe-any\n    if (type === 'text/plain') {\n      // gmail likes this\n      node.addHeader('Content-Transfer-Encoding', 'quoted-printable'); // tslint:disable-line:no-unsafe-any\n    }\n    return node;\n  }\n\n}\n",
    "extension/js/common/core/stream.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nexport class Stream {\n  public static readToEnd = async (data: ReadableStream<Uint8Array>) => {\n    let buffer = new Uint8Array();\n    const ws = new WritableStream<Uint8Array>({ write: chunk => { buffer = new Uint8Array([...buffer, ...chunk]); } });\n    await data.pipeTo(ws);\n    return buffer;\n  }\n}",
    "extension/js/common/platform/catch.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { FLAVOR, VERSION } from '../core/const.js';\n\nexport class UnreportableError extends Error { }\ntype ObjWithStack = { stack: string };\nexport type ErrorReport = {\n  name: string;\n  message: string;\n  url: string;\n  line: number;\n  col: number;\n  trace: string;\n  version: string;\n  environment: string;\n}\n\nexport class Catch {\n\n  public static RUNTIME_ENVIRONMENT = 'undetermined';\n  private static ORIG_ONERROR = window.onerror;\n  private static CONSOLE_MSG = ' Please report errors above to human@flowcrypt.com. We fix errors VERY promptly.';\n  private static IGNORE_ERR_MSG = [\n    // happens in gmail window when reloaded extension + now reloading gmail\n    'Invocation of form get(, function) doesn\\'t match definition get(optional string or array or object keys, function callback)',\n    // happens in gmail window when reloaded extension + now reloading gmail\n    'Invocation of form set(, function) doesn\\'t match definition set(object items, optional function callback)',\n    // not sure when this one happens, but likely have to do with extnsion lifecycle as well\n    'Invocation of form runtime.connect(null, ) doesn\\'t match definition runtime.connect(optional string extensionId, optional object connectInfo)',\n    // this is thrown often by gmail and cought by content script\n    'TypeError: a is null',\n    'TypeError: d is null',\n    'TypeError: G is null',\n    'TypeError: window.opener is null',\n    // errors on other domains: https://bugzilla.mozilla.org/show_bug.cgi?id=363897\n    'Script error.',\n    // benign error https://github.com/WICG/ResizeObserver/issues/38#issuecomment-422126006 https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n    'ResizeObserver loop limit exceeded',\n  ];\n\n  public static rewrapErr = (e: any, message: string): Error => {\n    const newErr = new Error(`${message}::${e instanceof Error ? `${e.name}: ${e.message}` : String(e)}`);\n    newErr.stack += `\\n\\n${Catch.stringify(e)}`;\n    return newErr;\n  }\n\n  public static stringify = (e: any): string => {\n    if (e instanceof Error) {\n      return `[typeof:Error:${e.name}] ${e.message}\\n\\n${e.stack}`;\n    }\n    if (typeof e === 'string') {\n      return `[typeof:string] ${e}`;\n    }\n    try {\n      return `[typeof:${(typeof e)}:${String(e)}] ${JSON.stringify(e)}`;\n    } catch (cannotStringify) {\n      return `[unstringifiable typeof:${(typeof e)}:${String(e)}]`;\n    }\n  }\n\n  public static hasStack = (e: any): e is ObjWithStack => {\n    return e && typeof e === 'object' && typeof (e as ObjWithStack).stack === 'string' && Boolean((e as ObjWithStack).stack); // tslint:disable-line:no-unsafe-any\n  }\n\n  /**\n   * @returns boolean - whether error was reported remotely or not\n   */\n  public static onErrorInternalHandler = (errMsg: string | undefined, url: string, line: number, col: number, originalErr: any, isManuallyCalled: boolean): boolean => {\n    const exception = Catch.formExceptionFromThrown(originalErr, errMsg, url, line, col, isManuallyCalled);\n    if ((Catch.IGNORE_ERR_MSG.indexOf(exception.message) !== -1) || (errMsg && Catch.IGNORE_ERR_MSG.indexOf(errMsg) !== -1)) {\n      return false;\n    }\n    console.error(originalErr);\n    if (exception !== originalErr) {\n      console.error(exception);\n    }\n    console.log(`%c[${exception.message}]\\n${exception.stack}`, 'color: #F00; font-weight: bold;');\n    if (isManuallyCalled !== true && Catch.ORIG_ONERROR && Catch.ORIG_ONERROR !== (Catch.onErrorInternalHandler as OnErrorEventHandler)) {\n      // @ts-ignore\n      Catch.ORIG_ONERROR.apply(undefined, arguments); // Call any previously assigned handler\n    }\n    if (exception instanceof UnreportableError) {\n      console.error('Not reporting UnreportableError above');\n      return false;\n    }\n    if ((exception.stack || '').indexOf('PRIVATE') !== -1) {\n      exception.stack = '~censored:PRIVATE';\n    }\n    const formatted = Catch.formatExceptionForReport(exception, line, col);\n    // todo - here would have to make a decision if we are sending it to flowcrypt.com or enterprise FES\n    if (FLAVOR === 'enterprise') {\n      console.log('enterprise flavor - not reporting this remotely');\n      // if FES is set up, then on enterprise flavor, we could still send report there\n      return false; // do not send to flowcrypt.com backend on enterprise flavor\n    }\n    // consumer flavor\n    Catch.doSendErrorToFlowCryptComBackend(formatted);\n    return true;\n  }\n\n  /**\n   * @returns boolean - whether error was reported remotely or not\n   */\n  public static reportErr = (e: any): boolean => {\n    const { line, col } = Catch.getErrorLineAndCol(e);\n    return Catch.onErrorInternalHandler(e instanceof Error ? e.message : String(e), window.location.href, line, col, e, true);\n  }\n\n  /**\n   * @returns boolean - whether error was reported remotely or not\n   */\n  public static report = (name: string, details?: any): boolean => {\n    return Catch.reportErr(Catch.nameAndDetailsAsException(name, details));\n  }\n\n  public static isPromise = (v: any): v is Promise<any> => {\n    return v && typeof v === 'object' // tslint:disable-line:no-unsafe-any\n      && typeof (v as Promise<any>).then === 'function' // tslint:disable-line:no-unbound-method - only testing if exists\n      && typeof (v as Promise<any>).catch === 'function'; // tslint:disable-line:no-unbound-method - only testing if exists\n  }\n\n  public static try = (code: () => void | Promise<void>) => {\n    return () => { // returns a function\n      try {\n        const r = code();\n        if (Catch.isPromise(r)) {\n          r.catch(Catch.reportErr);\n        }\n      } catch (codeErr) {\n        Catch.reportErr(codeErr);\n      }\n    };\n  }\n\n  public static browser = (): { name: 'firefox' | 'ie' | 'chrome' | 'opera' | 'safari' | 'unknown', v: number | undefined } => {\n    // http://stackoverflow.com/questions/4825498/how-can-i-find-out-which-browser-a-user-is-using\n    if (/Firefox[\\/\\s](\\d+\\.\\d+)/.test(navigator.userAgent)) {\n      return { name: 'firefox', v: Number(RegExp.$1) };\n    } else if (/MSIE (\\d+\\.\\d+);/.test(navigator.userAgent)) {\n      return { name: 'ie', v: Number(RegExp.$1) };\n    } else if (/Chrome[\\/\\s](\\d+\\.\\d+)/.test(navigator.userAgent)) {\n      return { name: 'chrome', v: Number(RegExp.$1) };\n    } else if (/Opera[\\/\\s](\\d+\\.\\d+)/.test(navigator.userAgent)) {\n      return { name: 'opera', v: Number(RegExp.$1) };\n    } else if (/Safari[\\/\\s](\\d+\\.\\d+)/.test(navigator.userAgent)) {\n      return { name: 'safari', v: Number(RegExp.$1) };\n    } else {\n      return { name: 'unknown', v: undefined };\n    }\n  }\n\n  public static environment = (url = window.location.href): string => {\n    const browserName = Catch.browser().name;\n    const origin = new URL(window.location.href).origin;\n    let env = 'unknown';\n    if (url.indexOf('bnjglocicd') !== -1) {\n      env = 'ex:prod';\n    } else if (url.indexOf('gjdhkacdgd') !== -1 || url.indexOf('gggocmadhd') !== -1) {\n      env = 'ex:dev';\n    } else if (url.indexOf('mefaeofbcc') !== -1) {\n      env = 'ex:stable';\n    } else if (/chrome-extension:\\/\\/[a-z]{32}\\/.+/.test(url)) {\n      env = 'ex:fork';\n    } else if (/moz-extension:\\/\\/.+/.test(url)) {\n      env = 'ex';\n    } else if (origin === 'http://l.flowcrypt.com') {\n      env = 'web:local';\n    } else if (origin === 'https://flowcrypt.com') {\n      env = 'web:prod';\n    } else if (origin === 'https://mail.google.com') {\n      env = 'ex:script:gmail';\n    }\n    return browserName + ':' + env;\n  }\n\n  public static test = (type: 'error' | 'object' = 'error') => {\n    if (type === 'error') {\n      throw new Error('intentional error for debugging');\n    } else {\n      throw { what: 'intentional thrown object for debugging' };\n    }\n  }\n\n  public static stackTrace = (): string => {\n    try {\n      Catch.test();\n    } catch (e) {\n      // return stack after removing first 3 lines plus url\n      return `${((e as Error).stack || '').split('\\n').splice(3).join('\\n')}\\n\\nurl: ${Catch.censoredUrl(window.location.href)}\\n`;\n    }\n    return ''; // make ts happy - this will never happen\n  }\n\n  public static censoredUrl = (url: string | undefined): string => {\n    if (!url) {\n      return '(unknown url)';\n    }\n    if (url.indexOf('refreshToken=') !== -1) {\n      return `${url.split('?')[0]}~censored:refreshToken`;\n    }\n    if (url.indexOf('token=') !== -1) {\n      return `${url.split('?')[0]}~censored:token`;\n    }\n    if (url.indexOf('code=') !== -1) {\n      return `${url.split('?')[0]}~censored:code`;\n    }\n    if (url.indexOf('idToken=') !== -1) {\n      return `${url.split('?')[0]}~censored:idToken`;\n    }\n    return url;\n  }\n\n  public static onUnhandledRejectionInternalHandler = (e: any) => {\n    if (Catch.isPromiseRejectionEvent(e)) {\n      Catch.reportErr(e.reason);\n    } else {\n      const str = Catch.stringify(e);\n      if (str.match(/^\\[typeof:object:\\[object (PromiseRejectionEvent|CustomEvent|ProgressEvent)\\]\\] \\{\"isTrusted\":(?:true|false)\\}$/)) {\n        return; // unrelated to FlowCrypt, has to do with JS-initiated clicks/events\n      }\n      const { line, col } = Catch.getErrorLineAndCol(e);\n      const msg = e instanceof Error ? e.message : String(e);\n      Catch.onErrorInternalHandler(`REJECTION: ${msg}`, window.location.href, line, col, e, true);\n    }\n  }\n\n  public static setHandledInterval = (cb: () => void | Promise<void>, ms: number): number => {\n    return window.setInterval(Catch.try(cb), ms); // error-handled: else setInterval will silently swallow errors\n  }\n\n  public static setHandledTimeout = (cb: () => void | Promise<void>, ms: number): number => {\n    return window.setTimeout(Catch.try(cb), ms); // error-handled: else setTimeout will silently swallow errors\n  }\n\n  public static doesReject = async (p: Promise<unknown>, errNeedle?: string[]) => {\n    try {\n      await p;\n      return false;\n    } catch (e) {\n      if (!errNeedle) { // no needles to check against\n        return true;\n      }\n      return !!errNeedle.find(needle => String(e).includes(needle));\n    }\n  }\n\n  public static undefinedOnException = async <T>(p: Promise<T>): Promise<T | undefined> => {\n    try {\n      return await p;\n    } catch (e) {\n      return undefined;\n    }\n  }\n\n  private static formatExceptionForReport = (thrown: any, line?: number, col?: number): ErrorReport => {\n    if (!line || !col) {\n      const { line: parsedLine, col: parsedCol } = Catch.getErrorLineAndCol(thrown);\n      line = parsedLine;\n      col = parsedCol;\n    }\n    if (thrown instanceof Error) { // reporting stack may differ from the stack of the actual error, both may be interesting\n      thrown.stack += Catch.formattedStackBlock('Catch.reportErr calling stack', Catch.stackTrace());\n      if (thrown.hasOwnProperty('workerStack')) { // https://github.com/openpgpjs/openpgpjs/issues/656#event-1498323188\n        thrown.stack += Catch.formattedStackBlock('openpgp.js worker stack', String((thrown as any).workerStack));\n      }\n    }\n    const exception = Catch.formExceptionFromThrown(thrown);\n    return {\n      name: exception.name.substring(0, 50),\n      message: exception.message.substring(0, 200),\n      url: window.location.href.substring(0, 100),\n      line: line || 0,\n      col: col || 0,\n      trace: exception.stack || '',\n      version: VERSION,\n      environment: Catch.RUNTIME_ENVIRONMENT,\n    };\n  }\n\n  private static doSendErrorToFlowCryptComBackend = (errorReport: ErrorReport) => {\n    try {\n      $.ajax({ // tslint:disable-line:no-direct-ajax\n        url: 'https://flowcrypt.com/api/help/error',\n        method: 'POST',\n        data: JSON.stringify(errorReport),\n        dataType: 'json',\n        crossDomain: true,\n        contentType: 'application/json; charset=UTF-8',\n        async: true,\n        success: (response: { saved: boolean }) => {\n          if (response && typeof response === 'object' && response.saved === true) {\n            console.log('%cFlowCrypt ERROR:' + Catch.CONSOLE_MSG, 'font-weight: bold;');\n          } else {\n            console.error('%cFlowCrypt EXCEPTION:' + Catch.CONSOLE_MSG, 'font-weight: bold;');\n          }\n        },\n        error: () => {\n          console.error('%cFlowCrypt FAILED:' + Catch.CONSOLE_MSG, 'font-weight: bold;');\n        },\n      });\n    } catch (ajaxErr) {\n      console.error(ajaxErr);\n      console.error('%cFlowCrypt ISSUE:' + Catch.CONSOLE_MSG, 'font-weight: bold;');\n    }\n  }\n\n  private static formExceptionFromThrown = (thrown: any, errMsg?: string, url?: string, line?: number, col?: number, isManuallyCalled?: boolean): Error => {\n    let exception: Error;\n    if (typeof thrown !== 'object') {\n      exception = new Error(`THROWN_NON_OBJECT[${typeof thrown}]: ${String(thrown)}`);\n    } else if (errMsg && url && typeof line !== 'undefined' && !col && !thrown && !isManuallyCalled) {\n      exception = new Error(`LIMITED_ERROR: ${errMsg}`);\n    } else if (thrown instanceof Error) {\n      exception = thrown;\n      if (thrown.hasOwnProperty('thrown')) { // this is created by custom async stack reporting in tooling/tsc-compiler.ts\n        exception.stack += `\\n\\ne.thrown:\\n${Catch.stringify((thrown as any).thrown)}`;\n      }\n    } else {\n      exception = new Error(`THROWN_OBJECT: ${errMsg}`);\n      if (Catch.hasStack(thrown)) {\n        exception.stack += `\\n\\nORIGINAL_THROWN_OBJECT_STACK:\\n${thrown.stack}\\n\\n`;\n      }\n      exception.stack += `\\n\\nORIGINAL_ERR:\\n${Catch.stringify(thrown)}`;\n    }\n    return exception;\n  }\n\n  private static getErrorLineAndCol = (e: any) => {\n    try {\n      const callerLine = e.stack!.split('\\n')[1]; // tslint:disable-line:no-unsafe-any\n      const matched = callerLine.match(/\\.js:([0-9]+):([0-9]+)\\)?/); // tslint:disable-line:no-unsafe-any\n      return { line: Number(matched![1]), col: Number(matched![2]) }; // tslint:disable-line:no-unsafe-any\n    } catch (lineErr) {\n      return { line: 0, col: 0 };\n    }\n  }\n\n  private static formattedStackBlock = (name: string, text: string) => {\n    return `\\n\\n### ${name} ###\\n# ${text.split('\\n').join('\\n# ')}\\n######################\\n`;\n  }\n\n  private static nameAndDetailsAsException = (name: string, details: any): Error => {\n    try {\n      throw new Error(name);\n    } catch (e) {\n      (e as Error).stack += `\\n\\n\\ndetails:\\n${Catch.stringify(details)}`;\n      return e as Error;\n    }\n  }\n\n  private static isPromiseRejectionEvent = (ev: any): ev is PromiseRejectionEvent => {\n    if (ev && typeof ev === 'object') {\n      const eHasReason = (ev as {}).hasOwnProperty('reason') && typeof (ev as PromiseRejectionEvent).reason === 'object';\n      const eHasPromise = (ev as {}).hasOwnProperty('promise') && Catch.isPromise((ev as PromiseRejectionEvent).promise);\n      return eHasReason && eHasPromise;\n    }\n    return false;\n  }\n\n}\n\nCatch.RUNTIME_ENVIRONMENT = Catch.environment();\nwindow.onerror = (Catch.onErrorInternalHandler as OnErrorEventHandler);\nwindow.onunhandledrejection = Catch.onUnhandledRejectionInternalHandler;\n",
    "extension/js/common/platform/store/acct-store.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { Env } from '../../browser/env.js';\nimport { GoogleAuth } from '../../api/email-provider/gmail/google-auth.js';\nimport { KeyInfo } from '../../core/crypto/key.js';\nimport { Dict } from '../../core/common.js';\nimport { GmailRes } from '../../api/email-provider/gmail/gmail-parser.js';\nimport { DomainRulesJson } from '../../org-rules.js';\nimport { BrowserMsg, BgNotReadyErr } from '../../browser/browser-msg.js';\nimport { Ui } from '../../browser/ui.js';\nimport { storageLocalGet, storageLocalSet, storageLocalRemove } from '../../browser/chrome.js';\nimport { AbstractStore } from './abstract-store.js';\nimport { RawStore } from './abstract-store.js';\nimport { FcUuidAuth } from '../../api/account-servers/flowcrypt-com-api.js';\n\nexport type StoredReplyDraftMeta = string; // draftId, TODO: remove in #3329\nexport type EmailProvider = 'gmail';\ntype GoogleAuthScopesNames = [keyof typeof GoogleAuth.OAUTH.scopes, keyof typeof GoogleAuth.OAUTH.legacy_scopes][number];\n\nexport type Scopes = {\n  openid: boolean;\n  email: boolean;\n  profile: boolean;\n  compose: boolean;\n  modify: boolean;\n  readContacts: boolean;\n  read: boolean;\n  gmail: boolean;\n};\n\nexport type AccountIndex = 'keys' | 'notification_setup_needed_dismissed' | 'email_provider' | 'google_token_access' | 'google_token_expires' | 'google_token_scopes' |\n  'google_token_refresh' | 'hide_message_password' | 'sendAs' | 'drafts_reply' |\n  'pubkey_sent_to' | 'full_name' | 'cryptup_enabled' | 'setup_done' |\n  'successfully_received_at_leat_one_message' | 'notification_setup_done_seen' | 'picture' |\n  'outgoing_language' | 'setup_date' | 'openid' | 'tmp_submit_main' | 'tmp_submit_all' | 'uuid' | 'use_rich_text' | 'rules' |\n  'fesUrl' | 'fesAccessToken';\n\nexport type SendAsAlias = {\n  isPrimary: boolean;\n  isDefault?: boolean;\n  name?: string | null;\n  footer?: string | null;\n};\n\nexport type AcctStoreDict = {\n  keys?: KeyInfo[];\n  notification_setup_needed_dismissed?: boolean;\n  email_provider?: EmailProvider;\n  google_token_access?: string;\n  google_token_expires?: number;\n  google_token_scopes?: string[]; // these are actuall scope urls the way the provider expects them\n  google_token_refresh?: string;\n  hide_message_password?: boolean; // is global?\n  sendAs?: Dict<SendAsAlias>;\n  addresses?: string[],\n  drafts_reply?: Dict<StoredReplyDraftMeta>; // legacy, TODO: remove in #3329\n  pubkey_sent_to?: string[];\n  full_name?: string;\n  cryptup_enabled?: boolean;\n  setup_done?: boolean;\n  successfully_received_at_leat_one_message?: boolean;\n  notification_setup_done_seen?: boolean;\n  picture?: string; // google image\n  outgoing_language?: 'EN' | 'DE';\n  setup_date?: number;\n  use_rich_text?: boolean;\n  openid?: GmailRes.OpenId;\n  uuid?: string;\n  rules?: DomainRulesJson;\n  fesUrl?: string; // url where FlowCrypt Enterprise Server is deployed\n  fesAccessToken?: string;\n  // temporary\n  tmp_submit_main?: boolean;\n  tmp_submit_all?: boolean;\n};\n\n/**\n * Local storage of data related to a particular email account\n */\nexport class AcctStore extends AbstractStore {\n\n  public static get = async (acctEmail: string, keys: AccountIndex[]): Promise<AcctStoreDict> => {\n    if (Env.isContentScript()) {\n      // extension storage can be disallowed in rare cases for content scripts throwing 'Error: Access to extension API denied.'\n      // go through bg script to avoid such errors\n      for (let i = 0; i < 10; i++) { // however backend may not be immediately ready to respond - retry\n        try {\n          return await BrowserMsg.send.bg.await.storeAcctGet({ acctEmail, keys });\n        } catch (e) {\n          if (!(e instanceof BgNotReadyErr) || i === 9) {\n            throw e;\n          }\n          await Ui.time.sleep(300);\n        }\n      }\n      throw new BgNotReadyErr('this should never happen');\n    }\n    const storageObj = await storageLocalGet(AcctStore.singleScopeRawIndexArr(acctEmail, keys)) as RawStore;\n    const result = AcctStore.buildSingleAccountStoreFromRawResults(acctEmail, storageObj) as AcctStoreDict;\n    return AcctStore.fixAcctStorageResult(acctEmail, result, keys);\n  }\n\n  public static getAccounts = async (acctEmails: string[], keys: string[]): Promise<Dict<AcctStoreDict>> => {\n    const storageObj = await storageLocalGet(AcctStore.manyScopesRawIndexArr(acctEmails, keys)) as RawStore;\n    const resultsByAcct: Dict<AcctStoreDict> = {};\n    for (const account of acctEmails) {\n      resultsByAcct[account] = AcctStore.buildSingleAccountStoreFromRawResults(account, storageObj);\n    }\n    return resultsByAcct;\n  }\n\n  public static set = async (acctEmail: string, values: AcctStoreDict): Promise<void> => {\n    if (Env.isContentScript()) {\n      // extension storage can be disallowed in rare cases for content scripts throwing 'Error: Access to extension API denied.'\n      // always go through bg script to avoid such errors\n      return await BrowserMsg.send.bg.await.storeAcctSet({ acctEmail, values });\n    }\n    const indexedUpdateFields: RawStore = {};\n    const indexedRemoveFields: string[] = [];\n    for (const key of Object.keys(values)) {\n      const index = AcctStore.singleScopeRawIndex(acctEmail, key);\n      if (typeof values[key as AccountIndex] !== 'undefined') {\n        indexedUpdateFields[index] = values[key as AccountIndex];\n      } else {\n        indexedRemoveFields.push(index);\n      }\n    }\n    if (Object.keys(indexedUpdateFields).length) {\n      await storageLocalSet(indexedUpdateFields);\n    }\n    if (indexedRemoveFields.length) {\n      await storageLocalRemove(indexedRemoveFields);\n    }\n  }\n\n  public static authInfo = async (acctEmail: string): Promise<FcUuidAuth> => {\n    const { uuid } = await AcctStore.get(acctEmail, ['uuid']);\n    return { account: acctEmail, uuid };\n  }\n\n  public static remove = async (acctEmail: string, keys: AccountIndex[]) => {\n    await storageLocalRemove(AcctStore.singleScopeRawIndexArr(acctEmail, keys));\n  }\n\n  public static getScopes = async (acctEmail: string): Promise<Scopes> => {\n    const { google_token_scopes } = await AcctStore.get(acctEmail, ['google_token_scopes']);\n    const result: { [key in GoogleAuthScopesNames]: boolean } = {\n      email: false, openid: false, profile: false, compose: false,\n      modify: false, readContacts: false, gmail: false, read: false\n    };\n    if (google_token_scopes) {\n      for (const key of Object.keys({ ...GoogleAuth.OAUTH.scopes, ...GoogleAuth.OAUTH.legacy_scopes })) {\n        const scopeName = key as GoogleAuthScopesNames;\n        if (scopeName in GoogleAuth.OAUTH.scopes) {\n          result[scopeName] = google_token_scopes.includes(GoogleAuth.OAUTH.scopes[scopeName as keyof typeof GoogleAuth.OAUTH.scopes]);\n        } else if (scopeName in GoogleAuth.OAUTH.legacy_scopes) {\n          result[scopeName] = google_token_scopes.includes(GoogleAuth.OAUTH.legacy_scopes[scopeName as keyof typeof GoogleAuth.OAUTH.legacy_scopes]);\n        }\n      }\n    }\n    return result;\n  }\n\n  private static fixAcctStorageResult = (acctEmail: string, acctStore: AcctStoreDict, keys: AccountIndex[]): AcctStoreDict => {\n    if (keys.includes('sendAs') && !acctStore.sendAs) {\n      acctStore.sendAs = { [acctEmail]: { isPrimary: true, isDefault: true } };\n    }\n    return acctStore;\n  }\n\n}\n",
    "extension/js/common/platform/store/contact-store.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { AbstractStore } from './abstract-store.js';\nimport { Catch } from '../catch.js';\nimport { opgp } from '../../core/crypto/pgp/openpgpjs-custom.js';\nimport { BrowserMsg } from '../../browser/browser-msg.js';\nimport { DateUtility, Str } from '../../core/common.js';\nimport { Key, Contact, KeyUtil } from '../../core/crypto/key.js';\n\n// tslint:disable:no-null-keyword\n\ntype DbContactObjArg = {\n  email: string,\n  name?: string | null,\n  pubkey?: string | null,\n  lastUse?: number | null, // when was this contact last used to send an email\n  lastCheck?: number | null; // when was the local copy of the pubkey last updated (or checked against Attester)\n};\n\nexport type Email = {\n  email: string;\n  name: string | null;\n  searchable: string[];\n  fingerprints: string[];\n  lastUse: number | null;\n};\n\nexport type Pubkey = {\n  fingerprint: string;\n  armoredKey: string;\n  longids: string[];\n  lastCheck: number | null,\n  expiresOn: number | null;\n};\n\ntype Revocation = {\n  fingerprint: string;\n};\n\ntype PubkeyAttributes = {\n  fingerprint: string | null;\n  expiresOn: number | null;\n};\n\nexport type ContactV4 = {\n  info: Email,\n  pubkeys: Pubkey[],\n  revocations: Revocation[]\n}\n\nexport type ContactPreview = {\n  email: string;\n  name: string | null;\n  hasPgp: 0 | 1;\n  lastUse: number | null;\n};\n\nexport type ContactUpdate = {\n  name?: string | null;\n  lastUse?: number | null;\n  pubkey?: Key;\n  pubkeyLastCheck?: number | null; // when non-null, `pubkey` must be supplied\n};\n\ntype DbContactFilter = { hasPgp?: boolean, substring?: string, limit?: number };\n\nconst x509postfix = \"-X509\";\n\n/**\n * Store of contacts and their public keys\n * This includes an index of email and name substrings for easier search when user is typing\n * Db is initialized in the background page and accessed through BrowserMsg\n */\nexport class ContactStore extends AbstractStore {\n\n  // static [f: string]: Function; // https://github.com/Microsoft/TypeScript/issues/6480\n\n  private static dbQueryKeys = ['limit', 'substring', 'hasPgp'];\n\n  public static dbOpen = async (): Promise<IDBDatabase> => {\n    return await new Promise((resolve, reject) => {\n      const openDbReq = indexedDB.open('cryptup', 5);\n      openDbReq.onupgradeneeded = (event) => {\n        const db = openDbReq.result;\n        if (event.oldVersion < 4) {\n          const emails = db.createObjectStore('emails', { keyPath: 'email' });\n          const pubkeys = db.createObjectStore('pubkeys', { keyPath: 'fingerprint' });\n          emails.createIndex('search', 'searchable', { multiEntry: true });\n          emails.createIndex('index_fingerprints', 'fingerprints', { multiEntry: true }); // fingerprints of all connected pubkeys\n          pubkeys.createIndex('index_longids', 'longids', { multiEntry: true }); // longids of all public key packets in armored pubkey\n        }\n        if (event.oldVersion < 5) {\n          db.createObjectStore('revocations', { keyPath: 'fingerprint' });\n        }\n        if (db.objectStoreNames.contains('contacts')) {\n          const countRequest = openDbReq.transaction!.objectStore('contacts').count();\n          ContactStore.setReqPipe(countRequest, (count: number) => {\n            if (count === 0) {\n              console.info('contacts store is now empty, deleting it...');\n              db.deleteObjectStore('contacts');\n            }\n          });\n        }\n      };\n      openDbReq.onsuccess = () => resolve(openDbReq.result as IDBDatabase);\n      openDbReq.onblocked = () => reject(ContactStore.errCategorize(openDbReq.error));\n      openDbReq.onerror = () => reject(ContactStore.errCategorize(openDbReq.error));\n    });\n  }\n\n  public static previewObj = ({ email, name }: { email: string, name?: string | null }): ContactPreview => {\n    const validEmail = Str.parseEmail(email).email;\n    if (!validEmail) {\n      throw new Error(`Cannot handle the contact because email is not valid: ${email}`);\n    }\n    return { email: validEmail, name: name || null, hasPgp: 0, lastUse: null };\n  }\n\n  public static obj = async ({ email, name, pubkey, lastUse, lastCheck }: DbContactObjArg): Promise<Contact> => {\n    if (typeof opgp === 'undefined') {\n      return await BrowserMsg.send.bg.await.db({ f: 'obj', args: [{ email, name, pubkey, lastUse, lastCheck }] }) as Contact;\n    } else {\n      const validEmail = Str.parseEmail(email).email;\n      if (!validEmail) {\n        throw new Error(`Cannot save contact because email is not valid: ${email}`);\n      }\n      if (!pubkey) {\n        return {\n          email: validEmail,\n          name: name || null,\n          pubkey: undefined,\n          hasPgp: 0, // number because we use it for sorting\n          fingerprint: null,\n          lastUse: lastUse || null,\n          pubkeyLastCheck: null,\n          expiresOn: null,\n          revoked: false\n        };\n      }\n      const pk = await KeyUtil.parse(pubkey);\n      return {\n        email: validEmail,\n        name: name || null,\n        pubkey: pk,\n        hasPgp: 1, // number because we use it for sorting\n        lastUse: lastUse || null,\n        pubkeyLastCheck: lastCheck || null,\n        revoked: pk.revoked,\n        ...ContactStore.getKeyAttributes(pk)\n      };\n    }\n  }\n\n  /**\n   * Used to save a contact or an array of contacts.\n   * An underlying update operation is used for each of the provided contact.\n   * Null properties will be ignored if a record already exists in the database\n   * as described in the `update` remarks.\n   *\n   * @param {IDBDatabase} db                     (optional) database to use\n   * @param {Contact | Contact[]} email            a single contact or an array of contacts\n   * @returns {Promise<void>}\n   *\n   * @async\n   * @static\n   */\n  public static save = async (db: IDBDatabase | undefined, contact: Contact | Contact[]): Promise<void> => {\n    if (!db) { // relay op through background process\n      await BrowserMsg.send.bg.await.db({ f: 'save', args: [contact] });\n      return;\n    }\n    if (Array.isArray(contact)) {\n      await Promise.all(contact.map(oneContact => ContactStore.save(db, oneContact)));\n      return;\n    }\n    await ContactStore.update(db, contact.email, contact);\n  }\n\n  /**\n   * Used to update certain fields of existing contacts or create new contacts using the provided data.\n   * If an array of emails is provided, the update operation will be performed independently on each of them.\n   * Null or missing properties from the `update` object will not be overwritten in the database,\n   * The `pubkey` property will be used only to add or update a pubkey record by the pubkey fingerprint.\n   * Null value of `pubkey` won't affect any pubkey records.\n   * The `pubkeyLastCheck` property can be set to a non-null value only when `pubkey` specified\n   * and will be applied only to that specific pubkey record. Missing or null `pubkeyLastCheck` will\n   * leave the `pubkeyLastCheck` value of the existing pubkey unchanged.\n   *\n   * @param {IDBDatabase} db                     (optional) database to use\n   * @param {string | string[]} email            a single email or an array of emails\n   * @param {ContactUpdate} update               object containing fields to be updated\n   * @returns {Promise<void>}\n   *\n   * @async\n   * @static\n   */\n  public static update = async (db: IDBDatabase | undefined, email: string | string[], update: ContactUpdate): Promise<void> => {\n    if (!db) { // relay op through background process\n      await BrowserMsg.send.bg.await.db({ f: 'update', args: [email, update] });\n      return;\n    }\n    if (Array.isArray(email)) {\n      await Promise.all(email.map(oneEmail => ContactStore.update(db, oneEmail, update)));\n      return;\n    }\n    const validEmail = Str.parseEmail(email).email;\n    if (!validEmail) {\n      throw Error(`Cannot update contact because email is not valid: ${email}`);\n    }\n    if (update.pubkey?.isPrivate) {\n      Catch.report(`Wrongly updating prv ${update.pubkey.id} as contact - converting to pubkey`);\n      update.pubkey = await KeyUtil.asPublicKey(update.pubkey);\n    }\n    const tx = db.transaction(['emails', 'pubkeys', 'revocations'], 'readwrite');\n    await new Promise((resolve, reject) => {\n      ContactStore.setTxHandlers(tx, resolve, reject);\n      ContactStore.updateTx(tx, validEmail, update);\n    });\n  }\n\n  public static get = async (db: undefined | IDBDatabase, emailOrLongid: string[]): Promise<(Contact | undefined)[]> => {\n    if (!db) { // relay op through background process\n      return await BrowserMsg.send.bg.await.db({ f: 'get', args: [emailOrLongid] }) as (Contact | undefined)[];\n    }\n    if (emailOrLongid.length === 1) {\n      const contact = await ContactStore.dbContactInternalGetOne(db, emailOrLongid[0]);\n      return [contact];\n    } else {\n      const results: (Contact | undefined)[] = [];\n      for (const singleEmailOrLongid of emailOrLongid) {\n        const [contact] = await ContactStore.get(db, [singleEmailOrLongid]);\n        results.push(contact);\n      }\n      return results;\n    }\n  }\n\n  public static search = async (db: IDBDatabase | undefined, query: DbContactFilter): Promise<ContactPreview[]> => {\n    return (await ContactStore.rawSearch(db, query)).filter(Boolean).map(ContactStore.toContactPreview);\n  }\n\n  public static searchPubkeys = async (db: IDBDatabase | undefined, query: DbContactFilter): Promise<string[]> => {\n    const fingerprints = (await ContactStore.rawSearch(db, query)).filter(Boolean).map(email => email.fingerprints).reduce((a, b) => a.concat(b));\n    return (await ContactStore.extractPubkeys(db, fingerprints)).map(pubkey => pubkey?.armoredKey).filter(Boolean);\n  }\n\n  public static getOneWithAllPubkeys = async (db: IDBDatabase, email: string): Promise<ContactV4 | undefined> => {\n    const tx = db.transaction(['emails', 'pubkeys', 'revocations'], 'readonly');\n    const pubkeys: Pubkey[] = [];\n    const revocations: Revocation[] = [];\n    const emailEntity: Email | undefined = await new Promise((resolve, reject) => {\n      const req = tx.objectStore('emails').get(email);\n      ContactStore.setReqPipe(req,\n        (email: Email) => {\n          if (!email) {\n            resolve(undefined);\n            return;\n          }\n          if (!email.fingerprints || email.fingerprints.length === 0) {\n            resolve(email);\n            return;\n          }\n          const uniqueAndStrippedFingerprints = email.fingerprints.\n            map(ContactStore.stripFingerprint).\n            filter((value, index, self) => !self.slice(0, index).find((el) => el === value));\n          let countdown = email.fingerprints.length + uniqueAndStrippedFingerprints.length;\n          // request all pubkeys by fingerprints\n          for (const fp of email.fingerprints) {\n            const req2 = tx.objectStore('pubkeys').get(fp);\n            ContactStore.setReqPipe(req2,\n              (pubkey: Pubkey) => {\n                if (pubkey) {\n                  pubkeys.push(pubkey);\n                }\n                if (!--countdown) {\n                  resolve(email);\n                }\n              },\n              reject);\n          }\n          for (const fp of uniqueAndStrippedFingerprints) {\n            const range = ContactStore.createFingerprintRange(fp);\n            const req3 = tx.objectStore('revocations').getAll(range);\n            ContactStore.setReqPipe(req3,\n              (revocation: Revocation[]) => {\n                revocations.push(...revocation);\n                if (!--countdown) {\n                  resolve(email);\n                }\n              },\n              reject);\n          }\n        },\n        reject);\n    });\n    return emailEntity ? { info: emailEntity, pubkeys, revocations } : undefined;\n  }\n\n  public static updateTx = (tx: IDBTransaction, email: string, update: ContactUpdate) => {\n    if (update.pubkey && !update.pubkeyLastCheck) {\n      const req = tx.objectStore('pubkeys').get(ContactStore.getPubkeyId(update.pubkey));\n      ContactStore.setReqPipe(req, (pubkey: Pubkey) => {\n        const range = ContactStore.createFingerprintRange(update.pubkey!.id);\n        const req2 = tx.objectStore('revocations').getAll(range);\n        ContactStore.setReqPipe(req2, (revocations: Revocation[]) => {\n          ContactStore.updateTxPhase2(tx, email, update, pubkey, revocations);\n        });\n      });\n    } else {\n      ContactStore.updateTxPhase2(tx, email, update, undefined, []);\n    }\n  }\n\n  public static setReqPipe<T>(req: IDBRequest, pipe: (value?: T) => void, reject?: ((reason?: any) => void) | undefined) {\n    req.onsuccess = () => {\n      try {\n        pipe(req.result as T);\n      } catch (codeErr) {\n        req.transaction!.dispatchEvent(new ErrorEvent('error'));\n        if (reject) {\n          reject(codeErr);\n        }\n        Catch.reportErr(codeErr);\n      }\n    };\n    if (reject) {\n      this.setReqOnError(req, reject);\n    }\n  }\n\n  public static pubkeyObj = (pubkey: Key, lastCheck: number | null | undefined): Pubkey => {\n    const keyAttrs = ContactStore.getKeyAttributes(pubkey);\n    return {\n      fingerprint: ContactStore.getPubkeyId(pubkey),\n      lastCheck: DateUtility.asNumber(lastCheck),\n      expiresOn: keyAttrs.expiresOn,\n      longids: KeyUtil.getPubkeyLongids(pubkey),\n      armoredKey: KeyUtil.armor(pubkey)\n    };\n  }\n\n  public static revocationObj = (pubkey: Key): { fingerprint: string, armoredKey: string } => {\n    return { fingerprint: ContactStore.getPubkeyId(pubkey), armoredKey: KeyUtil.armor(pubkey) };\n    // todo: we can add a timestamp here and/or some other info\n  }\n\n  private static getPubkeyId = (pubkey: Key): string => {\n    return (pubkey.type === 'x509') ? (pubkey.id + x509postfix) : pubkey.id;\n  }\n\n  private static stripFingerprint = (fp: string): string => {\n    return fp.endsWith(x509postfix) ? fp.slice(0, -x509postfix.length) : fp;\n  }\n\n  private static equalFingerprints = (fp1: string, fp2: string): boolean => {\n    return (fp1.endsWith(x509postfix) ? fp1 : (fp1 + x509postfix))\n      === (fp2.endsWith(x509postfix) ? fp2 : (fp2 + x509postfix));\n  }\n\n  private static createFingerprintRange = (fp: string): IDBKeyRange => {\n    const strippedFp = ContactStore.stripFingerprint(fp);\n    return IDBKeyRange.bound(strippedFp, strippedFp + x509postfix, false, false);\n  }\n\n  private static updateTxPhase2 = (tx: IDBTransaction, email: string, update: ContactUpdate,\n    existingPubkey: Pubkey | undefined, revocations: Revocation[]) => {\n    let pubkeyEntity: Pubkey | undefined;\n    if (update.pubkey) {\n      const internalFingerprint = ContactStore.getPubkeyId(update.pubkey!);\n      if (update.pubkey.type === 'openpgp' && !update.pubkey.revoked && revocations.some(r => r.fingerprint === internalFingerprint)) {\n        // we have this fingerprint revoked but the supplied key isn't\n        // so let's not save it\n        // pubkeyEntity = undefined\n      } else {\n        pubkeyEntity = ContactStore.pubkeyObj(update.pubkey, update.pubkeyLastCheck ?? existingPubkey?.lastCheck);\n      }\n      if (update.pubkey.revoked && !revocations.some(r => r.fingerprint === internalFingerprint)) {\n        tx.objectStore('revocations').put(ContactStore.revocationObj(update.pubkey));\n      }\n      // todo: will we benefit anything when not saving pubkey if it isn't modified?\n    } else if (update.pubkeyLastCheck) {\n      Catch.report(`Wrongly updating pubkeyLastCheck without specifying pubkey for ${email} - ignoring`);\n    }\n    const req = tx.objectStore('emails').get(email);\n    ContactStore.setReqPipe(req, (emailEntity: Email) => {\n      let updatedEmailEntity: Email | undefined;\n      if (!emailEntity) {\n        updatedEmailEntity = { email, name: null, searchable: [], fingerprints: [], lastUse: null };\n      } else if (pubkeyEntity || update.name || update.lastUse) {\n        updatedEmailEntity = emailEntity;\n      } else {\n        updatedEmailEntity = undefined; // not modified\n      }\n      if (updatedEmailEntity) {\n        if (pubkeyEntity) {\n          if (!updatedEmailEntity.fingerprints.includes(pubkeyEntity.fingerprint)) {\n            updatedEmailEntity.fingerprints.push(pubkeyEntity.fingerprint);\n          }\n        }\n        if (update.name) {\n          updatedEmailEntity.name = update.name;\n        }\n        if (update.lastUse) {\n          updatedEmailEntity.lastUse = DateUtility.asNumber(update.lastUse);\n        }\n        ContactStore.updateSearchable(updatedEmailEntity);\n        tx.objectStore('emails').put(updatedEmailEntity);\n      }\n      if (pubkeyEntity) {\n        tx.objectStore('pubkeys').put(pubkeyEntity);\n      }\n    });\n  }\n\n  private static chainExtraction<T>(\n    store: IDBObjectStore,\n    setup: { keys: IDBValidKey[], values: T[] },\n    req?: IDBRequest | undefined): void {\n    if (req) {\n      ContactStore.setReqPipe(req,\n        (value: T) => {\n          if (value) {\n            setup.values.push(value);\n          }\n        });\n    }\n    const key = setup.keys.pop();\n    if (key) {\n      const reqNext = store.get(key);\n      ContactStore.chainExtraction(store, setup, reqNext);\n    }\n  }\n\n  private static async extractKeyset<T>(db: IDBDatabase, storeName: string, keys: IDBValidKey[], poolSize: number): Promise<T[]> {\n    const tx = db.transaction([storeName], 'readonly');\n    const setup = { keys, values: [] as T[] };\n    await new Promise((resolve, reject) => {\n      ContactStore.setTxHandlers(tx, resolve, reject);\n      for (let poolCount = 0; poolCount < poolSize; poolCount++) {\n        ContactStore.chainExtraction(tx.objectStore(storeName), setup);\n      }\n    });\n    return setup.values;\n  }\n\n  private static extractPubkeys = async (db: IDBDatabase | undefined, fingerprints: string[]): Promise<Pubkey[]> => {\n    if (!fingerprints.length) {\n      return [];\n    }\n    if (!db) { // relay op through background process\n      return await BrowserMsg.send.bg.await.db({ f: 'extractPubkeys', args: [fingerprints] }) as Pubkey[];\n    }\n    return await ContactStore.extractKeyset(db, 'pubkeys', fingerprints, 10);\n  }\n\n  private static rawSearch = async (db: IDBDatabase | undefined, query: DbContactFilter): Promise<Email[]> => {\n    if (!db) { // relay op through background process\n      return await BrowserMsg.send.bg.await.db({ f: 'rawSearch', args: [query] }) as Email[];\n    }\n    for (const key of Object.keys(query)) {\n      if (!ContactStore.dbQueryKeys.includes(key)) {\n        throw new Error('ContactStore.rawSearch: unknown key: ' + key);\n      }\n    }\n    query.substring = ContactStore.normalizeString(query.substring || '');\n    if (typeof query.hasPgp === 'undefined' && query.substring) {\n      const resultsWithPgp = await ContactStore.rawSearch(db, { substring: query.substring, limit: query.limit, hasPgp: true });\n      if (query.limit && resultsWithPgp.length === query.limit) {\n        return resultsWithPgp;\n      } else {\n        const limit = query.limit ? query.limit - resultsWithPgp.length : undefined;\n        const resultsWithoutPgp = await ContactStore.rawSearch(db, { substring: query.substring, limit, hasPgp: false });\n        return resultsWithPgp.concat(resultsWithoutPgp);\n      }\n    }\n    const emails = db.transaction(['emails'], 'readonly').objectStore('emails');\n    const raw: Email[] = await new Promise((resolve, reject) => {\n      let search: IDBRequest;\n      if (typeof query.hasPgp === 'undefined') { // any query.hasPgp value\n        search = emails.openCursor(); // no substring, already covered in `typeof query.hasPgp === 'undefined' && query.substring` above\n      } else { // specific query.hasPgp value\n        const indexRange = ContactStore.dbIndexRange(query.hasPgp, query.substring ?? '');\n        // To find all the index keys starting with a certain sequence of characters (e.g. 'abc')\n        // we use a range with inclusive lower boundary and exclusive upper boundary\n        // ['t:abc', 't:abd) or ['f:abc', 'f:abd'), so that any key having an arbitrary tail of\n        // characters beyond 'abc' falls into this range, and none of the non-matching keys do.\n        // Thus we only have to keep complete keywords in the 'search' index.\n        const range = IDBKeyRange.bound(indexRange.lowerBound, indexRange.upperBound, false, true);\n        search = emails.index('search').openCursor(range);\n      }\n      const found: Email[] = [];\n      ContactStore.setReqPipe(search,\n        (cursor: IDBCursorWithValue) => {\n          if (!cursor) {\n            resolve(found);\n          } else {\n            found.push(cursor.value); // tslint:disable-line:no-unsafe-any\n            if (query.limit && found.length >= query.limit) {\n              resolve(found);\n            } else {\n              cursor.continue();\n            }\n          }\n        },\n        reject);\n    });\n    return raw;\n  }\n\n  private static normalizeString = (str: string) => {\n    return str.normalize('NFKD').replace(/[\\u0300-\\u036F]/g, '').toLowerCase();\n  }\n\n  private static dbIndex = (hasPgp: boolean, substring: string): string => {\n    return (hasPgp ? 't:' : 'f:') + substring;\n  }\n\n  private static dbIndexRange = (hasPgp: boolean, substring: string): { lowerBound: string, upperBound: string } => {\n    // to find all the keys starting with 'abc', we need to use a range search with exlcusive upper boundary\n    // ['t:abc', 't:abd'), that is, we \"replace\" the last char ('c') with the char having subsequent code ('d')\n    // The edge case is when the search string terminates with a certain char X having the max allowed code (65535)\n    // or with a sequence of these, e.g. 'abcXXXXX'. In this case, we have to remove the tail of X characters\n    // and increase the preceding non-X char, hence, the range would be ['t:abcXXXXX', 't:abd')\n    // If the search sequence consists entirely of such symbols, the search range will have\n    // the upper boundary of 'f;' or 't;', so this algorithm always works\n    const lowerBound = ContactStore.dbIndex(hasPgp, substring);\n    let copyLength = lowerBound.length - 1;\n    let lastChar = lowerBound.charCodeAt(copyLength);\n    while (lastChar >= 65535) {\n      lastChar = lowerBound.charCodeAt(--copyLength);\n    }\n    const upperBound = lowerBound.substring(0, copyLength) + String.fromCharCode(lastChar + 1);\n    return { lowerBound, upperBound };\n  }\n\n  private static updateSearchable = (emailEntity: Email) => {\n    const email = emailEntity.email.toLowerCase();\n    const name = emailEntity.name ? emailEntity.name.toLowerCase() : '';\n    // we only need the longest word if it starts with a shorter one,\n    // e.g. we don't need \"flowcrypt\" if we have \"flowcryptcompatibility\"\n    const sortedNormalized = [...email.split(/[^a-z0-9]/), ...name.split(/[^a-z0-9]/)].filter(p => !!p)\n      .map(ContactStore.normalizeString).sort((a, b) => b.length - a.length);\n    emailEntity.searchable = sortedNormalized.filter((value, index, self) => !self.slice(0, index).find((el) => el.startsWith(value)))\n      .map(normalized => ContactStore.dbIndex(emailEntity.fingerprints.length > 0, normalized));\n  }\n\n  private static dbContactInternalGetOne = async (db: IDBDatabase, emailOrLongid: string): Promise<Contact | undefined> => {\n    if (emailOrLongid.includes('@')) { // email\n      const contactWithAllPubkeys = await ContactStore.getOneWithAllPubkeys(db, emailOrLongid);\n      if (!contactWithAllPubkeys) {\n        return contactWithAllPubkeys;\n      }\n      // parse the keys\n      const parsed = await Promise.all(contactWithAllPubkeys.pubkeys.map(async (pubkey) => {\n        const pk = await KeyUtil.parse(pubkey.armoredKey);\n        const revoked = pk.revoked || contactWithAllPubkeys.revocations.some(r => ContactStore.equalFingerprints(pk.id, r.fingerprint));\n        const expirationSortValue = (typeof pk.expiration === 'undefined') ? Infinity : pk.expiration!;\n        return {\n          lastCheck: pubkey.lastCheck,\n          pubkey: pk,\n          revoked,\n          // sort non-revoked first, then non-expired\n          sortValue: revoked ? -Infinity : expirationSortValue\n        };\n      }));\n      const sorted = parsed.sort((a, b) => b.sortValue - a.sortValue);\n      // pick first usableForEncryption\n      let selected = sorted.find(entry => !entry.revoked && entry.pubkey.usableForEncryption);\n      if (!selected) {\n        selected = sorted.find(entry => !entry.revoked && entry.pubkey.usableForEncryptionButExpired);\n      }\n      if (!selected) {\n        selected = sorted[0];\n      }\n      return ContactStore.toContactFromKey(contactWithAllPubkeys.info, selected?.pubkey, selected?.lastCheck, Boolean(selected?.revoked));\n    }\n    // search all longids\n    const tx = db.transaction(['emails', 'pubkeys'], 'readonly');\n    return await new Promise((resolve, reject) => {\n      const req = tx.objectStore('pubkeys').index('index_longids').get(emailOrLongid);\n      ContactStore.setReqPipe(req,\n        (pubkey: Pubkey) => {\n          if (!pubkey) {\n            resolve(undefined);\n            return;\n          }\n          const req2 = tx.objectStore('emails').index('index_fingerprints').get(pubkey.fingerprint!);\n          ContactStore.setReqPipe(req2,\n            (email: Email) => {\n              if (!email) {\n                resolve(undefined);\n              } else {\n                resolve(ContactStore.toContact(db, email, pubkey));\n              }\n            },\n            reject);\n        },\n        reject);\n    });\n  }\n\n  private static getKeyAttributes = (key: Key | undefined): PubkeyAttributes => {\n    return { fingerprint: key?.id ?? null, expiresOn: DateUtility.asNumber(key?.expiration) };\n  }\n\n  private static toContact = async (db: IDBDatabase, email: Email, pubkey: Pubkey | undefined): Promise<Contact | undefined> => {\n    if (!email) {\n      return;\n    }\n    const parsed = pubkey ? await KeyUtil.parse(pubkey.armoredKey) : undefined;\n    let revokedExternally = false;\n    if (parsed && !parsed.revoked) {\n      const revocations: Revocation[] = await new Promise((resolve, reject) => {\n        const tx = db.transaction(['revocations'], 'readonly');\n        const range = ContactStore.createFingerprintRange(parsed!.id);\n        const req = tx.objectStore('revocations').getAll(range);\n        ContactStore.setReqPipe(req, resolve, reject);\n      });\n      if (revocations.length) {\n        revokedExternally = true;\n      }\n    }\n    return ContactStore.toContactFromKey(email, parsed, parsed ? pubkey!.lastCheck : null, revokedExternally);\n  }\n\n  private static toContactFromKey = (email: Email, key: Key | undefined, lastCheck: number | undefined | null, revokedExternally: boolean): Contact | undefined => {\n    if (!email) {\n      return;\n    }\n    const safeKey = revokedExternally ? undefined : key;\n    return {\n      email: email.email,\n      name: email.name,\n      pubkey: safeKey,\n      hasPgp: safeKey ? 1 : 0,\n      lastUse: email.lastUse,\n      pubkeyLastCheck: lastCheck ?? null,\n      ...ContactStore.getKeyAttributes(key),\n      revoked: revokedExternally || Boolean(key?.revoked)\n    };\n  }\n\n  private static toContactPreview = (result: Email): ContactPreview => {\n    return { email: result.email, name: result.name, hasPgp: result.fingerprints.length > 0 ? 1 : 0, lastUse: result.lastUse };\n  }\n}\n",
    "extension/js/common/platform/store/global-store.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { BrowserMsg } from '../../browser/browser-msg.js';\nimport { Env } from '../../browser/env.js';\nimport { RawStore, AbstractStore } from './abstract-store.js';\nimport { Value } from '../../core/common.js';\nimport { storageLocalSet, storageLocalGet, storageLocalRemove } from '../../browser/chrome.js';\nimport { Catch } from '../catch.js';\n\nexport type StoredAdminCode = { date: number, codes: string[] };\n\nexport type GlobalStoreDict = {\n  version?: number | null;\n  account_emails?: string; // stringified array\n  settings_seen?: boolean;\n  hide_pass_phrases?: boolean;\n  dev_outlook_allow?: boolean;\n  install_mobile_app_notification_dismissed?: boolean;\n  key_info_store_fingerprints_added?: boolean;\n  contact_store_x509_fingerprints_and_longids_updated?: boolean;\n  contact_store_opgp_revoked_flags_updated?: boolean;\n};\n\nexport type GlobalIndex = 'version' | 'account_emails' | 'settings_seen' | 'hide_pass_phrases' |\n  'dev_outlook_allow' | 'install_mobile_app_notification_dismissed' | 'key_info_store_fingerprints_added' |\n  'contact_store_x509_fingerprints_and_longids_updated' | 'contact_store_opgp_revoked_flags_updated';\n\n/**\n * Locally stored data that is not associated with any email account\n */\nexport class GlobalStore extends AbstractStore {\n\n  private static globalStorageScope: 'global' = 'global';\n\n  public static set = async (values: GlobalStoreDict): Promise<void> => {\n    if (Env.isContentScript()) {\n      // extension storage can be disallowed in rare cases for content scripts throwing 'Error: Access to extension API denied.'\n      // always go through bg script to avoid such errors\n      return await BrowserMsg.send.bg.await.storeGlobalSet({ values });\n    }\n    const storageUpdate: RawStore = {};\n    for (const key of Object.keys(values)) {\n      const index = GlobalStore.singleScopeRawIndex(GlobalStore.globalStorageScope, key);\n      storageUpdate[index] = values[key as GlobalIndex];\n    }\n    await storageLocalSet(storageUpdate);\n  }\n\n  public static get = async (keys: GlobalIndex[]): Promise<GlobalStoreDict> => {\n    if (Env.isContentScript()) {\n      // extension storage can be disallowed in rare cases for content scripts throwing 'Error: Access to extension API denied.'\n      // always go through bg script to avoid such errors\n      return await BrowserMsg.send.bg.await.storeGlobalGet({ keys });\n    }\n    const storageObj = await storageLocalGet(GlobalStore.singleScopeRawIndexArr(GlobalStore.globalStorageScope, keys)) as RawStore;\n    return GlobalStore.buildSingleAccountStoreFromRawResults(GlobalStore.globalStorageScope, storageObj) as GlobalStore;\n  }\n\n  public static remove = async (keys: string[]) => {\n    await storageLocalRemove(GlobalStore.singleScopeRawIndexArr(GlobalStore.globalStorageScope, keys));\n  }\n\n  public static acctEmailsGet = async (): Promise<string[]> => {\n    const storage = await GlobalStore.get(['account_emails']);\n    const acctEmails: string[] = [];\n    if (typeof storage.account_emails !== 'undefined') {\n      for (const acctEmail of JSON.parse(storage.account_emails) as string[]) {\n        if (!acctEmails.includes(acctEmail.toLowerCase())) {\n          acctEmails.push(acctEmail.toLowerCase());\n        }\n      }\n    }\n    return acctEmails;\n  }\n\n  public static acctEmailsAdd = async (acctEmail: string): Promise<void> => { // todo: concurrency issues with another tab loaded at the same time\n    if (!acctEmail) {\n      throw new Error(`attempting to save empty acctEmail: ${acctEmail}`);\n    }\n    if (acctEmail.match(/[A-Z]/)) {\n      Catch.report(`attempting to save acctEmail that wasn't lowercased: ${acctEmail}`);\n      acctEmail = acctEmail.toLowerCase();\n    }\n    const acctEmails = await GlobalStore.acctEmailsGet();\n    if (!acctEmails.includes(acctEmail) && acctEmail) {\n      acctEmails.push(acctEmail);\n      await GlobalStore.set({ account_emails: JSON.stringify(acctEmails) });\n      BrowserMsg.send.bg.updateUninstallUrl();\n    }\n  }\n\n  public static acctEmailsRemove = async (acctEmail: string): Promise<void> => { // todo: concurrency issues with another tab loaded at the same time\n    const acctEmails = await GlobalStore.acctEmailsGet();\n    await GlobalStore.set({ account_emails: JSON.stringify(Value.arr.withoutVal(acctEmails, acctEmail)) });\n    BrowserMsg.send.bg.updateUninstallUrl();\n  }\n}\n",
    "extension/js/common/platform/store/passphrase-store.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { StorageType, AbstractStore } from './abstract-store.js';\nimport { AccountIndex, AcctStore, AcctStoreDict } from './acct-store.js';\nimport { SessionStore } from './session-store.js';\nimport { PromiseCancellation, Dict } from '../../core/common.js';\nimport { Ui } from '../../browser/ui.js';\nimport { OpenPGPKey } from '../../core/crypto/pgp/openpgp-key.js';\n\n/**\n * Local or session store of pass phrases\n */\nexport class PassphraseStore extends AbstractStore {\n\n  /**\n   * todo - make it only accept fingerprints\n   */\n  public static set = async (storageType: StorageType, acctEmail: string, fingerprintOrLongid: string, passphrase: string | undefined) => {\n    const longid = fingerprintOrLongid.length === 40 ? OpenPGPKey.fingerprintToLongid(fingerprintOrLongid) : fingerprintOrLongid;\n    const storageIndex = PassphraseStore.getIndex(longid);\n    if (storageType === 'session') {\n      await SessionStore.set(acctEmail, storageIndex, passphrase);\n    } else {\n      if (typeof passphrase === 'undefined') {\n        await AcctStore.remove(acctEmail, [storageIndex]);\n      } else {\n        const toSave: AcctStoreDict = {};\n        toSave[storageIndex] = passphrase as any;\n        await AcctStore.set(acctEmail, toSave);\n      }\n    }\n  }\n\n  /**\n   * todo - make it only accept fingerprints\n   */\n  public static get = async (acctEmail: string, fingerprintOrLongid: string, ignoreSession: boolean = false): Promise<string | undefined> => {\n    const longid = fingerprintOrLongid.length === 40 ? OpenPGPKey.fingerprintToLongid(fingerprintOrLongid) : fingerprintOrLongid;\n    const storageIndex = PassphraseStore.getIndex(longid);\n    const storage = await AcctStore.get(acctEmail, [storageIndex]);\n    const found = storage[storageIndex];\n    if (typeof found === 'string') {\n      return found;\n    }\n    const fromSession = await SessionStore.get(acctEmail, storageIndex);\n    return fromSession && !ignoreSession ? fromSession : undefined;\n  }\n\n  /**\n   * todo - make it only accept fingerprints\n   */\n  public static waitUntilPassphraseChanged = async (\n    acctEmail: string, missingOrWrongPpKeyLongids: string[], interval = 1000, cancellation: PromiseCancellation = { cancel: false }\n  ): Promise<boolean> => {\n    const missingOrWrongPassprases: Dict<string | undefined> = {};\n    const passphrases = await Promise.all(missingOrWrongPpKeyLongids.map(longid => PassphraseStore.get(acctEmail, longid)));\n    for (const i of missingOrWrongPpKeyLongids.keys()) {\n      missingOrWrongPassprases[missingOrWrongPpKeyLongids[i]] = passphrases[i];\n    }\n    while (!cancellation.cancel) {\n      await Ui.time.sleep(interval);\n      const longidsMissingPp = Object.keys(missingOrWrongPassprases);\n      const updatedPpArr = await Promise.all(longidsMissingPp.map(longid => PassphraseStore.get(acctEmail, longid)));\n      for (let i = 0; i < longidsMissingPp.length; i++) {\n        const missingOrWrongPp = missingOrWrongPassprases[longidsMissingPp[i]];\n        const updatedPp = updatedPpArr[i];\n        if (updatedPp !== missingOrWrongPp) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  private static getIndex = (longid: string): AccountIndex => {\n    return `passphrase_${longid}` as AccountIndex;\n  }\n\n}\n",
    "extension/js/common/platform/store/session-store.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { Env } from '../../browser/env.js';\nimport { BrowserMsg } from '../../browser/browser-msg.js';\nimport { AbstractStore } from './abstract-store.js';\n\n/**\n * Local session store of information to store temporarily, such as pass phrases\n */\nexport class SessionStore extends AbstractStore {\n\n  public static get = async (acctEmail: string, key: string): Promise<string | null> => {\n    if (!Env.isBackgroundPage()) {\n      // session in background page is separated from content script frames\n      // must always go through background page to be consistent\n      return await BrowserMsg.send.bg.await.storeSessionGet({ acctEmail, key });\n    }\n    return window.sessionStorage.getItem(SessionStore.singleScopeRawIndex(acctEmail, key));\n  }\n\n  public static set = async (acctEmail: string, key: string, value: string | undefined): Promise<void> => {\n    if (!Env.isBackgroundPage()) {\n      // session in background page is separated from content script frames\n      // must always go through background page to be consistent\n      return await BrowserMsg.send.bg.await.storeSessionSet({ acctEmail, key, value });\n    }\n    if (typeof value !== 'undefined') { // pass phrases may be stored in session for reuse\n      sessionStorage.setItem(SessionStore.singleScopeRawIndex(acctEmail, key), String(value)); // lgtm [js/clear-text-storage-of-sensitive-data]\n    } else {\n      sessionStorage.removeItem(SessionStore.singleScopeRawIndex(acctEmail, key));\n    }\n  }\n\n}\n",
    "extension/js/common/settings.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Dict, Str, Url, UrlParams } from './core/common.js';\nimport { Ui } from './browser/ui.js';\nimport { Api } from './api/shared/api.js';\nimport { ApiErr, AjaxErr } from './api/shared/api-error.js';\nimport { Attachment } from './core/attachment.js';\nimport { Browser } from './browser/browser.js';\nimport { Buf } from './core/buf.js';\nimport { Catch } from './platform/catch.js';\nimport { Env } from './browser/env.js';\nimport { Gmail } from './api/email-provider/gmail/gmail.js';\nimport { GoogleAuth } from './api/email-provider/gmail/google-auth.js';\nimport { Lang } from './lang.js';\nimport { Key, KeyUtil } from './core/crypto/key.js';\nimport { PgpPwd } from './core/crypto/pgp/pgp-password.js';\nimport { OrgRules } from './org-rules.js';\nimport { Xss } from './platform/xss.js';\nimport { storageLocalGetAll } from './browser/chrome.js';\nimport { AccountIndex, AcctStore, SendAsAlias } from './platform/store/acct-store.js';\nimport { GlobalStore } from './platform/store/global-store.js';\nimport { AbstractStore } from './platform/store/abstract-store.js';\nimport { KeyStore } from './platform/store/key-store.js';\nimport { PassphraseStore } from './platform/store/passphrase-store.js';\n\ndeclare const zxcvbn: Function; // tslint:disable-line:ban-types\n\nexport class Settings {\n\n  public static evalPasswordStrength = (passphrase: string, type: 'passphrase' | 'pwd' = 'passphrase') => {\n    return PgpPwd.estimateStrength(zxcvbn(passphrase, PgpPwd.weakWords()).guesses, type); // tslint:disable-line:no-unsafe-any\n  }\n\n  public static renderSubPage = async (acctEmail: string | undefined, tabId: string, page: string, addUrlTextOrParams?: string | UrlParams) => {\n    await Ui.modal.iframe(\n      Settings.prepareNewSettingsLocationUrl(acctEmail, tabId, page, addUrlTextOrParams),\n      Math.min(800, $('body').width()! - 200),\n      $('body').height()! - ($('body').height()! > 800 ? 150 : 75)\n    );\n  }\n\n  public static redirectSubPage = (acctEmail: string, parentTabId: string, page: string, addUrlTextOrParams?: string | UrlParams) => {\n    window.location.href = Settings.prepareNewSettingsLocationUrl(acctEmail, parentTabId, page, addUrlTextOrParams);\n  }\n\n  public static refreshSendAs = async (acctEmail: string) => {\n    const fetchedSendAs = await Settings.fetchAcctAliasesFromGmail(acctEmail);\n    const result = { defaultEmailChanged: false, aliasesChanged: false, footerChanged: false, sendAs: fetchedSendAs };\n    const { sendAs: storedSendAs } = await AcctStore.get(acctEmail, ['sendAs']);\n    await AcctStore.set(acctEmail, { sendAs: fetchedSendAs });\n    if (!storedSendAs) { // Aliases changed (it was previously undefined)\n      result.aliasesChanged = true;\n      return result;\n    }\n    if (Settings.getDefaultEmailAlias(fetchedSendAs) !== Settings.getDefaultEmailAlias(storedSendAs)) {\n      result.defaultEmailChanged = true;\n    }\n    if (Object.keys(fetchedSendAs).sort().join(',') !== Object.keys(storedSendAs).sort().join(',')) {\n      result.aliasesChanged = true;\n    }\n    const fetchedFooters = Object.keys(fetchedSendAs).sort().map(email => fetchedSendAs[email].footer).join('|');\n    const storedFooters = Object.keys(storedSendAs).sort().map(email => storedSendAs[email].footer).join('|');\n    if (fetchedFooters !== storedFooters) {\n      result.footerChanged = true;\n    }\n    return result.aliasesChanged || result.defaultEmailChanged || result.footerChanged ? result : undefined;\n  }\n\n  public static acctStorageReset = async (acctEmail: string): Promise<void> => {\n    if (!acctEmail) {\n      throw new Error('Missing account_email to reset');\n    }\n    const acctEmails = await GlobalStore.acctEmailsGet();\n    if (!acctEmails.includes(acctEmail)) {\n      throw new Error(`\"${acctEmail}\" is not a known account_email in \"${JSON.stringify(acctEmails)}\"`);\n    }\n    const storageIndexesToRemove: AccountIndex[] = [];\n    const filter = AbstractStore.singleScopeRawIndex(acctEmail, '');\n    if (!filter) {\n      throw new Error('Filter is empty for account_email\"' + acctEmail + '\"');\n    }\n    return await new Promise((resolve, reject) => {\n      chrome.storage.local.get(async storage => {\n        try {\n          for (const storageIndex of Object.keys(storage)) {\n            if (storageIndex.indexOf(filter) === 0) {\n              storageIndexesToRemove.push(storageIndex.replace(filter, '') as AccountIndex);\n            }\n          }\n          await AcctStore.remove(acctEmail, storageIndexesToRemove);\n          for (const sessionStorageIndex of Object.keys(sessionStorage)) {\n            if (sessionStorageIndex.indexOf(filter) === 0) {\n              sessionStorage.removeItem(sessionStorageIndex);\n            }\n          }\n          resolve();\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n\n  public static acctStorageChangeEmail = async (oldAcctEmail: string, newAcctEmail: string) => {\n    if (!oldAcctEmail || !newAcctEmail || !Str.isEmailValid(newAcctEmail)) {\n      throw new Error('Missing or wrong account_email to reset');\n    }\n    const acctEmails = await GlobalStore.acctEmailsGet();\n    if (!acctEmails.includes(oldAcctEmail)) {\n      throw new Error(`\"${oldAcctEmail}\" is not a known account_email in \"${JSON.stringify(acctEmails)}\"`);\n    }\n    const storageIndexesToChange: string[] = [];\n    const oldAcctEmailIndexPrefix = AbstractStore.singleScopeRawIndex(oldAcctEmail, '');\n    const newAcctEmailIndexPrefix = AbstractStore.singleScopeRawIndex(newAcctEmail, '');\n    // in case the destination email address was already set up with an account, recover keys and pass phrases before it's overwritten\n    const destAccountPrivateKeys = await KeyStore.get(newAcctEmail);\n    const destAcctPassPhrases: Dict<string> = {};\n    for (const ki of destAccountPrivateKeys) {\n      const pp = await PassphraseStore.get(newAcctEmail, ki.fingerprints[0], true);\n      if (pp) {\n        destAcctPassPhrases[ki.fingerprints[0]] = pp;\n      }\n    }\n    if (!oldAcctEmailIndexPrefix) {\n      throw new Error(`Filter is empty for account_email \"${oldAcctEmail}\"`);\n    }\n    await GlobalStore.acctEmailsAdd(newAcctEmail);\n    const storage = await storageLocalGetAll();\n    for (const key of Object.keys(storage)) {\n      if (key.indexOf(oldAcctEmailIndexPrefix) === 0) {\n        storageIndexesToChange.push(key.replace(oldAcctEmailIndexPrefix, ''));\n      }\n    }\n    const oldAcctStorage = await AcctStore.get(oldAcctEmail, storageIndexesToChange as any);\n    await AcctStore.set(newAcctEmail, oldAcctStorage);\n    for (const sessionStorageIndex of Object.keys(sessionStorage)) {\n      if (sessionStorageIndex.indexOf(oldAcctEmailIndexPrefix) === 0) {\n        const v = sessionStorage.getItem(sessionStorageIndex);\n        sessionStorage.setItem(sessionStorageIndex.replace(oldAcctEmailIndexPrefix, newAcctEmailIndexPrefix), v!);\n        sessionStorage.removeItem(sessionStorageIndex);\n      }\n    }\n    for (const ki of destAccountPrivateKeys) {\n      await KeyStore.add(newAcctEmail, ki.private);\n    }\n    for (const fingerprint of Object.keys(destAcctPassPhrases)) {\n      await PassphraseStore.set('local', newAcctEmail, fingerprint, destAcctPassPhrases[fingerprint]);\n    }\n    await Settings.acctStorageReset(oldAcctEmail);\n    await GlobalStore.acctEmailsRemove(oldAcctEmail);\n  }\n\n  public static renderPrvCompatFixUiAndWaitTilSubmittedByUser = async (\n    acctEmail: string, containerStr: string | JQuery<HTMLElement>, origPrv: Key, passphrase: string, backUrl: string\n  ): Promise<Key> => {\n    const uids = origPrv.identities;\n    if (!uids.length) {\n      uids.push(acctEmail);\n    }\n    const container = $(containerStr as JQuery<HTMLElement>); // due to JQuery TS quirk\n    Xss.sanitizeRender(container, [\n      `<div class=\"line\">${Lang.setup.prvHasFixableCompatIssue}</div>`,\n      '<div class=\"line compatibility_fix_user_ids\">' + uids.map(uid => '<div>' + Xss.escape(uid) + '</div>').join('') + '</div>',\n      '<div class=\"line\">',\n      '  Choose expiration of updated key',\n      '  <select class=\"input_fix_expire_years\" data-test=\"input-compatibility-fix-expire-years\">',\n      '    <option  value=\"\" disabled selected>please choose expiration</option>',\n      '    <option value=\"never\">no expiration</option>',\n      '    <option value=\"1\">1 year</option>',\n      '    <option value=\"2\">2 years</option>',\n      '    <option value=\"3\">3 years</option>',\n      '    <option value=\"5\">5 years</option>',\n      '  </select>',\n      '</div>',\n      '<div class=\"line\">FlowCrypt will attempt to update the key before importing.</div>',\n      '<div class=\"line\">',\n      '  <button class=\"button long gray action_fix_compatibility\" data-test=\"action-fix-and-import-key\">UPDATE AND IMPORT KEY</button>',\n      '</div>',\n    ].join('\\n'));\n    container.find('select.input_fix_expire_years').change(Ui.event.handle(target => {\n      if ($(target).val()) {\n        (container as JQuery<HTMLElement>).find('.action_fix_compatibility').removeClass('gray').addClass('green');\n      } else {\n        (container as JQuery<HTMLElement>).find('.action_fix_compatibility').removeClass('green').addClass('gray');\n      }\n    }));\n    return await new Promise((resolve, reject) => {\n      container.find('.action_fix_compatibility').click(Ui.event.handle(async target => {\n        const expireYears = String($(target).parents(container as any).find('select.input_fix_expire_years').val()); // JQuery quirk\n        if (!expireYears) {\n          await Ui.modal.warning('Please select key expiration');\n        } else {\n          $(target).off();\n          Xss.sanitizeRender(target, Ui.spinner('white'));\n          const expireSeconds = (expireYears === 'never') ? 0 : Math.floor((Date.now() - origPrv.created) / 1000) + (60 * 60 * 24 * 365 * Number(expireYears));\n          await KeyUtil.decrypt(origPrv, passphrase);\n          let reformatted;\n          const userIds = uids.map(uid => Str.parseEmail(uid)).map(u => ({ email: u.email, name: u.name || '' }));\n          try {\n            reformatted = await KeyUtil.reformatKey(origPrv, passphrase, userIds, expireSeconds);\n          } catch (e) {\n            reject(e);\n            return;\n          }\n          if (!reformatted.fullyEncrypted) { // this is a security precaution, in case OpenPGP.js library changes in the future\n            Catch.report(`Key update: Key not fully encrypted after update`, { isFullyEncrypted: reformatted.fullyEncrypted, isFullyDecrypted: reformatted.fullyDecrypted });\n            await Ui.modal.error('Key update:Key not fully encrypted after update. Please contact human@flowcrypt.com');\n            Xss.sanitizeReplace(target, Ui.e('a', { href: backUrl, text: 'Go back and try something else' }));\n            return;\n          }\n          if (reformatted.usableForEncryption) {\n            resolve(reformatted);\n          } else {\n            await Ui.modal.error('Key update: Key still cannot be used for encryption. This looks like a compatibility issue.\\n\\nPlease write us at human@flowcrypt.com.');\n            Xss.sanitizeReplace(target, Ui.e('a', { href: backUrl, text: 'Go back and try something else' }));\n          }\n        }\n      }));\n    });\n  }\n\n  public static retryUntilSuccessful = async (action: () => Promise<void>, errTitle: string) => {\n    try {\n      await action();\n    } catch (e) {\n      return await Settings.promptToRetry(e, errTitle, action);\n    }\n  }\n\n  /**\n   * todo - could probably replace most usages of this method with retryPromptUntilSuccessful which is more intuitive\n   */\n  public static promptToRetry = async (lastErr: any, userMsg: string, retryCb: () => Promise<void>): Promise<void> => {\n    let userErrMsg = `${userMsg} ${ApiErr.eli5(lastErr)}`;\n    if (lastErr instanceof AjaxErr && (lastErr.status === 400 || lastErr.status === 405)) {\n      // this will make reason for err 400 obvious to user - eg on EKM 405 error\n      userErrMsg = `${userMsg}, ${lastErr.resMsg}`;\n    }\n    while (await Ui.renderOverlayPromptAwaitUserChoice({ retry: {} }, userErrMsg, ApiErr.detailsAsHtmlWithNewlines(lastErr)) === 'retry') {\n      try {\n        return await retryCb();\n      } catch (e2) {\n        lastErr = e2;\n        if (ApiErr.isSignificant(e2)) {\n          Catch.reportErr(e2);\n        }\n      }\n    }\n    // pressing retry button causes to get stuck in while loop until success, at which point it returns, or until user closes tab\n    // if it got down here, user has chosen 'skip'. This option is only available on 'OPTIONAL' type\n    // if the error happens again, op will be skipped\n    return await retryCb();\n  }\n\n  public static forbidAndRefreshPageIfCannot = async (action: 'CREATE_KEYS' | 'BACKUP_KEYS', orgRules: OrgRules) => {\n    if (action === 'CREATE_KEYS' && !orgRules.canCreateKeys()) {\n      await Ui.modal.error(Lang.setup.creatingKeysNotAllowedPleaseImport);\n      window.location.reload();\n      throw new Error('creating_keys_not_allowed_please_import');\n    } else if (action === 'BACKUP_KEYS' && !orgRules.canBackupKeys()) {\n      await Ui.modal.error(Lang.setup.keyBackupsNotAllowed);\n      window.location.reload();\n      throw new Error('key_backups_not_allowed');\n    }\n  }\n\n  public static newGoogleAcctAuthPromptThenAlertOrForward = async (settingsTabId: string | undefined, acctEmail?: string, scopes?: string[]) => {\n    try {\n      const response = await GoogleAuth.newAuthPopup({ acctEmail, scopes });\n      if (response.result === 'Success' && response.acctEmail) {\n        await GlobalStore.acctEmailsAdd(response.acctEmail);\n        const storage = await AcctStore.get(response.acctEmail, ['setup_done']);\n        if (storage.setup_done) { // this was just an additional permission\n          await Ui.modal.info('You\\'re all set.');\n          window.location.href = Url.create('/chrome/settings/index.htm', { acctEmail: response.acctEmail });\n        } else {\n          await AcctStore.set(response.acctEmail, { email_provider: 'gmail' });\n          window.location.href = Url.create('/chrome/settings/setup.htm', { acctEmail: response.acctEmail, idToken: response.id_token });\n        }\n      } else if (response.result === 'Denied' || response.result === 'Closed') {\n        const authDeniedHtml = await Api.ajax({ url: '/chrome/settings/modules/auth_denied.htm' }, Catch.stackTrace()) as string; // tslint:disable-line:no-direct-ajax\n        if (await Ui.modal.confirm(authDeniedHtml, true)) {\n          await Settings.newGoogleAcctAuthPromptThenAlertOrForward(settingsTabId, acctEmail, scopes);\n        }\n      } else {\n        Catch.report('failed to log into google in newGoogleAcctAuthPromptThenAlertOrForward', response);\n        await Ui.modal.error(`Failed to connect to Gmail(new). If this happens repeatedly, please write us at human@flowcrypt.com to fix it.\\n\\n[${response.result}] ${response.error}`);\n        await Ui.time.sleep(1000);\n        window.location.reload();\n      }\n    } catch (e) {\n      if (ApiErr.isNetErr(e)) {\n        await Ui.modal.error('Could not complete due to network error. Please try again.');\n      } else if (ApiErr.isMailOrAcctDisabledOrPolicy(e)) {\n        await Ui.modal.error('Your Google account or Gmail service is disabled. Please check your Google account settings.');\n      } else {\n        Catch.reportErr(e);\n        await Ui.modal.error(`Unknown error happened when connecting to Google: ${String(e)}`);\n      }\n      await Ui.time.sleep(1000);\n      window.location.reload();\n    }\n  }\n\n  public static populateAccountsMenu = async (page: 'index.htm' | 'inbox.htm') => {\n    const menuAcctHtml = (email: string, picture = '/img/svgs/profile-icon.svg', isHeaderRow: boolean) => {\n      return [\n        `<a href=\"#\" ${isHeaderRow && 'id = \"header-row\"'} class=\"row alt-accounts action_select_account\">`,\n        `  <div class=\"col-2\"><img class=\"profile-img\" src=\"${Xss.escape(picture)}\" alt=\"\"></div>`,\n        '  <div class=\"col-10 text-left\">',\n        `    <div class=\"contains_email\" data-test=\"action-switch-to-account\">${Xss.escape(email)}</div>`,\n        '  </div>',\n        '</a>',\n      ].join('');\n    };\n    const acctEmails = await GlobalStore.acctEmailsGet();\n    const acctStorages = await AcctStore.getAccounts(acctEmails, ['picture', 'setup_done']);\n    for (const email of acctEmails) {\n      Xss.sanitizePrepend('#alt-accounts', menuAcctHtml(email, acctStorages[email].picture, page === 'inbox.htm'));\n    }\n    $('#alt-accounts img.profile-img').on('error', Ui.event.handle(self => {\n      $(self).off().attr('src', '/img/svgs/profile-icon.svg');\n    }));\n    $('.action_select_account').click(Ui.event.handle((target, event) => {\n      event.preventDefault();\n      const acctEmail = $(target).find('.contains_email').text();\n      const acctStorage = acctStorages[acctEmail];\n      window.location.href = acctStorage.setup_done\n        ? Url.create(page, { acctEmail })\n        : Url.create(Env.getBaseUrl() + '/chrome/settings/index.htm', { acctEmail });\n    }));\n  }\n\n  public static offerToLoginWithPopupShowModalOnErr = (acctEmail: string, then: (() => void) = () => undefined, prepend = '') => {\n    (async () => {\n      if (await Ui.modal.confirm(`${prepend}Please log in with FlowCrypt to continue.`)) {\n        await Settings.loginWithPopupShowModalOnErr(acctEmail, then);\n      }\n    })().catch(Catch.reportErr);\n  }\n\n  public static loginWithPopupShowModalOnErr = async (acctEmail: string, then: (() => void) = () => undefined) => {\n    if (window !== window.top && !chrome.windows) { // Firefox, chrome.windows isn't available in iframes\n      Browser.openExtensionTab(Url.create(chrome.runtime.getURL(`chrome/settings/index.htm`), { acctEmail }));\n      await Ui.modal.info(`Reload after logging in.`);\n      return window.location.reload();\n    }\n    const authRes = await GoogleAuth.newOpenidAuthPopup({ acctEmail });\n    if (authRes.result === 'Success' && authRes.acctEmail && authRes.id_token) {\n      then();\n    } else {\n      await Ui.modal.warning(`Could not log in:\\n${authRes.error || authRes.result}`);\n    }\n  }\n\n  public static resetAccount = async (acctEmail: string): Promise<boolean> => {\n    if (await Ui.modal.confirm(Lang.setup.confirmResetAcct(acctEmail))) {\n      await Settings.collectInfoAndDownloadBackupFile(acctEmail);\n      if (await Ui.modal.confirm('Proceed to reset? Don\\'t come back telling me I didn\\'t warn you.')) {\n        await Settings.acctStorageReset(acctEmail);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public static collectInfoAndDownloadBackupFile = async (acctEmail: string) => {\n    const name = `FlowCrypt_BACKUP_FILE_${acctEmail.replace(/[^a-z0-9]+/, '')}.txt`;\n    const backupText = await Settings.collectInfoForAccountBackup(acctEmail);\n    Browser.saveToDownloads(new Attachment({ name, type: 'text/plain', data: Buf.fromUtfStr(backupText) }));\n    await Ui.delay(1000);\n  }\n\n  private static collectInfoForAccountBackup = async (acctEmail: string) => {\n    const text = [\n      'This file contains sensitive information, please put it in a safe place.',\n      '',\n      'DO NOT DISPOSE OF THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING',\n      '',\n      'NOTE DOWN YOUR PASS PHRASE IN A SAFE PLACE THAT YOU CAN FIND LATER',\n      '',\n      'If this key was registered on a keyserver (typically they are), you will need this same key (and pass phrase!) to replace it.',\n      'In other words, losing this key or pass phrase may cause people to have trouble writing you encrypted emails, even if you use another key (on FlowCrypt or elsewhere) later on!',\n      '',\n      'acctEmail: ' + acctEmail,\n    ];\n    const globalStorage = await GlobalStore.get(['version']);\n    const acctStorage = await AcctStore.get(acctEmail, ['setup_date', 'full_name']);\n    text.push('global_storage: ' + JSON.stringify(globalStorage));\n    text.push('account_storage: ' + JSON.stringify(acctStorage));\n    text.push('');\n    const keyinfos = await KeyStore.get(acctEmail);\n    for (const keyinfo of keyinfos) {\n      text.push('');\n      text.push('key_longid: ' + keyinfo.longid);\n      text.push(keyinfo.private);\n    }\n    text.push('');\n    return text.join('\\n');\n  }\n\n  private static prepareNewSettingsLocationUrl = (acctEmail: string | undefined, parentTabId: string, page: string, addUrlTextOrParams?: string | UrlParams): string => {\n    const pageParams: UrlParams = { placement: 'settings', parentTabId };\n    if (acctEmail) {\n      pageParams.acctEmail = acctEmail;\n    }\n    if (typeof addUrlTextOrParams === 'object' && addUrlTextOrParams) { // it's a list of params - add them. It could also be a text - then it will be added the end of url below\n      for (const k of Object.keys(addUrlTextOrParams)) {\n        pageParams[k] = addUrlTextOrParams[k];\n      }\n      addUrlTextOrParams = undefined;\n    }\n    return Url.create(page, pageParams) + (addUrlTextOrParams || '');\n  }\n\n  private static getDefaultEmailAlias = (sendAs: Dict<SendAsAlias>) => {\n    for (const key of Object.keys(sendAs)) {\n      if (sendAs[key] && sendAs[key].isDefault) {\n        return key;\n      }\n    }\n    return undefined;\n  }\n\n  private static fetchAcctAliasesFromGmail = async (acctEmail: string): Promise<Dict<SendAsAlias>> => {\n    const response = await new Gmail(acctEmail).fetchAcctAliases();\n    const validAliases = response.sendAs.filter(alias => alias.isPrimary || alias.verificationStatus === 'accepted');\n    const result: Dict<SendAsAlias> = {};\n    for (const a of validAliases) {\n      result[a.sendAsEmail.toLowerCase()] = { name: a.displayName, isPrimary: !!a.isPrimary, isDefault: a.isDefault, footer: a.signature };\n    }\n    return result;\n  }\n\n}\n",
    "extension/js/common/ui/attachment-ui.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Attachment } from '../core/attachment.js';\nimport { Catch, UnreportableError } from '../platform/catch.js';\nimport { Dict } from '../core/common.js';\nimport { MsgUtil } from '../core/crypto/pgp/msg-util.js';\nimport { Ui } from '../browser/ui.js';\nimport { PubkeyResult, KeyUtil } from '../core/crypto/key.js';\n\ndeclare const qq: any;\n\nexport type AttachmentLimits = { count?: number, size?: number, sizeMb?: number, oversize?: (newFileSize: number) => Promise<void> };\ntype AttachmentUICallbacks = {\n  attachmentAdded?: (r: Attachment) => Promise<void>,\n  uiChanged?: () => void,\n};\n\nclass CancelAttachmentSubmit extends Error { }\n\nexport class AttachmentUI {\n\n  private templatePath = '/chrome/elements/shared/attach.template.htm';\n  private getLimits: () => Promise<AttachmentLimits>;\n  private attachedFiles: Dict<File> = {};\n  private uploader: any = undefined;\n  private callbacks: AttachmentUICallbacks = {};\n\n  constructor(getLimits: () => Promise<AttachmentLimits>) {\n    this.getLimits = getLimits;\n  }\n\n  public initAttachmentDialog = (elId: string, btnId: string, callbacks: AttachmentUICallbacks = {}) => {\n    this.callbacks = callbacks;\n    $('#qq-template').load(this.templatePath, () => {\n      const config = {\n        autoUpload: false,\n        // debug: true,\n        element: $('#' + elId).get(0),\n        button: $('#' + btnId).get(0),\n        dragAndDrop: {\n          extraDropzones: $('#input_text'),\n        },\n        callbacks: {\n          onSubmit: (uploadFileId: string) => this.processNewAttachment(uploadFileId),\n          onCancel: (uploadFileId: string) => this.cancelAttachment(uploadFileId),\n        },\n      };\n      this.uploader = new qq.FineUploader(config); // tslint:disable-line:no-unsafe-any\n      this.setInputAttributes();\n    });\n  }\n\n  public setInputAttributes = (): HTMLInputElement => {\n    const input: HTMLInputElement = this.uploader._buttons[0].getInput(); // tslint:disable-line:no-unsafe-any\n    input.setAttribute('title', 'Attach a file');\n    input.setAttribute('tabindex', '8');\n    input.setAttribute('data-test', 'action-attach-files');\n    return input;\n  }\n\n  public hasAttachment = () => {\n    return Object.keys(this.attachedFiles).length > 0;\n  }\n\n  public getAttachmentIds = () => {\n    return Object.keys(this.attachedFiles);\n  }\n\n  public collectAttachment = async (uploadFileId: string) => {\n    const fileData = await this.readAttachmentDataAsUint8(uploadFileId);\n    return new Attachment({ name: this.attachedFiles[uploadFileId].name, type: this.attachedFiles[uploadFileId].type, data: fileData });\n  }\n\n  public collectAttachments = async () => {\n    const attachments: Attachment[] = [];\n    for (const uploadFileId of Object.keys(this.attachedFiles)) {\n      attachments.push(await this.collectAttachment(uploadFileId));\n    }\n    return attachments;\n  }\n\n  public collectEncryptAttachments = async (pubs: PubkeyResult[]): Promise<Attachment[]> => {\n    const attachments: Attachment[] = [];\n    for (const uploadFileId of Object.keys(this.attachedFiles)) {\n      const file = this.attachedFiles[uploadFileId];\n      const data = await this.readAttachmentDataAsUint8(uploadFileId);\n      const pubsForEncryption = KeyUtil.choosePubsBasedOnKeyTypeCombinationForPartialSmimeSupport(pubs);\n      if (pubs.find(pub => pub.pubkey.type === 'x509')) {\n        throw new UnreportableError('Attachments are not yet supported when sending to recipients using S/MIME x509 certificates.');\n      }\n      const encrypted = await MsgUtil.encryptMessage({ pubkeys: pubsForEncryption, data, filename: file.name, armor: false }) as OpenPGP.EncryptBinaryResult;\n      attachments.push(new Attachment({ name: Attachment.sanitizeName(file.name) + '.pgp', type: file.type, data: encrypted.message.packets.write() }));\n    }\n    return attachments;\n  }\n\n  public clearAllAttachments = () => {\n    this.attachedFiles = {};\n  }\n\n  public addFile = (file: File) => {\n    this.uploader.addFiles([file]); // tslint:disable-line: no-unsafe-any\n  }\n\n  private cancelAttachment = (uploadFileId: string) => {\n    delete this.attachedFiles[uploadFileId];\n    if (this.callbacks.uiChanged) {\n      // run at next event loop cycle - let DOM changes render first\n      // this allows code that relies on this to evaluate the DOM after the file has been removed from it\n      Catch.setHandledTimeout(this.callbacks.uiChanged, 0);\n    }\n  }\n\n  private processNewAttachment = async (uploadFileId: string) => {\n    const limits = await this.getLimits();\n    if (limits.count && Object.keys(this.attachedFiles).length >= limits.count) {\n      const msg = `Amount of attached files is limited to ${limits.count}`;\n      await Ui.modal.warning(msg);\n      throw new CancelAttachmentSubmit(msg);\n    }\n    const newFile: File = this.uploader.getFile(uploadFileId); // tslint:disable-line:no-unsafe-any\n    if (limits.size && this.getFileSizeSum() + newFile.size > limits.size) {\n      const msg = `Combined file size is limited to ${limits.sizeMb} MB`;\n      if (typeof limits.oversize === 'function') {\n        await limits.oversize(this.getFileSizeSum() + newFile.size);\n      } else {\n        await Ui.modal.warning(msg);\n      }\n      throw new CancelAttachmentSubmit(msg);\n    }\n    this.attachedFiles[uploadFileId] = newFile;\n    if (typeof this.callbacks.attachmentAdded === 'function') {\n      const a = await this.collectAttachment(uploadFileId);\n      await this.callbacks.attachmentAdded(a);\n      const input = this.setInputAttributes();\n      input.focus();\n    }\n    if (this.callbacks.uiChanged) {\n      // run at next event loop cycle - let DOM changes render first\n      // this allows code that relies on this to evaluate the DOM after the file has been removed from it\n      Catch.setHandledTimeout(this.callbacks.uiChanged, 0);\n    }\n    return true;\n  }\n\n  private getFileSizeSum = () => {\n    let sum = 0;\n    for (const file of Object.values(this.attachedFiles)) {\n      sum += file.size;\n    }\n    return sum;\n  }\n\n  private readAttachmentDataAsUint8 = async (uploadFileId: string): Promise<Uint8Array> => {\n    return await new Promise(resolve => {\n      const reader = new FileReader();\n      reader.onload = () => {\n        resolve(new Uint8Array(reader.result as ArrayBuffer)); // that's what we're getting\n      };\n      reader.readAsArrayBuffer(this.attachedFiles[uploadFileId]);\n    });\n  }\n\n}\n",
    "extension/js/common/ui/attachment_preview_pdf.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Catch } from '../platform/catch.js';\nimport { PDFDocumentProxy } from '../../../types/pdf.js';\n\nexport class AttachmentPreviewPdf {\n\n  private attachmentPreviewContainer: JQuery<HTMLElement>;\n  private pdf: PDFDocumentProxy;\n  private currentZoomLevel: number;\n  private zoomLevels: number[];\n  private fitToWidthZoomLevelDetected: boolean;\n  private fitToWidthZoomLevel: number;\n\n  constructor(attachmentPreviewContainer: JQuery<HTMLElement>, pdf: PDFDocumentProxy) {\n    this.attachmentPreviewContainer = attachmentPreviewContainer;\n    this.pdf = pdf;\n    this.currentZoomLevel = 1;\n    this.zoomLevels = [1, 1.25, 1.5, 2, 3, 4, 5];\n    this.fitToWidthZoomLevelDetected = false;\n    this.fitToWidthZoomLevel = 1;\n  }\n\n  public render = async () => {\n    this.attachmentPreviewContainer.find('*:not(.attachment-preview-pdf-page)').remove();\n    this.attachmentPreviewContainer.addClass('attachment-preview-pdf');\n    await this.renderPdf();\n    this.renderControls();\n  }\n\n  private renderPdf = async (zoomLevelDiff?: number) => {\n    const container = this.attachmentPreviewContainer;\n    for (let pageNumber = 1; pageNumber <= this.pdf.numPages; pageNumber++) {\n      let pageCanvas;\n      // use existed page, or create a new one for the first render\n      if (container.find(`.attachment-preview-pdf-page[data-page-number=\"${pageNumber}\"]`).length) {\n        pageCanvas = container.find(`.attachment-preview-pdf-page[data-page-number=\"${pageNumber}\"]`);\n      } else {\n        pageCanvas = $(`<canvas class=\"attachment-preview-pdf-page\" data-page-number=\"${pageNumber}\"></canvas>`);\n        container.append(pageCanvas); // xss-escaped\n      }\n      // remove margins from first and last pages\n      if (pageNumber === 1) {\n        pageCanvas.css('margin-top', 0);\n      }\n      if (pageNumber === this.pdf.numPages) {\n        pageCanvas.css('margin-bottom', 0);\n      }\n      // render PDF page\n      await this.renderPage(this.pdf, pageNumber, pageCanvas.get(0) as HTMLCanvasElement);\n      // adjust horizontal scrollings to keep the document center\n      if (pageNumber === 1 && zoomLevelDiff) {\n        container[0].scrollLeft += (container[0].scrollLeft + container[0].clientWidth / 2) * zoomLevelDiff;\n      }\n    }\n  }\n\n  private renderPage = async (pdf: PDFDocumentProxy, pageNumber: number, canvas: HTMLCanvasElement) => {\n    const page = await pdf.getPage(pageNumber);\n    const viewport = page.getViewport({ scale: this.currentZoomLevel });\n    canvas.height = viewport.height;\n    canvas.width = viewport.width;\n    await page.render({ canvasContext: canvas.getContext('2d') as CanvasRenderingContext2D, viewport }).promise;\n  }\n\n  private renderControls = () => {\n    const controls = $(`\n      <div id=\"pdf-preview-controls\">\n        <div id=\"pdf-preview-page\">\n          Page\n          <span id=\"pdf-preview-current-page-number\">1</span>\n          <span id=\"pdf-preview-page-slash\">/</span>\n          <span id=\"pdf-preview-total-pages-number\">${this.pdf.numPages}</span>\n        </div>\n        <div id=\"pdf-preview-zoom\">\n          <button id=\"pdf-preview-zoom-out\" title=\"Zoom out\" disabled><img src=\"/img/svgs/minus-solid.svg\" width=\"20\"></button>\n          <button id=\"pdf-preview-fit-to-width\" title=\"Fit to width\"><img src=\"/img/svgs/zoom-in.svg\" width=\"20\"></button>\n          <button id=\"pdf-preview-reset-zoom\" title=\"Reset zoom\" style=\"display: none\"><img src=\"/img/svgs/zoom-out.svg\" width=\"20\"></button>\n          <button id=\"pdf-preview-zoom-in\" title=\"Zoom in\"><img src=\"/img/svgs/plus-solid.svg\" width=\"20\"></button>\n        </div>\n      </div>\n    `);\n    this.attachmentPreviewContainer.append(controls); // xss-escaped\n    // Page X of Y\n    this.attachmentPreviewContainer.on('scroll', () => {\n      const pageHeight = this.attachmentPreviewContainer.find('canvas').outerHeight(true) as number;\n      const scrollTop = this.attachmentPreviewContainer.scrollTop() as number;\n      const currentPage = Math.round(scrollTop / pageHeight) + 1;\n      this.attachmentPreviewContainer.find('#pdf-preview-current-page-number').text(currentPage);\n    });\n    // Zoom in, zoom out, fit to width, reset zoom\n    this.handleZoom();\n  }\n\n  private handleZoom = () => {\n    const container = this.attachmentPreviewContainer;\n    // zoom in\n    container.find('#pdf-preview-zoom-in').on('click', async () => {\n      await this.reRenderWithNewZoomLevel(this.zoomLevels[this.zoomLevels.indexOf(this.currentZoomLevel) + 1]);\n      container.find('#pdf-preview-reset-zoom').css('display', 'block');\n      container.find('#pdf-preview-fit-to-width').css('display', 'none');\n    });\n    // zoom out\n    container.find('#pdf-preview-zoom-out').on('click', async () => {\n      await this.reRenderWithNewZoomLevel(this.zoomLevels[this.zoomLevels.indexOf(this.currentZoomLevel) - 1]);\n      if (this.currentZoomLevel === 1) {\n        container.find('#pdf-preview-reset-zoom').css('display', 'none');\n        container.find('#pdf-preview-fit-to-width').css('display', 'block');\n      } else {\n        container.find('#pdf-preview-reset-zoom').css('display', 'block');\n        container.find('#pdf-preview-fit-to-width').css('display', 'none');\n      }\n    });\n    // reset zoom\n    container.find('#pdf-preview-reset-zoom').on('click', async () => {\n      await this.reRenderWithNewZoomLevel(1);\n      container.find('#pdf-preview-reset-zoom').css('display', 'none');\n      container.find('#pdf-preview-fit-to-width').css('display', 'block');\n    });\n    // fit to width\n    container.find('#pdf-preview-fit-to-width').on('click', async () => {\n      if (!this.fitToWidthZoomLevelDetected) {\n        let containerWidth = container.width() as number;\n        if (Catch.browser().name === 'firefox') {\n          containerWidth -= this.getScrollbarWidth();\n        }\n        this.fitToWidthZoomLevel = containerWidth / (container.find('.attachment-preview-pdf-page').width() as number);\n        this.zoomLevels.push(this.fitToWidthZoomLevel);\n        this.zoomLevels = this.zoomLevels.sort();\n        this.fitToWidthZoomLevelDetected = true;\n      }\n      await this.reRenderWithNewZoomLevel(this.fitToWidthZoomLevel);\n      container.find('#pdf-preview-reset-zoom').css('display', 'block');\n      container.find('#pdf-preview-fit-to-width').css('display', 'none');\n    });\n  }\n\n  private reRenderWithNewZoomLevel = async (newZoomLevel: number) => {\n    const container = this.attachmentPreviewContainer;\n    const zoomLevelDiff = (newZoomLevel - this.currentZoomLevel) / this.currentZoomLevel;\n    this.currentZoomLevel = newZoomLevel;\n    await this.renderPdf(zoomLevelDiff);\n    container.find('#pdf-preview-zoom-in, #pdf-preview-zoom-out').prop('disabled', true);\n    if (this.currentZoomLevel > 1) {\n      container.find('#pdf-preview-zoom-out').prop('disabled', false);\n    }\n    if (this.currentZoomLevel < 5) {\n      container.find('#pdf-preview-zoom-in').prop('disabled', false);\n    }\n  }\n\n  // borrowed from https://github.com/twbs/bootstrap/blob/master/js/src/modal.js\n  private getScrollbarWidth = (): number => {\n    const scrollDiv = $('<div class=\"scrollbar-measure\"></div>');\n    $('body').append(scrollDiv); // xss-escaped\n    const scrollbarWidth = scrollDiv[0].getBoundingClientRect().width - scrollDiv[0].clientWidth;\n    scrollDiv.remove();\n    return scrollbarWidth;\n  }\n\n}",
    "extension/js/common/ui/fetch-key-ui.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { BrowserMsg } from '../browser/browser-msg.js';\nimport { Catch } from '../platform/catch.js';\nimport { KeyImportUi } from './key-import-ui.js';\nimport { Ui } from '../browser/ui.js';\n\nexport class FetchKeyUI {\n  public handleOnPaste = (elem: JQuery<HTMLElement>) => {\n    elem.on('paste', Ui.event.handle(async (elem: HTMLInputElement, event) => {\n      const clipboardEvent = event.originalEvent as ClipboardEvent;\n      if (clipboardEvent.clipboardData) {\n        const possiblyURL = clipboardEvent.clipboardData.getData('text');\n        const pattern = /(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#:.?+=&%@!\\-\\/]))?/;\n        if (pattern.test(possiblyURL)) {\n          const pubkey = await this.fetchPubkey(possiblyURL);\n          if (pubkey) {\n            elem.value = pubkey;\n          }\n        }\n      }\n    }));\n  }\n\n  private fetchPubkey = async (url: string) => {\n    try {\n      // tslint:disable-next-line: no-direct-ajax\n      const result = (await BrowserMsg.send.bg.await.ajax({ req: { url, type: 'GET', dataType: 'text', async: true }, stack: Catch.stackTrace() })) as string;\n      const keyImportUi = new KeyImportUi({ checkEncryption: true });\n      return await keyImportUi.checkPub(result);\n    } catch (e) {\n      return;\n    }\n  }\n}\n",
    "extension/js/common/ui/key-import-ui.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { AttachmentUI } from './attachment-ui.js';\nimport { Catch } from '../platform/catch.js';\nimport { KeyBlockType } from '../core/msg-block.js';\nimport { Lang } from '../lang.js';\nimport { MsgBlockParser } from '../core/msg-block-parser.js';\nimport { PgpArmor } from '../core/crypto/pgp/pgp-armor.js';\nimport { Key, KeyUtil } from '../core/crypto/key.js';\nimport { PgpPwd } from '../core/crypto/pgp/pgp-password.js';\nimport { Settings } from '../settings.js';\nimport { Ui } from '../browser/ui.js';\nimport { Url, Str } from '../core/common.js';\nimport { opgp } from '../core/crypto/pgp/openpgpjs-custom.js';\nimport { KeyStore } from '../platform/store/key-store.js';\n\ntype KeyImportUiCheckResult = { normalized: string; passphrase: string; fingerprint: string; decrypted: Key; encrypted: Key; };\n\nexport class KeyCanBeFixed extends Error {\n  public encrypted: Key;\n  constructor(encrypted: Key) {\n    super();\n    this.encrypted = encrypted;\n  }\n}\n\nexport class UserAlert extends Error { }\n\nexport class KeyImportUi {\n\n  private expectedLongid?: string;\n  private rejectKnown: boolean;\n  private checkEncryption: boolean;\n  private checkSigning: boolean;\n\n  public static normalizeFingerprintOrLongId = (fingerprintOrLongid: string) => {\n    let result = fingerprintOrLongid.trim().replace(/0x|\\s|:|-/g, '').toUpperCase();\n    if (result.length >= 40) {\n      result = result.substring(result.length - 40);\n      if (result.match(/[A-F0-9]{40}/g)) {\n        return result; // fingerprint\n      }\n    }\n    if (result.length >= 16) {\n      result = result.substring(result.length - 16);\n      if (result.match(/[A-F0-9]{16}/g)) {\n        return result; // longid\n      }\n    }\n    return;\n  }\n\n  constructor(o: { rejectKnown?: boolean, checkEncryption?: boolean, checkSigning?: boolean }) {\n    this.rejectKnown = o.rejectKnown === true;\n    this.checkEncryption = o.checkEncryption === true;\n    this.checkSigning = o.checkSigning === true;\n  }\n  public onBadPassphrase: VoidCallback = () => undefined;\n\n  public initPrvImportSrcForm = (acctEmail: string, parentTabId: string | undefined) => {\n    $('input[type=radio][name=source]').off().change(function () {\n      if ((this as HTMLInputElement).value === 'file') {\n        $('.input_private_key').val('').change().prop('disabled', true);\n        $('.source_paste_container').css('display', 'none');\n        $('.source_paste_container .unprotected_key_create_pass_phrase').hide();\n        $('#fineuploader_button > input').click();\n      } else if ((this as HTMLInputElement).value === 'paste') {\n        $('.input_private_key').val('').change().prop('disabled', false);\n        $('.source_paste_container').css('display', 'block');\n        $('.source_paste_container .unprotected_key_create_pass_phrase').hide();\n      } else if ((this as HTMLInputElement).value === 'backup') {\n        window.location.href = Url.create('/chrome/settings/setup.htm', { acctEmail, parentTabId, action: 'add_key' });\n      }\n    });\n    $('.line.unprotected_key_create_pass_phrase .action_use_random_pass_phrase').click(Ui.event.handle(() => {\n      $('.source_paste_container .input_passphrase').val(PgpPwd.random()).keyup();\n      $('.input_passphrase').attr('type', 'text');\n      $('#e_rememberPassphrase').prop('checked', true);\n    }));\n    $('.input_private_key').change(Ui.event.handle(async target => {\n      const { keys: [prv] } = await opgp.key.readArmored(String($(target).val()));\n      $('.input_passphrase').val('');\n      if (!prv || !prv.isPrivate()) {\n        $('.line.unprotected_key_create_pass_phrase').hide();\n        return;\n      }\n      if (prv.isFullyDecrypted()) {\n        $('.line.unprotected_key_create_pass_phrase').show();\n        const { passwordResultElement, removeValidationElements } = this.renderPassPhraseStrengthValidationInput($('.input_passphrase'), $('.action_add_private_key'));\n        passwordResultElement.addClass('left');\n        const removeValidationElementsWhenKeyChanged = Ui.event.handle(() => {\n          removeValidationElements();\n          $('.input_private_key').off('change', removeValidationElementsWhenKeyChanged);\n        });\n        $('.input_private_key').change(removeValidationElementsWhenKeyChanged);\n      } else if (prv.isFullyEncrypted()) {\n        $('.line.unprotected_key_create_pass_phrase').hide();\n      } else {\n        await Ui.modal.error(Lang.setup.partiallyEncryptedKeyUnsupported);\n        $('.line.unprotected_key_create_pass_phrase').hide();\n      }\n    }));\n    const attachmentUi = new AttachmentUI(() => Promise.resolve({ count: 100, size: 1024 * 1024, size_mb: 1 }));\n    attachmentUi.initAttachmentDialog('fineuploader', 'fineuploader_button', {\n      attachmentAdded: async file => {\n        let prv: Key | undefined;\n        const utf = file.getData().toUtfStr('ignore'); // ignore utf8 errors because this may be a binary key (in which case we use the bytes directly below)\n        if (utf.includes(PgpArmor.headers('privateKey').begin)) {\n          const firstPrv = MsgBlockParser.detectBlocks(utf).blocks.filter(b => b.type === 'privateKey')[0];\n          if (firstPrv) { // filter out all content except for the first encountered private key (GPGKeychain compatibility)\n            prv = (await KeyUtil.parse(firstPrv.content.toString()));\n          }\n        } else {\n          const parsed = await KeyUtil.parseBinary(file.getData(), '');\n          prv = parsed[0];\n        }\n        if (typeof prv !== 'undefined') {\n          $('.input_private_key').val(KeyUtil.armor(prv)).change().prop('disabled', true);\n          $('.source_paste_container').css('display', 'block');\n        } else {\n          $('.input_private_key').val('').change().prop('disabled', false);\n          await Ui.modal.error('Not able to read this key. Make sure it is a valid PGP private key.', false, Ui.testCompatibilityLink);\n          $('input[type=radio][name=source]').removeAttr('checked');\n        }\n      }\n    });\n  }\n\n  public checkPrv = async (acctEmail: string, armored: string, passphrase: string): Promise<KeyImportUiCheckResult> => {\n    const { normalized } = await this.normalize('privateKey', armored);\n    const decrypted = await this.read('privateKey', normalized); // for decrypting - not decrypted yet\n    const encrypted = await this.read('privateKey', normalized); // original (typically encrypted)\n    this.rejectIfNot('privateKey', decrypted);\n    await this.rejectKnownIfSelected(acctEmail, decrypted);\n    await this.decryptAndEncryptAsNeeded(decrypted, encrypted, passphrase);\n    await this.checkEncryptionPrvIfSelected(decrypted, encrypted);\n    await this.checkSigningIfSelected(decrypted);\n    if (encrypted.identities.length === 0) {\n      throw new KeyCanBeFixed(encrypted);\n    }\n    // mandatory checks have passed, now display warnings\n    if (decrypted.missingPrivateKeyForDecryption || decrypted.missingPrivateKeyForSigning) {\n      const missing: string[] = [];\n      if (decrypted.missingPrivateKeyForSigning) {\n        missing.push('signing');\n      }\n      if (decrypted.missingPrivateKeyForDecryption) {\n        missing.push('decryption');\n      }\n      await Ui.modal.warning('Looks like this key was exported with --export-secret-subkeys option and missing private key parameters.\\n\\n' +\n        'Please export the key with --export-secret-key option if you plan to use it for ' +\n        missing.join(' and ') + '.');\n    }\n    return { normalized, passphrase, fingerprint: decrypted.id, decrypted, encrypted }; // will have fp if had longid\n  }\n\n  public checkPub = async (armored: string): Promise<string> => {\n    const { normalized } = await this.normalize('publicKey', armored);\n    await this.read('publicKey', normalized); // throws on err\n    await this.checkEncryptionPubIfSelected(normalized);\n    return normalized;\n  }\n\n  public renderPassPhraseStrengthValidationInput = (input: JQuery<HTMLElement>, submitButton?: JQuery<HTMLElement>, type: 'passphrase' | 'pwd' = 'passphrase') => {\n    const validationElements = this.getPPValidationElements();\n    const setBtnColor = (type: 'gray' | 'green') => {\n      if (submitButton) { // submitButton may be undefined if we don't want password strength to affect color of any action button\n        submitButton.addClass(type === 'gray' ? 'gray' : 'green');\n        submitButton.removeClass(type === 'gray' ? 'green' : 'gray');\n      }\n    };\n    const validate = () => {\n      const password = input.val();\n      if (typeof password !== 'string') {\n        Catch.report('render_password_strength: Selected password is not a string', typeof password);\n        return;\n      }\n      const result = Settings.evalPasswordStrength(password, type);\n      validationElements.passwordResultElement.css('display', 'block');\n      validationElements.passwordResultElement.css('color', result.word.color);\n      validationElements.passwordResultElement.find('.password_result').text(result.word.word);\n      validationElements.passwordResultElement.find('.password_time').text(result.time);\n      validationElements.progressBarElement.find('div').css('width', result.word.bar + '%');\n      validationElements.progressBarElement.find('div').css('background-color', result.word.color);\n      setBtnColor(result.word.pass ? 'green' : 'gray');\n    };\n    validationElements.progressBarElement\n      .find('input').css('width', input.outerWidth() + 'px');\n    input.parent().append(validationElements.progressBarElement); // xss-direct\n    input.parent().append(validationElements.passwordResultElement); // xss-direct\n    const validation = Ui.event.prevent('spree', validate);\n    input.on('keyup', validation);\n    const removeValidationElements = () => {\n      validationElements.passwordResultElement.remove();\n      validationElements.progressBarElement.remove();\n      input.off('keydown', validation);\n      setBtnColor('green');\n    };\n    if (!input.val()) {\n      setBtnColor('gray');\n    } else {\n      validate();\n    }\n    return { ...validationElements, removeValidationElements };\n  }\n\n  private normalize = async (type: KeyBlockType, armored: string): Promise<{ normalized: string }> => {\n    // non-OpenPGP keys are considered to be always normalized\n    // TODO: PgpKey.normalize depends on OpenPGP.key.Key objects, when this is resolved\n    // this check for key type should be moved to PgpKey.normalize function.\n    if (KeyUtil.getKeyType(armored) !== 'openpgp') {\n      return { normalized: armored };\n    }\n    const headers = PgpArmor.headers(type);\n    const normalized = await KeyUtil.normalize(armored);\n    if (!normalized) {\n      throw new UserAlert('There was an error processing this key, possibly due to bad formatting.\\nPlease insert complete key, including \"' + headers.begin + '\" and \"' + headers.end + '\"');\n    }\n    return normalized;\n  }\n\n  private read = async (type: KeyBlockType, normalized: string) => {\n    const headers = PgpArmor.headers(type);\n    const k = await KeyUtil.parse(normalized);\n    if (typeof k === 'undefined') {\n      throw new UserAlert(`${type === 'privateKey' ? 'Private' : 'Public'} key is not correctly formatted. Please insert complete key, including \"${headers.begin}\" and \"${headers.end}\"`);\n    }\n    return k;\n  }\n\n  private rejectIfNot = (type: KeyBlockType, k: Key) => {\n    const headers = PgpArmor.headers(type);\n    if (type === 'privateKey' && k.isPublic) {\n      throw new UserAlert('This was a public key. Please insert a private key instead. It\\'s a block of text starting with \"' + headers.begin + '\"');\n    }\n    if (type === 'publicKey' && !k.isPublic) {\n      throw new UserAlert('This was a public key. Please insert a private key instead. It\\'s a block of text starting with \"' + headers.begin + '\"');\n    }\n  }\n\n  private rejectKnownIfSelected = async (acctEmail: string, k: Key) => {\n    if (this.rejectKnown) {\n      const keyinfos = await KeyStore.get(acctEmail);\n      const privateKeysIds = keyinfos.map(ki => ki.fingerprints[0]);\n      if (privateKeysIds.includes(k.id)) {\n        throw new UserAlert('This is one of your current keys, try another one.');\n      }\n    }\n  }\n\n  private decryptAndEncryptAsNeeded = async (toDecrypt: Key, toEncrypt: Key, passphrase: string): Promise<void> => {\n    if (!passphrase) {\n      throw new UserAlert('Please enter a pass phrase to use with this key');\n    }\n    try {\n      if (toEncrypt.fullyDecrypted) {\n        await KeyUtil.encrypt(toEncrypt, passphrase);\n      } else if (!toEncrypt.fullyEncrypted) {\n        throw new UserAlert(Lang.setup.partiallyEncryptedKeyUnsupported);\n      }\n      if (toDecrypt.fullyEncrypted) {\n        if (! await KeyUtil.decrypt(toDecrypt, passphrase)) {\n          this.onBadPassphrase();\n          if (this.expectedLongid) { // todo - double check this line, should it not say `this.expectedLongid === PgpKey.longid() ? Or is that checked elsewhere beforehand?\n            throw new UserAlert(`This is the right key! However, the pass phrase does not match. Please try a different pass phrase.\n              Your original pass phrase might have been different then what you use now.`);\n          } else {\n            throw new UserAlert('The pass phrase does not match. Please try a different pass phrase.');\n          }\n        }\n      } else if (!toDecrypt.fullyDecrypted) {\n        throw new UserAlert(Lang.setup.partiallyEncryptedKeyUnsupported);\n      }\n    } catch (e) {\n      if (e instanceof UserAlert) {\n        throw e;\n      }\n      throw new UserAlert(`This key is not supported by FlowCrypt yet. Please write at human@flowcrypt.com to add support soon. (decrypt error: ${String(e)})`);\n    }\n  }\n\n  private checkEncryptionPrvIfSelected = async (k: Key, encrypted: Key) => {\n    if (this.checkEncryption && (!k.usableForEncryption || k.missingPrivateKeyForDecryption)) {\n      if (k.missingPrivateKeyForDecryption) {\n        throw new UserAlert('Looks like this key was exported with --export-secret-subkeys option and missing private key parameters.\\n\\n' +\n          'Please export the key with --export-secret-key option.');\n      } else if (await KeyUtil.isWithoutSelfCertifications(k)) {\n        throw new KeyCanBeFixed(encrypted);\n      } else if (k.usableForEncryptionButExpired) {\n        // Currently have 2 options: import or skip. Would be better to give user 3 choices:\n        // 1) Confirm importing expired key\n        // 2) Extend validity of expired key + import\n        // 3) Cancel\n        const isConfirmed = await Ui.modal.confirm('You are importing a key that is expired. You can still import it to read messages from the past, ' +\n          'but you will not be able to send new messages using this key. You can add more keys in the settings later.\\n\\nProceed with expired key?');\n        if (!isConfirmed) {\n          throw new UserAlert('You chose to not import expired key.\\n\\nPlease import another key, or edit the expired key in another OpenPGP software to extend key validity.');\n        }\n      } else {\n        throw new UserAlert('This looks like a valid key but it cannot be used for encryption. Please write at human@flowcrypt.com to see why is that.');\n      }\n    }\n  }\n\n  private checkEncryptionPubIfSelected = async (normalized: string) => {\n    const key = await KeyUtil.parse(normalized);\n    if (this.checkEncryption && !key.usableForEncryption) {\n      let msg = 'This public key is correctly formatted, but it cannot be used for encryption';\n      if (key.expiration && key.expiration < Date.now()) {\n        msg += ` because it expired on ${Str.fromDate(new Date(key.expiration))}.\\n\\nAsk the recipient to provide you with an updated Public Key.`;\n        msg += '\\n\\nIf you need to use this particular expired key, click the \"SETTINGS\" button below and import it there.';\n      } else {\n        msg += '.';\n      }\n      throw new UserAlert(msg);\n    }\n  }\n\n  private checkSigningIfSelected = async (k: Key) => {\n    if (this.checkSigning && (!k.usableForSigning || k.missingPrivateKeyForSigning)) {\n      if (k.missingPrivateKeyForSigning && !k.usableForSigningButExpired) {\n        throw new UserAlert('Looks like this key was exported with --export-secret-subkeys option and missing private key parameters.\\n\\n' +\n          'Please export the key with --export-secret-key option.');\n      } else {\n        throw new UserAlert('This looks like a valid key but it cannot be used for signing. Please write at human@flowcrypt.com to see why is that.');\n      }\n    }\n  }\n\n  private getPPValidationElements = () => {\n    const passwordResultHTML = `<div class=\"line password_feedback\" data-test=\"container-password-feedback\">\n                                  <span class=\"password_result\"></span> (time to crack: <span class=\"password_time\"></span>)<ul></ul>\n                                </div>`;\n    const progressBarHTML = `<br/><div class=\"password_bar\">\n                <div></div>\n              </div>`;\n    return { passwordResultElement: $(passwordResultHTML), progressBarElement: $(progressBarHTML) };\n  }\n\n}\n",
    "extension/js/content_scripts/webmail/setup-webmail-content-script.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nimport { Bm, BrowserMsg, TabIdRequiredError } from '../../common/browser/browser-msg.js';\nimport { Env, WebMailName } from '../../common/browser/env.js';\nimport { WebmailVariantString, XssSafeFactory } from '../../common/xss-safe-factory.js';\nimport { BrowserMsgCommonHandlers } from '../../common/browser/browser-msg-common-handlers.js';\nimport { Catch } from '../../common/platform/catch.js';\nimport { ContentScriptWindow } from '../../common/browser/browser-window.js';\nimport { Injector } from '../../common/inject.js';\nimport { Notifications } from '../../common/notifications.js';\nimport Swal from 'sweetalert2';\nimport { Ui } from '../../common/browser/ui.js';\nimport { VERSION } from '../../common/core/const.js';\nimport { AcctStore } from '../../common/platform/store/acct-store.js';\nimport { GlobalStore } from '../../common/platform/store/global-store.js';\n\nexport type WebmailVariantObject = { newDataLayer: undefined | boolean, newUi: undefined | boolean, email: undefined | string, gmailVariant: WebmailVariantString };\nexport type IntervalFunction = { interval: number, handler: () => void };\ntype WebmailSpecificInfo = {\n  name: WebMailName;\n  variant: WebmailVariantString;\n  getUserAccountEmail: () => string | undefined;\n  getUserFullName: () => string | undefined;\n  getReplacer: () => WebmailElementReplacer;\n  start: (acctEmail: string, inject: Injector, notifications: Notifications, factory: XssSafeFactory, notifyMurdered: () => void) => Promise<void>;\n};\nexport interface WebmailElementReplacer {\n  getIntervalFunctions: () => Array<IntervalFunction>;\n  setReplyBoxEditable: () => Promise<void>;\n  reinsertReplyBox: (replyMsgId: string) => void;\n  scrollToReplyBox: (replyMsgId: string) => void;\n  scrollToCursorInReplyBox: (replyMsgId: string, cursorOffsetTop: number) => void;\n}\n\nconst win = window as unknown as ContentScriptWindow;\n\n// tslint:disable:no-blank-lines-func\nexport const contentScriptSetupIfVacant = async (webmailSpecific: WebmailSpecificInfo) => {\n\n  const setUpNotification = `\n    <a href=\"#\" class=\"action_open_settings\" data-test=\"notification-setup-action-open-settings\">Set up FlowCrypt</a> to send and receive secure email on this account.\n    <a href=\"#\" class=\"notification_setup_needed_dismiss\" data-test=\"notification-setup-action-dismiss\">dismiss</a>\n    <a href=\"#\" class=\"close\" data-test=\"notification-setup-action-close\">remind me later</a>\n  `;\n  let wasDestroyed = false;\n  class DestroyTrigger extends Error { }\n\n  const waitForAcctEmail = async (): Promise<string> => {\n    let acctEmailInterval = 1000;\n    const webmails = await Env.webmails();\n    while (true) {\n      const acctEmail = webmailSpecific.getUserAccountEmail();\n      if (typeof acctEmail !== 'undefined') {\n        win.account_email_global = acctEmail;\n        if (webmails.includes(webmailSpecific.name)) {\n          console.info(`Loading FlowCrypt ${VERSION} for ${acctEmail}`);\n          return acctEmail;\n        } else {\n          console.info(`FlowCrypt disabled: ${webmailSpecific.name} integration currently for development only`);\n          throw new DestroyTrigger();\n        }\n      }\n      if (acctEmailInterval > 6000) {\n        console.info(`Cannot load FlowCrypt yet. Page: ${window.location} (${document.title})`);\n      }\n      await Ui.time.sleep(acctEmailInterval, win.TrySetDestroyableTimeout);\n      acctEmailInterval += 1000;\n      if (wasDestroyed) {\n        throw new DestroyTrigger(); // maybe not necessary, but don't want to take chances\n      }\n    }\n  };\n\n  const initInternalVars = async (acctEmail: string) => {\n    const tabId = await BrowserMsg.requiredTabId(30, 1000); // keep trying for 30 seconds\n    const notifications = new Notifications();\n    const factory = new XssSafeFactory(acctEmail, tabId, win.reloadable_class, win.destroyable_class);\n    const inject = new Injector(webmailSpecific.name, webmailSpecific.variant, factory);\n    inject.meta();\n    await GlobalStore.acctEmailsAdd(acctEmail);\n    saveAcctEmailFullNameIfNeeded(acctEmail).catch(Catch.reportErr); // may take a long time, thus async\n    return { tabId, notifications, factory, inject };\n  };\n\n  const showNotificationsAndWaitTilAcctSetUp = async (acctEmail: string, notifications: Notifications) => {\n    let showSetupNeededNotificationIfSetupNotDone = true;\n    while (true) {\n      const storage = await AcctStore.get(acctEmail, ['setup_done', 'cryptup_enabled', 'notification_setup_needed_dismissed']);\n      if (storage.setup_done === true && storage.cryptup_enabled !== false) { // \"not false\" is due to cryptup_enabled unfedined in previous versions, which means \"true\"\n        notifications.clear();\n        return;\n      } else if (!$(\"div.webmail_notification\").length && !storage.notification_setup_needed_dismissed && showSetupNeededNotificationIfSetupNotDone && storage.cryptup_enabled !== false) {\n        notifications.show(setUpNotification, {\n          notification_setup_needed_dismiss: () => AcctStore.set(acctEmail, { notification_setup_needed_dismissed: true }).then(() => notifications.clear()).catch(Catch.reportErr),\n          action_open_settings: () => BrowserMsg.send.bg.settings({ acctEmail }),\n          close: () => {\n            showSetupNeededNotificationIfSetupNotDone = false;\n          },\n        });\n      }\n      await Ui.time.sleep(3000, win.TrySetDestroyableTimeout);\n      if (wasDestroyed) {\n        throw new DestroyTrigger(); // maybe not necessary, but don't want to take chances\n      }\n    }\n  };\n\n  const browserMsgListen = (acctEmail: string, tabId: string, inject: Injector, factory: XssSafeFactory, notifications: Notifications) => {\n    BrowserMsg.addListener('open_new_message', async () => inject.openComposeWin());\n    BrowserMsg.addListener('close_new_message', async () => {\n      $('div.new_message').remove();\n    });\n    BrowserMsg.addListener('focus_body', async () => {\n      if (document.activeElement instanceof HTMLElement) { // iframe have to be blurred before focusing body\n        document.activeElement.blur();\n      }\n      $('body').focus();\n    });\n    BrowserMsg.addListener('focus_frame', async ({ frameId }: Bm.FocusFrame) => {\n      $(`iframe#${frameId}`).focus();\n    });\n    BrowserMsg.addListener('close_reply_message', async ({ frameId }: Bm.CloseReplyMessage) => {\n      $(`iframe#${frameId}`).remove();\n    });\n    BrowserMsg.addListener('reinsert_reply_box', async ({ replyMsgId }: Bm.ReinsertReplyBox) => {\n      webmailSpecific.getReplacer().reinsertReplyBox(replyMsgId);\n    });\n    BrowserMsg.addListener('render_public_keys', async ({ traverseUp, afterFrameId, publicKeys }: Bm.RenderPublicKeys) => {\n      const traverseUpLevels = traverseUp as number || 0;\n      let appendAfter = $(`iframe#${afterFrameId}`);\n      for (let i = 0; i < traverseUpLevels; i++) {\n        appendAfter = appendAfter.parent();\n      }\n      for (const armoredPubkey of publicKeys) {\n        appendAfter.after(factory.embeddedPubkey(armoredPubkey, false));\n      }\n    });\n    BrowserMsg.addListener('close_dialog', async () => {\n      $('#cryptup_dialog').remove();\n    });\n    BrowserMsg.addListener('close_swal', async () => {\n      Swal.close();\n    });\n    BrowserMsg.addListener('scroll_to_reply_box', async ({ replyMsgId }: Bm.ScrollToReplyBox) => {\n      webmailSpecific.getReplacer().scrollToReplyBox(replyMsgId);\n    });\n    BrowserMsg.addListener('scroll_to_cursor_in_reply_box', async ({ replyMsgId, cursorOffsetTop }: Bm.ScrollToCursorInReplyBox) => {\n      webmailSpecific.getReplacer().scrollToCursorInReplyBox(replyMsgId, cursorOffsetTop);\n    });\n    BrowserMsg.addListener('passphrase_dialog', async ({ longids, type }: Bm.PassphraseDialog) => {\n      if (!$('#cryptup_dialog').length) {\n        $('body').append(factory.dialogPassphrase(longids, type)) // xss-safe-factory;\n          .click(Ui.event.handle(() => { // click on the area outside the iframe\n            BrowserMsg.send.passphraseEntry('broadcast', { entered: false });\n            $('#cryptup_dialog').remove();\n          }));\n      }\n    });\n    BrowserMsg.addListener('add_pubkey_dialog', async ({ emails }: Bm.AddPubkeyDialog) => {\n      if (!$('#cryptup_dialog').length) {\n        $('body').append(factory.dialogAddPubkey(emails)); // xss-safe-factory\n      }\n    });\n    BrowserMsg.addListener('notification_show', async ({ notification, callbacks }: Bm.NotificationShow) => {\n      notifications.show(notification, callbacks);\n      $('body').one('click', Catch.try(notifications.clear));\n    });\n    BrowserMsg.addListener('notification_show_auth_popup_needed', async ({ acctEmail }: Bm.NotificationShowAuthPopupNeeded) => {\n      notifications.showAuthPopupNeeded(acctEmail);\n    });\n    BrowserMsg.addListener('reply_pubkey_mismatch', BrowserMsgCommonHandlers.replyPubkeyMismatch);\n    BrowserMsg.addListener('add_end_session_btn', () => inject.insertEndSessionBtn(acctEmail));\n    BrowserMsg.addListener('show_attachment_preview', async ({ iframeUrl }: Bm.ShowAttachmentPreview) => {\n      await Ui.modal.attachmentPreview(iframeUrl);\n    });\n\n    BrowserMsg.listen(tabId);\n  };\n\n  const saveAcctEmailFullNameIfNeeded = async (acctEmail: string) => {\n    const storage = await AcctStore.get(acctEmail, ['full_name']);\n    let timeout = 1000;\n    if (typeof storage.full_name === 'undefined') {\n      while (true) {\n        const fullName = webmailSpecific.getUserFullName();\n        if (fullName) {\n          await AcctStore.set(acctEmail, { full_name: fullName });\n          return;\n        }\n        await Ui.time.sleep(timeout, win.TrySetDestroyableTimeout);\n        timeout += 1000;\n        if (wasDestroyed) {\n          return;\n        }\n      }\n    }\n  };\n\n  const notifyMurdered = () => {\n    const notifEl = document.getElementsByClassName('webmail_notifications')[0];\n    const div = document.createElement('div');\n    div.innerText = 'FlowCrypt has updated, please reload the tab. ';\n    div.classList.add('webmail_notification');\n    const a = document.createElement('a');\n    a.href = '#';\n    a.onclick = function () {\n      const parent = (this as HTMLAnchorElement).parentNode as HTMLElement | undefined;\n      parent?.remove();\n    };\n    a.textContent = 'close';\n    div.appendChild(a);\n    notifEl.textContent = '';\n    notifEl.appendChild(div);\n  };\n\n  const entrypoint = async () => {\n    try {\n      const acctEmail = await waitForAcctEmail();\n      const { tabId, notifications, factory, inject } = await initInternalVars(acctEmail);\n      await showNotificationsAndWaitTilAcctSetUp(acctEmail, notifications);\n      browserMsgListen(acctEmail, tabId, inject, factory, notifications);\n      await webmailSpecific.start(acctEmail, inject, notifications, factory, notifyMurdered);\n    } catch (e) {\n      if (e instanceof TabIdRequiredError) {\n        console.error(`FlowCrypt cannot start: ${String(e)}`);\n      } else if (e instanceof Error && e.message === 'Extension context invalidated.') {\n        console.info(`FlowCrypt cannot start: extension context invalidated. Destroying.`);\n        win.destroy();\n      } else if (!(e instanceof DestroyTrigger)) {\n        Catch.reportErr(e);\n      }\n    }\n  };\n\n  if (!win.injected) {\n\n    /**\n     * This tries to deal with initial environment setup and plugin updtates in a running tab.\n     * - vacant: no influence of previous script is apparent in the DOM\n     * - destroy: script from old world will receive destroy event from new script (DOM event) and tear itself down. Should cause tab to be vacant.\n     * - murdered: what Firefox does to detached scripts. Will NOT cause tab to be vacant.\n     */\n\n    win.injected = true; // background script will use this to test if scripts were already injected, and inject if not\n    win.account_email_global = undefined; // used by background script\n    win.same_world_global = true; // used by background_script\n\n    win.destruction_event = Env.runtimeId() + '_destroy';\n    win.destroyable_class = Env.runtimeId() + '_destroyable';\n    win.reloadable_class = Env.runtimeId() + '_reloadable';\n    win.destroyable_intervals = [];\n    win.destroyable_timeouts = [];\n\n    win.destroy = () => {\n      Catch.try(() => {\n        console.info('Updating FlowCrypt');\n        document.removeEventListener(win.destruction_event, win.destroy);\n        for (const id of win.destroyable_intervals) {\n          clearInterval(id);\n        }\n        for (const id of win.destroyable_timeouts) {\n          clearTimeout(id);\n        }\n        $('.' + win.destroyable_class).remove();\n        $('.' + win.reloadable_class).each((i, reloadableEl) => {\n          $(reloadableEl).replaceWith($(reloadableEl)[0].outerHTML); // xss-reinsert - inserting code that was already present should not be dangerous\n        });\n        wasDestroyed = true;\n      })();\n    };\n\n    win.vacant = () => {\n      return !$('.' + win.destroyable_class).length;\n    };\n\n    win.TrySetDestroyableInterval = (code, ms) => {\n      const id = Catch.setHandledInterval(code, ms);\n      win.destroyable_intervals.push(id);\n      return id;\n    };\n\n    win.TrySetDestroyableTimeout = (code, ms) => {\n      const id = Catch.setHandledTimeout(code, ms);\n      win.destroyable_timeouts.push(id);\n      return id;\n    };\n\n    document.dispatchEvent(new CustomEvent(win.destruction_event));\n    document.addEventListener(win.destruction_event, win.destroy);\n\n    if (win.vacant()) {\n      await entrypoint();\n    } else if (Catch.browser().name === 'firefox') {\n      notifyMurdered();\n    }\n\n  }\n\n};\n",
    "extension/js/content_scripts/webmail/webmail.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\n// todo - a few things are duplicated here, refactor\n\n/// <reference path=\"../../../node_modules/@types/chrome/index.d.ts\" />\n\nimport { WebmailVariantObject, contentScriptSetupIfVacant } from './setup-webmail-content-script.js';\nimport { Catch } from '../../common/platform/catch.js';\nimport { ContentScriptWindow } from '../../common/browser/browser-window.js';\nimport { Env } from '../../common/browser/env.js';\nimport { GmailElementReplacer } from './gmail-element-replacer.js';\nimport { Injector } from '../../common/inject.js';\nimport { Notifications } from '../../common/notifications.js';\nimport { Str } from '../../common/core/common.js';\nimport { XssSafeFactory } from '../../common/xss-safe-factory.js';\nimport { OrgRules } from '../../common/org-rules.js';\nimport { AcctStore } from '../../common/platform/store/acct-store.js';\n\nCatch.try(async () => {\n\n  const gmailWebmailStartup = async () => {\n    let replacePgpElsInterval: number;\n    let replacer: GmailElementReplacer;\n    let hostPageInfo: WebmailVariantObject;\n\n    const getUserAccountEmail = (): undefined | string => {\n      if (window.location.search.indexOf('&view=btop&') === -1) {  // when view=btop present, FlowCrypt should not be activated\n        if (hostPageInfo.email) {\n          return hostPageInfo.email;\n        }\n        const acctEmailLoadingMatch = $(\"#loading div.msg\").text().match(/[a-z0-9._\\-]+@[^…< ]+/gi);\n        if (acctEmailLoadingMatch) { // try parse from loading div\n          return acctEmailLoadingMatch[0].trim().toLowerCase();\n        }\n        const emailFromAccountDropdown = $('div.gb_Cb > div.gb_Ib').text().trim().toLowerCase();\n        if (Str.isEmailValid(emailFromAccountDropdown)) {\n          return emailFromAccountDropdown;\n        }\n      }\n      return undefined;\n    };\n\n    const getInsightsFromHostVariables = () => {\n      const insights: WebmailVariantObject = { newDataLayer: undefined, newUi: undefined, email: undefined, gmailVariant: undefined };\n      $('body').append([ // xss-direct - not sanitized because adding a <script> in intentional here\n        '<script>',\n        '  (function() {',\n        '    const payload = JSON.stringify([String(window.GM_SPT_ENABLED), String(window.GM_RFT_ENABLED), String((window.GLOBALS || [])[10])]);',\n        '    let e = document.getElementById(\"FC_VAR_PASS\");',\n        '    if (!e) {e = document.createElement(\"div\");e.style=\"display:none\";e.id=\"FC_VAR_PASS\";document.body.appendChild(e)}',\n        '    e.innerText=payload;',\n        '  })();',\n        '</script>',\n      ].join('')); // executed synchronously - we can read the vars below\n      try {\n        const extracted = (JSON.parse($('body > div#FC_VAR_PASS').text()) as any[]).map(String);\n        if (extracted[0] === 'true') {\n          insights.newDataLayer = true;\n        } else if (extracted[0] === 'false') {\n          insights.newDataLayer = false;\n        }\n        if (extracted[1] === 'true') {\n          insights.newUi = true;\n        } else if (extracted[1] === 'false') {\n          insights.newUi = false;\n        }\n        if (Str.isEmailValid(extracted[2])) {\n          insights.email = extracted[2].trim().toLowerCase();\n        }\n        if (typeof insights.newDataLayer === 'undefined' && typeof insights.newUi === 'undefined' && typeof insights.email === 'undefined') {\n          insights.gmailVariant = 'html';\n        } else if (insights.newUi === false) {\n          insights.gmailVariant = 'standard';\n        } else if (insights.newUi === true) {\n          insights.gmailVariant = 'new';\n        }\n      } catch (e) {\n        // no need to handle\n      }\n      return insights;\n    };\n\n    const start = async (acctEmail: string, injector: Injector, notifications: Notifications, factory: XssSafeFactory, notifyMurdered: () => void) => {\n      hijackGmailHotkeys();\n      const storage = await AcctStore.get(acctEmail, ['sendAs', 'google_token_scopes', 'full_name']);\n      const orgRules = await OrgRules.newInstance(acctEmail);\n      if (!storage.sendAs) {\n        storage.sendAs = {};\n        storage.sendAs[acctEmail] = { name: storage.full_name, isPrimary: true };\n      }\n      injector.btns();\n      replacer = new GmailElementReplacer(factory, orgRules, acctEmail, storage.sendAs, injector, notifications, hostPageInfo.gmailVariant);\n      await notifications.showInitial(acctEmail);\n      const intervaliFunctions = replacer.getIntervalFunctions();\n      for (const intervalFunction of intervaliFunctions) {\n        intervalFunction.handler();\n        replacePgpElsInterval = (window as unknown as ContentScriptWindow).TrySetDestroyableInterval(() => {\n          if (typeof (window as any).$ === 'function') {\n            intervalFunction.handler();\n          } else { // firefox will unload jquery when extension is restarted or updated\n            clearInterval(replacePgpElsInterval);\n            notifyMurdered();\n          }\n        }, intervalFunction.interval);\n      }\n\n    };\n\n    const hijackGmailHotkeys = () => {\n      const keys = Env.keyCodes();\n      const unsecureReplyKeyShortcuts = [keys.a, keys.r, keys.A, keys.R, keys.f, keys.F];\n      $(document).keypress(e => {\n        Catch.try(() => {\n          const causesUnsecureReply = unsecureReplyKeyShortcuts.includes(e.which);\n          if (causesUnsecureReply && !$(document.activeElement!).is('input, select, textarea, div[contenteditable=\"true\"]') && $('iframe.reply_message').length) {\n            e.stopImmediatePropagation();\n            replacer.setReplyBoxEditable().catch(Catch.reportErr);\n          }\n        })();\n      });\n    };\n\n    hostPageInfo = getInsightsFromHostVariables();\n    await contentScriptSetupIfVacant({\n      name: 'gmail',\n      variant: hostPageInfo.gmailVariant,\n      getUserAccountEmail,\n      getUserFullName: () => $(\"div.gb_hb div.gb_lb\").text() || $(\"div.gb_Fb.gb_Hb\").text(),\n      getReplacer: () => replacer,\n      start,\n    });\n\n    // BrowserMsg.addPgpListeners(); // todo - re-allow when https://github.com/FlowCrypt/flowcrypt-browser/issues/2560 fixed\n  };\n\n  // when we support more webmails, there will be if/else here to figure out which one to run\n  // in which case each *WebmailStartup function should go into its own file\n  await gmailWebmailStartup();\n\n})();\n",
    "test/debug/puppeteer_cannot_access_iframes/ext-frame-online.js": "\nconst puppeteer = require('../node_modules/puppeteer');\n\nlet browser;\n\n(async () => {\n\n  browser = await puppeteer.launch({\n    args: [\n      '--disable-features=site-per-process',\n      '--disable-extensions-except=add_iframe',\n      '--load-extension=add_iframe',\n    ],\n    headless: false,\n    slowMo: 50,\n  });\n\n  let page = await browser.newPage();\n  await page.goto('https://google.com/404');\n\n  await page.waitForSelector('iframe', { timeout: 5000, visible: true });\n  let iframeHandle = await page.$('iframe');\n  let iframeSrc = await (await iframeHandle.getProperty('src')).jsonValue();\n\n  let frames = await page.frames();\n  let urls = frames.map(frame => frame.url());\n\n  console.info(`parsed iframe src: ${iframeSrc}`);\n  console.info(`page.frames() url: ${JSON.stringify(urls)}`);\n  console.info(urls.indexOf(iframeSrc) === -1 ? 'FAIL' : 'PASS');\n\n})();\n",
    "test/source/browser/controllable.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { AvaContext, newTimeoutPromise } from '../tests/tooling';\nimport { ConsoleMessage, Dialog, ElementHandle, Frame, KeyInput, Page } from 'puppeteer';\nimport { PageRecipe } from '../tests/page-recipe/abstract-page-recipe';\nimport { TIMEOUT_DESTROY_UNEXPECTED_ALERT, TIMEOUT_ELEMENT_APPEAR, TIMEOUT_ELEMENT_GONE, TIMEOUT_PAGE_LOAD, TIMEOUT_TEST_STATE_SATISFY } from '.';\nimport { TestUrls } from './test-urls';\nimport { Util } from '../util';\nimport { expect } from 'chai';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as mkdirp from 'mkdirp';\nimport { Dict } from '../core/common';\n\ndeclare const jQuery: any;\n\nabstract class ControllableBase {\n\n  public target: Page | Frame;\n  private debugNamespace: string | undefined = undefined;\n\n  constructor(pageOrFrame: Page | Frame) {\n    this.target = pageOrFrame;\n  }\n\n  public enable_debugging(namespace: string) {\n    this.debugNamespace = namespace;\n  }\n\n  public isElementPresent = async (selector: string) => {\n    return Boolean(await this.element(selector));\n  }\n\n  public waitForSelTestState = async (state: 'ready' | 'working' | 'waiting' | 'closed', timeout = TIMEOUT_TEST_STATE_SATISFY) => {\n    await this.waitAll(`[data-test-state=\"${state}\"]`, { timeout, visible: false });\n  }\n\n  public waitUntilViewLoaded = async (timeout = TIMEOUT_PAGE_LOAD) => {\n    try {\n      await this.waitAll(`[data-test-view-state=\"loaded\"]`, { timeout, visible: false });\n    } catch (e) {\n      throw new Error(`View didn't load within ${timeout}s at ${this.target.url()}`);\n    }\n  }\n\n  public waitAll = async (selector: string | string[], { timeout = TIMEOUT_ELEMENT_APPEAR, visible = true }: { timeout?: number, visible?: boolean } = {}) => {\n    const selectors = this.selsAsProcessedArr(selector);\n    this.log(`wait_all:1:${selectors.join(',')}`);\n    for (const selector of selectors) {\n      this.log(`wait_all:2:${selector}`);\n      if (this.isXpath(selector)) {\n        this.log(`wait_all:3:${selector}`);\n        await this.target.waitForXPath(selector, { timeout: timeout * 1000, visible });\n        this.log(`wait_all:4:${selector}`);\n      } else {\n        this.log(`wait_all:5:${selector}`);\n        await this.target.waitForSelector(selector, { timeout: timeout * 1000, visible });\n        this.log(`wait_all:6:${selector}`);\n      }\n    }\n    this.log(`wait_all:7:${selectors.join(',')}`);\n  }\n\n  public waitAny = async (selector: string | string[], { timeout = TIMEOUT_ELEMENT_APPEAR, visible = true }: { timeout?: number, visible?: boolean } = {}): Promise<ElementHandle> => {\n    timeout = Math.max(timeout, 1);\n    const selectors = this.selsAsProcessedArr(selector);\n    while (timeout-- > 0) {\n      try {\n        for (const selector of selectors) {\n          const elements = await (this.isXpath(selector) ? this.target.$x(selector) : this.target.$$(selector));\n          for (const element of elements) {\n            if ((await element.boundingBox()) !== null || !visible) { // element is visible\n              return element;\n            }\n          }\n        }\n      } catch (e) {\n        if (e instanceof Error && e.message.indexOf('Cannot find context with specified id undefined') === -1) {\n          throw e;\n        }\n      }\n      await Util.sleep(0.05);\n    }\n    throw Error(`waiting failed: Elements did not appear: ${selectors.join(',')}`);\n  }\n\n  public waitTillGone = async (selector: string | string[], { timeout = TIMEOUT_ELEMENT_GONE }: { timeout?: number } = {}) => {\n    let secondsLeft = typeof timeout !== 'undefined' ? timeout : TIMEOUT_ELEMENT_GONE;\n    const selectors = Array.isArray(selector) ? selector : [selector];\n    while (secondsLeft-- >= 0) {\n      try {\n        await this.waitAny(selectors, { timeout: 0 }); // if this fails, that means there are none left: return success\n        await Util.sleep(1);\n      } catch (e) {\n        if (e.message.indexOf('waiting failed') === 0) {\n          return;\n        }\n      }\n    }\n    throw Error(`this.wait_till_gone: some of \"${selectors.join(',')}\" still present after timeout:${timeout}`);\n  }\n\n  public notPresent = async (selector: string | string[]) => {\n    return await this.waitTillGone(selector, { timeout: 0 });\n  }\n\n  public waitUntilFocused = async (selector: string) => {\n    const start = Date.now();\n    while (Date.now() - start < TIMEOUT_ELEMENT_APPEAR * 1000) {\n      const e = await this.element(selector) as ElementHandle;\n      const activeElement = await this.target.evaluateHandle(() => document.activeElement) as ElementHandle;\n      const activeElementHtml = await PageRecipe.getElementPropertyJson(activeElement, 'outerHTML');\n      const testedElementHtml = await PageRecipe.getElementPropertyJson(e, 'outerHTML');\n      if (activeElementHtml === testedElementHtml) {\n        return;\n      }\n      await Util.sleep(1);\n    }\n    throw new Error(`Element ${selector} did not become focused within ${TIMEOUT_ELEMENT_APPEAR}s`);\n  }\n\n\n  public click = async (selector: string) => {\n    this.log(`click:1:${selector}`);\n    const e = await this.element(selector);\n    this.log(`click:2:${selector}`);\n    if (!e) {\n      throw Error(`Element not found: ${selector}`);\n    }\n    this.log(`click:4:${selector}`);\n    try {\n      await e.click();\n    } catch (e) {\n      if (e instanceof Error) {\n        e.stack += ` SELECTOR: ${selector}`;\n        await Util.sleep(60);\n      }\n      throw e;\n    }\n    this.log(`click:5:${selector}`);\n  }\n\n  public type = async (selector: string, text: string, letterByLetter = false) => {\n    const e = await this.element(selector);\n    if (!e) {\n      throw Error(`Element not found: ${selector}`);\n    }\n    if (letterByLetter || text.length < 10) {\n      await e.type(text);\n    } else {\n      const typeLastTenChars = await this.target.evaluate((s, t) => {\n        const el = document.querySelector(s);\n        if (el.contentEditable === 'true') {\n          el.innerText = t;\n          el.selectionEnd = el.innerText.length;\n          el.selectionStart = el.innerText.length;\n          return false;\n        }\n        el.value = t.substring(0, t.length - 5);\n        if (el.type !== 'email' && typeof el.value !== 'undefined') {\n          el.selectionEnd = el.value.length;\n          el.selectionStart = el.value.length;\n        }\n        return true;\n      }, this.selector(selector), text);\n      if (typeLastTenChars) { // used to simulate typing events\n        await e.type(text.substring(text.length - 5, text.length));\n      }\n    }\n  }\n\n  public attr = async (selector: string, attr: string): Promise<string | null> => {\n    return await this.target.evaluate((selector, attr) => {\n      const el = document.querySelector(selector); // this will get evaluated in the browser\n      return el.getAttribute(attr);\n    }, this.selector(selector), attr);\n  }\n\n  public value = async (selector: string): Promise<string> => {\n    await this.waitAll(selector);\n    return await this.target.evaluate((s) => {\n      const e = document.querySelector(s); // this will get evaluated in the browser\n      if (e.tagName === 'SELECT') {\n        return e.options[e.selectedIndex].value;\n      } else {\n        return e.value;\n      }\n    }, this.selector(selector));\n  }\n\n  public isDisabled = async (selector: string): Promise<boolean> => {\n    return await this.target.evaluate((s) => document.querySelector(s).disabled, this.selector(selector));\n  }\n\n  public isChecked = async (selector: string): Promise<boolean> => {\n    return await this.target.evaluate((s) => document.querySelector(s).checked, this.selector(selector));\n  }\n\n  public hasClass = async (selector: string, className: string): Promise<boolean> => {\n    const classList = await this.target.evaluate((s) => document.querySelector(s).classList, this.selector(selector));\n    return Object.values(classList).includes(className);\n  }\n\n  // Get the current computed outer height (including padding, border)\n  public getOuterHeight = async (selector: string): Promise<string> => {\n    return await this.target.evaluate((s) => {\n      const computedStyle = getComputedStyle(document.querySelector(s));\n      const paddings = parseInt(computedStyle.getPropertyValue('padding-top')) + parseInt(computedStyle.getPropertyValue('padding-bottom'));\n      const border = parseInt(computedStyle.getPropertyValue('border-top-width')) + parseInt(computedStyle.getPropertyValue('border-bottom-width'));\n      const outerHeight = parseInt(computedStyle.getPropertyValue('height')) + paddings + border;\n      return outerHeight.toString();\n    }, this.selector(selector));\n  }\n\n  public read = async (selector: string, onlyVisible = false): Promise<string> => {\n    selector = this.selector(selector);\n    if (onlyVisible) {\n      return await this.target.evaluate((s) => [].slice.call(document.querySelectorAll(s)).find((el: HTMLElement) => el.offsetParent !== null).innerText, selector);\n    } else {\n      return await this.target.evaluate((s) => document.querySelector(s).innerText, selector);\n    }\n  }\n\n  public readHtml = async (selector: string): Promise<string> => {\n    return await this.target.evaluate((s) => document.querySelector(s).innerHTML, this.selector(selector));\n  }\n\n  public selectOption = async (selector: string, choice: string) => {\n    await this.waitAll(selector, { visible: true });\n    await this.target.evaluate((s, v) => jQuery(s).val(v).trigger('change'), this.selector(selector), choice);\n  }\n\n  public waitAndType = async (selector: string, text: string, { delay = 0.1 }: { delay?: number } = {}) => {\n    await this.waitAll(selector);\n    await Util.sleep(delay);\n    await this.type(selector, text);\n  }\n\n  public waitAndFocus = async (selector: string) => {\n    await this.waitAll(selector);\n    await this.target.focus(this.selector(selector));\n  }\n\n  public waitAndRespondToModal = async (type: 'info' | 'warning' | 'error' | 'confirm' | 'confirm-checkbox', clickBtn: 'confirm' | 'cancel', message: string) => {\n    await this.waitAll([`@ui-modal-${type}`, `@ui-modal-${type}:message`]);\n    await Util.sleep(0.5);\n    expect(await this.read(`@ui-modal-${type}:message`)).to.contain(message, `ui-modal-${type}:message does not contain expected text`);\n    if (type === 'confirm-checkbox') {\n      await this.waitAndClick(`@ui-modal-${type}-input`);\n    }\n    await this.waitAndClick(`@ui-modal-${type}-${clickBtn}`);\n  }\n\n  public waitAndClick = async (selector: string, { delay = 0.1, confirmGone = false, retryErrs = false, sleepWhenDone }:\n    { delay?: number, confirmGone?: boolean, retryErrs?: boolean, sleepWhenDone?: number } = {}) => {\n    for (const i of [1, 2, 3]) {\n      this.log(`wait_and_click(i${i}):1:${selector}`);\n      await this.waitAll(selector);\n      this.log(`wait_and_click(i${i}):2:${selector}`);\n      await Util.sleep(delay);\n      this.log(`wait_and_click(i${i}):3:${selector}`);\n      try {\n        this.log(`wait_and_click(i${i}):4:${selector}`);\n        await this.click(selector);\n        this.log(`wait_and_click(i${i}):5:${selector}`);\n        break;\n      } catch (e) {\n        this.log(`wait_and_click(i${i}):6:err(${String(e)}):${selector}`);\n        if (e.message === 'Node is either not visible or not an HTMLElement' || e.message === 'Node is detached from document') {\n          // maybe the node just re-rendered?\n          if (!retryErrs || i === 3) {\n            e.stack = `[clicking(${selector}) failed because element quickly disappeared, consider adding retryErrs]\\n` + e.stack;\n            throw e;\n          }\n          this.log(`wait_and_click(i${i}):retrying`);\n          await Util.sleep(1);\n          continue;\n        }\n        throw e;\n      }\n    }\n    if (confirmGone) {\n      this.log(`wait_and_click:7:${selector}`);\n      await this.waitTillGone(selector);\n    }\n    this.log(`wait_and_click:8:${selector}`);\n    if (sleepWhenDone) {\n      await Util.sleep(sleepWhenDone);\n      this.log(`wait_and_click:9:${selector}`);\n    }\n    this.log(`wait_and_click:10:${selector}`);\n  }\n\n  public waitForContent = async (selector: string, needle: string | RegExp, timeoutSec = 20, testLoopLengthMs = 100) => {\n    await this.waitAny(selector);\n    const start = Date.now();\n    const texts: string[] = [];\n    while (Date.now() - start < timeoutSec * 1000) {\n      const text = await this.read(selector, true);\n      if (typeof needle === 'string') { // str\n        if (text.includes(needle)) {\n          return;\n        }\n      } else { // regex\n        if (text.match(needle)) {\n          return;\n        }\n      }\n      texts.push(text);\n      await Util.sleep(testLoopLengthMs / 1000);\n    }\n    throw new Error(`Selector ${selector} was found but did not match \"${needle}\" within ${timeoutSec}s. Last content: \"${JSON.stringify(texts, undefined, 2)}\"`);\n  }\n\n  public verifyContentIsPresentContinuously = async (selector: string, expectedText: string, expectPresentForMs: number = 3000, timeoutSec = 30) => {\n    await this.waitAll(selector);\n    const start = Date.now();\n    const sleepMs = 250;\n    let presentForMs: number = 0;\n    let actualText = '';\n    const history: string[] = [];\n    let round = 1;\n    while (Date.now() - start < timeoutSec * 1000) {\n      await Util.sleep(sleepMs / 1000);\n      actualText = await this.read(selector, true);\n      if (!actualText.includes(expectedText)) {\n        presentForMs = 0;\n      } else {\n        presentForMs += sleepMs;\n      }\n      history.push(`${actualText} for ${presentForMs}ms at ${Date.now()} (round ${round++})`);\n      if (presentForMs >= expectPresentForMs) {\n        return;\n      }\n    }\n    console.log(`verifyContentIsPresentContinuously:\\n${history.join('\\n')}`);\n    throw new Error(`selector ${selector} not continuously containing \"${expectedText}\" for ${expectPresentForMs}ms within ${timeoutSec}s, last content:${actualText}`);\n  }\n\n  public getFramesUrls = async (urlMatchables: string[], { sleep, appearIn }: { sleep?: number, appearIn?: number } = { sleep: 3 }): Promise<string[]> => {\n    if (sleep) {\n      await Util.sleep(sleep);\n    }\n    if (!appearIn) {\n      return await this.getFramesUrlsInThisMoment(urlMatchables);\n    }\n    for (let second = 0; second < appearIn; second++) {\n      const matched = await this.getFramesUrlsInThisMoment(urlMatchables);\n      if (matched.length) {\n        return matched;\n      }\n      await Util.sleep(1);\n    }\n    throw new Error(`Could not find any frame in ${appearIn}s that matches ${urlMatchables.join(' ')}`);\n  }\n\n  public getFrame = async (urlMatchables: string[], { sleep = 1, timeout = 10 } = { sleep: 1, timeout: 10 }): Promise<ControllableFrame> => {\n    if (sleep) {\n      await Util.sleep(sleep);\n    }\n    let passes = Math.max(2, Math.round(timeout)); // 1 second per pass, 2 pass minimum\n    while (passes--) {\n      let frames: Frame[];\n      if (this.target.constructor.name === 'Page') {\n        frames = await (this.target as Page).frames();\n      } else if (this.target.constructor.name === 'Frame') {\n        frames = await (this.target as Frame).childFrames();\n      } else {\n        throw Error(`Unknown this.target.constructor.name: ${this.target.constructor.name}`);\n      }\n      const frame = frames.find(frame => {\n        for (const fragment of urlMatchables) {\n          if (frame.url().indexOf(fragment) === -1) {\n            return false;\n          }\n        }\n        return true;\n      });\n      if (frame) {\n        return new ControllableFrame(frame);\n      }\n      await Util.sleep(1);\n    }\n    throw Error(`Frame not found within ${timeout}s: ${urlMatchables.join(',')}`);\n  }\n\n  public awaitDownloadTriggeredByClicking = async (selector: string | (() => Promise<void>)): Promise<Buffer> => {\n    const resolvePromise: Promise<Buffer> = (async () => {\n      const downloadPath = path.resolve(__dirname, 'download', Util.lousyRandom());\n      mkdirp.sync(downloadPath);\n      await (this.target as any)._client.send('Page.setDownloadBehavior', { behavior: 'allow', downloadPath });\n      if (typeof selector === 'string') {\n        await this.waitAndClick(selector);\n      } else {\n        await selector();\n      }\n      const filename = await this.waitForFileToDownload(downloadPath);\n      return fs.readFileSync(path.resolve(downloadPath, filename));\n    })();\n    const timeoutPromise = newTimeoutPromise(`awaitDownloadTriggeredByClicking timeout for ${selector}`, 20);\n    return await Promise.race([resolvePromise, timeoutPromise]);\n  }\n\n  protected log = (msg: string) => {\n    if (this.debugNamespace) {\n      console.info(`[debug][controllable][${this.debugNamespace}] ${msg}`);\n    }\n  }\n\n  protected isXpath = (selector: string): boolean => {\n    return selector.match(/^\\/\\//) !== null;\n  }\n\n  protected selector = (customSelLanguageQuery: string): string => { // supply browser selector, xpath, @test-id or @test-id(contains this text)\n    let m: RegExpMatchArray | null;\n    if (this.isXpath(customSelLanguageQuery)) {\n      return customSelLanguageQuery;\n      // eslint-disable-next-line no-cond-assign\n    } else if (m = customSelLanguageQuery.match(/@(ui-modal-[a-z\\-]+)\\:message/)) { // tslint:disable-line:no-conditional-assignment\n      return `.${m[1]} .swal2-html-container`; // message inside the modal\n      // eslint-disable-next-line no-cond-assign\n    } else if (m = customSelLanguageQuery.match(/@(ui-modal-[a-z\\-]+)/)) { // tslint:disable-line:no-conditional-assignment\n      return `.${m[1]}`; // represented as a class\n      // eslint-disable-next-line no-cond-assign\n    } else if (m = customSelLanguageQuery.match(/^@([a-z0-9\\-_]+)$/)) { // tslint:disable-line:no-conditional-assignment\n      return `[data-test=\"${m[1]}\"]`;\n      // eslint-disable-next-line no-cond-assign\n    } else if (m = customSelLanguageQuery.match(/^@([a-z0-9\\-_]+)\\(([^()]*)\\)$/)) { // tslint:disable-line:no-conditional-assignment\n      return `//*[@data-test='${m[1]}' and contains(text(),'${m[2]}')]`;\n    } else {\n      return customSelLanguageQuery;\n    }\n  }\n\n  protected element = async (selector: string): Promise<ElementHandle | null> => {\n    selector = this.selector(selector);\n    if (this.isXpath(selector)) {\n      return (await this.target.$x(selector))[0];\n    } else {\n      return await this.target.$(selector);\n    }\n  }\n\n  protected selsAsProcessedArr = (selector: string | string[]): string[] => {\n    return (Array.isArray(selector) ? selector : [selector]).map(this.selector);\n  }\n\n  private getFramesUrlsInThisMoment = async (urlMatchables: string[]) => {\n    const matchingLinks: string[] = [];\n    for (const iframe of await this.target.$$('iframe')) {\n      const src = await PageRecipe.getElementPropertyJson(iframe, 'src');\n      const visible = !! await iframe.boundingBox(); // elements without bounding box are not visible\n      if (urlMatchables.filter(m => src.indexOf(m) !== -1).length === urlMatchables.length && visible) {\n        matchingLinks.push(src);\n      }\n    }\n    return matchingLinks;\n  }\n\n  private waitForFileToDownload = async (downloadPath: string) => {\n    let filename;\n    while (!filename || filename.endsWith('.crdownload')) {\n      filename = fs.readdirSync(downloadPath)[0];\n      await Util.sleep(1);\n    }\n    return filename;\n  }\n\n}\n\nexport class ControllableAlert {\n\n  public target: Dialog;\n  public active = true;\n\n  constructor(alert: Dialog) {\n    this.target = alert;\n  }\n\n  public accept = async () => {\n    await this.target.accept();\n    this.active = false;\n  }\n\n  public dismiss = async () => {\n    await this.target.dismiss();\n    this.active = false;\n  }\n\n}\n\nclass ConsoleEvent {\n  constructor(public type: string, public text: string) { }\n}\n\nexport class ControllablePage extends ControllableBase {\n\n  public consoleMsgs: (ConsoleMessage | ConsoleEvent)[] = [];\n  public alerts: ControllableAlert[] = [];\n  private preventclose = false;\n\n  constructor(public t: AvaContext, public page: Page) {\n    super(page);\n    page.on('console', console => {\n      this.consoleMsgs.push(console);\n    });\n    page.on('requestfinished', r => {\n      const response = r.response();\n      const fail = r.failure();\n      const url = r.url();\n      if (url.indexOf(TestUrls.extension('')) !== 0 || fail) { // not an extension url, or a fail\n        this.consoleMsgs.push(new ConsoleEvent('request', `${response ? response.status() : '-1'} ${r.method()} ${url}: ${fail ? fail.errorText : 'ok'}`));\n      }\n    });\n    page.on('dialog', alert => {\n      this.consoleMsgs.push(new ConsoleEvent('alert', alert.message()));\n    });\n    page.on('pageerror', error => {\n      this.consoleMsgs.push(new ConsoleEvent('error', error.stack || String(error)));\n    });\n    // page.on('error', e => this.consoleMsgs.push(`[error]${e.stack}[/error]`)); // this is Node event emitter error. Maybe just let it go crash the process / test\n    page.on('dialog', alert => {\n      const controllableAlert = new ControllableAlert(alert);\n      this.alerts.push(controllableAlert);\n      setTimeout(() => {\n        if (controllableAlert.active) {\n          t.retry = true;\n          this.preventclose = true;\n          t.log(`${t.attemptText} Dismissing unexpected alert ${alert.message()}`);\n          try {\n            alert.dismiss().catch((e: any) => t.log(`${t.attemptText} Err1 dismissing alert ${String(e)}`));\n          } catch (e) {\n            t.log(`${t.attemptText} Err2 dismissing alert ${String(e)}`);\n          }\n        }\n      }, TIMEOUT_DESTROY_UNEXPECTED_ALERT * 1000);\n    });\n  }\n\n  public newAlertTriggeredBy = async (triggeringAction: () => Promise<void>): Promise<ControllableAlert> => {\n    const dialogPromise: Promise<ControllableAlert> = new Promise((resolve, reject) => {\n      this.page.on('dialog', () => resolve(this.alerts[this.alerts.length - 1])); // we need it as a ControllableAlert so that we know if it was dismissed or not\n      setTimeout(() => reject(new Error('new alert timout - no alert')), TIMEOUT_ELEMENT_APPEAR * 1000);\n    });\n    triggeringAction().catch(console.error);\n    return await dialogPromise;\n  }\n\n  public waitForNavigationIfAny = async (seconds: number = 5) => {\n    try {\n      await this.page.waitForNavigation({ timeout: seconds * 1000 });\n    } catch (e) {\n      // can be \"Navigation Timeout Exceeded\" or \"Navigation timeout of 5000 ms exceeded\"\n      if (new RegExp('^Navigation timeout .*xceeded$').test(e.message)) {\n        return;\n      }\n      throw e;\n    }\n  }\n\n  public goto = async (url: string) => {\n    url = url.indexOf('https://') === 0 || url.indexOf(TestUrls.extension('')) === 0 ? url : TestUrls.extension(url);\n    // await this.page.goto(url); // may produce intermittent Navigation Timeout Exceeded in CI environment\n    this.page.goto(url).catch(e => this.t.log(`goto: ${e.message}: ${url}`));\n    await Promise.race([\n      this.page.waitForNavigation({ waitUntil: 'domcontentloaded', timeout: TIMEOUT_PAGE_LOAD * 1000 }),\n      this.page.waitForNavigation({ waitUntil: 'load', timeout: TIMEOUT_PAGE_LOAD * 1000 })\n    ]);\n  }\n\n  public close = async () => {\n    if (this.preventclose) {\n      this.t.log('page.close() was called but closing was prevented because we want to evaluate earlier errors (cannot screenshot a closed page)');\n      this.preventclose = false;\n    } else {\n      await this.page.close();\n    }\n  }\n\n  public press = async (key: KeyInput, repeat = 1) => {\n    for (let i = 0; i < repeat; i += 1) {\n      await this.page.keyboard.press(key);\n    }\n  }\n\n  public screenshot = async (): Promise<string> => {\n    await this.dismissActiveAlerts();\n    return await Promise.race([\n      this.page.screenshot({ encoding: 'base64' }) as Promise<string>,\n      newTimeoutPromise('screenshot', 20)\n    ]);\n  }\n\n  public html = async (): Promise<string> => {\n    await this.dismissActiveAlerts();\n    return await Promise.race([this.page.content(), newTimeoutPromise('html content', 10)]);\n  }\n\n  public console = async (t: AvaContext, alsoLogDirectly: boolean): Promise<string> => {\n    await this.dismissActiveAlerts();\n    let html = '';\n    for (const msg of this.consoleMsgs) {\n      if (msg instanceof ConsoleEvent) {\n        html += `<span class=\"c-${Util.htmlEscape(msg.type)}\">${Util.htmlEscape(msg.type)}: ${Util.htmlEscape(msg.text)}</span>\\n`;\n        if (alsoLogDirectly) {\n          console.log(`[${t.title}] console-${msg.type}: ${msg.text}`);\n        }\n      } else {\n        html += `<div class=\"c-${Util.htmlEscape(msg.type())}\">${Util.htmlEscape(msg.type())}: ${Util.htmlEscape(msg.text())}`;\n        if (alsoLogDirectly) {\n          console.log(`[${t.title}] console-${msg.type()}: ${msg.text()}`);\n        }\n        const args: string[] = [];\n        for (const arg of msg.args()) {\n          try {\n            const r = JSON.stringify(await Promise.race([arg.jsonValue(), new Promise(resolve => setTimeout(() => resolve('test.ts: log fetch timeout'), 3000))]));\n            if (r !== '{}' && r && r !== JSON.stringify(msg.text())) {\n              args.push(r);\n            }\n          } catch (e) {\n            args.push(`test.ts: console msg arg err: ${String(e)}`);\n          }\n        }\n        if (args.length) {\n          html += `<ul>${args.map(arg => `<li>${Util.htmlEscape(arg)}</li>`)}</ul>`;\n        }\n        html += `</div>\\n`;\n      }\n    }\n    return html;\n  }\n\n  public getFromLocalStorage = async (keys: string[]): Promise<Dict<unknown>> => {\n    const result = await new Promise((resolve, reject) => {\n      (this.target as Page).exposeFunction('saveRawStorageResult', resolve).then(() =>\n        (this.target as Page).evaluate(keys =>\n          chrome.storage.local.get(keys, items => (window as any).saveRawStorageResult(items)), keys\n        ).then(undefined, reject), reject);\n    });\n    return result as Dict<unknown>;\n  }\n\n  private dismissActiveAlerts = async (): Promise<void> => {\n    const activeAlerts = this.alerts.filter(a => a.active);\n    for (const alert of activeAlerts) {\n      // active alert will cause screenshot and other ops to hang: https://github.com/GoogleChrome/puppeteer/issues/2481\n      try {\n        await Promise.race([alert.dismiss(), newTimeoutPromise('alert dismiss', 10)]);\n      } catch (e) {\n        if (!(e instanceof Error && e.message === 'Cannot dismiss dialog which is already handled!')) {\n          throw e;\n        }\n      }\n    }\n  }\n}\n\nexport class ControllableFrame extends ControllableBase {\n\n  public frame: Frame;\n\n  constructor(frame: Frame) {\n    super(frame);\n    this.frame = frame;\n  }\n\n}\n\nexport type Controllable = ControllableFrame | ControllablePage;\n",
    "test/source/mock/attester/attester-endpoints.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { HttpClientErr } from '../lib/api';\nimport { Dict } from '../../core/common';\nimport { HandlersDefinition } from '../all-apis-mock';\nimport { isPost, isGet } from '../lib/mock-util';\nimport { oauth } from '../lib/oauth';\nimport { expect } from 'chai';\nimport { GoogleData } from '../google/google-data';\nimport { Buf } from '../../core/buf';\nimport { testConstants } from '../../tests/tooling/consts';\n\n// tslint:disable:no-blank-lines-func\n\nconst knownMockEmails = [\n  'ci.tests.gmail@flowcrypt.test',\n  'flowcrypt.compatibility@gmail.com',\n  'human@flowcrypt.com',\n  'flowcrypt.test.key.new.manual@gmail.com',\n  'flowcrypt.test.key.used.pgp@gmail.com',\n  'flowcrypt.test.key.recovered@gmail.com',\n];\n\nlet data: GoogleData;\n\nconst getDC26454AFB71D18EABBAD73D1C7E6D3C5563A941 = async () => {\n  if (!data) {\n    data = await GoogleData.withInitializedData('flowcrypt.compatibility@gmail.com');\n  }\n\n  const msg = data.getMessage('1754cfc37886899e')!;\n  const msgText = Buf.fromBase64Str(msg!.raw!).toUtfStr();\n  const dhartleyPubkey = msgText\n    .match(/\\-\\-\\-\\-\\-BEGIN PGP PUBLIC KEY BLOCK\\-\\-\\-\\-\\-.*\\-\\-\\-\\-\\-END PGP PUBLIC KEY BLOCK\\-\\-\\-\\-\\-/s)![0]\n    .replace(/=\\r\\n/g, '').replace(/=3D/g, '=');\n\n  return dhartleyPubkey;\n};\n\nexport const mockAttesterEndpoints: HandlersDefinition = {\n  '/attester/pub/?': async ({ body }, req) => {\n    const emailOrLongid = req.url!.split('/').pop()!.toLowerCase().trim();\n    if (isGet(req)) {\n      if (knownMockEmails.includes(emailOrLongid)) {\n        // the client does not yet check that the pubkey contains the right uids\n        // once it starts checking that, we'll have to be more specific with the pubkeys\n        return somePubkey;\n      }\n      if (emailOrLongid === 'mock.only.pubkey@flowcrypt.com') {\n        return somePubkey;\n      }\n      if (emailOrLongid === 'mock.only.pubkey@other.com') {\n        return somePubkey;\n      }\n      if (emailOrLongid === 'expired.on.attester@domain.com') {\n        return expiredPubkey;\n      }\n      if (emailOrLongid === 'flowcrypt.compatibility@protonmail.com') {\n        return protonMailCompatKey;\n      }\n      if (['dhartley@verdoncollege.school.nz', '1C7E6D3C5563A941'.toLowerCase()].includes(emailOrLongid)) {\n        return await getDC26454AFB71D18EABBAD73D1C7E6D3C5563A941();\n      }\n      if (['sams50sams50sept@gmail.com', 'president@forged.com', '2864E326A5BE488A'.toLowerCase()].includes(emailOrLongid)) {\n        return testConstants.pubkey2864E326A5BE488A;\n      }\n      if (emailOrLongid.startsWith('martin@p')) {\n        return mpVerificationKey;\n      }\n      if (emailOrLongid === 'sha1@sign.com') {\n        return sha1signpubkey;\n      }\n      if (emailOrLongid === '6D3E09867544EE627F2E928FBEE3A42D9A9C8AC9'.toLowerCase()) { // newer version of expired pubkey\n        return newerVersionOfExpiredPubkey;\n      }\n      if (emailOrLongid === '8EC78F043CEB022498AFD4771E62ED6D15A25921'.toLowerCase()) { // older version of expired pubkey\n        return olderVersionOfExpiredPubkey;\n      }\n      throw new HttpClientErr('Pubkey not found', 404);\n    } else if (isPost(req)) {\n      oauth.checkAuthorizationHeaderWithIdToken(req.headers.authorization);\n      expect(body).to.contain('-----BEGIN PGP PUBLIC KEY BLOCK-----');\n      return 'Saved'; // 200 OK\n    } else {\n      throw new HttpClientErr(`Not implemented: ${req.method}`);\n    }\n  },\n  '/attester/initial/legacy_submit': async ({ body }, req) => {\n    if (!isPost(req)) {\n      throw new HttpClientErr(`Wrong method: ${req.method}`);\n    }\n    const { email, pubkey } = body as Dict<string>;\n    expect(email).to.contain('@');\n    expect(pubkey).to.contain('-----BEGIN PGP PUBLIC KEY BLOCK-----');\n    if (email === 'no.pub@org-rules-test.flowcrypt.test') {\n      throw new HttpClientErr(`Could not find LDAP pubkey on a LDAP-only domain for email ${email} on server keys.flowcrypt.test`);\n    }\n    return { saved: true };\n  },\n  '/attester/test/welcome': async ({ body }, req) => {\n    if (!isPost(req)) {\n      throw new HttpClientErr(`Wrong method: ${req.method}`);\n    }\n    const { email, pubkey } = body as Dict<string>;\n    expect(email).to.contain('@');\n    expect(pubkey).to.contain('-----BEGIN PGP PUBLIC KEY BLOCK-----');\n    return { sent: true };\n  },\n};\n\nexport const somePubkey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\nVersion: CryptUP 3.2.0 Easy Gmail Encryption https://cryptup.org\nComment: Seamlessly send, receive and search encrypted email\n\nxsBNBFU0WMgBCACZSzijeN4YozhjmHU7BGWzW7ZbY6GGtJinByt8OnEnQ9TX\n9zrAxbyr0grPE4On7nd3uepwNxJbk5LlaCwHNkpX39xKgDgCskRO9CfeqOIO\n4l5Wjj4XldrgLSOGJe8Vmimo9UKmqsP5v8fR3mMyIqQbtE4G+Vq/J9A3uabr\nf0XYVsBdBvVoJkQ83gtQrZoTA/zihNmtLXH9pTwtX8FJcqgFK6RgvfAh2jCz\nDhT+reI50ZcuHRvVRxvrL172DFSQsLSdj8PcewS1J89knH4sjjBC/kwbLa0n\ntod/gBPWw/uetaOJna43wNueUKKOl2kAXE4sw6ESIrlFDynJ4g05T9yxABEB\nAAHNIlRvbSBKYW1lcyBIb2x1YiA8dG9tQGJpdG9hc2lzLm5ldD7CwFwEEAEI\nABAFAlU0WM8JEA1WiOvzECvnAAAB4gf8DaIzZACUqkGEoI19HyBPtcrJT4mx\nhKZ/Wts0C6TGj/OQXevDI+h2jQTYf8+fOqCdQev2Kwh/8mQV6wQqmN9uiVXO\n5F4vAbWNfEve6mCVB5gi296mFf6kx04xC7VVYAJ3FUR72BplE/0+cwv9Nx2r\nJh3QGFhoPaFMPtCAk0TgKcO0UkcBwXNzAV5Pgz0MT1COTWBXEej4yOrqdWoP\nA6fEpV8aLaFnAt+zh3cw4A7SNAO9omGAUZeBl4Pz1IlN2lC2grc2zpqoxo8o\n3W49JYTfExeCNVWhlSU74f6bpN6CMdSdrh5phOr+ffQQhEhkNblUgSZe6tKa\nVFI1MhkJ6Xhrug==\n=+de8\n-----END PGP PUBLIC KEY BLOCK-----`;\n\nconst expiredPubkey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxsBNBGANSYYBCACkVfVUKS9ura0KSiRu6i4bC0mEpwOjuYotor1d1NciysN977UMKQw1uux0GIZz\n3PvJUL4Ij77eyF5wxOueOwqON/LHunqnufvES9zj2BgQLwfE5d7gXp0IjQqWEg4YfSkTNIwzP67R\nqDbvW4E7XScLY1BYutrZhq53rzXurON9eftFi2ScW4/Pja2eCah5bMxFqoINRGFYJwK6Z6rD1h2+\n/w5s9Ir+qELUKxIYtwfp2Uf3uTDnT4BRFPcuNh9rXLPpXprTjGe2cZ6i9ENzMj0dTlU8kqvTyhPm\nBReZZZcUe5teVyfbLXmz/nQCnxnuH/e8LDeQ5TC6knTFd8d9gTI7ABEBAAHNHmV4cGlyZWQub24u\nYXR0ZXN0ZXJAZG9tYWluLmNvbcLAjwQTAQgAORYhBBr54+QEmYDLPhttjC90yktngnCgBQJgDUmL\nBQkAAAA8AhsDBQsJCAcCBhUICQoLAgUWAgMBAAAKCRAvdMpLZ4JwoLb0B/0cFAn266wKMNSq556G\nldLCLDpPrMaKy6r3qsiG/Y3otvnn+iBLqkuEo7P9XmfQooiplpUxLnmiBmGxlVmUcNMBh15Z7GXP\ncj4fas++H1sjAbF6mPqhggIsxGcnk9YjbZC+GaDzKp5BKgDUUIitsYzSENdADqeL6SQixSMWAiGA\nCiOQ8mnriH/CGb1XW76YVjYa5fK2OqflQj+l5IiJ4gqWuHpYs5zR24tnxIiv5UtvxglahV8Tugdf\nKfjnkfYbJEwxyUGzXNtmqhsrhoSWaYbrqjRqNolnFP6hr5NlVVNA9XNWLhWd0HdhzgJWYvd+ukLE\neTY/IvQlyIVMV9nqQqOVzsBNBGANSYwBCADFzPusdjjO0zcI/7sfgUHk/XmPawR6WIhzTHaM38Pg\n1woaXZt0oSU6K2OSKwYRnuVGM0zbjhhICPhtAo3m26h4LojPlM1Dnp+U/p9hXVFa7MPtlUupfhZt\n9Ip4nNLWyYhQrSAI73InVtJvYQbQU/t7or+twrXZJqAPIqMBQ+pkYab8+bOfdY+/QoHM7SKyvggg\n6E+4fw9IwwaoZpxcbc2Wbcn1LpaF2xZUq0kWxtQ86b6rMQWbNgfs4xVUKAeP74SINM5iYDV4qjD0\nKTTzAmn/rlBbvwP2r7SX1gmismLJYDJCpZrYdJEMOMhfXBQaz+0rlHIT6YIyr1mpLecJzIXRABEB\nAAHCwHwEGAEIACYWIQQa+ePkBJmAyz4bbYwvdMpLZ4JwoAUCYA1JkQUJAAAAPAIbDAAKCRAvdMpL\nZ4JwoGmXB/97g6/UkdVtBv5bP1V7JZpxEo31Q0S3dZR6pMVaEpVgtksSIcO2i9PdCZhYZ9noRkdO\nBpSNkgVOzk6/WvpVBl8TZ7bpWa7ux6ExiJLKKjWSHnJJ3SkviARSrAmDfvDCxKh3duEmjsmBy/r0\nugFu0E2D/Oxqa6ZUv7swwx8kuq7/UchZLQQCiKCGosRqiApqhp2ze/CNzeD/na+q0yvT6pFFDjGl\n82Yrr1oqCyZZedSFSLelVqBJ8FkyJlqN3J9Q3M5rEp5vcRqGOHxfO5j2Gb88mmmtnWnBzRPPX8CB\nDDF85HtNOR10V1aJrfE7F6e3QTzu5SZBjDPi5vVcbtK72eyd\n=o0Ib\n-----END PGP PUBLIC KEY BLOCK-----\n`;\n\nconst protonMailCompatKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\nVersion: OpenPGP.js v3.0.5\nComment: https://openpgpjs.org\n\nxsBNBFskt/ABCAD0N+Y+ZavNGwRif9vkjcHxmvWkkqBO+pA1KanPUftoi2b/\nzMErfl+4P6xe+KpDS97W/BqBGKP7bzN08XSkqyROhv/lroofXgu1WSJ53znf\nbRGiRmOjIntBX7iSKecSh9zcgjBRK6xnhoaXxUhCwp8ZsxapMRSwQmlXU6WQ\n4XAI4JhtZVpBUtbeUW0/+4KRObmj9Dy+4nnNFFBubBrHV0F7FmkJkvksvkNL\n4awmTFbfPE8vkapoDi1hFzMbWoYvEPLmv/HTRcqjPZASLr7fXG+AOefE8uJA\nL++Zs0jw2ukrk9KHk3q70ii61CUz9zODCXzeoWQMNTUHoZFuhzawCFe1ABEB\nAAHNT2Zsb3djcnlwdC5jb21wYXRpYmlsaXR5QHByb3Rvbm1haWwuY29tIDxm\nbG93Y3J5cHQuY29tcGF0aWJpbGl0eUBwcm90b25tYWlsLmNvbT7CwHUEEAEI\nACkFAlskt/EGCwkHCAMCCRB+1D156WF2VQQVCAoCAxYCAQIZAQIbAwIeAQAA\n2hYIANsYeRHhz5odpXWbeLc//Ex90llhgWb/kWWW5O5/mQwrOt+4Ct0ZL45J\nGeXCQyirHiYhmA50BoDDfayqULDx17v6easDmfdZ2qkVxczc+TjF0VMI+Y/3\nGrPuVddzBomc7qqYmEOkKEcnz4Q7mX5Ti1ImY8SSVPOchIbOQUFa96VhZJAq\nXyx+TIzalFQ0F8O1Xmcj2WuklBKAgR4LIX6RrESDcxrozYLZ+ggbFYtf2RBA\ntEhsGyA3cJe0d/34jlhs9yxXpKsXGkfVd6atfHVoS7XlJyvZe8nZgUGtCaDf\nh5kJ+ByNPQwhTIoK9zWIn1p6UXad34o4J2I1EM9LY4OuONvOwE0EWyS38AEI\nALh5KJNcXr0SSE3qZ7RokjsHl+Oi0YZBiHg0HBZsliIwMBLbR007aSSIAmLa\nfJyZ0cD/BmQxHguluaTomfno3GYrjyM86ETz+C0YJJ441Fcji/0fFr8JexXf\neX4GEIVxQd4L0tB7VAAKMIGv/VAfLBpKjfY32LbgiVqVvgkxBtNNGXCaLXNa\n3l6l3/xo6hd4/JFIlaVTEb8yI578NF5nZSYG5IlF96xX7kNKj2aKXvdppRDc\nRG+nfmDsH9pN3bK4vmfnkI1FwUciKhbiwuDPjDtzBq6lQC4kP89DvLrdU7PH\nn2PQxiJyxgjqBUB8eziKp63BMTCIUP5EUHfIV+cU0P0AEQEAAcLAXwQYAQgA\nEwUCWyS38QkQftQ9eelhdlUCGwwAAKLKB/94R0jjyKfMGe6QY5hKnlMCNVdD\nNqCl3qr67XXCnTuwnwR50Ideh+d2R4gHuu/+7nPo2juCkakZ6rSZA8bnWNiT\nz6MOL1b54Jokoi1MreuyA7mOqlpjhTGbyJewFhUI8ybGlFWCudajobY2liF6\nAdeK17uMFfR6I1Rid3Qftszqg4FNExTOPHFZIc8CiGgWCye8NKcVqeuVlXKw\n257TmI5YAxZAyzhc7iX/Ngv6ZoR18JwKvLP1TfTJxFCG5APb5OSlQmwG747I\nEexnUn1E1mOjFwiYOZavCLvJRtazGCreO0FkWtrrtoa+5F2fbKUIVNGg44fG\n7aGdFze6mNyI/fMU\n=D34s\n-----END PGP PUBLIC KEY BLOCK-----`;\n\nconst mpVerificationKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\nVersion: SKS 1.1.6\nComment: Hostname: keyserver.ubuntu.com\n\n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\nD+QpnsOtKCqDWiq6s1l0UasWPk7xv6awH29H\n=EpXD\n-----END PGP PUBLIC KEY BLOCK-----`;\n\nconst newerVersionOfExpiredPubkey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\nVersion: FlowCrypt Email Encryption 7.8.4\nComment: Seamlessly send and receive encrypted email\n\nxsBNBF8PcdUBCADi8no6T4Bd9Ny5COpbheBuPWEyDOedT2EVeaPrfutB1D8i\nCP6Rf1cUvs/qNUX/O7HQHFpgFuW2uOY4OU5cvcrwmNpOxT3pPt2cavxJMdJo\nfwEvloY3OfY7MCqdAj5VUcFGMhubfV810V2n5pf2FFUNTirksT6muhviMymy\nuWZLdh0F4WxrXEon7k3y2dZ3mI4xsG+Djttb6hj3gNr8/zNQQnTmVjB0mmpO\nFcGUQLTTTYMngvVMkz8/sh38trqkVGuf/M81gkbr1egnfKfGz/4NT3qQLjin\nnA8In2cSFS/MipIV14gTfHQAICFIMsWuW/xkaXUqygvAnyFa2nAQdgELABEB\nAAHNKDxhdXRvLnJlZnJlc2guZXhwaXJlZC5rZXlAcmVjaXBpZW50LmNvbT7C\nwI0EEAEIACAFAl8Pc5cGCwkHCAMCBBUICgIEFgIBAAIZAQIbAwIeAQAhCRC+\n46QtmpyKyRYhBG0+CYZ1RO5ify6Sj77jpC2anIrJ/awIAMVNZmNzQkWA9uZr\nRity+QME43ySC6p9cRx3o39apmOuVn6TOv/n9tfAlR/lYNZR80myhNi4xkQe\nBpuTSJ8WAIw+9CIXrROV/YBdqvPXucYUZGjkAWzN6StQUfYP8nRm6+MebgLI\nB/s+Lkr1d7wrDDF8rh7Ir9SkpXqr5FPTkDMsiFEbUR7oKpRoeI9zVtF375FB\nZJMUxm8YU+Tj1LAEullgrO9omHyMVqAVffZe6rH62c7L9ZR3C3/oG5rNcC/0\nkIRsh0QGrq+kuZ6bsLFBhDLIjci8DH9yO1auceNy+Xa1U6scLb1ZZpVfV5R9\nHWPy4QcNitDMoAtqVPYxPQYqRXXOwE0EXw9x1QEIALdJgAsQ0JnvLXwAKoOa\nmmWlUQmracK89v1Yc4mFnImtHDHS3pGsbx3DbNGuiz5BhXCdoPDfgMxlGmJg\nShy9JAhrhWFXkvsjW/7aO4bM1wU486VPKXb7Av/dcrfHH0ASj4zj/TYAeubN\noxQtxHgyb13LVCW1kh4Oe6s0ac/hKtxogwEvNFY3x+4yfloHH0Ik9sbLGk0g\nS03bPABDHMpYk346406f5TuP6UDzb9M90i2cFxbq26svyBzBZ0vYzfMRuNsm\n6an0+B/wS6NLYBqsRyxwwCTdrhYS512yBzCHDYJJX0o3OJNe85/0TqEBO1pr\ngkh3QMfw13/Oxq8PuMsyJpUAEQEAAcLAdgQYAQgACQUCXw9zlwIbDAAhCRC+\n46QtmpyKyRYhBG0+CYZ1RO5ify6Sj77jpC2anIrJzogH/2sRLw/hL2asprWR\nU78VdhG+oUKKoNYvLFMJ93jhIB805E87kDB1Cietxg1xTj/lt911oK6eyoe4\nCekCU25WkxmsAh0NUKz/1D6wJ1uDyh2lkmgyX+Iz9RCjtDHnnuzM1It77z6F\nlGemOmYh8ZLYxJmG6e3MqHelRH25TuPm6fB0TN7lRlleTl26/8aJDBCvp7N1\n4AdIgRWhBCoByCNe8QuNiZ0Bb+TLOt0jVVder645fVWx+4te0tpHTbGn9e3c\nnLDskCEyJFvADug883x3lswUqh65zLO22m/plVmJ7X++whhSsDyQQRFiH0Du\n1uh93GjDDNgrP1GfAMeRjZ4V8R8=\n=R9m4\n-----END PGP PUBLIC KEY BLOCK-----\n`;\n\nconst olderVersionOfExpiredPubkey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\nVersion: FlowCrypt Email Encryption 7.8.4\nComment: Seamlessly send and receive encrypted email\n\nxsBNBF8QJFgBCACdPi2i6uflsgNVvSw20eVaqOwEgwRAu1wrwB+s3UxFxsnE\nXBiJ6tvQU+NzNFLWjT5FwyTz8PM2lDnXz/j6nQGft+l/01l349u0L4WhTEES\nByPTOA1Wbs4YRbef1+T6tKklN8CKH93tBKRFTZXsMv0nLuEMmyxNgYHvNsnB\nGXlGQrrsJ5qVr10YZh+dXo8Ir4mXXE5tCrVH/AzDBK/cBZcUbBD7gmvnt+HF\nvuJYMRQ46/NR84S57Dwm5ZzER0PMQfnLYyjdKE4DEVtL84WVhGVqNhBqy1Z6\nl/wvSHnBvrXe1Vdm2YXT0pIahe9wJmrA2dixA8c+SczICn+QZAkBsAZRABEB\nAAHNKTxoYXMub2xkZXIua2V5Lm9uLmF0dGVzdGVyQHJlY2lwaWVudC5jb20+\nwsCTBBABCAAmBQJfECRYBQkAAAACBgsJBwgDAgQVCAoCBBYCAQACGQECGwMC\nHgEAIQkQHmLtbRWiWSEWIQSOx48EPOsCJJiv1HceYu1tFaJZIQewCACYWDJ5\n3sbGDvIwRlPiAQqTp4IvjrvLC+unX4OVyaqXPcTbCWkjjUcZci2aO5V59J+I\nfHkI7PVwheuEk4HjNBiPvSOy8BbwiGXYxkQX4Z4QZkcf6wCvd3rtwyICzhNh\njsehA4uaYStr0k0pxzHMWhpDeppzVL+yVnCoftiW9+9MuTFQ2ynQhBYp57yA\n6LGn9X91L7ACZvWMstBwTNkT2N2Vw7ngCnacweIj0LMje2wt6cKO1IMm0U4Q\nEkag9pqTf1DnyC/dkw7GB6kT5lP9wAdZNxtIgJwHQNidH+0gfJlTQ31LQp5T\njFa6LU+7XK8sprZG27TjQX9w7NVyYbkib3mGzsBNBF8QJFgBCACnVXFdNoKA\nTHN6W7ewu8CDaDEOxrUGckrTFSOLN0hkLrlrHRZg4/N0gZf/TdUynGJ6fkXq\n5ZDZWiPujAyjeTHhoUb3Oc0O9voX3TLRROduDxW6UAeurzXAiL/25qOp1TRr\nFhvllleg+fcZDNjPct4zyUxUW6NzWkHJ+XvNxq2fTH82n0RfPTyRoee/ymuR\nexRU4vfYF8XNo+aEDx00rwQFpl8ot20Qus6vKejo0SIyr0bS4oHBB3sYHrxt\nkfHLwiSfE27eW2pogta6JcH7w+OLGadoGxqGs1cYpbVhteDRUQ4nTov3JWt5\nVoNlXiaBdV3vRF52Q+UuUwylsbcplDeDABEBAAHCwHwEGAEIAA8FAl8QJFgF\nCQAAAAICGwwAIQkQHmLtbRWiWSEWIQSOx48EPOsCJJiv1HceYu1tFaJZIcYi\nB/wNq0UOV3d1aaFtx2ie2CYX5f7o9/emyN7HomW53DBXSAlj98R0MnKrUadU\noIXkUnJlGIyU9NjzWWZsdPMrlaU/tCvceO/wvc2K/pqjiQKjtfiA/mR+0dGf\ncVskq2WOiAfEuOcTAdrYmLeTs5r6RJueTb3qxUN7a9OWru+avuyJ7lDiOiNC\nMnhQ8xZy1zREApD1weSz9JEUOTkcNYFm/dm08g0QfKneqi5/ZvNmRlKNW/Nf\n9DCM/jCp1Nb33yNTC9n3HW8qMOd4pPfajDEtGivqi5aQGaZ+AbT6RTR4jD8q\n7GiOeV7wDbZXG0MYLM9kqW7znnDTAGHWvTw+HanlU23+\n=KVqr\n-----END PGP PUBLIC KEY BLOCK-----`;\n\nconst sha1signpubkey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxsBNBGANYRQBCADI3WP21Ut4L+g+qBBMk24cxsAX4N+FisqcxW7jhrqksH9Mi2vhpDFZyUCRe4d8\nliXGTfiWnkp9qQIos8vnC6yPf9gNxsrjlccVVIiusoJB18KqsiKVBUiiqbNQwLUCACMA5PCALaBJ\n1TRrTy5hWPCa8v+iyxTr2LaE7BcJCv1eGB3/vfsIt9zf2fsRga7FroJHSOdrxAPMu5rIU5iHwGPe\nnFe2dSt8Y+dX5YKV7IBbjP7/Vp+/gV2HItaKmHFXP5FOtndPPCOtnIp6vUNZwA/o4K7tmiz6ZFp0\n/Yn2DwUK0Nmmr+2v75FRnWqtelgACEDuGfrvYeJwAZIOmV0fr5yxABEBAAHNDXNoYTFAc2lnbi5j\nb23CwIkEEwECADMWIQRXddqCmBkCxSCZ5qPIqyMsf2dexAUCYA1hGgIbAwULCQgHAgYVCAkKCwIF\nFgIDAQAACgkQyKsjLH9nXsTM5AgAwWhDr2X9LY+7eJGyihkwXDCBZUvjF0hpY+8FYyxllfbW45pu\n0bVs5T/EfnUYr+fOZuHdmhz4lNI2BPDwHhdQZpIqrrimD6jrypwcb500hwu5FKUBzw6U39QDuOSc\nW6wIkiZ7hajTSTzniQRpbYZaKPrsFY40uZeQo6rAl71iuRsVvCjCazX8McOdGGP7oJCxtCpxaHoL\nS2RcVu5/SWmEi8wHopDCKf/1UJphjJDeIHgdLwM6xMLrYBfbt6Fd2PYpJ17+ECs8Y9Q2v5nyXFaD\nq+/Ri36rk3lz5YJGyB2AOFG+ma80SlOsCbA6j9Ky49tJZ1we6F368Lujrxnb+xMKY87ATQRgDWEa\nAQgAqy0j+/GZvh4o7EabTtPKLOkVtQp/OV0ZGw6SKnhDB7pJhHKqgRduK4NYr1u+t575NI7EwgR3\n7qoZkuvs/KmFizTxosCgL7WC6o5Groibc2XrL8mXbGDqWzKGllvKO+7gfkwx5qh0MoOXHWaavxE3\neXM6vvlATcjLkTjISiqzK/jSAmqB9J3GdqFafmtjqm/4Nfu1FGgpWi9JJxpv5aN8nILYksL/X+s8\nounYOz+OpUU+liv2wU3eRXP2/Qzc7Acdkrw5hRert9u+klHB3MckNUujVqq0mxB1yrPeJjqOBPCl\n2n/wNLUoLqWbP/TW40MSFPAYdR/z+T67MDmRzVlewQARAQABwsB2BBgBAgAgFiEEV3XagpgZAsUg\nmeajyKsjLH9nXsQFAmANYR8CGwwACgkQyKsjLH9nXsSw8wf8CedMX61foCmCOEmKCscH+GcFKWwH\nS4xlOPQZG4RXFla/VMvJrHqbxZ5vIID0GQ+t6kdhuD0ws9Y7DObFcSCxqPm8idkJUvC4kv1MSu+P\n7NbWDS8t7e/b1EOu+aeIxqUhaQrJacWWiUn9tbobpld8GGlquLIteY9Ix2H/xjXnDvpB30v/fDNG\nT/X6OnVQdcOI7SvdQI74SxbaHnEeCLDEk7dOhWLJBLuZwK7M3cT6BX+V2v6Fm7SX0hSpDg1HK0KL\nqHJuDNEmMUvx3cMUd5HtsOFO9JapCp1iCVo2p49CIXA4NUrLETNM2ZddknhbFm8bsK48tTJEH6l4\nWq3aCVXYGg==\n=Ldag\n-----END PGP PUBLIC KEY BLOCK-----`;\n",
    "test/source/mock/google/strategies/send-message-strategy.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { AddressObject, ParsedMail, StructuredHeader } from 'mailparser';\nimport { ITestMsgStrategy, UnsuportableStrategyError } from './strategy-base.js';\nimport { Buf } from '../../../core/buf';\nimport { Config } from '../../../util';\nimport { expect } from 'chai';\nimport { GoogleData } from '../google-data';\nimport { HttpClientErr } from '../../lib/api';\nimport { MsgUtil } from '../../../core/crypto/pgp/msg-util';\nimport { parsedMailAddressObjectAsArray } from '../google-endpoints.js';\n\n// TODO: Make a better structure of ITestMsgStrategy. Because this class doesn't test anything, it only saves message in the Mock\nclass SaveMessageInStorageStrategy implements ITestMsgStrategy {\n  public test = async (mimeMsg: ParsedMail, base64Msg: string) => {\n    (await GoogleData.withInitializedData(mimeMsg.from!.value[0].address!)).storeSentMessage(mimeMsg, base64Msg);\n  }\n}\n\nclass PwdEncryptedMessageTestStrategy implements ITestMsgStrategy {\n  public test = async (mimeMsg: ParsedMail, base64Msg: string) => {\n    if (!mimeMsg.text?.match(/https:\\/\\/flowcrypt.com\\/[a-z0-9A-Z]{10}/)) {\n      throw new HttpClientErr(`Error: cannot find pwd encrypted link in:\\n\\n${mimeMsg.text}`);\n    }\n    if (!mimeMsg.text?.includes('Follow this link to open it')) {\n      throw new HttpClientErr(`Error: cannot find pwd encrypted open link prompt in ${mimeMsg.text}`);\n    }\n    (await GoogleData.withInitializedData(mimeMsg.from!.value[0].address!)).storeSentMessage(mimeMsg, base64Msg);\n  }\n}\n\nclass MessageWithFooterTestStrategy implements ITestMsgStrategy {\n  private readonly footer = 'flowcrypt.compatibility test footer with an img';\n\n  public test = async (mimeMsg: ParsedMail) => {\n    const keyInfo = await Config.getKeyInfo([\"flowcrypt.compatibility.1pp1\", \"flowcrypt.compatibility.2pp1\"]);\n    const decrypted = await MsgUtil.decryptMessage({ kisWithPp: keyInfo!, encryptedData: Buf.fromUtfStr(mimeMsg.text || '') });\n    if (!decrypted.success) {\n      throw new HttpClientErr(`Error: can't decrypt message`);\n    }\n    const textContent = decrypted.content.toUtfStr();\n    if (!textContent.includes(this.footer)) {\n      throw new HttpClientErr(`Error: Msg Text doesn't contain footer. Current: '${mimeMsg.text}', expected footer: '${this.footer}'`);\n    }\n  }\n}\n\nclass SignedMessageTestStrategy implements ITestMsgStrategy {\n  private readonly expectedText = 'New Signed Message (Mock Test)';\n  private readonly signedBy = 'B6BE3C4293DDCF66'; // could potentially grab this from test-secrets.json file\n\n  public test = async (mimeMsg: ParsedMail) => {\n    const keyInfo = await Config.getKeyInfo([\"flowcrypt.compatibility.1pp1\", \"flowcrypt.compatibility.2pp1\"]);\n    const decrypted = await MsgUtil.decryptMessage({ kisWithPp: keyInfo!, encryptedData: Buf.fromUtfStr(mimeMsg.text!) });\n    if (!decrypted.success) {\n      throw new HttpClientErr(`Error: Could not successfully verify signed message`);\n    }\n    if (!decrypted.signature) {\n      throw new HttpClientErr(`Error: The message isn't signed.`);\n    }\n    if (decrypted.signature.signer?.longid !== this.signedBy) {\n      throw new HttpClientErr(`Error: expected message signed by ${this.signedBy} but was actually signed by ${decrypted.signature.signer?.longid}`);\n    }\n    const content = decrypted.content.toUtfStr();\n    if (!content.includes(this.expectedText)) {\n      throw new HttpClientErr(`Error: Contents don't match. Expected: '${this.expectedText}' but got: '${content}'.`);\n    }\n  }\n}\n\nclass PlainTextMessageTestStrategy implements ITestMsgStrategy {\n  private readonly expectedText = 'New Plain Message';\n\n  public test = async (mimeMsg: ParsedMail) => {\n    if (!mimeMsg.text?.includes(this.expectedText)) {\n      throw new HttpClientErr(`Error: Msg Text is not matching expected. Current: '${mimeMsg.text}', expected: '${this.expectedText}'`);\n    }\n  }\n}\n\nclass IncludeQuotedPartTestStrategy implements ITestMsgStrategy {\n  private readonly quotedContent: string = [\n    'On 2019-06-14 at 23:24, flowcrypt.compatibility@gmail.com wrote:',\n    '> This is some message',\n    '> ',\n    '> and below is the quote',\n    '> ',\n    '> > this is the quote',\n    '> > still the quote',\n    '> > third line',\n    '> >> double quote',\n    '> >> again double quote'\n  ].join('\\n');\n\n  public test = async (mimeMsg: ParsedMail) => {\n    const keyInfo = await Config.getKeyInfo([\"flowcrypt.compatibility.1pp1\", \"flowcrypt.compatibility.2pp1\"]);\n    const decrypted = await MsgUtil.decryptMessage({ kisWithPp: keyInfo!, encryptedData: Buf.fromUtfStr(mimeMsg.text!) });\n    if (!decrypted.success) {\n      throw new HttpClientErr(`Error: can't decrypt message`);\n    }\n    const textContent = decrypted.content.toUtfStr();\n    if (!textContent.endsWith(this.quotedContent)) {\n      throw new HttpClientErr(`Error: Quoted content isn't included to the Msg. Msg text: '${textContent}'\\n Quoted part: '${this.quotedContent}'`, 400);\n    }\n  }\n}\n\nclass NewMessageCCAndBCCTestStrategy implements ITestMsgStrategy {\n  public test = async (mimeMsg: ParsedMail) => {\n    const hasAtLeastOneRecipient = (ao: AddressObject[]) => ao && ao.length && ao[0].value && ao[0].value.length && ao[0].value[0].address;\n    if (!hasAtLeastOneRecipient(parsedMailAddressObjectAsArray(mimeMsg.to))) {\n      throw new HttpClientErr(`Error: There is no 'To' header.`, 400);\n    }\n    if (!hasAtLeastOneRecipient(parsedMailAddressObjectAsArray(mimeMsg.cc))) {\n      throw new HttpClientErr(`Error: There is no 'Cc' header.`, 400);\n    }\n    if (!hasAtLeastOneRecipient(parsedMailAddressObjectAsArray(mimeMsg.bcc))) {\n      throw new HttpClientErr(`Error: There is no 'Bcc' header.`, 400);\n    }\n  }\n}\n\nclass SmimeEncryptedMessageStrategy implements ITestMsgStrategy {\n  public test = async (mimeMsg: ParsedMail) => {\n    expect((mimeMsg.headers.get('content-type') as StructuredHeader).value).to.equal('application/pkcs7-mime');\n    expect((mimeMsg.headers.get('content-type') as StructuredHeader).params.name).to.equal('smime.p7m');\n    expect((mimeMsg.headers.get('content-type') as StructuredHeader).params['smime-type']).to.equal('enveloped-data');\n    expect(mimeMsg.headers.get('content-transfer-encoding')).to.equal('base64');\n    expect((mimeMsg.headers.get('content-disposition') as StructuredHeader).value).to.equal('attachment');\n    expect((mimeMsg.headers.get('content-disposition') as StructuredHeader).params.filename).to.equal('smime.p7m');\n    expect(mimeMsg.headers.get('content-description')).to.equal('S/MIME Encrypted Message');\n    expect(mimeMsg.attachments!.length).to.equal(1);\n    expect(mimeMsg.attachments![0].contentType).to.equal('application/pkcs7-mime');\n    expect(mimeMsg.attachments![0].filename).to.equal('smime.p7m');\n    expect(mimeMsg.attachments![0].size).to.be.greaterThan(300);\n  }\n}\n\nexport class TestBySubjectStrategyContext {\n  private strategy: ITestMsgStrategy;\n\n  constructor(subject: string) {\n    if (subject.includes('testing quotes')) {\n      this.strategy = new IncludeQuotedPartTestStrategy();\n    } else if (subject.includes('Testing CC And BCC')) {\n      this.strategy = new NewMessageCCAndBCCTestStrategy();\n    } else if (subject.includes('New Plain Message')) {\n      this.strategy = new PlainTextMessageTestStrategy();\n    } else if (subject.includes('New Signed Message (Mock Test)')) {\n      this.strategy = new SignedMessageTestStrategy();\n    } else if (subject.includes('Test Footer (Mock Test)')) {\n      this.strategy = new MessageWithFooterTestStrategy();\n    } else if (subject.includes('PWD encrypted message')) {\n      this.strategy = new PwdEncryptedMessageTestStrategy();\n    } else if (subject.includes('Message With Image')) {\n      this.strategy = new SaveMessageInStorageStrategy();\n    } else if (subject.includes('Message With Test Text')) {\n      this.strategy = new SaveMessageInStorageStrategy();\n    } else if (subject.includes('send with single S/MIME cert')) {\n      this.strategy = new SmimeEncryptedMessageStrategy();\n    } else if (subject.includes('send with several S/MIME certs')) {\n      this.strategy = new SmimeEncryptedMessageStrategy();\n    } else if (subject.includes('send with S/MIME attachment')) {\n      this.strategy = new SmimeEncryptedMessageStrategy();\n    } else {\n      throw new UnsuportableStrategyError(`There isn't any strategy for this subject: ${subject}`);\n    }\n  }\n\n  public test = async (mimeMsg: ParsedMail, base64Msg: string) => {\n    await this.strategy.test(mimeMsg, base64Msg);\n  }\n}\n",
    "test/source/mock/key-manager/key-manager-endpoints.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { HttpClientErr } from '../lib/api';\nimport { HandlersDefinition } from '../all-apis-mock';\nimport { isPut, isGet } from '../lib/mock-util';\nimport { oauth } from '../lib/oauth';\nimport { Dict } from '../../core/common';\nimport { expect } from 'chai';\nimport { KeyUtil } from '../../core/crypto/key';\nimport { testConstants } from '../../tests/tooling/consts';\n\n// tslint:disable:max-line-length\n/* eslint-disable max-len */\n// tslint:disable:no-unused-expression\n/* eslint-disable no-unused-expressions */\n\nconst existingPrv = '-----BEGIN PGP PRIVATE KEY BLOCK-----\\r\\nVersion: FlowCrypt 7.6.2 Gmail Encryption\\r\\nComment: Seamlessly send and receive encrypted email\\r\\n\\r\\n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\\r\\n=tqvP\\r\\n-----END PGP PRIVATE KEY BLOCK-----\\r\\n';\n\nconst twoKeys1 = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\nyop5IsJlO6jh3rWU0YsjGg==\n=Wyxv\n-----END PGP PRIVATE KEY BLOCK-----`;\nconst twoKeys2 = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\nrplQXs015ts=\n=lGnP\n-----END PGP PRIVATE KEY BLOCK-----`;\n\nconst prvNoSubmit = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\n=DUFa\n-----END PGP PRIVATE KEY BLOCK-----\n`;\n\nexport const MOCK_KM_LAST_INSERTED_KEY: { [acct: string]: { decryptedPrivateKey: string, publicKey: string } } = {}; // accessed from test runners\n\nexport const mockKeyManagerEndpoints: HandlersDefinition = {\n  '/flowcrypt-email-key-manager/keys/private': async ({ body }, req) => {\n    const acctEmail = oauth.checkAuthorizationHeaderWithIdToken(req.headers.authorization);\n    if (isGet(req)) {\n      if (acctEmail === 'wkd@google.mock.flowcryptlocal.test:8001') {\n        return { privateKeys: [{ decryptedPrivateKey: testConstants.wkdAtgooglemockflowcryptlocalcom8001Private }] };\n      }\n      if (acctEmail === 'get.key@key-manager-autogen.flowcrypt.test') {\n        return { privateKeys: [{ decryptedPrivateKey: existingPrv }] };\n      }\n      if (acctEmail === 'get.key@no-submit-org-rule.key-manager-autogen.flowcrypt.test') {\n        return { privateKeys: [{ decryptedPrivateKey: prvNoSubmit }] };\n      }\n      if (acctEmail === 'two.keys@key-manager-autogen.flowcrypt.test') {\n        return { privateKeys: [{ decryptedPrivateKey: twoKeys1 }, { decryptedPrivateKey: twoKeys2 }] };\n      }\n      if (acctEmail === 'user@key-manager-no-pub-lookup.flowcrypt.test') {\n        return { privateKeys: [{ decryptedPrivateKey: existingPrv }] };\n      }\n      if (acctEmail === 'put.key@key-manager-autogen.flowcrypt.test') {\n        return { privateKeys: [] };\n      }\n      if (acctEmail === 'put.error@key-manager-autogen.flowcrypt.test') {\n        return { privateKeys: [] };\n      }\n      if (acctEmail === 'reject.client.keypair@key-manager-autogen.flowcrypt.test') {\n        return { privateKeys: [] };\n      }\n      if (acctEmail === 'expire@key-manager-keygen-expiration.flowcrypt.test') {\n        return { privateKeys: [] };\n      }\n      if (acctEmail === 'get.error@key-manager-autogen.flowcrypt.test') {\n        throw new Error('Intentional error for get.error to test client behavior');\n      }\n      throw new HttpClientErr(`Unexpectedly calling mockKeyManagerEndpoints:/keys/private GET with acct ${acctEmail}`);\n    }\n    if (isPut(req)) {\n      const { decryptedPrivateKey, publicKey } = body as Dict<string>;\n      if (acctEmail === 'put.key@key-manager-autogen.flowcrypt.test') {\n        const prv = await KeyUtil.parseMany(decryptedPrivateKey);\n        expect(prv).to.have.length(1);\n        expect(prv[0].algo.bits).to.equal(2048);\n        expect(prv[0].identities).to.have.length(1);\n        expect(prv[0].identities[0]).to.equal('First Last <put.key@key-manager-autogen.flowcrypt.test>');\n        expect(prv[0].isPrivate).to.be.true;\n        expect(prv[0].fullyDecrypted).to.be.true;\n        expect(prv[0].expiration).to.not.exist;\n        const pub = await KeyUtil.parseMany(publicKey);\n        expect(pub).to.have.length(1);\n        expect(pub[0].algo.bits).to.equal(2048);\n        expect(pub[0].identities).to.have.length(1);\n        expect(pub[0].identities[0]).to.equal('First Last <put.key@key-manager-autogen.flowcrypt.test>');\n        expect(pub[0].isPrivate).to.equal(false);\n        expect(pub[0].expiration).to.not.exist;\n        expect(pub[0].id).to.equal(prv[0].id);\n        MOCK_KM_LAST_INSERTED_KEY[acctEmail] = { decryptedPrivateKey, publicKey };\n        return {};\n      }\n      if (acctEmail === 'put.error@key-manager-autogen.flowcrypt.test') {\n        throw new Error('Intentional error for put.error user to test client behavior');\n      }\n      if (acctEmail === 'reject.client.keypair@key-manager-autogen.flowcrypt.test') {\n        throw new HttpClientErr(`No key has been generated for ${acctEmail} yet. Please ask your administrator.`, 405);\n      }\n      if (acctEmail === 'expire@key-manager-keygen-expiration.flowcrypt.test') {\n        const prv = await KeyUtil.parseMany(decryptedPrivateKey);\n        expect(prv).to.have.length(1);\n        expect(prv[0].algo.bits).to.equal(2048);\n        expect(prv[0].identities).to.have.length(1);\n        expect(prv[0].identities[0]).to.equal('First Last <expire@key-manager-keygen-expiration.flowcrypt.test>');\n        expect(prv[0].isPrivate).to.be.true;\n        expect(prv[0].fullyDecrypted).to.be.true;\n        expect(prv[0].expiration).to.exist;\n        const pub = await KeyUtil.parseMany(publicKey);\n        expect(pub).to.have.length(1);\n        expect(pub[0].algo.bits).to.equal(2048);\n        expect(pub[0].id).to.equal(prv[0].id);\n        expect(pub[0].identities).to.have.length(1);\n        expect(pub[0].identities[0]).to.equal('First Last <expire@key-manager-keygen-expiration.flowcrypt.test>');\n        expect(pub[0].isPrivate).to.be.false;\n        expect(pub[0].expiration).to.exist;\n        MOCK_KM_LAST_INSERTED_KEY[acctEmail] = { decryptedPrivateKey, publicKey };\n        return {};\n      }\n      throw new HttpClientErr(`Unexpectedly calling mockKeyManagerEndpoints:/keys/private PUT with acct ${acctEmail}`);\n    }\n    throw new HttpClientErr(`Unknown method: ${req.method}`);\n  },\n  '/flowcrypt-email-key-manager/keys/public/?': async ({ }, req) => {\n    if (!isGet(req)) {\n      throw new Error(`keys/public: expecting GET, got ${req.method}`);\n    }\n    const query = req.url!.split('/').pop()!;\n    const publicKey = KeyUtil.armor(await KeyUtil.asPublicKey(await KeyUtil.parse(existingPrv)));\n    if (query.includes('@')) { // search by email\n      const email = query.toLowerCase().trim();\n      if (email === 'find.public.key@key-manager-autogen.flowcrypt.test') {\n        return { publicKeys: [{ publicKey }] };\n      }\n      if (email === 'not.suppposed.to.lookup@key-manager-no-pub-lookup.flowcrypt.test') {\n        throw Error(`Not supposed to lookup on EKM based on NO_KEY_MANAGER_PUB_LOOKUP rule: ${email}`);\n      }\n      return { publicKeys: [] };\n    } else { // search by fingerprint\n      // const fingerprint = query;\n      return { publicKeys: [] };\n    }\n  },\n};\n",
    "test/source/mock/wkd/wkd-endpoints.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { KeyUtil } from '../../core/crypto/key.js';\nimport { PgpArmor } from '../../core/crypto/pgp/pgp-armor.js';\nimport { testConstants } from '../../tests/tooling/consts.js';\nimport { HandlersDefinition } from '../all-apis-mock';\n\nconst alice = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmDMEXgS/LxYJKwYBBAHaRw8BAQdAJ/BnDcmcOCED/rW3y1zPHSX6lABI7G19R6mP\nhgfIgj+0EUFsaWNlIDxhbGljZUBybnA+iJAEExYIADgWIQRz7cyRGa/I4tu9zeUE\nUUCWaf/ePAUCXgS/LwIbAwULCQgHAgYVCgkICwIEFgIDAQIeAQIXgAAKCRAEUUCW\naf/ePCSdAP9OWq8uOk5B5LUtPvFnxqGkrZlAHt+tgR271QSggRV3MAEAvtL/ru5o\nss9jx26EqYj2GUgHGtsYqsz8j1y97S5lMQo=\n=H16D\n-----END PGP PUBLIC KEY BLOCK-----`;\n\nconst johnDoe = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxsBNBF+IiY4BCADiCm145EEu8QALcex4OY+K7AEof4w2ZFW0Xj9wRodRj5WMEk0h5TOXlCr9Fzah\nN75pl7W7jkYJUSUWucSga2tiIphR3JkPVDod6QUgwKSw/ZbXef9IY10bg4k+jobWToy4FmhOxUoZ\nMfYGRMJKAwWBXajygbFp3XLV08BTToK4VRzA5/jZqjTmBnQ4Dut+F+TtdEve4WII/vtKYdpt7uSp\nC3beifG0GD+bwoHit1hlsawN7iHGNjvszSGm9gXSRvF2dBskSgR2mtMC2HkgkhxR8Xrc5lBJAqPd\nV05wvzjg26BXBEhe8AhJbqmnwUuEt40MleWuQPUMM0MBHtWfDIMxABEBAAHNEmpvaG4uZG9lQGxv\nY2FsaG9zdMLAiQQTAQgAMxYhBMsbekG6fBy6oIphZrkCy2XGlNa0BQJfiImUAhsDBQsJCAcCBhUI\nCQoLAgUWAgMBAAAKCRC5AstlxpTWtCOMCACS/BgBU+/11SCzKcyjXHECPoJC2zxjBHZELaA8YRAP\nCX9SIdWiaP06F7HTRrvBUqFuPtebA62GmF6PCyWv3wM7iY8HWrNNWnRgclfn203s6LpkIO8myzPi\nitH15+2+CoKRD9QnGbkLZqOe+20ZG8AalciSnQm2QNMMd5RXyUhI8YxWFwzmd9rw18yA5r+P2g2y\nuwC0PHbJDeRPzVsX5ZPVty00MCCOtJxcjTMszEVrndae78i2X7lI4WllGXvouw5nYJ4QCJxnE7IN\ntrwEW2/oqt1deeKAzDqtBlaz5eKameQhzCfIQ9yIvIxmS4GS25FScIBCqQktncKhujI2HfPbzsBN\nBF+IiZQBCADAyDpTiMghfyWWqdqM09afztzzePk02xJJYRO/p09wgmqPaWgxfe//NqiFPDfiTyvc\nnDLCDKuFktU5uD+I6UGVj7511r9veDh9Q+YB81qria0NONJtYN+bJ0T+depUAlOfNRSf9U79iuck\nEHQR0j+4WLXHfqNR+CP9uobXZeAuyU47/KGXLvpO0GV1f8oDIxHW/ZnArFjXFHCbEwFg2Gbdedd6\n7gFMc18Q4brfhA4XbMyN0rybipmuylWGIXM30O7cJDBg7+wM3CGRU/aiPCuFkGyknJvRMcjd2XnK\nJxqRhvtIF4ZFoXMTi3U2ZqBjkrInECEIVxo0ImNmugzPFyCHABEBAAHCwHYEGAEIACAWIQTLG3pB\nunwcuqCKYWa5AstlxpTWtAUCX4iJmQIbDAAKCRC5AstlxpTWtBJiB/9HkI+URaTsMYA+Jh98Ia9J\nU57naEB/iugXGiStORK/QQfa3/aSnVeCI/NU2Ja0QKwb/QkjeTA8J6pSXjz5BqQs6Ydgww/cTHfZ\neqx9TuETieW/vzdBtkEHPNAWk4h6uB3KlE+WiaErLqMp/ibp3XlDizDzIanxBGwJH3n0xbsII2c4\nSk0/2pKhkHZeombiFhL4Ius6Ym82DsaHg/ngq0Alm9lUrZd2bhKWuOlUXF/kl1BtFuxQSNhAD13r\nGOcKZI9WfvN8IV5P8oh/ldHcF8WUumQEFIAR3WGk8P9v1XfHtBFeDQ70ZoE+KV7Uy7UKAzcVni4O\nAwMwBxWpyLaH6xjb\n=mswb\n-----END PGP PUBLIC KEY BLOCK-----`;\n\nconst johnDoe1 = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxsBNBF+Jz04BCACYEg0Fkg4NLnTxzuyF3gnz2pMfp+BelG/IHvIg9mls4U8OJcjGyq3bVpPDKDDQ\n4ZuhRtrMy5K0ZnyiGsmzMKXvVS3FUPQ5EJD2Laveo5ohtM6t49jlloQvv7aMUBVpjTskaY06lJuV\n2f1CCCDteh3G8qNpKvziUc4a8PzeIItktHTCa0MNdDRxq19DUs2eQGGXqBDm/mQjVMZ1Zgt55Ymu\nBpPLytJXOjRoDYsTj+OdOv+aQ4Td7JnicTDVQR4Uc9x02lMPsBF3K0N0cnITyiKCV/QdgdSQkL8N\nzFVgvt5QPGhlGA0sAl1wiBFeNZrrd+VXg4FmuGrWd9YLS01AyRSJABEBAAHNEmpvaG4uZG9lQDEy\nNy4wLjAuMcLAiQQTAQgAMxYhBGWfN6kiReeNpwCbUy2oGOH1OKOdBQJfic9SAhsDBQsJCAcCBhUI\nCQoLAgUWAgMBAAAKCRAtqBjh9TijnU1JB/wPcImnOmo42gu8YBKe18d9HyCQNs4q4pw/bYXshLe7\naMjx+XgUvWHBcoTtz+4g2QjmhmL3ROkGs/vBriZZqhZz4636s7RAlyU0yyzcH4rvNq/ByNm+Ol7x\nBwo3EbaRh46Q4mbctslfQ/jd42cUzwEOnY2HSPH+tgfTjd8xciBL5tH0+YinCuqSi/sAOkBoNAkv\nkgiA+cRH4scVsW2KwWuZPOJINO8nJVu0at64sZib8/UJ4Zku5w7i1dnmWu6C9aqz+Ddu/xcDUW8j\n2GFXECJX0deXZmhEZ8wLt5P+ke3Wt1gttGCigVzPvpXHkpZpC7zlykcMeE2ywRBqypauZUjPzsBN\nBF+Jz1IBCACjRVxKy2aU49H95g8LM1Dsqmc+KCSOl9/kC1pyzKl4xUEYQ+ok5OKHt9tf42a1z9SM\noUicFkSOwBMtjOhWjrghxVBHIc4NtDewFXY6IifG6BvewOiNat2mYzfLF852idBbhnN82p4NWd2g\noUwDcqOvZ3Z5qg4eKiH2l+UzlHuFXmSfFP3g7Pm3UTaYhOWRBwOO/u7JN9rMHBcLxfp7T745C8dT\nUmrZEpfTEGgwhmYfBFyMZFxzgtZwt4UUTnyLFtqhROPx6ji4ecSDNAD7yVjd9uJSNbxIRV4SUPCG\n/vR39Lm8dXiFEek47DYGPaPyid/zfFkfhLndQ70W2GkhGdLnABEBAAHCwHYEGAEIACAWIQRlnzep\nIkXnjacAm1MtqBjh9TijnQUCX4nPVwIbDAAKCRAtqBjh9Tijna+wB/4tsj016eBsQGb3xGs/BBa6\n06VLL9tjrTV9TdZj3DfpE9xSPiNC+Jah09uW//VNRzNTDYctGXEGIYm2tx2q8QAX/rWBC/UYi16l\n4lHnvlHa4NNA+O22uQpMlwmbTVSPTs4kVUSpNyuOtE6SXY6UyzcyvwTpffXiQkfICW7BXmykUXHx\nHZ8Ddq/syp3eBitlmNZHGwRWKD5ihd96o5dCw/Dgpz/p6dxka1627j013wov65p1NbXiV1kM7G7s\nZccLrjYxOL/1Rc1ac9TdfXX7lVeZtbpSVhSl9Z1YMhth+oWVJ79iQQ8OPKEvt471Qwk1LH7k4a9O\nnT5+WNnpAkcxrjMd\n=fISM\n-----END PGP PUBLIC KEY BLOCK-----\n`;\n\nconst jackAdvanced = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxsBNBF+J56IBCADSvEei1mAEQCEXHxaOKzsxvM8Qvgjj0vr+zHE+hUFg1znRAyjQ9XSDGwJ4+dut\nkKh8P2Ibu8hhX01eHiqW85IXO2yvLDo19+8TnRHQGfn895Ptxs150Xcg4gwXPzvY9tIXV4+z+vm2\nek7tM3zI4IXpT/VCasVHHn34C6qupkJSviZwC+SoXPS5flFXNSGktALC9OIpDzW1qqtIpl2niG2I\n4Df4yn3iiRVM8Zt4SGxsvcSXbsAAVEev7BQTUgxin5DlWkA7R9zaiBQ/DkO1JCEXJVvqpK1ETxi3\nK/3rkmmob3mICp0QXpgpllik6jH5YXGtK0Dbly9IXPH03smrpBS7ABEBAAHNF2phY2suYWR2YW5j\nZWRAbG9jYWxob3N0wsCJBBMBCAAzFiEEFpnGj5ZL0Um8kGZee64HZY9qWHgFAl+J56cCGwMFCwkI\nBwIGFQgJCgsCBRYCAwEAAAoJEHuuB2WPalh4frQH/jWdjU1OPy0mMToZFRF81j4v1eyziyBSPjWV\nMxvqNMSeBxHBmDWsfcWesvUi24kodiAYnJW8zAN9N99BATgGgvGNkghq4AFneOWBXDwQi8t+5H0v\nc9JXSUbE/NH1JuqkPoF6p2flcR3VIhmfOEKMfKcCSyLRykiDQxGjkGwBMo/Dmv6iC0qJu95u/8PG\nC8hnLmkORJFs0Ql0lTTqKrZQdhdyS34Ad99YwbNjtZvZcfIRljiMaJlwsj9e/kj9Ppn7PZWgs20X\n/reafSKWyPFsgQyNzWnmXggrodvVKrj2NHlFlAqYyKNujbz0NdpwBx4U4WBFIpSZ2HLNT+chHdnr\nNlfOwE0EX4nnpwEIALRviWiViluglkUGltBX6rWwYjY8niPbBaXC+xus4uH08IlDO/aDD2t4efkP\nt0QMeQE9WYsRk8hHUC+isJRF+jbwVhAW1fkv4R3WWkwXQFsr0wXW4Krp30m9JaOW9EolDwv8/Fik\nXmkBhWviByqBDvZ9CPtEt5Nwd6XT49Cf4HycQvrkKC3ytYohs2iyf+T7BLKJr6y3zDlaBtXaoqpA\nwIXBduoccL01MyrGxLeLF56W75SZmtE4CK0G6g/zjjwmawKDSfK6DZHARYC/ZguUocnpB3Ui7B8d\nsprqB1QmQZJQt7By6EUvhnw1WYAiDD05xryFPNhXYt3+Ypid/N/A2eEAEQEAAcLAdgQYAQgAIBYh\nBBaZxo+WS9FJvJBmXnuuB2WPalh4BQJfieetAhsMAAoJEHuuB2WPalh4TvgIAIRkAuvvl+9p8xPg\npfMp5muIpVFjWmMUBIT8MEXZvVSr3YUpDmHxTgbL78Hf9Fk7rAw7tkFFz+cZltnIDITUCyGdIJaF\ndow3a+ImNZ/eo6zcftWJiyH1zM5w5aEcWNUnHpy8TDRIFgomt1K1DcAo2zoutpGylCF5ZeL6vqFw\nafV6xkjQ9+neZ2LahN5cYNOKAeeI73hvoGFSCYp9Ih8JaEhG6seU9lskg2qQDvVEJaHHp0nPxbU/\nmhejIVi+pinqouXEqSb+84n2dNQ7HdgGe1YBM8kvNzq9SLfcYWjpnkchoL+5KGksjgbOvKFDz1Ek\nnmusEeYtrrMytL4oUohBVZk=\n=bbav\n-----END PGP PUBLIC KEY BLOCK-----\n`;\n\n// todo - add a not found test with: throw new HttpClientErr('Pubkey not found', 404);\n\nexport const mockWkdEndpoints: HandlersDefinition = {\n  '/.well-known/openpgpkey/hu/st5or5guodbnsiqbzp6i34xw59h1sgmw?l=wkd': async () => {\n    // direct for wkd@google.mock.flowcryptlocal.test:8001\n    const pub = await KeyUtil.asPublicKey(await KeyUtil.parse(testConstants.wkdAtgooglemockflowcryptlocalcom8001Private));\n    return Buffer.from((await PgpArmor.dearmor(KeyUtil.armor(pub))).data);\n  },\n  '/.well-known/openpgpkey/hu/ihyath4noz8dsckzjbuyqnh4kbup6h4i?l=john.doe': async () => {\n    return Buffer.from((await PgpArmor.dearmor(johnDoe1)).data); // direct for john.doe@localhost\n  },\n  '/.well-known/openpgpkey/hu/ihyath4noz8dsckzjbuyqnh4kbup6h4i?l=John.Doe': async () => {\n    return Buffer.from((await PgpArmor.dearmor(johnDoe1)).data); // direct for John.Doe@localhost\n  },\n  '/.well-known/openpgpkey/hu/cb53pfqmbzc8mm3ecbjxyen65fdxos56?l=jack.advanced': async () => {\n    return Buffer.from((await PgpArmor.dearmor(jackAdvanced)).data); // direct for jack.advanced@localhost\n  },\n  '/.well-known/openpgpkey/localhost/hu/ihyath4noz8dsckzjbuyqnh4kbup6h4i?l=john.doe': async () => {\n    return Buffer.from((await PgpArmor.dearmor(johnDoe)).data); // advanced for john.doe@localhost\n  },\n  '/.well-known/openpgpkey/localhost/hu/ihyath4noz8dsckzjbuyqnh4kbup6h4i?l=John.Doe': async () => {\n    return Buffer.from((await PgpArmor.dearmor(johnDoe)).data); // advanced for John.Doe@localhost\n  },\n  '/.well-known/openpgpkey/localhost/hu/pob4adi8roqdsmtmxikx68pi6ij35oca?l=incorrect': async () => {\n    return Buffer.from((await PgpArmor.dearmor(alice)).data); // advanced for incorrect@localhost\n  },\n  '/.well-known/openpgpkey/localhost/hu/66iu18j7mk6hod4wqzf6qd37u6wejx4y?l=some.revoked': async () => {\n    return Buffer.from([\n      ...(await PgpArmor.dearmor(testConstants.somerevokedRevoked1)).data,\n      ...(await PgpArmor.dearmor(testConstants.somerevokedValid)).data,\n      ...(await PgpArmor.dearmor(testConstants.somerevokedRevoked2)).data,\n    ]);\n  },\n  '/.well-known/openpgpkey/localhost/policy': async () => {\n    return ''; // allow advanced for localhost\n  },\n  '/.well-known/openpgpkey/policy': async () => {\n    return ''; // allow direct for all\n  },\n};\n",
    "test/source/mock.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { startAllApisMock } from './mock/all-apis-mock';\n\nexport const mock = async (logger: (line: string) => void) => {\n  return await startAllApisMock(logger);\n};\n\nif (require.main === module) {\n  mock(msgLog => console.log(msgLog)).catch(e => {\n    console.error(e);\n    process.exit(1);\n  });\n}\n",
    "test/source/platform/catch.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n'use strict';\n\nconst VERSION = 'B.1.0';\n\nexport type ObjWithStack = { stack: string };\nexport class UnreportableError extends Error { }\n\nexport class Catch {\n\n  public static RUNTIME_VERSION = VERSION;\n  public static RUNTIME_ENVIRONMENT = 'undetermined';\n\n  public static handleErr = (e: any) => { // eslint-disable-line @typescript-eslint/no-unused-vars\n    // core errs that are not rethrown are not very interesting\n  }\n\n  public static reportErr = (err: any) => { // eslint-disable-line @typescript-eslint/no-unused-vars\n    // core reports are not very interesting\n  }\n\n  public static report = (name: string) => { // eslint-disable-line @typescript-eslint/no-unused-vars\n    // core reports are not very interesting\n  }\n\n  public static doesReject = async (p: Promise<unknown>, errNeedle?: string[]): Promise<boolean> => {\n    try {\n      await p;\n      return false;\n    } catch (e) {\n      if (!errNeedle) { // no needles to check against\n        return true;\n      }\n      return !!errNeedle.find(needle => String(e).includes(needle));\n    }\n  }\n\n  public static undefinedOnException = async <T>(p: Promise<T>): Promise<T | undefined> => {\n    try {\n      return await p;\n    } catch (e) {\n      return undefined;\n    }\n  }\n\n  public static version = () => {\n    return Catch.RUNTIME_VERSION;\n  }\n\n}\n",
    "test/source/platform/store/contact-store.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n// tslint:disable:no-null-keyword\n\nimport { Contact, Key, KeyUtil } from '../../core/crypto/key';\n\nconst DATA: Contact[] = [];\n\nexport type ContactUpdate = {\n  email?: string;\n  name?: string | null;\n  pubkey?: Key;\n  lastUse?: number | null;\n};\n\nexport class ContactStore {\n\n  public static get = async (db: void, emailOrLongid: string[]): Promise<(Contact | undefined)[]> => {\n    const result = DATA.filter(x => emailOrLongid.includes(x.email) ||\n      // is there any intersection\n      (x.pubkey && KeyUtil.getPubkeyLongids(x.pubkey).some(y => emailOrLongid.includes(y))));\n    return result;\n  }\n\n  public static update = async (db: void, email: string | string[], update: ContactUpdate): Promise<void> => {\n    if (Array.isArray(email)) {\n      await Promise.all(email.map(oneEmail => ContactStore.update(db, oneEmail, update)));\n      return;\n    }\n    let [updated] = await ContactStore.get(db, [email]);\n    if (!updated) { // updating a non-existing contact, insert it first\n      updated = await ContactStore.obj({ email });\n      DATA.push(updated);\n    }\n    if (update.pubkey?.isPrivate) {\n      update.pubkey = await KeyUtil.asPublicKey(update.pubkey);\n    }\n    for (const k of Object.keys(update)) {\n      // @ts-ignore\n      updated[k] = update[k];\n    }\n    if (update.pubkey) {\n      const key = typeof update.pubkey === 'string' ? await KeyUtil.parse(update.pubkey) : update.pubkey;\n      updated.pubkey = key;\n      updated.fingerprint = key.id;\n      updated.expiresOn = key.expiration ? Number(key.expiration) : null;\n      updated.hasPgp = 1;\n    }\n  }\n\n  public static obj = async ({ email, name, pubkey, lastUse, lastCheck }: any): Promise<Contact> => {\n    if (!pubkey) {\n      return {\n        email,\n        name: name || null,\n        pubkey: undefined,\n        hasPgp: 0, // number because we use it for sorting\n        fingerprint: null,\n        lastUse: lastUse || null,\n        pubkeyLastCheck: null,\n        expiresOn: null,\n        revoked: false\n      };\n    }\n    const pk = await KeyUtil.parse(pubkey);\n    const contact = {\n      email,\n      name,\n      pubkey: pk,\n      hasPgp: 1, // number because we use it for sorting\n      fingerprint: pk.id,\n      lastUse,\n      pubkeyLastCheck: lastCheck,\n      revoked: pk.revoked\n    } as Contact;\n    return contact;\n  }\n\n  public static save = async (db: any, contact: Contact | Contact[]): Promise<void> => {\n    if (Array.isArray(contact)) {\n      DATA.push(...contact);\n    } else {\n      DATA.push(contact);\n    }\n  }\n}\n",
    "test/source/test.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as ava from 'ava';\n\nimport { AvaContext, getDebugHtmlAtts, minutes, standaloneTestTimeout } from './tests/tooling';\nimport { BrowserHandle, BrowserPool } from './browser';\nimport { Config, Util, getParsedCliParams } from './util';\n\nimport { BrowserRecipe } from './tests/tooling/browser-recipe';\nimport { FlowCryptApi } from './tests/tooling/api';\nimport { defineComposeTests } from './tests/compose';\nimport { defineDecryptTests } from './tests/decrypt';\nimport { defineElementTests } from './tests/elements';\nimport { defineFlakyTests } from './tests/flaky';\nimport { defineGmailTests } from './tests/gmail';\nimport { defineSettingsTests } from './tests/settings';\nimport { defineSetupTests } from './tests/setup';\nimport { defineUnitNodeTests } from './tests/unit-node';\nimport { defineUnitBrowserTests } from './tests/unit-browser';\nimport { mock } from './mock';\nimport { mockBackendData } from './mock/backend/backend-endpoints';\nimport { TestUrls } from './browser/test-urls';\nimport { writeFileSync } from 'fs';\n\nexport const { testVariant, testGroup, oneIfNotPooled, buildDir, isMock } = getParsedCliParams();\nexport const internalTestState = { expectIntentionalErrReport: false }; // updated when a particular test that causes an error is run\nconst DEBUG_BROWSER_LOG = false; // set to true to print / export information from browser\nconst DEBUG_MOCK_LOG = false; // se to true to print mock server logs\n\nprocess.setMaxListeners(60);\n\nconst consts = { // higher concurrency can cause 429 google errs when composing\n  TIMEOUT_SHORT: minutes(1),\n  TIMEOUT_EACH_RETRY: minutes(3),\n  TIMEOUT_ALL_RETRIES: minutes(13), // this has to suffer waiting for semaphore between retries, thus almost the same as below\n  TIMEOUT_OVERALL: minutes(14),\n  ATTEMPTS: testGroup === 'STANDARD-GROUP' ? oneIfNotPooled(3) : process.argv.includes('--retry=false') ? 1 : 3,\n  POOL_SIZE: oneIfNotPooled(isMock ? 20 : 3),\n  PROMISE_TIMEOUT_OVERALL: undefined as any as Promise<never>, // will be set right below\n  IS_LOCAL_DEBUG: process.argv.includes('--debug') ? true : false, // run locally by developer, not in ci\n};\nconsole.info('consts: ', JSON.stringify(consts), '\\n');\nconsts.PROMISE_TIMEOUT_OVERALL = new Promise((resolve, reject) => setTimeout(() => reject(new Error(`TIMEOUT_OVERALL`)), consts.TIMEOUT_OVERALL));\n\nexport type Consts = typeof consts;\nexport type CommonAcct = 'compatibility' | 'compose' | 'ci.tests.gmail';\n\nconst browserPool = new BrowserPool(consts.POOL_SIZE, 'browserPool', false, buildDir, isMock, undefined, undefined, consts.IS_LOCAL_DEBUG);\nlet closeMockApi: () => Promise<void>;\nconst mockApiLogs: string[] = [];\n\nava.before('set config and mock api', async t => {\n  standaloneTestTimeout(t, consts.TIMEOUT_EACH_RETRY, t.title);\n  Config.extensionId = await browserPool.getExtensionId(t);\n  console.info(`Extension url: chrome-extension://${Config.extensionId}`);\n  if (isMock) {\n    const mockApi = await mock(line => {\n      if (DEBUG_MOCK_LOG) {\n        console.log(line);\n      }\n      mockApiLogs.push(line);\n    });\n    closeMockApi = mockApi.close;\n  }\n  t.pass();\n});\n\nconst testWithBrowser = (acct: CommonAcct | undefined, cb: (t: AvaContext, browser: BrowserHandle) => Promise<void>, flag?: 'FAILING'): ava.Implementation<{}> => {\n  return async (t: AvaContext) => {\n    await browserPool.withNewBrowserTimeoutAndRetry(async (t, browser) => {\n      const start = Date.now();\n      if (acct) {\n        await BrowserRecipe.setUpCommonAcct(t, browser, acct, !isMock);\n      }\n      await cb(t, browser);\n      if (DEBUG_BROWSER_LOG) {\n        try {\n          const page = await browser.newPage(t, TestUrls.extension('chrome/dev/ci_unit_test.htm'));\n          const items = await page.target.evaluate(() => (window as any).Debug.readDatabase()) as { input: unknown, output: unknown }[];\n          for (let i = 0; i < items.length; i++) {\n            const item = items[i];\n            const input = JSON.stringify(item.input);\n            const output = JSON.stringify(item.output, undefined, 2);\n            const file = `./test/tmp/${t.title}-${i}.txt`;\n            writeFileSync(file, `in: ${input}\\n\\nout: ${output}`);\n            t.log(`browser debug written to file: ${file}`);\n          }\n        } catch (e) {\n          t.log(`Error reading debug messages: ${e}`);\n        }\n      }\n      t.log(`run time: ${Math.ceil((Date.now() - start) / 1000)}s`);\n    }, t, consts, flag);\n    t.pass();\n  };\n};\n\nexport type TestWithBrowser = typeof testWithBrowser;\n\nava.after.always('close browsers', async t => {\n  standaloneTestTimeout(t, consts.TIMEOUT_SHORT, t.title);\n  await browserPool.close();\n  t.pass();\n});\n\nif (isMock) {\n  ava.after.always('close mock api', async t => {\n    standaloneTestTimeout(t, consts.TIMEOUT_SHORT, t.title);\n    closeMockApi().catch(t.log);\n    t.pass();\n  });\n}\n\nava.after.always('evaluate Catch.reportErr errors', async t => {\n  if (!isMock || testGroup !== 'STANDARD-GROUP') { // can only collect reported errs when running with a mocked api\n    t.pass();\n    return;\n  }\n  // todo - here we filter out an error that would otherwise be useful\n  // in one test we are testing an error scenario\n  // our S/MIME implementation is still early so it throws \"reportable\" errors like this during tests\n  const usefulErrors = mockBackendData.reportedErrors\n    .filter(e => e.message !== 'Too few bytes to read ASN.1 value.')\n    // below for test \"no.fes@example.com - skip FES on consumer, show friendly message on enterprise\"\n    .filter(e => !e.trace.includes('-1 when GET-ing https://fes.example.com'))\n    // todo - ideally mock tests would never call this. But we do tests with human@flowcrypt.com so it's calling here\n    .filter(e => !e.trace.includes('-1 when GET-ing https://openpgpkey.flowcrypt.com'));\n  const foundExpectedErr = usefulErrors.find(re => re.message === `intentional error for debugging`);\n  const foundUnwantedErrs = usefulErrors.filter(re => re.message !== `intentional error for debugging` && !re.message.includes('traversal forbidden'));\n  if (testVariant === 'CONSUMER-MOCK' && internalTestState.expectIntentionalErrReport && !foundExpectedErr) {\n    // on consumer flavor app, we submit errors to flowcrypt.com backend\n    t.fail(`Catch.reportErr errors: missing intentional error report on consumer flavor`);\n    return;\n  }\n  if (testVariant === 'ENTERPRISE-MOCK' && mockBackendData.reportedErrors.length) {\n    // on enterprise flavor app, we don't submit any errors anywhere yet\n    t.fail(`Catch.reportErr errors: should not report any error on enterprise app`);\n    return;\n  }\n  if (foundUnwantedErrs.length) {\n    for (const e of foundUnwantedErrs) {\n      console.info(`----- mockBackendData Catch.reportErr -----\\nname: ${e.name}\\nmessage: ${e.message}\\nurl: ${e.url}\\ntrace: ${e.trace}`);\n    }\n    t.fail(`Catch.reportErr errors: ${foundUnwantedErrs.length}`);\n  } else {\n    t.pass();\n  }\n});\n\nava.after.always('send debug info if any', async t => {\n  console.info('send debug info - deciding');\n  const failRnd = Util.lousyRandom();\n  const testId = `FlowCrypt Browser Extension ${testVariant} ${failRnd}`;\n  const debugHtmlAttachments = getDebugHtmlAtts(testId, mockApiLogs);\n  if (debugHtmlAttachments.length) {\n    console.info(`FAIL ID ${testId}`);\n    standaloneTestTimeout(t, consts.TIMEOUT_SHORT, t.title);\n    for (let i = 0; i < debugHtmlAttachments.length; i++) {\n      const subject = `${testId} ${i + 1}/${debugHtmlAttachments.length}`;\n      await FlowCryptApi.hookCiDebugEmail(subject, debugHtmlAttachments[i]);\n    }\n  } else {\n    console.info(`no fails to debug`);\n  }\n  t.pass();\n});\n\n\nif (testGroup === 'UNIT-TESTS') {\n  defineUnitNodeTests(testVariant);\n  defineUnitBrowserTests(testVariant, testWithBrowser);\n} else if (testGroup === 'FLAKY-GROUP') {\n  defineFlakyTests(testVariant, testWithBrowser);\n} else {\n  defineSetupTests(testVariant, testWithBrowser);\n  defineComposeTests(testVariant, testWithBrowser);\n  defineDecryptTests(testVariant, testWithBrowser);\n  defineGmailTests(testVariant, testWithBrowser);\n  defineSettingsTests(testVariant, testWithBrowser);\n  defineElementTests(testVariant, testWithBrowser);\n}\n",
    "test/source/tests/browser-unit-tests/unit-AttUI.js": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n/* eslint-disable max-len */\n\n/**\n * These tests use JavaScript instead of TypeScript to avoid dealing with types in cross-environment setup.\n * (tests are injected from NodeJS through puppeteer into a browser environment)\n * While this makes them less convenient to write, the result is more flexible.\n * \n * Import your lib to `ci_unit_test.ts` to resolve `ReferenceError: SomeClass is not defined`\n * \n * Each test must return \"pass\" to pass. To reject, throw an Error.\n * \n * Each test must start with one of (depending on which flavors you want it to run): \n *  - BROWSER_UNIT_TEST_NAME(`some test name`);\n *  - BROWSER_UNIT_TEST_NAME(`some test name`).enterprise;\n *  - BROWSER_UNIT_TEST_NAME(`some test name`).consumer;\n * \n * This is not a JavaScript file. It's a text file that gets parsed, split into chunks, and\n *    parts of it executed as javascript. The structure is very rigid. The only flexible place is inside\n *    the async functions. For the rest, do not change the structure or our parser will get confused.\n *    Do not put any code whatsoever outside of the async functions.\n */\n\nBROWSER_UNIT_TEST_NAME(`collectEncryptAtts preserves utf attachment names`);\n(async () => {\n  // DOM prep\n  $('body').append('<div id=\"fineuploader\"></div><button id=\"fineuploader_button\">attach</button>');\n  // test prep\n  const utfName = '\\u0410\\u0411\\u0412';\n  const encryptedUtfName = `${utfName}.pgp`;\n  const content = Buf.fromUtfStr('hello');\n  const attachmentUi = new AttachmentUI(() => Promise.resolve({ sizeMb: 5, size: 5 * 1024 * 1024, count: 1 }));\n  attachmentUi.initAttachmentDialog('fineuploader', 'fineuploader_button');\n  await new Promise((resolve) => setTimeout(resolve, 1000)); // the above method is actually async and needs some time\n  attachmentUi.addFile(new File([content], utfName));\n  await new Promise((resolve) => setTimeout(resolve, 1000)); // again it seems to need some time to crunch the new file\n  const pubkey = '-----BEGIN PGP PUBLIC KEY BLOCK-----\\nVersion: CryptUP 3.2.0 Easy Gmail Encryption https://cryptup.org\\nComment: Seamlessly send, receive and search encrypted email\\n\\nxsBNBFU0WMgBCACZSzijeN4YozhjmHU7BGWzW7ZbY6GGtJinByt8OnEnQ9TX\\n9zrAxbyr0grPE4On7nd3uepwNxJbk5LlaCwHNkpX39xKgDgCskRO9CfeqOIO\\n4l5Wjj4XldrgLSOGJe8Vmimo9UKmqsP5v8fR3mMyIqQbtE4G+Vq/J9A3uabr\\nf0XYVsBdBvVoJkQ83gtQrZoTA/zihNmtLXH9pTwtX8FJcqgFK6RgvfAh2jCz\\nDhT+reI50ZcuHRvVRxvrL172DFSQsLSdj8PcewS1J89knH4sjjBC/kwbLa0n\\ntod/gBPWw/uetaOJna43wNueUKKOl2kAXE4sw6ESIrlFDynJ4g05T9yxABEB\\nAAHNIlRvbSBKYW1lcyBIb2x1YiA8dG9tQGJpdG9hc2lzLm5ldD7CwFwEEAEI\\nABAFAlU0WM8JEA1WiOvzECvnAAAB4gf8DaIzZACUqkGEoI19HyBPtcrJT4mx\\nhKZ/Wts0C6TGj/OQXevDI+h2jQTYf8+fOqCdQev2Kwh/8mQV6wQqmN9uiVXO\\n5F4vAbWNfEve6mCVB5gi296mFf6kx04xC7VVYAJ3FUR72BplE/0+cwv9Nx2r\\nJh3QGFhoPaFMPtCAk0TgKcO0UkcBwXNzAV5Pgz0MT1COTWBXEej4yOrqdWoP\\nA6fEpV8aLaFnAt+zh3cw4A7SNAO9omGAUZeBl4Pz1IlN2lC2grc2zpqoxo8o\\n3W49JYTfExeCNVWhlSU74f6bpN6CMdSdrh5phOr+ffQQhEhkNblUgSZe6tKa\\nVFI1MhkJ6Xhrug==\\n=+de8\\n-----END PGP PUBLIC KEY BLOCK-----';\n  const pubkeyResult = { pubkey: await KeyUtil.parse(pubkey), email: 'some@email.com', isMine: false };\n  // test\n  const [att] = await attachmentUi.collectEncryptAttachments([pubkeyResult]);\n  if (att.name !== encryptedUtfName) {\n    throw Error(`Expected att.name to equal \"${encryptedUtfName}\" but got \"${att.name}\"`);\n  }\n  return 'pass';\n})();\n",
    "test/source/tests/browser-unit-tests/unit-ContactStore.js": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n/* eslint-disable max-len */\n\n/**\n * These tests use JavaScript instead of TypeScript to avoid dealing with types in cross-environment setup.\n * (tests are injected from NodeJS through puppeteer into a browser environment)\n * While this makes them less convenient to write, the result is more flexible.\n * \n * Import your lib to `ci_unit_test.ts` to resolve `ReferenceError: SomeClass is not defined`\n * \n * Each test must return \"pass\" to pass. To reject, throw an Error.\n * \n * Each test must start with one of (depending on which flavors you want it to run): \n *  - BROWSER_UNIT_TEST_NAME(`some test name`);\n *  - BROWSER_UNIT_TEST_NAME(`some test name`).enterprise;\n *  - BROWSER_UNIT_TEST_NAME(`some test name`).consumer;\n * \n * This is not a JavaScript file. It's a text file that gets parsed, split into chunks, and\n *    parts of it executed as javascript. The structure is very rigid. The only flexible place is inside\n *    the async functions. For the rest, do not change the structure or our parser will get confused.\n *    Do not put any code whatsoever outside of the async functions.\n */\n\nBROWSER_UNIT_TEST_NAME(`ContactStore is able to search by partial email address`);\n(async () => {\n  const contactABBDEF = await ContactStore.obj({\n    email: 'abbdef@test.com', pubkey: testConstants.abbdefTestComPubkey\n  });\n  const contactABCDEF = await ContactStore.obj({\n    email: 'abcdef@test.com', pubkey: testConstants.abcdefTestComPubkey\n  });\n  const contactABCDDF = await ContactStore.obj({\n    email: 'abcddf@test.com', pubkey: testConstants.abcddfTestComPubkey\n  });\n  const contactABDDEF = await ContactStore.obj({\n    email: 'abddef@test.com', pubkey: testConstants.abddefTestComPubkey\n  });\n  const contactABCDVWXYZHELLOCOM = await ContactStore.obj({\n    email: 'abcd.vwxyz@hello.com', pubkey: testConstants.abcdVwxyzHelloComPubkey\n  });\n  await ContactStore.save(undefined, [contactABBDEF, contactABCDEF, contactABCDDF, contactABDDEF,\n    contactABCDVWXYZHELLOCOM]);\n  const contactsABC = await ContactStore.search(undefined, { hasPgp: true, substring: 'abc' });\n  if (contactsABC.length !== 3) {\n    throw Error(`Expected 3 contacts to match \"abc\" but got \"${contactsABC.length}\"`);\n  }\n  const contactsABCD = await ContactStore.search(undefined, { hasPgp: true, substring: 'abcd' });\n  if (contactsABCD.length !== 3) {\n    throw Error(`Expected 3 contacts to match \"abcd\" but got \"${contactsABCD.length}\"`);\n  }\n  const contactsABCDE = await ContactStore.search(undefined, { hasPgp: true, substring: 'abcde' });\n  if (contactsABCDE.length !== 1) {\n    throw Error(`Expected 1 contact to match \"abcde\" but got \"${contactsABCDE.length}\"`);\n  }\n  if (contactsABCDE[0].email !== 'abcdef@test.com') {\n    throw Error(`Expected \"abcdef@test.com\" but got \"${contactsABCDE[0].email}\"`);\n  }\n  const contactsVWX = await ContactStore.search(undefined, { hasPgp: true, substring: 'vwx' });\n  if (contactsVWX.length !== 1) {\n    throw Error(`Expected 1 contact to match \"vwx\" but got \"${contactsVWX.length}\"`);\n  }\n  const contactsHEL = await ContactStore.search(undefined, { hasPgp: true, substring: 'hel' });\n  if (contactsHEL.length !== 1) {\n    throw Error(`Expected 1 contact to match \"hel\" but got \"${contactsHEL.length}\"`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore doesn't store duplicates in searchable`);\n(async () => {\n  const db = await ContactStore.dbOpen();\n  const contact = await ContactStore.obj({\n    email: 'this.word.this.word@this.word.this.word', name: 'This Word THIS WORD this word'\n  });\n  await ContactStore.save(db, contact);\n  // extract the entity from the database to see the actual field\n  const entity = await new Promise((resolve, reject) => {\n    const req = db.transaction(['emails'], 'readonly').objectStore('emails').get(contact.email);\n    ContactStore.setReqPipe(req, resolve, reject);\n  });\n  if (entity?.searchable.length !== 2) {\n    throw Error(`Expected 2 entries in 'searchable' but got \"${entity?.searchable}\"`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore doesn't store smaller words in searchable when there is a bigger one that starts with it`);\n(async () => {\n  const db = await ContactStore.dbOpen();\n  const contact = await ContactStore.obj({\n    email: 'a@big.one', name: 'Bigger'\n  });\n  await ContactStore.save(db, contact);\n  // extract the entity from the database to see the actual field\n  const entity = await new Promise((resolve, reject) => {\n    const req = db.transaction(['emails'], 'readonly').objectStore('emails').get(contact.email);\n    ContactStore.setReqPipe(req, resolve, reject);\n  });\n  if (entity?.searchable.length !== 3 || !entity.searchable.includes('f:a')\n    || !entity.searchable.includes('f:bigger') || !entity.searchable.includes('f:one')) {\n    throw Error(`Expected \"a bigger one\" entries in 'searchable' but got \"${entity?.searchable}\"`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore.update updates correct 'pubkeyLastCheck'`);\n(async () => {\n  const db = await ContactStore.dbOpen();\n  const email = 'flowcrypt.compatibility@gmail.com';\n  const date2_0 = Date.now();\n  const contacts = [\n    await ContactStore.obj({\n      email,\n      pubkey: testConstants.flowcryptcompatibilityPublicKey7FDE685548AEA788\n    }),\n    await ContactStore.obj({\n      email,\n      pubkey: testConstants.flowcryptcompatibilityPublicKeyADAC279C95093207,\n      lastCheck: date2_0\n    })];\n  await ContactStore.save(db, contacts);\n  // extract the entities from the database\n  const fp1 = '5520CACE2CB61EA713E5B0057FDE685548AEA788';\n  const fp2 = 'E8F0517BA6D7DAB6081C96E4ADAC279C95093207';\n  const getEntity = async (fp) => {\n    return await new Promise((resolve, reject) => {\n      const req = db.transaction(['pubkeys'], 'readonly').objectStore('pubkeys').get(fp);\n      ContactStore.setReqPipe(req, resolve, reject);\n    });\n  };\n  let entity1 = await getEntity(fp1);\n  let entity2 = await getEntity(fp2);\n  if (entity1.fingerprint !== fp1) {\n    throw Error(`Failed to extract pubkey ${fp1}`);\n  }\n  if (entity2.fingerprint !== fp2) {\n    throw Error(`Failed to extract pubkey ${fp2}`);\n  }\n  if (entity1.lastCheck) {\n    throw Error(`Expected undefined lastCheck for ${fp1} but got ${entity1.lastCheck}`);\n  }\n  if (entity2.lastCheck !== date2_0) {\n    throw Error(`Expected lastCheck=${date2_0} for ${fp2} but got ${entity2.lastCheck}`);\n  }\n  const pubkey1 = await KeyUtil.parse(testConstants.flowcryptcompatibilityPublicKey7FDE685548AEA788);\n  const pubkey2 = await KeyUtil.parse(testConstants.flowcryptcompatibilityPublicKeyADAC279C95093207);\n  const date1_1 = date2_0 + 1000;\n  // update entity 1 with pubkeyLastCheck = date1_1\n  await ContactStore.update(db, email, { pubkeyLastCheck: date1_1, pubkey: pubkey1 });\n  // extract the entities from the database\n  entity1 = await getEntity(fp1);\n  entity2 = await getEntity(fp2);\n  if (entity1.lastCheck !== date1_1) {\n    throw Error(`Expected lastCheck=${date1_1} for ${fp1} but got ${entity1.lastCheck}`);\n  }\n  if (entity2.lastCheck !== date2_0) {\n    throw Error(`Expected lastCheck=${date2_0} for ${fp2} but got ${entity2.lastCheck}`);\n  }\n  const date2_2 = date1_1 + 10000;\n  // updating with undefined value shouldn't modify pubkeyLastCheck\n  await ContactStore.update(db, email, { pubkeyLastCheck: undefined, pubkey: pubkey1 });\n  await ContactStore.update(db, email, { pubkeyLastCheck: date2_2, pubkey: pubkey2 });\n  // extract the entities from the database\n  entity1 = await getEntity(fp1);\n  entity2 = await getEntity(fp2);\n  if (entity1.lastCheck !== date1_1) {\n    throw Error(`Expected lastCheck=${date1_1} for ${fp1} but got ${entity1.lastCheck}`);\n  }\n  if (entity2.lastCheck !== date2_2) {\n    throw Error(`Expected lastCheck=${date2_2} for ${fp2} but got ${entity2.lastCheck}`);\n  }\n  // updating contact details without specifying a pubkey shouln't update pubkeyLastCheck\n  await ContactStore.update(db, email, { name: 'Some Name' });\n  // extract the entities from the database\n  entity1 = await getEntity(fp1);\n  entity2 = await getEntity(fp2);\n  if (entity1.lastCheck !== date1_1) {\n    throw Error(`Expected lastCheck=${date1_1} for ${fp1} but got ${entity1.lastCheck}`);\n  }\n  if (entity2.lastCheck !== date2_2) {\n    throw Error(`Expected lastCheck=${date2_2} for ${fp2} but got ${entity2.lastCheck}`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore.update tests`);\n(async () => {\n  const db = await ContactStore.dbOpen();\n  const email1 = 'email1@test.com';\n  const email2 = 'email2@test.com';\n  const contacts = [\n    await ContactStore.obj({ email: email1 }),\n    await ContactStore.obj({ email: email2 })];\n  await ContactStore.save(db, contacts);\n  const expectedObj1 = {\n    email: email1,\n    name: undefined,\n    lastUse: undefined\n  };\n  const expectedObj2 = {\n    email: email2,\n    name: undefined,\n    lastUse: undefined\n  };\n  const getEntity = async (email) => {\n    return await new Promise((resolve, reject) => {\n      const req = db.transaction(['emails'], 'readonly').objectStore('emails').get(email);\n      ContactStore.setReqPipe(req, resolve, reject);\n    });\n  };\n  const compareEntity = async (expectedObj) => {\n    const loaded = await getEntity(expectedObj.email);\n    if (loaded.name != expectedObj.name) {\n      throw Error(`name field mismatch, expected ${expectedObj.name} but got ${loaded.name}`);\n    }\n    if (loaded.lastUse != expectedObj.lastUse) {\n      throw Error(`lastUse field mismatch, expected ${expectedObj.lastUse} but got ${loaded.lastUse}`);\n    }\n  };\n  const compareEntities = async () => {\n    await compareEntity(expectedObj1);\n    await compareEntity(expectedObj2);\n  };\n  await compareEntities();\n  expectedObj1.name = 'New Name for contact 1';\n  await ContactStore.update(db, email1, { name: expectedObj1.name });\n  await compareEntities();\n  await ContactStore.update(db, email1, { name: undefined }); // won't affect the entity\n  await compareEntities();\n  const date = new Date();\n  expectedObj2.lastUse = date.getTime();\n  await ContactStore.update(db, email2, { lastUse: date });\n  await compareEntities();\n  await ContactStore.update(db, email2, { lastUse: undefined }); // won't affect the entity\n  await compareEntities();\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore saves and returns dates as numbers`);\n(async () => {\n  // we'll use background operation to make sure the date isn't transformed on its way\n  const email = 'test@expired.com';\n  const lastCheck = Date.now();\n  const lastUse = lastCheck + 1000;\n  const contact = await ContactStore.obj({ email, pubkey: testConstants.expiredPub, lastCheck, lastUse });\n  await ContactStore.save(undefined, [contact]);\n  const [loaded] = await ContactStore.get(undefined, [email]);\n  if (typeof loaded.lastUse !== 'number') {\n    throw Error(`lastUse was expected to be a number, but got ${typeof loaded.lastUse}`);\n  }\n  if (typeof loaded.pubkeyLastCheck !== 'number') {\n    throw Error(`pubkeyLastCheck was expected to be a number, but got ${typeof loaded.pubkeyLastCheck}`);\n  }\n  if (typeof loaded.expiresOn !== 'number') {\n    throw Error(`expiresOn was expected to be a number, but got ${typeof loaded.expiresOn}`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore gets a contact by any longid`);\n(async () => {\n  const contactABBDEF = await ContactStore.obj({\n    email: 'abbdef@test.com', pubkey: testConstants.abbdefTestComPubkey\n  });\n  const contactABCDEF = await ContactStore.obj({\n    email: 'abcdef@test.com', pubkey: testConstants.abcdefTestComPubkey\n  });\n  const contactABCDDF = await ContactStore.obj({\n    email: 'abcddf@test.com', pubkey: testConstants.abcddfTestComPubkey\n  });\n  const contactABDDEF = await ContactStore.obj({\n    email: 'abddef@test.com', pubkey: testConstants.abddefTestComPubkey\n  });\n  await ContactStore.save(undefined, [contactABBDEF, contactABCDEF, contactABCDDF, contactABDDEF]);\n  const [abbdefByPrimaryLongid] = await ContactStore.get(undefined, ['DF63659C3B4A81FB']);\n  if (abbdefByPrimaryLongid.email !== 'abbdef@test.com') {\n    throw Error(`Expected to get the key for abbdef@test.com by primary longid but got ${abbdefByPrimaryLongid.email}`);\n  }\n  if (abbdefByPrimaryLongid.pubkey.id !== 'B790AE8F425DC44633A8C086DF63659C3B4A81FB') {\n    throw Error(`Expected to get the key fingerprint B790AE8F425DC44633A8C086DF63659C3B4A81FB but got ${abbdefByPrimaryLongid.pubkey.id}`);\n  }\n  const [abbdefBySubkeyLongid] = await ContactStore.get(undefined, ['621DE1814AD675E0']);\n  if (abbdefBySubkeyLongid.email !== 'abbdef@test.com') {\n    throw Error(`Expected to get the key for abbdef@test.com by subkey longid but got ${abbdefBySubkeyLongid.email}`);\n  }\n  if (abbdefBySubkeyLongid.pubkey.id !== 'B790AE8F425DC44633A8C086DF63659C3B4A81FB') {\n    throw Error(`Expected to get the key fingerprint B790AE8F425DC44633A8C086DF63659C3B4A81FB but got ${abbdefBySubkeyLongid.pubkey.id}`);\n  }\n\n  const [abcdefByPrimaryLongid] = await ContactStore.get(undefined, ['608BCD797A23FB91']);\n  if (abcdefByPrimaryLongid.email !== 'abcdef@test.com') {\n    throw Error(`Expected to get the key for abcdef@test.com by primary longid but got ${abcdefByPrimaryLongid.email}`);\n  }\n  if (abcdefByPrimaryLongid.pubkey.id !== '3155F118B6E732B3638A1CE1608BCD797A23FB91') {\n    throw Error(`Expected to get the key fingerprint 3155F118B6E732B3638A1CE1608BCD797A23FB91 but got ${abcdefByPrimaryLongid.pubkey.id}`);\n  }\n  const [abcdefBySubkeyLongid] = await ContactStore.get(undefined, ['2D47A41943DFAFCE']);\n  if (abcdefBySubkeyLongid.email !== 'abcdef@test.com') {\n    throw Error(`Expected to get the key for abcdef@test.com by subkey longid but got ${abcdefBySubkeyLongid.email}`);\n  }\n  if (abcdefBySubkeyLongid.pubkey.id !== '3155F118B6E732B3638A1CE1608BCD797A23FB91') {\n    throw Error(`Expected to get the key fingerprint 3155F118B6E732B3638A1CE1608BCD797A23FB91 but got ${abcdefBySubkeyLongid.pubkey.id}`);\n  }\n\n  const [abcddfByPrimaryLongid] = await ContactStore.get(undefined, ['75AA44AB8930F7E9']);\n  if (abcddfByPrimaryLongid.email !== 'abcddf@test.com') {\n    throw Error(`Expected to get the key for abcddf@test.com by primary longid but got ${abcddfByPrimaryLongid.email}`);\n  }\n  if (abcddfByPrimaryLongid.pubkey.id !== '6CF53D2329C2A80828F499D375AA44AB8930F7E9') {\n    throw Error(`Expected to get the key fingerprint 6CF53D2329C2A80828F499D375AA44AB8930F7E9 but got ${abcddfByPrimaryLongid.pubkey.id}`);\n  }\n  const [abcddfBySubkeyLongid] = await ContactStore.get(undefined, ['92CFDAC7AA3A4253']);\n  if (abcddfBySubkeyLongid.email !== 'abcddf@test.com') {\n    throw Error(`Expected to get the key for abcddf@test.com by subkey longid but got ${abcddfBySubkeyLongid.email}`);\n  }\n  if (abcddfBySubkeyLongid.pubkey.id !== '6CF53D2329C2A80828F499D375AA44AB8930F7E9') {\n    throw Error(`Expected to get the key fingerprint 6CF53D2329C2A80828F499D375AA44AB8930F7E9 but got ${abcddfBySubkeyLongid.pubkey.id}`);\n  }\n\n  const [abddefByPrimaryLongid] = await ContactStore.get(undefined, ['5FCC1541CF282951']);\n  if (abddefByPrimaryLongid.email !== 'abddef@test.com') {\n    throw Error(`Expected to get the key for abddef@test.com by primary longid but got ${abddefByPrimaryLongid.email}`);\n  }\n  if (abddefByPrimaryLongid.pubkey.id !== '9E020D9B752FD3FFF17ED9B65FCC1541CF282951') {\n    throw Error(`Expected to get the key fingerprint 9E020D9B752FD3FFF17ED9B65FCC1541CF282951 but got ${abddefByPrimaryLongid.pubkey.id}`);\n  }\n  const [abddefBySubkeyLongid] = await ContactStore.get(undefined, ['EAA7A05FE34F3A1A']);\n  if (abddefBySubkeyLongid.email !== 'abddef@test.com') {\n    throw Error(`Expected to get the key for abddef@test.com by subkey longid but got ${abddefBySubkeyLongid.email}`);\n  }\n  if (abddefBySubkeyLongid.pubkey.id !== '9E020D9B752FD3FFF17ED9B65FCC1541CF282951') {\n    throw Error(`Expected to get the key fingerprint 9E020D9B752FD3FFF17ED9B65FCC1541CF282951 but got ${abddefBySubkeyLongid.pubkey.id}`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore gets a valid pubkey by e-mail, or exact pubkey by longid`);\n(async () => {\n  // Note 1: email differs from pubkey id\n  // Note 2: not necessary to call ContactStore.save, it's possible to always use ContactStore.update\n  await ContactStore.update(undefined, 'some.revoked@otherhost.com', { pubkey: await KeyUtil.parse(testConstants.somerevokedRevoked1) });\n  await ContactStore.update(undefined, 'some.revoked@otherhost.com', { pubkey: await KeyUtil.parse(testConstants.somerevokedValid) });\n  await ContactStore.update(undefined, 'some.revoked@otherhost.com', { pubkey: await KeyUtil.parse(testConstants.somerevokedRevoked2) });\n\n  const [expectedValid] = await ContactStore.get(undefined, ['some.revoked@otherhost.com']);\n  if (expectedValid.pubkey.id !== 'D6662C5FB9BDE9DA01F3994AAA1EF832D8CCA4F2') {\n    throw Error(`Expected to get the key fingerprint D6662C5FB9BDE9DA01F3994AAA1EF832D8CCA4F2 but got ${expectedValid.pubkey.id}`);\n  }\n  const [expectedRevoked1] = await ContactStore.get(undefined, ['097EEBF354259A5E']);\n  if (expectedRevoked1.pubkey.id !== 'A5CFC8E8EA4AE69989FE2631097EEBF354259A5E') {\n    throw Error(`Expected to get the key fingerprint A5CFC8E8EA4AE69989FE2631097EEBF354259A5E but got ${expectedRevoked1.pubkey.id}`);\n  }\n  const [expectedRevoked2] = await ContactStore.get(undefined, ['DE8538DDA1648C76']);\n  if (expectedRevoked2.pubkey.id !== '3930752556D57C46A1C56B63DE8538DDA1648C76') {\n    throw Error(`Expected to get the key fingerprint 3930752556D57C46A1C56B63DE8538DDA1648C76 but got ${expectedRevoked2.pubkey.id}`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore stores postfixed fingerprint internally for X.509 certificate`);\n(async () => {\n  const db = await ContactStore.dbOpen();\n  const email = 'actalis@meta.33mail.com';\n  const contacts = [\n    await ContactStore.obj({\n      email,\n      pubkey: testConstants.smimeCert\n    })];\n  await ContactStore.save(db, contacts);\n  // extract the entity directly from the database\n  const entityFp = '16BB407403A3ADC55E1E0E4AF93EEC8FB187C923-X509';\n  const fingerprint = '16BB407403A3ADC55E1E0E4AF93EEC8FB187C923';\n  const longid = 'X509-MIGiMIGNMQswCQYDVQQGEwJJVDEQMA4GA1UECAwHQmVyZ2FtbzEZMBcGA1UEBwwQUG9udGUgU2Fu' +\n    'IFBpZXRybzEjMCEGA1UECgwaQWN0YWxpcyBTLnAuQS4vMDMzNTg1MjA5NjcxLDAqBgNVBAMMI0FjdGFsaXMgQ2xpZW50IE' +\n    'F1dGhlbnRpY2F0aW9uIENBIEcyAhBj9wJecA85RTAfsvulZ0+E';\n  const entity = await new Promise((resolve, reject) => {\n    const req = db.transaction(['pubkeys'], 'readonly').objectStore('pubkeys').get(entityFp);\n    ContactStore.setReqPipe(req, resolve, reject);\n  });\n  if (entity.fingerprint !== entityFp) {\n    throw Error(`Failed to extract pubkey ${fingerprint}`);\n  }\n  const [contactByLongid] = await ContactStore.get(db, [longid]);\n  if (contactByLongid.pubkey.id !== fingerprint) {\n    throw Error(`Failed to extract pubkey ${fingerprint}`);\n  }\n  const [contactByEmail] = await ContactStore.get(db, [email]);\n  if (contactByEmail.pubkey.id !== fingerprint) {\n    throw Error(`Failed to extract pubkey ${fingerprint}`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore searches S/MIME Certificate by PKCS#7 message recipient`);\n(async () => {\n  const db = await ContactStore.dbOpen();\n  const email = 'actalis@meta.33mail.com';\n  const pubkey = testConstants.smimeCert;\n  const contacts = [await ContactStore.obj({ email, pubkey })];\n  await ContactStore.save(db, contacts);\n  const p7 = forge.pkcs7.createEnvelopedData();\n  const certificate = forge.pki.certificateFromPem(pubkey);\n  p7.addRecipient(certificate);\n  const recipient = p7.recipients[0];\n  const issuerAndSerialNumberAsn1 =\n    forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [\n      // Name\n      forge.pki.distinguishedNameToAsn1({ attributes: recipient.issuer }),\n      // Serial\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false,\n        forge.util.hexToBytes(recipient.serialNumber))\n    ]);\n  const der = forge.asn1.toDer(issuerAndSerialNumberAsn1).getBytes();\n  const buf = Buf.fromRawBytesStr(der);\n  const [contact] = await ContactStore.get(db, ['X509-' + buf.toBase64Str()]);\n  const foundCert = KeyUtil.armor(contact.pubkey);\n  console.log('foundCert');\n  console.log(foundCert);\n  if (foundCert !== pubkey) {\n    throw new Error(`The certificate wasn't found by S/MIME IssuerAndSerialNumber`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore: X-509 revocation affects OpenPGP key`);\n(async () => {\n  const db = await ContactStore.dbOpen();\n  const opgpKeyOldAndValid = await KeyUtil.parse(testConstants.somerevokedValid);\n  const fingerprint = 'D6662C5FB9BDE9DA01F3994AAA1EF832D8CCA4F2';\n  if (opgpKeyOldAndValid.id !== fingerprint) {\n    throw new Error(`Valid OpenPGP Key is expected to have fingerprint ${fingerprint} but actually is ${opgpKeyOldAndValid.id}`);\n  }\n  await ContactStore.update(db, 'some.revoked@localhost.com', { pubkey: opgpKeyOldAndValid });\n  const [loadedOpgpKey1] = await ContactStore.get(db, [`some.revoked@localhost.com`]);\n  if (loadedOpgpKey1.pubkey.revoked) {\n    throw new Error(`The loaded OpenPGP Key (1) was expected to be valid but it is revoked.`);\n  }\n  const [loadedOpgpKey2] = await ContactStore.get(db, [`AA1EF832D8CCA4F2`]);\n  if (loadedOpgpKey2.pubkey.revoked) {\n    throw new Error(`The loaded OpenPGP Key (2) was expected to be valid but it is revoked.`);\n  }\n  // emulate X-509 revocation\n  await new Promise((resolve, reject) => {\n    const tx = db.transaction(['revocations'], 'readwrite');\n    ContactStore.setTxHandlers(tx, resolve, reject);\n    tx.objectStore('revocations').put({ fingerprint: fingerprint + \"-X509\" });\n  });\n  // original key should be either revoked or missing\n  const [loadedOpgpKey3] = await ContactStore.get(db, [`some.revoked@localhost.com`]);\n  if (loadedOpgpKey3.pubkey && !loadedOpgpKey3.pubkey.revoked) {\n    throw new Error(`The loaded OpenPGP Key (3) was expected to be revoked but it is not.`);\n  }\n  const [loadedOpgpKey4] = await ContactStore.get(db, [`AA1EF832D8CCA4F2`]);\n  if (loadedOpgpKey4.pubkey && !loadedOpgpKey4.pubkey.revoked) {\n    throw new Error(`The loaded OpenPGP Key (4) was expected to be revoked but it is not.`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore: OpenPGP revocation affects X.509 certificate`);\n(async () => {\n  const db = await ContactStore.dbOpen();\n  const smimeKey = await KeyUtil.parse(testConstants.smimeCert);\n  await ContactStore.update(db, 'actalis@meta.33mail.com', { pubkey: smimeKey });\n  const [loadedCert1] = await ContactStore.get(db, [`actalis@meta.33mail.com`]);\n  const longid = KeyUtil.getPrimaryLongid(smimeKey);\n  if (loadedCert1.pubkey.revoked) {\n    throw new Error(`The loaded X.509 certificate (1) was expected to be valid but it is revoked.`);\n  }\n  const [loadedCert2] = await ContactStore.get(db, [longid]);\n  if (loadedCert2.pubkey.revoked) {\n    throw new Error(`The loaded X.509 certificate (2) was expected to be valid but it is revoked.`);\n  }\n  // emulate openPGP revocation\n  await new Promise((resolve, reject) => {\n    const tx = db.transaction(['revocations'], 'readwrite');\n    ContactStore.setTxHandlers(tx, resolve, reject);\n    tx.objectStore('revocations').put({ fingerprint: ContactStore.stripFingerprint(smimeKey.id) });\n  });\n  // original key should be either revoked or missing\n  const [loadedCert3] = await ContactStore.get(db, [`actalis@meta.33mail.com`]);\n  if (loadedCert3.pubkey && !loadedCert3.pubkey.revoked) {\n    throw new Error(`The loaded X.509 certificate (3) was expected to be revoked but it is not.`);\n  }\n  const [loadedCert4] = await ContactStore.get(db, [longid]);\n  if (loadedCert4.pubkey && !loadedCert4.pubkey.revoked) {\n    throw new Error(`The loaded X.509 certificate (4) was expected to be revoked but it is not.`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore doesn't replace revoked key with older version`);\n(async () => {\n  const db = await ContactStore.dbOpen();\n  const opgpKeyOldAndValid = await KeyUtil.parse(testConstants.somerevokedValid);\n  const fingerprint = 'D6662C5FB9BDE9DA01F3994AAA1EF832D8CCA4F2';\n  if (opgpKeyOldAndValid.id !== fingerprint) {\n    throw new Error(`Valid OpenPGP Key is expected to have fingerprint ${fingerprint} but actually is ${opgpKeyOldAndValid.id}`);\n  }\n  const opgpKeyRevoked = await KeyUtil.parse(testConstants.somerevokedValidNowRevoked);\n  if (opgpKeyRevoked.id !== fingerprint) {\n    throw new Error(`RevokedOpenPGP Key is expected to have fingerprint ${fingerprint} but actually is ${opgpKeyRevoked.id}`);\n  }\n  await ContactStore.update(db, 'some.revoked@localhost.com', { pubkey: opgpKeyOldAndValid });\n  const [loadedOpgpKey1] = await ContactStore.get(db, [`some.revoked@localhost.com`]);\n  if (loadedOpgpKey1.pubkey.revoked) {\n    throw new Error(`The loaded OpenPGP Key (1) was expected to be valid but it is revoked.`);\n  }\n  const [loadedOpgpKey2] = await ContactStore.get(db, [`AA1EF832D8CCA4F2`]);\n  if (loadedOpgpKey2.pubkey.revoked) {\n    throw new Error(`The loaded OpenPGP Key (2) was expected to be valid but it is revoked.`);\n  }\n  await ContactStore.update(db, 'some.revoked@localhost.com', { pubkey: opgpKeyRevoked });\n  const [loadedOpgpKey3] = await ContactStore.get(db, [`some.revoked@localhost.com`]);\n  if (loadedOpgpKey3.pubkey && !loadedOpgpKey3.pubkey.revoked) {\n    throw new Error(`The loaded OpenPGP Key (3) was expected to be revoked but it is not.`);\n  }\n  const [loadedOpgpKey4] = await ContactStore.get(db, [`AA1EF832D8CCA4F2`]);\n  if (loadedOpgpKey4.pubkey && !loadedOpgpKey4.pubkey.revoked) {\n    throw new Error(`The loaded OpenPGP Key (4) was expected to be revoked but it is not.`);\n  }\n  await ContactStore.update(db, 'some.revoked@localhost.com', { pubkey: opgpKeyOldAndValid });\n  const [loadedOpgpKey5] = await ContactStore.get(db, [`some.revoked@localhost.com`]);\n  if (loadedOpgpKey5.pubkey && !loadedOpgpKey5.pubkey.revoked) {\n    throw new Error(`The loaded OpenPGP Key (5) was expected to be revoked but it is not.`);\n  }\n  const [loadedOpgpKey6] = await ContactStore.get(db, [`AA1EF832D8CCA4F2`]);\n  if (loadedOpgpKey6.pubkey && !loadedOpgpKey6.pubkey.revoked) {\n    throw new Error(`The loaded OpenPGP Key (6) was expected to be revoked but it is not.`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`ContactStore searchPubkeys { hasPgp: true } returns all keys`);\n(async () => {\n  const db = await ContactStore.dbOpen();\n  const contactABBDEF = await ContactStore.obj({\n    email: 'abbdef@test.com', pubkey: testConstants.abbdefTestComPubkey\n  });\n  const contactABCDEF = await ContactStore.obj({\n    email: 'abcdef@test.com', pubkey: testConstants.abcdefTestComPubkey\n  });\n  const contactABCDDF = await ContactStore.obj({\n    email: 'abcddf@test.com', pubkey: testConstants.abcddfTestComPubkey\n  });\n  const contactABDDEF = await ContactStore.obj({\n    email: 'abddef@test.com', pubkey: testConstants.abddefTestComPubkey\n  });\n  await ContactStore.save(db, [contactABBDEF, contactABCDEF, contactABCDDF, contactABDDEF]);\n  const foundKeys = await ContactStore.searchPubkeys(db, { hasPgp: true });\n  const fingerprints = (await Promise.all(foundKeys.map(async (key) => await KeyUtil.parse(key)))).\n    map(pk => pk.id);\n  if (!fingerprints.includes('B790AE8F425DC44633A8C086DF63659C3B4A81FB')\n    || !fingerprints.includes('3155F118B6E732B3638A1CE1608BCD797A23FB91')\n    || !fingerprints.includes('6CF53D2329C2A80828F499D375AA44AB8930F7E9')\n    || !fingerprints.includes('9E020D9B752FD3FFF17ED9B65FCC1541CF282951')) {\n    throw new Error('Some keys were not loaded!');\n  }\n  return 'pass';\n})();\n",
    "test/source/tests/browser-unit-tests/unit-Mime.js": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n/**\n * These tests use JavaScript instead of TypeScript to avoid dealing with types in cross-environment setup.\n * (tests are injected from NodeJS through puppeteer into a browser environment)\n * While this makes them less convenient to write, the result is more flexible.\n * \n * Import your lib to `ci_unit_test.ts` to resolve `ReferenceError: SomeClass is not defined`\n * \n * Each test must return \"pass\" to pass. To reject, throw an Error.\n * \n * Each test must start with one of (depending on which flavors you want it to run): \n *  - BROWSER_UNIT_TEST_NAME(`some test name`);\n *  - BROWSER_UNIT_TEST_NAME(`some test name`).enterprise;\n *  - BROWSER_UNIT_TEST_NAME(`some test name`).consumer;\n * \n * This is not a JavaScript file. It's a text file that gets parsed, split into chunks, and\n *    parts of it executed as javascript. The structure is very rigid. The only flexible place is inside\n *    the async functions. For the rest, do not change the structure or our parser will get confused.\n *    Do not put any code whatsoever outside of the async functions.\n */\n\nBROWSER_UNIT_TEST_NAME(`Mime attachment file names`);\n(async () => {\n  const expectedEncodedFilenames = [\n    // 1..31\n    \"filename*0*=utf-8''%01\",\n    \"filename*0*=utf-8''%02\",\n    \"filename*0*=utf-8''%03\",\n    \"filename*0*=utf-8''%04\",\n    \"filename*0*=utf-8''%05\",\n    \"filename*0*=utf-8''%06\",\n    \"filename*0*=utf-8''%07\",\n    \"filename*0*=utf-8''%08\",\n    \"filename*0*=utf-8''%09\",\n    \"filename*0*=utf-8''%0A\",\n    \"filename*0*=utf-8''%0B\",\n    \"filename*0*=utf-8''%0C\",\n    \"filename*0*=utf-8''%0D\",\n    \"filename*0*=utf-8''%0E\",\n    \"filename*0*=utf-8''%0F\",\n    \"filename*0*=utf-8''%10\",\n    \"filename*0*=utf-8''%11\",\n    \"filename*0*=utf-8''%12\",\n    \"filename*0*=utf-8''%13\",\n    \"filename*0*=utf-8''%14\",\n    \"filename*0*=utf-8''%15\",\n    \"filename*0*=utf-8''%16\",\n    \"filename*0*=utf-8''%17\",\n    \"filename*0*=utf-8''%18\",\n    \"filename*0*=utf-8''%19\",\n    \"filename*0*=utf-8''%1A\",\n    \"filename*0*=utf-8''%1B\",\n    \"filename*0*=utf-8''%1C\",\n    \"filename*0*=utf-8''%1D\",\n    \"filename*0*=utf-8''%1E\",\n    \"filename*0*=utf-8''%1F\",\n    // 33..127 \n    \"filename*0*=utf-8''!\",\n    \"filename*0*=utf-8''%22\",\n    \"filename*0*=utf-8''%23\",\n    \"filename*0*=utf-8''%24\",\n    \"filename*0*=utf-8''%25\",\n    \"filename*0*=utf-8''%26\",\n    \"filename*0*=utf-8'''\",\n    \"filename*0*=utf-8''%28\",\n    \"filename*0*=utf-8''%29\",\n    \"filename*0*=utf-8''*\",\n    \"filename*0*=utf-8''%2B\",\n    \"filename*0*=utf-8''%2C\",\n    \"filename=-\",\n    \"filename=.\",\n    \"filename*0*=utf-8''%2F\",\n    \"filename=0\",\n    \"filename=1\",\n    \"filename=2\",\n    \"filename=3\",\n    \"filename=4\",\n    \"filename=5\",\n    \"filename=6\",\n    \"filename=7\",\n    \"filename=8\",\n    \"filename=9\",\n    \"filename*0*=utf-8''%3A\",\n    \"filename*0*=utf-8''%3B\",\n    \"filename*0*=utf-8''%3C\",\n    \"filename*0*=utf-8''%3D\",\n    \"filename*0*=utf-8''%3E\",\n    \"filename*0*=utf-8''%3F\",\n    \"filename*0*=utf-8''%40\",\n    \"filename=A\",\n    \"filename=B\",\n    \"filename=C\",\n    \"filename=D\",\n    \"filename=E\",\n    \"filename=F\",\n    \"filename=G\",\n    \"filename=H\",\n    \"filename=I\",\n    \"filename=J\",\n    \"filename=K\",\n    \"filename=L\",\n    \"filename=M\",\n    \"filename=N\",\n    \"filename=O\",\n    \"filename=P\",\n    \"filename=Q\",\n    \"filename=R\",\n    \"filename=S\",\n    \"filename=T\",\n    \"filename=U\",\n    \"filename=V\",\n    \"filename=W\",\n    \"filename=X\",\n    \"filename=Y\",\n    \"filename=Z\",\n    \"filename*0*=utf-8''%5B\",\n    \"filename*0*=utf-8''%5C\",\n    \"filename*0*=utf-8''%5D\",\n    \"filename*0*=utf-8''%5E\",\n    \"filename=_\",\n    \"filename*0*=utf-8''%60\",\n    \"filename=a\",\n    \"filename=b\",\n    \"filename=c\",\n    \"filename=d\",\n    \"filename=e\",\n    \"filename=f\",\n    \"filename=g\",\n    \"filename=h\",\n    \"filename=i\",\n    \"filename=j\",\n    \"filename=k\",\n    \"filename=l\",\n    \"filename=m\",\n    \"filename=n\",\n    \"filename=o\",\n    \"filename=p\",\n    \"filename=q\",\n    \"filename=r\",\n    \"filename=s\",\n    \"filename=t\",\n    \"filename=u\",\n    \"filename=v\",\n    \"filename=w\",\n    \"filename=x\",\n    \"filename=y\",\n    \"filename=z\",\n    \"filename*0*=utf-8''%7B\",\n    \"filename*0*=utf-8''%7C\",\n    \"filename*0*=utf-8''%7D\",\n    \"filename*0*=utf-8''~\",\n    \"filename*0*=utf-8''%7F\",\n    // 128..255\n    \"filename*0*=utf-8''%C2%80\",\n    \"filename*0*=utf-8''%C2%81\",\n    \"filename*0*=utf-8''%C2%82\",\n    \"filename*0*=utf-8''%C2%83\",\n    \"filename*0*=utf-8''%C2%84\",\n    \"filename*0*=utf-8''%C2%85\",\n    \"filename*0*=utf-8''%C2%86\",\n    \"filename*0*=utf-8''%C2%87\",\n    \"filename*0*=utf-8''%C2%88\",\n    \"filename*0*=utf-8''%C2%89\",\n    \"filename*0*=utf-8''%C2%8A\",\n    \"filename*0*=utf-8''%C2%8B\",\n    \"filename*0*=utf-8''%C2%8C\",\n    \"filename*0*=utf-8''%C2%8D\",\n    \"filename*0*=utf-8''%C2%8E\",\n    \"filename*0*=utf-8''%C2%8F\",\n    \"filename*0*=utf-8''%C2%90\",\n    \"filename*0*=utf-8''%C2%91\",\n    \"filename*0*=utf-8''%C2%92\",\n    \"filename*0*=utf-8''%C2%93\",\n    \"filename*0*=utf-8''%C2%94\",\n    \"filename*0*=utf-8''%C2%95\",\n    \"filename*0*=utf-8''%C2%96\",\n    \"filename*0*=utf-8''%C2%97\",\n    \"filename*0*=utf-8''%C2%98\",\n    \"filename*0*=utf-8''%C2%99\",\n    \"filename*0*=utf-8''%C2%9A\",\n    \"filename*0*=utf-8''%C2%9B\",\n    \"filename*0*=utf-8''%C2%9C\",\n    \"filename*0*=utf-8''%C2%9D\",\n    \"filename*0*=utf-8''%C2%9E\",\n    \"filename*0*=utf-8''%C2%9F\",\n    \"filename*0*=utf-8''%C2%A0\",\n    \"filename*0*=utf-8''%C2%A1\",\n    \"filename*0*=utf-8''%C2%A2\",\n    \"filename*0*=utf-8''%C2%A3\",\n    \"filename*0*=utf-8''%C2%A4\",\n    \"filename*0*=utf-8''%C2%A5\",\n    \"filename*0*=utf-8''%C2%A6\",\n    \"filename*0*=utf-8''%C2%A7\",\n    \"filename*0*=utf-8''%C2%A8\",\n    \"filename*0*=utf-8''%C2%A9\",\n    \"filename*0*=utf-8''%C2%AA\",\n    \"filename*0*=utf-8''%C2%AB\",\n    \"filename*0*=utf-8''%C2%AC\",\n    \"filename*0*=utf-8''%C2%AD\",\n    \"filename*0*=utf-8''%C2%AE\",\n    \"filename*0*=utf-8''%C2%AF\",\n    \"filename*0*=utf-8''%C2%B0\",\n    \"filename*0*=utf-8''%C2%B1\",\n    \"filename*0*=utf-8''%C2%B2\",\n    \"filename*0*=utf-8''%C2%B3\",\n    \"filename*0*=utf-8''%C2%B4\",\n    \"filename*0*=utf-8''%C2%B5\",\n    \"filename*0*=utf-8''%C2%B6\",\n    \"filename*0*=utf-8''%C2%B7\",\n    \"filename*0*=utf-8''%C2%B8\",\n    \"filename*0*=utf-8''%C2%B9\",\n    \"filename*0*=utf-8''%C2%BA\",\n    \"filename*0*=utf-8''%C2%BB\",\n    \"filename*0*=utf-8''%C2%BC\",\n    \"filename*0*=utf-8''%C2%BD\",\n    \"filename*0*=utf-8''%C2%BE\",\n    \"filename*0*=utf-8''%C2%BF\",\n    \"filename*0*=utf-8''%C3%80\",\n    \"filename*0*=utf-8''%C3%81\",\n    \"filename*0*=utf-8''%C3%82\",\n    \"filename*0*=utf-8''%C3%83\",\n    \"filename*0*=utf-8''%C3%84\",\n    \"filename*0*=utf-8''%C3%85\",\n    \"filename*0*=utf-8''%C3%86\",\n    \"filename*0*=utf-8''%C3%87\",\n    \"filename*0*=utf-8''%C3%88\",\n    \"filename*0*=utf-8''%C3%89\",\n    \"filename*0*=utf-8''%C3%8A\",\n    \"filename*0*=utf-8''%C3%8B\",\n    \"filename*0*=utf-8''%C3%8C\",\n    \"filename*0*=utf-8''%C3%8D\",\n    \"filename*0*=utf-8''%C3%8E\",\n    \"filename*0*=utf-8''%C3%8F\",\n    \"filename*0*=utf-8''%C3%90\",\n    \"filename*0*=utf-8''%C3%91\",\n    \"filename*0*=utf-8''%C3%92\",\n    \"filename*0*=utf-8''%C3%93\",\n    \"filename*0*=utf-8''%C3%94\",\n    \"filename*0*=utf-8''%C3%95\",\n    \"filename*0*=utf-8''%C3%96\",\n    \"filename*0*=utf-8''%C3%97\",\n    \"filename*0*=utf-8''%C3%98\",\n    \"filename*0*=utf-8''%C3%99\",\n    \"filename*0*=utf-8''%C3%9A\",\n    \"filename*0*=utf-8''%C3%9B\",\n    \"filename*0*=utf-8''%C3%9C\",\n    \"filename*0*=utf-8''%C3%9D\",\n    \"filename*0*=utf-8''%C3%9E\",\n    \"filename*0*=utf-8''%C3%9F\",\n    \"filename*0*=utf-8''%C3%A0\",\n    \"filename*0*=utf-8''%C3%A1\",\n    \"filename*0*=utf-8''%C3%A2\",\n    \"filename*0*=utf-8''%C3%A3\",\n    \"filename*0*=utf-8''%C3%A4\",\n    \"filename*0*=utf-8''%C3%A5\",\n    \"filename*0*=utf-8''%C3%A6\",\n    \"filename*0*=utf-8''%C3%A7\",\n    \"filename*0*=utf-8''%C3%A8\",\n    \"filename*0*=utf-8''%C3%A9\",\n    \"filename*0*=utf-8''%C3%AA\",\n    \"filename*0*=utf-8''%C3%AB\",\n    \"filename*0*=utf-8''%C3%AC\",\n    \"filename*0*=utf-8''%C3%AD\",\n    \"filename*0*=utf-8''%C3%AE\",\n    \"filename*0*=utf-8''%C3%AF\",\n    \"filename*0*=utf-8''%C3%B0\",\n    \"filename*0*=utf-8''%C3%B1\",\n    \"filename*0*=utf-8''%C3%B2\",\n    \"filename*0*=utf-8''%C3%B3\",\n    \"filename*0*=utf-8''%C3%B4\",\n    \"filename*0*=utf-8''%C3%B5\",\n    \"filename*0*=utf-8''%C3%B6\",\n    \"filename*0*=utf-8''%C3%B7\",\n    \"filename*0*=utf-8''%C3%B8\",\n    \"filename*0*=utf-8''%C3%B9\",\n    \"filename*0*=utf-8''%C3%BA\",\n    \"filename*0*=utf-8''%C3%BB\",\n    \"filename*0*=utf-8''%C3%BC\",\n    \"filename*0*=utf-8''%C3%BD\",\n    \"filename*0*=utf-8''%C3%BE\",\n    \"filename*0*=utf-8''%C3%BF\",\n    // capital Cyrillic letters\n    \" filename*0*=utf-8''%D0%81%D0%90%D0%91%D0%92%D0%93%D0%94%D0%95;\\r\\n\" +\n    \" filename*1*=%D0%96%D0%97%D0%98%D0%99%D0%9A%D0%9B%D0%9C%D0%9D;\\r\\n\" +\n    \" filename*2*=%D0%9E%D0%9F%D0%A0%D0%A1%D0%A2%D0%A3%D0%A4%D0%A5;\\r\\n\" +\n    \" filename*3*=%D0%A6%D0%A7%D0%A8%D0%A9%D0%AA%D0%AB%D0%AC%D0%AD;\\r\\n\" +\n    \" filename*4*=%D0%AE%D0%AF\"\n  ];\n  // 1..31\n  var filenames = [...Array(31).keys()].map(i => String.fromCharCode(i + 1));\n  // 33..255\n  filenames = filenames.concat([...Array(223).keys()].map(i => String.fromCharCode(i + 33)));\n  // capital Cyrillic letters\n  filenames.push('\\u0401' + String.fromCharCode(...[...Array(32).keys()].map(i => i + 0x410)));\n  const attachments = filenames.map(name => new Attachment({ name: name, type: 'text/plain', data: new Uint8Array([80, 81]) }));\n  const encoded = await Mime.encode({ 'text/plain': 'text' }, { Subject: 'subject' }, attachments);\n  const encodedFilenames = [...encoded.matchAll(/Content\\-Disposition: attachment; ?\\r?\\n?(.+?)\\r\\nX\\-Attachment\\-Id/gs)];\n  if (encodedFilenames.length !== expectedEncodedFilenames.length) {\n    throw Error(`Found ${encodedFilenames.length} encoded filenames, while ${expectedEncodedFilenames.length} were expected`);\n  }\n  const mismatchIndex = encodedFilenames.findIndex((value, index) => value[1] !== expectedEncodedFilenames[index]);\n  if (mismatchIndex !== -1) {\n    throw Error(`Mismatch at index ${mismatchIndex}, found: ${encodedFilenames[mismatchIndex][1]}, expected: ${expectedEncodedFilenames[mismatchIndex]}`);\n  }\n  const decoded = await Mime.decode(encoded);\n  for (var i = 0; i < filenames.length; i++) {\n    const originalName = filenames[i];\n    const extractedAttachment = decoded.attachments[i];\n    if (typeof extractedAttachment === 'undefined') {\n      throw Error(`could not extract attachment at index ${i}`);\n    }\n    const extractedName = extractedAttachment.name;\n    if (extractedName !== originalName) {\n      throw Error(`extractedName unexpectedly ${extractedName}, expecting ${originalName}`);\n    }\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`Mime attachment file name issue 3352`);\n(async () => {\n  const originalName = 'XX J 1 IT E (P 4) p_c.pdf';\n  const attachments = [new Attachment({ name: originalName, type: 'text/plain', data: new Uint8Array([80, 81]) })];\n  const encoded = await Mime.encode({ 'text/plain': 'text' }, { Subject: 'subject' }, attachments);\n  const decoded = await Mime.decode(encoded);\n  if (decoded.attachments.length !== 1) {\n    throw Error(`Decoded MIME message has unexpectedly ${decoded.attachments.length} attachments, expecting 1`);\n  }\n  const index = 0;\n  const extractedAttachment = decoded.attachments[index];\n  if (typeof extractedAttachment === 'undefined') {\n    throw Error(`could not extract attachment at index ${index}`);\n  }\n  const extractedName = extractedAttachment.name;\n  if (extractedName !== originalName) {\n    throw Error(`extractedName unexpectedly ${extractedName}, expecting ${originalName}`);\n  }\n  return 'pass';\n})();\n",
    "test/source/tests/browser-unit-tests/unit-Sks.js": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n/**\n * These tests use JavaScript instead of TypeScript to avoid dealing with types in cross-environment setup.\n * (tests are injected from NodeJS through puppeteer into a browser environment)\n * While this makes them less convenient to write, the result is more flexible.\n * \n * Import your lib to `ci_unit_test.ts` to resolve `ReferenceError: SomeClass is not defined`\n * \n * Each test must return \"pass\" to pass. To reject, throw an Error.\n * \n * Each test must start with one of (depending on which flavors you want it to run): \n *  - BROWSER_UNIT_TEST_NAME(`some test name`);\n *  - BROWSER_UNIT_TEST_NAME(`some test name`).enterprise;\n *  - BROWSER_UNIT_TEST_NAME(`some test name`).consumer;\n * \n * This is not a JavaScript file. It's a text file that gets parsed, split into chunks, and\n *    parts of it executed as javascript. The structure is very rigid. The only flexible place is inside\n *    the async functions. For the rest, do not change the structure or our parser will get confused.\n *    Do not put any code whatsoever outside of the async functions.\n */\n\nBROWSER_UNIT_TEST_NAME(`Sks lookup pubkey - trailing slash`);\n(async () => {\n  const email = 'john.doe@example.com';\n  const sks = new Sks('https://localhost:8001/');\n  const { pubkey } = await sks.lookupEmail(email);\n  const key = await KeyUtil.parse(pubkey);\n  if (key.id !== '094C3CBA696FA009F6015C473B635D858A1DB5E0') {\n    throw Error(`Expecting key.id=094C3CBA696FA009F6015C473B635D858A1DB5E0 but got ${key.id}`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`Sks lookup pubkey - no trailing slash`);\n(async () => {\n  const email = 'john.doe@example.com';\n  const sks = new Sks('https://localhost:8001');\n  const { pubkey } = await sks.lookupEmail(email);\n  const key = await KeyUtil.parse(pubkey);\n  if (key.id !== '094C3CBA696FA009F6015C473B635D858A1DB5E0') {\n    throw Error(`Expecting key.id=094C3CBA696FA009F6015C473B635D858A1DB5E0 but got ${key.id}`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`Sks lookup pubkey - server down`);\n(async () => {\n  const email = 'john.doe@example.com';\n  const sks = new Sks('https://localhost:3456');\n  try {\n    await sks.lookupEmail(email);\n  } catch (e) {\n    if (ApiErr.isNetErr(e)) {\n      return 'pass';\n    }\n    throw e;\n  }\n  throw new Error('Lookup wrongly didnt throw');\n})();\n\nBROWSER_UNIT_TEST_NAME(`Sks lookup pubkey - not found`);\n(async () => {\n  const email = 'nobody@example.com';\n  const sks = new Sks('https://localhost:8001/');\n  const { pubkey } = await sks.lookupEmail(email);\n  if (pubkey !== null) {\n    throw Error(`expected pubkey=null but got ${pubkey}`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`Sks lookup pubkey - from live host`);\n(async () => {\n  // this may be flaky - if so, can disable it\n  const email = 'human@flowcrypt.com';\n  const sks = new Sks('https://attester.flowcrypt.com');\n  const { pubkey } = await sks.lookupEmail(email);\n  const key = await KeyUtil.parse(pubkey);\n  if (key.id !== '6BF16EE1ECE7A66C4B6636DF0C9C2E6A4D273C6F') {\n    throw Error(`Expecting key.id=6BF16EE1ECE7A66C4B6636DF0C9C2E6A4D273C6F but got ${key.id}`);\n  }\n  return 'pass';\n})();\n",
    "test/source/tests/browser-unit-tests/unit-Wkd.js": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\n/**\n * These tests use JavaScript instead of TypeScript to avoid dealing with types in cross-environment setup.\n * (tests are injected from NodeJS through puppeteer into a browser environment)\n * While this makes them less convenient to write, the result is more flexible.\n * \n * Import your lib to `ci_unit_test.ts` to resolve `ReferenceError: SomeClass is not defined`\n * \n * Each test must return \"pass\" to pass. To reject, throw an Error.\n * \n * Each test must start with one of (depending on which flavors you want it to run): \n *  - BROWSER_UNIT_TEST_NAME(`some test name`);\n *  - BROWSER_UNIT_TEST_NAME(`some test name`).enterprise;\n *  - BROWSER_UNIT_TEST_NAME(`some test name`).consumer;\n * \n * This is not a JavaScript file. It's a text file that gets parsed, split into chunks, and\n *    parts of it executed as javascript. The structure is very rigid. The only flexible place is inside\n *    the async functions. For the rest, do not change the structure or our parser will get confused.\n *    Do not put any code whatsoever outside of the async functions.\n */\n\nBROWSER_UNIT_TEST_NAME(`Wkd direct method`);\n(async () => {\n  const wkd = new Wkd();\n  wkd.port = 8001;\n  let email;\n  email = 'john.doe@localhost';\n  if (!(await wkd.lookupEmail(email)).pubkeys.length) {\n    throw Error(`Wkd for ${email} didn't return a pubkey`);\n  }\n  email = 'John.Doe@localhost';\n  if (!(await wkd.lookupEmail(email)).pubkeys.length) {\n    throw Error(`Wkd for ${email} didn't return a pubkey`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`Wkd advanced method`);\n(async () => {\n  const wkd = new Wkd();\n  wkd.port = 8001;\n  let email;\n  email = 'john.doe@localhost';\n  if (!(await wkd.lookupEmail(email)).pubkeys.length) {\n    throw Error(`Wkd for ${email} didn't return a pubkey`);\n  }\n  email = 'John.Doe@localHOST';\n  if (!(await wkd.lookupEmail(email)).pubkeys.length) {\n    throw Error(`Wkd for ${email} didn't return a pubkey`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`Wkd client returns all keys`);\n(async () => {\n  const wkd = new Wkd();\n  wkd.port = 8001;\n  const email = 'some.revoked@localhost';\n  const pubkeys = (await wkd.lookupEmail(email)).pubkeys;\n  if (!pubkeys.length) {\n    throw Error(`Wkd for ${email} didn't return a pubkey`);\n  }\n  const ids = (await Promise.all(pubkeys.map(async(pubkey) => await KeyUtil.parse(pubkey)))).map(key => key.id.toUpperCase());\n  if (ids.length === 3 && ids.includes('D6662C5FB9BDE9DA01F3994AAA1EF832D8CCA4F2') &&\n    ids.includes('A5CFC8E8EA4AE69989FE2631097EEBF354259A5E') &&\n    ids.includes('3930752556D57C46A1C56B63DE8538DDA1648C76')) {\n    return 'pass';\n  } else {\n    return \"Expected keys weren't received\";\n  }\n})();\n\nBROWSER_UNIT_TEST_NAME(`Wkd advanced shouldn't fall back on direct if advanced policy file is present`);\n(async () => {\n  const wkd = new Wkd();\n  wkd.port = 8001;\n  const email = 'jack.advanced@localhost';\n  if ((await wkd.lookupEmail(email)).pubkeys.length) {\n    throw Error(`Wkd for ${email} didn't expect a pubkey`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`Wkd incorrect UID should fail`);\n(async () => {\n  const wkd = new Wkd();\n  wkd.port = 8001;\n  const email = 'incorrect@localhost';\n  if ((await wkd.lookupEmail(email)).pubkeys.length) {\n    throw Error(`Wkd for ${email} didn't expect a pubkey`);\n  }\n  return 'pass';\n})();\n\nBROWSER_UNIT_TEST_NAME(`Wkd should extract key for human@flowcrypt.com`);\n(async () => {\n  const wkd = new Wkd();\n  const email = 'human@flowcrypt.com';\n  if (!(await wkd.lookupEmail(email)).pubkeys.length) {\n    throw Error(`Wkd for ${email} didn't return a pubkey`);\n  }\n  return 'pass';\n})();\n",
    "test/source/tests/compose.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as ava from 'ava';\nimport { Page } from 'puppeteer';\n\nimport { BrowserHandle, Controllable, ControllablePage, ControllableFrame } from './../browser';\nimport { Config, Util } from './../util';\nimport { writeFileSync } from 'fs';\nimport { AvaContext } from './tooling';\nimport { ComposePageRecipe } from './page-recipe/compose-page-recipe';\nimport { Dict } from './../core/common';\nimport { GoogleData } from './../mock/google/google-data';\nimport { InboxPageRecipe } from './page-recipe/inbox-page-recipe';\nimport { OauthPageRecipe } from './page-recipe/oauth-page-recipe';\nimport { PageRecipe } from './page-recipe/abstract-page-recipe';\nimport { SettingsPageRecipe } from './page-recipe/settings-page-recipe';\nimport { somePubkey } from './../mock/attester/attester-endpoints';\nimport { TestUrls } from './../browser/test-urls';\nimport { TestVariant } from './../util';\nimport { TestWithBrowser } from './../test';\nimport { expect } from \"chai\";\nimport { BrowserRecipe } from './tooling/browser-recipe';\nimport { SetupPageRecipe } from './page-recipe/setup-page-recipe';\nimport { testConstants } from './tooling/consts';\n\n// tslint:disable:no-blank-lines-func\n// tslint:disable:no-unused-expression\n/* eslint-disable max-len */\n\nexport const defineComposeTests = (testVariant: TestVariant, testWithBrowser: TestWithBrowser) => {\n\n  if (testVariant !== 'CONSUMER-LIVE-GMAIL') {\n\n    ava.default('compose - toggle minimized state by clicking compose window header', testWithBrowser('compatibility', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('flowcrypt.compatibility@gmail.com'));\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      const initialComposeFrameHeight = await inboxPage.getOuterHeight('iframe');\n      await composeFrame.waitAll('#section_header');\n      const composeFrameHeaderHeight = await composeFrame.getOuterHeight('#section_header');\n      await Util.sleep(4); // todo - should be fixed, caused by `$('body').attr('data-test-state', 'ready');` baing called in two differing situations\n      // mimimize compose frame\n      await composeFrame.waitAndClick('@header-title');\n      expect(await inboxPage.getOuterHeight('iframe')).to.eq(composeFrameHeaderHeight, 'compose box height failed to collapse');\n      // restore compose frame\n      await composeFrame.waitAndClick('@header-title');\n      expect(await inboxPage.getOuterHeight('iframe')).to.eq(initialComposeFrameHeight);\n    }));\n\n    ava.default('compose - signed with entered pass phrase + will remember pass phrase in session', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const k = Config.key('ci.tests.gmail');\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('ci.tests.gmail@flowcrypt.test'));\n      await SettingsPageRecipe.forgetAllPassPhrasesInStorage(settingsPage, k.passphrase);\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'human@flowcrypt.com' }, 'sign with entered pass phrase', { encrypt: false });\n      await composeFrame.waitAndClick('@action-send');\n      await inboxPage.waitAll('@dialog-passphrase');\n      const passphraseDialog = await inboxPage.getFrame(['passphrase.htm']);\n      await passphraseDialog.waitAndType('@input-pass-phrase', k.passphrase);\n      await passphraseDialog.waitAndClick('@action-confirm-pass-phrase-entry');\n      await inboxPage.waitTillGone('@dialog-passphrase');\n      await inboxPage.waitTillGone('@container-new-message'); // confirming pass phrase will auto-send the message\n      // signed - done, now try to see if it remembered pp in session\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'signed message pp in session', { encrypt: false });\n      await ComposePageRecipe.sendAndClose(composePage);\n      await settingsPage.close();\n      await inboxPage.close();\n    }));\n\n    ava.default('compose - can load contact based on name', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      // works on first search\n      const composePage1 = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await composePage1.type('@input-to', 'human'); // test guessing of contacts\n      await composePage1.waitAll(['@container-contacts', '@action-select-contact-name(Human at FlowCrypt)']);\n      await composePage1.waitAll(['@container-contacts', '@action-select-contact-email(human@flowcrypt.com)']);\n      // works on subsequent search\n      const composePage2 = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await composePage2.type('@input-to', 'human'); // test guessing of contacts\n      await composePage2.waitAll(['@container-contacts', '@action-select-contact-name(Human at FlowCrypt)']);\n      await composePage2.waitAll(['@container-contacts', '@action-select-contact-email(human@flowcrypt.com)']);\n    }));\n\n    ava.default('compose - can load contact based on name different from email', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      // works on the first search\n      const composePage1 = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await composePage1.type('@input-to', 'FirstName'); // test guessing of contacts when the name is not included in email address\n      await composePage1.waitAll(['@container-contacts', '@action-select-contact-email(therecipient@theirdomain.com)']);\n      // works on subsequent search\n      const composePage2 = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await composePage2.type('@input-to', 'FirstName'); // test guessing of contacts when the name is not included in email address\n      await composePage2.waitAll(['@container-contacts', '@action-select-contact-email(therecipient@theirdomain.com)']);\n    }));\n\n    ava.default(`compose - can choose found contact`, testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      // composePage.enable_debugging('choose-contact');\n      await composePage.type('@input-to', 'human'); // test loading of contacts\n      await composePage.waitAll(['@container-contacts', '@action-select-contact-email(human@flowcrypt.com)'], { timeout: 30 });\n      await composePage.waitAndClick('@action-select-contact-email(human@flowcrypt.com)', { retryErrs: true, confirmGone: true, delay: 0 });\n      // todo - verify that the contact/pubkey is showing in green once clicked\n      await composePage.waitAndClick('@input-subject');\n      await composePage.type('@input-subject', `Automated puppeteer test: pubkey chosen by clicking found contact`);\n      await composePage.type('@input-body', `This is an automated puppeteer test: pubkey chosen by clicking found contact`);\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default(`compose - recipients are properly ordered`, testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await composePage.page.setViewport({ width: 540, height: 606 });\n      await ComposePageRecipe.fillMsg(composePage, { to: 'recip1@corp.co', cc: 'сс1@corp.co', bcc: 'bсс1@corp.co' }, 'recipients are properly ordered');\n      await composePage.waitAndType(`@input-to`, 'recip2@corp.co');\n      await composePage.waitAndType(`@input-bcc`, 'bcc2@corp.co');\n      await composePage.waitAndFocus('@input-body');\n      await composePage.waitTillGone('@spinner');\n      const emailPreview = await composePage.waitAny('@recipients-preview');\n      const recipients = await PageRecipe.getElementPropertyJson(emailPreview, 'textContent');\n      expect(recipients).to.eq(['recip1@corp.co', 'recip2@corp.co', 'сс1@corp.co', 'bсс1@corp.co', '1 more'].join(''));\n    }));\n\n    ava.default(`compose - auto include pubkey when our key is not available on Wkd`, testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await composePage.page.setViewport({ width: 540, height: 606 });\n      await ComposePageRecipe.fillMsg(composePage, { to: 'flowcrypt.compatibility@gmail.com' }, 'testing auto include pubkey');\n      await composePage.waitTillGone('@spinner');\n      await Util.sleep(3); // wait for the Wkd lookup to complete\n      expect(await composePage.hasClass('@action-include-pubkey', 'active')).to.be.false;\n      await composePage.waitAndType(`@input-to`, 'some.unknown@unknown.com');\n      await composePage.waitAndFocus('@input-body');\n      await composePage.waitTillGone('@spinner');\n      await Util.sleep(3); // allow some time to search for messages\n      expect(await composePage.hasClass('@action-include-pubkey', 'active')).to.be.true;\n    }));\n\n    ava.default(`compose - auto include pubkey is inactive when our key is available on Wkd`, testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'wkd@google.mock.flowcryptlocal.test:8001';\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await SetupPageRecipe.autoKeygen(settingsPage);\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, acct);\n      await composePage.page.setViewport({ width: 540, height: 606 });\n      await ComposePageRecipe.fillMsg(composePage, { to: 'ci.tests.gmail@flowcrypt.test' }, 'testing auto include pubkey');\n      await composePage.waitTillGone('@spinner');\n      await Util.sleep(3); // wait for the Wkd lookup to complete\n      expect(await composePage.hasClass('@action-include-pubkey', 'active')).to.be.false;\n      await composePage.waitAndType('@input-to', 'some.unknown@unknown.com');\n      await composePage.waitAndFocus('@input-body');\n      await composePage.waitTillGone('@spinner');\n      await Util.sleep(3); // allow some time to search for messages\n      expect(await composePage.hasClass('@action-include-pubkey', 'active')).to.be.false;\n    }));\n\n    ava.default(`compose - freshly loaded pubkey`, testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'freshly loaded pubkey');\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('compose - recipient pasted including name', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'Human at Flowcrypt <Human@FlowCrypt.com>' }, 'recipient pasted including name');\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('compose - nopgp', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human+nopgp@flowcrypt.com' }, 'unknown pubkey');\n      await ComposePageRecipe.sendAndClose(composePage, { password: 'test-pass' });\n    }));\n\n    ava.default('compose - from alias', testWithBrowser('compatibility', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      await composePage.selectOption('@input-from', 'flowcryptcompatibility@gmail.com');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'from alias');\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('compose - with attachments + nopgp', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human+nopgp@flowcrypt.com' }, 'with files + nonppg');\n      const fileInput = await composePage.target.$('input[type=file]');\n      await fileInput!.uploadFile('test/samples/small.txt', 'test/samples/small.png', 'test/samples/small.pdf');\n      await ComposePageRecipe.sendAndClose(composePage, { password: 'test-pass', timeout: 90 });\n    }));\n\n    ava.default('compose - signed message', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'signed message', { encrypt: false });\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('compose - settings - manually copied pubkey', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      let composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'human@flowcrypt.com' }, 'just to load - will close this page');\n      await Util.sleep(2); // todo: should wait until actually loaded\n      await composeFrame.waitAndClick('@action-close-new-message');\n      await inboxPage.waitTillGone('@container-new-message');\n      composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'human+manualcopypgp@flowcrypt.com' }, 'manual copied key');\n      await composeFrame.waitAndClick('@action-open-add-pubkey-dialog', { delay: 1 });\n      await inboxPage.waitAll('@dialog-add-pubkey');\n      const addPubkeyDialog = await inboxPage.getFrame(['add_pubkey.htm']);\n      await addPubkeyDialog.waitAll('@input-select-copy-from');\n      await Util.sleep(1);\n      await addPubkeyDialog.selectOption('@input-select-copy-from', 'human@flowcrypt.com');\n      await Util.sleep(1);\n      await addPubkeyDialog.waitAndClick('@action-add-pubkey');\n      await inboxPage.waitTillGone('@dialog-add-pubkey');\n      await composeFrame.waitAndClick('@action-send', { delay: 2 });\n      await inboxPage.waitTillGone('@container-new-message');\n    }));\n\n    ava.default('compose - keyboard - Ctrl+Enter sends message', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await composeFrame.target.evaluateHandle(() => (document.querySelector('#section_compose') as HTMLElement).dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', ctrlKey: true })));\n      await composeFrame.waitAndRespondToModal('error', 'confirm', 'Please add a recipient first');\n    }));\n\n    ava.default('compose - keyboard - Opening & changing composer send btn popover using keyboard', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await composeFrame.waitAndFocus('@action-show-options-popover');\n      await inboxPage.press('Enter');\n      await inboxPage.press('ArrowDown', 3); // more arrow downs to ensure that active element selection loops\n      await inboxPage.press('Enter');\n      expect(await composeFrame.read('@action-send')).to.eq('Sign and Send');\n    }));\n\n    ava.default('compose - keyboard - Attaching file using keyboard', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await composeFrame.waitAndFocus('@action-attach-files');\n      // Set up the Promise *before* the file chooser is launched\n      const fileChooser = inboxPage.page.waitForFileChooser();\n      await Util.sleep(0.5); // waitForFileChooser() is flaky without this timeout, #3051\n      await inboxPage.press('Enter');\n      await fileChooser;\n    }));\n\n    ava.default('compose - reply - old gmail threadId fmt', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___&threadId=16841ce0ce5cb74d&replyMsgId=16841ce0ce5cb74d';\n      const replyFrame = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, skipValidation: true });\n      await replyFrame.waitAll(['#new_message', '@action-retry-by-reloading']);\n      expect(await replyFrame.read('#new_message')).to.include('Cannot get reply data for the message you are replying to');\n      await replyFrame.notPresent('@action-accept-reply-prompt');\n    }));\n\n    ava.default('compose - reply - thread id does not exist', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___&threadId=16804894591b3a4b&replyMsgId=16804894591b3a4b';\n      const replyFrame = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, skipValidation: true, });\n      await replyFrame.waitAll(['#new_message', '@action-retry-by-reloading']);\n      expect(await replyFrame.read('#new_message')).to.include('Cannot get reply data for the message you are replying to');\n      await replyFrame.notPresent('@action-accept-reply-prompt');\n    }));\n\n    ava.default('compose - quote - can load quote from encrypted/text email', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'threadId=16b584ed95837510&skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___&replyMsgId=16b584ed95837510';\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, hasReplyPrompt: true });\n      await composePage.waitAndClick('@encrypted-reply', { delay: 5 });\n      await clickTripleDotAndExpectQuoteToLoad(composePage, [\n        'On 2019-06-14 at 23:24, flowcrypt.compatibility@gmail.com wrote:',\n        '> This is some message',\n        '>',\n        '> and below is the quote',\n        '>',\n        '> > this is the quote',\n        '> > still the quote',\n        '> > third line',\n        '> >> double quote',\n        '> >> again double quote'\n      ].join('\\n'));\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('compose - quote - can load quote from plain/text email', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'threadId=16402d6dc4342e7f&skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___' +\n        '&replyMsgId=16402d6dc4342e7f';\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, hasReplyPrompt: true });\n      await composePage.waitAndClick('@encrypted-reply', { delay: 1 });\n      await clickTripleDotAndExpectQuoteToLoad(composePage, [\n        'On 2018-06-15 at 09:46, info@nvimp.com wrote:',\n        '> cropping all except for the image below'\n      ].join('\\n'));\n    }));\n\n    ava.default('compose - reply - can load quote from plain/html email', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'threadId=16b36861a890bb26&skipClickPrompt=___cu_false___' +\n        '&ignoreDraft=___cu_false___&replyMsgId=16b36861a890bb26';\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, hasReplyPrompt: true });\n      await composePage.waitAndClick('@encrypted-reply', { delay: 1 });\n      expect(await composePage.read('@input-body')).to.not.include('flowcrypt.compatibility test footer with an img');\n      await clickTripleDotAndExpectQuoteToLoad(composePage, [\n        'On 2019-06-08 at 09:57, human@flowcrypt.com wrote:',\n        '> Used to fail on Android app',\n        '>',\n        '> ---------- Forwarded message ---------',\n        '> From: Mozilla <Mozilla@e.mozilla.org>',\n        '> Date: Thu, 6 Jun 2019, 17:22',\n        '> Subject: Your misinformation questions ... answered.',\n        '> To: <tom@cryptup.org>'\n      ].join('\\n'));\n    }));\n\n    ava.default('compose - reply - can load quote from encrypted/html email', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'threadId=1663a65bbd73ce1a&skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___&replyMsgId=1663a65bbd73ce1a';\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, hasReplyPrompt: true });\n      await composePage.waitAndClick('@encrypted-reply', { delay: 1 });\n      await clickTripleDotAndExpectQuoteToLoad(composePage, [\n        'On 2018-10-03 at 14:47, henry.electrum@gmail.com wrote:',\n        '> The following text is bold: this is bold',\n        '>',\n        '> The following text is red: this text is red'\n      ].join('\\n'));\n    }));\n\n    for (const inputMethod of ['mouse', 'keyboard']) {\n      ava.default(`compose - reply - pass phrase dialog - dialog ok (${inputMethod})`, testWithBrowser('compatibility', async (t, browser) => {\n        const pp = Config.key('flowcrypt.compatibility.1pp1').passphrase;\n        const { inboxPage, replyFrame } = await setRequirePassPhraseAndOpenRepliedMessage(t, browser, pp);\n        // Get Passphrase dialog and write confirm passphrase\n        await inboxPage.waitAll('@dialog-passphrase');\n        const passPhraseFrame = await inboxPage.getFrame(['passphrase.htm']);\n        await passPhraseFrame.waitAndType('@input-pass-phrase', pp);\n        if (inputMethod === 'mouse') {\n          await passPhraseFrame.waitAndClick('@action-confirm-pass-phrase-entry');\n        } else if (inputMethod === 'keyboard') {\n          await inboxPage.press('Enter');\n        }\n        await inboxPage.waitTillGone('@dialog');\n        // Then we can try to run base test\n        await clickTripleDotAndExpectQuoteToLoad(replyFrame, [\n          'On 2019-06-14 at 23:24, flowcrypt.compatibility@gmail.com wrote:',\n          '> This is some message',\n          '>',\n          '> and below is the quote',\n          '>',\n          '> > this is the quote',\n          '> > still the quote',\n          '> > third line',\n          '> >> double quote',\n          '> >> again double quote'\n        ].join('\\n'));\n      }));\n\n      ava.default(`compose - reply - pass phrase dialog - dialog cancel (${inputMethod})`, testWithBrowser('compatibility', async (t, browser) => {\n        const pp = Config.key('flowcrypt.compatibility.1pp1').passphrase;\n        const { inboxPage, replyFrame } = await setRequirePassPhraseAndOpenRepliedMessage(t, browser, pp);\n        // Get Passphrase dialog and cancel confirm passphrase\n        await inboxPage.waitAll('@dialog-passphrase');\n        const passPhraseFrame = await inboxPage.getFrame(['passphrase.htm']);\n        if (inputMethod === 'mouse') {\n          await passPhraseFrame.waitAndClick('@action-cancel-pass-phrase-entry');\n        } else if (inputMethod === 'keyboard') {\n          await inboxPage.press('Escape');\n        }\n        await inboxPage.waitTillGone('@dialog');\n        await replyFrame.waitAll(['@action-expand-quoted-text']);\n        const inputBody = await replyFrame.read('@input-body');\n        expect(inputBody.trim()).to.be.empty;\n        await clickTripleDotAndExpectQuoteToLoad(replyFrame, [\n          'On 2019-06-14 at 23:24, flowcrypt.compatibility@gmail.com wrote:',\n          '> (Skipping previous message quote)'\n        ].join('\\n'));\n      }));\n    }\n\n    ava.default('compose - reply - signed message', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'threadId=15f7f5face7101db&skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___&replyMsgId=15f7f5face7101db';\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, hasReplyPrompt: true });\n      await composePage.notPresent('@action-accept-reply-all-prompt');\n      await composePage.waitAndClick('@encrypted-reply', { delay: 1 });\n      await composePage.waitAll('@action-send');\n      await Util.sleep(0.5);\n      expect(await composePage.read('@action-send')).to.eq('Sign and Send');\n      await composePage.waitAndClick('@action-show-options-popover');\n      await composePage.waitAll(['@action-toggle-sign', '@action-toggle-encrypt', '@icon-toggle-sign-tick']);\n      await composePage.notPresent(['@icon-toggle-encrypt-tick']); // response to signed message should not be auto-encrypted\n      await ComposePageRecipe.fillMsg(composePage, {}, undefined, {}, 'reply');\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('compose - forward - pgp/mime signed-only', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'threadId=15f7fc2919788f03&skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___&replyMsgId=15f7fc2919788f03';\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, hasReplyPrompt: true });\n      await composePage.waitAndClick('@action-forward');\n      await ComposePageRecipe.fillRecipients(composePage, { to: 'human@flowcrypt.com' }, 'forward');\n      expect(await composePage.read('@input-body')).to.include('> This message will contain a separately attached file + signature.');\n      await composePage.waitAny('.qq-file-id-0');\n    }));\n\n    ava.default('compose - standalone- hide/show btns after signing', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'test.no.pgp@test.com' }, 'Signed Message', { encrypt: false });\n      expect(await composePage.isElementPresent('@add-intro')).to.be.true;\n      expect(await composePage.isElementPresent('@password-or-pubkey-container')).to.be.true;\n      await composePage.notPresent('@add-intro');\n      await composePage.notPresent('@password-or-pubkey-container');\n    }));\n\n    ava.default('compose - CC&BCC new message', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com', cc: 'human@flowcrypt.com', bcc: 'human@flowcrypt.com' }, 'Testing CC And BCC');\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('compose - reply - CC&BCC test reply', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'threadId=16ce2c965c75e5a6&skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___&replyMsgId=16ce2c965c75e5a6';\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, hasReplyPrompt: true });\n      await composePage.waitAndClick('@action-accept-reply-all-prompt', { delay: 2 });\n      await ComposePageRecipe.fillMsg(composePage, { bcc: \"test@email.com\" }, undefined, undefined, 'reply');\n      await expectRecipientElements(composePage, { to: ['censored@email.com'], cc: ['censored@email.com'], bcc: ['test@email.com'] });\n      await Util.sleep(3);\n      await ComposePageRecipe.sendAndClose(composePage, { password: 'test-pass' });\n    }));\n\n    ava.default('compose - expired can still send', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'expired.on.attester@domain.com' }, 'Test Expired Email');\n      const expandContainer = await composePage.waitAny('@action-show-container-cc-bcc-buttons');\n      const recipient = await expandContainer.$('.email_preview span');\n      expect(await PageRecipe.getElementPropertyJson(recipient!, 'className')).to.include('expired');\n      await composePage.waitAndClick('@action-send');\n      await PageRecipe.waitForModalAndRespond(composePage, 'confirm', { contentToCheck: 'The public key of one of your recipients is expired.', clickOn: 'confirm', timeout: 40 });\n      await composePage.waitForSelTestState('closed', 20); // succesfully sent\n      await composePage.close();\n    }));\n\n    ava.default('compose - revoked OpenPGP key', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const dbPage = await browser.newPage(t, TestUrls.extension('chrome/dev/ci_unit_test.htm'));\n      await dbPage.page.evaluate(async (pubkey: string) => {\n        const db = await (window as any).ContactStore.dbOpen();\n        const opgpKeyRevoked = await (window as any).KeyUtil.parse(pubkey);\n        await (window as any).ContactStore.update(db, 'revoked.pubkey@flowcrypt.com', { pubkey: opgpKeyRevoked });\n      }, testConstants.somerevokedValidNowRevoked);\n      await dbPage.close();\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'revoked.pubkey@flowcrypt.com' }, 'Test Revoked');\n      const expandContainer = await composePage.waitAny('@action-show-container-cc-bcc-buttons');\n      const recipient = await expandContainer.$('.email_preview span');\n      expect(await PageRecipe.getElementPropertyJson(recipient!, 'className')).to.include('revoked');\n      await composePage.close();\n    }));\n\n    ava.default('compose - externally revoked key', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const dbPage = await browser.newPage(t, TestUrls.extension('chrome/dev/ci_unit_test.htm'));\n      await dbPage.page.evaluate(async (pubkey: string) => {\n        const db = await (window as any).ContactStore.dbOpen();\n        const opgpKeyOldAndValid = await (window as any).KeyUtil.parse(pubkey);\n        await (window as any).ContactStore.update(db, 'not.revoked.pubkey@flowcrypt.com', { pubkey: opgpKeyOldAndValid });\n        await new Promise((resolve, reject) => {\n          const tx = db.transaction(['revocations'], 'readwrite');\n          (window as any).ContactStore.setTxHandlers(tx, resolve, reject);\n          tx.objectStore('revocations').put({ fingerprint: opgpKeyOldAndValid.id + '-X509' });\n        });\n      }, testConstants.somerevokedValid);\n      await dbPage.close();\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'not.revoked.pubkey@flowcrypt.com' }, 'Test Revoked');\n      const expandContainer = await composePage.waitAny('@action-show-container-cc-bcc-buttons');\n      const recipient = await expandContainer.$('.email_preview span');\n      expect(await PageRecipe.getElementPropertyJson(recipient!, 'className')).to.include('revoked');\n      await composePage.close();\n    }));\n\n    ava.default('compose - nogpg and revoked recipients trigger both warnings', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const dbPage = await browser.newPage(t, TestUrls.extension('chrome/dev/ci_unit_test.htm'));\n      await dbPage.page.evaluate(async (pubkey: string) => {\n        const db = await (window as any).ContactStore.dbOpen();\n        const opgpKeyRevoked = await (window as any).KeyUtil.parse(pubkey);\n        await (window as any).ContactStore.update(db, 'revoked.pubkey@flowcrypt.com', { pubkey: opgpKeyRevoked });\n      }, testConstants.somerevokedValidNowRevoked);\n      await dbPage.close();\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'revoked.pubkey@flowcrypt.com', cc: 'nopgp@missing.com' }, 'Test NoPGP and Revoked');\n      await composePage.waitAll(['@warning-nopgp', '@warning-revoked']);\n      await composePage.close();\n    }));\n\n    ava.default('compose - nogpg and non-revoked recipients trigger nopgp warning only', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const dbPage = await browser.newPage(t, TestUrls.extension('chrome/dev/ci_unit_test.htm'));\n      await dbPage.page.evaluate(async (pubkey: string) => {\n        const db = await (window as any).ContactStore.dbOpen();\n        const opgpKeyValid = await (window as any).KeyUtil.parse(pubkey);\n        await (window as any).ContactStore.update(db, 'not.revoked.pubkey@flowcrypt.com', { pubkey: opgpKeyValid });\n      }, testConstants.somerevokedValid);\n      await dbPage.close();\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'not.revoked.pubkey@flowcrypt.com', cc: 'nopgp@missing.com' }, 'Test NoPGP and Non-Revoked');\n      await composePage.waitAll('@warning-nopgp');\n      await composePage.waitTillGone('@warning-revoked');\n      await composePage.close();\n    }));\n\n    ava.default('compose - revoked recipients trigger revoked warning', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const dbPage = await browser.newPage(t, TestUrls.extension('chrome/dev/ci_unit_test.htm'));\n      await dbPage.page.evaluate(async (pubkey: string) => {\n        const db = await (window as any).ContactStore.dbOpen();\n        const opgpKeyRevoked = await (window as any).KeyUtil.parse(pubkey);\n        await (window as any).ContactStore.update(db, 'revoked.pubkey@flowcrypt.com', { pubkey: opgpKeyRevoked });\n      }, testConstants.somerevokedValidNowRevoked);\n      await dbPage.close();\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'revoked.pubkey@flowcrypt.com', }, 'Test Revoked Only');\n      await composePage.waitAll('@warning-revoked');\n      await composePage.waitTillGone('@warning-nopgp');\n      await composePage.close();\n    }));\n\n    ava.default('compose - good recipients trigger no warning', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const dbPage = await browser.newPage(t, TestUrls.extension('chrome/dev/ci_unit_test.htm'));\n      await dbPage.page.evaluate(async (pubkey: string) => {\n        const db = await (window as any).ContactStore.dbOpen();\n        const opgpKeyValid = await (window as any).KeyUtil.parse(pubkey);\n        await (window as any).ContactStore.update(db, 'not.revoked.pubkey@flowcrypt.com', { pubkey: opgpKeyValid });\n      }, testConstants.somerevokedValid);\n      await dbPage.close();\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'not.revoked.pubkey@flowcrypt.com', }, 'Test Non-Revoked Only');\n      await composePage.waitTillGone(['@warning-nopgp', '@warning-revoked']);\n      await composePage.close();\n    }));\n\n    ava.default('compose - loading drafts - new message, rendering cc/bcc and check if cc/bcc btns are hidden',\n      testWithBrowser('compatibility', async (t, browser) => {\n        const appendUrl = 'draftId=draft-1';\n        const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl });\n        await expectRecipientElements(composePage, { to: ['flowcryptcompatibility@gmail.com'], cc: ['flowcrypt.compatibility@gmail.com'], bcc: ['human@flowcrypt.com'] });\n        const subjectElem = await composePage.waitAny('@input-subject');\n        expect(await PageRecipe.getElementPropertyJson(subjectElem, 'value')).to.equal('Test Draft - New Message');\n        expect((await composePage.read('@input-body')).trim()).to.equal('Testing Drafts (Do not delete)');\n        for (const elem of await composePage.target.$$('.container-cc-bcc-buttons > span')) {\n          expect(await PageRecipe.getElementPropertyJson(elem, 'offsetHeight')).to.equal(0); // CC/BCC btn isn't visible\n        }\n      }));\n\n    ava.default('compose - loading drafts - reply', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'threadId=16cfa9001baaac0a&skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___&replyMsgId=16cfa9001baaac0a';\n      const initialScript = () => {\n        chrome.storage.local.set({ 'cryptup_flowcryptcompatibilitygmailcom_drafts_reply': { '16cfa9001baaac0a': 'draft-3' } });\n      };\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, hasReplyPrompt: true, skipClickPropt: true, initialScript });\n      await composePage.waitAndClick('@action-show-container-cc-bcc-buttons');\n      await expectRecipientElements(composePage, { to: ['flowcryptcompatibility@gmail.com'] });\n      expect(await composePage.read('@input-body')).to.include('Test Draft Reply (Do not delete, tests is using this draft)');\n    }));\n\n    ava.default('compose - key-mismatch - standalone - key mismatch loading', testWithBrowser('compatibility', async (t, browser) => {\n      const params = 'threadId=15f7f5630573be2d&skipClickPrompt=___cu_true___&ignoreDraft=___cu_true___&replyMsgId=15f7f5630573be2d&disableDraftSaving=___cu_true___&replyPubkeyMismatch=___cu_true___';\n      const replyMismatchPage = await browser.newPage(t, 'chrome/elements/compose.htm?account_email=flowcrypt.compatibility%40gmail.com&parent_tab_id=0&debug=___cu_true___&frameId=none&' + params);\n      await replyMismatchPage.waitForSelTestState('ready');\n      await Util.sleep(3);\n      await expectRecipientElements(replyMismatchPage, { to: ['censored@email.com'], cc: [], bcc: [] });\n      expect(await replyMismatchPage.read('@input-body')).to.include('I was not able to read your encrypted message because it was encrypted for a wrong key.');\n      await replyMismatchPage.waitAll('.qq-upload-file');\n      await ComposePageRecipe.sendAndClose(replyMismatchPage);\n    }));\n\n    ava.default('compose - reply all - TO/CC/BCC when replying all', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = `threadId=16d6a6c2d6ae618f&skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___&replyMsgId=16d6a6c2d6ae618f`;\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, hasReplyPrompt: true });\n      await composePage.waitAndClick('@action-accept-reply-all-prompt');\n      await composePage.waitForSelTestState('ready'); // continue when all recipients get evaluated\n      await composePage.waitAndClick('@action-show-container-cc-bcc-buttons');\n      for (const type of ['to', 'cc', 'bcc']) {\n        const container = (await composePage.waitAny(`@container-${type}`))!;\n        const recipients = await container.$$('.recipients > span');\n        expect(recipients.length).to.equal(2);\n        for (const recipient of recipients) {\n          const textContent = await PageRecipe.getElementPropertyJson(recipient, 'textContent');\n          expect(textContent.trim()).to.include('@flowcrypt.com');\n        }\n      }\n    }));\n\n    ava.default('compose - send new plain message', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'New Plain Message', { encrypt: false, sign: false });\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('compose - reply - signed message with attachment - can be downloaded after send', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'threadId=15f7f5face7101db&skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___&replyMsgId=15f7f5face7101db';\n      const attachmentFilename = 'small.txt';\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, hasReplyPrompt: true });\n      await composePage.waitAndClick('@encrypted-reply', { delay: 1 });\n      await composePage.waitAll('@action-send');\n      await Util.sleep(0.5);\n      expect(await composePage.read('@action-send')).to.eq('Sign and Send');\n      await composePage.waitAndClick('@action-show-options-popover');\n      await composePage.waitAll(['@action-toggle-sign', '@action-toggle-encrypt', '@icon-toggle-sign-tick']);\n      await composePage.notPresent(['@icon-toggle-encrypt-tick']); // response to signed message should not be auto-encrypted\n      const fileInput = await composePage.target.$('input[type=file]');\n      await fileInput!.uploadFile(`test/samples/${attachmentFilename}`);\n      await composePage.waitAndClick('@action-send', { delay: 1 });\n      const attachment = await composePage.getFrame(['attachment.htm', `name=${attachmentFilename}`]);\n      await attachment.waitForSelTestState('ready');\n      const fileText = await composePage.awaitDownloadTriggeredByClicking(async () => {\n        await attachment.click('#download');\n      });\n      expect(fileText.toString()).to.equal(`small text file\\nnot much here\\nthis worked\\n`);\n      await composePage.close();\n    }));\n\n    ava.default('compose - send btn should be disabled while encrypting/sending', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, '');\n      await composePage.waitAndClick('@action-send', { delay: 1 });\n      expect(await composePage.isDisabled('#send_btn')).to.be.true;\n      expect(await composePage.isDisabled('#toggle_send_options')).to.be.true;\n      await composePage.waitAndRespondToModal('confirm', 'cancel', 'Send without a subject?');\n      expect(await composePage.isDisabled('#send_btn')).to.be.false;\n      expect(await composePage.isDisabled('#toggle_send_options')).to.be.false;\n    }));\n\n    ava.default('compose - load contacts through API', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      let composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await composePage.waitAndClick('@action-show-container-cc-bcc-buttons');\n      await composePage.type('@input-to', 'contact');\n      if (testVariant === 'CONSUMER-MOCK') {\n        // consumer does not get Contacts scope automatically (may scare users when they install)\n        // first search, did not yet receive contacts scope - should find no contacts\n        await expectContactsResultEqual(composePage, ['No Contacts Found']);\n        // allow contacts scope, and expect that it will find a contact\n        const oauthPopup = await browser.newPageTriggeredBy(t, () => composePage.waitAndClick('@action-auth-with-contacts-scope'));\n        await OauthPageRecipe.google(t, oauthPopup, 'ci.tests.gmail@flowcrypt.test', 'approve');\n      }\n      await expectContactsResultEqual(composePage, ['contact.test@flowcrypt.com']);\n      // re-load the compose window, expect that it remembers scope was connected, and remembers the contact\n      composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await composePage.waitAndClick('@action-show-container-cc-bcc-buttons');\n      await composePage.type('@input-to', 'contact');\n      await expectContactsResultEqual(composePage, ['contact.test@flowcrypt.com']);\n      await composePage.notPresent('@action-auth-with-contacts-scope');\n    }));\n\n    ava.default('compose - load contacts - contacts should be properly ordered', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      let composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await composeFrame.type('@input-to', 'testsearchorder');\n      if (testVariant === 'CONSUMER-MOCK') {\n        // allow contacts scope, and expect that it will find contacts\n        const oauthPopup = await browser.newPageTriggeredBy(t, () => composeFrame.waitAndClick('@action-auth-with-contacts-scope'));\n        await OauthPageRecipe.google(t, oauthPopup, 'ci.tests.gmail@flowcrypt.test', 'approve');\n      }\n      await expectContactsResultEqual(composeFrame, [\n        'testsearchorder1@flowcrypt.com',\n        'testsearchorder2@flowcrypt.com',\n        'testsearchorder3@flowcrypt.com',\n        'testsearchorder4@flowcrypt.com',\n        'testsearchorder5@flowcrypt.com',\n        'testsearchorder6@flowcrypt.com',\n        'testsearchorder7@flowcrypt.com',\n        'testsearchorder8@flowcrypt.com',\n      ]);\n      await composeFrame.waitAndClick('@action-close-new-message');\n      await inboxPage.waitTillGone('@container-new-message');\n      // add key + send\n      composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'testsearchorder3@flowcrypt.com' }, t.title);\n      await pastePublicKeyManually(composeFrame, inboxPage, 'testsearchorder3@flowcrypt.com', testConstants.smimeCert);\n      await composeFrame.waitAndClick('@action-send', { delay: 1 });\n      await composeFrame.waitAndClick('.swal2-cancel');\n      await composeFrame.waitAndClick('@action-close-new-message');\n      await inboxPage.waitTillGone('@container-new-message');\n      // add key\n      composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'testsearchorder9@flowcrypt.com' }, t.title);\n      await pastePublicKeyManually(composeFrame, inboxPage, 'testsearchorder9@flowcrypt.com', testConstants.smimeCert);\n      await composeFrame.waitAndClick('@action-close-new-message');\n      await inboxPage.waitTillGone('@container-new-message');\n      // send\n      composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'testsearchorder5@flowcrypt.com' }, t.title);\n      await composeFrame.waitAndType('@input-password', 'test-pass');\n      await composeFrame.waitAndClick('@action-send', { delay: 1 });\n      await composeFrame.waitAndClick('.swal2-cancel');\n      await composeFrame.waitAndClick('@action-close-new-message');\n      await inboxPage.waitTillGone('@container-new-message');\n      // check that contacts are ordered according to hasPgp and lastUse\n      composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await composeFrame.type('@input-to', 'testsearchorder');\n      await expectContactsResultEqual(composeFrame, [\n        'testsearchorder3@flowcrypt.com', // hasPgp + lastUse\n        'testsearchorder9@flowcrypt.com', // hasPgp\n        'testsearchorder5@flowcrypt.com', // lastUse\n        'testsearchorder1@flowcrypt.com',\n        'testsearchorder2@flowcrypt.com',\n        'testsearchorder4@flowcrypt.com',\n        'testsearchorder6@flowcrypt.com',\n        'testsearchorder7@flowcrypt.com',\n      ]);\n    }));\n\n    ava.default('compose - delete recipients with keyboard', testWithBrowser('compatibility', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      await ComposePageRecipe.fillRecipients(composePage, { to: 'human1@flowcrypt.com' }, 'new');\n      await composePage.waitAndType(`@input-to`, 'human2@flowcrypt.com');\n      await composePage.press('Enter');\n      await composePage.waitAndType(`@input-to`, 'human3@flowcrypt.com');\n      await composePage.press('Enter');\n      await expectRecipientElements(composePage, { to: ['human1@flowcrypt.com', 'human2@flowcrypt.com', 'human3@flowcrypt.com'] });\n      // delete recipient with Backspace when #input_to is focued\n      await composePage.press('Backspace');\n      await expectRecipientElements(composePage, { to: ['human1@flowcrypt.com', 'human2@flowcrypt.com'] });\n      // delete recipient with Delete when it's focused\n      await composePage.waitAndFocus('@recipient_0');\n      await composePage.press('Delete');\n      await expectRecipientElements(composePage, { to: ['human2@flowcrypt.com'] });\n      // delete recipient with Backspace when it's focused\n      await composePage.waitAndFocus('@recipient_1');\n      await composePage.press('Backspace');\n      await expectRecipientElements(composePage, { to: [] });\n    }));\n\n    ava.default('compose - new message, open footer', testWithBrowser('compatibility', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      await ComposePageRecipe.fillRecipients(composePage, { to: 'human@flowcrypt.com' }, 'new');\n      await composePage.waitAndClick(`@action-send`);\n      expect(await composePage.read('.swal2-html-container')).to.include('Send without a subject?');\n      await composePage.waitAndClick('.swal2-cancel');\n      await composePage.waitAndType('@input-subject', 'Testing new message with footer', { delay: 1 });\n      await composePage.waitAndClick(`@action-send`);\n      expect(await composePage.read('.swal2-html-container')).to.include('Send empty message?');\n      await composePage.waitAndClick('.swal2-cancel');\n      await composePage.waitAndClick('@action-expand-quoted-text', { delay: 1 });\n      const footer = await composePage.read('@input-body');\n      expect(footer).to.eq('\\n\\n\\n--\\nflowcrypt.compatibility test footer with an img');\n      await composePage.waitAndClick(`@action-send`);\n      expect(await composePage.read('.swal2-html-container')).to.include('Send empty message?');\n      await composePage.waitAndClick('.swal2-cancel');\n      await composePage.waitAndType('@input-body', 'New message\\n' + footer, { delay: 1 });\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('compose - new message, Footer Mock Test', testWithBrowser('compatibility', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'Test Footer (Mock Test)', {}, 'new');\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('compose - loading drafts - test tags in draft', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'draftId=draft-0';\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl });\n      expect(await composePage.read('@input-body')).to.include('hello<draft>here');\n    }));\n\n    ava.default('compose - compose - test minimizing/maximizing', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, 'chrome/settings/inbox/inbox.htm?acctEmail=ci.tests.gmail%40flowcrypt.test');\n      await inboxPage.waitAndClick('@action-open-secure-compose-window');\n      await inboxPage.waitAll(['@container-new-message']);\n      const composeFrame = await inboxPage.getFrame(['compose.htm']);\n      await composeFrame.waitForSelTestState('ready');\n      const composeBody = await composeFrame.waitAny('body');\n      const initialWidth = Number(await PageRecipe.getElementPropertyJson(composeBody, 'offsetWidth'));\n      const initialHeight = Number(await PageRecipe.getElementPropertyJson(composeBody, 'offsetHeight'));\n      await composeFrame.waitAndClick('.popout', { sleepWhenDone: 1 });\n      expect(Number(await PageRecipe.getElementPropertyJson(composeBody, 'offsetWidth'))).to.be.greaterThan(initialWidth, 'popout width greater than initial');\n      expect(Number(await PageRecipe.getElementPropertyJson(composeBody, 'offsetHeight'))).to.be.greaterThan(initialHeight, 'popout weight greater than initial');\n      await composeFrame.waitAndClick('.popout', { sleepWhenDone: 1 });\n      expect(Number(await PageRecipe.getElementPropertyJson(composeBody, 'offsetWidth'))).to.equal(initialWidth, 'width back to initial');\n      expect(Number(await PageRecipe.getElementPropertyJson(composeBody, 'offsetHeight'))).to.equal(initialHeight, 'height back to initial');\n      await composeFrame.waitAndClick('.minimize_new_message', { sleepWhenDone: 1 });\n      expect(Number(await PageRecipe.getElementPropertyJson(composeBody, 'offsetHeight'))).to.be.lessThan(initialHeight, 'minimized lower than initial');\n      await composeFrame.waitAndClick('.minimize_new_message', { sleepWhenDone: 1 });\n      expect(Number(await PageRecipe.getElementPropertyJson(composeBody, 'offsetHeight'))).to.equal(initialHeight, 'back to initial after un-minimizing');\n    }));\n\n    ava.default('compose - saving and rendering a draft with image', testWithBrowser('compatibility', async (t, browser) => {\n      const imgBase64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAnElEQVR42u3RAQ0AAAgDIE1u9FvDOahAVzLFGS1ECEKEIEQIQoQgRIgQIQgRghAhCBGCECEIQYgQhAhBiBCECEEIQoQgRAhChCBECEIQIgQhQhAiBCFCEIIQIQgRghAhCBGCEIQIQYgQhAhBiBCEIEQIQoQgRAhChCAEIUIQIgQhQhAiBCEIEYIQIQgRghAhCBEiRAhChCBECEK+W3uw+TnWoJc/AAAAAElFTkSuQmCC';\n      let composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      const subject = `saving and rendering a draft with image ${Util.lousyRandom()}`;\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, subject, { 'richtext': true });\n      await composePage.page.evaluate((src: string) => { $('[data-test=action-insert-image]').val(src).click(); }, imgBase64);\n      await ComposePageRecipe.waitWhenDraftIsSaved(composePage);\n      await composePage.close();\n      composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl: 'draftId=draft_with_image' });\n      const body = await composePage.waitAny('@input-body');\n      await composePage.waitAll('#input_text img');\n      expect(await body.$eval('#input_text img', el => el.getAttribute('src'))).to.eq(imgBase64);\n    }));\n\n    ava.default('compose - saving and rendering a draft when offline', testWithBrowser('compatibility', async (t, browser) => {\n      let composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      await (composePage.target as Page).setOfflineMode(true); // go offline mode\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'offline test', {});\n      expect(await composePage.read('@action-send')).to.eq('Re-enter recipient..'); // ensure offline mode\n      await composePage.type('@input-body', `This is a test of saving a draft when offline`);\n      await ComposePageRecipe.waitWhenDraftIsSavedLocally(composePage);\n      await composePage.close();\n      composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      expect(await composePage.value('@input-subject')).to.match(/offline test/);\n      await composePage.waitForContent('@input-body', 'This is a test of saving a draft when offline');\n    }));\n\n    ava.default('compose - RTL subject', testWithBrowser('compatibility', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      await composePage.type('@input-subject', 'ش');\n      expect(await composePage.attr('@input-subject', 'dir')).to.eq('rtl');\n      await composePage.press('Backspace');\n      expect(await composePage.attr('@input-subject', 'dir')).to.be.null;\n      await composePage.type('@input-subject', 'a');\n      expect(await composePage.attr('@input-subject', 'dir')).to.be.null;\n    }));\n\n    ava.default('compose - saving and rendering a draft with RTL text (plain text)', testWithBrowser('compatibility', async (t, browser) => {\n      let composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      const subject = `مرحبا RTL plain text`;\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, subject, { richtext: false });\n      await ComposePageRecipe.waitWhenDraftIsSaved(composePage);\n      await composePage.close();\n      composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl: 'draftId=draft_with_rtl_text_plain' });\n      expect(await composePage.attr('@input-subject', 'dir')).to.eq('rtl');\n      expect(await composePage.readHtml('@input-body')).to.include('<div dir=\"rtl\">مرحبا<br></div>');\n    }));\n\n    ava.default('compose - saving and rendering a draft with RTL text (rich text)', testWithBrowser('compatibility', async (t, browser) => {\n      let composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      const subject = `مرحبا RTL rich text`;\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, subject, { richtext: true });\n      await ComposePageRecipe.waitWhenDraftIsSaved(composePage);\n      await composePage.close();\n      composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl: 'draftId=draft_with_rtl_text_rich' });\n      expect(await composePage.readHtml('@input-body')).to.include('<div dir=\"rtl\">مرحبا<br></div>');\n    }));\n\n    ava.default('compose - sending and rendering encrypted message with image', testWithBrowser('compatibility', async (t, browser) => {\n      await sendImgAndVerifyPresentInSentMsg(t, browser, 'encrypt');\n    }));\n\n    ava.default('compose - sending and rendering signed message with image', testWithBrowser('compatibility', async (t, browser) => {\n      await sendImgAndVerifyPresentInSentMsg(t, browser, 'sign');\n    }));\n\n    ava.default('compose - sending and rendering plain message with image', testWithBrowser('compatibility', async (t, browser) => {\n      await sendImgAndVerifyPresentInSentMsg(t, browser, 'plain');\n    }));\n\n    ava.default('compose - sending and rendering message with U+10000 code points', testWithBrowser('compatibility', async (t, browser) => {\n      const rainbow = '\\ud83c\\udf08';\n      await sendTextAndVerifyPresentInSentMsg(t, browser, rainbow, { sign: true, encrypt: false });\n      await sendTextAndVerifyPresentInSentMsg(t, browser, rainbow, { sign: false, encrypt: true });\n      await sendTextAndVerifyPresentInSentMsg(t, browser, rainbow, { sign: true, encrypt: true });\n    }));\n\n    ava.default('compose - sent message should\\'t have version and comment based on OrgRules', testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'has.pub@org-rules-test.flowcrypt.test';\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await SetupPageRecipe.manualEnter(settingsPage, 'has.pub.orgrulestest', { noPrvCreateOrgRule: true, enforceAttesterSubmitOrgRule: true });\n      const subject = `Test Sending Message With Test Text and HIDE_ARMOR_META OrgRule ${Util.lousyRandom()}`;\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, acct);\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, subject, { sign: true });\n      await composePage.waitAndType('@input-body', 'any text', { delay: 1 });\n      await ComposePageRecipe.sendAndClose(composePage);\n      // get sent msg from mock\n      const sentMsg = (await GoogleData.withInitializedData(acct)).getMessageBySubject(subject)!;\n      const message = sentMsg.payload!.body!.data!;\n      expect(message).to.include('-----BEGIN PGP MESSAGE-----');\n      expect(message).to.include('-----END PGP MESSAGE-----');\n      expect(message).to.not.include('Version');\n      expect(message).to.not.include('Comment');\n    }));\n\n    ava.default.skip('oversize attachment does not get erroneously added', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      // big file will get canceled\n      const fileInput = await composePage.target.$('input[type=file]');\n      const localpath = 'test/samples/oversize.txt';\n      await writeFileSync(localpath, 'x'.repeat(30 * 1024 * 1024));\n      await fileInput!.uploadFile(localpath); // 30mb\n      await composePage.waitAndRespondToModal('confirm', 'cancel', 'Combined attachment size is limited to 25 MB. The last file brings it to 30 MB.');\n      await Util.sleep(1);\n      await composePage.notPresent('.qq-upload-file-selector');\n      // small file will get accepted\n      await fileInput!.uploadFile('test/samples/small.png');\n      await composePage.waitForContent('.qq-upload-file-selector', 'small.png');\n    }));\n\n    ava.default('rendered reply - can preview attachment', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const threadId = '173fd7dbe2fec90c';\n      const acctEmail = 'ci.tests.gmail@flowcrypt.test';\n      const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=${acctEmail}&threadId=${threadId}`));\n      await inboxPage.waitAll('iframe');\n      const replyFrame = await inboxPage.getFrame(['compose.htm']);\n      await replyFrame.waitAndClick('@encrypted-reply');\n      const fileInput = await replyFrame.target.$('input[type=file]');\n      await fileInput!.uploadFile('test/samples/small.png');\n      await replyFrame.waitAndClick('@action-send');\n      const attachment = await replyFrame.getFrame(['attachment.htm', 'name=small.png']);\n      await attachment.waitForSelTestState('ready');\n      await attachment.click('body');\n      const attachmentPreviewImage = await inboxPage.getFrame(['attachment_preview.htm']);\n      await attachmentPreviewImage.waitAll('#attachment-preview-container img.attachment-preview-img');\n    }));\n\n    ava.default('attachments - failed to decrypt', testWithBrowser('compatibility', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=flowcrypt.compatibility@gmail.com&threadId=162ec58d70fe04ef`));\n      const attachment = await inboxPage.getFrame(['attachment.htm']);\n      await attachment.waitAndClick('@download-attachment');\n      await attachment.waitAndClick('@decrypt-error-details');\n      const decryptErrorDetails = await inboxPage.getFrame(['attachment_preview.htm']);\n      await decryptErrorDetails.waitForContent('@error-details', 'Error: Session key decryption failed'); // stack\n      await decryptErrorDetails.waitForContent('@error-details', '\"type\": \"key_mismatch\"'); // DecryptError\n    }));\n\n    ava.default('can lookup public key from FlowCrypt Email Key Manager', testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'get.key@key-manager-autogen.flowcrypt.test';\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await SetupPageRecipe.autoKeygen(settingsPage);\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, acct);\n      await ComposePageRecipe.fillMsg(composePage, { to: 'find.public.key@key-manager-autogen.flowcrypt.test' }, 'should find pubkey from key manager');\n      await composePage.waitForContent('.email_address.has_pgp', 'find.public.key@key-manager-autogen.flowcrypt.test');\n      expect(await composePage.attr('.email_address.has_pgp', 'title')).to.contain('00B0 1158 0796 9D75');\n    }));\n\n    ava.default('can lookup public key from WKD directly', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'test-wkd@metacode.biz' }, 'should find pubkey from WKD directly');\n      await composePage.waitForContent('.email_address.has_pgp', 'test-wkd@metacode.biz');\n      expect(await composePage.attr('.email_address.has_pgp', 'title')).to.contain('5B7A BE66 0D5C 62A6 07FE 2448 716B 1776 4E3F CACA');\n    }));\n\n    ava.default('timeouts when searching WKD - used to never time out', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'somewhere@mac.com' }, 'should show no pubkey within a few seconds');\n      await composePage.waitForContent('.email_address.no_pgp', 'somewhere@mac.com');\n      await composePage.waitAll('@input-password');\n    }));\n\n    ava.todo('compose - reply - new gmail threadId fmt');\n\n    ava.todo('compose - reply - skip click prompt');\n\n    ava.default('send with single S/MIME cert', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'smime@recipient.com' }, t.title);\n      await pastePublicKeyManually(composeFrame, inboxPage, 'smime@recipient.com', testConstants.smimeCert);\n      await composeFrame.waitAndClick('@action-send', { delay: 2 });\n      await inboxPage.waitTillGone('@container-new-message');\n    }));\n\n    ava.default('send with several S/MIME certs', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'smime1@recipient.com', cc: 'smime2@recipient.com' }, t.title);\n      await pastePublicKeyManually(composeFrame, inboxPage, 'smime1@recipient.com', testConstants.smimeCert);\n      await pastePublicKeyManually(composeFrame, inboxPage, 'smime2@recipient.com', testConstants.smimeCert);\n      await composeFrame.waitAndClick('@action-send', { delay: 2 });\n      await inboxPage.waitTillGone('@container-new-message');\n    }));\n\n    ava.default('send with S/MIME attachment', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      // todo - this is not yet looking for actual attachment in the result, just checks that it's s/mime message\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'smime.attachment@recipient.com' }, t.title);\n      await pastePublicKeyManually(composeFrame, inboxPage, 'smime.attachment@recipient.com', testConstants.smimeCert);\n      const fileInput = await composeFrame.target.$('input[type=file]');\n      await fileInput!.uploadFile('test/samples/small.txt', 'test/samples/small.png', 'test/samples/small.pdf');\n      await composeFrame.waitAndClick('@action-send', { delay: 2 });\n      await inboxPage.waitTillGone('@container-new-message');\n    }));\n\n    ava.default('send with mixed S/MIME and PGP recipients - should show err', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'smime@recipient.com', cc: 'human@flowcrypt.com' }, t.title);\n      await pastePublicKeyManually(composeFrame, inboxPage, 'smime@recipient.com', testConstants.smimeCert);\n      await composeFrame.waitAndClick('@action-send', { delay: 2 });\n      await PageRecipe.waitForModalAndRespond(composeFrame, 'error', {\n        contentToCheck: 'Failed to send message due to: Error: Cannot use mixed OpenPGP (human@flowcrypt.com) and S/MIME (smime@recipient.com) public keys yet.If you need to email S/MIME recipient, do not add any OpenPGP recipient at the same time.',\n        timeout: 40\n      });\n    }));\n\n    ava.default('send with broken S/MIME cert - err', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'smime@recipient.com' }, t.title);\n      const brokenCert = testConstants.smimeCert.split('\\n');\n      brokenCert.splice(5, 5); // remove 5th to 10th line from cert - make it useless\n      const addPubkeyDialog = await pastePublicKeyManuallyNoClose(composeFrame, inboxPage, 'smime@recipient.com', brokenCert.join('\\n'));\n      await addPubkeyDialog.waitAndRespondToModal('error', 'confirm', 'Too few bytes to read ASN.1 value.');\n    }));\n\n    ava.default('send non-S/MIME cert - err', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to: 'smime@recipient.com' }, t.title);\n      const httpsCert = '-----BEGIN CERTIFICATE-----\\nMIIFZTCCBE2gAwIBAgISA/LOLnFAcrNSDjMi+PvkSbX1MA0GCSqGSIb3DQEBCwUA\\nMEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD\\nExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0yMDAzMTQxNTQ0NTVaFw0y\\nMDA2MTIxNTQ0NTVaMBgxFjAUBgNVBAMTDWZsb3djcnlwdC5jb20wggEiMA0GCSqG\\nSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDBYeT+zyJK4VrAtpBoxnzNrgPMkeJ3WBw3\\nlZrO7GXsPUUQL/2uL3NfMwQ4qWqsiJStShaTQ0UX1MQCBgdOY/Ajr5xgyCz4aE0+\\nQeReGy+qFyoGE9okVdF+/uJhFTOkK8goA4rDRN3MrSuWsivc/5/8Htd/M01JFAcU\\nEblrPkSBtJp8IAtr+QD8etmMd05N0oQFNFT/T7QNrEdItCKSS6jMpprR4phr792K\\niQh9MzhZ3O+QEM+UKpsL0dM9C6PD9jNFjFz3EDch/VFPbBlcBfWGvYnjBlqKjhYA\\nLPUVPgIF4CVQ60EoOHk1ewyoAyydYyFXppUz1eDvemUhLMWuBJ2tAgMBAAGjggJ1\\nMIICcTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUF\\nBwMCMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFMr4ERxBRtKNI67oIkJHN2QSBptE\\nMB8GA1UdIwQYMBaAFKhKamMEfd265tE5t6ZFZe/zqOyhMG8GCCsGAQUFBwEBBGMw\\nYTAuBggrBgEFBQcwAYYiaHR0cDovL29jc3AuaW50LXgzLmxldHNlbmNyeXB0Lm9y\\nZzAvBggrBgEFBQcwAoYjaHR0cDovL2NlcnQuaW50LXgzLmxldHNlbmNyeXB0Lm9y\\nZy8wKQYDVR0RBCIwIIIPKi5mbG93Y3J5cHQuY29tgg1mbG93Y3J5cHQuY29tMEwG\\nA1UdIARFMEMwCAYGZ4EMAQIBMDcGCysGAQQBgt8TAQEBMCgwJgYIKwYBBQUHAgEW\\nGmh0dHA6Ly9jcHMubGV0c2VuY3J5cHQub3JnMIIBBgYKKwYBBAHWeQIEAgSB9wSB\\n9ADyAHcAb1N2rDHwMRnYmQCkURX/dxUcEdkCwQApBo2yCJo32RMAAAFw2e8sLwAA\\nBAMASDBGAiEA7Omcf4+uFphcbEq19r4GoWi7E1qvsJTykvgH342x1d4CIQDSCJZK\\n3zsVSw8I1GVfnIr/drVhgn4TJgacXx6+gBzfXQB3ALIeBcyLos2KIE6HZvkruYol\\nIGdr2vpw57JJUy3vi5BeAAABcNnvK/kAAAQDAEgwRgIhAP7BbIkG/mNclZAVqgA0\\nomAB/6xMwbu1ZUsHNBMkZG+QAiEAmZWCVdUfmFs3b+zDEaAF7eFDnz7qbDa5q6M0\\n98r8In0wDQYJKoZIhvcNAQELBQADggEBAFaUhUkxGkHc3lxozCbozM7ffAOcK5De\\nJGoTtsXw/XmMACBIIqn2Aan+zvQdK/cWV9+dYu5tA/PHZwVbfKAU2x+Fizs7uDgs\\nslg16un1/DP7bmi4Ih3KDVyznzgTwWPq9CmPMIeCXBSGvGN4xdfyIf7mKPSmsEB3\\ngkM8HyE27e2u8B4f/R4W+sbqx0h5Y/Kv6NFqgQlatEY2HdAQDYYL21xO1ZjaUozP\\nyfHQSJwGHp3/1Xdq5mIkV7w9xxhOn64FXp4S0spVCxT3er1EEUurq+lXjyeX4Dog\\n1gy3r417NPqQWuBJcA/InSaS/GUyGghp+kuGfIDqVYfQqU1297nThEA=\\n-----END CERTIFICATE-----\\n';\n      const addPubkeyDialog = await pastePublicKeyManuallyNoClose(composeFrame, inboxPage, 'smime@recipient.com', httpsCert);\n      await addPubkeyDialog.waitAndRespondToModal('error', 'confirm', 'This S/MIME x.509 certificate has an invalid recipient email: flowcrypt.com');\n    }));\n\n    ava.default('cannot import expired key in secure compose', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extensionInbox('ci.tests.gmail@flowcrypt.test'));\n      const to = 'nopgp@recipient.com';\n      const composeFrame = await InboxPageRecipe.openAndGetComposeFrame(inboxPage);\n      await ComposePageRecipe.fillMsg(composeFrame, { to }, t.title);\n      const expiredPubkey = '-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: FlowCrypt Email Encryption 7.8.4\\r\\nComment: Seamlessly send and receive encrypted email\\r\\n\\r\\nxsBNBF8QJFgBCACdPi2i6uflsgNVvSw20eVaqOwEgwRAu1wrwB+s3UxFxsnE\\r\\nXBiJ6tvQU+NzNFLWjT5FwyTz8PM2lDnXz/j6nQGft+l/01l349u0L4WhTEES\\r\\nByPTOA1Wbs4YRbef1+T6tKklN8CKH93tBKRFTZXsMv0nLuEMmyxNgYHvNsnB\\r\\nGXlGQrrsJ5qVr10YZh+dXo8Ir4mXXE5tCrVH/AzDBK/cBZcUbBD7gmvnt+HF\\r\\nvuJYMRQ46/NR84S57Dwm5ZzER0PMQfnLYyjdKE4DEVtL84WVhGVqNhBqy1Z6\\r\\nl/wvSHnBvrXe1Vdm2YXT0pIahe9wJmrA2dixA8c+SczICn+QZAkBsAZRABEB\\r\\nAAHNKTxoYXMub2xkZXIua2V5Lm9uLmF0dGVzdGVyQHJlY2lwaWVudC5jb20+\\r\\nwsCTBBABCAAmBQJfECRYBQkAAAACBgsJBwgDAgQVCAoCBBYCAQACGQECGwMC\\r\\nHgEAIQkQHmLtbRWiWSEWIQSOx48EPOsCJJiv1HceYu1tFaJZIQewCACYWDJ5\\r\\n3sbGDvIwRlPiAQqTp4IvjrvLC+unX4OVyaqXPcTbCWkjjUcZci2aO5V59J+I\\r\\nfHkI7PVwheuEk4HjNBiPvSOy8BbwiGXYxkQX4Z4QZkcf6wCvd3rtwyICzhNh\\r\\njsehA4uaYStr0k0pxzHMWhpDeppzVL+yVnCoftiW9+9MuTFQ2ynQhBYp57yA\\r\\n6LGn9X91L7ACZvWMstBwTNkT2N2Vw7ngCnacweIj0LMje2wt6cKO1IMm0U4Q\\r\\nEkag9pqTf1DnyC/dkw7GB6kT5lP9wAdZNxtIgJwHQNidH+0gfJlTQ31LQp5T\\r\\njFa6LU+7XK8sprZG27TjQX9w7NVyYbkib3mGzsBNBF8QJFgBCACnVXFdNoKA\\r\\nTHN6W7ewu8CDaDEOxrUGckrTFSOLN0hkLrlrHRZg4/N0gZf/TdUynGJ6fkXq\\r\\n5ZDZWiPujAyjeTHhoUb3Oc0O9voX3TLRROduDxW6UAeurzXAiL/25qOp1TRr\\r\\nFhvllleg+fcZDNjPct4zyUxUW6NzWkHJ+XvNxq2fTH82n0RfPTyRoee/ymuR\\r\\nexRU4vfYF8XNo+aEDx00rwQFpl8ot20Qus6vKejo0SIyr0bS4oHBB3sYHrxt\\r\\nkfHLwiSfE27eW2pogta6JcH7w+OLGadoGxqGs1cYpbVhteDRUQ4nTov3JWt5\\r\\nVoNlXiaBdV3vRF52Q+UuUwylsbcplDeDABEBAAHCwHwEGAEIAA8FAl8QJFgF\\r\\nCQAAAAICGwwAIQkQHmLtbRWiWSEWIQSOx48EPOsCJJiv1HceYu1tFaJZIcYi\\r\\nB/wNq0UOV3d1aaFtx2ie2CYX5f7o9/emyN7HomW53DBXSAlj98R0MnKrUadU\\r\\noIXkUnJlGIyU9NjzWWZsdPMrlaU/tCvceO/wvc2K/pqjiQKjtfiA/mR+0dGf\\r\\ncVskq2WOiAfEuOcTAdrYmLeTs5r6RJueTb3qxUN7a9OWru+avuyJ7lDiOiNC\\r\\nMnhQ8xZy1zREApD1weSz9JEUOTkcNYFm/dm08g0QfKneqi5/ZvNmRlKNW/Nf\\r\\n9DCM/jCp1Nb33yNTC9n3HW8qMOd4pPfajDEtGivqi5aQGaZ+AbT6RTR4jD8q\\r\\n7GiOeV7wDbZXG0MYLM9kqW7znnDTAGHWvTw+HanlU23+\\r\\n=KVqr\\r\\n-----END PGP PUBLIC KEY BLOCK-----\\r\\n';\n      const addPubkeyDialog = await pastePublicKeyManuallyNoClose(composeFrame, inboxPage, to, expiredPubkey);\n      await addPubkeyDialog.waitAndRespondToModal('warning', 'confirm', 'This public key is correctly formatted, but it cannot be used for encryption because it expired on 2020-07-16 09:56.');\n    }));\n\n    ava.default('auto-refresh expired key if newer version of the same key available', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const expiredPublicKey = '-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: FlowCrypt Email Encryption 7.8.4\\r\\nComment: Seamlessly send and receive encrypted email\\r\\n\\r\\nxsBNBF8PcdUBCADi8no6T4Bd9Ny5COpbheBuPWEyDOedT2EVeaPrfutB1D8i\\r\\nCP6Rf1cUvs/qNUX/O7HQHFpgFuW2uOY4OU5cvcrwmNpOxT3pPt2cavxJMdJo\\r\\nfwEvloY3OfY7MCqdAj5VUcFGMhubfV810V2n5pf2FFUNTirksT6muhviMymy\\r\\nuWZLdh0F4WxrXEon7k3y2dZ3mI4xsG+Djttb6hj3gNr8/zNQQnTmVjB0mmpO\\r\\nFcGUQLTTTYMngvVMkz8/sh38trqkVGuf/M81gkbr1egnfKfGz/4NT3qQLjin\\r\\nnA8In2cSFS/MipIV14gTfHQAICFIMsWuW/xkaXUqygvAnyFa2nAQdgELABEB\\r\\nAAHNKDxhdXRvLnJlZnJlc2guZXhwaXJlZC5rZXlAcmVjaXBpZW50LmNvbT7C\\r\\nwJMEEAEIACYFAl8PcdUFCQAAAAEGCwkHCAMCBBUICgIEFgIBAAIZAQIbAwIe\\r\\nAQAhCRC+46QtmpyKyRYhBG0+CYZ1RO5ify6Sj77jpC2anIrJIvQIALG8TGMN\\r\\nYB4CRouMJawNCLui6Fx4Ba1ipPTaqlJPybLoe6z/WVZwAA9CmbjkCIk683pp\\r\\nmGQ3GXv7f8Sdk7DqhEhfZ7JtAK/Uw2VZqqIryNrrB0WV3EUHsENCOlq0YJod\\r\\nLqtkqgl83lCNDIkeoQwq4IyrgC8wsPgF7YMpxxQLONJvChZxSdCDjnfX3kvO\\r\\nZsLYFiKnNlX6wyrKAQxWnxxYhglMf0GDDyh0AJ+vOQHJ9m+oeBnA1tJ5AZU5\\r\\naQHvRtyWBKkYaEhljhyWr3eu1JjK4mn7/W6Rszveso33987wtIoQ66GpGcX2\\r\\nmh7y217y/uXz4D3X5PUEBXIbhvAPty71bnTOwE0EXw9x1QEIALdJgAsQ0Jnv\\r\\nLXwAKoOammWlUQmracK89v1Yc4mFnImtHDHS3pGsbx3DbNGuiz5BhXCdoPDf\\r\\ngMxlGmJgShy9JAhrhWFXkvsjW/7aO4bM1wU486VPKXb7Av/dcrfHH0ASj4zj\\r\\n/TYAeubNoxQtxHgyb13LVCW1kh4Oe6s0ac/hKtxogwEvNFY3x+4yfloHH0Ik\\r\\n9sbLGk0gS03bPABDHMpYk346406f5TuP6UDzb9M90i2cFxbq26svyBzBZ0vY\\r\\nzfMRuNsm6an0+B/wS6NLYBqsRyxwwCTdrhYS512yBzCHDYJJX0o3OJNe85/0\\r\\nTqEBO1prgkh3QMfw13/Oxq8PuMsyJpUAEQEAAcLAfAQYAQgADwUCXw9x1QUJ\\r\\nAAAAAQIbDAAhCRC+46QtmpyKyRYhBG0+CYZ1RO5ify6Sj77jpC2anIrJARgH\\r\\n/1KV7JBOS2ZEtO95FrLYnIqI45rRpvT1XArpBPrYLuHtDBwgMcmpiMhhKIZC\\r\\nFlZkR1W88ENdSkr8Nx81nW+f9JWRR6HuSyom7kOfS2Gdbfwo3bgp48DWr7K8\\r\\nKV/HHGuqLqd8UfPyDpsBGNx0w7tRo+8vqUbhskquLAIahYCbhEIE8zgy0fBV\\r\\nhXKFe1FjuFUoW29iEm0tZWX0k2PT5r1owEgDe0g/X1AXgSQyfPRFVDwE3QNJ\\r\\n1np/Rmygq1C+DIW2cohJOc7tO4gbl11XolsfQ+FU+HewYXy8aAEbrTSRfsff\\r\\nMvK6tgT9BZ3kzjOxT5ou2SdvTa0eUk8k+zv8OnJJfXA=\\r\\n=LPeQ\\r\\n-----END PGP PUBLIC KEY BLOCK-----\\r\\n';\n      const recipientEmail = 'auto.refresh.expired.key@recipient.com';\n      // add an expired key manually\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('ci.tests.gmail@flowcrypt.test'));\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      const contactsFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-contacts-page', ['contacts.htm', 'placement=settings']);\n      await contactsFrame.waitAll('@page-contacts');\n      await contactsFrame.waitAndClick('@action-show-import-public-keys-form', { confirmGone: true });\n      await contactsFrame.waitAndType('@input-bulk-public-keys', expiredPublicKey);\n      await contactsFrame.waitAndClick('@action-show-parsed-public-keys', { confirmGone: true });\n      await contactsFrame.waitAll('iframe');\n      const pubkeyFrame = await contactsFrame.getFrame(['pgp_pubkey.htm']);\n      await pubkeyFrame.waitForContent('@action-add-contact', 'IMPORT EXPIRED KEY');\n      await pubkeyFrame.waitAndClick('@action-add-contact');\n      await pubkeyFrame.waitForContent('@container-pgp-pubkey', `${recipientEmail} added`);\n      await contactsFrame.waitAndClick('@action-back-to-contact-list', { confirmGone: true });\n      await contactsFrame.waitAndClick(`@action-show-pubkey-${recipientEmail.replace(/[^a-z0-9]+/g, '')}`, { confirmGone: true });\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Type: openpgp');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Fingerprint: 6D3E 0986 7544 EE62 7F2E 928F BEE3 A42D 9A9C 8AC9');\n      await contactsFrame.waitForContent('@container-pubkey-details', `Users: ${recipientEmail}`);\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Created on: Wed Jul 15 2020 21:15:01');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Expiration: Wed Jul 15 2020 21:15:02');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Expired: yes');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Usable for encryption: false');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Usable for signing: false');\n      // now we want to see that compose page auto-fetches an updated one\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: recipientEmail }, t.title);\n      const expandContainer = await composePage.waitAny('@action-show-container-cc-bcc-buttons');\n      const recipient = await expandContainer.$('.email_preview span');\n      expect(await PageRecipe.getElementPropertyJson(recipient!, 'className')).to.not.include('expired'); // because auto-reloaded\n      await ComposePageRecipe.sendAndClose(composePage);\n      // make sure that the contact itself got updated\n      await contactsFrame.waitAndClick('@action-back-to-contact-list', { confirmGone: true });\n      await contactsFrame.waitAndClick(`@action-show-pubkey-${recipientEmail.replace(/[^a-z0-9]+/g, '')}`, { confirmGone: true });\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Expired: no');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Usable for encryption: true');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Expiration: Does not expire');\n    }));\n\n    ava.default('expired key will turn green when manually updated in different window', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      const recipientEmail = 'expired.on.attester@domain.com';\n      await ComposePageRecipe.fillMsg(composePage, { to: recipientEmail }, t.title);\n      await composePage.waitForContent('.email_address.expired', recipientEmail);\n      // now open a pubkey frame and update the pubkey\n      const pubkeyFrameUrl = `chrome/elements/pgp_pubkey.htm?frameId=none&armoredPubkey=${encodeURIComponent(somePubkey)}&acctEmail=flowcrypt.compatibility%40gmail.com&parentTabId=0`;\n      const pubkeyFrame = await browser.newPage(t, pubkeyFrameUrl);\n      await pubkeyFrame.waitAndType('.input_email', recipientEmail);\n      await pubkeyFrame.waitForContent('@action-add-contact', 'UPDATE KEY');\n      await pubkeyFrame.waitAndClick('@action-add-contact');\n      await pubkeyFrame.waitForContent('@container-pgp-pubkey', `${recipientEmail} added`);\n      await Util.sleep(1);\n      await pubkeyFrame.close();\n      await composePage.waitForContent('.email_address.has_pgp:not(.expired)', recipientEmail);\n    }));\n\n    ava.default('do not auto-refresh key if older version of the same key available on attester', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const newerExpiredKey = '-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: FlowCrypt Email Encryption 7.8.4\\r\\nComment: Seamlessly send and receive encrypted email\\r\\n\\r\\nxsBNBF8QJFgBCACdPi2i6uflsgNVvSw20eVaqOwEgwRAu1wrwB+s3UxFxsnE\\r\\nXBiJ6tvQU+NzNFLWjT5FwyTz8PM2lDnXz/j6nQGft+l/01l349u0L4WhTEES\\r\\nByPTOA1Wbs4YRbef1+T6tKklN8CKH93tBKRFTZXsMv0nLuEMmyxNgYHvNsnB\\r\\nGXlGQrrsJ5qVr10YZh+dXo8Ir4mXXE5tCrVH/AzDBK/cBZcUbBD7gmvnt+HF\\r\\nvuJYMRQ46/NR84S57Dwm5ZzER0PMQfnLYyjdKE4DEVtL84WVhGVqNhBqy1Z6\\r\\nl/wvSHnBvrXe1Vdm2YXT0pIahe9wJmrA2dixA8c+SczICn+QZAkBsAZRABEB\\r\\nAAHNKTxoYXMub2xkZXIua2V5Lm9uLmF0dGVzdGVyQHJlY2lwaWVudC5jb20+\\r\\nwsCTBBABCAAmBQJfECR2BQkAAAA8BgsJBwgDAgQVCAoCBBYCAQACGQECGwMC\\r\\nHgEAIQkQHmLtbRWiWSEWIQSOx48EPOsCJJiv1HceYu1tFaJZIZ4CB/4hCFJw\\r\\nustsTLQNCBJMAoBtjGPDohnsaMImmDPw8P1TyIidDlgnKqpzBhF29X0LiJIf\\r\\n5EUDiWMb3O5j+jXOR7kF1UJkj64eW5/GOuN+O15CIRLRWCEJ3mv3H9b/Bzgt\\r\\njzWg1qf4c8GIaU+R4nJKbrvoX8GT2mnntLnTCDxZvSb9vfgBNXLleeI33xvX\\r\\nEHtOnb1zYb9SH6YKWRKAYD7zihPdIDnbbgUMTAahHGjZqPm0R/MoBK0ra1QY\\r\\njJA9SZIWInTjDQimfbsMbFXwyufVwBYoEn6qZuRFBts/8/gd83l51fu+JfO8\\r\\nG90LSQQUGJXwsAa/CaDUI6WlN1Xyv3+D+avUzsBNBF8QJFgBCACnVXFdNoKA\\r\\nTHN6W7ewu8CDaDEOxrUGckrTFSOLN0hkLrlrHRZg4/N0gZf/TdUynGJ6fkXq\\r\\n5ZDZWiPujAyjeTHhoUb3Oc0O9voX3TLRROduDxW6UAeurzXAiL/25qOp1TRr\\r\\nFhvllleg+fcZDNjPct4zyUxUW6NzWkHJ+XvNxq2fTH82n0RfPTyRoee/ymuR\\r\\nexRU4vfYF8XNo+aEDx00rwQFpl8ot20Qus6vKejo0SIyr0bS4oHBB3sYHrxt\\r\\nkfHLwiSfE27eW2pogta6JcH7w+OLGadoGxqGs1cYpbVhteDRUQ4nTov3JWt5\\r\\nVoNlXiaBdV3vRF52Q+UuUwylsbcplDeDABEBAAHCwHwEGAEIAA8FAl8QJHYF\\r\\nCQAAADwCGwwAIQkQHmLtbRWiWSEWIQSOx48EPOsCJJiv1HceYu1tFaJZIQ2b\\r\\nCACYF7lF3mnvgduu0l5USNRsu7ZkkgK0qKvUaoyPvD80bg/kze7XP+Eg3Bad\\r\\n6kakLW/jZhQO5S4qDPLhjLLhsbdXWBcoKctfLAYLfBE5mQfC7sU5ufQ615JM\\r\\njcomkXMxStmcTzulV49H9U0AfKOuO9TYKYudm+iMXz3b5aVY4Db4SBChr+t8\\r\\nFhsuaDOcy4mCstA4HJjhVDWuGoUSwxbxUOyYb8YioxHi+CgRWnuf/chGEPHv\\r\\nmp+d37nWzm561RPm8+YfLI+Ps/OcsYogXm/RZNirn08XSaCuRBwwIiDasHTi\\r\\nlTjK+SO789oXkNajtP6A8FbrkF6HlNBgpaYB10Y4qfW5\\r\\n=aZpf\\r\\n-----END PGP PUBLIC KEY BLOCK-----\\r\\n';\n      const recipientEmail = 'has.older.key.on.attester@recipient.com';\n      // add a newer expired key manually\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('ci.tests.gmail@flowcrypt.test'));\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      const contactsFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-contacts-page', ['contacts.htm', 'placement=settings']);\n      await contactsFrame.waitAll('@page-contacts');\n      await contactsFrame.waitAndClick('@action-show-import-public-keys-form', { confirmGone: true });\n      await contactsFrame.waitAndType('@input-bulk-public-keys', newerExpiredKey);\n      await contactsFrame.waitAndClick('@action-show-parsed-public-keys', { confirmGone: true });\n      await contactsFrame.waitAll('iframe');\n      const pubkeyFrame = await contactsFrame.getFrame(['pgp_pubkey.htm']);\n      await pubkeyFrame.waitForContent('@action-add-contact', 'IMPORT EXPIRED KEY');\n      await pubkeyFrame.waitAndClick('@action-add-contact');\n      await pubkeyFrame.waitForContent('@container-pgp-pubkey', `${recipientEmail} added`);\n      await contactsFrame.waitAndClick('@action-back-to-contact-list', { confirmGone: true });\n      await contactsFrame.waitAndClick(`@action-show-pubkey-${recipientEmail.replace(/[^a-z0-9]+/g, '')}`, { confirmGone: true });\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Type: openpgp');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Fingerprint: 8EC7 8F04 3CEB 0224 98AF D477 1E62 ED6D 15A2 5921');\n      await contactsFrame.waitForContent('@container-pubkey-details', `Users: ${recipientEmail}`);\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Created on: Thu Jul 16 2020 09:56:40');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Expiration: Thu Jul 16 2020 09:57:40');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Last signature: Thu Jul 16 2020 09:57:10');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Expired: yes');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Usable for encryption: false');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Usable for signing: false');\n      // now we want to see that compose page auto-fetches an updated one\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compose');\n      await ComposePageRecipe.fillMsg(composePage, { to: recipientEmail }, t.title);\n      const expandContainer = await composePage.waitAny('@action-show-container-cc-bcc-buttons');\n      const recipient = await expandContainer.$('.email_preview span');\n      expect(await PageRecipe.getElementPropertyJson(recipient!, 'className')).to.include('expired');\n      await composePage.close();\n      // make sure that the contact itself did NOT get updated, because the one on Attester is an older key\n      await contactsFrame.waitAndClick('@action-back-to-contact-list', { confirmGone: true });\n      await contactsFrame.waitAndClick(`@action-show-pubkey-${recipientEmail.replace(/[^a-z0-9]+/g, '')}`, { confirmGone: true });\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Fingerprint: 8EC7 8F04 3CEB 0224 98AF D477 1E62 ED6D 15A2 5921');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Created on: Thu Jul 16 2020 09:56:40');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Expiration: Thu Jul 16 2020 09:57:40');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Expired: yes');\n    }));\n\n    ava.default('import S/MIME cert', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      // the cert since expired, therefore test was updated to reflect that\n      const recipientEmail = 'actalis@meta.33mail.com';\n      // add S/MIME key manually\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('ci.tests.gmail@flowcrypt.test'));\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      const contactsFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-contacts-page', ['contacts.htm', 'placement=settings']);\n      await contactsFrame.waitAll('@page-contacts');\n      await contactsFrame.waitAndClick('@action-show-import-public-keys-form', { confirmGone: true });\n      await contactsFrame.waitAndType('@input-bulk-public-keys', testConstants.smimeCert);\n      await contactsFrame.waitAndClick('@action-show-parsed-public-keys', { confirmGone: true });\n      await contactsFrame.waitAll('iframe');\n      const pubkeyFrame = await contactsFrame.getFrame(['pgp_pubkey.htm']);\n      await pubkeyFrame.waitForContent('@action-add-contact', 'IMPORT EXPIRED KEY');\n      await pubkeyFrame.waitAndClick('@action-add-contact');\n      await pubkeyFrame.waitForContent('@container-pgp-pubkey', `${recipientEmail} added`);\n      await contactsFrame.waitAndClick('@action-back-to-contact-list', { confirmGone: true });\n      await contactsFrame.waitAndClick(`@action-show-pubkey-${recipientEmail.replace(/[^a-z0-9]+/g, '')}`, { confirmGone: true });\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Type: x509');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Fingerprint: 16BB 4074 03A3 ADC5 5E1E 0E4A F93E EC8F B187 C923');\n      await contactsFrame.waitForContent('@container-pubkey-details', `Users: ${recipientEmail}`);\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Created on: Mon Mar 23 2020');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Expiration: Tue Mar 23 2021');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Expired: yes');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Usable for encryption: true');\n      await contactsFrame.waitForContent('@container-pubkey-details', 'Usable for signing: true');\n    }));\n\n    ava.default('compose - reply - CC&BCC test forward', testWithBrowser('compatibility', async (t, browser) => {\n      const appendUrl = 'threadId=16ce2c965c75e5a6&skipClickPrompt=___cu_false___&ignoreDraft=___cu_false___&replyMsgId=16ce2c965c75e5a6';\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility', { appendUrl, hasReplyPrompt: true });\n      await composePage.waitAndClick('@action-forward', { delay: 2 });\n      await composePage.waitAny('@input-to');\n      await composePage.waitUntilFocused('@input-to');\n      await expectRecipientElements(composePage, { to: [], cc: [], bcc: [] });\n    }));\n\n  }\n\n};\n\nconst pastePublicKeyManuallyNoClose = async (composeFrame: ControllableFrame, inboxPage: ControllablePage, recipient: string, pub: string) => {\n  await Util.sleep(1); // todo: should wait until recipient actually loaded\n  await composeFrame.waitForContent('.email_address.no_pgp', recipient);\n  await composeFrame.waitAndClick('@action-open-add-pubkey-dialog', { delay: 1 });\n  await inboxPage.waitAll('@dialog-add-pubkey');\n  const addPubkeyDialog = await inboxPage.getFrame(['add_pubkey.htm']);\n  await addPubkeyDialog.waitAndType('@input-pubkey', pub);\n  await Util.sleep(1);\n  await addPubkeyDialog.waitAndClick('@action-add-pubkey');\n  return addPubkeyDialog;\n};\n\nconst pastePublicKeyManually = async (composeFrame: ControllableFrame, inboxPage: ControllablePage, recipient: string, pub: string) => {\n  await pastePublicKeyManuallyNoClose(composeFrame, inboxPage, recipient, pub);\n  await inboxPage.waitTillGone('@dialog-add-pubkey');\n};\n\nconst sendImgAndVerifyPresentInSentMsg = async (t: AvaContext, browser: BrowserHandle, sendingType: 'encrypt' | 'sign' | 'plain') => {\n  // send a message with image in it\n  const imgBase64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAnElEQVR42u3RAQ0AAAgDIE1u9FvDOahAVzLFGS1ECEKEIEQIQoQgRIgQIQgRghAhCBGCECEIQYgQhAhBiBCECEEIQoQgRAhChCBECEIQIgQhQhAiBCFCEIIQIQgRghAhCBGCEIQIQYgQhAhBiBCEIEQIQoQgRAhChCAEIUIQIgQhQhAiBCEIEYIQIQgRghAhCBEiRAhChCBECEK+W3uw+TnWoJc/AAAAAElFTkSuQmCC';\n  const sendingTypeForHumans = sendingType === 'encrypt' ? 'Encrypted' : (sendingType === 'sign' ? 'Signed' : 'Plain');\n  const subject = `Test Sending ${sendingTypeForHumans} Message With Image ${Util.lousyRandom()}`;\n  const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n  await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, subject, { richtext: true, sign: sendingType === 'sign', encrypt: sendingType === 'encrypt' });\n  // the following is a temporary hack - currently not able to directly paste an image with puppeteer\n  // instead we should find a way to load the image into clipboard, and paste it into textbox\n  await composePage.page.evaluate((src: string) => { $('[data-test=action-insert-image]').val(src).click(); }, imgBase64);\n  await ComposePageRecipe.sendAndClose(composePage);\n  // get sent msg id from mock\n  const sentMsg = (await GoogleData.withInitializedData('flowcrypt.compatibility@gmail.com')).getMessageBySubject(subject)!;\n  if (sendingType === 'plain') {\n    expect(sentMsg.payload?.body?.data).to.match(/<img src=\"cid:(.+)@flowcrypt\">This is an automated puppeteer test: Test Sending Plain Message With Image/);\n    return;\n    // todo - this test case is a stop-gap. We need to implement rendering of such messages below,\n    //   then let test plain messages with images in them (referenced by cid) just like other types of messages below\n  }\n  let url = `chrome/dev/ci_pgp_host_page.htm?frameId=none&msgId=${encodeURIComponent(sentMsg.id)}&senderEmail=flowcrypt.compatibility%40gmail.com&isOutgoing=___cu_false___&acctEmail=flowcrypt.compatibility%40gmail.com`;\n  if (sendingType === 'sign') {\n    url += '&signature=___cu_true___';\n  }\n  // open a page with the sent msg, investigate img\n  const pgpHostPage = await browser.newPage(t, url);\n  const pgpBlockPage = await pgpHostPage.getFrame(['pgp_block.htm']);\n  await pgpBlockPage.waitAll('.image_src_link');\n  expect(await pgpBlockPage.read('.image_src_link')).to.contain('show image');\n  await pgpBlockPage.waitAndClick('.image_src_link');\n  await pgpBlockPage.waitTillGone('.image_src_link');\n  const img = await pgpBlockPage.waitAny('body img');\n  expect(await PageRecipe.getElementPropertyJson(img, 'src')).to.eq(imgBase64);\n};\n\nconst sendTextAndVerifyPresentInSentMsg = async (t: AvaContext,\n  browser: BrowserHandle,\n  text: string,\n  sendingOpt: { encrypt?: boolean, sign?: boolean, richtext?: boolean } = {}\n) => {\n  const subject = `Test Sending ${sendingOpt.sign ? 'Signed' : ''} ${sendingOpt.encrypt ? 'Encrypted' : ''} Message With Test Text ${text} ${Util.lousyRandom()}`;\n  const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n  await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, subject, sendingOpt);\n  await composePage.waitAndType('@input-body', text, { delay: 1 });\n  expect(await composePage.read('@input-body')).to.include(text);\n  await ComposePageRecipe.sendAndClose(composePage);\n  // get sent msg from mock\n  const sentMsg = (await GoogleData.withInitializedData('flowcrypt.compatibility@gmail.com')).getMessageBySubject(subject)!;\n  const message = encodeURIComponent(sentMsg.payload!.body!.data!);\n  await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n    content: [text],\n    unexpectedContent: [],\n    params: `?frameId=none&msgId=${encodeURIComponent(sentMsg.id)}&senderEmail=flowcrypt.compatibility%40gmail.com&isOutgoing=___cu_false___&acctEmail=flowcrypt.compatibility%40gmail.com&message=${message}`\n  });\n};\n\nconst setRequirePassPhraseAndOpenRepliedMessage = async (t: AvaContext, browser: BrowserHandle, passpharase: string) => {\n  const settingsPage = await browser.newPage(t, TestUrls.extensionSettings());\n  await SettingsPageRecipe.forgetAllPassPhrasesInStorage(settingsPage, passpharase);\n  // Open Message Page\n  const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=flowcrypt.compatibility@gmail.com&threadId=16b584ed95837510`));\n  await inboxPage.waitAll('iframe');\n  // Get Reply Window (Composer) and click on reply button.\n  const replyFrame = await inboxPage.getFrame(['compose.htm']);\n  await replyFrame.waitAndClick('@encrypted-reply');\n\n  return { inboxPage, replyFrame };\n};\n\nconst clickTripleDotAndExpectQuoteToLoad = async (composePage: Controllable, textToInclude: string) => {\n  await composePage.waitAll(['@action-expand-quoted-text']);\n  await Util.sleep(2); // wait for quote to be loaded and button activated\n  expect(await composePage.read('@input-body')).to.not.include(textToInclude);\n  await composePage.waitAndClick('@action-expand-quoted-text');\n  await composePage.waitTillGone(['@action-expand-quoted-text']);\n  expect(await composePage.read('@input-body')).to.include(textToInclude);\n};\n\nexport const expectRecipientElements = async (controllable: ControllablePage, expected: { to?: string[], cc?: string[], bcc?: string[] }) => {\n  for (const type of ['to', 'cc', 'bcc']) {\n    const expectedEmails: string[] | undefined = (expected as Dict<string[]>)[type] || undefined; // tslint:disable-line:no-unsafe-any\n    if (expectedEmails) {\n      const container = await controllable.waitAny(`@container-${type}`, { visible: false });\n      const recipientElements = await container.$$('.recipients > span');\n      expect(recipientElements.length).to.equal(expectedEmails.length);\n      for (const recipientElement of recipientElements) {\n        const textContent = await PageRecipe.getElementPropertyJson(recipientElement, 'textContent');\n        expect(expectedEmails).to.include(textContent.trim());\n      }\n    }\n  }\n};\n\nconst expectContactsResultEqual = async (composePage: ControllablePage | ControllableFrame, emails: string[]) => {\n  await composePage.waitAny('@container-contacts');\n  await Util.sleep(0.5);\n  await composePage.waitTillGone('@container-contacts-loading');\n  await Util.sleep(0.5);\n  const contacts = await composePage.waitAny('@container-contacts');\n  const contactsList = await contacts.$$('li');\n  for (const index in contactsList) { // tslint:disable-line:forin\n    expect(await PageRecipe.getElementPropertyJson(contactsList[index], 'textContent')).to.equal(emails[index]);\n  }\n};\n",
    "test/source/tests/decrypt.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as ava from 'ava';\n\nimport { Config, TestVariant, Util } from './../util';\nimport { testConstants } from './tooling/consts';\nimport { BrowserRecipe } from './tooling/browser-recipe';\nimport { InboxPageRecipe } from './page-recipe/inbox-page-recipe';\nimport { SettingsPageRecipe } from './page-recipe/settings-page-recipe';\nimport { TestUrls } from './../browser/test-urls';\nimport { TestWithBrowser } from './../test';\nimport { expect } from \"chai\";\n\n// tslint:disable:no-blank-lines-func\n// tslint:disable:max-line-length\n/* eslint-disable max-len */\n\nexport const defineDecryptTests = (testVariant: TestVariant, testWithBrowser: TestWithBrowser) => {\n\n  if (testVariant !== 'CONSUMER-LIVE-GMAIL') {\n\n    ava.default(`decrypt - without a subject`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"This is a compatibility test email\"],\n        unexpectedContent: [\"Encrypted Subject:\", \"(no subject)\"],\n        params: \"?frameId=none&message=-----BEGIN%20PGP%20MESSAGE-----%0A%0AhQEMA%2Ba5zJlucROnAQf%2BJc3kkQPIko5gnq0bN510e16pk%2FBNq3w00BWZZmqe8QZ3%0A2CDi1i8mJCTf0ax9zCjJmNEoK4sonX88ZtQ3nDX819ATeu8gi6cWTaaTrdtfI5wF%0AGoD3IgRiwOGJf3NAUSa8YB77%2Fpx6AL35je44uXHvstmmWrt4LMQBQaRUGHG51vxf%0AQKNx9hBHLOv83wGjjKoDOByb0Lf2sGIlECgeOHGfowKG3fH4NNO0kWbaLcVvM9Dh%0AgWjQQWWAWhZCuFmpYdIktYzC4CN7JaTRdGbyuK2syrsiWyc1tty%2FlV1XM06dwYO8%0A7xgdXTDbmVwujEtQJW1bJuOoI8DiuRbYfEgGSGADmIUCDANLWi%2F85i2VAQEP%2F1qR%0AiYLG5IMS60KJf89GK13PNeo1QzbNNYrNjxWyiEZOy7n0qZ1X7JWfGrRSx2Wqtesh%0AvzY5Dt%2FWQWVES%2F4sl54GO8Pjlhi6YjIn3wFyZryftOF4eXjoQ7dbbpoOsHhOizcD%0Ap3l4zXPRng8hC4gF%2FZ6XxCsFRHLXgDRsJKu5bZ8VEJvK2m1soG%2BCDl9s%2FDifjf%2FU%0AJVc3DWh7lQPGy%2B8TxkvHtvaD1ZbNSjOIfdmsybBS3Hk%2BSoaLb3MI%2Bv2clHMYnSKs%0A1Z2zEn21SBxrLd%2BYKWD5mBE9UZGyarANvvbMkiPGVkHzzUrfu6NjF9sVKoNLDJmu%0Aegjr6RWNv2CrHr%2BREQWRaQ4004Xfu2WRZkcZH7DLaOvIMlvi8mHNW1EplL2SrvF9%0AoH7YMev0j2x0BLEkrOWtFfRG7NpgMU%2FO1bDz3DD7uDHIgi32KJ%2BUhSYXqiMOlIPK%0A8wB39mCqgY1vD5bkw7l%2FVHX%2BfwU7QTAK2Lg7%2BUGD29VmJhso46Mpz1pbL0HZiuCY%0A9JRr1Cxi%2FXwKWXgng8ijIUhQ8%2FsDdUxuRIx%2FxgLCn%2BNy69MrjZnXE2T0W5%2BgBpuX%0Ac7KUdJwCUEkdiB%2FWlz4izdPUCBUnc0QAqCt7Ixx4S4Hn%2BU1lNfrECqJI14kbf27r%0ALmLiZqEB5WJHLBtUkegyFWr6WwHmqQFxtuu2Tg%2Fz0ukBkZDzODNz0eVQANEb%2FkWn%0AxaaH%2FDhvkx%2BDxKeyhi6LDfAtU7oOOo8C3%2BiTFzk%2BSsr2Tl6Mb6fuSSxxVc%2Fi1YZb%0AEOWEuw%2BTLGhH3nzWG1reM7N0q7lNVy5mz3V9cXRcvRUj7wYBhxf4LyBRtCq3lOUl%0AhfHf7U3zk6ZpIUCq146CbWVAy83jnKbJwzmlOCWoy1rVfbRg6%2BemShml3ugOCjfp%0AJVViuW33ZUEGYIeDHa8CihGn3ai0aN4CHQiuDe%2FA9tljFseYi%2BIdfVhIz10VRPBO%0AbRTW%2FnFDkVjI9E3Bd%2BH5%2Byj4LEbGFYfcSHMjgoMjS578p5dmbl%2FVeNt%2FwS9dxPF8%0A8iRV2tcSu5HbLhWGZJ1l%2Bcn6N1PwW6Rs9NrdfsMD7QNsyDU71hOz10asOgebxYNM%0AgFhhw%2FlxHig9iuNwO8GE0HBDmRv%2BHKxLXue0pHPWt9Ut%2FmY4r%2F%2BruXloxRsU8gjG%0AhzSamV5IdvfQy0xCog2bWDCL4rCngh1IkrFi0CtNNl1mPskhoZqMZjso290yNaUc%0AHeFIdyPyvjjxyoHd9K3BuXx6fPvYbZzFRz9YikMqHxz6AyHAiMJnl8OPFH6XOTki%0AO1liU9LI%2BMsLCmeDqGliNap9VMvpBkJK6lWoC0RDtqHM48sI4BqHBgW6nUwnGv5H%0AtKbDTgFfMZw5c%2BklOWIUHME4eFNyRej69uoofFyb2rNjXBqvKlL2g0dUXbm2nmYG%0AUW4JPHWria6djv6zg0h037c%2FP6%2BDhVdm2O8in8b%2BBgqsdr7ChYPp2jUX8rouFNwd%0AU4xAXYo7iLoDN7AXHUb%2BG19qrx3c%2FXBrb5msVllfjDfKspX9ftTBukl1%2FJv2QdE0%0AG0kEVzAVB3amt9KHNX%2BfMC28rBla60gfxmpEJ9Q7fZCAOqTJPPcS1D9AKVm3wpoh%0ANWNJXYstblVGNBGuYeJuvHyjcGfs23RPgy1PI%2FAqJJcumUCcGb8Aa4BufsyZLw4L%0ACkN6yaCuw5DdmeNklkm%2FNVDJJJpvkLYrTRr6V5VIeO1usvmTYwAg5301DjG%2FI6qP%0AVRJQ7GeUXB9G6r6g15KbNfIALz0SUt6wKrFn6H39aVlBXzFO5Y6EmmD%2BYapfJH0o%0AhOHiIbWHXqU9rPToLC2Pn9WDq9FIUMx%2B0wL0En172e2%2BUOfEoPrcoykVFXemGCVp%0AIbB9HsIUVrsYyqvs7HLQfMdR%2FSjw%2BsFilKzIIBFjgNWHiyOwshVMkHCUHohcw6mJ%0A3cx01xWgJaG42ggGSYvkb4BvZEfgKmslwIV79pbwQxuayKNNqCpPwHuqA1fdlZ2E%0AhR8Dn%2BShq2eP5lStlK0V%2BGYT9fBcfuqApdUKNmJA1Pks%2Bj9h0CzseWYA%0A%3DHRui%0A-----END%20PGP%20MESSAGE-----&msgId=1600f39127880eed&senderEmail=paul.ilardi%40stresearch.com&isOutgoing=___cu_false___&acctEmail=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [enigmail] encrypted iso-2022-jp pgp/mime`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"ゾし逸現飲\"],\n        params: \"?frameId=none&message=-----BEGIN%20PGP%20MESSAGE-----%0A%0AhQIMA0taL%2FzmLZUBAQ%2F%2BJgpmkgscJEB9uAiFT6TbeZsBqD%2FrRDInab9OevrRBWOZ%0AwQ7UxS4OkM8M1joflEgtP1ZjNkCCuOG5RXR3JZFkUeQbvtMc4mpx%2BOOjYbwHwNNE%0A05wbcIHn380axNPWMYqe8%2FiCK9wFWhMDwtpDfJ0PzLKAhnjFhymMWjmXB2avejaS%0AiaKQRelmUiNt5Tk6FAu8UnOAbr7%2BuLvFBzzjyELL3pGzDBLkawhUT2QZ2nqrC1Ns%0AJ8HEXnl0TBI5T9rlK5i6YQi2i26SWk8QkM0ov5OWVK1qISf15VHeP5uLXch3MfHu%0AEfQEubo378Jbka9QMo1%2FE%2F8ublGQReMpsvbrWto9HqfPSXUGe3hUQcIRi3nKuQBx%0AnbMWonnNE7UEhBFytLL2w%2BMmBDlkePa7zDngOjQwLpYNVvrxJnCjk6Skcrn%2Bx20D%0AYkGziEubqhquMRLxJht4UTLuRSLI8j1NtIRZ5Q9Bi%2B1krSJz527cbq%2FIFBU%2BEmNV%0AfCcR1nYbF5%2FhyTwB7aZQyxCVlRWKlYfwv4%2B7q9cj5wCBuLCY7ZKucEbzodehRcEt%0A4C8Txg2KkD7%2F8%2BTt60KcqjvyDtQkQYNSaubugsG2BAmJpYRU6KFVGDlpNe6gGEQI%0AhnVQq5UaZ9z0DcevE25Xr7fg2mLN7yHRRSauvOGlMnP98d3gDluQlbvAzk5qOMqF%0AAgwDqn0MG9%2BUHywBD%2FsHF58ogxK3kAbITjA453U15KkR4bAqcH343mPfjPOPTyAb%0A3IMoYbQV9SbHuptav6t9rhtrGEkNVunLQLrGYNbwrQx253yqgN%2BdRYD8mn101yJM%0AFcN3R6PDCxAL4hW0cXjSspaqe1mx8U7pz%2BLn1DrC4X8O9HHgMrPvUl18Uc14fAkw%0AZm%2Bwk5vzVYxHp8WsQXb9xpe1imlew7jPuHZkNSA4k6YDoGn%2FwpN3mEOKE3BYq6Ro%0AhnTaapIe%2BJIzsa%2FH0HXKcD0ztFeRUEyyjd%2BdE3vdJYehZrEQIjsM0ocqbn5tcf1W%0A9DP0OXGylTfNbBMT6PQ4N5gfyQDext9Z3QOT0c3HcmUYHJd865jR5nXHGzsGW%2BUr%0Ad0Z6AaCsSCP8WPUNixLzgCdB7EQ6Z5PB4etj9%2BFmKYvEbFiaOr9hrY48ny%2BiOJjq%0As0dudhgZkE8XpA9jcJaGnM4UZdFnssiTydlqaFWYwjVk8d4CsjrsTx%2BJNRWOSVHy%0A9WBbUFQc1eH01rv1sfL467Eyzhh92SCfHooHN9lLtF2mDh43ZQu0ReW8aBd7RzHc%0AKJC8E0wcslzLqfF%2Bx7rh0Vt54Y3i0PS9H9RDWATssCx0V3ySwbnxqme6zIa5qKUN%0AkbSqkucmzZKnaksb46S0zJyOB%2BQV%2F8ntYErmLsX1pGFvPFBm0%2BGQ%2FyQgpUiJhtLp%0AAW8jKCFMyQBHhBKyG0k8Dn9f5mO8rE0xG982m%2BnGwlMKJunn%2Biiyz561V%2F2ebb5e%0ARPCj12RUAIzKicPqRaPCaXhEyD30y1rDCHO7vpCB1CgnbVfRcPvTOOuUlGlrMYWa%0AZlAyrc5RkAiSCLUJab9ZTf%2F%2FT34dmP1p0bmIN3Mnwu3XsbEdZnoQxqPSl0UyfqiL%0A4e5uGe2Za%2FrxykM9CuG0f8vtFWsoNhJkTugdZjfKUZdnyfdsmZhNbKlJcuB7prvb%0A0Gl0%2F3fNns6qv%2B%2BR%2FEGNHbZhSxw%2FqZXGBwGa0Y7hwwsA1Q6ObXgnZA1TDqFUhFk6%0A%2FcDa8FlRD1jj9rKyeuwwLryRy%2FLhoq1LL%2FWV%2BOiUB%2F%2FSldGaHkqXv9%2BCJNhmNwEU%0AiC5mZYyhGGbsVcBxuQigilyMpDQJJfcUiqfN8KL%2BN8ICpnuPGgaMQ97SLeHq2Mmm%0AehcEZwVQZGlCnQJNKmhbqqxJB7WmdBRKTDiBxE5qz5r3grB%2F5v%2BMbyM6G6MyAnkP%0AA%2FUKX0QUZsPDR41XVWhZPTDo%2F%2FZ6aIKJwlgB3E9vak2JkD4%2FpdgzyAM28HOTUyJ%2F%0ASfBVLd%2B%2FjxHIVlm1IaLUAzvJjG0NFlXvD7Pkzs5pXmUf%2F%2FbTdFXNA3uh7VBSGQMl%0AkaeyuemQwiW2Ray4tYbUq%2FFCzl%2B8862JBY98w38natrA%2B%2BWMLHIox0rhMIG%2FvoyK%0AU1%2B2KKgED414MsC309jn%2BP6WCZGKt34BXSfDp%2FRbgwP3X0QIxSYOxtmX8fjKlVPR%0A9FPmkwFvIYsE14MSB16y2vxSEt8JFKoGhXRuVxlGoYuuZrpERfhynnkwSLkw0zln%0AMNUUihw9AePivi6H0qy%2B7DpUy%2B41CW8nxkx%2FdePcdbAq84Y71FyfM7gbLu04EPZ0%0AhTzzgSLDSWvLc7vWRGbqI1erQhfadQwiUzMd0YAyImWmnm003dxfRNNC0oCYDE8V%0A3QGFqOmr4AqcbMGIWBGiP0LajmehJEv%2B8GkIkuDwQRtkgaAkHwDMigujFtraqGEn%0AmduYmYBW88YDsXD9Jv24d4Pt2Ce7P4lc4DEAU3vqUMZFdIwHanjKSNr8O6aXXd0e%0AwrFjc71tUTNGF0suNi%2B74ol0rlS1seQNiijulEW53ngK8z5brNSd1N56H%2FwcYx81%0AqSyeqnGYHphNbpwhBTqHkURBlwygxI2%2BCuMSR96j49ko9AZZHYl6DBAqHLKYWHGi%0AvqvpG%2F%2B%2BFFy0AMSxjs%2F%2FCe5lTS3y3skfneaZ9sgH7o%2BUXCJ7Op%2BmtLdHGjn6%0A%3DGAOS%0A-----END%20PGP%20MESSAGE-----&msgId=16f66f1da9d50d05&senderEmail=michael%20<censored%40email.com>&isOutgoing=___cu_false___&acctEmail=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [enigmail] encrypted iso-2022-jp, plain text`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"ゾし逸現飲\"],\n        params: \"?frameId=none&message=-----BEGIN%20PGP%20MESSAGE-----%0A%0AhQIMA0taL%2FzmLZUBAQ%2F%2FembFGVPRuVfiUujhLesQa6a4sbp%2FPOQcAsy%2B%2BO6tD%2FVA%0AwrQtPhJeniYVFeOs%2B37MWy1PkOUn6AAvgasHtlMCVnthxavG1onImCJWyC0NdgYn%0AhrIN9aPmOY7UGhVzpU%2FGTxE1WHJHGMMGShmKbt%2BJThtAvmufuDK1DSho3kcjGEs9%0AwpY0DU0%2B9I7xEmobgQqK4jyzLBLNx4aHl2qurKSmjghmk1ZMW4oluckrDmmQ3AWT%0AZ%2Fq7bnbP1GDNJV8cxR7ed4k6HCzkrX%2BBxL308E8soLtg87occ18QoJAIRAHU0kx5%0AJlS9%2Bfh%2FjNwKanZJjCWv6hqZKz9iUocRZD9iPqh9dhjsKalqkRaxuPM2eJkZY%2B91%0AjG8tsHYTLeY33A4aUpdA6FpNR8Uyz8Agv%2Bx8%2FaFp8GxSNIuUumf6bSIk2Oudt%2Fa6%0ArWvZO%2BM%2BUK53a4k4ibxrkv4zsE8CbijjCP8BvUrA37023GEWkOHIyMoFFy0o06W1%0A56wTP2bLmKbujeES%2Bdkzjrr1r9X6oDBwpoPABKSAjIKFQKcxWvhMgz4WO3w61g3F%0AE8U0Rlx4lB4Ce1I0qzu8S4hkaZ7sYcKJ%2F211pzsaf0BfxZQdrfyu5kse275YgTUA%0AbObnoW2sAWg8fX9JwuL9JVArnJ%2B6AOQjvNG9fr%2FuM4thV%2FzwqBUWfQ0sasDjjxSF%0AAgwDqn0MG9%2BUHywBD%2F9bMrHNk%2FqirxpfIRa9vZcZssXv7A61XUZy2IVum9%2Bp9c4W%0Aswd23kQOfC%2F82Fx75CwMQ%2BzzdP7%2B5tqeNfm3%2F4vfObLCmszf1%2B%2Bj3nVxEEX8sWpC%0AmgHobD3uZPwgShvgcy6ZHkfz%2BBrxqqTJIZ6xD03VgzmNg2cuAHD1YVUKbTHGYcKM%0ACY0b%2B1VG6lv4f78xiB0v8aw%2FaPTvtx0rY2g0YZHaE0JXT59cMNTMORNiE8h8guLB%0Alf6hcwctRN%2BsJw5oW%2FsaXpgFJSzVbQrwp0a1b6Ftzqv%2BqyJL2%2Byay83RaPX%2BR7LR%0AJy9jPrwBbzwCVbJBBSfeQ0zXkeNAOso83rE13UjxPsl%2BkU0ajxy55K%2FP%2FcLO6KKs%0AKtFN7UGo2jGelpqDoGU5FwOoGeEaYW%2BInrZryyV%2FA2bjw6Zmfbh0GMzls25fK%2F9O%0AOJp%2FD0yqEmnkU60O6eDwwwxY7VNqmtuOTZ4z8PIaV9LWuftVOeOG99%2B9g6280CKF%0AYYHAxgb559v70V50bk%2BZ91rdA1SnxSq9wOkUu2K1BmkTdqEO5jxWf04MGrvROZUA%0AdIKQ%2BPYibnRo%2BSObBUn4Otlfhel1tJ9wWWjJLpGJ1Zm3FaoCVH%2FMnnvhF48Q5JNR%0ASDnqTg4wWd51Tokcnz2PoPrxRN3jacI4d0GZiAtsmB28mcKjdB5UYoXEy2MazNLA%0AyAHzCHRtOJ7eOcStwltwnbh67%2FRCK9OCegaiSOMAcsEciVXUpT%2BhVl8oMl6IvJDk%0AFq1CwOL8t3Oj3W2igPkm2EejHl1dkz2JXPHjfHqt24tTtWRa3xuotoSvMAy%2BtfKT%0ACwg67nQan%2F13hl3eF0XXLCD%2B%2BaotGSahUePsgZU79oedY2vmcofUf743sZ%2FN6aMP%0AgELzwyLm7LzcFLjeokhNUDYpBgrH5%2BFcFZqpiTQhILONSvenncP4k3FDjC87DG5J%0AyIckBN1KeU219vaYHEkmSmU3egfEYRMw2HznFAaiMEAnDoGs0ZTqNOx75ktZLpfS%0A779APSTDmS%2FhsXXo7D8%2FmyYWO5RMxFzGL7SIcXkosqa%2BTS3FJ5198epH0xLNrDhM%0A1lMO2ZU5qb2TNA%2BWvSviiwWsZ%2Byj6kD1rzrvEg%2B%2Bq1b67s3oogP08wwHcfX%2BUiND%0AvdGeVd2YFPX0kszhtfJDEYAkJ8ERe5RKQqeNXdk8XMYq2irp3AVBTBDkgTgMDPSU%0ACI3g89S3eldT%0A%3DP4O8%0A-----END%20PGP%20MESSAGE-----&msgId=16f431a0b9056562&senderEmail=michael.flowcrypt2%40gmail.com&isOutgoing=___cu_false___&acctEmail=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - quoted part parsing will not crash browser`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"point to them directly\", \"free cert through\", \"will honestly soon\", \"dropped significantly\"],\n        params: \"?frameId=none&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20FlowCrypt%206.8.5%20Gmail%20Encryption%0AComment%3A%20Seamlessly%20send%20and%20receive%20encrypted%20email%0A%0AwcFMAzBfgamu0SA1ARAAuHXRxM9k%2BXfQ8iPNconAE62s5pP1PdO5iS01%2FOB%2B%0A3%2B6xUX5oWemiwXjmKetzMvYvSA4ltQ7fWxwY%2FRznfUqxiWQAMQflWINMlmrq%0Apv1iznuVrkdXiyhSLvHuhN3F6ZrWFBn3UL5xDHPHYaFsg2azvqgF6QXK9i37%0AwYbZZzJ9OU5yqAdzdTAk2Il5V%2FG7dh0Su9qrY7NAa46DIqbgdlbLYy6qLcvx%0AiI1yaliUg%2FmCbiVj%2B6kgb%2FFs87peaHg0z%2FpcngOB0a7x1ofbIW%2FrcTbhsEjH%0Ag6I%2B7XST3RmKcOv0PgCtEDU6HnRINbbKrwr9M%2F7xjjBKN8iyDs0Z%2FdOXDKKC%0AFuUmD10ut8%2F3d4jJfTIb5FEiPUNsChM7lidHadKjMoEg55iQgUTp2FeWXyIl%0AF0UlmWRZziljUURdDU02z0F%2BNg9wJkCNrdaCHZeULWfU4%2Bzhvobb%2FaTQfS9C%0AIDC9Qo1jPw1U1nojFMQdBMQQ8P9xsD8vHkeG0f3FOzvj8xWm2oJEvBDpsP6Z%0A3tGf5vV0uRFWuTE2xWbV3cMdvsL2rVJanmGnsddJP4p2WS5at7UDdm7DxyKR%0AzUJnuvITlydd78pSXmqUrw9W%2By0oOdIfwWz1A2V9pdaYwBolPGt7UKUeSK6A%0AMYELv6Ac6Yt9TBJ2B7pLu%2Fw0Wtvjw8IGGA%2FYxKX2t4rBwUwDvb12YPaZjcQB%0AEADRrSJiXzDXVdM%2BGbHBW%2FrdKcDoHq6n3f0mUSbwumiz51pQrtKmNgWFQZuM%0ArkV2O76foEDpUn8m3Gwcoo0MvCxJKWQN3U7dzrMzKd79egDQr8mCQIUqPDbJ%0A4gxVCy9pMAI51oIFM4bOD51MdOgrU1uITZDtaapswiIMywmjxYGRGLDsQ%2BgB%0AVaGF86QgHSgH2M7KdWtN9MSqDs28z7N9kdr0bVWAmVauSchqBeGEZAOq90d%2B%0ApXET%2FbEm0Y0l%2BqpOFEfkbWGoAsjOdOa0rSmBcfZoSh%2FtYWDpPwJDT%2BIp4XLp%0AC3C%2FFSQ11gPt0%2BAb8%2FYouGYmICTzMVUkiHxHGs24n6Tww26qBwQFDzXUAwxL%0A7LENsgsebLDOW8RjCn3EUuH0vZID7T13Xa9R1YQQHmIebVN4%2Fgrz%2FqGDYaZ0%0A4Ub%2BpMWpNYIhDWiQRkj3u39m4hCWa2Lo9d2avgUqmdghCDKZkfMtNRAMyLt5%0ALSDnh16yrl1p4P4e7IMDFp6Yt%2BeSCjH55HaDGeq5Z%2F3PhlbD%2BVFY17v72cBN%0AuyqsecJpTacESxX0Q4Psgahr7htG71KvIjaRBeN05I80IXjrMcTY6c8r0qhz%0A72rW2rfNRuwjIGtJOUfFK6vAovR%2F6kMJMTM4elJ4Q%2FEZIN7zd0OY5z%2FzZ%2BkP%0AoyC8hwFHgwhhx1%2Fu%2Bj8Ira7DXtLMIAFT2PriDTi4aGUjforTVKCh9DifU8Bp%0AUvpEUJl71EdFZ5ic%2B%2B6pkGKhyAFbNvJS3dvZWE50%2FCf%2Bm8iUvZCs63aikTON%0AdjBOpQgE32ig39oM9ggHit0zIZPtZl6XTJHytxNoydnT1bp2qJNj81ZyTlQB%0ANTusbMcY3usDMzIbgFdiNFLrRTaZ6KPuXIzljP7Xw2Lm%2BTcVFGRUmDkadFF9%0AY4RC7q3isJz9h8i5Q6sbaWJu6Ylc305FDKH9XensyR0lXGEX7ishe5Mg8MBp%0AOeSyw20GEejrxUHOp5daUA1XKFX6%2BvZbekqZ57Z%2BJFrB%2BU3cWN2b7ADHkxol%0AhfnCymupqLmoOj%2BU8sx2omWE5KBehRiSpWIF01Mx3j0KKwVpJo8wisB9WXg4%0AG3V2LduE%2BBTZves%2F0A0FTUg0m5ZWeqUm1MAOUkQOdf3%2BC8sKVEUUUeW6%2FchL%0AyQXhKCfgpDHFmYKiTUr7ybPmQZ%2F2hll49a0xkndGPi92kmne5dz3X7tHtPH2%0AcgRAluAt2GU7nPYxu3jqWURfeIZvGRLPd4Ty3CfQDAymEQr%2BmMvkgFdfn2pj%0AlhDGntJgUmNzgwmpD60y4eEZhYCnDFQUdEACHb8OTFZ7sZhKO41po%2FCV7Sip%0Apv9ryn%2F5QJJkoDPD1Yy56NqzoaAZxSfm5Uh0mr1wqCjk4yBHrvu8naYpnQMw%0Af%2B0NM0BffntPx6jUr58uUh4GF9bwThLYtFY8SRVMRbz2R2Vfgn5nxnD3EwrV%0AGZo4YnzXXkryrD2V2uwTc8iOhIc47h8LcN7Riz4mvg6wlc2B04skZKknRgBN%0AwtPXB0cjKy5vi5%2FmBTnyHGnCVxhGAtaCsGFBLNmIAoVuu8Te0o0whDyA%2BNly%0A9aBJunBjkfLWol1Xc4wO1PKOE1xQAS9EzE3B%2F%2FGujyzoL6311HgABCjMQeCL%0A3Nv7YQSgp5meoBXX3%2BCqKiPDEaKY%2B%2Bftr8YomcIYQJyDUuRhXoHynv7LcepI%0A%2FQUdYKxem7XECg9rVsjkz%2BP0xtPtTCW1%2F9wWFBkZJP%2Bl6V5zV29Q4ROAIKhN%0AuNmcekI7gUYKhpMp2AGt6MalswUoqhV0aMIpRPdVzN2xrygGtv3LEfOXV%2FlR%0ABdW3J5I%2Fh0AcbR1cteMVZfFX0DInDtJ%2BeOUj236HFWuJ7%2Bc5%2Baj%2BfN%2BIAubQ%0AEinGN1n7KPRtd7s1W%2FT%2Ft7m3ECTCt2bjOGu4E7kcetNuROV0cRpISC40KylC%0AWDhCY0T0jRheyP0n0QA46UHCMvWsFPc8wh03MI9dvDuBf4olzFX3UfCd%2FJC0%0Ap9KlzxRG6CMlJZaDykP3rbCMatUsioMcCubma63ZGUJ0%2Fs8zaOhh5wM8fLLg%0AVJJ0z0cxZJOOaNyulIrCcMonQ42IAiqNr3lQO9dQ4TeR2qCrai90UK%2BDbyH%2F%0AptuxG3Z1D7RWn3KTMoL4lybbcD82HsQvzayNKqFKs3ePRpJ2bHyrb1ehhfuR%0AD1tBuLY3qjk9Ah%2FbPvck%2FwWpzui%2F%2BwanfLRHkl0n7TtZIqA6U87OSQCIGQpN%0AOZfhNSzyFYHwfdHTXon2lyyBXwRAm4WVvb4hYU%2F3ZtVheUevqjDW0gau4KSo%0Aa%2BnbXYYziOrWZ1HtYJYuuDS43I2f%2FfmNpv8PC01OO4b2FOt9QNuHnFzTPnI8%0AgFy4dXj5W9WU%2FwS6eLTBZqftSa5zM8lxEM1ZLQHOtgH3FUwvNJOddujHtJ5V%0A5rsXxFNNYV9WKPxVa1fB9tWvmtXHVLr39djsL92rQTGTgniViHNJRAGk2eCC%0AMoheMqVnBHwv%2B1fIy4YoeWZmmbWnpIq%2Fl7Zi0aKmhsgu5EeJ66R7g3zL2srC%0AIu9OVyVCiCzb1j%2Bm4wSTiLzLlc8iPREdsTt%2BF1cpbB1b9euEDA1l4OIIEcLa%0A0oxZICpvBcrrZkVxayPjsPzz1y%2F3%2Bm%2B2ylEZbew30kaHFxet0abd3NWRYzxO%0ADRSNl%2BZGG6ThAqKcmxPrHNv2gUIqt%2Bvo8O8f6REaPMqRpZRdCesBc1XD5FMi%0AJREzoOCLrFdMO%2Ff6SOe6w7Q%2FtzQqVR%2F7YQJJ4aafqCgclckF7DW%2F%2FJKkAo2x%0AnV63%2FnHrv7zCeurdFLs7iYu7Zrjd9%2FZEZ0DWzI7MKCf7rulwLr9Z1M4s%2BzJy%0ANeV2Qx5HIZ7DBxQxj7PE5AVKgQntVyS4fYIfc4giUDvFb3%2B%2BaTJ%2B%2FPxEW8o0%0AW7kd%2Fb9Y%2FUoIwo1gTA1vL8OQtAmN5%2FizO23APj2%2Bk1Yxa6seaVbGUfgtehde%0APko9tgcRBPr%2BnQMFuiWxzgUb5HFH%2Fiibg1sXZ32re%2BrKJkD6eUQBZF5gFdCS%0AO4UbO9GCEvOCNoAFlatkYEOhA4i25cRW9FmBfmJyCZ%2Fot4vqR5bHYvkddZLp%0AvUCYx9XQn6%2BTsZwaRB6MDPFABqAqFrsJnjzOfjO%2Fwchn10vo9zf3x3dQcKc1%0AGwJECb4v%2FawAayNzqQgmAjmT8JqkcHDGrbUvjVJYvfVA57V3L7Ohd5iceicO%0APb4VEPh2X6%2F2xQKsXgpDqF4aC%2BT9mJ96olqTnFsqKwib%2Bm5%2BdJa9PCAKEKxB%0AuPzU8j7llXBChJt7qwzPNShVV5kYTWpnrUJLyvjCP9qBZ%2BH%2F9UACHQvsrP6Z%0AJERvjq5sUuLpSOvqdUcTACHyEZWHZjXArGLmpCdTsyeHv2UF6%2FG2RVXrwDVk%0Al8xL4pBQkgG1HSA%2BCh2dDTaFyNZcZuF6EtwjfGOyJ0a2dX7sOTSXVggIpXwf%0AHxLB7KZg8GOTr7LRgjMl3h2bCOQJ8K4fOCYLw8yAK%2BMw8dQHwvtYUKcB8jCl%0A2eg3NAgDfqquKS0V06usPmSbXjgYyXTwYFM8NkOglAidnMKE%2BmzJRPsmInxs%0AB90SL2vu7%2BR5%2BX8tbLfCf2AMDd96cgCDB3TCxgaUbo3SU%2Bm6d97ALpiF%2FY6I%0AAUkl%2B5fcUdk8pPXkWzs%2FGyy%2FzpSmSF3I%2F6O0%2FS5RkCGVZ70Ig5%2BfeU89RZCW%0Ad%2Bjz0r8plMUn7lDBmouUkHGIkmXYHM%2Bzf6q9C17VWBwJCx%2FXddGmYTsPHmnL%0A9uHOIVNpDluf6cUvp%2FJlZ7t28f4fCqMFLF1Ebi87zVJBXmyvgue4WEcHVnAD%0A8ZNTpVvc03ZGba9UchGdWt5Y3kauldSFPN%2F4ziCPOeC%2BL50M84irXUevO5Es%0AwAFJtm%2BRI6FycBz7CLlZKjxz8I97%2BXxsjA7ZyuvUNRhORwv9HZx2BJ0OFM01%0Az%2F60Keq%2BQTXPzpzL0xAJNdrrYi3CtWf7gC5hTUlO8ocnx4qnwGOPyo%2BRmMGk%0AqKXLCeeb6OkS%2B%2FPfoGXm%2B9mBpPiskdMhhDD6gEfP6Z6oX%2Fhf%2FnlI9JEMKECN%0AQpPzOcFqDPyBjyBhTo3VSQClqBV2K1dQNL5GLgXa8tkHaXlPtVJR4S0WHCVh%0Aa3vcT%2FossJijMIR01HrM1jhbj%2BmFo6wc0o2XTG003IZih9T6ZZvCnGV6v31%2F%0AJZ2LOWfBReStcSrFZ5ZinS7fWcG%2F5JbuokKZVUxWqJq3jolD6nKpfEcBPaga%0A%2Fc6SujlXKQ2Gr58cmdCrN7JTty5F7lFtZlZRcG7QHtr01RXrrqCGU%2B%2B29%2FB7%0AcS4jpPvX8of3zwaPiBsi68YfkfAlyhQhbWIYYmWFjtyC2aduiGGcPudnRzVk%0AYG3li130yRvD%2BxeS4f4oficXUdB7SvloRbYvNuT%2BtaCPJ15ncSUXwLLOFWk2%0A7PY5r5h6PwPVxhxEtmUgcihbBP59WWViL%2BijxPCBoPxDknREjeJOgKxoswyK%0ALuOj5R2D6SU0Zs%2Fv4kWwXCz3wTTdU%2Bph019Z6SvLnm4XFbJTx1MI90XYzydD%0A2HFYgMuAEae72Hmv8qDO8SOat%2B3EkNw9e4DAT%2FRGOmwuPR95gMucqJLcP%2Fu2%0AJxLNQLSUnlfABSGiAA68Gym6ykDKYMrt4v2JOFNE7j457Iq0U6fKKRxVGNdc%0AnF4KmIyA08QIc1YKoR794%2B%2FgNYmb78PCsBQbXOmgldOAKQQl8%2B5Cz6Y2Mu1U%0AduXWUmcAi%2FIEb1w815jTzedtoIQ2GdW5gGIcWSLiLztV%2Fz35gDPxXb0HUGuO%0AJ6THAR4mc87euWzcBhUBxdfNaEiTdUgcfx5M%2Fh9YFuhS5VJjK1rjX9I2jwP%2F%0AgUBlWVwmG3mE0thoVxpSFHICI7uw00PjTNRA3qiXe1sEB6D9%2FWRuqUvKfkak%0A6ukzJBHJA2buKyZqOGE1R9ZJniRImpJN9sPVF2joSvHPB3cSb1JWENeF2T5H%0AgXMhFY2jbgpcXucMHapqDLJ3WMXCCR6R0pCGxWnYcY0O8klv2r%2FTPfdptVJO%0AaEib8XRAgxR7FfctRKmfrf0d%2F9UQQRYsBnN7fn3baHFG1UUVUEYHTr%2BiXpMM%0ACFontBV4pK%2BGl1bYAvYWLVXeL01drpVTgU24FZp4yTPC%0A%3DqLXa%0A-----END%20PGP%20MESSAGE-----&msgId=16b7fce1c1589c0a&senderEmail=human%40flowcrypt.com&isOutgoing=___cu_false___&acctEmail=flowcrypt.compatibility%40gmail.com\",\n        quoted: true\n      });\n    }));\n\n    ava.default(`decrypt - [flowcrypt] signed message inline`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"Standard message\", \"signed inline\", \"should easily verify\", \"This is email footer\"],\n        params: \"?frameId=none&account_email=flowcrypt.compatibility%40gmail.com&message=-----BEGIN%20PGP%20SIGNED%20MESSAGE-----%0D%0AHash%3A%20SHA256%0D%0A%0D%0AStandard%20message%0D%0A%0D%0Asigned%20inline%0D%0A%0D%0Ashould%20easily%20verify%0D%0AThis%20is%20email%20footer%0D%0A-----BEGIN%20PGP%20SIGNATURE-----%0D%0AVersion%3A%20FlowCrypt%205.0.4%20Gmail%20Encryption%20flowcrypt.com%0D%0AComment%3A%20Seamlessly%20send%2C%20receive%20and%20search%20encrypted%20email%0D%0A%0D%0AwsFcBAEBCAAQBQJZ%2B74YCRAGylU%2BwkVdcAAAfAkQAKYwTCQUX4K26jwzKPG0%0D%0Aue6%2BjSygpkNlsHqfo7ZU0SYbvao0xEo1QQPy9zVW7zP39UAJZkN5EpIARBzF%0D%0A671AA3s0KtknLt0AYfiTJdkqTihRjJZHBHQcxkkajws%2B3Br8oBieB4zi19GJ%0D%0AoOqjyi2uxl7By5CSP238B6CXBTgaYkh%2F7TpYJDgFzuhtXtx0aWBP9h7TgEYN%0D%0AAYNmtGItT6W2Q%2FJoB29cVsxyugVsQhdfM8DA5MpEZY2Zk%2F%2BUHXN0L45rEJFj%0D%0A8HJkR83voiwAe6DdkLQHbYfVytSDZN%2BK80xN%2FVCQfdd7%2BHKpKbftIig0cXmr%0D%0A%2BOsoDMGvPWkGEqJRh57bezWfz6jnkSSJSX9mXFG6KSJ2xuj30nPXsl1Wn1Xv%0D%0AwR5T3L2kDusluFERiq0NnKDwAveHZIzh7xtjmYRlGVNujta0qTQXTyajxDpu%0D%0AgZIqZKjDVZp7CjKYYPzvgUsihPzlgyqAodkMpl%2FIhYidPMB135lV4BBKHrF2%0D%0AUrbb2tXMHa6rEZoj6jbS0uw%2FO1fSBJASYflrJ1M8YLsFCwBHpMWWL38ojbmK%0D%0Ai1EHYIU8A%2Fy0qELPpKorgnLNKh8t05a01nrUWd%2FeXDKS1bbGlLeR6R%2FYvOM5%0D%0AADjvgywpiGmrwdehioKtS0SrHRvExYx8ory0iLo0cLGERArZ3jycF8F%2BS2Xp%0D%0A5BnI%0D%0A%3DF2om%0D%0A-----END%20PGP%20SIGNATURE-----&senderEmail=none@flowcrypt.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [gpgmail] signed message will get parsed and rendered (though verification fails, enigmail does the same)`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"Hi this is a signed message.\"],\n        params: \"?frameId=none&message=&msgId=15f81b5e6ed91b20&senderEmail=none@flowcrypt.com&isOutgoing=___cu_false___&signature=___cu_true___&acctEmail=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [gpg] signed fully armored message`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\n          \"this was encrypted with gpg\",\n          \"gpg --sign --armor -r flowcrypt.compatibility@gmail.com ./text.txt\"\n        ],\n        quoted: false,\n        \"params\": \"?frameId=none&message=-----BEGIN%20PGP%20MESSAGE-----%0A%0AowGbwMvMwMVYfy8j1GPd8g7GNXlJHCWpFSV6JRUlcSH3akoyMosVyhOLFVLzkosq%0AC0pSUxTKM0syFNIL0rm4gISCrm5xZnoekEosys0vUtAtUkjLyS8Hq9VLzs8tSCzJ%0ATMrMySypdEjPTczMAYkp6OnDrODqZDJmYWDkYpAVU2QJVTh1Tmeb3HLhpxtYYQ5i%0AZQK5goGLUwAmYl8mwDC3yqJ3RqXeax2n108b42sc%2BI29zE1fLvdgq1Tz3ZL0a2Z5%0AXSTDobXyoiGnj748k%2F8iX7dJYc5C%2BTTmPMXtPmYJKmd7V7v2x6675BfR%2Bm25ednr%0APfEB9k%2B47iQ9yNsgu9TG8NC%2FhhccalMkT1UUcv7V07mW2ZRbfvSop1ZSU%2FbXm3c%2F%0A8nd%2BZShfmrHQYMMfe3Xmildmbhs2f7S6I8G%2ByamhrH1XsnXKlc%2Fca63S53TU7u5e%0A%2BX7vil97zTc3cDgtP%2Fuw6GB6mmTo8mqlb20GytG1LuYzZftP55XYL7XyO5M8Rzx2%0AZcLBPTsfzs8o6bgxt0fBucIlds7nzLOyKld%2BG2u%2BuSqzuj9wgpeOSX149f%2B8y7N%2F%0Ahl5nbXIo3qL3QXaWwsXvh7fITVp155%2FbxSXKX65fuLmh%2BET24Z9C7V8iGf9M7v76%0AtI%2BjSNRu7cnAttxlX4tOGHhtuMH%2BTU8nNv1cPEc1X%2FH1VRv95mWabl3lP%2BHVmou%2F%0ArkyN1%2FsWl7tS%2FfZP3vVlp3MSPvqy%2FP6T3VKhXSYdWFzhyblB6KhqzAbBuuVf%2F2bY%0AKRx1239v9uZrM3yEZOc0JtzNz7Lh7xb6e89tIne4blx81aRT7b86YroUHGfe0PF4%0AsHjRnQWdmeU2kgcmH%2BLUEdxd4bJgx%2FSQwPrb%2B6zieQ0mLbDsvZm7gHFPeq5ZW%2B%2Fe%0ABU8%2FcNc2bd49KWrdT8%2FzKpJ9KmvV9uz4AQA%3D%0A%3Dr8So%0A-----END%20PGP%20MESSAGE-----&hasPassword=___cu_false___&msgId=1707b9c96c5d7893&senderEmail=flowcrypt.compatibility%40gmail.com&isOutgoing=___cu_true___&acctEmail=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [flowcrypt] encrypted hello`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"hello\"],\n        params: \"?frameId=none&account_email=flowcrypt.compatibility%40gmail.com&message=-----BEGIN%20PGP%20MESSAGE-----%0D%0AVersion%3A%20FlowCrypt%205.2.0%20Gmail%20Encryption%20flowcrypt.com%0D%0AComment%3A%20Seamlessly%20send%2C%20receive%20and%20search%20encrypted%20email%0D%0A%0D%0AwcFMA0taL%2FzmLZUBARAArdbyWcgwf3B0LjUD0ephMVsbwKMqETPnpCZiXnuk%0AXWEfNv0IbbuH3Z3MT%2FDmMQuzjltFOx7ggKAg3z452JZI%2FZ74vxaMtiWL%2F4NB%0AbDERSYIsLe%2FqaG0r9bLSFgju2JpToUGY6yiEYg9ciE1vitUwzurx%2BwFi7WIq%0AsO%2Bzra46rp76rUKk%2Fvss6CtPlqScNyJTBmv%2FSz%2BL4zbMESkdiR5qBVqm5ah6%0A65TXO1KIH2ZjdOBmLOEi4p3%2FJM6IQ2iPQQIsxWHjqtMQyOZA9Q40GpRT5kQ7%0ADCUXsRsGB5YjfgsBw2r8HUt2eLKmUThPC%2FQZlu8yLO1AAIAPJJtwAw6OOJTR%0ATxBTwMAhcJxtFRKPYtUD87xuydctGhoLy6mJiPk3q2Z4BP5hctnuSsaUQPl%2F%0ACsZnSyobQIde5MnS3GyEQ%2BMUc0oq94aTS8OdXrX3EJJU1EU3Zy1P38n3V%2Bgy%0AW1qH5CR1D8otQ8Ed9Ks%2BSRiNm%2FQPBo8hu3df5RGQycwVe%2Bbmx3EDCSBq%2BzbD%0ASbaViUJaKxJnqJ%2BUKEruouuhli1EkzVgSj%2BnpQjJ1EcVIjPGNE57BDC0qIF9%0AbcHcCsyT%2B8VMtrCB9aMAUGNXr%2BbyhY8SIv0xFdTshjx5M6PWu7e6yFrRiT2d%0A4mMUJjYMWcEyXd3RH9pn1QLEWZK1Fpaclb8oPi4PwHzSPQEeLXuhArWpS%2Fsv%0AkqaG2U1x8qUu3yM3vkxWWRRMtmRuPTvFfLhoJRqxGV%2FihBIEQXwlKvgG5qcW%0AjP%2FPXN0%3D%0D%0A%3DNyoF%0D%0A-----END%20PGP%20MESSAGE-----%0D%0A&senderEmail=flowcrypt.compatibility@gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [flowcrypt] encrypted utf8`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"გამარჯობა.\", \"こんにちは。\", \"Здравствуй.\", \"Chào bạn.\", \"Dobrý deň!\", \"여보세요?\", \"你好。\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_CdqnkNWgHP&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20FlowCrypt%205.0.4%20Gmail%20Encryption%20flowcrypt.com%0AComment%3A%20Seamlessly%20send%2C%20receive%20and%20search%20encrypted%20email%0A%0AwcFMA%2BADv%2F5v4RgKAQ%2F8ChgnbhGZoPWlurgYIIv2QrY19hjaUs3cpuKMDlDu%0AVEtRRktKtX2aQ3Uoa8Uujc5xbP%2Ftj4PI2Tq7Hq2J6e%2BevJ83QOkKhT9zjfaJ%0AMqutNeP6TFDdtBsumdoLMEPXeGRL5iQ1QpIlifenIMsGI0JRRYZnZJIa%2Bezf%0AAhp%2FKrwK06bnT7mopm4zNRai2JRDppCbs486Xk9ErOMtCLEzWDZcVPD76agC%0AoTiRQjX%2BHeIyPgAqYTFgS4n5OyOl24alwHwPAvYV9uMEmKfoWZAOc87lZ53v%0Amqmyj14kWMtHwNhgQ8AncozGbv%2B0j52%2FJATK9U605cF6f0%2Fuc4wvd2jqpfWY%0A%2ByJw8E1wLR93oHvp0osyrHPq5TFeQO2CyLzOhhZsT50kyXJuD%2BQfgj7buNed%0AQQY2Ve4nrkYPgHIMukfXQDj8W0ZCluct3WCg7M0YWJizDnI9GE2UN9VN4OHn%0Adfle%2FAjBCijxWLxQqWCSyuwNmZl2QaHS%2BTrGj7%2B27GtsQc3JPu26D50a3PRg%0AHZ9srOYHVRR18PgoSfunySNio6FuMCreg%2BtPds0dN%2FYapCkXnOSrIWUGhOv%2F%0A5XalIpMK4ICa7mCmtgGV7C9BW%2FlvDr2jL4o%2FE0jyJHMF7eUimylGLU5ETu0e%0A3wJFemlLMlClcfsoo7Djpv%2FZLv7M8SvBLwSzr8%2FkF1nBwUwDS1ov%2FOYtlQEB%0AD%2F0YG4QGIkkxLjK5pHLlWGD9k4VJ0vxMjgP3zI5hLG3V9j9mR3dm7zmiULpN%0A%2FyeDlU7v1sdmh2s8x4yJZ5xJaiL6gDPGoxKg017L1GyNzqvna9qoDc2HxBMj%0Aegs8RR6Do8rqk9p8EBXiI3FlHHn%2F5hG49Ni%2FLNNxcqf6dOextTWpm4tFeMHx%0A9nA%2BPO2MoF6oGkrgbOMDUtKZwnQGCxA3%2FYXgv7wya%2FoAS1HYVvRx6Lbl1YME%0AHM7e4nYiAOflwU2getEtSXfu1CD8p30F%2FAkO%2BqKaitZF2LXmS%2F41yIjD69oQ%0AsY5ERKRdNQTBkr5eUhS6rFXII8SXtJVw%2BDY29AAelZTIxIJ%2FzLW6AiPydRSp%0Amu4vi1%2Fy7YWTQ1bWlvyIjHWDRpwVv4K7VMWIk8wUq3uRF5%2F2%2B4h%2FemcXc7pG%0ALuX%2BwiqMWw8Hjv34%2F8HlltrQRG38JtsTKC9DPKTqezrIcdPvv4PkVXGHLxYg%0AdFyfkYr%2Fb3mKiGVpptGEE1rCPzg0TCd8JNQgFr04Xq5gElPP6XBcvs3J5%2Bh%2B%0AuHlaFsoPMzthn8%2BeNmvxiCHpd92VIbl9Vq6%2FZtSPcJn4drrftn3V1zvUC712%0A4LNp2iipdSAynfkBQE0FJv7m9mbunCa5aAEVQ7bxhgNX1CqAtRmeshd8w7SA%0AoyTwxN%2BVsQUhx8OMKB%2FvQ4SQNNK2AVgaKnVXEtPWJsyj0HUlwHB9jjV5L4I%2F%0Ai4OoVEy5ANL2f09cPeHGkbaKb8s4LTqZAU6Zz%2BLfDfTjzPrRD3qVcn3Kcwj3%0A4eCvkBIEt8NJ5%2BZVIKhN3lGCCab%2BFJOtlXaCL0oks7JGlQn57IPmtmWCaGKa%0AVRhp4WU3oIVZkKjI23sIWdt0l0z1H1xKhFVF%2BLE4kiQ%2FCIwifGYJ2R5eQi5I%0AqtFxVWy8T4Y4aWPciv73P%2BRL%2FnDd3JU%3D%0A%3DwmSW%0A-----END%20PGP%20MESSAGE-----&message_id=15f7f5f098d6bc36&senderEmail=cryptup.tester%40gmail.com&is_outgoing=___cu_false___\"\n      });\n    }));\n\n    ava.default(`decrypt - [flowcrypt] encrypted thai utf8`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"ทดสอบ\", \"นี้เป็นการทดสอบ\", \"ภาษาไทย\"],\n        params: \"?frame_id=frame_vsaWCVStjY&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20FlowCrypt%205.7.1%20Gmail%20Encryption%20flowcrypt.com%0AComment%3A%20Seamlessly%20send%2C%20receive%20and%20search%20encrypted%20email%0A%0AwcFMA1DaD5CEIgc5ARAAoUfZ%2B9NZCeiIQKQK25%2BdSvxB085gOTv0XnoAlqPE%0AjdhKp7XXojq7ccUSaeEW8DqTel5P74FZ8GwuhFNj%2B6G8ZEcOaxo%2BVKgoOkfX%0Azh%2B5BsABuCDRxoEUivVVM3%2BC2SBBGkqgbj47RJUFOWYkQIlwBhSA%2B4bVXaIC%0A7TEYLxNy8845%2FtTLDoSjQyMA2qXx5KgFaiD%2FZNDQeWM6wcYeHCczbRBLBJ9z%0AOvHy6hDdo%2Bs0P1N4jqGCUKpORrrCyqupKkViWIYwhkrNE74BGzSGtWp4PD4d%0Au0bSgCcKNJI4D56vOl7VPpNlqumNaM1DFgWCRdGcQdfeHyw10PuLrWB8QmSI%0Atzhv7SLxGQBc0o0tveTKfugVZlDq3Fi3eo6GDzKHW%2B2NkOjMoR7mNCvI8Zrg%0AcZVFwmSEClNTnBV5QwDSevEkOYdhc6TEi8p3Gngv%2BOMLZmPO1TSAQ15KgzeH%0AK6BzTff%2FeTJggXvR4gbYOvySIrow2eUQ8F%2BLJV2jKfmOJIJBOUKEh%2BRQCuIW%0Ac1TUxrANDM6Q0ZMPrQ9uvKUQuDjORmizBqXo1YvjDEbGHh2%2BdwaTSNr603%2Ff%0A4RDOgaSMhMWNvTx2MXk%2B5V8uqoAqZQZ3tSLkPGtGTumlCnLivR%2FcKTeL0wIb%0AueEVTDW%2Ff7nQfhuPXL%2BfVL4i2HItQgl68YQQg1PxuCHBwUwDS1ov%2FOYtlQEB%0AD%2F965w%2BTY6hqEtzgQaHr0S2AyNdgLU2HkKI26%2F0iZ6m5V9S6Kd39r5HmVOcY%0AuNLDlNwlXjK3ohbmEg3VmLirLt4tiq8meN6wpCKLv29GL1qkNXsrfA01dd8M%0AizYFXmf0c7d7HkV9JQmUr0xbl3Iy1mNl3qcXooR2OociWykK0Z4ESLKNV2Do%0AUAP6z7X7jVHLstri5BOqMKTRihvFB2rMGdJTIzH6XuMlSnJXSa8LBHE3FZZr%0A%2FSqxSV4pseg2VXouscdDkMq958ZAaLteptrQT7rqO2qcJoE3Xoon5RJaFv%2Fl%0AM%2FVSzfgfcXCfJF34HMrZGjrHddeAGG%2B7k9E%2FiEGcZ%2Bkxx4ToruzdxGdenANv%0AQ8W5l3AkT1qlvV5GSB0uwpJm1FavoAtiwQfLX0f%2BDC1jI%2FwL658%2BnzNp70BY%0AlL7MXN9PgLLY22wSIYXG7ZHlbWAbs8WD67gBw7W943rw0%2FmCzuhQGH6sJSLc%0AEMhoCA%2FePk3oL2LqU9F1Im04tz%2B0FBP%2BtPZDey%2Bo96Tl%2F0W8wBUxLCq0SAdv%0ARoG%2Btm%2FqfFpJnCvKMOlW2UMT2dYxFGAsTdgHU2xWBP7v%2FnsUsRBM%2BF2mGcxh%0A1OOVzxs01SvYqza7jPhfW3NYBW5QhtnIx6w4b6h8aFrwOwgH0B%2BhuGvDrppR%0AL5TgtK3%2FJqomOtbk5n7T2YID8dLAIAFzuBmdFwMtyzU3NFucc4ekf%2BZYLiR3%0A0edmsPhzAFhHxbaaUimCfe0ipXiuWMyOTgGr%2FeQHKT5Tax9QbGq6j5XVzAr3%0AsAJ%2BYho2XvA%2F%2Bj0XdVHDw3m68HJcJzcJfESIHod8asikJSpr6l%2F2a7e7P7yk%0Ao5sQ7owhi%2F7DXTPdSyjB7rIO389WrRy3AHBy2T70qEcXL%2FZcRX1Hg00dqNZ1%0Az6r8N1dCp6En71mie9jxN37iejGJgD7ygyr%2BRm4Q8r0dsL8%2B8wfDcbxWpJZu%0A2Zmv7a4MdPYJ6bFiVJYpFau26zP3%0A%3DaaqE%0A-----END%20PGP%20MESSAGE-----&message_id=1645e37647db32f8&senderEmail=flowcrypt.compatibility@gmail.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [facebook] encrypted utf8`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"Сергій Ткаченко\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_CdqnkNWgHP&message=-----BEGIN%20PGP%20MESSAGE-----%0A%0AhQIMA0taL%2FzmLZUBAQ%2F9FG%2FDQ01YvjE9jIzCRSPJ392q28yexjq5PIyFnmUb%2FSOk%0Aboeh8Xs1zMmsgcT2rtMN2Fw79MQdqhhsSS8GSU47MJ7MdMLaWBdrF8oR1ChpsCMp%0AwMAqdy31b%2FRE95Pzp78VJnmZp5qDqqCNbnLVD%2BZzev4ElGan58YhpfnMFsdz0tk%2B%0AgTr6CQVDKOprvbskaFanG%2BjpLWo%2F9LzPu1eWrX%2FQ5SwUVcaVKSdbLm5DVRSU1qnt%0A%2FItTiRueMaOPwZgqXJS3GeqT0C%2FCVxCDd0ZKwfP%2FBuhVTKv77l%2BqnxuNj83I%2Fak1%0A0CJw1J5jTe%2FNEwU8ZdcJO8hDWo900zU90oqUoYUsH1yf7SKL8qSJ8%2FGMW9GSz3cX%0AFhsbE1FiJZ0CG6sUAYtMFWX2rhMwuz8vPLXlj3q6iYQ6s%2FCxqJvuHSbIK26XYMWX%0AnsCkuJjKm3cKe3KONeyxOyizlQaA%2BeQB21U33Bap1FSFdJ0APK3HVJ4B6ZICsLiF%0AVX0iml03ezvhC4qRv%2F0Xb2AdYZm%2F1HSgVUuCvX6bnoLDpRYq%2Baiy%2BHeO79%2Fu2Z0T%0A9Dv0YUAopO5it8cEAWBz1eQvKmkNMQC1W%2B3dZ04Z8bZZ95UwQpcVZLLlvxc8ubwK%0A%2Fh55B8g2ExlAFKtkuEfTtsDzAE%2FPUkgzZ%2FmcyT6clvPrGG4NZGpHxEvl%2FshWRjzS%0A7AHgElrFBgyBD%2F3EhQGy3Lb4pf0helGHuMFjEWHb0NocxyKhLLi63rLVZrDPSPWb%0AM4gtE44bMp0HZ1kF150X8F%2FfXX243M7EVf88zv7uFJaKThbK6tqhl%2ByuegUFiDUO%0ADXOwDkj3aPKM5tOpkkR2ECOOsNZiHQXkfvED4yNhx4sRGAEiw7iXuIJp8mRYQKxW%0Afrmbl4yxUSgWii0s8VQOagwRjcYq9PL1Qn2gujfeNDk6SSfDHh2vIEr6by%2F9y6MG%0AeIvbI9VVke%2FUWtZE75yn4XlVROou%2FUmfERyR6%2BzsQBoMp%2BPy3bG%2FZ1pS42jk%2B6YM%0ATVoGz5SEpch1RH41Kokgn9gRvlbUN64jwsAHbWi3CDEtik81TXNhE9GbPidbB49N%0Aihy172mP0U0MoeAdF5T9Y8GEdDu2%2BTBJYzzpjhGszi6pHjyh%2FqFE2stuNCV44YDc%0AJRnWW35gzD1PU%2BgVOWcx%2FPEAMLmY1VN3RMuuFW951BlNtjg6B1E7GBhMHm%2Bn9l8R%0Aw4%2B%2BzjnV8t6ZqIo6OjJgiQkEh85pOq4yq%2BqGrQAJYOwpnJ4hZ65IB3rsqUrlCeeh%0AXU9n%2B8DCgtfmxuodQWqcRDjwADXc8bWFYifHvTehBly1pIrFLvNq%2BBfrE85vbJmv%0ADn%2FGIa%2Bcu9celM8%2Fuu9pKN5Um8sK%2F%2FHRWo4vFzTXRkBUDuK5p0xWMM%2FYVtSV9PN4%0Af51wBMyaY20YOXLYdyAy31%2FNGh61vSRd%2B%2FzjuzresZ2ghvlecZdQy9fnSqUSvbIt%0AJLYa1tK7H7UjmzauZccKcQqKgaXXAQJt%2BXYZYYlwGcCBzHzMCD65fMwcHit%2BH5Gs%0AjMKjBh%2FitsQP3FV50zO%2FkFq6k4fy9j7ib%2BREQqFyeb0JZp3tnqTxpUPPV21wa%2Fws%0AZ87kxWPN4ckwVClciZMDXtESxRXm2xmlwvQY76Kjw5vvvGgizxEBvMafD59bB%2FdO%0AFwa8tlPqlwCnI3SSB5WHEdV2Rfu5O9SU1ao5X%2BzFpZLSeMMgnysY5VBJzFa6EdEP%0Apu16Hl94RX3aONOD4Mq1DGZQg0ZZ5qFZ9ZXCgf%2FJ6mqFo%2BaHCnT4ETNRotN4bIvO%0AdQROF7yiZxKl%2Bue74pfAfgDLPyYBSmOB00IA11dPsml%2FeI%2BVU4MpDdKNWHI6a4lw%0ArqoeoxaKaSg8lx58SeLW5VuRiEZ2PlNnf1aFzfew5lb%2FMBmTrNQLikTkKgRNUzUe%0ApaobFtSnXDabV0Yqg4A2AYoCKErk%2F0R0lyrUitaUgAl6s3e76QRzf4Ao7r5HTXF3%0AsnwFAD4O6ijuQQz0FnszF3VjHwO%2B%2BfxZRoUAVhovPMN8sUxAXbPUq4Lui9vHbGHO%0AxN0CAY%2BAj3qgtrZE5nUt8rTRwiW%2FkVCyDDLY3kbPdZwdOvyeWkSNOijRcdy99ZZG%0A3OXoT8ja60yMmtRvbrSvXQ2KoyM1%2BeLaFOqap6elGGmkZbKvuDR3b4KZElZCvB62%0Aryd4v%2BtsEcCMsTTpo7ekZqtlcs98LA%2BjCFjVUWGxBz5SavUmcVWCy6QzjG0RaXMx%0AImDGQWiom%2FXD8hACE%2B41HYwGrTvKsW33yM%2FJEsDb2dRN%2BrbCQ6RGTjX7tiRV8BGk%0A0MIY3EejIgQkZMZRAzh4ZbGbZhBUZgfUUzsTmNu%2B%2FfppZPQtwRsXvunF%2BqFCvXWT%0Ag5ZVUcZeBqd6awLJe2nr4i1sYKfHLztKjSXnxbN1Gofnvh4NbPRN%2Bh3Q1vB%2FhCgg%0AfjPjdojEiHk1QcUG4Vw3N5IUSWdeYnC%2BCGsO%2FRX9f0u00TnVpgkkQTfj2FPOE0fr%0AYd90TYhegXykYtzjigAkSMgnasd7zg23MLH0kZQxQCdj7%2BEq5JF0zB%2FgbGbKPdId%0AxxWhSPoAU3y0i%2FlyN0541uqlHxX4i%2BcXdlsTSrAg1QBAquCf3we7b7IMaku72aBp%0AXInSLj1bbnWeRmeuKWh%2FIDnk0xvPN7eTIzi%2B0wYkYfuwKLd5QSn6CGLgk9VRHzsC%0AY2PwwSX58Yo0JK%2BYE9DCvMVMNUeJAxpdIkq%2BV0jwjdER%2Fzpv%2FLUy6MKh4X62dKMh%0AyU9MpvqeMYkfFjbVnFlV9bJnWutYKbtNpzRegY5wIGEOXtpRxuFuhQoGkGH423rD%0AcWDEzNuQ3CYqxY%2ByVATpElBiEYbfx3KKZ1%2BG8aLajv0tI6NnN9qkmCIbjv1e%2BFlS%0AuA5WutrCrIgHrMhREC1R6woUh%2FtlcwGpn9gumNZvmvqUY1GY3jQ5UgY5VFgwBycv%0AvM4kbEbk241xt1%2F8%2F9FZBwvjfW9Lyt0CSw%2B9dqYuRAEbXSaAvvqPL8mUUjG2%2FYuD%0A%2FeStuJYwOn1e9gNYX%2FiUYJD8SqPx89DgGSOcSPOefcURbqLF2yQGl5si2PonVNW0%0AjCsLc6iREfLO%2F28qn9Wd1ORBI6VdcRKHmAxRf517IZDAzO4aay45T04hU5xFL2eA%0AUZ9TC8kx56rdNFvrL670XfOa1er7MaprUBhWfdtgbIQ%2BYTYjzVVi5954ivMEV7J%2B%0AyBLgCKUUJYI%2B%2BvWJ%2Bi7X07Kzt0ZHXebLRCCljiM124dkhncGVUM6QXb1qK4hQG5Q%0AFhxrOjGUrNq7zExBPYEihmd4zf3e3kQXPb1DmldTrwRz%2BusBSB4kSi%2BKjW%2FiKrte%0A0%2BGXgDaJUIL28XLPTYZHPwE3mB7tw4YImSxeSfC9FnRw66JF%2B2Eoae%2FO52G7BoEl%0AqPVRTvVu2DgXxb%2FDljorSrWa00iJSZKeasXDrHSCKcUexkZ21D8Fmr%2BNib3KhQRY%0Aa%2FzgNO9lg%2Bg4JWu2KbVyjECcjToS1sS1TOXWFpGUFMJ5WXMUgZGD1Kk7m09fZF%2F2%0ARbgm6mDWFzG4gNbz%2BqpRmZUCfKwvEDEWtCw7lc0AtAZitjZW1OfATo7oCuqSYQyb%0A4A%2BPibAme7a3kJ3pn5puGQ11hYY33iYv0Jk5%2FMEWVztwkwYc4rweS71YxatIrJiT%0A6SaD2jSzZwAvyqeEWZbYOByIZaRmm6rTmGpE0yGB%2B7zWJ0ZpbCvqQcyTrCZBMlp9%0AkselQeRaxDpkcmlP60Hb0b3emrbDtRliVrTpw3WJbafI4kMSv9kuozBqAavPkhjm%0AKH%2FR6bvuuYzG0fhr9O1CT7wdn85hILepQoIAiLkkjpx9t0x2GS4els2LQm3fRU9h%0AaXP4YKsIoe%2FJjSmdyvs5orSHbNEIsS8MpLBRTKzpl9y7SOFaGp82Vz8%2FLh6yrey0%0AXV8Oz1tQZguU23%2FNkEkgSFjWeJwEB6LCKzMnBOXmFPi%2BFqx5S7JphhAJdu6sCTXK%0AZjYkkNP%2FUGsbWIFCkqzId9CRPzR2Q5Db16bkjJmxNzSnYXUP%2FRzI%2FILbvFTtA5uU%0AS9%2FYPTcTXyVQWuU0uPUl504M6Vz7uMtj6XFFbU9yAOlBrimZpJPYHygFvkS7MoNu%0AuV5pwAADkNFxzoW9GxBeZW9fwouL3KrHw52Nl1AkFWmoIshdXqTOpNgi7Xxj8XqA%0AMF56BJYMjxRbQtnGHZoj8jrIwUTDTIYvms7xxJHm5YOv%2BtvAlcBMcaRX%2FpKYtoz8%0AQYrOZATUQs6OjXuWWzydltx4Z334iZqtJPwlJ4tp9AkLVPjhHwB64pAdrVLOwlDz%0AoYXccYJsqWPZhp2ygkQ06IMPT%2FSVKs0poKdchaaHTo8BRDvzC1PoudjoB4SusL5F%0AWG0mZrv3N6yPk7V%2FCajURwrf2i14SV58swwiS05xZDhUX4IOVBFDQEF4EEHbjWvR%0AbiYyr48NZCqQKIUUX7Ol5aO4ogv7ZFW%2FLsviCh7iYENRHcF0RKRXCLnpFNdULXFA%0A%2FAIm3TOX0vp%2BtjpM%2F19%2BH7wmqj1DLTGWk8xX%2FrBsgTbuqhPaT4otQxcwkA%2FzppMh%0AJ9iUYOdWrnHs4DLX7cHoKjwcHkemF7GT6F0ufyQI4MimLp9YJioy0Vs7seZiGBnA%0AyBSFIFn827tgGN%2FbEqNT5JAUcRn3VClhmgA25mPeHtJ0Qm%2BrF2rOddfXJ9yLGJcd%0AcLQK6yPf3T1wqd1rWdgJ%2FLCj%2BNrWWfOgp%2FL9qDrzdTJoTOQZtSw5KVnQ683Y%2FJr9%0AwX3j5B2mgMwT5EfJb%2BQzDiD%2F02Pnitzn42v9FMZct9260HIGWsnfVu2dhXPwbE69%0Ajh8ccj6E1Pz%2BfRcheJCnyMD7YDNO5palOGNQgjtMaFIoMORiX4UYyWsgQVkB7gDw%0A%2FH8TdhsYCi06Z8LCj1XF4qkiTVseikyih3Ro9sypUUeln9QhNrEglpj12xrUcNZ3%0Arap4C4inie%2FMrxZ3IaEKP930QkaGWmP8IdQ3gykz8%2BWVBXwu1OyJdZERjbsoZVTy%0AiO1eE%2Fo2jSpol9KcBD0s9DobHWcFlDhzExdk%2BVb9pS%2F6a37lrQvj59bBQ2aVt41b%0AbTngwnCrMeOWYChecnu078YEeyRVlOItsB%2FTl5qbq4HyLPYfMj53nJtGh6IbDN%2BT%0ABgbKJbmrjpbiXUEWryNJYVNu%2FE1CS9X0AXb3or%2BBBzVqdwioO07m3GUYyMV2hlnm%0Akk0o6Qlxb1VR7CB3PuJOgeUK%2Fn3cqzZcG7q3EdYobjfkM1bGiuXpuIzkOPsD8Gbn%0ADYKjvLts0yO3CF4EdYEKBGnZ7Mo4IL4G0xZjAKqg6jVb9DhiWyVp5R3dcoOBZik2%0AqcQ3iY5cE40SddK0jQYgWRhPFyi9V8n0fElhef0OJL2jLKYRHbxpLM5lgKpnmH9Y%0A2ti%2Fv8l2n5z7wSVBIpHbpYq5LrRdlAwyvSITglf6IHFXiagyJTcL3mx7eJSfscQT%0AdH9RYoAO650vDfhXZd%2FrVgbZsUjr8vHf5SHIS16yZE2mXxIPSBpKJZpTMXJwc9h5%0AYAxwukFXP0k2SUZN%2FgoKg%2BQ7rtL5LbgmOAcPInVxQILv5HqSsgZFwunQ3v8TWtzx%0ARYmdHDGQSyfpAmOEJ5Kpnzqxon59tUdudNSgut9FL8SCy9nC0sB8SxPKO%2FqtLM5i%0A4n%2FPqMutwPsqTW4ugiFuBKvwDQbLhUtlr6BuVP61dhv970TBNZfrfO5mptxdxjey%0APrj%2BP6uKi6RODHHdE8jVvZSrxGRowBYyPN8GpY7pfchKdU27AfGP6p%2F95oboSnQN%0A2MTOmCYO%2BW2aaqVO7xaBHB6slY8OZ0a%2Bb9fk7w5m5zE28RfJIp%2FFNRZXzUmvR5Ek%0AXln%2Fx141yHEl9go1RnWX%2BKuRjptFPN293SXQZCubQqJ7MMAWixTGcyKb8L6V2KoZ%0AWMqzP54Ud%2F%2Bt3ddHC7BxSPkVAgDY%2FrWqu5kBJOTbuHFCrTTFPEQBEs4WZRfiR1FH%0AC%2BKZH3GWBoi6tVGVCVjapGQR9pwzTUpWQ9txN7XC3a9A%2FGUxCgCPDSDKPjjuoBwY%0AreJvP27UiyWnHR2QjcCXAC4lbAC41Gc7Q6ejTfd0HZ803V9bDTrcvsb933rM45%2B%2F%0AYM5mbp2VkugZbSQ9fTNXP%2FiSsZRjhk96I38n%2Fw2ZH0np6m5YcfCdj%2Bd15tYQKe9M%0AyjqTsaxEvncLT9M9RcRgzgnq8gmetEf4ntUC0P6dk4TcSfhqCfg03KgixRNqJEOk%0AYTR7t%2F%2BiV7efS42ppR1XwJXAOVy7S8EGY5iKnoJtxSKMgcWBKUng9v7cPLvuJJ7M%0A%2Fw379Bo4%2BpgXtRJKEQX5wBwbs%2F%2BV67rZAppCJfyrA%2F0k3UwqF7s6%2F1wG%2FPHjpAlf%0AWco17A5UW%2F4PAL4ASUzhSijcdl4P%2FulalCyL7zz0CE9szDTxvGoQcUjyFz4X7k9d%0AQ4h6mFdJGXnAc6KxXUo8hgKzcoP1uUU%2Bb%2BZzMV7iaX6JIA1bq0l1wCqogF6A7Xqn%0AMXzZXfOO3k3w6FWqSIpSwGMo%2FZgdApvQdzsLdcI4WpKQYcvv1kkNQHJsMzp0Av3p%0Awf3e5Yi3cS9c6D68CPiinSKaz5Hh4TWhYdEogKehW4cBYchjst9Q5PpC4%2BlC4gRP%0AvBT5QW6i9XTDprdUhHZxeNtefsZz57kgJTr%2Fhaf1kbiH1ZTcGOsM1R%2FQtl2RB85n%0Ar0RNRxFC%2B6S0B6HbTQFjD0Kfy%2BcuYJY9%2FtvevLRLSlGFjqgOjJmBjr7fmUCCJSIP%0AZkp%2FLF7jBBt%2FtaoUjLNOGQfSYBot9Fhi6DMoQYQ4SJZL9FXpTA7SsugjSvULxXPh%0A6AAmevooajrYvrbQfTlZ1uKoUwZXb4%2Fz6iGgtDuXtilmx%2B04SO%2F7j507HDm4WooP%0AH191ZiH%2FPYEVt3BLERNzVqg5C1orr8yMpeuKvib6YQRk1heXiGPpJEWiSAHKYx5r%0ASkRtowOSymL4PfUdcUzeWtNp7kjpBDX548KWZbmROBM2326ecxKzr2UdaLcYi5Tg%0ABpmJhxP3pySowMOBQOg8Qgls6LJZwLePLBpDS6h6kI67pZlR2P%2BMVpzfN8G%2FDd77%0AG5yC0rMNGhCaLGAbNZYHhHq8z9EqoxCzvVKEyeqh9OTDGUmuytRLnKSijukxEuvy%0AGHXRpkO%2FJWTc0z6IgLh6uvGaHxcswLWd7%2B%2BPoUsU%2FWuFLyt0VtzcjkMFfriRhYWm%0AHmbSVDfZsz3JEJGPRFJb0eU4qgc0qj%2BzFmpSGSeDroZhwFBqVwu%2FXp%2F9dPYJRebd%0AlwFJ9fTjFJkkv%2BsWE17wAjRcHDqdbWk1%2BXjjZ1lnLRCPGLalK9IB%2FIATibk%2FmMe0%0AoQnVGuYABhvpa1CldSy8A907jt1grqx2foQfJLvCMUp0yCmTjdtO3b3fLwySrHh8%0AwuD4V2RxRjjjkzivPyBBA6Cr7rkwra%2F6MofokiUXFNrZZq8PQaoxifwcKMXmmqtA%0Agv18sY%2Bc7gCeQJcFz3VTLCrI22RYoKYuQHCZ0Pp8tQlAkMjcpkxfWR0tQLxpDNqe%0Ajvtqf3hNNW2qu5amEUGXs0Mq%2Bv5v6aRfr9Xy%2BLb0ZNhz8%2Bks7eAax%2B4IsaDbrGs7%0AeIzvp413pFwO%2FunARcBXn%2F%2FE9AVXWXARVqIWFHrYO%2FH2ll9GR0Pe%2FOAPwuEGG0QH%0A907r7dbHe%2FaWQw%2BmMdK5j53PbDYinm%2BFVcTEUklzJ5n1rc%2FvMIyqseGl6MoT%2BKXu%0AuBlSIedJ%2FnNwsu1Oa9l55lklFtV8bHOg5NPj530BIAC4tAnbRhdtoWa0O%2Bz8SYmc%0AdXUdf%2B2vF6BA%2F63YjinYUOX8PreIJVnD8qFpJCtBTT5HRBhaHYV5L6A60lq1%2B1Mh%0ANWmNckKVG6pZDZrNAYfkm0tdYJ8wJOR5XjAstbHFRwbRqWWNJU283v5wuZQtpMt2%0ANXWbUCjMVsO8IVh2VYwftrb1HV1mZYrN0%2BxdGc7mjPlHGU8G12ci4K0BqMqNv9Bq%0AXtu7RO3iZHNc1Ir2Xy9FJBd9ysr3SoZc6C0NmWzFOQ8oMKtg%2BC5HK6joO2Wced8v%0Ad16ghltn0WxLck8%2FloqUMaJZ58GCaJws%2Fxip45PQeWBAWJRvXlqWkQfdiPGp1G2I%0Act29btIAixOGMplReIuwPlCg7R5RaFn28Mt7QFk8NK2kVBd3pWzWtgodeGyo6jG5%0AZG8uZpg872hENmTZYKg4TQDdlCSzX%2FjEAX5VBPFTNUYKSw73%2FCAHZgtHWE%2F3Hdv9%0A5rSokViBqIOrmU5Xpy%2BDfOsRaMEkv%2BpSzElKU7wBY%2BVRDV%2FCBis7bOei70IBsaUw%0AwKfoz9NemxHR7gTi46l%2F5fBjWtubx8TO%2BbtZWd0845hvvSTroP5E0KtUWiqCwq9h%0AWV%2BkBlpu06aHue6abPcbQ2P%2BEXLEVg8r2SzKMq6br%2F3O3NF2uiUIygM6OV81yiqR%0Ad%2Fs7Op8dnVXlnQ5CYViOGMKjuFHReQNCeIUx2TDtlKm61F2%2FzMrqIOopJqbZrQrp%0ApeZNe0YSUlPGzxlAV9%2BlbACf3ZCO6pigogIdoGELUqg2aStQ8482FHupSeSubSD8%0AwIVVJC5bX%2FEB2xY2EImJ%2BqS%2Bv5VjGRTwcW8srEJL3qq2zgn3Llc%2B0k7nabjZTPVg%0AW%2BI9YphTDpfAvXE0rUAocquP2bxjHavW3J3tVLQ8HFCQxxcWFGg686JNDxVqleJ2%0AIBmraou9mLQMU33YLJP1Yc8gRvkOyhP9NkK52mvQDeshYkb7Q%2BmjGnHAD%2FMiAE5S%0ARncixlzbGkGWXFZ2Hk2NQqvWnflt98zU8RDHeqTGss6KL%2FeffmpM8gxK3WIvvnWW%0AfNHuSVUgYjEKhnuouaAY%2BKSjvUhxeF1l%2FeCHYcvtWABl%2B4Q6y4EhzGfubgqbcIav%0AVNF%2B2yF1q5m4c9stoYjzalg4oExlepAdzQ%3D%3D%0A%3DzHlX%0A-----END%20PGP%20MESSAGE-----&message_id=15f7f5f098d6bc36&senderEmail=cryptup.tester%40gmail.com&is_outgoing=___cu_false___\"\n      });\n    }));\n\n    ava.default(`decrypt - [gpgmail] encrypted utf8`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"Prozent => %\", \"Scharf-S => ß\", \"Ue => Ü\", \"Ae => Ä\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_CdqnkNWgHP&message=-----BEGIN%20PGP%20MESSAGE-----%0A%0AhQIMA0taL%2FzmLZUBARAApSOEoWZSpvBNMFPgyhbnMd3Jdv2%2BsQRSs3iX28z6TsOp%0Axq7Gqm1xh%2F27EeJfisCZH9Af1aB9OSQXDzfZG9NqvXXQcsMsp6GcqyzUhxp33VDq%0A5xWRAoS8M4WvEMGOKx2q4ChoBhpl8wloDQtPtnk7cDv3YRgxF0JSkwTy%2F%2Bs6wAOJ%0AX%2FULyAayJ8MgETkRpFgzYpWaWTmrJsdsy91ASJAP%2BKujGn6BNss0LdufWrzOZmxw%0AJ3sX%2FSasurMwwaftRcQd9CVzckrAFeuwn4fCsr4kFdR%2BRDSM7GRPM5rxWnTiulgh%0A9SRTyekvJlpnwbn9K6qPO6oiXVDZmB5Gpl3OuBl5V%2FPazSHpm%2BzPzNxiwlQOobgN%0AP35PfbpJAi%2Fq%2BpSEra0dmU1Jtek7s%2FNh%2FsRebJEgAXwZvuUiTBu2zdIygW%2BItsaa%0AQqvffyZqcrY85Q0KF%2Bz5j7MOYXL0E3bkhEtpou0pjdOEJTsbNlAsFu64oxRjUjkD%0As%2Bfpgv3hnW%2BvYHQy98B1VEz1Q%2B2G3sxmArepnaD7Kylj6mNE%2FI2QPYCl%2FDqxBdZv%0A%2FSKL9D5t6DKqj0cu6TsitWNbT8SOq1oJP97ZUcr%2BNg9YHDYnb6v3mXdKZ2UxtqVG%0AmXzGU9rc2QW%2BltQINpj0uYzKNQiYxXnVaO0eYF4wJQ5EkJeixLltUQKSTlarQKOF%0AAgwDBlAx99b1mtYBD%2F9yAcmyrvlAGEvn5bScQXV0k4KY0n2gpXp6A81uyJAv4iFo%0AUye4LdRlZEdx9WOxpujfLCiGAKaN4tfDoDw4G%2FAlLelOwG87AcuK01EYQOmtVWmO%0A0jPkQJkmQe68Z68KRUlS7BpsLriC%2BfSjbT9wOlhVA6xaA0DQfig%2FhMkvZp%2FA2vCT%0Ax7OE49siG6lyWHhTQXEmXflGm23a3Eza1%2B16Ln8TDUEt3uFiPFAg8Wk4arb2NMth%0AlzPOvLtDjOmVjpbPDtGjmUeCjlt3m%2F3IB2HrII9KZrT%2FnXBb29XenXa4z3Rv8ziF%0AtBNWOXqKj4E0aYzXJKNDvGtK7Ddn4gMgdLfsSeJ4zL9vwam%2BL%2FJi7WPb3SGSew6H%0APKGnOJj2fBMXUnWxzLDf7KZs8Z6ON69P26kYrwd%2BMpL2hkhEi5fYkpHDam7vBUUb%0AYwBUpGF2Msx2YH7suCwaNVeXX%2FakNzeu6%2BxgyocPTDlIPN3C%2BJsZIeglw7lsWs%2Bn%0A3EcTvS%2FC6zIOLTH0fYAES5dzc1sSIYPJ%2BE86nhC8snxnSIsJyaB8OJxSfVUreMmO%0Aw1kiBdMuAtUPOUs3ME9Xaqic2zQrcX1G%2FKSNjsXCNEf%2Fj%2By%2FNpeVP8jtyGFmHdi2%0AIaBFez6rMOQWmEimThz8r7805jvfYHlCWRN1ADSvxtd6pjzUgrdnmGu8mqfZ39Lq%0AAT5PwLztaOjaI%2FhCOdPzjb7%2F5OLvAh8voc6EbEXEHRvg0Ut7viWnSlLw2VrgHXM4%0AuBEEMUtRTaFQr19FKyp698V%2BnMoi6i00aoxVYx5K0fhR28eTiyZFRAYLpo4jV4p7%0AG5wuS2Bl%2FetLDZ%2BKlWjN0OdZn13OIMV0hO12RibB7ixK0dR6aFxsrDvL05RIl6Cx%0A9oLaBTQs%2BQcHTGL88%2BJ0dxY9Q09%2FBkz8VJcIdM8BIJSPDj2Z97FsMPgo21NNR7EW%0AaKY%2F17%2FztFHXXsh4LPYxr8xe%2Fjz8i9PYPCo3VTe4E8lW7r0XbXCsinFtmouO%2FawX%0AZF0pgMCnSfT%2BFaji6THxfeMCQEXH%2FA7HLe32l7B%2Fnhl9q7Hb6vEIJrav7yfSSpp4%0AW9P0Qoz5xXRtphcqE78TXGNlMYGOZjZtMKk9qPeRAfBlf9o0B1TAPAVb%2FcaYbph6%0ACe%2Bd2mRPSHv%2FFZlHtk3aVhLbEVBdfbwculi8OY%2B13EiUuzGahrjWXJU8%2FVj38U8V%0AGt8glmUkshZDX%2B023YJ4e%2FBg3m1ClnavXnW%2BoKDsUfvHOjIBwH1PGjkhnaEqqXw4%0AhHM%2Bqn21KViyDemgxhiff9ruvNq0w0fWk%2BdD1bCuS9JJM3Lrgpq7EduBhP0924Dp%0AlQvDNHMOXqdm5x6cec4ZDJUJVKNt0RM2hi%2Bz1ZWuZKsNnm2WkV5VMjE5m4kVkLKW%0ARzJOpZ%2B8CzMi3oYO2R9BRYpcNjNETXN86mYaMJOBxXyUM1p%2BcNVtqjE2L7EMhy%2BR%0As6sKiDPX1VHX%2FUrIoBiscAJsROzFJ2DoLS21omL6V1opCp5yg66t9P4ksnZC%2FPTT%0A5jndqWbNFVzCsyaGjH9skHwHlFbgwnuonvhwShJIfjEnG9CIKUlsIsHIHxuUKO0j%0A4dmCmfpQVUYgWNsw6u6FZ4mXaTwx%2Bg8e5BjP0xW%2FvQkmsOltZnxt90zp8aujtGyH%0AM741rzKAp40wR7mmd8qiAim399yyLthNSrJOGI4LYbixIMEk0IdiU7BoHvOkNjqF%0AE6cZBgHIstClOz6rYIJmzMeJSD5knjHBO3O4OIlFOtOa47jOrU5yCV2MaUtLcI8A%0AS1YZ75bgznVQZEHS6qNH7lfuLw3DPm5otvYJQwX9Nf2EfNhdp4XKiSyN9GslzpxL%0AtR5FMA2%2B97MAC4rUg6IrEF%2FsvM0I307g%2FEKGCJp9K1MuuVmrUvOuRxDcbdzwTRMA%0AYs7Bjf9jasO1gw9CXE%2FoWPQCERlZMse%2B39DmJkfWpc3jxYLo29OqwKNzyjohr97z%0A%2FffM98dwmkLJYr8Hh%2FSVlKrvq98kA400%2F%2FYo9ZhOqvXhxAC51dn7IdlPL0hrRVE2%0A7E4cHZQ6k5RBi6mRs1v6s47qgUekQAFfhOwNUECvKzuKBFYDtUpwgS32RkytdcRf%0AMwhqau0F5rbghdWpJCY9vffiw3qpTh3q2bMVm0ZRR2SCUtJ9L%2BRC78PStbNu9xr2%0AnvCgqyXJUl0p5%2FQbqLUdtLr5ZRsOsPnKo3Cqmedpkv9p75Uda0VASisOVf64Fc35%0AMa7MzfqLTrPSQSpNfLLc%0A%3DoKrd%0A-----END%20PGP%20MESSAGE-----&message_id=15f7f5f098d6bc36&senderEmail=cryptup.tester%40gmail.com&is_outgoing=___cu_false___\"\n      });\n    }));\n\n    ava.default(`decrypt - [enigmail] encrypted utf8`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"TEST, ПРОВЕРКА\", \"C увaжeниeм, Пaвлoвcкий Poмaн Oлeгoвич.\"],\n        quoted: true,\n        params: \"?frameId=none&message=-----BEGIN%20PGP%20MESSAGE-----%0A%0AhQIMA0taL%2FzmLZUBAQ%2F6A7g5vt9ji%2Fp17TEtJ%2BN0SLKj3%2FSVCBGsUB1OPoG5jXKd%0AURfKPDZ1wwlANopiaqnPOFmXQa3mfLnonvoHlR4oK7LBBJnqxaDR%2B1apxXeKJd9M%0A9zb1QTHmGioOGegJicc9b%2FOtL%2BXK%2BkB8kby0%2FyYVWItwghf32VjFB76UVfTnMvh5%0AI%2F%2B04zxLJ8yelt9m2c6TEpjP8lYjn58ODQgdXr7oYGfqNro9uNKDFJf9mwog7W3L%0AGaA1fGePWvaTnwpu9UZ72qsRn8ON8vmI27gqP%2ByW1drlUYl0gPjhlWy9xR6L1ri1%0AkOD56gLhL%2Biy97Eaer6jTKtuy93esvehKqRldBmIB%2BisQFTR1TV8Ugf3EzTlTW5Q%0A0jWgx9%2Bgl98B%2Bk5Tzh8VoCok%2BXaQxfkKK71LEqNTtAjFIHpzEz1QfSWP49kYBMiZ%0AQ8H39NKYPjLc8vfOWgdDkK4twNUApbjC6plIa1hfQoiktFNN7iRNp0sDiSh2BY3v%0AkDima3Pl1IBlLSZyjZRVlslebzxtXorJSgDHdoZLiyPLDEuzuAHT5vD32HUmBVBM%0AjsB0N2NlvPu9AIZvLtYbSeviTDxri5biy1n7gBNaO6udql%2FF0HObIinm6W%2FAdK%2BJ%0Anh8zmW%2BWEh8xJiTuocrmCIobq7%2BNydhAONV406X5%2BvLWNbEq4NOp%2FgO83vrPeFaF%0AAgwDuL%2Bybr9GbWQBD%2F9eWIom%2BopCTOYs3emdQtp3SzJgTGgYecUpdc09vrZRGDl5%0AUDozj7xeulXkT6A7hJlg7se505CYEtZNGdoZVBHKQxQsqyDBXVReNDS%2FDOf1BIP3%0A5gUIm9SDOFc2sro7U74HThSPePFPslIcl9WCF7%2FZbhwIQ%2FX1gk7EbdREct7f1nxh%0AEsH9EldrNFT79Lt6gZZ5jmeE2YdgSCuFof64cImReMU%2Fs8y5JI6x65IEwxTNHiPG%0AJw%2FR85Bh3bl0N8VlxJKgBW0ZNyJiF8%2F7JuBvsZ3u8Sh9jH9qSE0f%2FIXYvZEfMm00%0AHzMax7jF%2Fvc%2FtW8rTfZzHLxgYCJaIJHAeqnksmf2mfgiiCryVU%2BkOYMNOVYv4PYn%0AEaQLX%2FY34DkoeFDQJnCnC2Vny9CGW6qz1UuaCKes%2FnbQr8sphpfvF7%2BO1dVFqib1%0ASz25tTWQqfnVqoiZaVnQp9RbRN2LlQ6j6YmVap8hLMXPtu2enIvraH9tSKkEiZu1%0A4615OybnIVhYjPSgzrZjihYz8hgxl9EznCKnJ%2BvDTUMl4sxxBnwF%2Br4rDtAs%2F%2FWU%0AeG7QfruTyLZ%2F40tTg16WdrjK4AWHwcQNuf%2Fy22YHP13G3OuhWaFLYLqpgwO5CwF%2B%0AlkROtXdIZcmD8dV%2FjFy%2FmurMIulyRCAHKDGUJcjklA03CW%2FUTe1A%2FX5sIA5GLdLs%0AAXfkl1lNVHQFyGoVqSXW0zUKIi53EkUAC3fbEIK%2B4ljf3Owj9I4M14YbF62Dn1fz%0Amk6KGPOyApO8jH3q5pST2cWGnlAl2Jrwmm2mMPtYKWMSbIHaufMDX68suWS1ZN3%2B%0A1t9LehxG9ruTCrg80t1H9Llaz4rHpho9vXOmIFxPHmREN%2Bqo6dq0cwVb5TkLAalT%0AU795tmmmiI4n%2BSQA8ouPbu%2FvndFQGX1IJC6Z1bln2h%2BxS2HXzS8WT17sWxGKZYiq%0AviL%2B85QMH5oM7mQGW2g%2Bm6LxmAibjmcvYIEPcsOJp5WBMtv%2B6U0%2FHMXJkLWS4NTU%0Ag2beKjmRI9wyT0THkQEBWJ0lcY1Cmbv3k1y7TuhO80FSBh6MUlfFKROsbbgJ50G1%0Ak6%2BuCw2UOH3xWivj30%2FvBU73f%2BFLt99fX8l2xfIxRut3ud68tjVYEtq7j2m5iJ4E%0AZmZdjPbfWa8zpJrSiL%2BTmJUTtrIzp3vuD2YI%2FvZ70%2Btw%2FciRUnCk8%2BvsNz%2FLKG8m%0AwKz9nmnc4qWmRGk3TqEjC47o3N9r0LLTnYh5npena0ns0AIX33w45afjkb0Q8Csb%0ABwzuedgOjruUvOacUo07mNrgjUVDmsGOZJLuQA4KpYA9o2obZw4FhGXrdMgYmp4p%0AnDfTr9nPasfg7Lw%2Bqn%2Fxkwcpc090BBJA%2FAzuCrzYtiKTEH%2B7FojBR6AUaOfsJSvb%0AVvYv8N3TikqYT2gTkQgrwd%2FFtCSkGU4%2FrCIPQzcNdNauL%2BwvayAFVSJE1l0AClRh%0Am1%2FUNvvJ%2BkzSyuRTjWZUHZ10O%2FXdldtLbw5FERuLTI%2BNV2ju1Uh%2Byb%2BPBT3W%2BWZP%0A0kcDFr9MFu0Nz1xg3H9ur1dU%2BQaNIR0vhEvCbQwsthddIu0irX38Gp%2FKbL1f0LhG%0AW%2FCizRuU3IHcnE6FGqAirbMU3M0z0bF7uf10bdCx7Q5obEr6UcvHZbWEp0zuHSzo%0AVl7MxnEJOZaqs79faTP2N3ZXPruZK5O%2FU8s%2FFvm0QOAhnNMGzCRw3tKOPFJYi%2BoG%0A2jpflyaA7PW5aPHRMZjXPqN9pcVNr%2BoCECNFNn1btBCLlqQj4aJ60XQPZPKq4lH9%0AEicKmhnU25%2FP9U7hWpLjSVqnGtJWLsJUqyw%2BQnLh75Zt%2Ba%2BU16q6G9MaYIB2bEkp%0AjLPtUxA0RYVfXn9dvwrq6rLGRXo6dg5VckRkAVN%2FDxi5ZSFfhw%2FpmLRwD%2BwTAQ2W%0ACmRkoMwEpvSAB1trZeZ0iKTP7vl%2FwL5daCgg%2FmpqEj5Fsl3ufXZcWrA%2BqqgTKiK%2B%0AKshS5ZFnPnkC6SWB7XERizeKUDx8V%2BXMGD%2F74FBXlCzw0%2F7wLU2Wal5eRRSaKeCf%0AM7emi7iWR7X0pBQoQCHK6SD7pQsRNowjC54zFmksNM0u9tcwQmOR7hwn65nKmMbR%0AIV2DLHuwb%2FC5%2FYCqgNScENvnq5WRO5TWUKdc5vhpDd%2FuLsrSKB8DgqwTnwKxLiyR%0A7Z8abUs2mdoaEBSFQj4MmZHP87vk7wm8MDkZ%2BZ8yC5PNC9aEqFvNVavoTvfSzO%2B8%0AHIjKrCqZ56QnEFlM2qCfERERzvlVV%2FWYaj95KEV9N2neJrCh8kpwHmaBis21I6KJ%0ApZsbQV9YKEj2sEBtndETXWr9dsaNzy%2BlaUUnRzbrH7OcOq1JQ0GxW4sGHmoky0GE%0Amnuo%2FYTBLzPqhTrnAWaSMoRhUDlQbHdz8lyNyQEmSNAEbmB8zfIzV9Qw31NIa6Qz%0AFISoYR1Teo%2BkbXRvABGqvlaD0VnS2gdgSoCW92PvEwgBvfdKNmOan80PELFaqujG%0Ah76Rt08g0UGcP%2BGnU0iCydjbmTOtXBypFOpXQh7phd0RlknlLhro7fhMlNtHO6Jf%0A6o2y0zcEEu2CzmNiNS7G4k4Op0o8txZjBfCRk0JRmzl8IBiWEk1eaUs11AHlVun2%0AhP9iVyF1PAaD%2Fx2siEi7Y6P%2BMUmLIpZUHQtSartAIsudhqtkbyh9rTWT4N%2B1ya8o%0AQha9O409HLCdVk1J%2BDj9RMDhw4o5oVZ0HryHvw29l%2F7CUe34%2FwRz0fp%2F97Slryc2%0AV85wzRiUEjWNDqOlrgruShywik1i1YDK0ZoUDy2V5otgrWRN%2BFnV1ezbbkp8V4cZ%0AlOPbnRTr0QQQcoHyb5lHolRlhhjHNy8FwEi5y7rtYued1lBBc3tjiNt1AW2QrqH2%0A3QHCaURQVknS%2BW3kvUlfFBSkWHVXeuL2MtKZ204%2Bjyk7t4hz5zJI7P0ZMsITPCfZ%0AVgl7VTEYyTBVDI13T5bAxXzyBLafc7KOqWmo7Rmwhh5ksomEKA3s98CbSATcRem7%0AH%2Fd0CWpBIWYDQh6GhQUwAfqoqFMb%2B2paJoySD3I7oukQ7Mjf61N9ZUsvb85xfDog%0A6E0X7ocyPMsOOJuZUT%2BIO13WDxIOAIedJ9AZ1%2BdqQSDSdYd3R7bfBJaJ831ESR80%0APer2RlkOm5KwHmPBj%2Biby2qX1NFtfUwFaIiZvilDipiwO3vdiQN8tqwCQGUXUwc%2F%0AcgjIUfwsQIZID%2FC05aFh4TOHpxEHGh1zihw%2FjOKmgntZAM5BBxFKRoLRb%2FizmxXg%0A7WpnPwYPqh3NZogB%2FLzT1v4Gn4LfDXB49%2F%2BPpWiymqyitepjfCCLI4Iezgpz4DNI%0AftIp71gI0GCEHH2ZV2fWkZtiMmCuX4BRq2Ck4E4d55AUamlj0Op%2FH%2FzyJeacIZzr%0AgMk4geKO51112xGw5hCWF0VRu0HyoqH44foOsB7JDth2k8WoS%2Fz4aWXGi12aT036%0Agtpqww3ZDXjb9mW5QdsRQ%2F00Hye1%2F4iCEJ97rB2K2XrWBDqz2AZQDC9uXfdyOFDx%0AMGTqwdcQCN8vDtIDOZGXoIj39HKD0KjCwNxzFMbdQngo5y9cBXrBhA%2BAyKOQCNoW%0A1Hq7OROolPfreqheIIqv2zZKNBzkJysEuJbMgHgPJKreBJa%2F7mK6yORaS91OofM6%0AzUOingcNjR0QmLWdxPX9PcoIHsIpQPA8k8KEe%2FtIWhQSciy1ZyyqWrL9Pt8LeupB%0A%2BZo%2BASgwoPSuQpIKdBOcnmqZfm%2FR0V6caQ2f80bIKwafA%2B7KgAiYmi0URiraITSk%0AzAV6BR44Ijn6dBR4MJFrxY3VWXwaJr07EfGuOkkY7YMndQNovHtlZNWtFPmH6kBh%0ATHBhNuHRdpL3Z31gYSEv4bKaXjfkXzG5fotUL5wDUTnit9jtAzgr%2Fk3i1JlGAHmp%0A0AQQquEQQf8aKY0gCLxB13t6jhOSGAriMAm%2B5BYkEIPTditnK7vCG1y4%2BhO7sHYL%0AXKKkm4yoOart3%2FUUtjZSxrIjz97Hd61V7He85zbFmevanXQ7BLBU%2BAh7ppyK4iMV%0A2vWcZGMsU11iO%2FSfsbuqotZYQLQtacpTP7IYtNflWevS%2BPILb%2Fh13DmL3OW%2B9ebS%0ArwRsP59hNFLesJKVh%2FPWa1Orz3rybOhskM4T%2F7jT9OH2DyGgaMnGEL9EISkZ5m9q%0ANTVD%2BHmejta1yf%2F3AMhgYS2rzGqJrjBIfY%2BxciOERaTmV4o8x8ranri%2FsUPEDdUr%0Azk%2BcnTsfvurwjZNyrfRpB5Jcg7v%2FTtAkmftCQKZWPXCQFLwAO9HsLLaQ5PsVPZ6O%0A8OKXKqrARyhuH90OB%2FaeRBqZeisfMpF3CgP1%2BhUksncMGmufhDtTW%2Fs%2FZyIpKN1E%0A87Rd34EG8%2BzcIm7YtlEqJjJKsxohfm4bx6OqGbaUVrOijqK0G43ZWdXZtF1%2Bm4n4%0Ab9NZWbG8l46%2FIRg0LrlNAaNwyJVcmzLhF0DOv1J8%2FmrVs7fXJWKgRw6u5BlxmvC7%0A0zJsarwyqQNhcINF%2B2sxoVNMi0stcN3h6cUlamfX8Q%2FrrRxJLIkU1GzTr1JtEQzf%0AUHxL2%2Bl%2BcTiYTKOFU%2Bi5pIPLo3K0eH%2BWdiG4n1juUUN9ufhAzw1j1eDyxZ8PmKbM%0AmHIpZrao8r1lghni8eFTJwnh8K0KLQcp2DEYGHa%2Fx%2BqzZOZWWrgQTwFRZ4wdp2DH%0AsM5XX9MGu5wl1HGF3bzKNQC%2FSoyWFsrpCESFdTOOMAjBC0BL1Ap6pLtk2AsMlnWT%0APoxmlZ%2FbejCkLRDCJMgcDKXJL1uHf16cjyjTbstDPDNxzcVMISsfBxuYhcPDICse%0A%2BXJ4rxQL8CWym05JEG9OspenjHuuDK07mLNkyDcv0jruFhy%2FVftJnGnmwheMGk2b%0ASFC2LMqYEduYIlc5vSQYajFZnWjzOtxh6CmCDyKPDhhP3jbFEKJix0m8jeFlxlmO%0AqsXNVAO75FKZxTqpBxPpiN3%2BLj7Aa9k2JPGZ0BCT5TdqxLmIUzyKWyIVB7D%2Fg1c%2F%0Aa7qLLtVhwQV3l0ckc7txHVXXMPyhvJK%2FTC3E8Qnmhwb9t0AjdcQpW0mhdQqB6d4I%0A6NfoWETjuyxiCxnJGdng1%2FJhxlRAkGnyOcuWIycv14nfXyyZTR3WGsiCNrv8mrLB%0AdYRi9jMBH%2FSNh7wO4xxYJL5Izpa9uCGPBJCER6LadV%2FrjWn0LOPSq1HT2ZqzgZGQ%0ANtZBuQu%2FB714SU3M8yL1ySEPAqmwAtvke6y4oMdJogSSUMiYGNj8w1SnC58Kin5j%0A3NT%2B%2F1O58EbZ7u%2FkaubgmgQx6kMs7aRO9Ri7Lcalgt%2BA6FkAeCnyiuQ2xbehX2oz%0APZ%2F6DIejX5dQ362rFD1RMemLhi7bh5mIoyQgDz5DziVj4SFIioNv5%2Bn6Im6A3iYb%0A8xsgxlKBOb2REdric6RfUPuIX8tq7yhTGVH7a%2FIXLxhaJHUYJQUQVmhQmLVaQvB4%0Au8zpwVmdr0YJ6B8IaguDwoF7Zr5m3fUVZH8%2Fu%2BqVE%2Bhn8XGzWNcxuUwbU8aNE4G9%0AdAKZ%2FTxCrh%2BBibsTA7LkT%2BODaL3T4inJYrF0xcJa8h1SSot47mc74Ixz6iUoZIeX%0AJIRbI9wcwoJflQvSOy55vHEGBVcYoowab8V1WY4%2BPmQfpZKkSqPuhqToq7PvpSpR%0ARGeHL1v1H3f5sQIbZCKf7a%2BCvoWwcEdsLhKU8mVyrDhLbVj6kLy%2Bi3xADBLZ0y68%0A9kMdegb4bppAMJnFLgHvogqMKrXRTzRLGC09cllK90i4Gp05ez%2FacciXD3oVecvo%0A0icQ7fz3sjpqhghxotS7WqXHYJuogXdeFjSUFKg2biMRPZNEhtoN2ybgpZcWL5Yi%0AeTFzCvIP0JA7U3eMuBpFbZr6hEzzFbqoPcS%2FeOks1h9NiMLggLcZUWrrb5ZSs05I%0AKgKFNLqkQNTeK0r2X%2FP03qFb7YD4Sb%2FQxGqZaan0cNj8mL5BclwBZKM3QouEsbeN%0AqUQ0mdPf7dqRu7KO7rCQFYWYU7nIDOrsppbJ8m4r2sOKXP%2F7YSxoiK5gtX9lTDpy%0AlUGmkR1P3yuSupp0%2FI%2FfPdRQZmVV6yizFNPluDkWC83TTjk39Wd44QV2ZFwAGI2x%0ARn3%2BTZoxunxYWPaOy8wbMiO0i9OIAxAPVnGFjQB4W3eJLVdkwjBGujdX%2Fk1MsbtG%0Al75lW5HAbn5EGvmyRoS4O3J7LF7MFiVxEWbqnbG532w8Z%2FIJYJ2Dc42q8nR2p2dQ%0AlxQ8%2FI4I166THh%2BTmUYA%2B6wi8UeTBtHx69fYK3Xt8x2ZJQh%2BfjWGGeVNRyLX6j1j%0AIjMzsER%2FLiih91BqkekWCC1eRmPJkC2AZVaWlWbutZgbZlM%3D%0A%3DV3XT%0A-----END%20PGP%20MESSAGE-----&account_email=flowcrypt.compatibility%40gmail.com&senderEmail=none@flowcrypt.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [enigmail] encrypted pgp/mime`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"This is an encrypted message.\", \"Not much going on here.\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_tGCJGTMBdi&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20GnuPG%20v2%0A%0AhQIMA0taL%2FzmLZUBARAAmSfoaXFbA0tv0ulFxViTwrDVcbPHaPQxx3vaX2cHLABe%0AKS2P2wOekq%2B8qD%2F72MMWMU%2Bvx1fbVu%2B0MDkAEcygCP1o54mIR8vYGkpL70JaLyMF%0A0jqy8LKfheJO5o%2BdBYMv3rk55%2FQlMgrKSrXUmGr%2FEAM6kLh6UwWS%2FK00TFrwmPAx%0A2c4ngRQLqyHyg9DOLL8x2SkBoPYLHTycKY1oM1CgdwcNqjy5RXDwrN44Ws8HRX57%0APKLgrAM%2BvUv58bThYT2oS1L2l7rIq8S0n2eFI21HHUQFDA3rBJJyvmhV4JAy9BLi%0AUYqmBDjvMtdfn9iBkFhzapORqigAUds4aTiBnwWijgfuzilXq97OTmb%2FHNVvPd0A%0AsXY8u1c6snBqu9vuspu%2F2qXPLYh06H1aQlMP11q%2FhWVfVLnj8vFmYpwQREVe8cXd%0AKVWN8%2BhYiqKoSmu5nKbqwXMqeHjS9L%2BEGZMyiRlSwImUq%2BB9gGMcTBFR2EC%2BOD3U%0AweWhseK9jIOio0otF1EF4pV%2F%2BVUU2gPCZhUrytGItwfcDxyo2DPWUun2SA9EDH3%2F%0ApGf6ODUwCb67gNDDFoR%2BY%2BWxfGCKK1CSPAEHHnKXTUP1483IzUHWxP6R0%2BxhgypQ%0A%2FufEhXOVwEjdV%2BCTMlENeSNpQdNt1tyy2TMhlNd1A0dnRMivvgVpqk2hHH38iGeF%0AAgwDluAOlKXQo5sBD%2FwLeNZiKJznLa65VNzJot28Tc7BOZQyfmtbjF9H46RRB8a8%0AICqu78K8Paf9QBP%2F%2FWcPL0RFvWf42k4fZ3dy3DgPcwZourYKJpvFkdaiIuFQ1ua7%0AIgH6sJjTrv%2BbsBbCNloFTMgljBldmiSXSZPdOjf%2FAt8EU%2FG44Iu9NWzuowMDgXiZ%0AUfTUm3RXdWYYi84WlL1oMWdMTrHmvpd3s1yat4Y7yaBGrlxr0Vep6hmUAXtDqEep%0AcjPr%2BBl0tzXC9XJ9RJsAp03pDwEkfXiSfIQB9yorGF46XOT%2BdRnicwk7HgUQIkw1%0AbP3xsOFpP4R8xda3QZ0ySDmn3E4bAc9T6Lu0qKEBr6cECgZXp7NfJxpjoQbnHxd1%0AqS0FXmbTuHWagJbESHqXtrBBz6Ug%2BFoVh4fuxy5%2Fu3QFMaVFRoAyA3PbUTbOfiJa%0APMiW1nTJG7ofspKgmsg%2BxFqg9%2FdLepgBw2QU0azsbXPmmSXGJEwlzrrvkKz1EiK4%0A%2Fp3r5Agj7S4jXSUsDEhWFmrmqXmj5Sv3EcC2Jew%2FzykWG5NOMxuq4mPTWx1cK1Pu%0AP1eBnzXlHMZWNBvn6lDwPv1CyS%2BT5SrTjxuFmJYs6sPGioVIT%2FiVmAVgh7ctqV2a%0A3daPU5bLEVVH2m4mcMwULbQ9%2BVc1lIbuG5PlJvAYuRTy3QEsGs2VFd2t8lG%2BENLB%0ABgG6E8Ln3ziqECqQZV4WLTn5fRGttKuA3%2F%2BosQBC55%2BtcPsKk6j2J4pxaU8KwK4z%0AT40MKFRpBTNXZQOEWEvNngv3RsM3dp6FvVWgUoUhu6340H7OqASuKd9QoiqIZjXz%0A4O7%2BqVzjpJykiJyXoJDTXBCF9BO9SvxADG9IDTUsJ1iFYRDkWH3jjf29E3l47zru%0A4PFnKMQsDRT9UrtAjNR%2BHD1AZakZczhljcRql83rG7hDSOjBwUML%2FckpJ3HA4wx2%0AbeAN4y8ywJPHWbZxcT%2FwZlLZzIn%2F1us%2FQhYtIfU8%2FhPaU0N49oMVy6SU64KA4rgT%0AjUVhUoBIQ3ivi6hs0GAUAapcwdulEcuvQEJ1JbPXMst6aU5H73MbhjYTNduK3QZc%0AXpokQN8AZYL9pqbUcViMLWBqznuF%2BbOIMKNftEoj9MVPbHVKvHIZZQrKVZb7UMcl%0ATcSsI0Jm%2B5fWkdrHkI51YxcrVapNkT%2BpGo%2BMBzTVtw7oZ844eVYUnF44AjaDEr8x%0AR3lQ%2FHSh4Hy6ibRJ0ZGQZsbAg1SLAg%2Bhg8hzg1uuy9E0MDaI15mdz7FrsIwbbi8O%0AuRTWDQgLQtxCY45xvSmVJqangIg8pkQ%3D%0A%3Dv6vs%0A-----END%20PGP%20MESSAGE-----&message_id=15f7fcace2d72246&senderEmail=henry.electrum%40gmail.com&is_outgoing=___cu_false\"\n      });\n    }));\n\n    ava.default(`decrypt - [enigmail] encrypted inline`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"This is inline-encrypted message from Enigmail.\", \"Yay.\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_vCSPFGeIod&message=-----BEGIN%20PGP%20MESSAGE-----%0ACharset%3A%20utf-8%0AVersion%3A%20GnuPG%20v2%0A%0AhQIMA0taL%2FzmLZUBAQ%2F%2FRO4wLVr52Zf0v6%2Ffa19%2FnoJFsFLIEqsWkX3OPOZfiRew%0AtcI17dq5u854lbuXwSELEAUkhX0NJ2ZM%2BjNPRyW4dqhcuFBebBXN10%2FpzBaG%2BnKi%0ACK3B4mAhqYeFAzVeInFS9MPbp1%2BXzcyPm%2FkPs2oxISk4CUGaFClSTGFUdRjdwVyt%0A06BEVx4o0dvu0em5O4sbmAqAictL9Kc7c%2BBYRmvIBBat2xkJtoOix3HmJBcNR0w3%0AAQxoB1pKkbzqOtweOhcP9opSvO8GXx%2B9vXzSi88PJ4uMKOSFUbtKGavMyXYkKpIs%0AN%2FhYiK4L0B8%2FqcJS6LsM26o0kZsVMg9pz%2BBK3ZspAyq3QnMRGaVezzrA%2BeA2%2FGz8%0Aou5CU0tBXMLbuBPj8qWBBgaDJzWBJyQ9VRNwx1OE4yWN%2BR%2F5H38fy6Z%2FBj8NiueW%0AbSVVhXVdwPzYoG6Wg06CUS%2FuyjTUtUkGGy7noii610XLsOhfOcsBcYOEwFuQ9FYn%0An9x2qMfo71cuWwtDcxdUBfGsoZzJkn1auD6XfHrJY5fux0Ji%2Bav%2BnkWtgRsu2%2FJe%0ABEFikuBYFZxjWOiArGGybznVZXE8m8ogZWYMlyQYybShs%2Bctp%2B4Wx5oNWBP4E0Jb%0AT3qW6GXSreP%2FECfZNUggPgONUYm8YKTZoWgwL%2BsxyDlL6snZMidP4FrC35BnvQ%2BF%0AAgwDluAOlKXQo5sBD%2F9h6N4KWlL41e0jHJX%2F2KbPXg1%2FcU%2FW4urdFxmx%2FHu1y9Y%2F%0AJ9VKYxne3HwJb9BxNu6g1QJirGSL%2BN4dH%2FbaR9Bl01uPdR6KZg06lygWeVRIMPO%2B%0A2ytla9Gx9lv%2BG8bXM1adNVbCeRX%2FILvU13SM4rO2eHvZodBQ%2FYyaQfUOc59idNHx%0AaXSDT19%2FiBVB67Xxq%2Ft4J5n8xWt0b0gB6pEzADnJ92iK1so7iviSxWbn0ld4E9jf%0AczalFCZBb2Hlqlt7qUyOQvqPIw5YR5R24o4TFdtq8DzjLdNfaz8eIlHjuh%2Frvprq%0AxBhdqgWFMc2V8bOPIkQSmYfVQXPLWflnWV0MHuoo7RgW33xD2ASPKHpUX1br65C4%0Ahsq1e3R32tXcOO%2Fbh9SoJKj7vL%2BNP61QYkarmh30yh5YxNcJV33lkmZ%2F4AvF8fRa%0AeeTQdHKdvJtgmMgWuRSeR1zKSIadvylGZotqTI662pfm%2FzGjdVj8gJWvcN4XnAqI%0Aktg3mpI8mRS6yzDLcbWI%2BqFkcAkBfkK3HTw9Kqj596jQuWbd08ORm6NxH2L47BZE%0AfV4OiTm5mJFn2eRakrS9UmYhVkvL9jITXwhqMy1Mj72qxZVnx4PSnn8wgMt0Jd04%0A36QKwsmsl4oaxBAt95QQVu5a3UQa8P%2F2vTdinKaLV9voQdFW5lcOUPVO955ms9Jw%0AARLIm29ptBkVK6N3fquEQQtssR4Zt97HK4O7l%2FYilRa5m9iQFaPIqasHHJaVxhKM%0AZk3zfTTNR8t3%2FmoaSbo45bXQk4Vgmux1ATrNcKjyIRiNqPRz2tbJIc2H05naijsb%0AyTu3s7CnSECMWF283s2Dtg%3D%3D%0A%3Dl3WP%0A-----END%20PGP%20MESSAGE-----&message_id=15f7fcb7fabc7511&senderEmail=henry.electrum%40gmail.com&is_outgoing=___cu_false___\"\n      });\n    }));\n\n    ava.default(`decrypt - [enigmail] encrypted+signed inline`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"This message is both encrypted + signed.\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_NYYEYtuCVf&message=-----BEGIN%20PGP%20MESSAGE-----%0ACharset%3A%20utf-8%0AVersion%3A%20GnuPG%20v2%0A%0AhQIMA0taL%2FzmLZUBAQ%2F9FX0uRThi4ZT1KmNEZYS3WC%2BNoqommn5szVhI72E03HUp%0A3JMub2XMmU80Oe6WybHancEZw3w%2FoWR5CvdQx9414jub4uXxaE91wBuqlS3Ow6%2Fo%0AXfXZAzT0aEz7jXkh9rAZDzKjwqJjD%2FUICHmZsgVsx1%2FZZBYNBpbh2esDFGcCE%2Bn0%0Ahgd5%2BekbNqXU1ByU0eZRMo30u3hw4RAp3dPcfIJO3mTNUTXbAunHztbvGFk1TI2s%0AaSxvJQ%2FQNt4IRMaVG7pl%2BGwc28ymWbNOv9vVQQB80TJt5x7xJ8S6MitoAzTZ0KTa%0Awj2BQ9JPO1fgxTw7Zehab5UhQLJXsofe0WnU7XIxzFYyZdZSGNq6u%2BcI%2BDfUH836%0AUDYyEOhlIOyYf8SCd7B3AT7Wd4%2F5c333EC%2FWnG7W7f8RsdWAQtf8E6iWEDgnGmvu%0A2trxHZdTIOhEqwgwPWkVX0UjBdJ7U8nBhP%2B%2Fcsn2h6bpxOARFpXOwgmlmjjA%2FQQL%0ARgaK0TCy7JcnQ%2Ft9SCGw62YYQsgF8RCUPvmz%2BKpZV%2B9ckwOlj8vN75sxFtitd%2FHq%0AhSVMUeIsgBGvo%2BOxFA%2BNFLQTxd8T9hUNpU2Y7RWv0GLqgQtj6GE7ykh4I4dcb%2Fgf%0AIApF4XKnzGlOIoHNUf9tOnY8JV%2BTLbQl3hnRX64QCNimglagQ0yxe3p5jzX1uImF%0AAgwDluAOlKXQo5sBEACU3rx6u9Xh%2B61DcpUHMxgQ43KqEXWwMpzk8YudWrmNKL23%0Aa65%2FOYpyCBsL%2FD0%2BbVKvLMhmyfaz09M3q5lh86oNrvHHFsbDOKzHlAeBF9x8%2BHOR%0ALANj0TCttNR08e4i3HPbUT6uK%2FfKlHbqA6%2BiKgbBafbdHJreXtKKS7g9erEYgBYe%0AEg14s7X8q%2BnHXZ5sS8%2FptWUh3CoVtRgBsYe6AgH%2B6uDvtQWu%2Bm3NRZZrTBUj94%2Fv%0ABlkAV6ptRbTsBWQJZjRaKGQuN115WBrKAoPzIXoIk%2F3LJSe1zZU9kpmdJ4wrawsE%0AwcMRJSjYWR2mjpIKZZa2UEMaHSNKD0tfMYnt2etvmDrrt1eLMfzd8Nz2Z4rj77c9%0ArfI8nQgTmX5EaHJQ0PcJ0H0Jn514gz3wOh1B8zCD34KlS%2FwRl4v2bc7ModN0pTUI%0AeohNA4j%2B9GamJNoMPbLGi7o0JqagLTPiF4JuuEmV0Mu%2FpjWKiik%2BSi6HIddXsP4s%0AWbPfIVweOhCKfkN161TwSw%2B1cdHOw%2BD%2BPAxMOCpSDU8GOV94uoTL0JtJEdAaZHsj%0AZZbMGC%2BzATIKxpoXIONr5Qwy50hHf%2BnZRQfvfn8il%2FF0Noyg08pMafZmAUjWQgSm%0Au9bE3NkTF7FXYrJ%2BX2687i%2F1KJ7UrjhJQFcz1%2B0wbRmmSmJlqqw7AJKxzO7wRNLp%0AAZlYT2fl7jLUvnq%2FKeEhpU%2FHIQ8kiHC31J8%2FSYBvt1s4%2F%2F0%2BcykA8bKEC43VKZ3R%0ApncO5P3LasxCMm6dPcrWuR%2FoN8UM8uTQjUsxhJlF6fNUv3gDqt0em24ZogKuKpzS%0AIPXX9EGotN5XxKgbCY6lAOiHOjHJ0tfMpPQvtqP1Y28mJjp%2Fx3kb8ul5h4H6Uigr%0AB7u8tHIbR82ghbqzE7vKrGld%2B31hP7sRKthtd17qJPEvDfvwW%2F6C7q8Do2PObVqY%0ARqwzVWns8mrkTuzJgzSUgWCHBU%2FrDVxf3ucVu7bDqCYkWVkm7bd8Gpy0%2Bako87UM%0A93Fa%2Ff%2FTegrWGbFqj2maoPgBVHCe%2FaEN2M2dyjeltqW9ATHyeelq4PgqO6i7CE00%0ARC5ZKpdPkMruroviP%2BWr59oIxEU9YzTVwv7B4jIr3I9ZxFrrdz5xIWwA3kfHoBs0%0Ay8H01tkzJVFlL0tRTd6SZOCMao9SXFa16SAd6boL2rzB4KhQPl2KYop4jFQGPvBa%0AZtlGgI8mjL5UH94YAO%2FpMQb5eB0fYxnZ5WCrjr3PMjg%2Fw9OB8y6DL7cpI1%2F9kxqP%0AfPlnDv%2B6U%2B8%2Bc%2B96s52C4QIpddeAqsyDbiUv3D7KfajhF0WDaf599YK1TAyOR3tX%0AtmCq4JtKQ9%2BHehztvwDM%2FvWf2Ku0hk%2FHjPwJ01ct%2FJLAGm1UeZ%2FjuhaqQldmOMBJ%0AbhSHT9U%2Ffy72GWNiDAeX6f4Fa6aJuOVKYjDUSAhdgGsfdfrPJ7kJPcOOyI%2B%2FcC1p%0Aasvfc9OvJWyZ716Md5j0hTVfKWfXtnhzKcGl8nrA4XYZGA8%2BlZYamefKzIVm46kw%0AowsB15NUI773ZDTddSCL8c6JQuOt5K0G60w9M0qxYouZEnWT4LE8eg1S61Vrbl6P%0A3yiG7MDy2p6%2FFlmCZgDHQRUqkiuCGUVpCwKiZwNzEMqe%2FMNx988dMknwadXEAt%2BI%0AR1xpkkyUDD8cdbb1%0A%3DWrMi%0A-----END%20PGP%20MESSAGE-----&message_id=15f7fd2fd072cff2&senderEmail=henry.electrum%40gmail.com&is_outgoing=___cu_false___\"\n      });\n    }));\n\n    ava.default(`decrypt - [enigmail] encrypted+signed pgp/mime`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"Message encrypted and signed using PGP/MIME.\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_POsACRbHGk&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20GnuPG%20v2%0A%0AhQIMA0taL%2FzmLZUBAQ%2F%2Feb40AmsR8djZANi63cCx4sk2TIlNauZ9OdnqMEbII7sB%0AYoK%2F0KDRnH5I0cNfwpFcmXkUhrSLKtn0%2BfyCrxrxo%2FQZZO8fD78OqUu3ZwC3hFPm%0AOiLlx9oI48hj3Hrw%2F4CU8FQtboMA%2FqPPLqtjnIJLDHQiZayCF6XnokHNF4Cj3wqn%0A4%2BGn8AakUGsAr7iUyIkZ%2B%2FpR0VbPSgejFgddu8H9296o21MR%2FtB%2BFN7DK%2FL7fa69%0ADZyLLdGp5vPHUB3GikAuS%2FpoyggRc%2BlSUa4T6jtjUSAUGtOUWtRgBFLAeeuHoskX%0A6tw5A7OyDBTGyQSWIRb1J5N7P5dXrU%2Fvt97pQhrVgRXxfbeq0OLkLm9G98thE%2B%2FG%0Amww5CQ%2BZNfRMouPzBDPT050TGB23JMTxTx8o3bPLb%2FUCmB2Qhtb90XNcUiyU3gyJ%0APnkI91fKGftT6bG%2F9lk76RusZnEqWhNEsvXS8KF59pj3Ea1cVeowwQZq%2F57C6pWQ%0ANSKMQJI0W3VCCyrxMXbedqbXfVuI%2BmOYt4%2ByRKp0mPWced4d5nV6O8qICrfr3%2Fkk%0And7VtWqRL7nDTbcPWZNSPOP%2FDHj5yZ4w%2Bcq%2BrOj5AtjRsbWIt3NR%2Fpo%2Bhyyu3zHD%0AM4GktXqPxtDZl2HsTC6gc00CFP8zqTKqnDpQRZ%2BKl6xfvemPQLmz4pnrzEyEsbSF%0AAgwDluAOlKXQo5sBD%2F9EObMtDbWnqtRpIIYXp3es47FPBKgR5Ouc%2Fcrtf3K9n168%0AMp7K%2Ftt1JsrCnO4o3ojiIK6O40IilqnhBN3hFYcRPJ2lW2jefJvKO1ksji1q7k6H%0AdmTz%2BjE3mow%2BPAn7D%2By1CVgTpvy%2BNg2Do%2F6UR0dny4Mm7lZhH2l2sCTH6FFXskBV%0A3IzAwSONtwkxpvT7%2BMqcq7k9D5P5hZTPuip8ck%2BIFr%2FEKUaJm8fAnTcbf5tRqgep%0Ac%2BVy4QxKXu6GgTDHwYwHLzVbiPD8GG5cApbpn8c%2BnfKqgjGua0zyYl0FUd023kZy%0A9c4Webi83NVMZDm8%2F5SCHvVJtiKJa0bquxy1aBO5nLlxxnIM6H3oB1UrQpij5oC1%0AktaW08rwBSkDHnaFLfW8bxdyAkjsibahvIW3epIK5aLoOiDkhMIhkKaBvBOOSVet%0AO04XJauG2rAeYF9JFV8FxexOncXBSZfBFWHjeN3b%2BcriKuD41FwLx1nIkVIZYd6a%0AYXxvby7jKTO4%2B8Xy%2B6QuDFPKmUIRbSZZ07n8D6ZsJzwcU4MIBCthM320oIFnD9W4%0Aq6dk56Jma%2BrWsLbQoqh4I1rJ2kJ3yT1jQWBuAwLWz5Hzdomz1Q9if%2BSDlQy9sjl%2B%0AO%2BzKB34vcqfet3wbA44P3ROhmanBa1TOoBG%2Bwkhh8xusHyJd5aU6AbuEoi6XrtLq%0AAS31F9NVnEjnCykrBZIj2B5TlC1mT0yENRyCkqEvmBWVjM%2FxfiW2vBpmEj%2F7rI%2F3%0Ap0eQabbyVSHXngz0IlAch%2FcV8wp58tXkVUpWzn6GU0B1KCxuc7FyPcdAAThNzZP0%0AREhuIRgjJSR%2Bj4okHgJhKnxfvIxqlrnKYNyGWEvvL61D2nBiRlCPGl38CMSlT8eP%0A87hU2ks2I9ztv4l9Z9Ob639nYFBLQ5UlesUgQND6d%2BfHqk3mdC6Hzm2kHHBdujgl%0AFuj66eGrfgHwcNCtQiNkYXcgh6TmcIMvFgOiE1PyE3v6x04N7I71cFgUNkoeo4ke%0A4jjOgGJJHRDofWvTGvT4JtCnoqLPahQWqtR%2BBNMY5phFEVtsfuMND6fJTkzYEDpQ%0ABVM3NmukPaw6LIjlN1EmoeSX2BleqvvDIk9rAt3iekOlioYKqvk%2B7xjS2O9otWX6%0A15mHWRx62Et4RSArvRJdGiUP6UTLqGd89Il574poQXBMBDfkTvf%2BEQwgpeb8WEha%0A%2BtFI2aTMj3mlgskEUXSxtO0ZB7aORfCQiy2Jkf36puEfHwOy0l5YnQshXa%2FyJCQR%0ACIc4H8dnSuQlkgRnSODOnYGqpSqfU%2F7%2BMcM2na1jhsVLX6MPzSr6bOSB3QwTbGTk%0ALdO89dD3dnMeHmVjaKTg5wo6i7k1ERE1Um2gHMlrtW58AZN4KPABp07BXgV4H7P9%0ArkIBP42cfkPoUNJXd0BCGEiOg4%2FNcTjSg1%2FvWuAvmWEN28sABfO81d7ucGZtt1Js%0AuyHpVmumoSD%2Fi1woR58iwSPd5L3a4Ax%2BBCg7t0yTP%2FPJRtX7hvSh3FajNkE%2BexSq%0AJZPLq5CYAPNagBWY%2BYzRWTJCz9nC%2BpuOpxZ08x%2FdzX4AEcwvAG8pg0%2B%2BBo7JwDd6%0A8tm0I5LUXXm%2F%2FVf3AQf0GTfpM61bru%2BTyvjvRhmQJ8S5qwozazZtrJUpDQJDKhPY%0A%2BeMHgrlBDTHtXVLXfT0qKhft1UNXCY2v%2FUUq4C5%2FNjm1KHfMnydhHg%2BvzEg9mE4W%0A2mdbWVSz53XdfzBspAYE88EIT%2F8W2biebllWIuxb1%2FIbIpnkV0u5Gja0OB5cVVmy%0A64zNOOk5sgOIlsEgpgxAU8nHrnmg9585XiSjTSMAfb5h2zbQU0sEkOHvADnn8Asx%0AEWM0iquK7lpMaQKpE554UgBcDMjbZnhss1tZf5uz6SX4YEI2y64kIHXiTEL6sqj%2B%0Ao1XWkq9SDZOuvbq%2BUOgB6yaXwZr%2BB1fj6fGqozyy%2BHbTdg1Y2a%2FbTOG7%2BrM%2Fdl%2B9%0A7BUVZsCiF5Cs%2BVRLNmIpfpH80U4AGHoTyATsybiH9ZCZn8qsFmZ2hNpeWGrM%2FbQU%0A93We0G5lmun1qd347UhncEvfhtyt449iHytWebexzDqDMLfuo5BZtVfe%2FXJFhriP%0A2zFLe9gZu%2FOjM%2Bl6Th6UGJ01jrUmqKI1veai2y4jqzqRZbSg2EinBAp%2B1hI%3D%0A%3DFgMR%0A-----END%20PGP%20MESSAGE-----&message_id=15f7fd3ba3f37cf3&senderEmail=henry.electrum%40gmail.com&is_outgoing=___cu_false___\"\n      });\n    }));\n\n    ava.default(`decrypt - [enigmail] encrypted+signed+file pgp/mime + load from gmail`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"Message encrypted and signed as a whole using PGP/MIME.\", \"cape-town-central.jpg\", \"181.34 KB\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_ZFnrtBtiit&message=&message_id=15f7fd7fe45fc026&senderEmail=henry.electrum%40gmail.com&is_outgoing=___cu_false___\"\n      });\n    }));\n\n    ava.default(`decrypt - encrypted missing checksum`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"400 library systems in 177 countries worldwide\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_DfGthWpEth&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20FlowCrypt%205.0.4%20Gmail%20Encryption%20flowcrypt.com%0AComment%3A%20Seamlessly%20send%2C%20receive%20and%20search%20encrypted%20email%0A%0AwcFMA%2BADv%2F5v4RgKAQ%2F%2BK2rrAqhjMe9FLCfklI9Y30Woktg0Q%2Fxe71EVw6WO%0AtVD%2FVK%2Bxv4CHzi%2BHojtE0U2F%2BvqoPSO0q5TN9giKPMTiK25PnCzfd7Q%2BzXiF%0Aj%2B5RSHTVJxC62qLHhtKsAQtC4asub8cQIFXbZz3Ns4%2B7jKtSWPcRqhKTurWv%0AXVH0YAFJDsFYo26r2V9c%2BIe0uoQPx8graEGpKO9GtoQjXMKK32oApuBSSlmS%0AQ%2BnxyxMx1V%2BgxP4qgGBCxqkBFRYB%2FVe6ygNHL1KxxCVTEw9pgnxJscn89Iio%0AdO6qZ9EgIV0PVQN0Yw033MTgAhCHunlE%2FqXvDxib4tdihoNsLN0q5kdOeiMW%0A%2Bntm3kphjMpQ6TMCUGtdS7UmvnadZ%2Bdh5s785M8S9oY64mQd6QuYA2iy1IQv%0Aq3zpW4%2Fba2gqL36qCCw%2FOaruXpQ4NeBr3hMaJQjWgeSuMsQnNGYUn5Nn1%2B9X%0AwtlithO8eLi3M1dg19dpDky8CacWfGgHD7SNsZ2zqFqyd1qtdFcit5ynQUHS%0AIiJKeUknGv1dQAnPPJ1FdXyyqC%2FVDBZG6CNdnxjonmQDRh1YlqNwSnmrR%2FSy%0AX7n%2BnGra%2B%2F0EHJW6ohaSdep2jAwJDelq%2FDI1lqiN16ZXJ2%2FWH6pItA9tmkLU%0A61QUz6qwPAnd0t6iy%2FYkOi2%2Fs1%2BdwC0DwOcZoUPF8bTBwUwDS1ov%2FOYtlQEB%0AD%2F46rCPRZrX34ipseTkZxtw3YPhbNkNHo95Mzh9lpeaaZIqtUg2yiFUnhwLi%0AtYwyBCkXCb92l1GXXxGSmvSLDSKfQfIpZ0rV5j50MYKIpjSeJZyH%2F3qP%2BJXv%0AZ47GsTp0z5%2FoNau5XQwuhLhUtRoZd1WS9ahSJ1akiKeYJroLbTg10fjL25yp%0AiaoV16SqKA1H%2FJOuj6lT5z1nuez35JjeSpUc7ksdot60ZovMfWC%2BOGRnkYKb%0A7KxFd7uaxL6uOBOFyvRxYeohKd73aVkiKpcWd4orI18FhlftFNAwIdsmfzNc%0AmzTHZaUl89iYxEKR6ae6AKws1wzLq0noarsf2eKBVbTSfmK3S3xFqduKINnc%0Ae5Yb3F5adSj1dUjm1BZ4aqzsgKyBb%2BJ8keG9ESsnFOyxOIUXDM1nIo1IOgzC%0AM928Jb9GVa%2BuhdXRrb5cLjTihTusJN0I8oJrwKkwIpCJVgPMdDLkeubrMBQ4%0Afbpl4V76sOU2Nx%2B6nG2FnFBFBFohOL%2B0nTK5%2F6Ns9ateN7K9VP%2B%2BQcoeqfPk%0AIUO3%2BlCZW%2BtrTSvvFId3ziUVsPTeuAS%2B7nxSMfWZ%2FK9Ci6QV%2FXnx3F%2FqSmuS%0AAUm4zPQ1EjZf1N%2F5K%2BvhcCTN4MMx406VlqtedkXL2KPwZ6jDS%2Fww8RfcmPnD%0As94ct0WCZZtNlnQq%2B5h0ybwTJNLC2QFyrhhPqztVY95n9La2Mw5WITCWzg%2Fd%0AIBUceW%2FOwHYtePyaSQkCnegDw%2F2mN2%2FGC8d0OlwULcTYG6uVenGv2UOUbCr3%0APfy%2FEb%2FVqUEZK00PdvVQV7FWYAshuTFPTqidph04CgQvBpi3SDEEo8SkEIFS%0A%2FiEeRQaWjFEXKUI3FwKXPJQWvFpbrXBOAjnxXXbAFYOLxdydmq1GVl9Mm3GU%0AClc9g6t9vaYDBPx2gN562%2FCM%2FnT8Vq45VHe79XkrrcHDwLn7yeHJScNFsib%2B%0AVvwTPoUftlhC%2Fai21D403TsJpm7ZmPcDjagoIcXrS%2FlN03z79RBmSKFtYiXW%0A4obkKSGow61vMBh2%2FXLVYKJKpYKm%2FGnVlJxA0zQVl558x8I%2FnAMaxSzwx%2BZY%0AwaVU%2Fs5PLZ7Ghg3MOguiRTlflKUQyL0A7NR46OjFgUnHAZRxr4KO3GoxVPy4%0AXLeS4%2BWl68s7QlV6WF1IKCHWEUMEeRRea2%2FOvvlS%2FoLs2MNNWDemlJ4SiXHf%0AxINU38Txo84A00NALbKppsSyy9Gwj%2F%2FrO%2FFcerupkfeuOm9nHFwIQeeC5bWD%0AmmRlC90r2jY8gM%2Fv3Jjy9h8PbXWxh9MUpc7%2FkAcTwdGlMxiVjE29p065qTRr%0AOi6sJ7pWuYTfWldZqTVmaBjlv0zuXQ8Eo8o%2FUSvoTs%2BoihYIMcqReqdeqr%2FN%0Ae%2BsDtYKRg%2FLKp%2FJJ5nAQzVMP67DxkgwLNxx0ijBLysaQmvRlsiYWayxZB1Xd%0ABxA2bjZRvsmww%2BhgSKNlcsiubJGBqfqvgmlebZuJHHSC1L6mdMYgcihKmYAj%0Ap%2BHFLyqgyeRVMdjRHcrEdxNPG4fJmlk1bYiVQQ4XAd72w%2BAHS%2FseZ5HzbAK0%0AomuHYUD5PTEqZ1K9JObSsh3XMUkJK%2Bz3BnrOxnTOOyG2r%2B4FxizH6rfz%2FPgg%0AsPxqxE9ELUlgQe8plcPFge6aN9tUoSe%2BvMtDaEAqKw9JwofBF7jlxTqMMvQC%0AgWbn9x3W5o4VrnpjYGtPl8sh1QREu0A%2B0PUJAKL4A3GSMYRouGewLSMNJlOg%0A%2F0pPF6qB%2BFi4GJ7ju5C07tfr9z9UqRj09kDXJuoJd95NdSiCz6ndugn6gs8B%0AQf%2FXPxZVefeMLiB6p8pG0iZ%2FjcJjyYJLtTg6kA%2B1%2FffmJPfH%2F76ZA9dgEJLj%0A%2FW2u0Lp4NY8cwqcXuGKgl72TVJ34Iawl35Y0yr47k%2F7Y1vEQ5Q3bT7HP5A%3D%3D%0A-----END%20PGP%20MESSAGE-----&message_id=15f7ffbebc6ba296&senderEmail=flowcrypt.compatibility%40gmail.com&is_outgoing=___cu_true___\"\n      });\n    }));\n\n    ava.default(`decrypt - pgp/mime with large attachment - mismatch`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"Your current key cannot open this message.\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_yVMKFLRDiY&message=&message_id=162275c819bcbf9b&senderEmail=human%40flowcrypt.com&is_outgoing=___cu_false___\",\n        expectPercentageProgress: true,\n      });\n    }));\n\n    ava.default(`decrypt - pgp/mime with large attachment`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"This will will have a larger attachment below\", \"image-large.jpg\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_yVMKFLRDiY&message=&message_id=1622ea42f3654ddc&senderEmail=human%40flowcrypt.com&is_outgoing=___cu_false___\",\n        expectPercentageProgress: true\n      });\n    }));\n\n    ava.default(`decrypt - pgp/mime with large attachment as message.asc`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"This will will have a larger attachment below\", \"image-large.jpg\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_yVMKFLRDiY&message=&message_id=1622eaa286f90737&senderEmail=human%40flowcrypt.com&is_outgoing=___cu_false___\",\n        expectPercentageProgress: true\n      });\n    }));\n\n    ava.default(`decrypt - pgp/mime with small attachments as message.asc`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"Can you confirm this works.\", \"Senior Consultant, Security\"],\n        params: \"?account_email=flowcrypt.compatibility%40gmail.com&frame_id=frame_yVMKFLRDiY&message=&message_id=16224f57d26e038e&senderEmail=human%40flowcrypt.com&is_outgoing=___cu_false___\"\n      });\n    }));\n\n    ava.default(`decrypt - [flowcrypt] escape and keep tags in plain text`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"thispasswordhasa<tag>init\"],\n        params: \"?frame_id=frame_ZsfVUZsdjN&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20FlowCrypt%206.0.2%20Gmail%20Encryption%0AComment%3A%20Seamlessly%20send%20and%20receive%20encrypted%20email%0A%0AwcFMA0taL%2FzmLZUBAQ%2F%2BMC4kEIaAIdbuApd3CIf72DSEy9%2BA9%2BKlcXbhbFiP%0Ah6bT0x7PSzKMAraAgIRaUmuX3WojyYmeA3sZOtFw5I1TXo2wX0WUYlWGtXA8%0AsgsQvf3voy46DEhFYKjpk38OqK77GWnU1t4QrNUqjQJ6pBjslo99yx9RvYpv%0At1X%2BN0OLcIevTh0R7tjidPsjQx8PRejhuIAgM6mI39n5YUB%2FVCMqDRrqQzrj%0AcD7%2F%2F4X0eJhTYjDGzrSdLtK%2Fn2zDca2XeHe3je4OtLGqYP19n4YgmjcEVvit%0AQsDorTdXwoDKp3gZ27VmjkL4ua%2BA4j%2BeN78HXAbKCf3Hk0xxOlOaDmAdKvZa%0AXVb1KZNLaAeE62GiEombvFhyihvKBfXxmBCvXBz5x6g83r5idLd7U6Ndafyx%0AnZMPvxs7uutxeJ3HG2oMvWPOhr00FyiJvMG8mfHJh6Coh4RkK%2Fe8oxeZioS9%0AL0ZYNpmukffcxTyD%2Bwm13d%2Bfeu%2F5DFA8SbBfnhEOW80dzpA7COqx42HkOlRt%0AbAPn9Ao%2Bv9hzhDmOrHTYiGBGBzRO53b5Wyp55pyYCY6r4LyR2%2Bs6%2BRrCVBo0%0AD7yjez9AqPw65sYi1qeT4UHtBzTbi%2F7ll3EjtphzLxTv1DyytMjqDUHcg7Qi%0AvrqLY2mfFm%2BudqbdR99WX2WzJijJRBwt5hExJMMA8%2BbBwUwDvb12YPaZjcQB%0AEACdW7%2BIK3RgtLjJmo3V964JR8CQkXq50XzgiA%2BcJOXTN9Jsc72W3Vs1xZE2%0Ap5D%2BI3b9qQOMgzWNpYF6N5NiyWFDtKhGyeXL2zoG8x4COyZb25al%2B%2BPMtTkT%0AKooVSbpYaRif6Q3vWVZ9C29aeDqxa%2FMwxoI89q%2BB0mO1oAweNgk7%2BZmjOeYG%0AfwxkYm%2BOGevabDWZrxKLr3LhhWIFeewPxfzyi3TqAZjEnEwkD0FYssR%2BLtSX%0AIsbXTdkV6j3%2FcuDHLdJ4x9nEr0mefpSNfzIwq4iDYdWR7huGjE%2FTkw%2FSF7t6%0ALt7OwsO%2BDVr40fYOi0vnF5h6GMxCgsHpMy7LC9iCpd0jL9wWvR6IukHOVEwj%0AWPmZ34M627IC%2FOgiuFllVmXdJ%2FbtBVEnLOyr6hvsMKtKqD0cS83FoaY2h%2Bn5%0A%2FG9WzSWjABIZgsQijoAIJc1C9%2BwwN3uUFocrgdF54Z9pbwZHUrnBvCYrL%2FTQ%0AAN7iBvQNkkoFAWeS1JMmGKymR3tqiB8pSQU9SP8rYJhOMcj0oezuZxEZG8ge%0A%2FyUijaF8X%2F7NgfqLoBym2mfoLxk2pEGFuhk2Bbtxi2LeRl5nzpCvO6oEYdYi%0AI1ERyOA39BezaN1kw%2BQrmpqETKm%2BInprCxGA1vUOVmOHO%2F0YHZBaYOIvk2Xj%0Ajkq6kVFmQxjFE9L1IfxbaGkQ79JVAUV9w66wcSz0yULr2%2FU6knQPBnENobl4%0A6fwiBkiSGAvKd9%2Buu6wJaZ5tYPWUP0HAuKccawytNmGREWAsffz%2BnrMsEDUG%0AJi09JiLTQU4ACCacM3hPVw%3D%3D%0A%3De%2B8z%0A-----END%20PGP%20MESSAGE-----&message_id=1663ac8b70e22517&senderEmail=flowcrypt.compatibility%40gmail.com&is_outgoing=___cu_true___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [symantec] base64 german umlauts`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"verspätet die gewünschte\", \"Grüße\", \"ä, ü, ö or ß\"],\n        params: \"?frame_id=frame_TWloVRhvZE&message=&message_id=166117c082a73905&senderEmail=sender%40email.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [gnupg v2] thai text`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"still can read your message ยังคงอ่านได้อยู่\", \"This is time I can't read ครั้งนี้อ่านไม่ได้แล้ว\"],\n        params: \"?frame_id=frame_oGBJClmooG&message=&message_id=166147ea9bb6669d&senderEmail=flowcrypt.compatibility@gmail.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [gnupg v2] thai text in html`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"เทสไทย\", \"Vulnerability Assessment\"],\n        params: \"?frame_id=frame_NBokFyMmgB&message=&message_id=16613ff9c3735102&senderEmail=flowcrypt.compatibility@gmail.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [enigmail] basic html`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"The following text is bold: this is bold\"],\n        params: \"?frame_id=frame_aLOUYUkbNJ&message=&message_id=1663a65bbd73ce1a&senderEmail=henry.electrum%40gmail.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [thunderbird] unicode chinese`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"這封信是用 Thunderbird 做加密與簽章所寄出。\", \"第四屆董事會成員、認證委員會委員\"],\n        quoted: true,\n        params: \"?frame_id=frame_TgvZakuQNa&message=&message_id=164563dc9e3a8549&senderEmail=flowcrypt.compatibility@gmail.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [flowcrypt] remote images get replaced with a button`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"This includes a remote image\", \"show image\", \"It should not load\"],\n        params: \"?frame_id=frame_obvAUTGAJU&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20FlowCrypt%206.0.7%20Gmail%20Encryption%0AComment%3A%20Seamlessly%20send%20and%20receive%20encrypted%20email%0A%0AwcFMAzBfgamu0SA1AQ%2F%2FUx%2Bp8YjoeUUXHd9cd0rWntMM9eNkdWuOVpmURxSG%0A6ayF7lp5Tp26nDZvVmxQE0%2BYskt66vXpbT2BLjVnuhBrCiEkjvLuGMWcXLdc%0AidkaEXswVw9p31VeqrefKvMu4kCqwdHHpiWwf20PKhJQXAzXpmIjlJq1JHbE%0AVpZ5a76Qv2zh%2FxHDHvQQAGmvsjJFzjuClUKtIbqn%2BaQEx7q5zefKB2nObmQC%0AQ%2B5wup%2Bm%2BUaRZ2mwU8KVnjHizHb%2FLQXw8Ei93s0VVclHG2R9OYWZygToIJc3%0A05nk6RNQQYPSEWvsFC%2Bx%2FdkAhg9dpo0%2BPT4qnEdFQstkbzGAZXPxd4AfILPr%0A01OTfcp%2BDteZCaieFFlunwnCHjBRwA4R6zNeVt9N4lBu7Q9Tg0kso3cbkQTq%0AJckLlRQuKXIYK%2B29S6NBFsOndBBbQazGK%2FKlPYCh%2FTBRm6i%2BsQ7vbZOuX402%0Av1RviRc1HQ7Cl3ZZO4po4CtR3kDXcrERpRelUMcxKwQqmTeUQT3MNnZtOdXx%0A93SA9zqnklIuCrSkioL7g16i4cjKsFHwd5EmVdjAQCOSxXMKcbR4jE%2BmTP21%0Ae2nT%2BIIZmotruTp6Z3W4Pxh79BS8HKV8o9NxWlIjLa8xpS1YjA4l502z0vKi%0AFBUZxSC1Srdjlu6Zw4k2SntRDUASXQfMB6FlR20VV3zBwUwDvb12YPaZjcQB%0AD%2F9wEhZLgqSmrYu2dGN7xEE3lMNFuajttH3GDtan3M6LnQFe%2FAkvpFIYdS%2FH%0AgPVLZAJKgSGQySFpCrSc9LnoOlemQYbI4u97imi%2BP87WiZ4Cr%2Buv06NHBjFm%0AxDRIANTHqqatQja7X2mSXbCyXElZs8YKscz%2BaS9rK6S1m6vqmsilb2yRqw3Z%0AZr0eP4D7mpf1HZMZpKZ%2Bp%2BuV7H7FFddGEiekL7IlkyzeSZQYv5kUtXjyOwQG%0Atnx6bo2u99fG3yMa0RNK0enbMBviF5bcCWA6Z0HOfLmx9dIUYi4j%2Bp%2FG7w6z%0A0YeKMJjEFlpPNEhmeDsPJpbF41o%2B7iIzZdBYAhtxtrmZkYk%2BiMbhZtGZG5Yu%0A3v56OFdgXCvkOBMKK0oASoqzPXe0WrBsf41y4Ie97wBBLQ7OnYdR%2BQk0LWjM%0Atwjvm4GPvx3QO6sVi0sRHfRb97PB0QExw8Xk5vS0mKk9lO7pyYiTUiarjNze%0ADCTlCpyExHTNybxjUYcvDr9S9UebA4UzDQwL2V5y1GvPf5yPAV443pqQx6hW%0ApysptKiOg4Nud4b1Yfk4IAHtVesMJDMidowrdmOv1cU%2FgUe2f%2Frz14lErMYL%0AVCsQP7BIN6GkHnuPqrZybiZ02BNuOymNqsoxcQuphFV%2BNv1XyNAKSmbhtRjp%0AXhw%2BsZp0N0Fi9dKQ2ZmimK3nLNLFcQG17x7yBYzZkw04FLeKQCqHfJL%2BsE5U%0AbU%2BTeg1IQ%2FMMovXvZpJf7tNtPjx7%2BRKR0RwbRVyTLLKA6nUjOo34OJIaYHSk%0Ax1BUIC1YrXZTikDowlDNWYNpsySn05g3AFfWgRKhFzYTKX7BwDZnnWvyzi13%0Agpmh6SMbRMKaZSQ7%2FdfP67AyvBihu1B25FHQU0WEplEooMsvHONbHBECk7cg%0A%2F3FQriLkBIJ63YFpHpYBlqk%2FFtKEHioHxCu3noi7Kalkp3mSqLUjW27lmbOu%0A4YPVCw1xFupCglp5YgupuVTpnZt6FPF3uSWDipDgA3ECurBvH880ibOdPvxs%0AhIlouP2DotFvgSROgP5NKLska8a5dW5C%2BZwyEwQNEbok7vya%2BzRd6V7WExcA%0AR7cBywNLyEXgJJ%2FQa0rYd%2FHq%2FZ79HfrvVLvydk7DCRv5OomDaW8ipSI7DC5v%0AlSPLbkV6hghX7Cglv%2Bdnit2KqpzP78xoiQ4N5omUSun6ozS6aOu7zYC%2B4v2A%0AxhepY45%2B1Jc56MEinzq1gIgJ0TdzsnV8OaAnQn24X1g%2FkaWW%2Bb3tdsBfg7ec%0Ak5GLzOoMYopf4TkgJDpDX9oO8hXGFg2MoPEkhYjfsKMQd%2FOHd%2BFAOn3hl2m8%0AH5eC8lrOcaeWd%2B3Wp3wLXx5K4IWWSao1cnUhLWojFNDS2NJD3jItXzR2bTTy%0AbJlg4RgU%2Fxk2fJdMK0meKCsjlzU%2FXEcuv5aXMaUD9CM6XfBybFXyQ7eDzgm0%0AhjncOUw%2BaLsL%2FoHKffoOo53lp%2FiYDLNj35AVUScRCuhINuVUIVOZKpbUAnM6%0AuVuo%2BAgYt8ToSI7gmyNhFG7BDHirhPxFQsmW1IAv3D2g0NxflWD2f2uFralO%0A%2FQuJTaNEbKEOtsr4OKbY8Tnv9Tv%2B58Mf64D2H0KLg8vb8PWKaNA%2BfgRrWQ1V%0Af7s3yXOs6gGdK04995c1NZYsscSpN4X7XkIAmpRVp1nknY9%2FgIqlvjdBsQqI%0AKhBShbg7khtU7yeu1Seq9CTQFDFKPz%2FHG5CSx4OUVPIDnsuwxDCeTH3aNmGQ%0ALR8GVQ%2Fuu8g7eSjh7ab5w9KLyGwyX3VAEzLgdkItNu9pO%2FxPzYYBFWvzyZb4%0AbyjlxtSbe%2FvmHkItEIHZswsYRKPWWTAKqu2avqNw%2FFYI8GZvI8EPY2rxosaw%0AVVeAKn4fF07HxzVgPbWCxS3oJc5qXpUYVvR1B5nF9vHa2UEiJflJb2A7Udas%0A5LqDNcLogNWIhkPWQswIxml2bJVBV32x0YE2Prll6sr7Mtn%2F2PjDFonkebe6%0Az%2FnOOQ3JBC7rLxFjl6%2BQd8ieRKHvzkfOvjaaJEYIKb%2F1cD1mKQD4yfezVGdn%0AybLh45TTiLnWvahRNImkNuDKFGlGcfYYhifvlAVR7OAsPR9tZDJ8lx4vWhz7%0AoXdNDG2p4tzOzNoOw%2FmnuRolKnEOeMFDCKqAf%2Fh2W6YoWkp2yCAb2Ab37E4L%0AKL7zTAF%2Bp3KTpCEk58jaNAvR1TLKYMKB6ABdEQAhep7iG3vAM0wNh2LSVitX%0Ac%2BqOt3QzF5ucRchYnl33EHplwqewYPfwReSDcDZ9BdYZ65sOnj6H618RBUaU%0APEccylO1wv%2BTDwXrlFvdWBG1Gg0G7WhXuxdu2vY1PJj9z53lDZfGa0R1twsx%0A%2BU%2FBTa%2FNrJT1E9mxvUbZvUdI3eNO8LN6zokhqlj5uY2YaOj6%2BhRohMSltoRc%0AJvqXcbDYusQFhe6LjAJhRhywx57w5cqFwFp1ZAYmCay0eBoabHKrTCS6iOE8%0AS0B%2BdnnNq5vF%2BKk7Ch%2FZDLdqY0eQxupGct8vkgEOa5sLcU5GdIL4qYxskqqP%0Afj7hZkDxDWzBUhH%2Fha9GmShF46Ec%2FPDkXA%2FwZoxgJ18v%2BkZhuvl0uGPLWhjs%0ANNV6FD%2BGHFVqEEZxuaVqpVAKmeiFeeu9gErBFv3lbbbKL%2FAHcipCoslfnYib%0A826fC9NUStDxZUW4nqPPCbCBxgnlZn9GNXvjnXiGKi%2FKDVdiQYuiCvT%2FNKqn%0AfvH1X3RbMk64HzZC2Kf%2F0GLtiz0mySO2zS9vQQ4WZZRMyRcGCyAAd5R%2BY%2FjT%0ALsgp%2Bm21y3X05Oh6MVjZCLrmBsD%2B5MaI%2F3Nv%2BmXmKqg%3D%0A%3D%2F4SV%0A-----END%20PGP%20MESSAGE-----&message_id=166b194b21a0997c&senderEmail=human%40flowcrypt.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [security] mdc - missing - error`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"Security threat!\", \"MDC\", \"Display the message at your own risk.\"],\n        params: \"?frame_id=frame_obvAUTGAJU&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20FlowCrypt%205.5.9%20Gmail%20Encryption%20flowcrypt.com%0AComment%3A%20Seamlessly%20send%2C%20receive%20and%20search%20encrypted%20email%0A%0AwcFMA0taL%2FzmLZUBAQ%2F7Bwida5vvhXv5Zi%2BqJbG%2FQPst11jWfljDQlw1VLzF%0Aou8ofoIEHpvoFgXegZUnoQXBmlHGD%2BXLs9jG%2FTV1mtE2RWq4hDtqiTQ6rEIa%0AbrN3Nx77Yr%2B4EN1aKI20aTLEPTIjVU2GH2i9DAmjHteBU3nkL9Z3yecB8Pn8%0AEdhpCRY6cj2yrhJ5MPwmXrus9OFv39wA2DqYpqW5Be%2BKD8mipZ2CtJo5xtin%0AaeEhpWSDsdg26rjx1nz4dA0NcFzZK2p%2FBPfPIFzRvmoXoWFigpUnwryEoCqX%0A%2Ftgmcrv7PqiYT5oziPmMuBc1lb7icI%2FAq69uXz2z6%2B4MJHOlcTEFygV36J%2B1%0A1opcjoX%2BJKJNn1nvHovBxuemcMwriJdmDj4Hmfo4zkd6ryUtGVrMVn8DbRp6%0ATWB%2F0MSE8cmfuiA5DgzdGbrevdL6RxnQDmalTHJ5oxurFQVoLwpmbgd36C4Q%0AxMfG1xEqFn5zvrCTGHg2OfS2cynal8CQDG0ZQCoWwdb0kT5D6bx7QKcuyy1%2F%0A1TXKnp1NamD5Uhu1%2BXuxD7EbvDYUWYh3bkqgslsoX%2BOUl%2BONdtMD5PswArd5%0AKisD9UJuddJShL4clBUPoXeNrRxrU6HqjP5T4fapK684MeizicHIRpAww7fu%0AZ8YtaySZ%2FhoOAKWsx0rV4grgJV7pryj4ARBRa1pLL9rBwUwDS1ov%2FOYtlQEB%0AD%2F47fyD%2F6BvepqWmZXj7VLl2y63eE0b%2F6hf5K%2BIzv5A%2F%2B5l%2FEnjFx0rq%2BqeX%0A6hftYZBUAbbBvKfxq9D5xsWg3tnhFv2sYIE3YpkCSzZpWJmahHwQOVNT0ASw%0AgbO25OiTPlYPqfSkGYe0palbL%2B4T5dLOwVilmrZ2bQf%2FrLePwA4RQpWDPYio%0ANDU0Xfi7TQcHQrZTpwFbVzNPXgCHnQkqF%2Bs0v8RDJHnt9vVs2KEpi49V%2FYgN%0A%2BgZnZOeADL0rbre%2FPrIck1YSjZLbrWtQVk4%2BsCf0TjvixJ7MNjA4NgdZPo0M%0AHke%2F9XBFie3NiZaW%2FcEIVZ7WnjB3IbhkmOMJd4LgdHKgmswJwCYm%2BXvpOI19%0AFzU1vzZmfOA1nEJSuuCDNVUoKYIQA5UEYJrVJeGnVN5sU5jkdlX9xPtYceww%0AYFmLisuf9Ev0HC7v27KwYQRDPNYRA8GeK%2FjY6aZdg%2BVccsnzEigdYL5Tm4JI%0AZrxp%2FG807bZvt0yZwWh0gpWOFgbVgrm4Hpji5ilDyulZSW%2B8nJxB5tDoPzL4%0Aj4w9malje0c60GWNtiyCPLURyN63C2q144UpQjSU5r66oP1yF2A97aXKbf4p%0AqO7cSNWEOTpqJkJrNFVKQdWvXZ%2BmvW1PQFmkkwish2HiQIXmWb04uV1pI8hR%0A6YWk2ox9aZiJ664MpncgyJ5uIMlzVfYrX%2BAZRtBW36RgCTprIv6l1M5NcHMy%0AzEscTaSY%2Fe%2BpM5HzQKSzX%2BzHLa5kk5L7veX%2B1G33saiqSJ%2FfK13%2Bk7qDNZQD%0Anbtaebfh2JS0Pdbub6FUFjPHR5PydU9ltuppGEeYrOe1SxwiZ6BZfIXO2%2F8M%0AhA%3D%3D%0A%3DB%2FNE%0A-----END%20PGP%20MESSAGE-----&message_id=166b194b21a0997c&senderEmail=human%40flowcrypt.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [security] mdc - modification detected - error`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"Security threat - opening this message is dangerous because it was modified in transit.\"],\n        params: \"?frame_id=frame_obvAUTGAJU&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20FlowCrypt%205.5.9%20Gmail%20Encryption%20flowcrypt.com%0AComment%3A%20Seamlessly%20send%2C%20receive%20and%20search%20encrypted%20email%0A%0AwcFMA0taL%2FzmLZUBAQ%2F%2BKvSED2vb9fJMQd6lRTh0idC7srhg4ESSf4ggCXFE%0AdeOq2IkV5dNhgWGGawFVVUTewMh3L3JklDoONlatBthc2OGNu%2BFyu5No7hhG%0A3Jq1GkNwCqex0%2BG%2BGVhlZfN2LOAx855H9m%2FAGxYo6KLU%2BROmPZV8PZo5YJPr%0Ar8TrhhfHF%2FPG4ZmQIcuvPI1e0ivgF74wP4cG0qaPEacvSxQ1ZuDwzdqC1kGv%0AseOTJEhpBG%2FD8YfbzUXVrX4GiOzIu2OhnlKfU6c0BJCTz%2BqmQRqYOZXLvKgd%0AnU0RzfLgMsd7Sy1lCpld1syY3bT4l0FIRWUtVx1NrJ7cluicEPDiqJsEZntS%0AYy1ViiRZlnk2Xvx1Qpsh7fifUS8e9gfwPevYFhZ%2Fb6SeqpRFRDFGa0uP9L5C%0A%2FCcWqiUaLUL8nF51CYzfIMeIEGBk0TiVUAn19mkQTFbtbIB9K3uQHjFzgnrL%0AnLaJ08Eme5NugtJMUIW7bgo4CAddRjj0isFsoesUv75%2FmEsHJ7JRPICnWx4b%0ALPKOyP0anN6TYDgTC6IqvMOoNi0ZPEIpmGmf7ZOWjR4eUT%2B9uBmBHEPwGbLQ%0A85Mcjy1C7X%2B0uUkIPsqXgF7Ya%2FpwTuZ8mDtF%2FFU3kR87y3jlDZ%2B3ltq%2BY%2B5A%0ABJyMGXGf24%2BSquE1Q%2BONIzBwBqwXuYvRJwqA9vOtZ1PBwUwDS1ov%2FOYtlQEB%0AD%2F0R6LMWFQHZQCIFkvXcB5r4X3J68tcLffAIVs%2BJnoyR6JECUuCZJdKLc4Aa%0AF%2BA15GKiOnf5Z8RIg3Fn3nXuyN5rlWOu0yOO%2FXrnCSMHiYErTLUO6%2B6V6%2Bby%0Ai%2BPOAtAWptnJ7rGSAy17ZgIYD9WNPdX8Bv1fWEOJII2rj%2B5CVyBsOZWrnlnP%0AHjHOQ6gHop7bnQlrpmpA95PLhyoW1LkEIoC0jgrGF%2B0QXRqEfdwpQBCklZyL%0A%2FWAsG2GJLrHUgQALgpTys6%2F5P7VP%2BVSOaEnOJJExIZPkRVRFzWlYq1avgJWw%0AEFGmKeg335%2FiThKBFQ8JsH9U22G5DD1BcfX%2Bqtm4n640zC5pHRpLJO6ggiCJ%0AZA1SCtq6TBSF1FTa158ZNgjkiGZfS%2BoZvrMW%2BS1691vMmJrwqiRlPg9PXCA%2B%0AouGrU%2F1FVyRKGx1%2FUki%2Fh9SaxDX%2F3uHOOwJzytNxGMJP%2F4Y1Y6hbDwDzcrCM%0AFlFHXiNbfB3uxiHD9wWHE44z91MkqOb7%2FajoLXA8J8U3KJGFa%2B8JkZleRVnq%0Ar%2FUT8ppv0%2FozWzV59mTulYzRdIPSy6r4V0bH16XGwZtHVrljOi4TrkExB9cS%0ATdcX96RMMYpJ7p7dGcxoHaRBY120BD%2BsJ51jGi%2FYupoZBdbg7KcOAEelD2%2FF%0ALM1LzR9f3HUaYyKvdPL%2BC0OwINKCAZBPShfECZOiqrNWgHLWddAdXqexZFLH%0A0y7td11E7UNcCZegIlwOYksW7yuuCZ2ZLLnfx%2Fu1G18nKBCealqNkaow%2FPj7%0A4q%2B0UYxfZnAl%2FrFuTK9ndd8tWMSm%2F6xzWEbqe%2F8NKJrCwk%2Fnu%2BpvF%2BMuRvf5%0A9DuzZFiNRQSjSxSYvkyLuw%3D%3D%0A%3DvxOj%0A-----END%20PGP%20MESSAGE-----&message_id=166b194b21a0997c&senderEmail=human%40flowcrypt.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [everdesk] message encrypted for sub but claims encryptedFor:primary,sub`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"this is a sample for FlowCrypt compatibility\"],\n        params: \"?frame_id=frame_obvAUTGAJU&message=-----BEGIN%20PGP%20MESSAGE-----%0A%0AwcFMA62sJ5yVCTIHAQ%2F8CkcWeLmCy8lvANll0KbA9ymThNOmZjblBNRZvgT8DqaL%0AhaGXzHaMGHvi0d66P38RXfDc%2BH9l%2FjGtdS1zgiMJMpCUFtDc3OPgOuA93sReqBsq%0A7fv5a%2BLSdfFZUPgUkXM2ur0eA%2BniNE%2BG3mbDcr%2FcuILYI8xTs6xbHRIKVl2G09eS%0ABZMEyqH3duIAi0M42r4L%2FuvABTcEyVKvY%2FQHFmFTj1tSzqSD5PDv%2BnN0ihNR16R9%0AN56PMcZazvTdChhXuA3MNciKoJtbZ785c%2FdwRL8bz8rr7Wj6iF%2B3Qm6kgbkef%2Fo4%0A6D8u8G1eDfSWuwtXVqIOuokd%2FmYgNIVZwt1sJukuGv3eL76b7Mhk3lCEjE8uSOf9%0AN9mbLErel5VUTzNTVpA336aBnMKjEsJUIOg0sU0q8XAKeSjcrIuBrsaKpjq7WDXp%0AFA2eQkpHpwZnlWjVMOYRREdji3G%2Ft32ATTchNXl9zhQsioqQbfUtWkj2WvltE5oz%0AO85ddVUniqpQPdQaojZ5%2BdPZ8SBC%2F4eUp3z4J4%2Fb0fWSTPl%2FtLblFy1HJs0lKG5Z%0A8AaoCGF5TLPoygXjBk0ImikeIGlYIShVOqG36RJlMh4xOQCmY0g9nz9LdCEHJ%2BuC%0AkWh%2FoREBhSMnqlmn1ic%2FDG16h17E%2FtiOuOxsqTfIGlkLSShXDoiTjxgm527FA5HB%0AwUwDS1ov%2FOYtlQEBD%2F9f6jwJxYjdBo2pUy5c%2BgA47BtW%2Fzz12MKhRAHd%2B%2FbVbTv6%0A5JhlBw1Jow0ckjcbnDRqBP9EL%2BErAlc2UzGa%2B42Ahrc2HlDvyMJCcxLt0Fa2nhXG%0AYWGHsQbHxgbePWHozwun2RXaAvvBonhBaYtcn0QPNEtArB9uyO4YqXXoH1%2Fl0%2Fgh%0AIAzuR%2BLNymwdOBXpyiVFMJb6xyQF40aT31kI8Ge%2BUkBbkWDphcEPogd59krBEpwz%0AfBfPdlGoTrSwfbKbshM0kiEbPh%2BESMVvypg%2BPZo1Qp0eXYt7gjlYYqNzQHWobTTr%0AIQjY3T8vml7XlcPzxLFqvQliuIZyRLczvm%2BwDhTj%2BJ%2FdXAK0SHE%2F9XdqKY014j5t%0AWjUfy9iD6seZ85ntAWdxHmOkytANe3QfyVxbO3N31nFe4uqJmW0RaEDx0em3k9YM%0AYLe5OwK%2F49IpUj5gV1R3wnN0uNOZNOdhkyVJynLDJXV5DLoWO3yGMPM3iM%2BZGujk%0A4QrpXjVFscfTHy%2F5%2BbNFGHnapljzli9cbKqt3j610wLQa1pHj6K3xJOANwr0Vdjy%0ABFGwpREQDPceSNREFA%2B7FdPh7WQe7P5NbfYuBXGZZeIvRZ6R0EHi8Agxn1426qYJ%0AEJNr%2BqO2r49EhfCdwbizRLhBsqMJQIirkf5sI4w5RIgpI9ggkv%2FgQiqxvqFcDdK7%0AAVK%2BeZiB2bvY3SVaH49hWaCE1OZ28gDYPlce6ARxznq1eqQhvgUyOffjpDjPgSkF%0AQhQCj6%2Fle9lunPkNKEYUhFr2eBBabBejRAsdLTOslG3yltICpBjHGqOB2CaDlHgL%0Aa5eoeqHusBAx9fmYtd0Zi474cGay8RjGtq%2FE%2B8wDTsupnYGbsHF5pDXC7erW9gyZ%0AMzIE8wAZ%2BIxbhG7JXVtHaPWAbvl1ac7YBV7rpBYRKuvZvDQ9BL%2FtYy59HA%3D%3D%0A%3Dt1CY%0A-----END%20PGP%20MESSAGE-----&message_id=166b194b21a0997c&senderEmail=human%40flowcrypt.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default(`decrypt - [pep] pgp/mime message with text encoded as inline attachment`, testWithBrowser('compatibility', async (t, browser) => {\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        content: [\"Subject: Re: Test from Tom iOS\", \"test again\", \"A message\", \"Testing\"],\n        quoted: true,\n        params: \"?frame_id=frame_obvAUTGAJU&message=-----BEGIN%20PGP%20MESSAGE-----%0A%0AhQEMA1HNSU%2BzzjQFAQf9GFHItnUD5A%2F2Abbh1qwdUdsl8i%2FhsgPwhONes2FIKxTg%0AsK9QbZSEBWh4GP3pPAaM84NvWEI%2FZFPR6Oy%2FYEOakzO681o2mk7mnf6doGnAy5P4%0AUqOoRCYuMxziyooMsWmwNqQLdazv3b5CkpT1uQjGjw9no%2B4038g2UZdyVw4w9m%2Fn%0AK65OHg544PcR3vuLZTiV%2BujQiwDsUddXYcbEOu2jZj3%2BwT6QZ3UoAni4VHQgSjBj%0AaVBgVHpGnBvTiMf%2FV3rEB0btPbBH2I4pE0ZEklXBCL2sMLz%2BGPQogo3FCTcT%2BBqL%0ALJ5AFFm%2FhXBNYg4ZXRl%2BgOhSi9NswPbQyWQ2OeJdDoUCDANLWi%2F85i2VAQEP%2FA5%2F%0AQqa26qcp1yeM%2FGBNMX7NeaZo0RrCqvBUho7Y7nwuwdMxpyN9mnDzcHPdgxe41OZ5%0AmKDD%2Bgjl7RHClEZBFpSxhc7pi4wIiodlIZ%2BGo3g9%2F7Z7XC7erewnc6BHSTrE5AJa%0AW%2FryxsRDrr9FzR1P3aHqssGXfD4J7%2B3BFASznQKPPaS8e%2BBj2ib6ZdKCyQLRFHZa%0A18RZPF6PprQ4oty%2BpqB8Jv8YTFCWQaYQYfVJLgO6pqwZzReOwcSwkipIraMoBSVn%0AsqAeup4ByOVYWmAhxvN5JP621cHPJbRcRgXqC5%2BRvSW8H0lxNVla7X755PhH0ret%0AKj4HR1o1PAJuPtdh0JMg0LSLiuOaHjfg1w5RtGE7ZyD1CbnF3EfLRmRTY3cLRdVV%0AJBvKj41lSd0EStnGxC2YaRTc50dzwE8ZF%2FvTzQbHc469AYvCOjECQW4kYNgusUia%0Aip7l0y2LYtm7S%2FWkNKCDoFF7gVGNOgtIM4nRlmPqp4D2tAGr3523RdzlRa8kQopo%0AqAHmLrS7%2B8HGESgzl452Pi2crm3J8wOTm3SyZOF2Eg7cyvbC75tNDWzK5ixs881X%0ASKNA2ti56JYd3Mg6Qi%2BsqdgJLLtXbsG0JB1%2B7GcBEVldmFBd1VAlM8cwJt6VNb%2Fr%0ADX4Sd5XpF9WyQbQuM9Np0Qi04UCrsnplG6ZaeJxQ0usBr8i9WKgr6EZg9CtNMD2i%0ARtx6wsjqbJ98oMFsDwGT4xauImVej8fiZiyiL4aJWb9RwLTwhNOjd%2Bgv9Ccw1zaF%0AAb%2F3ECc%2F4k%2FQgvPzWl0epomyZMNfYnw6KS%2FLfYARxJC3ckSFxrevPCfX19528WUC%0AdZ88bXAj1J2ktdDegMNlaltdevgz6uP%2B1dA%2FIYrr169AuOz0qsGhuXYSroa1kEhs%0AvvYB%2FpR55gme%2F5TouKH8baw1rK8tCHtn8N%2FUd0pjrc2P169LRt6SYoVqvvueYKdh%0A9rs%2B8KMdqlvzt99Qj9OcbjRIDe4TaoKcOaSFl2UhuMDWVHkgHDoEf4J5Pxb%2B12HW%0AKaxkKAIEZ7rOC5zS7FO3RfxRtQkXQ9TSZGQl1lRY78IJuDA9JByUKpmd7LuCMLJL%0AjE4b6mFx2lKCBFwoDVyPorr%2FkMvaA8idYV%2Fbj4gmiqaVMELjL58lOme%2FLRFFkV4F%0APXifXSeZG3od9bzCwN%2Fbj%2FVv1IlVL5tmh0%2F0FXinUM1LvIq4wk56KuDxCEM7LcTz%0ADyBzRt%2BW3qGiEeq4g6OKb%2BZL6izxBQTV9QW%2BBFe1oHByw9HIb4HStoi2g4ptUDwv%0AV0bvJqBGYfsTkar%2FUw%2Fm5x6CcW0hqd0pfzqTMIah87tNpCg87XTl0F%2BCt0Zbony9%0AzK9Emew4OB8QbVua4EhQlk1lFTw3kQzsmRKpuFrPac4vDI8jltzIfz6%2BCzNNE85m%0ADMiZUkYSgvuv6CRV2g1raAkVGx%2FNdkDdrc7wvM095A3nbfqnTbLYZ9162WRroCuK%0AW428mzpZ2ABLrRKYwGpE7iS%2FInXjyhrSoWRWXaHbUqpz9JS%2BuLhKOtWuony8T1tm%0AGezGvqZGnubcuGkRFgjELDxsgZG9GJ29r56UZ3ImsMXq148B9t63yW8VafVR%2BJvz%0Aywusa5FgAO69nLE38eAW8YpOgRy4swkowC5So2OWfAoZlTVxZpjpUSDTwXa4Uags%0ArnafwYtnU%2BR4fFt9FIoc6Ty3HvmwVGDV%2BfcMPrvzAfLuPgjNXPS7lB5BuZ2foPQP%0A158WD%2B%2BQoo2vDeTE8HOVpZBak595qJ%2FA27kMJrHPqKLcE9tVWplJ16%2FDVX4ceCs%2F%0AJ0viBtaPA19IHnBmkKyKvX3U5iXnLlwNlxwEdACONWbD3Y%2FwcpABwzeQaDJmFnoR%0ADQ77LtvRJodo34BWLYpx804fVqhQ0XyMaux3V9EeIhnTjFguWQze%2BA3gCYbKpVu5%0AQBxJsZagBOWtyVi8u%2FIu%2FxfaZzr%2B%2BzNPU9CCOuEQHK3H6OYjBSWLYOdYG6l2irUP%0A4ARDU0UKuWrRBQIup3y1EUJzdd6zYXBc5Y%2FUrk0VsikCzYOhXxC9H9W3Fn0pYCft%0AW5RlK3p8xKlRacHTlp4wtACvIuIhwhGDvXFe1iU53GfaKm8ZFaHcA7cbDpNTEvk5%0ArMO%2F0vlVxKmyOmgtnkFcgxdyi6vwp6hVMa59toPYqvZYitYRPcyOGx%2F%2FAITDCPHl%0AylTQGm9JCeG3kts8HC05N2QXKeUxhjHorOwhRc6anjmOdBba9z%2B6aK4Pv%2FJp5693%0A24vVNBIe4HlGmf4fAbPLh%2BG6GmN7QAD3z76RYubPmlFFkqqhIkDCc1awSySnsb06%0A9ZrS1kzcnzK8If2ejyL1n%2FuIx2koQp3LQTzZyCtoq8ho7ybdBhxVK5UfSxbAnJoj%0Agb7uTK1C6qh7iqeYvptt9tmcaQKPBOLIk1cpS9kScfTHTtdE9vqna733rx0kjEK1%0AjldIKwxxi5cc%2Fhd3DfsWQ4gHoprZdXdiUMLJqQTpDmVubx2vIiRAarkMNpd8hsy2%0AYFXUfa%2FGiNl2ax3UIX9zMDkaPESBLcjIcUbu%2F0C2YpDBBLKiwxm6QF1vbn5xOGdN%0AFtoraIzWsN93vJskaNAzi54dd2GL%2FAIVNg%2FhopG07B6Iwn5ZVYIBocAC40FmuQz2%0AyLpplIGqeQ6WSegRfRn8dpbii8IBpgYFrxiAD7uiCrZ9yP17hz%2FMhnXBgBBS9wIl%0AurfPaTitmEP7TaYQTpu9GKPtNjmREC0PN%2BoV7jvIofF1Z3s%2BJSnWaZvmLprcvCqD%0ALYplr%2BvCPeMyuSgLyAnGkmHCliKTGoqF%2BHQYXlPMuQcyoA41rIcQlVCv%2BlguzSDF%0AQNhBm8MKI2vaPTm0Y7hXgsDZ1stYftKC%2Bti0ge4vcelhJLisEYEeEMDNgoS%2Fw%2BLt%0AilRS8eJispykDW7GWdMog2La8wZRe0RH%2Fkcuj04IZTjYcLMxvmgk6zCFOlxxyF7I%0AcUJT%2FqKq0LsHyMABziErSsHJHij1bOw6sCaREXvTf6tDK86vNzuyBHTWVGqp1rZ9%0AyuhRuJ36EdbzuVEd0N6Z3RX4PQuG%2B4ueBfhbkfgLJrGJdTfNNhpVXuajv2ixJdU9%0AfVt4NQr2zIcdV9XNAdLRLuhLU5s5kl8E%2B2lB4%2FVWeb4ZA1oq3hCUIpJnZgRJgqSG%0A8%2FXD9%2FlZdzveihMaIJURQBWk2NbGnALQVrk2AjzspBonM2TbH9VugqzWNS66HUYf%0AE1tN0xe%2BahUhPDlD3GmpE5%2FgBnSUt%2BkQNZm1TOP7gocsOteLHfG31uAbXXACsM52%0A5BX%2BPrsnaTohmXnkFhkqJYtEjlsHI0rcUNQf0%2BueuctMyskb81MxCpP4aodpEuNC%0AtgEqwhgnwbiL68JRaao3Z6y7lbfREvJ0P7gevn0iwgtgdrP2nJdS8eUNQumRCYMs%0Am7qKQ28p8fuZ6f94oINHAoOJOe1wMD4j9vRftPtJU6sKT39ynHs2cylbYkFAqTOz%0Ai%2BRhdRbeuKybMoEx%2FSxfoEHh7RABWzN4DI9w2WhdH7L0hByuBT2GRocZDTYjYerh%0AaRrP6ZC4meeooFzGnurqgKIdEd5e76iYjqnVML1E%2Bw%2BCJSRDqhgG55z465ewZBdp%0AFEB%2FyQ%3D%3D%0A%3DVMeb%0A-----END%20PGP%20MESSAGE-----&message_id=166b194b21a0997c&senderEmail=human%40flowcrypt.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\"\n      });\n    }));\n\n    ava.default('decrypt - by entering pass phrase + remember in session', testWithBrowser('compatibility', async (t, browser) => {\n      const pp = Config.key('flowcrypt.compatibility.1pp1').passphrase;\n      const threadId = '15f7f5630573be2d';\n      const expectedContent = 'The International DUBLIN Literary Award is an international literary award';\n      const acctEmail = 'flowcrypt.compatibility@gmail.com';\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings());\n      await SettingsPageRecipe.forgetAllPassPhrasesInStorage(settingsPage, pp);\n      // requires pp entry\n      await InboxPageRecipe.checkDecryptMsg(t, browser, { acctEmail, threadId, expectedContent, enterPp: Config.key('flowcrypt.compatibility.1pp1').passphrase });\n      // now remembers pp in session\n      await InboxPageRecipe.checkDecryptMsg(t, browser, { acctEmail, threadId, expectedContent });\n      // Finish session and check if it's finished\n      await InboxPageRecipe.checkFinishingSession(t, browser, acctEmail, threadId);\n    }));\n\n    ava.default('decrypt - thunderbird - signedHtml verifyDetached doesn\\'t duplicate PGP key section', testWithBrowser('compatibility', async (t, browser) => {\n      const threadId = '1754cfd1b2f1d6e5';\n      const acctEmail = 'flowcrypt.compatibility@gmail.com';\n      const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=${acctEmail}&threadId=${threadId}`));\n      await inboxPage.waitAll('iframe');\n      const pgpBlock = await inboxPage.getFrame(['pgp_block.htm']);\n      await pgpBlock.waitForSelTestState('ready');\n      const urls = await inboxPage.getFramesUrls(['pgp_pubkey.htm'], { sleep: 3 });\n      expect(urls.length).to.be.lessThan(2);\n    }));\n\n    ava.default('decrypt - thunderbird - signedMsg verifyDetached doesn\\'t duplicate PGP key section', testWithBrowser('compatibility', async (t, browser) => {\n      const threadId = '1754cfc37886899e';\n      const acctEmail = 'flowcrypt.compatibility@gmail.com';\n      const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=${acctEmail}&threadId=${threadId}`));\n      await inboxPage.waitAll('iframe');\n      const pgpBlock = await inboxPage.getFrame(['pgp_block.htm']);\n      await pgpBlock.waitForSelTestState('ready');\n      const urls = await inboxPage.getFramesUrls(['pgp_pubkey.htm'], { sleep: 3 });\n      expect(urls.length).to.be.equal(1);\n    }));\n\n    ava.default('decrypt - thunderbird - signing key is rendered in signed and encrypted message', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const threadId = '175adb163ac0d69b';\n      const acctEmail = 'ci.tests.gmail@flowcrypt.test';\n      const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=${acctEmail}&threadId=${threadId}`));\n      await inboxPage.waitAll('iframe');\n      const pgpBlock = await inboxPage.getFrame(['pgp_block.htm']);\n      await pgpBlock.waitForSelTestState('ready');\n      const urls = await inboxPage.getFramesUrls(['pgp_pubkey.htm'], { sleep: 3 });\n      expect(urls.length).to.be.equal(1);\n    }));\n\n    ava.default('decrypt - thunderbird - signed text is recognized', testWithBrowser('compatibility', async (t, browser) => {\n      const threadId = '1754cfc37886899e';\n      const acctEmail = 'flowcrypt.compatibility@gmail.com';\n      const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=${acctEmail}&threadId=${threadId}`));\n      await inboxPage.waitAll('iframe', { timeout: 2 });\n      const urls = await inboxPage.getFramesUrls(['/chrome/elements/pgp_block.htm'], { sleep: 10, appearIn: 20 });\n      expect(urls.length).to.equal(1);\n      const url = urls[0].split('/chrome/elements/pgp_block.htm')[1];\n      const signature = ['Dhartley@Verdoncollege.School.Nz', 'matching signature'];\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, { params: url, content: ['1234'], signature });\n    }));\n\n    ava.default('decrypt - unsigned encrypted message', testWithBrowser('compatibility', async (t, browser) => {\n      const threadId = '17918a9d7ca2fbac';\n      const acctEmail = 'flowcrypt.compatibility@gmail.com';\n      const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=${acctEmail}&threadId=${threadId}`));\n      await inboxPage.waitAll('iframe', { timeout: 2 });\n      const urls = await inboxPage.getFramesUrls(['/chrome/elements/pgp_block.htm'], { sleep: 3 });\n      expect(urls.length).to.equal(1);\n      const url = urls[0].split('/chrome/elements/pgp_block.htm')[1];\n      const signature = ['Message Not Signed'];\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, { params: url, content: ['This is unsigned, encrypted message'], signature });\n    }));\n\n    ava.default('signature - sender is different from pubkey email', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const threadId = '1766644f13510f58';\n      const acctEmail = 'ci.tests.gmail@flowcrypt.test';\n      const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=${acctEmail}&threadId=${threadId}`));\n      await inboxPage.waitAll('iframe', { timeout: 2 });\n      const urls = await inboxPage.getFramesUrls(['/chrome/elements/pgp_block.htm'], { sleep: 10, appearIn: 20 });\n      expect(urls.length).to.equal(1);\n      const url = urls[0].split('/chrome/elements/pgp_block.htm')[1];\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        params: url,\n        content: ['How is my message signed?'],\n        signature: ['Sams50sams50sept@Gmail.Com', 'matching signature']\n      });\n    }));\n\n    ava.default('decrypt - protonmail - load pubkey into contact + verify detached msg', testWithBrowser('compatibility', async (t, browser) => {\n      const textParams = `?frameId=none&message=&msgId=16a9c109bc51687d&` +\n        `senderEmail=mismatch%40mail.com&isOutgoing=___cu_false___&signature=___cu_true___&acctEmail=flowcrypt.compatibility%40gmail.com`;\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, { params: textParams, content: [\"1234\"], signature: [\"Missing pubkey\"] });\n      const pubFrameUrl = `chrome/elements/pgp_pubkey.htm?frameId=none&armoredPubkey=${encodeURIComponent(testConstants.protonCompatPub)}&acctEmail=flowcrypt.compatibility%40gmail.com&parentTabId=0`;\n      const pubFrame = await browser.newPage(t, pubFrameUrl);\n      await pubFrame.waitAndClick('@action-add-contact');\n      await Util.sleep(1);\n      await pubFrame.close();\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        params: textParams,\n        content: [\"1234\"],\n        signature: [\"matching signature\", \"Flowcrypt.Compatibility@Protonmail.Com\"]\n      });\n      const htmlParams = `?frameId=none&message=&msgId=16a9c0fe4e034bc2&` +\n        `senderEmail=flowcrypt.compatibility%40protonmail.com&isOutgoing=___cu_false___&signature=___cu_true___&acctEmail=flowcrypt.compatibility%40gmail.com`;\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        params: htmlParams,\n        content: [\"1234\"],\n        signature: [\"matching signature\", \"Flowcrypt.Compatibility@Protonmail.Com\"]\n      });\n    }));\n\n    ava.default('decrypt - protonmail - auto TOFU load matching pubkey first time', testWithBrowser('compatibility', async (t, browser) => {\n      const params = `?frameId=none&message=&msgId=16a9c109bc51687d&` +\n        `senderEmail=flowcrypt.compatibility%40protonmail.com&isOutgoing=___cu_false___&signature=___cu_true___&acctEmail=flowcrypt.compatibility%40gmail.com`;\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        params,\n        content: [\"1234\"],\n        signature: [\"matching signature\", \"Flowcrypt.Compatibility@Protonmail.Com\"]\n      });\n    }));\n\n    ava.default('decrypt - verify encrypted+signed message', testWithBrowser('compatibility', async (t, browser) => {\n      const params = `?frameId=none&message=&msgId=1617429dc55600db&senderEmail=martin%40politick.ca&isOutgoing=___cu_false___&acctEmail=flowcrypt.compatibility%40gmail.com`; // eslint-disable-line max-len\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        params,\n        content: ['4) signed + encrypted email if supported'],\n        signature: [\"matching signature\", \"Martin@Politick.Ca\"]\n      });\n    }));\n\n    ava.default('decrypt - load key - expired key', testWithBrowser('compatibility', async (t, browser) => {\n      const pubFrameUrl = `chrome/elements/pgp_pubkey.htm?frameId=none&armoredPubkey=${encodeURIComponent(testConstants.expiredPub)}&acctEmail=flowcrypt.compatibility%40gmail.com&parentTabId=0`;\n      const pubFrame = await browser.newPage(t, pubFrameUrl);\n      await pubFrame.waitAll('@action-add-contact');\n      expect((await pubFrame.read('@action-add-contact')).toLowerCase()).to.include('expired');\n      await pubFrame.click('@action-add-contact');\n      await Util.sleep(1);\n      await pubFrame.close();\n    }));\n\n    ava.default('decrypt - load key - unusable key', testWithBrowser('compatibility', async (t, browser) => {\n      const pubFrameUrl = `chrome/elements/pgp_pubkey.htm?frameId=none&armoredPubkey=${encodeURIComponent(testConstants.unusableKey)}&acctEmail=flowcrypt.compatibility%40gmail.com&parentTabId=0`;\n      const pubFrame = await browser.newPage(t, pubFrameUrl);\n      await Util.sleep(1);\n      await pubFrame.notPresent('@action-add-contact');\n      expect((await pubFrame.read('#pgp_block.pgp_pubkey')).toLowerCase()).to.include('not usable');\n      await pubFrame.close();\n    }));\n\n    ava.default('decrypt - wrong message - checksum throws error', testWithBrowser('compatibility', async (t, browser) => {\n      const acctEmail = 'flowcrypt.compatibility@gmail.com';\n      const threadId = '15f7ffb9320bd79e';\n      const expectedContent = 'Ascii armor integrity check on message failed';\n      await InboxPageRecipe.checkDecryptMsg(t, browser, { acctEmail, threadId, expectedContent });\n    }));\n\n    ava.default('decrypt - inbox - encrypted message inside signed', testWithBrowser('compatibility', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, 'chrome/settings/inbox/inbox.htm?acctEmail=flowcrypt.compatibility%40gmail.com&threadId=16f0bfce331ca2fd');\n      await inboxPage.waitAll('iframe.pgp_block');\n      const pgpBlock = await inboxPage.getFrame(['pgp_block.htm']);\n      await pgpBlock.waitForSelTestState('ready');\n      const content = await pgpBlock.read('#pgp_block');\n      expect(content).to.include('-----BEGIN PGP MESSAGE-----Version: FlowCrypt 7.4.2 Gmail\\nEncryptionComment: Seamlessly send and receive encrypted\\nemailwcFMA0taL/zmLZUBAQ/+Kj48OQND');\n    }));\n\n    ava.default('decrypt - inbox - check for rel=\"noopener noreferrer\" attribute in PGP/MIME links', testWithBrowser('compatibility', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, 'chrome/settings/inbox/inbox.htm?acctEmail=flowcrypt.compatibility%40gmail.com&threadId=1762c9a49bedbf6f');\n      await inboxPage.waitAll('iframe.pgp_block');\n      const pgpBlock = await inboxPage.getFrame(['pgp_block.htm']);\n      await pgpBlock.waitForSelTestState('ready');\n      const htmlContent = await pgpBlock.readHtml('#pgp_block');\n      expect(htmlContent).to.include('rel=\"noopener noreferrer\"');\n    }));\n\n    ava.default('decrypt - inbox - Verify null window.opener object after opening PGP/MIME links', testWithBrowser('compatibility', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, 'chrome/settings/inbox/inbox.htm?acctEmail=flowcrypt.compatibility%40gmail.com&threadId=1762c9a49bedbf6f');\n      await inboxPage.waitAll('iframe.pgp_block');\n      const pgpBlock = await inboxPage.getFrame(['pgp_block.htm']);\n      await pgpBlock.waitForSelTestState('ready');\n      await pgpBlock.click('a');\n      await Util.sleep(5);\n      const flowcryptTab = (await browser.browser.pages()).find(p => p.url() === 'https://flowcrypt.com/');\n      await flowcryptTab!.waitForSelector(\"body\");\n      flowcryptTab!.on('console', msg => expect((msg as any)._text).to.equal('Opener: null'));\n      await Util.sleep(5);\n      await flowcryptTab!.evaluate(() => console.log(`Opener: ${JSON.stringify(window.opener)}`));\n      await Util.sleep(5);\n    }));\n\n    ava.default('decrypt - inbox - PGP signature LTR', testWithBrowser('compatibility', async (t, browser) => {\n      const pgpHostPage = await browser.newPage(t, 'chrome/dev/ci_pgp_host_page.htm?frameId=none&account_email=flowcrypt.compatibility%40gmail.com&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20FlowCrypt%207.7.7%20Gmail%20Encryption%0AComment%3A%20Seamlessly%20send%20and%20receive%20encrypted%20email%0A%0AwcFMA0taL%2FzmLZUBAQ%2F%2BNDBmw%2FZftQUnEixSc1uT7cjBT4kLdclSiKHVjH81%0ARZPX%2B6%2BUiqOg44b3JzFnWhRW4g1c8qdmRPzy4IRmdg4zYPrpu9hbg7HSgGHy%0ABeWY9OInCkFwXm8o0ruH2yENYTt55Jxd5S%2BSEjSeqcY4TftuY1D3z0vYqVMV%0AblTm%2F7WioznDWzLISZHSuceZqqpUuFVhyVe%2F61Lg0cc7kMRq02BhucjdVuX7%0AT0nUKKVbquf1Tp1JgllZj15hhB0GoyG6WX8l3RMdjUunZnnWSKJmUHu%2FTjW5%0A%2F9aYvfoZ6%2FefM8nYVZNRcxY3kSSGdvu%2FIrrL6qmK0x894R3Cj5K872yW1ABd%0AnOY%2B6moKiOKUdaogTSSmpE86kLycfEk283GkhpRNeE6zRK0Dx5Xg1AE9veDc%0AqwdVqYBnpNPNbxe9qkNW3mBJxnuP9p1qFJrwCu5u2gbKj7RmB0c66cht1m5t%0A9hTfEjai8C%2FWc%2Ffqe8JVv%2B7XDtAhnKO%2FfvqAQ7QcJRM35NiQEsU1L03G5iFs%0A7dd1tKr%2BCPdtAmBjd5IdCv3L%2FU5RANm9poBwMEPKxI4ZmkYDwuA6m112Wsmw%0AOVTYEE5P8mdqK7k8LJQpgfN9V0jIIEi6gdIyZta%2BDeEtp8lxGaZJ7uPPCWrk%0AV2ZnCyFYIdj4UA3Cbux%2FSHRj2AcqKY3RVlsbhtcXNVTBwUwDS1ov%2FOYtlQEB%0AEACB3W3aWAHJbiU5IggPnYL2aOiH4iGS6FJIOAxF4mNywxst9acQBckwRy%2Fa%0AQvyOXUzj0md8pf6i7RsjRR6nMspdxIiQ7W2hM8qbJQHBc8reiILLa3biptOQ%0A%2FC%2F5YA4xcEr9rHD79a226byqTDeMuF6rT3HZ97d0WGbptJhUBskwAt0bxbA1%0Aqj%2F6ksgQ7WBN%2Fw2dCljEot3XeNiMuYV%2FczCpXpoHHJMdyIQmO%2BsZ%2FhcClEpb%0AAIabJFVNmS42ddQDs8uzoxSXiPzCCTyHV6tWZBvCByLwJ7wRX0XGmlZXiqgY%0AlMi085WbJiyUghf%2FHZaaHfRIkvCSHol7JcGcqy9uXyC8Qan%2FUsaH%2BpCQ1BOH%0Ag1ojTcsQwEJD4zuv%2BOZKNQUfT91%2F%2Fp5vIkPpv8qkWDmnMOPyzgx%2BZInxVEd2%0A1Bc9%2FlFPtQHNVw1Vp2MEOMPWPz4qYqR67zMdBbrwjAw1Txd%2B6nglg9Dn4KWb%0A3zuiOx63MR6g2q2aH3hpoUmuxcaoAj5xNkzNLiVDHR5a1seKenSE78E0%2BYr4%0AR9aQ9voXjM13cFcPLTGYjplhfIbCM0Qofqip0u%2FRtALNZJ61vzeP0R23%2FIa%2B%0A4ngOoPFds7nQ4I1bjsF%2BVQsz5ciT%2F9soXQe5%2FnJtzXSaPyyFnRT%2ByH7AiwOx%0AvZRhJlV7zwCM1YusA4OAgphj69LHiQHYfiwQytZW0alqsn2Me3jGrr0tQvIK%0A0B%2BKuxlrPOtc9sBvRzb6s8upq3IS1zKbTs6nxZaV9jhOu1GS1RNWIoLTrfnu%0AE5twD1jADlghs6%2B4mlzT4QxlBjeLQ7TXmVnip0Pgp19r6cfT0d0mvHPEDzQ%2F%0A0fD1APdD31HJ2Gtov3Y0ueE082VgkT%2FNgXQWkm5M5uPSp4CnrylABZzuYiFo%0Aypue%2FPffySAezZq%2Fa4pOxEYNgNuJkfKH6OY4pTlPLdHxVkUemA0P8wRBzYs6%0AB05xPn0E%2FjqpSCiz6cmxbCd7tuZCwNOtY2mDg3Ca67%2B9xiH%2FY%2BKVp6YKiSCq%0APE7tlnYdcOhwK%2FVdbENIPbypyEfTVV65%2Frla5nfh8SQj1b%2BTcc%2BopjzkKIbv%0AXkfOfPvmVUcZmv5Y4W54Lj6QrCht2EDQ12bQW5pSHPBcpQRC4dBXAKsd5Cv3%0As5e%2BgrGJeYFnqSmROzhIEEyxWVmQY9Q9aDoFTY7LO3bESRCZXj00NT4ibf7f%0AVPUj%2B3TheewMDfGNkzDXwoMqAhhsR%2FFaUUwY2JV3arVYrGSuf0VgR1lAOePW%0AEsTznRwZFTtGlTB3dW6GLf7yTHlZTgjp38AzqFPKwfNGDJsfFZNU%2BogP4ONT%0AKJr1V5AqmZHhLYfmrb3fAxfYjv%2FvWP2In08W4DjUSC0Upogu47baPEr%2BHO3J%0ATNJOjvd2PbVVZkDc3G8y0VEWW%2B886XLFBSlkUnNi0owk2usdnl88B5LYZzJb%0AeLn46M18nwNcvlNrY1BbR%2B2wR%2FzBx1iZHY1tK0Vip7Z194%2BnZOaC4BVvQpyq%0AWQj12pRDaSpsXm0swx6kfdDvY8K6EUf0FU9ZYJEJu9BpdDUpQtqb540QxlAW%0AsvkQKFkmXWA1D%2BtQeRTEC%2BLYrnKBc4nL66Gj49WV85P4lRVDYEAf6%2BfDj%2BQR%0AClt97K4u2sahOfLOepplohn9f19TeHR2SyquRobjignMatjlQgOo5ZkvPFSx%0Ae4Ym4GoMQUG2eUVznYaOqlNbDk6Fzk%2FpMBQYECMUUc37NcMJ3P9LJ7BlyIGF%0AoXlp4D7pnMs18yb6uVPetaaAEAP4GwOXPo8DPZmGbcuIpHJOUQkv4I7Jd%2FBG%0A4ygE2LmcUhBOsoko%2B5B9qLzF2jd6O5jeQ%2Fz8R%2BAmxsVSQQZkiOmvbME1npq0%0AO8s%2B4lVZ7yGRPSihQb8kNMA20T248p6JE1D1fKUpIvflHuVR1VSiQ1xmJzcz%0AfaiBDJXyLJNv1nDYV%2BuKQUA66ZvaDLM6E9FEfm6yMuTcANlzU37e0MDyvzLo%0Ai1qOnPZW4SN1VPHMZC%2FKbweIFAI4PIKft9ntujv5C0f2%2BNGRRSdoqX3ViYmp%0Aqp7pB3X%2FUprSI8ktdz4CPD9aPrbQKMhc4MMsuALEk%2F1WKFU9z5fPSj%2Brgw2x%0Ali0P%2FQeWCDaPGsC2zVq%2BRhSMiZx41svU8PtSG45w06IHl%2BwC4zSL7Xms8rg0%0AXvvXItPopXWq%2FYoAsCHU4FTfXBHInulBupF%2BQEsUKZY2VJN23Z3%2BoG%2FCO%2B5g%0AeDJPUVBDZjQyZRZHSdBqacT9OBYFSovY66nf9vn66Uw%2FXVkuly4qFpOIaODh%0AhXL%2ByjDXoXM2UIutUBjz0PNIB4KlkTebAdpFydxWY%2FW6JhONRm5NmaT%2BJjnx%0Arw4U6KBNd6vcuFKlPE6H95X%2Bp23uVSG1WgMdyo88nru%2FfFHIOtDU7Z9GlbGC%0ANSz2qcWYe62Sg5o230pMjTlwVzb9tHrrzhqKMyRF3r%2F2MuXKqEDTAVIoeA%2FB%0A3Wj11RphyMxblxMXdbkyhTnNhrUi4%2FK%2Ft8MxHNlbHl9n%2F%2BrooikhZjSILBFp%0AIgyMHkXUE2TGShmfzmhp6imr5f1h4gJazh7v7BCrrrMT%2BLMJSg5GDCdTimDj%0A9gaZLDwpo8BLEPt5akDPEWPtb1%2F3lVo2Z7iApb6L6t%2Fac3O7%2FZyhqeT94gk3%0AEvexMYF21%2FvIUH%2FwDctygxHZB1scNA8S2oyBSJ5j5CNT9ePvD0AjLxmSVs6U%0ADsrdyUN%2Bw9S40xPPp5cRi6Xln41hpz%2Bkxnf0RQu532Gf6j4UvnFKnESXYAMO%0AE48Dh4ZgBjiAXes%2FWVk2lxKwXlF2d%2FCyZ%2Fb2uwMkROOGVyhtkWYN%2FZTkxM8V%0Ag3vG0XSgciSpvU%2Bkjr6i%2FIcptzdAGbEd067ontXAzoGVuDETlThGGHR7fJKW%0Ap7EOke%2B1RAZUxKCGA59aTVHp09ZbACUgcnhzq87lMMCkWjty1%2BA0ac8xNUib%0Axs0hQEvBI%2B5aCog9A%2F9oTNBolMVD%2F1Dcn00%2FpVpHWEAR23rdC5hTfgfACF9E%0APJoZ%2B47su0RO2mU4Nxf0YHhV4cEs%2F99hstg1vMt%2F5hYvUJtDFnTWAu2ucYFI%0A4ggXVzZ%2FLmKsn6DlCRP2wDDTlusKe%2BFr7KizvnL3zz7HHnKG2L7BH5Niv%2BIq%0AHfUKMEAGH9mmzhrkwcxyZ3EBTmLvW0QWEQoaHeSoPtEyD9RFiH%2FjEWvxT0Sb%0APftwAfgJj4cwnJVHrZ8zVrRhvKnnEfUROLNyDIaSN6Fm6hCVF0gQRWrMpbnc%0AdeRFbO9jepbHWlCYB4bFliOYp1gZwJZ7VvnMt54jILaYCJI%2FjI61qRJK2plz%0Aa6Slackh%2F48U0KaMPqO1nMUweh352r0lYdoijI%2Ft%2FzbOsgPwJXXgsSCURWPD%0A5izd9%2Fnl3dfvETZ0GDz83StxKGP6rno5lJpAARlpm9tKgGZJNvwbepzTi6ZX%0Aly5V1bf%2Bqa5wBLjs2VAo1nSClR8yXq7YgcR6XD99FDWBHALI%2FBUblsqT8RHH%0AWzOaaLJlQ666KNtdwp9G9LFgaWEtADfCd%2FmClw%3D%3D%0A%3DSUpO%0A-----END%20PGP%20MESSAGE-----%0D%0A&senderEmail=flowcrypt.compatibility@gmail.com');\n      const pgpBlockPage = await pgpHostPage.getFrame(['pgp_block.htm']);\n      await pgpBlockPage.waitForSelTestState('ready');\n      expect(await pgpBlockPage.hasClass('@pgp-signature', 'rtl')).to.equal(false);\n    }));\n\n    ava.default('decrypt - inbox - PGP signature RTL', testWithBrowser('compatibility', async (t, browser) => {\n      const pgpHostPage = await browser.newPage(t, 'chrome/dev/ci_pgp_host_page.htm?frameId=none&account_email=flowcrypt.compatibility%40gmail.com&message=-----BEGIN%20PGP%20MESSAGE-----%0AVersion%3A%20FlowCrypt%207.7.7%20Gmail%20Encryption%0AComment%3A%20Seamlessly%20send%20and%20receive%20encrypted%20email%0A%0AwcFMA0taL%2FzmLZUBAQ%2F7BySdCnvjuSIrgAupyKrLQp0U21YI7mMlSIpxgVzi%0ABIiqyItURKXSoO5C9B7%2FGxiR2KEVTeaIbPRxQFuko6cRRL3xSlZOMjA8r8D4%0A%2FQKSUXJizJlILZw6gXlhiePCc3oYTgy9E4lQQzHViucerg4vRiKSttCOFwR7%0A7XXBAnkm1hmpq%2ByXREmkMieXHvarwt6tHp%2B6oiMbHt0i7orI%2BMqGRo6y2899%0APurnPLzyUZ4qIDB9ssr8PWQSa55IOrBdqh0BtTj9A2w2uEh80vALV%2Fk0zTQg%0ABBCnKf1BF7h6Yx5Lx3vOOfkKtTdJi2dOYkyAjNZwS9ANuku%2FfJ2bhyMoeV6g%0AY8%2FOvnTr1Qb0cbWf8CAInpSjOI45x2Z6nTBgbeTlPyrcT78bYPpymnflet%2BZ%0AHbjcjefofFkrNOYQp4zC8%2FSfv5ulR1qA%2FmlWpYu97hPgjJPDhIFtOw0OXP91%0AlP6oJ2LnB5hQfc7lxAv3UmT5DKGMXsR5z%2FaDmnhN%2FL6n6UeY8M6lwkYhxSon%0ARoYCQKDCn0WSwvzjeQpP1A5RmU0iqchOpzZjDLTpy6P9l51JovnhhE9qvOTt%0AfzooySj15s2iGUTFzlq%2FqTvxn3XsAGLLgOshi99NhUZzK8fArljmCfLb%2Bhg8%0AAa4hkmveB%2BuXIx8mU1Bkm%2BfYYUIyqKFgiGXoNnn4pibBwUwDS1ov%2FOYtlQEB%0AD%2F9q3LKsL3E1IrrSkPfyzp3qL8%2BIM4CyoJAaLIZdNRy1b4Oawz1uffFEBWhS%0AOpXemnL1SJxAgnQHTXARd1FWz%2BVWPtiZIoAcru6YhPOalAHzekWADtHqvuF%2F%0Az1JvYul5ColsFAj%2F8uqK86365TR9FHaf%2FqRRgXLGP8G%2B%2BW%2BmkGWBcQtjn06A%0AE7zFLCvaoR8rN0dlm5pXo06Ok%2FpsYeT6kYT1FMlI74E3lB271yXI50RnThA2%0Ayr%2Bgd1%2BV9CSW2KhhZbVeFqviGG9KpffD9AryWeZ1tPReVGZSQ32uwJ2FWQ%2FX%0A9cTNjhRSNivc9Akoqi35AvUQN6eRLtPvfnOxWeMhFe%2FBMkvyHgKj23cDub0p%0AOVv9uWQAkWDrDy69HwJny6ulcipH4P73uWSg3sVvsZuk22Kk9Q1Ucbp3rRUb%0AUFY%2BRpBOO05NH5lRnZeQFhkbdJVfe9qNP1H5W0PUIg3%2Bttz99jKfLgOjTLE8%0Ao4SIZyT4sgHFAXy32DJZ5As3vNcxZq4m7cZA7C1FqyCltEyHl5dWRWN7h9YA%0AoPu1dExAOYcPaCjWusy2ja8diOb1hAWZFlZ9xUxVDUP0Kc4Sr3ZPjLT1PSbh%0AncJLa%2BrjSt%2BxmNpQOcLPFZEn5eRwCjbAxjDb40eO6uvgmx3s6ygi8SJoZ2u3%0A7uR4X%2F72mPP4v20dM0J5djSPOtLPQgGMtoojpQo%2BdmX0JBCCYZTybflH2421%0AP0ghfmw4AmEGMWoqJDCEnYsNkbBBKEGiswfacGvHLrkC2Z8nf6GzDtcH6gTI%0AMHcl%2FmvW0VmgzyHpCkFJ5DFzVjWmVRzDNBg6DKpRbWkQFUGkb9iyY88woNE0%0AQgcubh8J60I5MaNMcdmGgg7Bzwzg4VBh%2B8SG8phD7nyuOeet9X0ojFC5%2FsfX%0AZNGKrV6FFDgoyw4JuyqiK%2BTv99630LSb7saHgVI3uWLsLC9A%2Ft6BcUkvKsqo%0AxYwPOZ6N%2FWLXHpfPj3zu5MfoD%2FC%2FUTtorOlBXRCOSwY7u7xvmKoC%2BR0d1umR%0AOPd36yItSEF4BBgCqFljtSd0nqd0nbWNlvb%2F64m%2F8gpTc%2Bt6Dniv%2FHQ%2BTco%2B%0AOqhFcb5Wx59%2F70xN1SghoNVvFMXJu2zLb%2BY66kVI7fiKNlhr%2FAVM%2FqEo8jMq%0AYNlvmjGyjrioUPgBD05t0%2FAwicJDwH4hj744VgvMd%2BekD9c2FjhEGaHLcqBN%0AdVHSuY7Xgsarzv4uoiU8rYg1MA96GRG%2FFT8rsZ235O2bauka%2Fk5PcYdkM%2BbJ%0AfNnbz%2FZuz0X7K5UkyKJ8wnW093bKQG%2BjeXxfEZXJwK8AnpSJtdDSnAN36F3J%0ANbLpY%2BfLULGNhIh8j05dLuukWzeZ%2FUZqvHkLj%2BqyDv1h6pus6VqoBcTBhqqA%0AoBLtDZHal3e7oKl9e0lktnm%2F%2F8mvHUmLTGboPlxUysIVIgLNv4Ne1U%2B8fXI%2F%0AxMjFMQuSe%2BWZlwIFt0qG7bApZBYG56773lR34%2FKdERXD8QR1Dah2AT6fCW%2F4%0ABtuiK0yuP%2B8zUAQOnk2df%2FMZGY%2BYhalEZAn5huMcOodgKAkMWaDdPeQnf%2FJN%0Aw0ognyYGZk3uczCJUfuLynQawTl4drmf9WTzpAxQ0CpZxoSVpKTRQUreDkIp%0AX%2B8%2BdcpKYzMVYwI8aBmb7OC1O4nq%2FdFH4P0u42zHmAzQBMgVWw%2FnVCmUOPoA%0AIqRQALu3JLnildZnAbmmuLNj1lu7zoRcNgs%2FZpey24OgpEBFYeXm3nnjRGH9%0An7TgXVqnbYq0yzqURiBwWC9gqpnxor7%2FbYA4L0EaXo1xyTDa%2BmsZM%2Fa90fNx%0AzZui8phLIC9vN8XUXVY1%2FM3R%2FWEQHZSQBAdGmQYGlbNISAnOvFl5sibhS39S%0AwPUHrpnTcP5y31DALj7JC9NfAO0bgmQl5Ew9jJQHkcvJPJeEhKdIVhOwLwKS%0AA%2F8hNQA4vg0g%2FYXZa42TxgIzm3XWOLXFDblPodfr3J5CNpivY3El3zp4Gtjo%0AwKJ5bpv8lNBn9IrgR1LmfYqQFkkXsSMrcJJhvjU7sMXC7kKiN0f13rnKYJn1%0Ayz1RWunvv3QAdpIP3Wbgy2FAQZC3rQOI3dW5W%2B5VNgfk1nUn7KmFvIH7%2B019%0Ax2dwSa8lPFCkkE6nxBfU4e4pdxAHZMwl2eVHQ9mVE1JJtKRLU5ReKG%2BSVWNs%0Aw0R6%2FTVccc3wxrkhrB2%2BiFK0qTespyk5JAgXAqF%2B9TDczhwcAFAEk6utRizi%0A3pS6Hl9GvZAXLNhxNL1cw3SsHhwBVgajqMFk4DpM8dxzxzaBTMiTcNBiB3uw%0AhGlGjYxnlQyYkX92ZUmQe31SYVIZojv9%2FkDhoGltcWrNbsqBQzGlw80HN0zP%0ADY0382SVjHBWiahlQTrp8JHIZmQkKhSqrBwFbX%2FZokE4l%2B3wMXPoGLG7ln8R%0A3C2IvsKs8DlrWrYOIhED%2FQvLoos5Gi2XyEwZls7NA5JHEFC9tcUWTLPbecKw%0A0By50zt3DYgURUW3%2F%2FxEs%2Bu%2Fb1f8X%2B5lZV7TCmX8d7ori3n6eMkBujWwp4mq%0AZwcvRl2inOLUtVj%2F57RPVo%2Fxhh9L5YhscropKyU%2BFgJQLx3B2ZjlEStcDqsD%0A6LdDd8RccapsGK%2FPOiICD4hxDakCWzTkcIOWO6XMFpoKxU7I5DLirylSgAxt%0Ac4JeOpXrJfhrI6Zh%2BDz2lcsTuJtGfS%2BKw70hnjO7gRpI9m64Zc39DcRTtfzv%0ANdaHUrG1nbT%2FxwgXd%2FgJFLYdPZR5jZApGtSnA5qNNWTv37npBzQgW7Gupa9J%0ATlvQ%2Fu2cFojS8ZeqxotoCgUQkyFduJrad680U2SdlO70VAjkm1hAT2XCnyc9%0AsCkqSEu61MTBUiklj7BODmNVoDFugcVryKNaXDPMUhgYf%2BYqihLea8X5na%2FD%0ATGbSmzR3vMAXcUndoMmbup5i5wzFN0eIcpbcVSG%2FEgxlbFgdnb0eeY%2BqeXyg%0A0PW5zvRy8IZheJYp2px%2Blq3bywXbinWw3yg5GhlLPcXkyV6N9lZDEkuGgPDp%0ASCHwjTl8e%2F52%2FfvACUzj1VDc4cQ%2Fda5Yd7SRReBq29BK230TLEGGtVYP%2Bfmq%0APGR7WILVUj0B7kaTZa%2BBaunT%2FD9hf0X4YbfdmblWqDDaykCbhl0Y1wkRyolN%0Al23WsqIdIjWb%2BlGwB3cvZ%2BU7PII5ndd%2BLtTbZfvFKGl%2FdqC66CQ3hNCgmqGq%0A%2F%2FFCGjCj2dGRp1FV5KnLs5bTENvnWGsxr0u8v662x9brqwq%2Fsm3MRfcGPG6t%0AtEN4p34%2B8OUiU27R97JQ9S4VFopOfaodCdpQuwmCemHz%2B%2BOfSeV4th9hI6j%2F%0A4wUKjISDtAdwyEaaE27S8XnrT%2FCLFWRt3y6X6lY6B%2FZg%2BidmUdvZxIVH3BUL%0APRqk%2BB4rsa1W9e2MESdS7d%2Fu51qwpZa4FVCqMANVLYKQFEd4GX0jN8kO7umx%0A0G%2BIgHvZdyoLq17CuBuh7YtC9VJi3zhwsD2IQo6H9lYvosXwCmPgE3J4%2F%2ByX%0AnYIcFH6Ge6p6%2FvyHphWEXA1yKtaqUJXl6nvrp%2B6QF9SJfGZpTwgBDzb%2BQIzs%0ApScrk4GMLH1Xd1KWXY%2B%2Bl6o50ktlWEykls%2BmtMhRuonyxt3Wrs%2BpDHRsHdwR%0Auf5utX3BIxHqxuIPJrPzazB2%2B%2BCDjyBB1%2FvvTnjGiC%2B4QTnkSNZYjGkZZYOb%0AaHWUOeTzuTblvKqPrLPM0mTIMiLADwRJO4jYJiQ8E3%2BUsVHnK2irUja3AoJ4%0ASrRhKzcCYfGvpu%2BtAm9WSIXaWFkFq53IQ%2FPwy3%2B1heNjffdlsbZaPVGCRAMo%0AAMiovhm0lnbUFsI4Zm99RkNmouOb9nkU6S3JQyjkOpAbJqHREOrXUBECuZTC%0A%2FkWHHeX%2BOCELS7HPOuF7%2BteQo0ZjXR1URwgqkADwFYRYTfIaacPw2rseTdvj%0AXtnpPf1g4bHRcxIUUSu0yy602KYHB8CQ1J%2FaKwE0UNKfJaSl1DMRq2bsZrYR%0AHlr29PmrWiYUOF%2FYU1iD%2B%2FNCIww6dmGWxGoDYpqW4dd%2Bew0GxHqMxl3FdIaT%0ABcsP%2FqFODuOkm7l5AXUcKGfQuW2x6RM1lllkle6strizkMq7A8bv0pTUKbZI%0AR%2FZtMhmIZE0Z8KZX0EUAcwlPTi%2FTPP%2BzGXIk2vTJvtfO38jZpn%2FhTFFKmjO1%0ARHn1EE6Zs4vBke0bM%2FcVFt8ShS5hFoTq6jUzdpgHXNY1ohET%2FtUfFE7LmCzh%0AvxK9q49jjuf4UVw7n%2Fpl5ib0DMJfEIDJlUZ%2F1SzY9DNX%2Fl%2FGUgWmxkbFLSjw%0AOnmSSrTBQACwk%2B2NUqoCc8S%2FLgrQVOSz3%2FE1qASnuYgCkSEqN%2BgTC%2F66oUbs%0AMwqCK%2Fts4BQYaC%2Bd%2FYDF9GVx4KL8NaEz7J2vgyD5%2B71VyCxRNBM2q7oHHbKF%0ATc%2FNLqgo85%2F4LN2%2FFKewNWkNBlDQrabEw5azoGWRU9lktHhd78YZlN7zzXp3%0AaHGXCc7z478scFs7NWST1GtB1JNyyJBM5xw%2Fpf8aJNktL91aMQfgkPbUGjq8%0ASib1RNq%2BmatA8VVLPh5aXwcWKonuhxILokw8M%2BbET0fkvILOB7QCJETJ8lQ0%0ANcW2Z9GboF6bDHXUlHoMvPscvwVHouklDTv0Iq66fQEomXI3nMwMFBygrMZP%0AUY6etsFHKRlRT%2BpjDxbmMINs0bG4Ud6IZj9ZRof30u%2FBfGbRJbG2FSB2TKB3%0AR8EUw8VH7uT1h%2B%2BFBBjSq1EOLyZHgIx4cuB1hXBg9RC7jkdGUfrcLmJSwt6X%0A1wVdYD%2FZto2kHFJAn91nQE9pUK0hXyYVwaLyGbeQUKxd3HUCcMnEN9E%2BwNJH%0AHIEe02IjMGESsONSEhlFNjf19GAh89Mvb8XyP3fzKLI4yXWuuCGnzCx6Qo3Y%0APnGRg2KTD16tFxl1L69iYC6j3085CrwNkKlJJRFZlmPVK%2FJ%2FaLq6ilup6ebS%0AB%2BATUvAKEO8IbfVhJGSwyHNEL53GB5dsMPKbMMY2DGX5%2FJnGw0my7%2BMdTumo%0Achhu6mrY51z3%2Ba8lW1PVzguvFH9adKy0Y5UYoxTN7LqSb%2FAvT4r0JViPDxDN%0A%2FC5vkGXtEgy1PQDtYp6h3I3uc3GBKbAunknZzepi9HOb82Rg7QsKuXNnlOa5%0Aou5klrc8%2BT0bHZ4emvesaS8VlP8WQRPhzHb%2FpbK%2B1zh9wLx4hkPUUthKO4t%2B%0AYdnDAVD0SBTfGYIhq65DC9ZtauUNheu5EsyuUSlq9bH1GrNeC2FHvZegeVDB%0AWJ6bRWlIHx1s9cnwE18diUBJKBwBqyY46i%2BUyFA5%2FWN626YHuxEaUoKX%2BEFl%0AIyTQGNAiK6c0q%2FL3YGPcbpC0yv6TN2xitoRvhsEQBrbl5PHYvwmxLDdRWiRZ%0AIQy63LPYpQ4YZRHCsuMibt6ajekKN6DjyW%2FIQEkOzTHyvCTn5Jl548U7l1nn%0AxdDaG%2Fg4FRIvQkNCL9DG8XIa021oQpz9sRNlbuHs2p78n1T7XzHQAIEELn10%0ANhtwayXyoBSOSSbBClsx95iLJfY%2BE9W2Eqe7MduR82Qv5PUDX6lj145Tbpqc%0AG%2B7%2B6OUJy3F2IrdfqAGcOyJav7oqx%2BklDRpr%2FM7ytMt3XrzoAQdpWcaLt4nX%0AlA4VEy6bCsPGyPpWyfhaStCWCPQAsOQ2x6UU%2FtBWDpA9pxqJMC2Ef%2BBc0MdS%0AOPboXRH2QKsOzfyJ%2BesKna7os2sH29Ip3OQ4yjYdGmskhzqzYo%2BbkUl9Iz94%0Au%2F0wqouIKclg93PNv4zmFlKLvRQTdDqvWQCj120U59cx4gWlpgUhUTufjjfj%0AZOrgqe14B%2Bgr7NEijI4oiCY4PrmDxDMrDkhdhnAHAe3ZIutGGWekPCvZKEZp%0AX9oqeLpXVJU29kd%2B%2FtvdN57OFF2RfBx3lJKymU46QIkxtPJgfZG7Ds9K4s%2Bb%0AGOuNWhw7WpXX4oejOWLTAFEfRf8j95rWNqQpFonWdXG%2FD2LhPkmu3hyEuoS7%0AcUl%2FaCXIl%2BK1A6dx4mUbD2wHhYqJvcCw2PG%2Fhz0OytAOkkUkS9v2nwj%2BOl9H%0AsFssFjGIBoehvGrw9pOCCqRcrZ9q24UtTD6mIVEdNXeTMV1Fr7paT%2FAHCZEs%0ANU6sV%2BluMxH%2BtTnxEHSZbHL%2BdgxFSuebPmYAu4ZdSs4JeUsDXoLePxCJo%2F7J%0AbEMqM0JKapdtymXjebTN5m0mpvBAk%2FESsQ%3D%3D%0A%3DOxfh%0A-----END%20PGP%20MESSAGE-----%0D%0A&senderEmail=flowcrypt.compatibility@gmail.com');\n      const pgpBlockPage = await pgpHostPage.getFrame(['pgp_block.htm']);\n      await pgpBlockPage.waitForSelTestState('ready');\n      expect(await pgpBlockPage.hasClass('@pgp-signature', 'rtl')).to.equal(true);\n    }));\n\n    ava.todo('decrypt - by entering secondary pass phrase');\n\n    ava.default(`decrypt - don't allow api path traversal`, testWithBrowser('compatibility', async (t, browser) => {\n      const params = \"?frame_id=frame_TWloVRhvZE&message=&message_id=../test&senderEmail=sender%40email.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\";\n      const pgpHostPage = await browser.newPage(t, `chrome/dev/ci_pgp_host_page.htm${params}`);\n      const pgpBlockPage = await pgpHostPage.getFrame(['pgp_block.htm']);\n      await pgpBlockPage.waitForSelTestState('ready', 5);\n      await pgpBlockPage.waitForContent('@container-err-text', 'API path traversal forbidden');\n    }));\n\n    ava.default(`decrypt - try path traversal forward slash workaround`, testWithBrowser('compatibility', async (t, browser) => {\n      const params = \"?frame_id=frame_TWloVRhvZE&message=&message_id=..\\\\test&senderEmail=sender%40email.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com\";\n      const pgpHostPage = await browser.newPage(t, `chrome/dev/ci_pgp_host_page.htm${params}`);\n      const pgpBlockPage = await pgpHostPage.getFrame(['pgp_block.htm']);\n      await pgpBlockPage.waitForSelTestState('ready', 5);\n      await pgpBlockPage.waitForContent('@container-err-text', 'API path traversal forbidden');\n    }));\n\n    ava.default(`verify - sha1 shows error`, testWithBrowser('compatibility', async (t, browser) => {\n      const msg = `-----BEGIN PGP MESSAGE-----\n\nyMCxATvCy8zAxHhitbJOfXrcEcbTKkkMIOCRmpOTr6NQkpFZrABEiQolqcUlCrmpxcWJ6alchw5U\nsjAwMjEoiymyhJfeapohyXRUYeazxTBjWJkSeOtDWJnBRnFxCsDEv33mYDjmdsuGPyx68g7tMwe3\ntqlevvUo5EIap+wmZm6mRXcOGBplvJy1mfuq1plrt08qs97Y2ztB+/XbuyG3Ir48u7I3pmD+TWae\nWSd5d26QYXcuusauc0Xy/fS1/FXbPJaYHlCeMCfnhrF9d2jyH33V+er6r3lS5i/mchOKffpglktT\nd6Z36//MsmczN00Wd60t9T+qyLz0T4/UG2Y9lgf367f3d+kYPE0LS7mXuFmjlPXfw0nKyVsSeFiu\n3duz+VfzU3HVZ65L4xc5PBYwWLlshdcG94VTt2oK3cuLC5zuy/3ks0sw1+MGzmKtjMeJrqXph+8p\n5W5JmHL28qarbQvv+71V3ni6odk8Z2NDban2y1kA\n=Ruyn\n-----END PGP MESSAGE-----`;\n      const params = `?frame_id=frame_TWloVRhvZE&message=${encodeURIComponent(msg)}&message_id=none&senderEmail=sha1%40sign.com&is_outgoing=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com`;\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        params,\n        content: ['test'],\n        signature: [\"Insecure message hash algorithm: SHA1\"]\n      });\n    }));\n\n    ava.default('verify - Kraken - urldecode signature', testWithBrowser('compatibility', async (t, browser) => {\n      const params = `?frameId=frame_ZRxshLEFdc&message=&msgId=171d138c8750863b&senderEmail=Kraken%20%3Ccensored%40email.com%3E&isOutgoing=___cu_false___&signature=___cu_true___&acctEmail=flowcrypt.compatibility%40gmail.com&parentTabId=12%3A0`;\n      const expectedContent = 'Kraken clients can now begin converting popular currencies';\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, {\n        params,\n        content: [expectedContent],\n        signature: ['Missing pubkey A38042F607D623DA']\n      });\n    }));\n\n  }\n\n};\n",
    "test/source/tests/elements.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as ava from 'ava';\n\nimport { TestVariant } from '../util';\nimport { TestWithBrowser } from '../test';\n\n// tslint:disable:no-blank-lines-func\n\nexport let defineElementTests = (testVariant: TestVariant, testWithBrowser: TestWithBrowser) => {\n\n  if (testVariant !== 'CONSUMER-LIVE-GMAIL') {\n\n    ava.default('elements/pgp_pubkey.htm renders a public key', testWithBrowser('compatibility', async (t, browser) => {\n      // eslint-disable-next-line max-len\n      const pub = `-----BEGIN%20PGP%20PUBLIC%20KEY%20BLOCK-----%0AVersion%3A%20CryptUp%204.3.6%20Gmail%20Encryption%20https%3A%2F%2Fcryptup.org%0AComment%3A%20Seamlessly%20send%2C%20receive%20and%20search%20encrypted%20email%0A%0AxsFNBFj%2FaG8BEADO625P5MArNIVlMBPp%2FHM1lYD1gcVwgYl4aHuXohDMS6dv%0AVAlSDXMVWwbsXJ9T3AxYIL3ZoOFDc1Jy0AqBKhYoOYm5miYHpOQtP%2FM4V6fK%0A3rhmc8C1LP1JXuaEXS0w7MQig8JZC08ECUH1%2FGnhm3tyacRgrAr13s591Obj%0AoP%2FkwglOUjKDYvkXXk9iwouU85sh9HKwC4wR6idFhFSnsl8xp4FI4plLQPTy%0AEa1nf3l%2BoVqCFT5moVtsew7qUD5mWkgytEdr728Sqh5vjiO%2Blc6cjqb0PK77%0ADAuhTel1bV5PRCtRom%2FqrqmOz4MbE5wd2kU%2FJxFPIXZ1BKyicT%2FQ6I9MXjni%0A77Bl91x0V9brnBqyhfY524Vlm%2F2AEb3H9I10rsTBtU4TT%2BSJOlwyU1V7hDkJ%0AKq1zTrVjCvoPcTBXGx9xSZmJO4TI7frNZFiJ5uiYwTYPwp3Yze69y%2FNORwme%0AZlXtXJbzpVvRzXUzex89c6pFiKE8mC5%2FDV%2FeJanBYKgSyGEiHq9U6kDJrTN4%0A%2FfSjiIJ0fWK3bcYwyYUbf9%2B%2FJcLSo2sG259FuRF75yxIe2u2RLSh62plEsyb%0AcpD545pvlrKIvwg%2F1hio999lMnSjj%2BhfNQ7A%2BXm5BWiSzrJ1fR1Oo5rq68kY%0A1C4K8FUQwP3zEF2YDoqbBEnYaxaH7HUcbc34xQARAQABzSlDcnlwdFVwIFRl%0Ac3RlciA8Y3J5cHR1cC50ZXN0ZXJAZ21haWwuY29tPsLBdQQQAQgAKQUCWP9o%0AcAYLCQcIAwIJEAbKVT7CRV1wBBUIAgoDFgIBAhkBAhsDAh4BAAAvwQ%2F%2BIaTX%0Am4ZrqA1h2N%2BgYSUiNkLKnVVZNTdVKSRCEvHNZaYHqZDK5mO9TRKlbz04bIle%0AhfYzt0MW65AmZm5vtp16TTzXQVpFv1YGbFFkol7qR2chzXdnbOCz172W0cKr%0AWu8exVr4XR1C7R6UVckltfouq%2FJGe4pDFwYshluL8ZezCCWDeno6y5JJJr98%0AobKWtSMw0%2B0XqMqFsTP3%2FkF77cWfeZ6aE7Tugq2vRIVg1CuaDZKnrGYPBWbw%0AYZA7r0MTLEHMNm3NWGcmA6BZyAqWLe7ocG%2B%2BDWlXC2AsScUqg26D2pmh4089%0A2%2Fi54ecThwzVmtaycWou6x7E7hEqDGGdD5RorVJ5FqEMq4NsBit43loV7Hoo%0A1R4IW6bVANIqFGUv0VS0MA8%2B7ce1UN9taC762f9idRfNBY0yi9u5hoinSrJo%0ALl%2F489nhyqL74HyelSghK2QusavHCe9BVsHR%2BH0kwszDMtXjDBJtkKRI9FcK%0A%2FQfvU4OvvVKNNSbkz1zaXrGI2YOu4p3CHK%2BaQCluR3PhldVUSDR7wT%2FasfWx%0AMH43juH%2BC0kXonRqye7cDs%2B3wi4qfrJw%2FGYtwC0Jfza%2FOlyuyE%2B1AlVpEBKV%0A7gG%2B6iKTIl2G5DnBN%2FtdfckLNSsYDVby7%2BaZV3CtVvuhfeAjN9YluNqZZBSD%0AqOym88BUsEFLOdzBLbbOwU0EWP9obwEQAKKVKmNQsbpNlhuFZydHjqf%2BAaBB%0AQsJb9Q7zLSuUABmBLUG9%2BohSdb1tsI5MEq7Ldksy2sF4KsY6KBHg0VK4Ndu8%0AKSzeVFlgESyizryt%2Fa8Jad%2FdaujYdJ5fliVx46XYAuVXROhes0Plpa8aQGwU%0AumbV%2Fs2INXqo8HwDke0UI42%2Bk%2FOG2SkkiLGTU2US3OMk85bWoqHi9fYkmM7Y%0ATJRt6dJgwjqevfIvEFUjh3i6ipFSwp%2BB1uS3%2FTHtc%2Fi066wWZwIWb0Z1nsAh%0AVpikL6ckaLiEhkvUEkL%2FmqTfIv0wJAsAsRvXKZvmO8qQrKq8UQrADjfMSP%2F4%0AscohiuwjPRYqpt3NyqrliCcTRWZTBLXj7w1E2m4ZcAeRUFFv1LhcLPkR3uBo%0AmxaoKqbwT6D64sz%2BaXopIMopcsWFf64zFnYBAJN7tYOmIQQMH5aZGNV%2B8v6u%0AWvPpgEzAFQutDUVr2ttAIfyK%2BHPu57pHOAB51N%2Bl04en9WXeUmT1cqpqaXAK%0AV9cEH3oRkpBRz5waIW1LmElWbubjEWKZfLB8NgvGMsA0lMqsaaVdV0swoehQ%0AHuvXIQv1eeBLK%2FsAL3%2FVCStMwkW8gfaL8%2BbEKDK%2Bl4Jd1mhXa%2BVAyzTAEsTT%0AyAaYP3Y1fR595LA8YHBsfu4ugYzqc7%2F71ExvE%2B7S8kdBv0wOiekWs7zVABEB%0AAAHCwV8EGAEIABMFAlj%2FaHMJEAbKVT7CRV1wAhsMAADFiw%2F%2Fe8AN74gI2LD%2B%0A827r3742%2FasQ76JnqM63GDT3c9Tp6N5i7HMxBw%2BKdcPuEgQHWADdpDBcPtRG%0AkQUD9ty2mtvGsYSg27G%2FHPyb2OYSLf6LF7MQPbHl0REvIjyGKvM0jV6sfGQA%0A1DkfY5EdbQIaqamB73GZrG1vmwXYR4NBFYHtqhDxcvOJNDTlTNRcI957G5cp%0AvWS68d2FkCHHlSRsZdLt1JknTaUdCYArgkJSLRMSWPAwWDFZpPJJHf7lkEgU%0A1quql3%2F7wEShDKqfmgOYDzBZ4K0Hy%2F8jSHpiEWlgF6F8Kl0HCRs%2BARhoAbl%2F%0AM45Xb0%2BbDp30xKJMoHkoOyveWZWz2MHb00ISzDlKEBe2MrCPJe6iHVFtqjPM%0A3qZ93hyIaYKu0H8Hc3HlqYB5muvN80FFX7FNPXc4NiIoRp5Nd6F2qvMMnuD%2B%0AAsOKCgQ4KcTa8Joe4%2BcJ8ba3rizK45ktPvvJNzSeB6Zj9rSIiF9iU4a49QDU%0Am9mzGSLx%2FpFtJ4kfFqiVs6htbtobOBKFjUVrhJtKsFuk7awoTA6cl9ytd%2BSA%0A%2BUxSdqb6cFHq5YjR%2BCwRAG0HF2bdd6XvYtZnjwzTkMwYQzG30QPFTpy%2Fnu%2By%0AOwlAeRiv2EMNWKHjnNVWpqwApGGHzFV%2Bg12fK%2BDgurILj%2F8qM1pZBvu3Q8bI%0ACkFQRDXhui8%3D%0A%3Dy3QV%0A-----END%20PGP%20PUBLIC%20KEY%20BLOCK-----`;\n      // eslint-disable-next-line max-len\n      const url = `chrome/elements/pgp_pubkey.htm?frame_id=frame_sqpdwqmqtu&armored_pubkey=${pub}&minimized=___cu_false___&account_email=flowcrypt.compatibility%40gmail.com&parent_tab_id=9%3A0`;\n      const page = await browser.newPage(t, url);\n      await page.waitForContent('@container-pgp-pubkey', 'cryptup.tester@gmail.com');\n      await page.waitForContent('@container-pgp-pubkey', '06CA 553E C245 5D70');\n    }));\n\n    ava.todo('elements/pgp_pubkey shows graceful error when pubkey not usable');\n\n    ava.todo('elements/pgp_pubkey can render several pubkeys in one armor');\n\n    ava.todo('compose - elements/pgp_pubkey can import several pubkeys in one armor');\n\n  }\n\n};\n",
    "test/source/tests/flaky.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as ava from 'ava';\nimport { expect } from 'chai';\n\nimport { Config, TestVariant, Util } from './../util';\n\nimport { BrowserRecipe } from './tooling/browser-recipe';\nimport { ComposePageRecipe } from './page-recipe/compose-page-recipe';\nimport { PageRecipe } from './page-recipe/abstract-page-recipe';\nimport { SettingsPageRecipe } from './page-recipe/settings-page-recipe';\nimport { SetupPageRecipe } from './page-recipe/setup-page-recipe';\nimport { TestWithBrowser } from './../test';\nimport { Stream } from '../core/stream';\n\n// tslint:disable:no-blank-lines-func\n\n// these tests are run serially, one after another, because they are somewhat more sensitive to parallel testing\n// eg if they are very cpu-sensitive (create key tests)\n\nexport const defineFlakyTests = (testVariant: TestVariant, testWithBrowser: TestWithBrowser) => {\n\n  if (testVariant !== 'CONSUMER-LIVE-GMAIL') {\n\n    ava.default('compose - own key expired', testWithBrowser(undefined, async (t, browser) => {\n      const expiredKey = \"-----BEGIN PGP PRIVATE KEY BLOCK-----\\nVersion: FlowCrypt 7.0.1 Gmail Encryption\\nComment: Seamlessly send and receive encrypted email\\n\\n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\\n+gib+vSxHvLhC6oDBA==\\n=RIPF\\n-----END PGP PRIVATE KEY BLOCK-----\"; // eslint-disable-line max-len\n      const validKey = \"-----BEGIN PGP PRIVATE KEY BLOCK-----\\nVersion: FlowCrypt 7.0.1 Gmail Encryption\\nComment: Seamlessly send and receive encrypted email\\n\\n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\\nGw==\\n=18AI\\n-----END PGP PRIVATE KEY BLOCK-----\"; // eslint-disable-line max-len\n      // Setup Expired key\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.new.manual@gmail.com');\n      await settingsPage.waitAndClick('@action-step0foundkey-choose-manual-enter');\n      await settingsPage.waitAndClick('@input-step2bmanualenter-source-paste');\n      await settingsPage.type('@input-step2bmanualenter-ascii-key', expiredKey);\n      await settingsPage.type('@input-step2bmanualenter-passphrase', \"qweasd\");\n      await settingsPage.waitAndClick('@input-step2bmanualenter-save');\n      await SettingsPageRecipe.waitForModalAndRespond(settingsPage, 'confirm', { contentToCheck: 'You are importing a key that is expired.', clickOn: 'confirm' });\n      await settingsPage.close();\n      // Try To send message with expired key\n      let composePage = await ComposePageRecipe.openStandalone(t, browser, 'flowcrypt.test.key.new.manual@gmail.com');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'Own Key Expired');\n      await composePage.waitAndClick('@action-send');\n      await ComposePageRecipe.waitForModalAndRespond(composePage, 'error', { contentToCheck: 'your own Private Key is expired', timeout: 45 });\n      const settingsWithUpdatePrvForm = await browser.newPageTriggeredBy(t, () => composePage.waitAndClick('#action_update_prv'));\n      const urls = await settingsWithUpdatePrvForm.getFramesUrls(['my_key_update.htm']);\n      await composePage.close();\n      await settingsWithUpdatePrvForm.close();\n      // Updating the key to valid one\n      const updatePrvPage = await browser.newPage(t, urls[0]);\n      await updatePrvPage.waitAndType('@input-prv-key', validKey);\n      await updatePrvPage.type('@input-passphrase', 'qweasd');\n      await updatePrvPage.waitAndClick('@action-update-key');\n      await PageRecipe.waitForModalAndRespond(updatePrvPage, 'confirm', { clickOn: 'confirm' });\n      await updatePrvPage.close();\n      // Try send message again\n      composePage = await ComposePageRecipe.openStandalone(t, browser, 'flowcrypt.test.key.new.manual@gmail.com');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'Own Key Expired');\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('setup - create key - choose no backup', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.new.manual@gmail.com');\n      await SetupPageRecipe.createKey(settingsPage, 'flowcrypt.test.key.used.pgp', 'none', { submitPubkey: false, usedPgpBefore: true });\n    }));\n\n    ava.default('setup - create key - backup as file - submit pubkey', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.new.manual@gmail.com');\n      await SetupPageRecipe.createKey(settingsPage, 'flowcrypt.test.key.used.pgp', 'file', { submitPubkey: true, usedPgpBefore: true });\n    }));\n\n    ava.default('create@prv-create-no-prv-backup.flowcrypt.test - create key allowed but backups not', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'setup@prv-create-no-prv-backup.flowcrypt.test');\n      await SetupPageRecipe.createKey(settingsPage, 'flowcrypt.test.key.used.pgp', 'disabled', { submitPubkey: false, usedPgpBefore: false, enforcedAlgo: 'rsa2048' });\n    }));\n\n    ava.default('standalone - different send from, new signed message, verification in mock', testWithBrowser('compatibility', async (t, browser) => {\n      const key = Config.key('flowcryptcompatibility.from.address');\n      await SettingsPageRecipe.addKeyTest(t, browser, 'flowcrypt.compatibility@gmail.com', key.armored!, key.passphrase!);\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      await composePage.selectOption('@input-from', 'flowcryptcompatibility@gmail.com');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'New Signed Message (Mock Test)', { encrypt: false });\n      await ComposePageRecipe.sendAndClose(composePage);\n    }));\n\n    ava.default('with attachments + shows progress %', testWithBrowser('compatibility', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'with files');\n      const fileInput = await composePage.target.$('input[type=file]');\n      await fileInput!.uploadFile('test/samples/small.txt', 'test/samples/small.png', 'test/samples/small.pdf', 'test/samples/large.jpg');\n      await ComposePageRecipe.sendAndClose(composePage, { expectProgress: true, timeout: 120 });\n    }));\n\n    ava.default('compose > large file > public domain account (should not prompt to upgrade)', testWithBrowser('compatibility', async (t, browser) => {\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'human@flowcrypt.com' }, 'a large file test (gmail account)');\n      const fileInput = await composePage.target.$('input[type=file]');\n      await fileInput!.uploadFile('test/samples/large.jpg');\n      await Util.sleep(2);\n      await ComposePageRecipe.sendAndClose(composePage, { timeout: 60, expectProgress: true });\n    }));\n\n    ava.default('compose - send pwd encrypted msg & check on flowcrypt site', testWithBrowser('compatibility', async (t, browser) => {\n      const msgPwd = 'super hard password for the message';\n      const subject = 'PWD encrypted message with attachment';\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, 'compatibility');\n      await ComposePageRecipe.fillMsg(composePage, { to: 'test@email.com' }, subject);\n      const fileInput = await composePage.target.$('input[type=file]');\n      await fileInput!.uploadFile('test/samples/small.txt');\n      await ComposePageRecipe.sendAndClose(composePage, { password: msgPwd });\n    }));\n\n    ava.default(`[unit][Stream.readToEnd] efficiently handles multiple chunks`, async t => {\n      const stream = new ReadableStream<Uint8Array>({\n        start(controller) {\n          for (let i = 0; i < 10; i++) {\n            controller.enqueue(Buffer.from('test'.repeat(1000000)));\n          }\n          controller.close();\n        }\n      });\n      const result = await Stream.readToEnd(stream);\n      expect(result.length).to.equal(40000000);\n      t.pass();\n    });\n\n  }\n\n};\n",
    "test/source/tests/gmail.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as ava from 'ava';\n\nimport { BrowserHandle, ControllablePage } from './../browser';\nimport { TestVariant, Util } from './../util';\nimport { AvaContext } from './tooling';\nimport { BrowserRecipe } from './tooling/browser-recipe';\nimport { ComposePageRecipe } from './page-recipe/compose-page-recipe';\nimport { GmailPageRecipe } from './page-recipe/gmail-page-recipe';\nimport { SettingsPageRecipe } from './page-recipe/settings-page-recipe';\nimport { TestUrls } from './../browser/test-urls';\nimport { TestWithBrowser } from './../test';\nimport { expect } from 'chai';\nimport { OauthPageRecipe } from './page-recipe/oauth-page-recipe';\n\n/**\n * All tests that use mail.google.com or have to operate without a Gmail API mock should go here\n */\n\n// tslint:disable:no-blank-lines-func\n\nexport const defineGmailTests = (testVariant: TestVariant, testWithBrowser: TestWithBrowser) => {\n\n  if (testVariant === 'CONSUMER-LIVE-GMAIL') {\n\n    const pageHasSecureReplyContainer = async (t: AvaContext, browser: BrowserHandle, gmailPage: ControllablePage, { isReplyPromptAccepted }: { isReplyPromptAccepted?: boolean } = {}) => {\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/compose.htm'], { sleep: 0 });\n      expect(urls.length).to.equal(1);\n      if (typeof isReplyPromptAccepted !== 'undefined') {\n        const replyBox = await browser.newPage(t, urls[0]);\n        if (isReplyPromptAccepted) {\n          await replyBox.waitAll('@action-send');\n          await replyBox.notPresent('@action-accept-reply-prompt');\n        } else {\n          await replyBox.waitAll('@action-accept-reply-prompt');\n          await replyBox.notPresent('@action-send');\n        }\n        await replyBox.close();\n      }\n    };\n\n    const pageHasSecureDraft = async (t: AvaContext, browser: BrowserHandle, gmailPage: ControllablePage, expectedContent?: string) => {\n      await gmailPage.waitAll('iframe');\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/compose.htm']);\n      expect(urls.length).to.equal(1);\n      const replyBox = await browser.newPage(t, urls[0]);\n      if (expectedContent) {\n        await replyBox.waitForContent('@input-body', expectedContent);\n      } else {\n        await replyBox.waitAll('@input-body');\n      }\n      return replyBox;\n    };\n\n    const pageDoesNotHaveSecureReplyContainer = async (gmailPage: ControllablePage) => {\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/compose.htm'], { sleep: 0 });\n      expect(urls.length).to.equal(0);\n    };\n\n    const openGmailPage = async (t: AvaContext, browser: BrowserHandle, path: string): Promise<ControllablePage> => {\n      const url = TestUrls.gmail(0, path);\n      const gmailPage = await browser.newPage(t, url);\n      await gmailPage.waitAll('@action-secure-compose');\n      if (path) { // gmail does weird things with navigation sometimes, nudge it again\n        await gmailPage.goto(url);\n      }\n      return gmailPage;\n    };\n\n    ava.default('mail.google.com - setup prompt notif + hides when close clicked + reappears + setup link opens settings', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginButCloseOauthWindowBeforeGrantingPermission(t, browser, 'ci.tests.gmail@flowcrypt.dev');\n      await settingsPage.close();\n      let gmailPage = await BrowserRecipe.openGmailPage(t, browser);\n      await gmailPage.waitAll(['@webmail-notification', '@notification-setup-action-open-settings', '@notification-setup-action-dismiss', '@notification-setup-action-close']);\n      await gmailPage.waitAndClick('@notification-setup-action-close', { confirmGone: true });\n      await gmailPage.close();\n      gmailPage = await BrowserRecipe.openGmailPage(t, browser);\n      await gmailPage.waitAll(['@webmail-notification', '@notification-setup-action-open-settings', '@notification-setup-action-dismiss', '@notification-setup-action-close']);\n      const newSettingsPage = await browser.newPageTriggeredBy(t, () => gmailPage.waitAndClick('@notification-setup-action-open-settings'));\n      await newSettingsPage.waitAll('@action-connect-to-gmail');\n    }));\n\n    ava.default('mail.google.com - success notif after setup, click hides it, does not re-appear + offers to reauth', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const acct = 'ci.tests.gmail@flowcrypt.dev';\n      let gmailPage = await BrowserRecipe.openGmailPage(t, browser);\n      await gmailPage.waitAll(['@webmail-notification', '@notification-successfully-setup-action-close']);\n      await gmailPage.waitAndClick('@notification-successfully-setup-action-close', { confirmGone: true });\n      await gmailPage.close();\n      gmailPage = await BrowserRecipe.openGmailPage(t, browser);\n      await gmailPage.notPresent(['@webmail-notification', '@notification-setup-action-close', '@notification-successfully-setup-action-close']);\n      await gmailPage.close();\n      // below test that can re-auth after lost access (simulating situation when user changed password on google)\n      for (const wipeTokenBtnSelector of ['@action-wipe-google-refresh-token', '@action-wipe-google-access-token']) {\n        const settingsPage = await browser.newPage(t, TestUrls.extensionSettings(acct));\n        await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n        const experimentalFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-module-experimental', ['experimental.htm']);\n        await experimentalFrame.waitAndClick(wipeTokenBtnSelector);\n        await Util.sleep(2);\n        await settingsPage.close();\n      }\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings(acct));\n      await settingsPage.waitAndRespondToModal('confirm', 'cancel', 'FlowCrypt must be re-connected to your Google account.');\n      // *** these tests below are very flaky in CI environment, Google will want to re-authenticate the user for whatever reason\n      // // opening secure compose should trigger an api call which causes a reconnect notification\n      gmailPage = await BrowserRecipe.openGmailPage(t, browser);\n      await gmailPage.waitAndClick('@action-secure-compose');\n      await gmailPage.waitAll(['@webmail-notification', '@action-reconnect-account']);\n      await Util.sleep(1);\n      expect(await gmailPage.read('@webmail-notification')).to.contain('Please reconnect FlowCrypt to your Gmail Account.');\n      const oauthPopup = await browser.newPageTriggeredBy(t, () => gmailPage.waitAndClick('@action-reconnect-account'));\n      await OauthPageRecipe.google(t, oauthPopup, acct, 'approve');\n      await gmailPage.waitAll(['@webmail-notification']);\n      await Util.sleep(1);\n      expect(await gmailPage.read('@webmail-notification')).to.contain('Connected successfully. You may need to reload the tab.');\n      await gmailPage.close();\n      // reload and test that it has no more notifications\n      gmailPage = await BrowserRecipe.openGmailPage(t, browser);\n      await gmailPage.waitAndClick('@action-secure-compose');\n      await Util.sleep(10);\n      await gmailPage.notPresent(['@webmail-notification']);\n    }));\n\n    ava.default('mail.google.com - setup prompt notification shows up + dismiss hides it + does not reappear if dismissed', testWithBrowser(undefined, async (t, browser) => {\n      await BrowserRecipe.openSettingsLoginButCloseOauthWindowBeforeGrantingPermission(t, browser, 'ci.tests.gmail@flowcrypt.dev');\n      let gmailPage = await BrowserRecipe.openGmailPage(t, browser);\n      await gmailPage.waitAll(['@webmail-notification', '@notification-setup-action-open-settings', '@notification-setup-action-dismiss', '@notification-setup-action-close']);\n      await gmailPage.waitAndClick('@notification-setup-action-dismiss', { confirmGone: true });\n      await gmailPage.close();\n      gmailPage = await BrowserRecipe.openGmailPage(t, browser);\n      await gmailPage.notPresent(['@webmail-notification', '@notification-setup-action-open-settings', '@notification-setup-action-dismiss', '@notification-setup-action-close']);\n    }));\n\n    ava.default('mail.google.com - send rich-text encrypted message', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await BrowserRecipe.openGmailPageAndVerifyComposeBtnPresent(t, browser);\n      const composePage = await GmailPageRecipe.openSecureCompose(t, gmailPage, browser);\n      const subject = `New Rich Text Message ${Util.lousyRandom()}`;\n      await ComposePageRecipe.fillMsg(composePage, { to: 'ci.tests.gmail@flowcrypt.dev' }, subject, { richtext: true });\n      await ComposePageRecipe.sendAndClose(composePage);\n      await gmailPage.waitAndClick('[aria-label^=\"Inbox\"]');\n      await gmailPage.waitAndClick('[role=\"row\"]'); // click the first message\n      await gmailPage.waitForContent('.nH.if h2', `Automated puppeteer test: ${subject}`);\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/pgp_block.htm'], { sleep: 1 });\n      await GmailPageRecipe.deleteMessage(gmailPage);\n      expect(urls.length).to.eq(1);\n    }));\n\n    ava.default('mail.google.com - decrypt message in offline mode', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await BrowserRecipe.openGmailPage(t, browser);\n      await gmailPage.type('[aria-label=\"Search mail\"]', 'encrypted email for offline decrypt');\n      await gmailPage.press('Enter'); // submit search\n      await Util.sleep(2); // wait for search results\n      await gmailPage.page.setOfflineMode(true); // go offline mode\n      await gmailPage.press('Enter'); // open the message\n      // TODO(@limonte): use the commented line below instead of opening pgp block in a new tab\n      // once https://github.com/puppeteer/puppeteer/issues/2548 is resolved\n      // const pgpBlockPage = await gmailPage.getFrame(['pgp_block.htm']);\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/pgp_block.htm'], { sleep: 1 });\n      const pgpBlockPage = await browser.newPage(t);\n      await pgpBlockPage.page.setOfflineMode(true); // go offline mode\n      await pgpBlockPage.page.goto(urls[0]);\n      await pgpBlockPage.waitForContent('@pgp-block-content', 'this should decrypt even offline');\n    }));\n\n    ava.default('mail.google.com - msg.asc message content renders', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await openGmailPage(t, browser, '/QgrcJHsTjVVKpcZSxSPxWWhHVCCZWpMQCVQ');\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/pgp_block.htm'], { sleep: 10, appearIn: 20 });\n      expect(urls.length).to.equal(1);\n      const params = urls[0].split('/chrome/elements/pgp_block.htm')[1];\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, { params, content: ['test that content from msg.asc renders'] });\n      await pageHasSecureReplyContainer(t, browser, gmailPage);\n    }));\n\n    ava.default('mail.google.com - Thunderbird signature [html] is recognized', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await openGmailPage(t, browser, '/FMfcgxwKjBRGVhcgRwklplhBCCKgSdfk');\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/pgp_block.htm'], { sleep: 10, appearIn: 20 });\n      expect(urls.length).to.equal(1);\n      const url = urls[0].split('/chrome/elements/pgp_block.htm')[1];\n      const signature = ['Dhartley@Verdoncollege.School.Nz', 'matching signature'];\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, { params: url, content: ['1234'], signature });\n      await pageHasSecureReplyContainer(t, browser, gmailPage);\n    }));\n\n    ava.default('mail.google.com - pubkey gets rendered on new Thunderbird signature [html] + correct height', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await openGmailPage(t, browser, '/FMfcgxwKjBRGVhcgRwklplhBCCKgSdfk');\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/pgp_pubkey.htm'], { sleep: 10, appearIn: 20 });\n      expect(urls.length).to.equal(1);\n      await pageHasSecureReplyContainer(t, browser, gmailPage);\n      await testMinimumElementHeight(gmailPage, '.pgp_block.signedMsg', 80);\n      await testMinimumElementHeight(gmailPage, '.pgp_block.publicKey', 120);\n      const pubkeyPage = await browser.newPage(t, urls[0]);\n      await pubkeyPage.waitForContent('@container-pgp-pubkey', 'Fingerprint: DC26 454A FB71 D18E ABBA D73D 1C7E 6D3C 5563 A941');\n    }));\n\n    ava.default('mail.google.com - Thunderbird signature [plain] is recognized + correct height', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await openGmailPage(t, browser, '/FMfcgxwKjBTWTbDjXSJVjDjKlWJGbWQd');\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/pgp_block.htm'], { sleep: 10, appearIn: 20 });\n      expect(urls.length).to.equal(1);\n      await testMinimumElementHeight(gmailPage, '.pgp_block.signedMsg', 80);\n      await testMinimumElementHeight(gmailPage, '.pgp_block.publicKey', 120);\n      const url = urls[0].split('/chrome/elements/pgp_block.htm')[1];\n      const signature = ['Dhartley@Verdoncollege.School.Nz', 'matching signature'];\n      await BrowserRecipe.pgpBlockVerifyDecryptedContent(t, browser, { params: url, content: ['1234'], signature });\n      await pageHasSecureReplyContainer(t, browser, gmailPage);\n    }));\n\n    ava.default('mail.google.com - pubkey gets rendered on new Thunderbird signature [plain]', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await openGmailPage(t, browser, '/FMfcgxwKjBTWTbDjXSJVjDjKlWJGbWQd');\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/pgp_pubkey.htm'], { sleep: 10, appearIn: 20 });\n      expect(urls.length).to.equal(1);\n      await pageHasSecureReplyContainer(t, browser, gmailPage);\n      const pubkeyPage = await browser.newPage(t, urls[0]);\n      await pubkeyPage.waitForContent('@container-pgp-pubkey', 'Fingerprint: DC26 454A FB71 D18E ABBA D73D 1C7E 6D3C 5563 A941');\n    }));\n\n    ava.default('mail.google.com - pubkey gets rendered with new signed and encrypted Thunderbird signature', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await openGmailPage(t, browser, '/FMfcgxwKjKvbtvZqhhqKGLQFkBmsvVjt');\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/pgp_pubkey.htm'], { sleep: 10, appearIn: 20 });\n      expect(urls.length).to.equal(1);\n      await pageHasSecureReplyContainer(t, browser, gmailPage);\n      const pubkeyPage = await browser.newPage(t, urls[0]);\n      await pubkeyPage.waitForContent('@container-pgp-pubkey', 'Fingerprint: DCB2 74D2 4683 145E B053 BC0B 48E4 74A0 926B AE86');\n    }));\n\n    // flaky test\n    ava.default.skip('mail.google.com - secure reply btn, reply draft', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await openGmailPage(t, browser, '/FMfcgxwJXVGtMJwQTZmBDlspVWDvsnnL'); // encrypted convo\n      await Util.sleep(5);\n      await pageHasSecureReplyContainer(t, browser, gmailPage, { isReplyPromptAccepted: false });\n      await gmailPage.waitAndClick('@secure-reply-button');\n      await Util.sleep(3);\n      await gmailPage.page.keyboard.type('hey there');\n      await Util.sleep(5);\n      await gmailPage.page.reload();\n      await Util.sleep(3);\n      const replyBox = await pageHasSecureDraft(t, browser, gmailPage, 'hey there');\n      await replyBox.waitAndClick('@action-send');\n      await Util.sleep(5);\n      await replyBox.close();\n      await gmailPage.page.reload();\n      await gmailPage.waitAndClick('.h7:last-child .ajz', { delay: 1 }); // the small triangle which toggles the message details\n      await gmailPage.waitForContent('.h7:last-child .ajA', 'Re: [ci.test] encrypted email for reply render'); // make sure that the subject of the sent draft is corrent\n      await GmailPageRecipe.deleteLastReply(gmailPage);\n    }));\n\n    ava.default('mail.google.com - plain reply to encrypted and signed messages', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await openGmailPage(t, browser, '/KtbxLvgswQbRmwVxNgDrtvttRPRBtMwKvq'); // plain convo\n      await Util.sleep(1);\n      await gmailPage.waitAndClick('[data-tooltip=\"Reply\"]');\n      await gmailPage.goto(TestUrls.gmail(0, '/FMfcgxwJXVGtMJwQTZmBDlspVWDvsnnL')); // encrypted convo\n      await Util.sleep(1);\n      await gmailPage.waitAndClick('[data-tooltip=\"Reply\"]');\n      await Util.sleep(5);\n      await pageDoesNotHaveSecureReplyContainer(gmailPage);\n      await gmailPage.waitAll('[data-tooltip^=\"Send\"]'); // The Send button from the Standard reply box\n      await gmailPage.waitForContent('.reply_message_evaluated .error_notification', 'The last message was encrypted, but you are composing a reply without encryption.');\n      await gmailPage.waitAndClick('[data-tooltip=\"Secure Reply\"]'); // Switch to encrypted reply\n      await Util.sleep(5);\n      await pageHasSecureReplyContainer(t, browser, gmailPage, { isReplyPromptAccepted: false });\n      await gmailPage.goto(TestUrls.gmail(0, '/FMfcgxwJXVGtMMLhrwhNcLBMCbFtpMhQ')); // signed convo\n      await Util.sleep(1);\n      await gmailPage.waitAndClick('[data-tooltip=\"Reply\"]');\n      await pageDoesNotHaveSecureReplyContainer(gmailPage);\n      await gmailPage.notPresent('.reply_message_evaluated .error_notification'); // should not show the warning about switching to encrypted reply\n    }));\n\n    ava.default('mail.google.com - plain reply draft', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await openGmailPage(t, browser, '/FMfcgxwJXVGtMNSCdRMcmZVWkwpxqFdF'); // encrypted convo\n      await gmailPage.waitAndClick('[data-tooltip=\"Reply\"]');\n      await Util.sleep(5);\n      await gmailPage.type('div[aria-label=\"Message Body\"]', 'plain reply', true);\n      await gmailPage.goto(TestUrls.gmail(0, '')); // go to Inbox\n      await Util.sleep(1);\n      await gmailPage.goto(TestUrls.gmail(0, '/FMfcgxwJXVGtMNSCdRMcmZVWkwpxqFdF')); // go back to convo with plain reply\n      await pageDoesNotHaveSecureReplyContainer(gmailPage);\n      await gmailPage.waitForContent('div[aria-label=\"Message Body\"]', 'plain reply');\n      await gmailPage.click('[aria-label^=\"Discard draft\"]');\n    }));\n\n    ava.default('mail.google.com - pubkey file gets rendered', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const gmailPage = await openGmailPage(t, browser, '/FMfcgxwJXVGtMNSfLJNxtJFfwbcjprpq');\n      const urls = await gmailPage.getFramesUrls(['/chrome/elements/pgp_pubkey.htm'], { sleep: 10, appearIn: 20 });\n      expect(urls.length).to.equal(1);\n      await pageHasSecureReplyContainer(t, browser, gmailPage);\n    }));\n\n    // ava.default('mail.google.com - reauth after uuid change', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n    //   const acct = 'ci.tests.gmail@flowcrypt.dev';\n    //   const settingsPage = await browser.newPage(t, TestUrls.extensionSettings(acct));\n    //   await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n    //   const experimentalFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-module-experimental', ['experimental.htm']);\n    //   await experimentalFrame.waitAndClick('@action-regenerate-uuid');\n    //   await Util.sleep(2);\n    //   const oauthPopup = await browser.newPageTriggeredBy(t, () => PageRecipe.waitForModalAndRespond(settingsPage, 'confirm',\n    //     { contentToCheck: 'Please log in with FlowCrypt to continue', clickOn: 'confirm' }));\n    //   await OauthPageRecipe.google(t, oauthPopup, acct, 'login');\n    //   await settingsPage.close();\n    //   // load gmail and test that it has no notifications\n    //   const gmailPage = await BrowserRecipe.openGmailPage(t, browser);\n    //   await gmailPage.waitAndClick('@action-secure-compose');\n    //   await Util.sleep(10);\n    //   await gmailPage.notPresent(['@webmail-notification']);\n    // }));\n\n    // todo - missing equivalent sample at ci.tests.gmail\n    // ava.default('mail.google.com - pubkey gets rendered when using quoted-printable mime', testWithBrowser('compatibility', async (t, browser) => {\n    //   const gmailPage = await openGmailPage(t, browser, '/WhctKJVRFztXGwvSbwcrbDshGTnLWMFvhwJmhqllRWwvpKnlpblQMXVZLTsKfWdPWKhPFBV');\n    //   const urls = await gmailPage.getFramesUrls(['/chrome/elements/pgp_pubkey.htm'], { sleep: 10, appearIn: 20 });\n    //   expect(urls.length).to.equal(1);\n    //   await pageHasSecureReplyContainer(t, browser, gmailPage);\n    //   const pubkeyPage = await browser.newPage(t, urls[0]);\n    //   const content = await pubkeyPage.read('body');\n    //   expect(content).to.contain('Fingerprint: 7A2E 4FFD 34BC 4AED 0F54 4199 D652 7AD6 65C3 B0DD');\n    // }));\n\n    const testMinimumElementHeight = async (page: ControllablePage, selector: string, min: number) => {\n      // testing https://github.com/FlowCrypt/flowcrypt-browser/issues/3519\n      const elStyle = await page.target.$eval(selector, el => el.getAttribute('style')); // 'height: 289.162px;'\n      const elHeight = Number(elStyle!.replace('height: ', '').replace('px;', ''));\n      if (isNaN(elHeight)) {\n        throw Error(`msgIframeHeight iNaN`);\n      }\n      expect(elHeight).to.be.above(min, 'Expected iframe height above 80px (in particular not expecting 60 or 30 which are defaults suggesting failure)');\n    };\n\n  }\n};\n",
    "test/source/tests/page-recipe/abstract-page-recipe.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { BrowserHandle, Controllable, ControllablePage } from '../../browser';\n\nimport { AvaContext } from '../tooling/';\nimport { ElementHandle, JSHandle } from 'puppeteer';\nimport { expect } from 'chai';\n\ntype ModalOpts = { contentToCheck?: string, clickOn?: 'confirm' | 'cancel', getTriggeredPage?: boolean, timeout?: number };\ntype ModalType = 'confirm' | 'error' | 'info' | 'warning';\n\nexport abstract class PageRecipe {\n  public static getElementPropertyJson = async (elem: ElementHandle<Element>, property: string) => {\n    return await (await elem.getProperty(property) as JSHandle).jsonValue() as string;\n  }\n\n  public static waitForModalAndRespond = async (controllable: Controllable, type: ModalType, { contentToCheck, clickOn, timeout }: ModalOpts) => {\n    const modalContainer = await controllable.waitAny(`.ui-modal-${type}`, { timeout });\n    if (typeof contentToCheck !== 'undefined') {\n      const contentElement = await modalContainer.$('.swal2-html-container');\n      expect(await PageRecipe.getElementPropertyJson(contentElement!, 'textContent')).to.include(contentToCheck);\n    }\n    if (clickOn) {\n      const button = await modalContainer.$(`button.ui-modal-${type}-${clickOn}`);\n      await button!.click();\n    }\n  }\n\n  /**\n   * responding to modal triggers a new page to be open, eg oauth login page\n   */\n  public static async waitForModalGetTriggeredPageAfterResponding(\n    t: AvaContext, browser: BrowserHandle, controllable: ControllablePage, type: ModalType, modalOpts: ModalOpts\n  ): Promise<ControllablePage> {\n    return await browser.newPageTriggeredBy(t, () => PageRecipe.waitForModalAndRespond(controllable, type, modalOpts));\n  }\n\n}\n",
    "test/source/tests/page-recipe/compose-page-recipe.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { BrowserHandle, Controllable, ControllablePage } from '../../browser';\n\nimport { AvaContext } from '../tooling/';\nimport { CommonAcct } from '../../test';\nimport { EvaluateFn } from 'puppeteer';\nimport { PageRecipe } from './abstract-page-recipe';\nimport { Util } from '../../util';\n\ntype RecipientType = \"to\" | \"cc\" | \"bcc\";\ntype Recipients = {\n  [key in RecipientType]?: string;\n};\n\ntype PopoverOpt = 'encrypt' | 'sign' | 'richtext';\n\nexport class ComposePageRecipe extends PageRecipe {\n\n  public static async openStandalone(\n    t: AvaContext, browser: BrowserHandle, group: CommonAcct | string, options:\n      { appendUrl?: string, hasReplyPrompt?: boolean, skipClickPropt?: boolean, skipValidation?: boolean, initialScript?: EvaluateFn } = {}\n  ): Promise<ControllablePage> {\n    if (group === 'compatibility') { // More common accounts\n      group = 'flowcrypt.compatibility@gmail.com';\n    } else if (group === 'compose') {\n      group = 'ci.tests.gmail@flowcrypt.test';\n    }\n    const email = encodeURIComponent(group);\n    const composePage = await browser.newPage(t, `chrome/elements/compose.htm?account_email=${email}&parent_tab_id=0&debug=___cu_true___&frameId=none&${options.appendUrl || ''}`,\n      options.initialScript);\n    // await composePage.page.on('console', msg => console.log(`compose-dbg:${msg.text()}`));\n    if (!options.skipValidation) {\n      if (!options.hasReplyPrompt) {\n        await composePage.waitAll(['@input-body', '@input-subject', '@action-send']);\n        await composePage.waitAny(['@action-show-container-cc-bcc-buttons', '@container-cc-bcc-buttons']);\n      } else {\n        if (options.skipClickPropt) {\n          await Util.sleep(2);\n        } else {\n          await composePage.waitAll(['@action-accept-reply-prompt']);\n        }\n      }\n      await composePage.waitForSelTestState('ready');\n    }\n    return composePage;\n  }\n\n  public static async fillMsg(\n    composePageOrFrame: Controllable,\n    recipients: Recipients,\n    subject?: string | undefined,\n    sendingOpt: { encrypt?: boolean, sign?: boolean, richtext?: boolean } = {}, // undefined means leave default\n    windowType: 'new' | 'reply' = 'new'\n  ) {\n    await Util.sleep(0.5);\n    await ComposePageRecipe.fillRecipients(composePageOrFrame, recipients, windowType);\n    if (subject) {\n      await composePageOrFrame.click('@input-subject');\n      await Util.sleep(1);\n      await composePageOrFrame.type('@input-subject', subject?.match(/RTL/) ? subject : `Automated puppeteer test: ${subject}`);\n    }\n    const sendingOpts = sendingOpt as { [key: string]: boolean | undefined };\n    for (const opt of Object.keys(sendingOpts)) {\n      const shouldBeTicked = sendingOpts[opt];\n      if (typeof shouldBeTicked !== 'undefined') {\n        await ComposePageRecipe.setPopoverToggle(composePageOrFrame, opt as PopoverOpt, shouldBeTicked);\n      }\n    }\n    const body = subject?.match(/RTL/) ? 'مرحبا' : `This is an automated puppeteer test: ${subject || '(no-subject)'}`;\n    await composePageOrFrame.type('@input-body', body);\n    return { subject, body };\n  }\n\n  public static setPopoverToggle = async (composePageOrFrame: Controllable, opt: PopoverOpt, shouldBeTicked: boolean) => {\n    await composePageOrFrame.waitAndClick('@action-show-options-popover');\n    await composePageOrFrame.waitAll('@container-sending-options');\n    const isCurrentlyTicked = await composePageOrFrame.isElementPresent(`@icon-toggle-${opt}-tick`);\n    if ((!isCurrentlyTicked && shouldBeTicked) || (isCurrentlyTicked && !shouldBeTicked)) { // not in desired state\n      await composePageOrFrame.waitAndClick(`@action-toggle-${opt}`); // toggling should set it to desired state\n    } else { // in desired state\n      await composePageOrFrame.waitAndClick('@input-body'); // close popover\n    }\n    await composePageOrFrame.waitTillGone('@container-sending-options');\n  }\n\n  public static fillRecipients = async (composePageOrFrame: Controllable, recipients: Recipients, windowType: 'new' | 'reply' | 'forward') => {\n    if (windowType === 'reply') { // new messages should already have cc/bcc buttons visible, because they should have recipients in focus\n      await composePageOrFrame.waitAndClick('@action-show-container-cc-bcc-buttons');\n    }\n    await composePageOrFrame.waitAll('@container-cc-bcc-buttons');\n    for (const key of Object.keys(recipients)) {\n      const sendingType = key as RecipientType;\n      const email = recipients[sendingType] as string | undefined;\n      if (email) {\n        if (sendingType !== 'to') { // input-to is always visible\n          await composePageOrFrame.waitAndClick(`@action-show-${sendingType}`);\n        }\n        await composePageOrFrame.waitAndType(`@input-${sendingType}`, email);\n        await Util.sleep(1);\n      }\n    }\n    await composePageOrFrame.target.evaluate(() => { $('#input_text').focus(); });\n    await Util.sleep(1);\n  }\n\n  public static waitWhenDraftIsSaved = async (composePageOrFrame: Controllable) => {\n    await composePageOrFrame.verifyContentIsPresentContinuously('@send-btn-note', 'Saved');\n  }\n\n  public static waitWhenDraftIsSavedLocally = async (composePageOrFrame: Controllable) => {\n    await composePageOrFrame.verifyContentIsPresentContinuously('@send-btn-note', 'Draft saved locally (offline)');\n  }\n\n  public static sendAndClose = async (\n    composePage: ControllablePage,\n    { password, timeout, expectProgress }: { password?: string, timeout?: number, expectProgress?: boolean } = { timeout: 60 }\n  ) => {\n    if (password) {\n      await composePage.waitAndType('@input-password', password);\n    }\n    await composePage.waitAndClick('@action-send', { delay: 1 });\n    if (expectProgress) {\n      await composePage.waitForContent('@action-send', '%', 20, 10);\n    }\n    await ComposePageRecipe.closed(composePage, timeout);\n  }\n\n  public static closed = async (composePage: ControllablePage, timeout = 60) => {\n    await Promise.race([\n      composePage.waitForSelTestState('closed', timeout), // in case this was a new message compose\n      composePage.waitAny('@container-reply-msg-successful', { timeout }) // in case of reply\n    ]);\n    await composePage.close();\n  }\n\n}\n",
    "test/source/tests/page-recipe/gmail-page-recipe.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { BrowserHandle, ControllablePage } from '../../browser';\n\nimport { AvaContext } from '../tooling/';\nimport { PageRecipe } from './abstract-page-recipe';\nimport { expect } from 'chai';\nimport { Util } from '../../util';\n\nexport class GmailPageRecipe extends PageRecipe {\n\n  public static openSecureCompose = async (t: AvaContext, gmailPage: ControllablePage, browser: BrowserHandle): Promise<ControllablePage> => {\n    await gmailPage.waitAndClick('@action-secure-compose', { delay: 1 });\n    await gmailPage.waitAll('@container-new-message');\n    const urls = await gmailPage.getFramesUrls(['/chrome/elements/compose.htm'], { sleep: 1 });\n    expect(urls.length).to.equal(1);\n    return await browser.newPage(t, `${urls[0]}&debug=___cu_true___`);\n  }\n\n  public static getSubscribeDialog = async (t: AvaContext, gmailPage: ControllablePage, browser: BrowserHandle): Promise<ControllablePage> => {\n    await gmailPage.waitAll('@dialog-subscribe');\n    const urls = await gmailPage.getFramesUrls(['/chrome/elements/subscribe.htm'], { sleep: 1 });\n    expect(urls.length).to.equal(1);\n    return await browser.newPage(t, urls[0]);\n  }\n\n  public static closeInitialSetupNotif = async (gmailPage: ControllablePage) => {\n    await gmailPage.waitAndClick('@notification-successfully-setup-action-close');\n  }\n\n  public static deleteMessage = async (gmailPage: ControllablePage) => {\n    // the toolbar needs to be focused in order for Delete button to work\n    await gmailPage.page.keyboard.down('Shift');\n    for (let i = 0; i < 5; i++) {\n      await gmailPage.press('Tab');\n    }\n    await gmailPage.page.keyboard.up('Shift');\n    await gmailPage.waitAndClick('[aria-label=\"Delete\"]');\n  }\n\n  // todo - is this the same as the one above?\n  public static deleteLastReply = async (gmailPage: ControllablePage) => {\n    await gmailPage.waitAndClick('[aria-label=\"More\"]');\n    await gmailPage.press('ArrowDown', 5);\n    await gmailPage.press('Enter');\n    await Util.sleep(3);\n  };\n\n}\n",
    "test/source/tests/page-recipe/inbox-page-recipe.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { BrowserHandle, ControllableFrame, ControllablePage } from '../../browser';\n\nimport { AvaContext } from '../tooling/';\nimport { PageRecipe } from './abstract-page-recipe';\nimport { TestUrls } from '../../browser/test-urls';\nimport { Util } from '../../util';\n\ntype CheckDecryptMsg$opt = { acctEmail: string, threadId: string, expectedContent: string, enterPp?: string, finishCurrentSession?: boolean };\ntype CheckSentMsg$opt = { acctEmail: string, subject: string, expectedContent?: string, isEncrypted?: boolean, isSigned?: boolean, sender?: string };\n\nexport class InboxPageRecipe extends PageRecipe {\n\n  public static checkDecryptMsg = async (t: AvaContext, browser: BrowserHandle, { acctEmail, threadId, enterPp, expectedContent, finishCurrentSession }: CheckDecryptMsg$opt) => {\n    const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=${acctEmail}&threadId=${threadId}`));\n    await inboxPage.waitAll('iframe');\n    if (finishCurrentSession) {\n      await inboxPage.waitAndClick('@action-finish-session');\n      await Util.sleep(5); // give frames time to reload, else we will be manipulating them while reloading -> Error: waitForFunction failed: frame got detached.\n      await inboxPage.waitAll('iframe');\n    }\n    const pgpBlockFrame = await inboxPage.getFrame(['pgp_block.htm']);\n    await pgpBlockFrame.waitAll('@pgp-block-content');\n    await pgpBlockFrame.waitForSelTestState('ready');\n    if (enterPp) {\n      await inboxPage.notPresent(\"@action-finish-session\");\n      await pgpBlockFrame.waitAndClick('@action-show-passphrase-dialog', { delay: 1 });\n      await inboxPage.waitAll('@dialog-passphrase');\n      const ppFrame = await inboxPage.getFrame(['passphrase.htm']);\n      await ppFrame.waitAndType('@input-pass-phrase', enterPp);\n      await ppFrame.waitAndClick('@action-confirm-pass-phrase-entry', { delay: 1 });\n      await pgpBlockFrame.waitForSelTestState('ready');\n      await inboxPage.waitAll('@action-finish-session');\n      await Util.sleep(1);\n    }\n    const content = await pgpBlockFrame.read('@pgp-block-content');\n    if (content.indexOf(expectedContent) === -1) {\n      throw new Error(`message did not decrypt`);\n    }\n    await inboxPage.close();\n  }\n\n  public static checkFinishingSession = async (t: AvaContext, browser: BrowserHandle, acctEmail: string, threadId: string) => {\n    const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=${acctEmail}&threadId=${threadId}`));\n    await inboxPage.waitAll('iframe');\n    await inboxPage.waitAndClick('@action-finish-session');\n    await inboxPage.waitTillGone('@action-finish-session');\n    await Util.sleep(3); // give frames time to reload, else we will be manipulating them while reloading -> Error: waitForFunction failed: frame got detached.\n    const pgpBlockFrame = await inboxPage.getFrame(['pgp_block.htm']);\n    await pgpBlockFrame.waitAll('@pgp-block-content');\n    await pgpBlockFrame.waitForSelTestState('ready');\n    await pgpBlockFrame.waitAndClick('@action-show-passphrase-dialog', { delay: 1 });\n    await inboxPage.waitAll('@dialog-passphrase');\n  }\n\n  public static checkSentMsg = async (t: AvaContext, browser: BrowserHandle, { acctEmail, subject, expectedContent, isEncrypted, isSigned, sender }: CheckSentMsg$opt) => {\n    if (typeof isSigned !== 'undefined') {\n      throw new Error('checkSentMsg.isSigned not implemented');\n    }\n    if (typeof expectedContent !== 'undefined') {\n      throw new Error('checkSentMsg.expectedContent not implemented');\n    }\n    if (typeof isEncrypted !== 'undefined') {\n      throw new Error('checkSentMsg.isEncrypted not implemented');\n    }\n    const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=${acctEmail}&labelId=SENT`));\n    await inboxPage.waitAndClick(`@container-subject(${subject})`, { delay: 1 });\n    if (sender) { // make sure it was sent from intended addr\n      await inboxPage.waitAll(`@container-msg-header(${sender})`);\n    }\n    await inboxPage.close();\n  }\n\n  public static openAndGetComposeFrame = async (inboxPage: ControllablePage): Promise<ControllableFrame> => {\n    await inboxPage.waitAndClick('@action-open-secure-compose-window');\n    await inboxPage.waitAll('@container-new-message');\n    await Util.sleep(0.5);\n    const composeFrame = await inboxPage.getFrame(['compose.htm']);\n    await composeFrame.waitAll(['@input-body', '@input-subject', '@action-send', '@container-cc-bcc-buttons']);\n    await composeFrame.waitForSelTestState('ready');\n    return composeFrame;\n  }\n\n}\n",
    "test/source/tests/page-recipe/oauth-page-recipe.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { Config, Util } from '../../util';\nimport { AvaContext } from '../tooling/';\nimport { ControllablePage } from '../../browser';\nimport { PageRecipe } from './abstract-page-recipe';\nimport { Url } from '../../core/common';\n\nexport class OauthPageRecipe extends PageRecipe {\n\n  private static longTimeout = 40;\n\n  public static google = async (t: AvaContext, oauthPage: ControllablePage, acctEmail: string, action: \"close\" | \"deny\" | \"approve\" | 'login'): Promise<void> => {\n    try {\n      const isMock = oauthPage.target.url().includes('localhost') || oauthPage.target.url().includes('google.mock.flowcryptlocal.test');\n      if (isMock) {\n        const mockOauthUrl = oauthPage.target.url();\n        const { login_hint } = Url.parse(['login_hint'], mockOauthUrl);\n        if (action === 'close') {\n          await oauthPage.close();\n        } else if (!login_hint) {\n          await oauthPage.target.goto(mockOauthUrl + '&login_hint=' + encodeURIComponent(acctEmail) + '&proceed=true');\n        } else {\n          await oauthPage.target.goto(mockOauthUrl + '&proceed=true');\n        }\n        return;\n      }\n    } catch (e) {\n      if (String(e).includes('page has been closed')) {\n        // the extension may close the auth page after success before we had a chance to evaluate it\n        return; // in this case the login was already successful\n      }\n    }\n    const auth = Config.secrets().auth.google.find(a => a.email === acctEmail);\n    const acctPassword = auth?.password;\n    const selectors = {\n      approve_button: '#submit_approve_access',\n      email_input: '#identifierId',\n      email_confirm_btn: '#identifierNext',\n      auth0_username: '#username',\n      auth0_password: '#password',\n      auth0_login_btn: 'button', // old: ._button-login\n    };\n    try {\n      await oauthPage.waitAny('#Email, #submit_approve_access, #identifierId, .w6VTHd, #profileIdentifier', { timeout: 45 });\n      if (await oauthPage.target.$(selectors.email_input) !== null) { // 2017-style login\n        await oauthPage.waitAll(selectors.email_input, { timeout: OauthPageRecipe.longTimeout });\n        await oauthPage.waitAndType(selectors.email_input, acctEmail, { delay: 2 });\n        await oauthPage.waitAndClick(selectors.email_confirm_btn, { delay: 2 });  // confirm email\n        await oauthPage.waitForNavigationIfAny();\n      } else if (await oauthPage.target.$(`#profileIdentifier[data-email=\"${acctEmail}\"]`) !== null) { // already logged in - just choose an account\n        await oauthPage.waitAndClick(`#profileIdentifier[data-email=\"${acctEmail}\"]`, { delay: 1 });\n      } else if (await oauthPage.target.$('.w6VTHd') !== null) { // select from accounts where already logged in\n        await oauthPage.waitAndClick('.bLzI3e', { delay: 1 }); // choose other account, also try .TnvOCe .k6Zj8d .XraQ3b\n        await Util.sleep(2);\n        return await OauthPageRecipe.google(t, oauthPage, acctEmail, action); // start from beginning after clicking \"other email acct\"\n      } else if (await oauthPage.target.$('#profileIdentifier[data-email=\"dummy\"]') !== null) {\n        // let any e-mail pass\n        const href = await oauthPage.attr('#profileIdentifier', 'href') + acctEmail;\n        await oauthPage.goto(href);\n      }\n      await Util.sleep(2);\n      if (action === 'login') {\n        await Util.sleep(3);\n        if (oauthPage.page.isClosed()) {\n          return;\n        }\n        throw new Error('Oauth page didnt close after login. Should increase timeout or await close event');\n      }\n      await oauthPage.waitAny([selectors.approve_button, selectors.auth0_username]);\n      if (await oauthPage.isElementPresent(selectors.auth0_username)) {\n        await oauthPage.waitAndType(selectors.auth0_username, acctEmail);\n        if (acctPassword) {\n          await oauthPage.waitAndType(selectors.auth0_password, acctPassword);\n        }\n        await oauthPage.waitAndClick(selectors.auth0_login_btn);\n        await oauthPage.waitForNavigationIfAny();\n      }\n      await Util.sleep(1);\n      await oauthPage.waitAll(selectors.approve_button); // if succeeds, we are logged in and presented with approve/deny choice\n      // since we are successfully logged in, we may save cookies to keep them fresh\n      // no need to await the API call because it's not crucial to always save it, can mostly skip errors\n      if (action === 'close') {\n        await oauthPage.close();\n      } else if (action === 'deny') {\n        throw new Error('tests.handle_gmail_oauth options.deny.true not implemented');\n      } else {\n        await oauthPage.waitAndClick('#submit_approve_access', { delay: 1 });\n      }\n    } catch (e) {\n      const eStr = String(e);\n      if (eStr.indexOf('Execution context was destroyed') === -1 && eStr.indexOf('Cannot find context with specified id') === -1) {\n        throw e; // not a known retriable error\n      }\n      // t.log(`Attempting to retry google auth:${action} on the same window for ${email} because: ${eStr}`);\n      return await OauthPageRecipe.google(t, oauthPage, acctEmail, action); // retry, it should pick up where it left off\n    }\n  }\n\n}\n",
    "test/source/tests/page-recipe/settings-page-recipe.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { Config, Util } from '../../util';\nimport { BrowserHandle, ControllableFrame, ControllablePage } from '../../browser';\n\nimport { PageRecipe } from './abstract-page-recipe';\nimport { expect } from 'chai';\nimport { Str } from '../../core/common';\nimport { AvaContext } from '../tooling';\nimport { TestUrls } from '../../browser/test-urls';\nimport { Xss } from '../../platform/xss';\nimport { KeyUtil } from '../../core/crypto/key';\n\nexport class SettingsPageRecipe extends PageRecipe {\n\n  public static ready = async (settingsPage: ControllablePage) => {\n    await settingsPage.waitAll('@page-settings');\n    await settingsPage.waitForSelTestState('ready');\n  }\n\n  public static toggleScreen = async (settingsPage: ControllablePage, to: \"basic\" | \"additional\") => {\n    await SettingsPageRecipe.ready(settingsPage);\n    await Util.sleep(0.5);\n    await settingsPage.waitAndClick(to === 'basic' ? '@action-toggle-screen-basic' : '@action-toggle-screen-additional'); // switch\n    await Util.sleep(0.5);\n    await settingsPage.waitAll(to === 'basic' ? '@action-toggle-screen-additional' : '@action-toggle-screen-basic'); // wait for opposite button to show up\n    await Util.sleep(0.5);\n  }\n\n  public static closeDialog = async (settingsPage: ControllablePage) => {\n    await settingsPage.waitAndClick('@dialog-close', { delay: 3 });\n    await settingsPage.waitTillGone('@dialog');\n  }\n\n  public static awaitNewPageFrame = async (settingsPage: ControllablePage, actionBtnSel: string, frameUrlFilter: string[]): Promise<ControllableFrame> => {\n    await SettingsPageRecipe.ready(settingsPage);\n    await settingsPage.waitAndClick(actionBtnSel);\n    await settingsPage.waitAll('@dialog');\n    return await settingsPage.getFrame(frameUrlFilter);\n  }\n\n  public static swithAcct = async (settingsPage: ControllablePage, acctEmail: string) => {\n    await SettingsPageRecipe.ready(settingsPage);\n    await settingsPage.waitAndClick('@action-toggle-accounts-menu');\n    await settingsPage.waitAndClick(`@action-switch-to-account(${acctEmail})`);\n  }\n\n  public static changePassphrase = async (settingsPage: ControllablePage, currentPp: string | undefined, newPp: string) => {\n    await SettingsPageRecipe.ready(settingsPage);\n    const securityFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-security-page', ['security.htm', 'placement=settings']);\n    await securityFrame.waitAndClick('@action-change-passphrase-begin', { delay: 1 });\n    if (currentPp) {\n      await securityFrame.waitAndType('@input-current-pp', currentPp, { delay: 1 });\n      await securityFrame.waitAndClick('@action-confirm-current-pp', { delay: 1 });\n    }\n    await securityFrame.waitAndType('@input-new-pp', newPp, { delay: 1 });\n    await securityFrame.waitAndClick('@action-show-confirm-new-pp', { delay: 1 });\n    await securityFrame.waitAndType('@input-confirm-new-pp', newPp, { delay: 1 });\n    await securityFrame.waitAndClick('@action-confirm-new-pp', { delay: 1 });\n    await securityFrame.waitAndRespondToModal('info', 'confirm', 'Now that you changed your pass phrase, you should back up your key');\n    await securityFrame.waitAll('@container-backup-dialog'); // offers a new backup\n    await securityFrame.waitAndClick('@input-backup-step3manual-file');\n    await securityFrame.waitAndClick('@action-backup-step3manual-continue');\n    await securityFrame.waitAndRespondToModal('info', 'confirm', 'Downloading private key backup file');\n    await securityFrame.waitAndRespondToModal('info', 'confirm', 'Your private key has been successfully backed up');\n  }\n\n  public static forgetAllPassPhrasesInStorage = async (settingsPage: ControllablePage, passphrase: string) => {\n    await SettingsPageRecipe.ready(settingsPage);\n    const securityFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-security-page', ['security.htm', 'placement=settings']);\n    await securityFrame.waitAndClick('@action-forget-pp');\n    await securityFrame.waitAndType('@input-confirm-pass-phrase', passphrase);\n    await securityFrame.waitAndClick('@action-confirm-pass-phrase-requirement-change');\n    await SettingsPageRecipe.closeDialog(settingsPage);\n  }\n\n  public static verifyMyKeyPage = async (settingsPage: ControllablePage, expectedKeyName: string, trigger: \"button\" | \"link\", linkIndex?: number) => {\n    await SettingsPageRecipe.ready(settingsPage);\n    await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n    const myKeyFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage,\n      trigger === 'button' ? '@action-open-pubkey-page' : `@action-show-key-${linkIndex}`, ['my_key.htm', 'placement=settings']);\n    await Util.sleep(1);\n    const k = Config.key(expectedKeyName);\n    await myKeyFrame.waitAll('@content-fingerprint');\n    if (!k.longid) {\n      throw new Error(`Missing key longid for tests: ${expectedKeyName}`);\n    }\n    expect(await myKeyFrame.read('@content-fingerprint')).to.contain(Str.spaced(k.longid));\n    await SettingsPageRecipe.closeDialog(settingsPage);\n    await SettingsPageRecipe.toggleScreen(settingsPage, 'basic');\n  }\n\n  public static passphraseTest = async (settingsPage: ControllablePage, passphrase: string, expectMatch: boolean) => {\n    await SettingsPageRecipe.ready(settingsPage);\n    const securityFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-security-page', ['security.htm', 'placement=settings']);\n    await securityFrame.waitAndClick('@action-test-passphrase-begin');\n    await securityFrame.waitAndType('@input-test-passphrase', passphrase);\n    await securityFrame.waitAndClick('@action-test-passphrase', { delay: 0.5 });\n    if (expectMatch) {\n      await securityFrame.waitAndClick('@action-test-passphrase-successful-close');\n    } else {\n      await securityFrame.waitAndRespondToModal('warning', 'confirm', 'not match');\n      await SettingsPageRecipe.closeDialog(settingsPage);\n    }\n    await settingsPage.waitTillGone('@dialog');\n  }\n\n  public static addKeyTest = async (t: AvaContext, browser: BrowserHandle, acctEmail: string, armoredPrvKey: string, passphrase: string) => {\n    const addPrvPage = await browser.newPage(t, `/chrome/settings/modules/add_key.htm?acctEmail=${Xss.escape(acctEmail)}&parent_tab_id=0`);\n    await addPrvPage.waitAndClick('#source_paste');\n    await addPrvPage.waitAndType('.input_private_key', armoredPrvKey);\n    await addPrvPage.waitAndClick('#toggle_input_passphrase');\n    await addPrvPage.waitAndType('#input_passphrase', passphrase);\n    await addPrvPage.waitAndClick('.action_add_private_key', { delay: 1 });\n    await addPrvPage.waitTillGone('.swal2-container'); // dialog closed\n    await Util.sleep(1);\n    await addPrvPage.close();\n    await Util.sleep(1);\n    const settingsPage = await browser.newPage(t, TestUrls.extensionSettings(acctEmail));\n    await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n    const key = await KeyUtil.parse(armoredPrvKey);\n    const fp = Str.spaced(Xss.escape(key.id));\n    await settingsPage.waitForContent('@container-settings-keys-list', fp); // confirm key successfully loaded\n    await settingsPage.close();\n  }\n}\n",
    "test/source/tests/page-recipe/setup-page-recipe.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { Config, Util } from '../../util';\n\nimport { ControllablePage } from '../../browser';\nimport { PageRecipe } from './abstract-page-recipe';\nimport { SettingsPageRecipe } from './settings-page-recipe';\nimport { expect } from 'chai';\n\ntype ManualEnterOpts = {\n  usedPgpBefore?: boolean,\n  savePassphrase?: boolean,\n  submitPubkey?: boolean,\n  fixKey?: boolean,\n  naked?: boolean,\n  genPp?: boolean,\n  simulateRetryOffline?: boolean,\n  noPrvCreateOrgRule?: boolean,\n  enforceAttesterSubmitOrgRule?: boolean,\n  noPubSubmitRule?: boolean,\n  fillOnly?: boolean,\n  key?: { title: string, passphrase: string, armored: string | null, longid: string | null, filePath?: string }\n};\n\ntype CreateKeyOpts = {\n  key?: { passphrase: string },\n  usedPgpBefore?: boolean,\n  submitPubkey?: boolean,\n  enforcedAlgo?: string | boolean,\n};\n\nexport class SetupPageRecipe extends PageRecipe {\n\n  public static createKey = async (\n    settingsPage: ControllablePage,\n    keyTitle: string,\n    backup: 'none' | 'email' | 'file' | 'disabled',\n    { usedPgpBefore = false, submitPubkey = false, enforcedAlgo = false, key }: CreateKeyOpts = {}\n  ) => {\n    await SetupPageRecipe.createBegin(settingsPage, keyTitle, { key, usedPgpBefore });\n    if (enforcedAlgo) {\n      expect(await settingsPage.value('@input-step2bmanualcreate-key-type')).to.equal(enforcedAlgo);\n      expect(await settingsPage.isDisabled('@input-step2bmanualcreate-key-type')).to.equal(true);\n    }\n    if (backup === 'disabled') { // user not given a backup choice due to NO_PRV_BACKUP OrgRule\n      await settingsPage.notPresent('@input-step2bmanualcreate-backup-inbox');\n    } else { // uncheck - because want to choose backup manually\n      await settingsPage.waitAndClick('@input-step2bmanualcreate-backup-inbox');\n    }\n    if (!submitPubkey && await settingsPage.isElementPresent('@input-step2bmanualcreate-submit-pubkey')) {\n      await settingsPage.waitAndClick('@input-step2bmanualcreate-submit-pubkey'); // uncheck\n    }\n    await settingsPage.waitAndClick('@input-step2bmanualcreate-create-and-save');\n    await settingsPage.waitAndRespondToModal('confirm-checkbox', 'confirm', 'Please write down your pass phrase');\n    if (backup === 'none') {\n      await settingsPage.waitAll('@input-backup-step3manual-no-backup', { timeout: 90 });\n      await settingsPage.waitAndClick('@input-backup-step3manual-no-backup');\n    } else if (backup === 'email') {\n      throw new Error('tests.setup_manual_create options.backup=email not implemented');\n    } else if (backup === 'file') {\n      await settingsPage.waitAndClick('@input-backup-step3manual-file');\n    } else if (backup !== 'disabled') {\n      throw new Error(`Unknown backup method: ${backup}`);\n    }\n    if (backup !== 'disabled') {\n      await settingsPage.waitAndClick('@action-backup-step3manual-continue');\n      if (backup === 'file') { // explicit wait first with longer timeout - keygen can take a while, particularly with other tests in parallel\n        await settingsPage.waitAll('@ui-modal-info', { timeout: 60 });\n        await settingsPage.waitAndRespondToModal('info', 'confirm', 'Downloading private key backup file');\n      }\n    }\n    await settingsPage.waitAll('@action-step4done-account-settings', { timeout: 60 }); // create key timeout\n    await settingsPage.waitAndClick('@action-step4done-account-settings');\n    await SettingsPageRecipe.ready(settingsPage);\n  }\n\n  public static async manualEnter(\n    settingsPage: ControllablePage,\n    keyTitle: string,\n    {\n      usedPgpBefore = false,\n      savePassphrase = false,\n      submitPubkey = false,\n      fixKey = false,\n      naked = false,\n      genPp = false,\n      simulateRetryOffline = false,\n      noPrvCreateOrgRule = false,\n      enforceAttesterSubmitOrgRule = false,\n      fillOnly = false,\n      noPubSubmitRule = false,\n      key,\n    }: ManualEnterOpts = {}\n  ) {\n    if (!noPrvCreateOrgRule) {\n      if (usedPgpBefore) {\n        await settingsPage.waitAndClick('@action-step0foundkey-choose-manual-enter', { retryErrs: true });\n      } else {\n        await settingsPage.waitAndClick('@action-step1easyormanual-choose-manual-enter', { retryErrs: true });\n      }\n    }\n    key = key || Config.key(keyTitle);\n    if (!key) {\n      throw new Error(`missing key to import with title ${keyTitle}`);\n    } else if (key.armored) { // pasted directly into the input\n      await settingsPage.waitAndClick('@input-step2bmanualenter-source-paste', { retryErrs: true });\n      await settingsPage.waitAndType('@input-step2bmanualenter-ascii-key', key.armored);\n    } else if (key.filePath) { // inputted as a file\n      await settingsPage.waitAndClick('@input-step2bmanualenter-file', { retryErrs: true });\n      await Util.sleep(0.5);\n      const fileInput = await settingsPage.target.$('input[type=file]');\n      await fileInput!.uploadFile(key.filePath);\n      await Util.sleep(1);\n    } else {\n      throw new Error('dont know how to import test key because missing both \"armored\" and \"filePath\"');\n    }\n    await settingsPage.waitAndClick('@input-step2bmanualenter-passphrase'); // blur ascii key input\n    if (noPrvCreateOrgRule) { // NO_PRV_CREATE cannot use the back button, so that they cannot select another setup method\n      await settingsPage.notPresent('@action-setup-go-back');\n    }\n    if (savePassphrase) {\n      await settingsPage.waitAndClick('@input-step2bmanualenter-save-passphrase');\n    }\n    if (!naked) {\n      await Util.sleep(1);\n      await settingsPage.notPresent('@action-step2bmanualenter-new-random-passphrase');\n      await settingsPage.waitAndType('@input-step2bmanualenter-passphrase', key.passphrase);\n      await Util.sleep(1);\n    } else {\n      await settingsPage.waitAndClick('@input-step2bmanualenter-passphrase');\n      await settingsPage.waitAll('@action-step2bmanualenter-new-random-passphrase', { visible: true });\n      if (genPp) {\n        await settingsPage.waitAndClick('@action-step2bmanualenter-new-random-passphrase');\n        await Util.sleep(1);\n        const generatedPp = await settingsPage.value('@input-step2bmanualenter-passphrase');\n        if (!/^[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}$/.test(generatedPp)) {\n          throw new Error(`Import naked key page did not generate proper pass phrase, instead got: ${generatedPp}`);\n        }\n        const ppValidationExpect = 'GREAT (time to crack: centuries)';\n        const ppValidationResult = await settingsPage.read('@container-password-feedback', true);\n        if (!ppValidationResult.includes(ppValidationExpect)) {\n          throw new Error(`Incorrect Passphrase validation result, expected '${ppValidationExpect}' but got ${ppValidationResult}`);\n        }\n      } else {\n        await settingsPage.waitAndType('@input-step2bmanualenter-passphrase', key.passphrase);\n      }\n    }\n    if (enforceAttesterSubmitOrgRule || noPubSubmitRule) {\n      await settingsPage.notPresent('@input-step2bmanualenter-submit-pubkey');\n    } else {\n      await settingsPage.waitAll('@input-step2bmanualenter-submit-pubkey');\n      if (!submitPubkey) {\n        await settingsPage.waitAndClick('@input-step2bmanualenter-submit-pubkey'); // uncheck\n      }\n    }\n    await settingsPage.waitAll('@input-step2bmanualenter-save');\n    if (fillOnly) {\n      return;\n    }\n    try {\n      if (simulateRetryOffline) {\n        await settingsPage.page.setOfflineMode(true); // offline mode\n      }\n      await settingsPage.waitAndClick('@input-step2bmanualenter-save', { delay: 1 });\n      if (fixKey) {\n        await settingsPage.waitAll('@input-compatibility-fix-expire-years');\n        await settingsPage.selectOption('@input-compatibility-fix-expire-years', '1');\n        await settingsPage.waitAndClick('@action-fix-and-import-key');\n      }\n      if (simulateRetryOffline) {\n        await settingsPage.waitAll(['@action-overlay-retry', '@container-overlay-prompt-text', '@action-show-overlay-details'], { timeout: fixKey ? 45 : 20 });\n        await Util.sleep(0.5);\n        expect(await settingsPage.read('@container-overlay-prompt-text')).to.contain('Network connection issue');\n        await settingsPage.click('@action-show-overlay-details');\n        await settingsPage.waitAll('@container-overlay-details');\n        await Util.sleep(0.5);\n        expect(await settingsPage.read('@container-overlay-details')).to.contain('Error stack');\n        expect(await settingsPage.read('@container-overlay-details')).to.contain('censored:idToken');\n        await settingsPage.page.setOfflineMode(false); // back online\n        await settingsPage.click('@action-overlay-retry');\n        // after retry, the rest should continue as usual below\n      }\n      await settingsPage.waitAll('@action-step4done-account-settings', { timeout: fixKey ? 90 : 20 });\n      await settingsPage.waitAndClick('@action-step4done-account-settings');\n      await SettingsPageRecipe.ready(settingsPage);\n    } finally {\n      await settingsPage.page.setOfflineMode(false); // in case this tab is reused for other tests (which it shouldn't)\n    }\n  }\n\n  // eslint-disable-next-line max-len\n  public static recover = async (settingsPage: ControllablePage, keyTitle: string, { wrongPp = false, clickRecoverMore = false, hasRecoverMore = false, alreadyRecovered = false }: { wrongPp?: boolean, clickRecoverMore?: boolean, hasRecoverMore?: boolean, alreadyRecovered?: boolean } = {}) => {\n    const k = Config.key(keyTitle);\n    await settingsPage.waitAll('@input-recovery-pass-phrase', { timeout: 40 }); // can sometimes be slow\n    await settingsPage.waitAndType('@input-recovery-pass-phrase', k.passphrase);\n    await Util.sleep(1); // wait for button to color\n    await settingsPage.waitAndClick('@action-recover-account');\n    if (wrongPp) {\n      await settingsPage.waitAndRespondToModal('warning', 'confirm', 'not match');\n    } else if (alreadyRecovered) {\n      await settingsPage.waitAndRespondToModal('warning', 'confirm', 'matches a key that was already recovered');\n    } else {\n      await settingsPage.waitAny(['@action-step4more-account-settings', '@action-step4done-account-settings'], { timeout: 60 });\n      if (hasRecoverMore) {\n        await settingsPage.waitAll(['@action-step4more-account-settings', '@action-step4more-recover-remaining']);\n        if (clickRecoverMore) {\n          await settingsPage.waitAndClick('@action-step4more-recover-remaining');\n        } else {\n          await settingsPage.waitAndClick('@action-step4more-account-settings');\n          await SettingsPageRecipe.ready(settingsPage);\n        }\n      } else {\n        await settingsPage.waitAll('@action-step4done-account-settings');\n        if (clickRecoverMore) {\n          throw new Error('Invalid options chosen: has_recover_more: false, click_recover_more: true');\n        } else {\n          await settingsPage.waitAndClick('@action-step4done-account-settings');\n          await SettingsPageRecipe.ready(settingsPage);\n        }\n      }\n    }\n  }\n\n  public static autoKeygen = async (settingsPage: ControllablePage, { expectErr }: { expectErr?: { title: string, text: string } } = {}): Promise<void> => {\n    if (expectErr) {\n      await settingsPage.waitAll(['@container-err-title', '@container-err-text', '@action-retry-by-reloading']);\n      expect(await settingsPage.read('@container-err-title')).to.contain(expectErr.title);\n      expect(await settingsPage.read('@container-err-text')).to.contain(expectErr.text);\n    } else {\n      await settingsPage.waitAndClick('@action-step4done-account-settings', { retryErrs: true });\n      await SettingsPageRecipe.ready(settingsPage);\n    }\n  }\n\n  private static createBegin = async (settingsPage: ControllablePage, keyTitle: string, { key, usedPgpBefore = false }: { key?: { passphrase: string }, usedPgpBefore?: boolean } = {}) => {\n    const k = key || Config.key(keyTitle);\n    if (usedPgpBefore) {\n      await settingsPage.waitAndClick('@action-step0foundkey-choose-manual-create');\n    } else {\n      await settingsPage.waitAndClick('@action-step1easyormanual-choose-manual-create');\n    }\n    await settingsPage.waitAndType('@input-step2bmanualcreate-passphrase-1', k.passphrase);\n    await settingsPage.waitAndType('@input-step2bmanualcreate-passphrase-2', k.passphrase);\n  }\n\n}\n",
    "test/source/tests/settings.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as fs from 'fs';\nimport * as ava from 'ava';\nimport { Page } from 'puppeteer';\n\nimport { Config, Util } from './../util';\nimport { TestWithBrowser, internalTestState } from './../test';\n\nimport { BrowserRecipe } from './tooling/browser-recipe';\nimport { InboxPageRecipe } from './page-recipe/inbox-page-recipe';\nimport { SettingsPageRecipe } from './page-recipe/settings-page-recipe';\nimport { TestUrls } from './../browser/test-urls';\nimport { TestVariant } from './../util';\nimport { expect } from 'chai';\nimport { SetupPageRecipe } from './page-recipe/setup-page-recipe';\nimport { testConstants } from './tooling/consts';\nimport { PageRecipe } from './page-recipe/abstract-page-recipe';\nimport { OauthPageRecipe } from './page-recipe/oauth-page-recipe';\n\n// tslint:disable:no-blank-lines-func\n\nexport let defineSettingsTests = (testVariant: TestVariant, testWithBrowser: TestWithBrowser) => {\n\n  if (testVariant !== 'CONSUMER-LIVE-GMAIL') {\n\n    ava.default('settings - my own emails show as contacts', testWithBrowser('compatibility', async (t, browser) => {\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('flowcrypt.compatibility@gmail.com'));\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      const comtactsFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-contacts-page', ['contacts.htm', 'placement=settings']);\n      await comtactsFrame.waitAll('@page-contacts');\n      await Util.sleep(1);\n      expect(await comtactsFrame.read('@page-contacts')).to.contain('flowcrypt.compatibility@gmail.com');\n      expect(await comtactsFrame.read('@page-contacts')).to.contain('flowcryptcompatibility@gmail.com');\n      await SettingsPageRecipe.closeDialog(settingsPage);\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'basic');\n    }));\n\n    ava.default('settings - attester shows my emails', testWithBrowser('compatibility', async (t, browser) => {\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('flowcrypt.compatibility@gmail.com'));\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      const attesterFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-attester-page', ['keyserver.htm', 'placement=settings']);\n      await attesterFrame.waitAll('@page-attester');\n      await Util.sleep(1);\n      await attesterFrame.waitTillGone('@spinner');\n      await attesterFrame.waitForContent('@page-attester', 'flowcrypt.compatibility@gmail.com');\n      await attesterFrame.waitForContent('@page-attester', 'flowcryptcompatibility@gmail.com');\n      await SettingsPageRecipe.closeDialog(settingsPage);\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'basic');\n    }));\n\n    ava.default('settings - verify key presense 1pp1', testWithBrowser('compatibility', async (t, browser) => {\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('flowcrypt.compatibility@gmail.com'));\n      await SettingsPageRecipe.verifyMyKeyPage(settingsPage, 'flowcrypt.compatibility.1pp1', 'button');\n    }));\n\n    ava.default('settings - test pass phrase', testWithBrowser('compatibility', async (t, browser) => {\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('flowcrypt.compatibility@gmail.com'));\n      await SettingsPageRecipe.passphraseTest(settingsPage, Config.key('flowcrypt.wrong.passphrase').passphrase, false);\n      await SettingsPageRecipe.passphraseTest(settingsPage, Config.key('flowcrypt.compatibility.1pp1').passphrase, true);\n    }));\n\n    ava.todo('settings - verify 2pp1 key presense');\n    // await tests.settings_my_key_tests(settingsPage, 'flowcrypt.compatibility.2pp1', 'link');\n\n    ava.default('settings - feedback form', testWithBrowser('compatibility', async (t, browser) => {\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('flowcrypt.compatibility@gmail.com'));\n      await settingsPage.waitAndClick('@action-open-modules-help');\n      await settingsPage.waitAll('@dialog');\n      const helpFrame = await settingsPage.getFrame(['help.htm']);\n      await helpFrame.waitAndType('@input-feedback-message', 'automated puppeteer test: help form from settings footer');\n      await helpFrame.waitAndClick('@action-feedback-send');\n      await helpFrame.waitAndRespondToModal('info', 'confirm', 'Message sent!');\n    }));\n\n    ava.default('settings - view contact public key', testWithBrowser('compatibility', async (t, browser) => {\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('flowcrypt.compatibility@gmail.com'));\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      const contactsFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-contacts-page', ['contacts.htm', 'placement=settings']);\n      await contactsFrame.waitAll('@page-contacts');\n      await Util.sleep(1);\n      await contactsFrame.waitAndClick('@action-show-pubkey-flowcryptcompatibilitygmailcom', { confirmGone: true });\n      await Util.sleep(1);\n      const contacts = await contactsFrame.read('@page-contacts');\n      expect(contacts).to.contain('flowcrypt.compatibility@gmail.com');\n      // todo: will specify which one of them should appear after finished with #3332\n      // tslint:disable-next-line:no-unused-expression\n      expect(contacts.includes('7FDE 6855 48AE A788') || contacts.includes('ADAC 279C 9509 3207')).to.be.true;\n      expect(contacts).to.contain('-----BEGIN PGP PUBLIC KEY BLOCK-----');\n      await contactsFrame.waitAndClick('@action-back-to-contact-list', { confirmGone: true });\n      await Util.sleep(1);\n      expect(await contactsFrame.read('@page-contacts')).to.contain('flowcrypt.compatibility@gmail.com');\n      expect(await contactsFrame.read('@page-contacts')).to.contain('flowcryptcompatibility@gmail.com');\n      await SettingsPageRecipe.closeDialog(settingsPage);\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'basic');\n    }));\n\n    ava.default('settings - my key page - primary + secondary', testWithBrowser('compatibility', async (t, browser) => {\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('flowcrypt.compatibility@gmail.com'));\n      await SettingsPageRecipe.verifyMyKeyPage(settingsPage, 'flowcrypt.compatibility.1pp1', 'link', 0);\n      await SettingsPageRecipe.verifyMyKeyPage(settingsPage, 'flowcrypt.compatibility.2pp1', 'link', 1);\n    }));\n\n    ava.default('settings - my key page - remove key', testWithBrowser('compatibility', async (t, browser) => {\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('flowcrypt.compatibility@gmail.com'));\n      await SettingsPageRecipe.ready(settingsPage);\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      await settingsPage.waitAll('@action-open-add-key-page');\n      await settingsPage.waitAndClick('@action-remove-key');\n      await settingsPage.page.waitForNavigation({ waitUntil: 'networkidle0' });\n      await Util.sleep(1);\n      await settingsPage.waitAll('@action-open-add-key-page');\n      await settingsPage.notPresent('@action-remove-key');\n    }));\n\n    ava.default('settings - my key page - remove button should be hidden when using key manager', testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'two.keys@key-manager-autogen.flowcrypt.test';\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await SetupPageRecipe.autoKeygen(settingsPage);\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      // check imported key at index 1\n      const myKeyFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, `@action-show-key-1`, ['my_key.htm', 'placement=settings']);\n      await Util.sleep(1);\n      await myKeyFrame.waitAll('@content-fingerprint');\n      await settingsPage.notPresent('@action-remove-key');\n    }));\n\n    ava.todo('settings - edit contact public key');\n\n    ava.default('settings - change passphrase - current in local storage', testWithBrowser(undefined, async (t, browser) => {\n      const { acctEmail, settingsPage } = await BrowserRecipe.setUpFcPpChangeAcct(t, browser);\n      const newPp = `temp ci test pp: ${Util.lousyRandom()}`;\n      await SettingsPageRecipe.changePassphrase(settingsPage, undefined, newPp); // change pp and test\n      await InboxPageRecipe.checkDecryptMsg(t, browser, { acctEmail, threadId: '16819bec18d4e011', expectedContent: 'changed correctly if this can be decrypted' });\n    }));\n\n    ava.default('settings - change passphrase - current in session known', testWithBrowser(undefined, async (t, browser) => {\n      const { acctEmail, k, settingsPage } = await BrowserRecipe.setUpFcPpChangeAcct(t, browser);\n      const newPp = `temp ci test pp: ${Util.lousyRandom()}`;\n      await SettingsPageRecipe.forgetAllPassPhrasesInStorage(settingsPage, k.passphrase);\n      // decrypt msg and enter pp so that it's remembered in session\n      await InboxPageRecipe.checkDecryptMsg(t, browser, { acctEmail, threadId: '16819bec18d4e011', expectedContent: 'changed correctly if this can be decrypted', enterPp: k.passphrase });\n      // change pp - should not ask for pp because already in session\n      await SettingsPageRecipe.changePassphrase(settingsPage, undefined, newPp);\n      // now it will remember the pass phrase so decrypts without asking\n      await InboxPageRecipe.checkDecryptMsg(t, browser, { acctEmail, threadId: '16819bec18d4e011', expectedContent: 'changed correctly if this can be decrypted' });\n      // test decrypt - should ask for new pass phrase\n      await InboxPageRecipe.checkDecryptMsg(t, browser, {\n        acctEmail, threadId: '16819bec18d4e011',\n        expectedContent: 'changed correctly if this can be decrypted', enterPp: newPp, finishCurrentSession: true\n      });\n    }));\n\n    ava.default('settings - change passphrase - current in session unknown', testWithBrowser(undefined, async (t, browser) => {\n      const { acctEmail, k, settingsPage } = await BrowserRecipe.setUpFcPpChangeAcct(t, browser);\n      const newPp = `temp ci test pp: ${Util.lousyRandom()}`;\n      await SettingsPageRecipe.forgetAllPassPhrasesInStorage(settingsPage, k.passphrase);\n      // pp wiped after switching to session - should be needed to change pp\n      await SettingsPageRecipe.changePassphrase(settingsPage, k.passphrase, newPp);\n      // now it will remember the pass phrase so decrypts without asking\n      await InboxPageRecipe.checkDecryptMsg(t, browser, { acctEmail, threadId: '16819bec18d4e011', expectedContent: 'changed correctly if this can be decrypted' });\n      // test decrypt - should ask for new pass phrase\n      await InboxPageRecipe.checkDecryptMsg(t, browser, {\n        acctEmail, threadId: '16819bec18d4e011',\n        expectedContent: 'changed correctly if this can be decrypted', enterPp: newPp, finishCurrentSession: true\n      });\n    }));\n\n    ava.default('settings - Catch.reportErr reports an error', testWithBrowser('compatibility', async (t, browser) => {\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('flowcrypt.compatibility@gmail.com'));\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      const experimentalFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-module-experimental', ['experimental.htm']);\n      await experimentalFrame.waitAndClick('@action-throw-err'); // mock tests will verify that err was reported to mock backend in `test.ts`\n      internalTestState.expectIntentionalErrReport = true;\n    }));\n\n    ava.default('settings - attachment previews are rendered according to their types', testWithBrowser('compatibility', async (t, browser) => {\n      const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=flowcrypt.compatibility@gmail.com&threadId=174ab0ba9643b4fa`));\n      // image\n      const attachmentImage = await inboxPage.getFrame(['attachment.htm', 'name=tiny-face.png']);\n      await attachmentImage.waitForSelTestState('ready');\n      await attachmentImage.click('body');\n      const attachmentPreviewImage = await inboxPage.getFrame(['attachment_preview.htm']);\n      await attachmentPreviewImage.waitAll('#attachment-preview-container img.attachment-preview-img');\n      await inboxPage.press('Escape');\n      // text\n      const attachmentText = await inboxPage.getFrame(['attachment.htm', 'name=small.txt']);\n      await attachmentText.waitForSelTestState('ready');\n      await attachmentText.click('body');\n      const attachmentPreviewText = await inboxPage.getFrame(['attachment_preview.htm']);\n      await attachmentPreviewText.waitForContent('#attachment-preview-container .attachment-preview-txt', 'small text file');\n      await inboxPage.press('Escape');\n      // pdf\n      const attachmentPdf = await inboxPage.getFrame(['attachment.htm', 'name=small.pdf']);\n      await attachmentPdf.waitForSelTestState('ready');\n      await attachmentPdf.click('body');\n      const attachmentPreviewPdf = await inboxPage.getFrame(['attachment_preview.htm']);\n      await attachmentPreviewPdf.waitAll('#attachment-preview-container.attachment-preview-pdf .attachment-preview-pdf-page');\n      await inboxPage.press('Escape');\n      // no preview\n      const attachmentOther = await inboxPage.getFrame(['attachment.htm', 'name=unknown']);\n      await attachmentOther.waitForSelTestState('ready');\n      await attachmentOther.click('body');\n      const attachmentPreviewOther = await inboxPage.getFrame(['attachment_preview.htm']);\n      await attachmentPreviewOther.waitForContent('#attachment-preview-container .attachment-preview-unavailable', 'No preview available');\n      await attachmentPreviewOther.waitAll('#attachment-preview-container .attachment-preview-unavailable #attachment-preview-download');\n    }));\n\n    ava.default('settings - attachment previews with entering pass phrase', testWithBrowser('compatibility', async (t, browser) => {\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings('flowcrypt.compatibility@gmail.com'));\n      const k = Config.key('flowcrypt.compatibility.1pp1');\n      await SettingsPageRecipe.forgetAllPassPhrasesInStorage(settingsPage, k.passphrase);\n      const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=flowcrypt.compatibility@gmail.com&threadId=174ab0ba9643b4fa`));\n      const attachmentImage = await inboxPage.getFrame(['attachment.htm', 'name=tiny-face.png']);\n      await attachmentImage.waitForSelTestState('ready');\n      await attachmentImage.click('body');\n      await Util.sleep(2);\n      await (inboxPage.target as Page).mouse.click(1, 1); // test closing the passphrase dialog by clicking its backdrop\n      await Util.sleep(2);\n      await inboxPage.notPresent('@dialog-passphrase');\n      await attachmentImage.click('body');\n      const passphraseDialog = await inboxPage.getFrame(['passphrase.htm']);\n      await passphraseDialog.waitAndType('@input-pass-phrase', k.passphrase);\n      await passphraseDialog.waitAndClick('@action-confirm-pass-phrase-entry');\n      const attachmentPreviewImage = await inboxPage.getFrame(['attachment_preview.htm']);\n      await attachmentPreviewImage.waitAll('#attachment-preview-container img.attachment-preview-img');\n    }));\n\n    ava.default('settings - pgp/mime preview and download attachment', testWithBrowser('compatibility', async (t, browser) => {\n      const downloadedAttachmentFilename = `${__dirname}/7 years.jpeg`;\n      Util.deleteFileIfExists(downloadedAttachmentFilename);\n      const inboxPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/inbox/inbox.htm?acctEmail=flowcrypt.compatibility@gmail.com&threadId=16e8b01f136c3d28`));\n      const pgpBlockFrame = await inboxPage.getFrame(['pgp_block.htm']);\n      // check if download is awailable\n      await pgpBlockFrame.waitAll('.download-attachment');\n      // and preview\n      await pgpBlockFrame.waitAndClick('.preview-attachment');\n      const attachmentPreviewImage = await inboxPage.getFrame(['attachment_preview.htm']);\n      await attachmentPreviewImage.waitAll('#attachment-preview-container img.attachment-preview-img');\n      // @ts-ignore\n      await (inboxPage.target as Page)._client.send('Page.setDownloadBehavior', { behavior: 'allow', downloadPath: __dirname });\n      await attachmentPreviewImage.waitAndClick('@attachment-preview-download');\n      await Util.sleep(1);\n      expect(fs.existsSync(downloadedAttachmentFilename)).to.be.true; // tslint:disable-line:no-unused-expression\n      Util.deleteFileIfExists(downloadedAttachmentFilename);\n    }));\n\n    ava.default('settings - add unprotected key', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      await SettingsPageRecipe.addKeyTest(t, browser, 'ci.tests.gmail@flowcrypt.test', testConstants.unprotectedPrvKey, 'this is a new passphrase to protect previously unprotected key');\n    }));\n\n    ava.default('settings - error modal when page parameter invalid', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const invalidParamModalPage = await browser.newPage(t, TestUrls.extension(`chrome/settings/index.htm?acctEmail=ci.tests.gmail@gmail.com&page=invalid`));\n      await Util.sleep(3);\n      await invalidParamModalPage.waitForContent('.swal2-html-container', 'An unexpected value was found for the page parameter');\n    }));\n\n    ava.default('settings - my key page - update non-first private key', testWithBrowser(undefined, async (t, browser) => {\n      const acctEmail = 'flowcrypt.test.key.multiple@gmail.com';\n      const settingsPage1 = await BrowserRecipe.openSettingsLoginApprove(t, browser, acctEmail);\n      await SetupPageRecipe.manualEnter(settingsPage1, 'unused', {\n        submitPubkey: false,\n        usedPgpBefore: false,\n        key: {\n          title: '?',\n          armored: testConstants.testKeyMultiple1b383d0334e38b28,\n          passphrase: '1234',\n          longid: '1b383d0334e38b28',\n        }\n      });\n      await settingsPage1.close();\n\n      await SettingsPageRecipe.addKeyTest(t, browser, acctEmail, testConstants.testKeyMultiple98acfa1eadab5b92, '1234');\n\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings(acctEmail));\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      // open key at index 1\n      const myKeyFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, `@action-show-key-1`, ['my_key.htm', 'placement=settings']);\n      await Util.sleep(1);\n      await myKeyFrame.waitAll('@content-fingerprint');\n      await myKeyFrame.waitAndClick('@action-update-prv');\n      await myKeyFrame.waitAndType('@input-prv-key', testConstants.testKeyMultiple98acfa1eadab5b92);\n      await myKeyFrame.type('@input-passphrase', '1234');\n      await myKeyFrame.waitAndClick('@action-update-key');\n      await PageRecipe.waitForModalAndRespond(myKeyFrame, 'confirm', { contentToCheck: 'Public and private key updated locally', clickOn: 'cancel' });\n      await settingsPage.close();\n    }));\n\n    ava.default('settings - reauth after uuid change', testWithBrowser('ci.tests.gmail', async (t, browser) => {\n      const acct = 'ci.tests.gmail@flowcrypt.test';\n      const settingsPage = await browser.newPage(t, TestUrls.extensionSettings(acct));\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      const experimentalFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-module-experimental', ['experimental.htm']);\n      await experimentalFrame.waitAndClick('@action-regenerate-uuid');\n      await Util.sleep(2);\n      const oauthPopup = await browser.newPageTriggeredBy(t, () => PageRecipe.waitForModalAndRespond(settingsPage, 'confirm',\n        { contentToCheck: 'Please log in with FlowCrypt to continue', clickOn: 'confirm' }));\n      await OauthPageRecipe.google(t, oauthPopup, acct, 'approve');\n      await Util.sleep(5);\n      await settingsPage.close();\n\n      const settingsPage1 = await browser.newPage(t, TestUrls.extensionSettings(acct));\n      await Util.sleep(10);\n      await settingsPage1.notPresent('.swal2-container');\n      await settingsPage1.close();\n    }));\n\n    ava.todo('settings - change passphrase - mismatch curent pp');\n\n    ava.todo('settings - change passphrase - mismatch new pp');\n\n  }\n\n};\n",
    "test/source/tests/setup.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as ava from 'ava';\n\nimport { TestVariant, Util } from './../util';\nimport { SetupPageRecipe } from './page-recipe/setup-page-recipe';\nimport { TestWithBrowser } from './../test';\nimport { expect } from 'chai';\nimport { SettingsPageRecipe } from './page-recipe/settings-page-recipe';\nimport { ComposePageRecipe } from './page-recipe/compose-page-recipe';\nimport { Str } from './../core/common';\nimport { MOCK_KM_LAST_INSERTED_KEY } from './../mock/key-manager/key-manager-endpoints';\nimport { BrowserRecipe } from './tooling/browser-recipe';\nimport { KeyInfo, KeyUtil } from '../core/crypto/key';\n\n// tslint:disable:no-blank-lines-func\n// tslint:disable:no-unused-expression\n/* eslint-disable no-unused-expressions */\n/* eslint-disable max-len */\n\nexport const defineSetupTests = (testVariant: TestVariant, testWithBrowser: TestWithBrowser) => {\n\n  if (testVariant !== 'CONSUMER-LIVE-GMAIL') {\n\n    // note - `SetupPageRecipe.createKey` tests are in `defineFlakyTests` - running serially\n    // because the keygen CPU spike can cause trouble to other concurrent tests\n\n    ava.todo('setup - no connection when pulling backup - retry prompt shows and works');\n\n    ava.todo('setup - simple - no connection when making a backup - retry prompt shows');\n\n    ava.todo('setup - advanced - no connection when making a backup - retry prompt shows');\n\n    ava.todo('setup - no connection when submitting public key - retry prompt shows and works');\n\n    ava.default('settings > login > close oauth window > close popup', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginButCloseOauthWindowBeforeGrantingPermission(t, browser, 'flowcrypt.test.key.imported@gmail.com');\n      await settingsPage.notPresent('.settings-banner');\n    }));\n\n    ava.default('setup - import key - do not submit - did not use before', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.imported@gmail.com');\n      await SetupPageRecipe.manualEnter(settingsPage, 'flowcrypt.test.key.used.pgp', { submitPubkey: false, usedPgpBefore: false });\n    }));\n\n    ava.default('setup - import key - submit - used before', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.used.pgp@gmail.com');\n      await SetupPageRecipe.manualEnter(settingsPage, 'flowcrypt.test.key.used.pgp', { submitPubkey: true, usedPgpBefore: true });\n    }));\n\n    ava.default('setup - import key - naked - choose my own pass phrase', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.import.naked@gmail.com');\n      await SetupPageRecipe.manualEnter(settingsPage, 'flowcrypt.test.key.naked', { submitPubkey: false, usedPgpBefore: false, naked: true });\n    }));\n\n    ava.default('setup - import key - naked - auto-generate a pass phrase', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.import.naked@gmail.com');\n      await SetupPageRecipe.manualEnter(settingsPage, 'flowcrypt.test.key.naked', { submitPubkey: false, usedPgpBefore: false, naked: true, genPp: true });\n    }));\n\n    ava.todo('setup - import key - naked - do not supply pass phrase gets error');\n\n    ava.default('setup - import key - fix key self signatures', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.imported@gmail.com');\n      await SetupPageRecipe.manualEnter(settingsPage, 'missing.self.signatures', { submitPubkey: false, fixKey: true });\n    }));\n\n    ava.default('setup - import key - fix key self signatures - skip invalid uid', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.imported@gmail.com');\n      await SetupPageRecipe.manualEnter(settingsPage, 'missing.self.signatures.invalid.uid', { submitPubkey: false, fixKey: true });\n    }));\n\n    // This test will succeed after OpenPGP adds support for parsing keys without\n    // User IDs. See: https://github.com/openpgpjs/openpgpjs/issues/1144\n    //\n    // The test will also succeed if local openpgp.js is patched and\n    // `!this.users.length` condition is removed from the Key constructor.\n    ava.failing('setup - import key - fix uids', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.imported@gmail.com');\n      await SetupPageRecipe.manualEnter(settingsPage, 'unused', {\n        submitPubkey: false, fixKey: true,\n        key: {\n          title: 'UIDless key',\n          armored: `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\nCciXuhqnLwoVF5/uXMYffVtfl/OU+w==\n=EqcV\n-----END PGP PRIVATE KEY BLOCK-----`,\n          passphrase: 'correct horse battery staple',\n          longid: '123',\n        }\n      });\n    }, 'FAILING'));\n\n    ava.default('setup - import key - warning on primary has no secret', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.imported@gmail.com');\n      await SetupPageRecipe.manualEnter(settingsPage, 'unused', {\n        submitPubkey: false,\n        genPp: false,\n        fillOnly: true,\n        key: {\n          title: 'Primary no secret',\n          armored: `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\n=OeNi\n-----END PGP PRIVATE KEY BLOCK-----`,\n          passphrase: '1234',\n          longid: '8B3BB9CFC476EE16',\n        }\n      });\n      await settingsPage.waitAndClick('@input-step2bmanualenter-save', { delay: 1 });\n      await Util.sleep(1);\n      await settingsPage.waitAndRespondToModal('warning', 'confirm', 'Please export the key with --export-secret-key option if you plan to use it for signing.');\n    }));\n\n    ava.default('setup - import key - two e-mails on the screen', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.imported@gmail.com');\n      await SetupPageRecipe.manualEnter(settingsPage, 'unused', {\n        submitPubkey: false,\n        key: {\n          title: '2 UIDs key',\n          armored: `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\nAN8G3r5Htj8olot+jm9mIa5XLXWzMNUZgg==\n=aK4l\n-----END PGP PRIVATE KEY BLOCK-----`,\n          passphrase: 'correct horse battery staple',\n          longid: '123',\n        }\n      });\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      const myKeyFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, `@action-show-key-0`, ['my_key.htm', 'placement=settings']);\n      await Util.sleep(1);\n      await myKeyFrame.waitAll('@content-fingerprint');\n      expect(await myKeyFrame.read('@content-fingerprint')).to.contain('61E8 C603 67CD B0EB');\n      expect(await myKeyFrame.read('@content-emails')).to.contain('test@example.com');\n      expect(await myKeyFrame.read('@content-emails')).to.contain('test-alias@example.com');\n    }));\n\n    ava.default('setup - recover with a pass phrase - skip remaining', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.compatibility@gmail.com');\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.1pp1', { hasRecoverMore: true, clickRecoverMore: false });\n    }));\n\n    ava.default('setup - recover with a pass phrase - 1pp1 then 2pp1', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.compatibility@gmail.com');\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.1pp1', { hasRecoverMore: true, clickRecoverMore: true });\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.2pp1');\n    }));\n\n    ava.default('setup - recover with a pass phrase - 1pp2 then 2pp1', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.compatibility@gmail.com');\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.1pp2', { hasRecoverMore: true, clickRecoverMore: true });\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.2pp1');\n    }));\n\n    ava.default('setup - recover with a pass phrase - 2pp1 then 1pp1', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.compatibility@gmail.com');\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.2pp1', { hasRecoverMore: true, clickRecoverMore: true });\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.1pp1');\n    }));\n\n    ava.default('setup - recover with a pass phrase - 2pp1 then 1pp2', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.compatibility@gmail.com');\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.2pp1', { hasRecoverMore: true, clickRecoverMore: true });\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.1pp2');\n    }));\n\n    ava.default('setup - recover with a pass phrase - 1pp1 then 1pp2 (shows already recovered), then 2pp1', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.compatibility@gmail.com');\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.1pp1', { hasRecoverMore: true, clickRecoverMore: true });\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.1pp2', { alreadyRecovered: true });\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.2pp1', {});\n    }));\n\n    ava.todo('setup - recover with a pass phrase - 1pp1 then wrong, then skip');\n    // ava.default('setup - recover with a pass phrase - 1pp1 then wrong, then skip', test_with_browser(async (t, browser) => {\n    //   const settingsPage = await BrowserRecipe.open_settings_login_approve(t, browser,'flowcrypt.compatibility@gmail.com');\n    //   await SetupPageRecipe.setup_recover(settingsPage, 'flowcrypt.compatibility.1pp1', {has_recover_more: true, click_recover_more: true});\n    //   await SetupPageRecipe.setup_recover(settingsPage, 'flowcrypt.wrong.passphrase', {wrong_passphrase: true});\n    //   await Util.sleep(200);\n    // }));\n\n    ava.default('setup - recover with a pass phrase - no remaining', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.recovered@gmail.com');\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.test.key.recovered', { hasRecoverMore: false });\n    }));\n\n    ava.default('setup - fail to recover with a wrong pass phrase', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.recovered@gmail.com');\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.wrong.passphrase', { hasRecoverMore: false, wrongPp: true });\n    }));\n\n    ava.default('setup - fail to recover with a wrong pass phrase at first, then recover with good pass phrase', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.recovered@gmail.com');\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.wrong.passphrase', { wrongPp: true });\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.test.key.recovered');\n    }));\n\n    ava.default('setup - import key - submit - offline - retry', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.used.pgp@gmail.com');\n      await SetupPageRecipe.manualEnter(settingsPage, 'flowcrypt.test.key.used.pgp', { submitPubkey: true, usedPgpBefore: true, simulateRetryOffline: true });\n    }));\n\n    ava.default('has.pub@org-rules-test - no backup, no keygen', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'has.pub@org-rules-test.flowcrypt.test');\n      await SetupPageRecipe.manualEnter(settingsPage, 'has.pub.orgrulestest', { noPrvCreateOrgRule: true, enforceAttesterSubmitOrgRule: true });\n      await settingsPage.waitAll(['@action-show-encrypted-inbox', '@action-open-security-page']);\n      await Util.sleep(1);\n      await settingsPage.notPresent(['@action-open-backup-page']);\n      const { cryptup_haspuborgrulestestflowcrypttest_keys: keys } = await settingsPage.getFromLocalStorage(['cryptup_haspuborgrulestestflowcrypttest_keys']);\n      const ki = keys as KeyInfo[];\n      expect(ki.length).to.equal(1);\n      expect(ki[0].private).to.include('PGP PRIVATE KEY');\n      expect(ki[0].private).to.not.include('Version');\n      expect(ki[0].private).to.not.include('Comment');\n      expect(ki[0].public).to.include('PGP PUBLIC KEY');\n      expect(ki[0].public).to.not.include('Version');\n      expect(ki[0].public).to.not.include('Comment');\n    }));\n\n    ava.default('no.pub@org-rules-test - no backup, no keygen, enforce attester submit with submit err', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'no.pub@org-rules-test.flowcrypt.test');\n      await SetupPageRecipe.manualEnter(settingsPage, 'no.pub.orgrulestest', { noPrvCreateOrgRule: true, enforceAttesterSubmitOrgRule: true, fillOnly: true });\n      await settingsPage.waitAndClick('@input-step2bmanualenter-save');\n      await settingsPage.waitAll(['@container-overlay-prompt-text', '@action-overlay-retry']);\n      const renderedErr = await settingsPage.read('@container-overlay-prompt-text');\n      expect(renderedErr).to.contain(`Failed to submit to Attester`);\n      expect(renderedErr).to.contain(`Could not find LDAP pubkey on a LDAP-only domain for email no.pub@org-rules-test.flowcrypt.test on server keys.flowcrypt.test`);\n    }));\n\n    ava.default('user@no-submit-org-rule.flowcrypt.test - do not submit to attester', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'user@no-submit-org-rule.flowcrypt.test');\n      await SetupPageRecipe.manualEnter(settingsPage, 'flowcrypt.test.key.used.pgp', { noPubSubmitRule: true });\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      const attesterFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-attester-page', ['keyserver.htm']);\n      await attesterFrame.waitAndClick('@action-submit-pub');\n      await attesterFrame.waitAndRespondToModal('error', 'confirm', 'Disallowed by your organisation rules');\n    }));\n\n    ava.default('user@no-submit-org-rule.flowcrypt.test - do not submit to attester on key generation', testWithBrowser(undefined, async (t, browser) => {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'user@no-submit-org-rule.flowcrypt.test');\n      await Util.sleep(5);\n      await SetupPageRecipe.createKey(settingsPage, 'unused', 'none', { key: { passphrase: 'long enough to suit requirements' }, usedPgpBefore: false });\n      await settingsPage.notPresent('.swal2-container');\n      await settingsPage.close();\n    }));\n\n    ava.default('user@no-search-domains-org-rule.flowcrypt.test - do not search attester for recipients on particular domains', testWithBrowser(undefined, async (t, browser) => {\n      // disallowed searching attester for pubkeys on \"flowcrypt.com\" domain\n      // below we search for human@flowcrypt.com which normally has pubkey on attester, but none should be found due to the rule\n      const acct = 'user@no-search-domains-org-rule.flowcrypt.test';\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await SetupPageRecipe.manualEnter(settingsPage, 'flowcrypt.test.key.used.pgp');\n      const composePage = await ComposePageRecipe.openStandalone(t, browser, acct);\n      await ComposePageRecipe.fillMsg(composePage, { to: 'mock.only.pubkey@flowcrypt.com,mock.only.pubkey@other.com' }, 'flowcrypt domain should not be found');\n      await composePage.waitForContent('.email_address.no_pgp', 'mock.only.pubkey@flowcrypt.com');\n      await composePage.waitForContent('.email_address.has_pgp', 'mock.only.pubkey@other.com');\n      await composePage.waitAll('@input-password');\n    }));\n\n    ava.default('get.key@key-manager-autogen.flowcrypt.test - automatic setup with key found on key manager', testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'get.key@key-manager-autogen.flowcrypt.test';\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await SetupPageRecipe.autoKeygen(settingsPage);\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      // check no \"add key\"\n      await settingsPage.notPresent('@action-open-add-key-page');\n      // check imported key\n      const myKeyFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, `@action-show-key-0`, ['my_key.htm', 'placement=settings']);\n      await Util.sleep(1);\n      await myKeyFrame.waitAll('@content-fingerprint');\n      expect(await myKeyFrame.read('@content-fingerprint')).to.contain('00B0 1158 0796 9D75');\n      await SettingsPageRecipe.closeDialog(settingsPage);\n      await Util.sleep(2);\n      // check that it does not offer any pass phrase options\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'basic');\n      const securityFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-security-page', ['security.htm', 'placement=settings']);\n      await Util.sleep(1);\n      await securityFrame.notPresent(['@action-change-passphrase-begin', '@action-test-passphrase-begin', '@action-forget-pp']);\n    }));\n\n    ava.default('get.key@no-submit-org-rule.key-manager-autogen.flowcrypt.test - automatic setup with key found on key manager and no submit rule', testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'get.key@no-submit-org-rule.key-manager-autogen.flowcrypt.test';\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await SetupPageRecipe.autoKeygen(settingsPage);\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      // check no \"add key\"\n      await settingsPage.notPresent('@action-open-add-key-page');\n      // check imported key\n      const myKeyFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, `@action-show-key-0`, ['my_key.htm', 'placement=settings']);\n      await Util.sleep(1);\n      await myKeyFrame.waitAll('@content-fingerprint');\n      expect(await myKeyFrame.read('@content-fingerprint')).to.contain('9C64 3D82 783E 291A 2AD2 611B 499E 84DB 185F 0359');\n      await SettingsPageRecipe.closeDialog(settingsPage);\n    }));\n\n    ava.default('put.key@key-manager-autogen.flowcrypt.test - automatic setup with key not found on key manager, then generated', testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'put.key@key-manager-autogen.flowcrypt.test';\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await SetupPageRecipe.autoKeygen(settingsPage);\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n      // check no \"add key\"\n      await settingsPage.notPresent('@action-open-add-key-page');\n      // check imported key\n      const myKeyFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, `@action-show-key-0`, ['my_key.htm', 'placement=settings']);\n      await Util.sleep(1);\n      await myKeyFrame.waitAll('@content-fingerprint');\n      const fromKm = MOCK_KM_LAST_INSERTED_KEY[acct];\n      expect(fromKm).to.exist;\n      const k = await KeyUtil.parse(fromKm.publicKey);\n      expect(await myKeyFrame.read('@content-fingerprint')).to.equal(Str.spaced(k.id));\n      expect(await myKeyFrame.read('@content-key-expiration')).to.equal('Key does not expire');\n      await SettingsPageRecipe.closeDialog(settingsPage);\n      await Util.sleep(2);\n      // check that it does not offer any pass phrase options\n      await SettingsPageRecipe.toggleScreen(settingsPage, 'basic');\n      const securityFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-open-security-page', ['security.htm', 'placement=settings']);\n      await Util.sleep(1);\n      await securityFrame.notPresent(['@action-change-passphrase-begin', '@action-test-passphrase-begin', '@action-forget-pp']);\n    }));\n\n    ava.default('get.error@key-manager-autogen.flowcrypt.test - handles error during KM key GET', testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'get.error@key-manager-autogen.flowcrypt.test';\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await SetupPageRecipe.autoKeygen(settingsPage, {\n        expectErr: {\n          title: 'Server responded with an unexpected error.',\n          text: '500 when GET-ing https://localhost:8001/flowcrypt-email-key-manager/keys/private (no body): -> Intentional error for get.error to test client behavior',\n        }\n      });\n    }));\n\n    ava.default('put.error@key-manager-autogen.flowcrypt.test - handles error during KM key PUT', testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'put.error@key-manager-autogen.flowcrypt.test';\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await settingsPage.waitAll(['@action-overlay-retry', '@container-overlay-prompt-text', '@action-show-overlay-details']);\n      await Util.sleep(0.5);\n      expect(await settingsPage.read('@container-overlay-prompt-text')).to.contain('Server responded with an unexpected error.');\n      await settingsPage.click('@action-show-overlay-details');\n      await settingsPage.waitAll('@container-overlay-details');\n      await Util.sleep(0.5);\n      const details = await settingsPage.read('@container-overlay-details');\n      expect(details).to.contain('500 when PUT-ing https://localhost:8001/flowcrypt-email-key-manager/keys/private string: decryptedPrivateKey,publicKey -> Intentional error for put.error user to test client behavior');\n      expect(details).to.not.contain('PRIVATE KEY');\n      expect(details).to.not.contain('<REDACTED:');\n    }));\n\n    ava.default('fail@key-manager-server-offline.flowcrypt.test - shows friendly KM not reachable error', testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'fail@key-manager-server-offline.flowcrypt.test';\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await SetupPageRecipe.autoKeygen(settingsPage, {\n        expectErr: {\n          title: 'Network connection issue.',\n          text: 'FlowCrypt Email Key Manager at https://localhost:1230/intentionally-wrong is down, please inform your network admin.',\n        }\n      });\n    }));\n\n    ava.default(\n      'user@key-manager-no-pub-lookup.flowcrypt.test - do not search pubkeys on EKM: NO_KEY_MANAGER_PUB_LOOKUP',\n      testWithBrowser(undefined, async (t, browser) => {\n        // disallowed searching EKM pubkeys (EKM is behind firewall, but user may be using public interned, with EKM not reachable)\n        const acct = 'user@key-manager-no-pub-lookup.flowcrypt.test';\n        const dontLookupEmail = 'not.suppposed.to.lookup@key-manager-no-pub-lookup.flowcrypt.test';\n        const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n        await SetupPageRecipe.autoKeygen(settingsPage);\n        const composePage = await ComposePageRecipe.openStandalone(t, browser, acct);\n        await ComposePageRecipe.fillMsg(composePage, { to: dontLookupEmail }, 'must skip EKM lookup');\n        await composePage.waitForContent('.email_address.no_pgp', dontLookupEmail); // if it tried EKM, this would be err\n        await composePage.waitAll('@input-password');\n      })\n    );\n\n    ava.default(\n      'expire@key-manager-keygen-expiration.flowcrypt.test - OrgRule enforce_keygen_expire_months: 1',\n      testWithBrowser(undefined, async (t, browser) => {\n        const acct = 'expire@key-manager-keygen-expiration.flowcrypt.test';\n        const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n        await SetupPageRecipe.autoKeygen(settingsPage);\n        await SettingsPageRecipe.toggleScreen(settingsPage, 'additional');\n        const myKeyFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, `@action-show-key-0`, ['my_key.htm', 'placement=settings']);\n        await Util.sleep(1);\n        await myKeyFrame.waitAll('@content-fingerprint');\n        const fromKm = MOCK_KM_LAST_INSERTED_KEY[acct];\n        expect(fromKm).to.exist;\n        const k = await KeyUtil.parse(fromKm.publicKey);\n        expect(await myKeyFrame.read('@content-fingerprint')).to.equal(Str.spaced(k.id));\n        const approxMonth = [29, 30, 31].map(days => Str.datetimeToDate(Str.fromDate(new Date(Date.now() + 1000 * 60 * 60 * 24 * days))));\n        expect(await myKeyFrame.read('@content-key-expiration')).to.be.oneOf(approxMonth);\n        await SettingsPageRecipe.closeDialog(settingsPage);\n      })\n    );\n\n    ava.default(\n      'reject.client.keypair@key-manager-autogen.flowcrypt.test - does not leak sensitive info on err 400, shows informative err',\n      testWithBrowser(undefined, async (t, browser) => {\n        const acct = 'reject.client.keypair@key-manager-autogen.flowcrypt.test';\n        const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n        await settingsPage.waitAll(['@action-overlay-retry', '@container-overlay-prompt-text', '@action-show-overlay-details']);\n        await Util.sleep(0.5);\n        const title = await settingsPage.read('@container-overlay-prompt-text');\n        expect(title).to.contain('Failed to store newly generated key on FlowCrypt Email Key Manager, ' +\n          'No key has been generated for reject.client.keypair@key-manager-autogen.flowcrypt.test yet. Please ask your administrator.');\n        await settingsPage.click('@action-show-overlay-details');\n        await settingsPage.waitAll('@container-overlay-details');\n        await Util.sleep(0.5);\n        const details = await settingsPage.read('@container-overlay-details');\n        expect(details).to.contain('405 when PUT-ing https://localhost:8001/flowcrypt-email-key-manager/keys/private string: ' +\n          'decryptedPrivateKey,publicKey -> No key has been generated for reject.client.keypair@key-manager-autogen.flowcrypt.test yet');\n        expect(details).to.not.contain('PRIVATE KEY');\n      })\n    );\n\n    /**\n     * You need the following lines in /etc/hosts:\n     * 127.0.0.1    standardsubdomainfes.test\n     * 127.0.0.1    fes.standardsubdomainfes.test\n     */\n    ava.default('user@standardsubdomainfes.test:8001 - uses FES on standard domain', testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'user@standardsubdomainfes.test:8001'; // added port to trick extension into calling the mock\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n      await SetupPageRecipe.manualEnter(settingsPage, 'flowcrypt.test.key.used.pgp', { submitPubkey: false, usedPgpBefore: false });\n      const debugFrame = await SettingsPageRecipe.awaitNewPageFrame(settingsPage, '@action-show-local-store-contents', ['debug_api.htm']);\n      await debugFrame.waitForContent('@container-pre', 'fes.standardsubdomainfes.test:8001'); // FES url on standard subdomain\n      await debugFrame.waitForContent('@container-pre', 'got.this@fromstandardfes.com'); // org rules from FES\n    }));\n\n    /**\n     * enterprise - expects FES to be set up. when it's not, show nice error\n     * consumer - tolerates the missing FES and and sets up without it\n     */\n    ava.default('no.fes@example.com - skip FES on consumer, show friendly message on enterprise', testWithBrowser(undefined, async (t, browser) => {\n      const acct = 'no.fes@example.com';\n      if (testVariant === 'ENTERPRISE-MOCK') { // shows err on enterprise\n        const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n        await settingsPage.waitAndRespondToModal('error', 'confirm',\n          \"Cannot reach your company's FlowCrypt Enterprise Server (FES). Contact human@flowcrypt.com when unsure.\");\n      } else if (testVariant === 'CONSUMER-MOCK') { // allows to set up on consumer\n        const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acct);\n        await SetupPageRecipe.manualEnter(settingsPage, 'flowcrypt.test.key.used.pgp', { submitPubkey: false, usedPgpBefore: false });\n      } else {\n        throw new Error(`Unexpected test variant ${testVariant}`);\n      }\n    }));\n\n    // todo - change to an \"add key\" instead of initial import test\n    // todo - disable initial import of s/mime key\n    // todo - disable import of encrypted s/mime key, require decrypted?\n    // ava.default.only(\n    //   'setup - s/mime private key',\n    //   testWithBrowser(undefined, async (t, browser) => {\n    //     const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.test.key.imported@gmail.com');\n    //     const key = {\n    //       title: 's/mime pkcs12 encrypted key',\n    //       filePath: 'test/samples/smime/human-unprotected-PKCS12.p12',\n    //       armored: null,\n    //       passphrase: 'test pp to encrypt unprotected key',\n    //       longid: null\n    //     };\n    //     await SetupPageRecipe.manualEnter(settingsPage, key.title, { submitPubkey: false, usedPgpBefore: false, key });\n    //   })\n    // );\n\n  }\n\n};\n",
    "test/source/tests/tooling/api.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as request from 'fc-node-requests';\n\nimport { Config } from '../../util';\n\nconst ci_admin_token = Config.secrets().ci_admin_token;\n\nexport class FlowCryptApi {\n\n  public static hookCiDebugEmail = async (debug_title: string, debug_html_content: string) => { // tslint:disable-line:variable-name\n    if (!ci_admin_token) {\n      console.error('hookCiDebugEmail: nor reporting because missing ci_admin_token');\n      return;\n    }\n    console.info(`hookCiDebugEmail - calling with length: ${debug_html_content.length}`);\n    const r = await FlowCryptApi.call('https://flowcrypt.com/api/hook/ci_debug_email', { ci_admin_token, debug_title, debug_html_content });\n    console.info('hookCiDebugEmail-response', r.body, r.statusCode);\n  }\n\n  private static call = async (url: string, values: { [k: string]: any }) => {\n    return await request.post({ url, json: values, headers: { 'api-version': 3 } });\n  }\n\n}\n",
    "test/source/tests/tooling/browser-recipe.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { Config, Util, TestMessage } from '../../util';\n\nimport { AvaContext } from '.';\nimport { BrowserHandle } from '../../browser';\nimport { OauthPageRecipe } from './../page-recipe/oauth-page-recipe';\nimport { SetupPageRecipe } from './../page-recipe/setup-page-recipe';\nimport { TestUrls } from '../../browser/test-urls';\nimport { google } from 'googleapis';\nimport { testVariant } from '../../test';\n\nexport class BrowserRecipe {\n\n  public static openSettingsLoginButCloseOauthWindowBeforeGrantingPermission = async (t: AvaContext, browser: BrowserHandle, acctEmail: string) => {\n    const settingsPage = await browser.newPage(t, TestUrls.extensionSettings());\n    const oauthPopup = await browser.newPageTriggeredBy(t, () => settingsPage.waitAndClick('@action-connect-to-gmail'));\n    await OauthPageRecipe.google(t, oauthPopup, acctEmail, 'close');\n    await settingsPage.waitAndRespondToModal('confirm', 'cancel', 'Explaining FlowCrypt webmail permissions');\n    return settingsPage;\n  }\n\n  public static openSettingsLoginApprove = async (t: AvaContext, browser: BrowserHandle, acctEmail: string) => {\n    const settingsPage = await browser.newPage(t, TestUrls.extensionSettings());\n    const oauthPopup = await browser.newPageTriggeredBy(t, () => settingsPage.waitAndClick('@action-connect-to-gmail'));\n    await OauthPageRecipe.google(t, oauthPopup, acctEmail, 'approve');\n    return settingsPage;\n  }\n\n  public static openGmailPage = async (t: AvaContext, browser: BrowserHandle, googleLoginIndex = 0) => {\n    const gmailPage = await browser.newPage(t, TestUrls.gmail(googleLoginIndex));\n    await gmailPage.waitAll('div.z0'); // compose button container visible\n    await Util.sleep(3); // give it extra time to make sure FlowCrypt is initialized if it was supposed to\n    return gmailPage;\n  }\n\n  public static openGmailPageAndVerifyComposeBtnPresent = async (t: AvaContext, browser: BrowserHandle, googleLoginIndex = 0) => {\n    const gmailPage = await BrowserRecipe.openGmailPage(t, browser, googleLoginIndex);\n    await gmailPage.waitAll('@action-secure-compose');\n    return gmailPage;\n  }\n\n  public static openGmailPageAndVerifyComposeBtnNotPresent = async (t: AvaContext, browser: BrowserHandle, googleLoginIndex = 0) => {\n    const gmailPage = await BrowserRecipe.openGmailPage(t, browser, googleLoginIndex);\n    await Util.sleep(3);\n    await gmailPage.notPresent('@action-secure-compose');\n    return gmailPage;\n  }\n\n  public static setUpCommonAcct = async (t: AvaContext, browser: BrowserHandle, acct: 'compatibility' | 'compose' | 'ci.tests.gmail', cleanup: boolean) => {\n    if (acct === 'compatibility') {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'flowcrypt.compatibility@gmail.com');\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.1pp1', { hasRecoverMore: true, clickRecoverMore: true });\n      await SetupPageRecipe.recover(settingsPage, 'flowcrypt.compatibility.2pp1');\n      await settingsPage.close();\n    } else if (acct === 'ci.tests.gmail' && testVariant === 'CONSUMER-LIVE-GMAIL') {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'ci.tests.gmail@flowcrypt.dev');\n      await SetupPageRecipe.recover(settingsPage, 'ci.tests.gmail');\n      if (cleanup) {\n        const { cryptup_citestsgmailflowcryptdev_google_token_access: accessToken } = await settingsPage.getFromLocalStorage(['cryptup_citestsgmailflowcryptdev_google_token_access']);\n        await Promise.all([BrowserRecipe.cleanGmailAccount(accessToken as string), settingsPage.close()]);\n      }\n    } else if (acct === 'ci.tests.gmail' && testVariant !== 'CONSUMER-LIVE-GMAIL') {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'ci.tests.gmail@flowcrypt.test');\n      await SetupPageRecipe.recover(settingsPage, 'ci.tests.gmail');\n      if (cleanup) {\n        const { cryptup_citestsgmailflowcryptdev_google_token_access: accessToken } = await settingsPage.getFromLocalStorage(['cryptup_citestsgmailflowcryptdev_google_token_access']);\n        await Promise.all([BrowserRecipe.cleanGmailAccount(accessToken as string), settingsPage.close()]);\n      }\n    } else {\n      const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, 'ci.tests.gmail@flowcrypt.dev');\n      await SetupPageRecipe.recover(settingsPage, 'test.ci.compose');\n      await settingsPage.close();\n    }\n  }\n\n  public static deleteAllDraftsInGmailAccount = async (accessToken: string): Promise<void> => {\n    const gmail = google.gmail({ version: 'v1' });\n    const list = await gmail.users.drafts.list({ userId: 'me', access_token: accessToken });\n    if (list.data.drafts) {\n      await Promise.all(list.data.drafts!.filter(draft => draft.id).map(draft => gmail.users.drafts.delete({ id: draft.id!, userId: 'me', access_token: accessToken })));\n    }\n  }\n\n  public static cleanGmailAccount = (accessToken: string) => BrowserRecipe.deleteAllDraftsInGmailAccount(accessToken);\n\n  // todo - ideally we could just add a 3rd common account: 'compatibility' | 'compose' | 'pp-change' in setUpCommonAcct\n  public static setUpFcPpChangeAcct = async (t: AvaContext, browser: BrowserHandle) => {\n    const acctEmail = 'flowcrypt.test.key.imported@gmail.com';\n    const k = Config.key('flowcrypt.test.key.used.pgp');\n    const settingsPage = await BrowserRecipe.openSettingsLoginApprove(t, browser, acctEmail);\n    await SetupPageRecipe.manualEnter(settingsPage, k.title, { usedPgpBefore: false, submitPubkey: false, savePassphrase: true });\n    return { acctEmail, k, settingsPage };\n  }\n\n  public static async pgpBlockVerifyDecryptedContent(t: AvaContext, browser: BrowserHandle, m: TestMessage) {\n    const pgpHostPage = await browser.newPage(t, `chrome/dev/ci_pgp_host_page.htm${m.params}`);\n    const pgpBlockPage = await pgpHostPage.getFrame(['pgp_block.htm']);\n    if (m.expectPercentageProgress) {\n      await pgpBlockPage.waitForContent('@pgp-block-content', /Retrieving message... \\d+%/, 20, 10);\n    }\n    await pgpBlockPage.waitForSelTestState('ready', 100);\n    await Util.sleep(1);\n    if (m.quoted) {\n      await pgpBlockPage.waitAndClick('@action-show-quoted-content');\n      await Util.sleep(1);\n    } else {\n      if (await pgpBlockPage.isElementPresent('@action-show-quoted-content')) {\n        throw new Error(`element: @action-show-quoted-content not expected in: ${t.title}`);\n      }\n    }\n    const content = await pgpBlockPage.read('@pgp-block-content');\n    for (const expectedContent of m.content) {\n      if (content.indexOf(expectedContent) === -1) {\n        throw new Error(`pgp_block_verify_decrypted_content:missing expected content: ${expectedContent}`);\n      }\n    }\n    if (m.unexpectedContent) {\n      for (const unexpectedContent of m.unexpectedContent) {\n        if (content.indexOf(unexpectedContent) !== -1) {\n          throw new Error(`pgp_block_verify_decrypted_content:unexpected content presents: ${unexpectedContent}`);\n        }\n      }\n    }\n    if (m.signature) {\n      const sigContent = await pgpBlockPage.read('@pgp-signature');\n      for (const expectedSigContent of m.signature) {\n        if (sigContent.indexOf(expectedSigContent) === -1) {\n          t.log(`found sig content:${sigContent}`);\n          throw new Error(`pgp_block_verify_decrypted_content:missing expected signature content:${expectedSigContent}`);\n        }\n      }\n    }\n    await pgpHostPage.close();\n  }\n\n}\n",
    "test/source/tests/unit-browser.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as ava from 'ava';\n\nimport { TestVariant } from '../util';\nimport { TestWithBrowser } from '../test';\nimport { TestUrls } from '../browser/test-urls';\nimport { readdirSync, readFileSync } from 'fs';\nimport { Buf } from '../core/buf';\nimport { testConstants } from './tooling/consts';\n\n// tslint:disable:no-blank-lines-func\n/* eslint-disable max-len */\n\ntype UnitTest = { title: string, code: string, only: boolean };\n\nexport let defineUnitBrowserTests = (testVariant: TestVariant, testWithBrowser: TestWithBrowser) => {\n\n  if (testVariant !== 'CONSUMER-LIVE-GMAIL') {\n\n    const browserUnitTestsFolder = './test/source/tests/browser-unit-tests/';\n\n    const defineAvaTest = (title: string, testCode: string, flag?: 'only') => {\n      // eslint-disable-next-line no-only-tests/no-only-tests\n      (flag !== 'only' ? ava.default : ava.default.only)(title, testWithBrowser(undefined, async (t, browser) => {\n        const hostPage = await browser.newPage(t, TestUrls.extension(`chrome/dev/ci_unit_test.htm`));\n        // update host page h1\n        await hostPage.target.evaluate((title) => { window.document.getElementsByTagName('h1')[0].textContent = title; }, title);\n        // inject testConstants\n        await hostPage.target.evaluate((object) => { (window as any).testConstants = object; }, testConstants);\n        // prepare code to run\n        const runThisCodeInBrowser = `\n            (async () => {\n              try {\n                return await ${testCode}\n              } catch (e) {\n                return \"unit test threw something:\" + String(e) + \"\\\\n\\\\n\" + e.stack;\n              }\n            })();\n          `;\n        // load and run the unit test\n        const r = await hostPage.target.evaluate(runThisCodeInBrowser);\n        if (r !== 'pass') {\n          t.log(`Expected unit test to return \"pass\" but got: \"${r}\"`);\n          throw Error(String(r).split('\\n')[0]);\n        }\n      }));\n    };\n\n    const parseTestFile = (filename: string): UnitTest[] => {\n      const unitTestCodes = Buf.fromUint8(readFileSync(browserUnitTestsFolder + filename)).toUtfStr().trim();\n      const testCasesInFile = unitTestCodes.split('\\nBROWSER_UNIT_TEST_NAME(`');\n      const header = testCasesInFile.shift()!;\n      if (!header.startsWith('/* ©️ 2016')) {\n        throw Error(`Expecting ${browserUnitTestsFolder}/${filename} to start with '/* ©️ 2016'`);\n      }\n      if (header.includes('require(') || header.includes('import')) { // do not import anything. Add deps to ci_unit_test.ts\n        throw Error(`Unexpected import statement found in ${browserUnitTestsFolder}/${filename}`);\n      }\n      const unitTests = [];\n      for (let code of testCasesInFile) {\n        if (code.includes('/*')) { // just to make sure we don't parse something wrongly. Block comment only allowed in header.\n          throw Error(`Block comments such as /* are not allowed in test definitions. Use line comments eg //`);\n        }\n        code = code.trim();\n        if (!code.endsWith('})();')) {\n          console.error(code);\n          throw Error(`Test case does not end with '})();'. Did you put code outside of the async functions? (forbidden)`);\n        }\n        const testCodeLines = code.split('\\n');\n        let thisUnitTestTitle = testCodeLines.shift()!.trim();\n        if (thisUnitTestTitle.includes('`).enterprise') && testVariant === 'CONSUMER-MOCK') {\n          continue;\n        }\n        if (thisUnitTestTitle.includes('`).consumer') && testVariant === 'ENTERPRISE-MOCK') {\n          continue;\n        }\n        const only = thisUnitTestTitle.endsWith('.only;');\n        thisUnitTestTitle = thisUnitTestTitle.replace(/`.+$/, '');\n        code = testCodeLines.join('\\n'); // without the title, just code\n        const title = `[${filename}] ${thisUnitTestTitle}`;\n        unitTests.push({ title, code, only });\n      }\n      return unitTests;\n    };\n\n    const allUnitTests: UnitTest[] = [];\n    for (const filename of readdirSync(browserUnitTestsFolder)) {\n      allUnitTests.push(...parseTestFile(filename));\n    }\n    const markedAsOnly: UnitTest[] = allUnitTests.filter(unitTest => unitTest.only);\n    if (!markedAsOnly.length) { // no tests marked as only - run all\n      for (const unitTest of allUnitTests) {\n        defineAvaTest(unitTest.title, unitTest.code);\n      }\n    } else { // some tests marked as only - only run those + run one test that always fails\n      for (const unitTest of markedAsOnly) {\n        defineAvaTest(unitTest.title, unitTest.code, 'only');\n      }\n      // eslint-disable-next-line no-only-tests/no-only-tests\n      ava.default.only('reminder to remove .only', async t => {\n        t.fail(`some tests marked as .only, preventing other tests from running`);\n      });\n    }\n\n  }\n};\n",
    "test/source/tests/unit-node.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as ava from 'ava';\n\nimport { MsgBlock } from '../core/msg-block';\nimport { MsgBlockParser } from '../core/msg-block-parser';\nimport { PgpHash } from '../core/crypto/pgp/pgp-hash';\nimport { TestVariant } from '../util';\nimport chai = require('chai');\nimport chaiAsPromised = require('chai-as-promised');\nimport { KeyUtil, ExtendedKeyInfo } from '../core/crypto/key';\nimport { UnreportableError } from '../platform/catch.js';\nimport { Buf } from '../core/buf';\nimport { OpenPGPKey } from '../core/crypto/pgp/openpgp-key';\nimport { DecryptError, DecryptSuccess, MsgUtil, PgpMsgMethod } from '../core/crypto/pgp/msg-util';\nimport { opgp } from '../core/crypto/pgp/openpgpjs-custom';\nimport { Attachment } from '../core/attachment.js';\nimport { ContactStore } from '../platform/store/contact-store.js';\nimport { GoogleData, GmailParser, GmailMsg } from '../mock/google/google-data';\nimport { testConstants } from './tooling/consts';\nimport { PgpArmor } from '../core/crypto/pgp/pgp-armor';\nimport * as forge from 'node-forge';\n\nchai.use(chaiAsPromised);\nconst expect = chai.expect;\n// tslint:disable:no-blank-lines-func\n/* eslint-disable max-len */\n// tslint:disable:no-unused-expression\n/* eslint-disable no-unused-expressions */\n\nexport const equals = (a: string | Uint8Array, b: string | Uint8Array) => {\n  expect(typeof a).to.equal(typeof b, `types dont match`);\n  if (typeof a === 'string' && typeof b === 'string') {\n    expect(a).to.equal(b, 'string result mismatch');\n    return;\n  }\n  if (a instanceof Uint8Array && b instanceof Uint8Array) {\n    expect(Array.from(a).join('|')).to.equal(Array.from(b).join('|'), 'buffers dont match');\n    return;\n  }\n  throw new Error(`unknown test state [${typeof a},${typeof b}] [${a instanceof Uint8Array},${b instanceof Uint8Array}]`);\n};\n\n\nexport let defineUnitNodeTests = (testVariant: TestVariant) => {\n\n  if (testVariant !== 'CONSUMER-LIVE-GMAIL') {\n\n    ava.default(`[unit][MsgBlockParser.detectBlocks] does not get tripped on blocks with unknown headers`, async t => {\n      expect(MsgBlockParser.detectBlocks(\"This text breaks email and Gmail web app.\\n\\n-----BEGIN FOO-----\\n\\nEven though it's not a vaild PGP m\\n\\nMuhahah\")).to.deep.equal({\n        \"blocks\": [\n          MsgBlock.fromContent(\"plainText\", \"This text breaks email and Gmail web app.\\n\\n-----BEGIN FOO-----\\n\\nEven though it's not a vaild PGP m\\n\\nMuhahah\"),\n        ],\n        \"normalized\": \"This text breaks email and Gmail web app.\\n\\n-----BEGIN FOO-----\\n\\nEven though it's not a vaild PGP m\\n\\nMuhahah\"\n      });\n      t.pass();\n    });\n\n    ava.default(`[unit][MsgBlockParser.detectBlocks] ignores false-positive blocks`, async t => {\n      const input = `Hello, sending you the promised json:\n      {\n        \"entries\" : [ {\n          \"id\" : \"1,email-key-manager,evaluation.org,pgp-key-private,106988520142055188323\",\n          \"content\" : \"-----BEGIN PGP PRIVATE KEY BLOCK-----\\r\\nVersion: FlowCrypt 7.6.9 Gmail Encryption\\r\\nComment: Seamlessly send and receive encrypted email\\r\\n\\r\\n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\\r\\n+P9DgunMb5OtkDwm6WWxpzV150LJcA==\\r\\n=FAco\\r\\n-----END PGP PRIVATE KEY BLOCK-----\\r\\n\"\n        }, {\n          \"id\" : \"1,email-key-manager,evaluation.org,pgp-key-public,ekm%40ekm-org-rules-test.flowcrypt.test\",\n          \"content\" : \"-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: FlowCrypt 7.6.9 Gmail Encryption\\r\\nComment: Seamlessly send and receive encrypted email\\r\\n\\r\\nxsBNBF5mRKEBCADX62s0p6mI6yrxB/ui/LqxfG4RcQzZJf8ah52Ynu1n8V7Y\\r\\n7143LmT3MfCDw1bfHu2k1OK7hT+BOi6sXas1D/fVtjz5WwuoBvwf1DBZ7eq8\\r\\ntMQbLqQ7m/A8uwrVFOhWfuxulM7RuzIPIgv4HqtKKEugprUd80bPus45+f80\\r\\nH6ZSgEpmZD6t9JShY6f8pU1OHcnPqFsFF0sLyOk7WcCG5Li3WjkwU/lIu18q\\r\\nR26oLb5UM8z6vv6JD29GmqCj+OLYaPk8b00kdpGEvTjw3VzGM+tXOgUf2y1T\\r\\nK9UfhMNkyswxUZw543CMTdw9V0+AzM0q70T/p0fP9nlJCv6M3bQm6D/vABEB\\r\\nAAHNL0VrbSBVc2VyIDxla21AZWttLW9yZy1ydWxlcy10ZXN0LmZsb3djcnlw\\r\\ndC5jb20+wsB1BBABCAAfBQJeZkShBgsJBwgDAgQVCAoCAxYCAQIZAQIbAwIe\\r\\nAQAKCRDESadeBea4P0KvCACD5uOgGxwGEmUWfH8EXPK7npDKulmoZnSWYrfC\\r\\nX3ctUKXjwPBWRXYid7LChnQAR6SRcyxyD1Eoel5ZVrJyKHqRkxcanFHeqRU1\\r\\nOyOgtsQyPIGtLipmOgc6i5JYhqbQ4mNu10CGS6ZKhjf6rFIqLl/8f4lnBc28\\r\\nUqVuP20Ru6KJZTVVQRF28FweMByR/3LyAWfObMwXJ0+uFEV941VEDv5MGdId\\r\\nfePTP2cHRSJxPqVhpPWtfzYLStUzLFvtLfE45hympok4lZeKfLVtZVVQEgT+\\r\\nojEImdiZQJ0dT+jeJhmuTjzURQcLapXv2GLBUZaY2zfoAXR31QNYjADOxlrO\\r\\nutSUzsBNBF5mRKEBCACVNQTzI2Cf1+G3q38OtXO89tuBI/a5TjcHh/sFIJB6\\r\\nPPuEg/uW+EsjkgI3yk+UZZd6iYohO2mJcJ7MnaFHOu7tmOEaaHSiYsA0RTnV\\r\\nqUBlbHbsl2oSlQJ/mjJ4cWq5ateuLHhx2RV0t1bm2anHJnqKGkqYqXA72m5g\\r\\nrLzRSJ9M43wQRheGWGNoNdg4kPxU+PjYwfk2ARX5SCUKoG0qp0RhRMplX74u\\r\\nYi+Ek/9qSyZevmhK55sXIUNwLsuEhejlr0iucOt2vcIybQ9EbMXz62yYMRjY\\r\\ngy4SxW5aQJxXFeWkSo6wzMqQ1ZiSArRCezBk+mftxNrmwmtCcJajQt2uAQQV\\r\\nABEBAAHCwF8EGAEIAAkFAl5mRKECGwwACgkQxEmnXgXmuD/7VAf+IMJMoADc\\r\\ndWNhn45AvkwbzSmYt4i2aRGe+qojswwYzvFBFZtyZ/FKV2+LHfKUBI18FRmH\\r\\nmKEba1UUetflytxiAwZxSJSf7Yz/NDiWaVn0eOLopmFMiPb02a5i3CjbLsDe\\r\\nex2y/69R0+fQc+rE3HZ04C8H/YAqFV0VOv3L+2EztOGK7KOZOx4toR05oDqb\\r\\nZbiDzwhsa2MugHLPLZuGl3eGk+n/EcINhopHg+HU8MHQE6rADvrok6QiYVhp\\r\\nGqi8ksD3kBAk43hGRSD2m/WDPWa/h2sh5rVswTKUDtv1fd1H6Ff5FnK21LHj\\r\\nEk0f+P9DgunMb5OtkDwm6WWxpzV150LJcA==\\r\\n=Hcoc\\r\\n-----END PGP PUBLIC KEY BLOCK-----\\r\\n\"\n        }, {\n          \"id\" : \"1,email-key-manager,evaluation.org,pgp-key-fingerprint,C05803F40E0B9FE4FE9B4822C449A75E05E6B83F\",\n          \"content\" : \"1,email-key-manager,evaluation.org,pgp-key-private,106988520142055188323\\n1,email-key-manager,evaluation.org,pgp-key-public,ekm%40ekm-org-rules-test.flowcrypt.test\"\n        } ]\n      }`;\n      const { blocks, normalized } = MsgBlockParser.detectBlocks(input);\n      expect(normalized).to.equal(input);\n      expect(blocks).to.have.property('length').that.equals(1);\n      expect(blocks[0]).to.deep.equal(MsgBlock.fromContent(\"plainText\", input));\n      t.pass();\n    });\n\n    ava.default(`[unit][MsgBlockParser.detectBlocks] replaces intended blocks`, async t => {\n      const prv = `-----BEGIN PGP PRIVATE KEY BLOCK-----\\r\\nVersion: FlowCrypt 7.6.9 Gmail Encryption\\r\\nComment: Seamlessly send and receive encrypted email\\r\\n\\r\\n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\\r\\n+P9DgunMb5OtkDwm6WWxpzV150LJcA==\\r\\n=FAco\\r\\n-----END PGP PRIVATE KEY BLOCK-----`;\n      const pub = `-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: FlowCrypt 7.6.9 Gmail Encryption\\r\\nComment: Seamlessly send and receive encrypted email\\r\\n\\r\\nxsBNBF5mRKEBCADX62s0p6mI6yrxB/ui/LqxfG4RcQzZJf8ah52Ynu1n8V7Y\\r\\n7143LmT3MfCDw1bfHu2k1OK7hT+BOi6sXas1D/fVtjz5WwuoBvwf1DBZ7eq8\\r\\ntMQbLqQ7m/A8uwrVFOhWfuxulM7RuzIPIgv4HqtKKEugprUd80bPus45+f80\\r\\nH6ZSgEpmZD6t9JShY6f8pU1OHcnPqFsFF0sLyOk7WcCG5Li3WjkwU/lIu18q\\r\\nR26oLb5UM8z6vv6JD29GmqCj+OLYaPk8b00kdpGEvTjw3VzGM+tXOgUf2y1T\\r\\nK9UfhMNkyswxUZw543CMTdw9V0+AzM0q70T/p0fP9nlJCv6M3bQm6D/vABEB\\r\\nAAHNL0VrbSBVc2VyIDxla21AZWttLW9yZy1ydWxlcy10ZXN0LmZsb3djcnlw\\r\\ndC5jb20+wsB1BBABCAAfBQJeZkShBgsJBwgDAgQVCAoCAxYCAQIZAQIbAwIe\\r\\nAQAKCRDESadeBea4P0KvCACD5uOgGxwGEmUWfH8EXPK7npDKulmoZnSWYrfC\\r\\nX3ctUKXjwPBWRXYid7LChnQAR6SRcyxyD1Eoel5ZVrJyKHqRkxcanFHeqRU1\\r\\nOyOgtsQyPIGtLipmOgc6i5JYhqbQ4mNu10CGS6ZKhjf6rFIqLl/8f4lnBc28\\r\\nUqVuP20Ru6KJZTVVQRF28FweMByR/3LyAWfObMwXJ0+uFEV941VEDv5MGdId\\r\\nfePTP2cHRSJxPqVhpPWtfzYLStUzLFvtLfE45hympok4lZeKfLVtZVVQEgT+\\r\\nojEImdiZQJ0dT+jeJhmuTjzURQcLapXv2GLBUZaY2zfoAXR31QNYjADOxlrO\\r\\nutSUzsBNBF5mRKEBCACVNQTzI2Cf1+G3q38OtXO89tuBI/a5TjcHh/sFIJB6\\r\\nPPuEg/uW+EsjkgI3yk+UZZd6iYohO2mJcJ7MnaFHOu7tmOEaaHSiYsA0RTnV\\r\\nqUBlbHbsl2oSlQJ/mjJ4cWq5ateuLHhx2RV0t1bm2anHJnqKGkqYqXA72m5g\\r\\nrLzRSJ9M43wQRheGWGNoNdg4kPxU+PjYwfk2ARX5SCUKoG0qp0RhRMplX74u\\r\\nYi+Ek/9qSyZevmhK55sXIUNwLsuEhejlr0iucOt2vcIybQ9EbMXz62yYMRjY\\r\\ngy4SxW5aQJxXFeWkSo6wzMqQ1ZiSArRCezBk+mftxNrmwmtCcJajQt2uAQQV\\r\\nABEBAAHCwF8EGAEIAAkFAl5mRKECGwwACgkQxEmnXgXmuD/7VAf+IMJMoADc\\r\\ndWNhn45AvkwbzSmYt4i2aRGe+qojswwYzvFBFZtyZ/FKV2+LHfKUBI18FRmH\\r\\nmKEba1UUetflytxiAwZxSJSf7Yz/NDiWaVn0eOLopmFMiPb02a5i3CjbLsDe\\r\\nex2y/69R0+fQc+rE3HZ04C8H/YAqFV0VOv3L+2EztOGK7KOZOx4toR05oDqb\\r\\nZbiDzwhsa2MugHLPLZuGl3eGk+n/EcINhopHg+HU8MHQE6rADvrok6QiYVhp\\r\\nGqi8ksD3kBAk43hGRSD2m/WDPWa/h2sh5rVswTKUDtv1fd1H6Ff5FnK21LHj\\r\\nEk0f+P9DgunMb5OtkDwm6WWxpzV150LJcA==\\r\\n=Hcoc\\r\\n-----END PGP PUBLIC KEY BLOCK-----`;\n      const input = `Hello, these should get replaced:\\n${prv}\\n\\nAnd this one too:\\n\\n${pub}`;\n      const { blocks, normalized } = MsgBlockParser.detectBlocks(input);\n      expect(normalized).to.equal(input);\n      expect(blocks).to.have.property('length').that.equals(4);\n      expect(blocks[0]).to.deep.equal(MsgBlock.fromContent('plainText', 'Hello, these should get replaced:'));\n      expect(blocks[1]).to.deep.equal(MsgBlock.fromContent('privateKey', prv));\n      expect(blocks[2]).to.deep.equal(MsgBlock.fromContent('plainText', 'And this one too:'));\n      expect(blocks[3]).to.deep.equal(MsgBlock.fromContent('publicKey', pub));\n      t.pass();\n    });\n\n    ava.default(`[unit][PgpHash.sha1] hello`, async t => {\n      expect(await PgpHash.sha1UtfStr(\"hello\")).to.equal(\"aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d\");\n      t.pass();\n    });\n\n    ava.default(`[unit][PgpHash.sha256] hello`, async t => {\n      expect(await PgpHash.sha256UtfStr(\"hello\")).to.equal('2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824');\n      t.pass();\n    });\n\n    ava.default(`[unit][PgpHash.doubleSha1Upper] hello`, async t => {\n      expect(await PgpHash.doubleSha1Upper(\"hello\")).to.equal(\"9CF5CAF6C36F5CCCDE8C73FAD8894C958F4983DA\");\n      t.pass();\n    });\n\n    ava.default(`[unit][PgpHash.challengeAnswer] hello`, async t => {\n      expect(await PgpHash.challengeAnswer(\"hello\")).to.equal('3b2d9ab4b38fe0bc24c1b5f094a45910b9d4539e8963ae8c79c8d76c5fb24978');\n      t.pass();\n    });\n\n    ava.default(`[unit][PgpKey.usableForEncryptionButExpired] recognizes usable expired key`, async t => {\n      const armored = \"-----BEGIN PGP PRIVATE KEY BLOCK-----\\nVersion: FlowCrypt 7.0.1 Gmail Encryption\\nComment: Seamlessly send and receive encrypted email\\n\\n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\\n+gib+vSxHvLhC6oDBA==\\n=RIPF\\n-----END PGP PRIVATE KEY BLOCK-----\"; // eslint-disable-line max-len\n      const expiredKey = await KeyUtil.parse(armored);\n      expect(expiredKey.usableForEncryptionButExpired).to.equal(true);\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.parse] S/MIME key parsing works', async t => {\n      const key = await KeyUtil.parse(testConstants.smimeCert);\n      expect(key.id).to.equal('16BB407403A3ADC55E1E0E4AF93EEC8FB187C923');\n      expect(key.type).to.equal('x509');\n      expect(key.usableForEncryption).to.equal(true);\n      expect(key.usableForSigning).to.equal(true);\n      expect(key.usableForEncryptionButExpired).to.equal(false);\n      expect(key.usableForSigningButExpired).to.equal(false);\n      expect(key.emails.length).to.equal(1);\n      expect(key.emails[0]).to.equal('actalis@meta.33mail.com');\n      expect(key.identities.length).to.equal(1);\n      expect(key.identities[0]).to.equal('actalis@meta.33mail.com');\n      expect(key.isPublic).to.equal(true);\n      expect(key.isPrivate).to.equal(false);\n      expect(key.expiration).to.not.equal(undefined);\n      t.pass();\n    });\n\n    const httpsCert = `-----BEGIN CERTIFICATE-----\nMIIGqzCCBZOgAwIBAgIQB0/pAsa31hmIThyhhU2ReDANBgkqhkiG9w0BAQsFADBN\nMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMScwJQYDVQQDEx5E\naWdpQ2VydCBTSEEyIFNlY3VyZSBTZXJ2ZXIgQ0EwHhcNMTkwNzA4MDAwMDAwWhcN\nMjEwOTEwMTIwMDAwWjB2MQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5p\nYTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNjbzEbMBkGA1UEChMSWSBDb21iaW5hdG9y\nLCBJbmMuMR0wGwYDVQQDExRuZXdzLnljb21iaW5hdG9yLmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAMsNA6BafLAJyN3SjorK4fq6P8oArZLHCHwB\nuf4NQ0Oo/CdMgrV28/PM4yh2U0++zL9ZuS3foqMOSwy6DZbZIfBa/WBjhJKd4/gy\n2yJwOGwSsIyVMpQ/HsBrZRruN2oEiu4inE4hPyYC03Z7zRlTDOuxDDBOJjuKMYRr\naMlzOqj7ZZDLAOYgRDoGHTGF1AnqT+ZsV98rXCijgFGvHTaXqJxcz+edKfHTzy+n\njsgbbbBJ9jGATX8qXqdqjCHm6D5G6hJ2MfcQt4Ohd5sm8BKvZAEMCcsLww2ijwx9\nj7ZadN7n7dOp5sY32BEhe7l0ki22TDS+pcaySoP8E5axqrnAMkUCAwEAAaOCA1ww\nggNYMB8GA1UdIwQYMBaAFA+AYRyCMWHVLyjnjUY4tCzhxtniMB0GA1UdDgQWBBQO\nJfQVakUgYp9x0ncgzQTXXFjfOjAfBgNVHREEGDAWghRuZXdzLnljb21iaW5hdG9y\nLmNvbTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUF\nBwMCMGsGA1UdHwRkMGIwL6AtoCuGKWh0dHA6Ly9jcmwzLmRpZ2ljZXJ0LmNvbS9z\nc2NhLXNoYTItZzYuY3JsMC+gLaArhilodHRwOi8vY3JsNC5kaWdpY2VydC5jb20v\nc3NjYS1zaGEyLWc2LmNybDBMBgNVHSAERTBDMDcGCWCGSAGG/WwBATAqMCgGCCsG\nAQUFBwIBFhxodHRwczovL3d3dy5kaWdpY2VydC5jb20vQ1BTMAgGBmeBDAECAjB8\nBggrBgEFBQcBAQRwMG4wJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0\nLmNvbTBGBggrBgEFBQcwAoY6aHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0Rp\nZ2lDZXJ0U0hBMlNlY3VyZVNlcnZlckNBLmNydDAMBgNVHRMBAf8EAjAAMIIBfQYK\nKwYBBAHWeQIEAgSCAW0EggFpAWcAdgDuS723dc5guuFCaR+r4Z5mow9+X7By2IMA\nxHuJeqj9ywAAAWvSsgGGAAAEAwBHMEUCIQDuwilh2VuUnkTH0tmDUbAdKWDxFukD\nm/4EktTbiwgFNAIgZltmbZUzknxDpGUXkVLpFmWTogu4wAGxh72hbbFp804AdgCH\ndb/nWXz4jEOZX73zbv9WjUdWNv9KtWDBtOr/XqCDDwAAAWvSsgIeAAAEAwBHMEUC\nIQDzAY1oWZD1mhX+nCKORP4DxtO3AnhLSUMOyvv3OBbICQIgWWzTJP2gsPM6vHux\nkb6fQtPekabXk0nhrOScMHr/cvAAdQBElGUusO7Or8RAB9io/ijA2uaCvtjLMbU/\n0zOWtbaBqAAAAWvSsgEiAAAEAwBGMEQCIFqbAfpfnJFvd4miwlb3ZMCy/tph+qn6\n0gFBIGhOFVlQAiBqo/dlgJEfPJU2pjPlR22kl7wTbnFnbVabTAy8eKx+DjANBgkq\nhkiG9w0BAQsFAAOCAQEARcovgnGiFSc6ve8yTxFOho47wBKXwYAUfoGiiRFybcX6\n43JcEMyH6KYU8qnfhKzp9juYBXTuc+4BqLP8fGdrP6I7xfYux6PWdhZ9ReVxZhrn\n+7neAPnr4IcDyUMGB3bqn4wslL8Go1+dHKfM+Ix8k/+ytaXWYZQgiWNwmuR3Piay\nvo5ioURVp9Hm28b1A5o828aXph6nbPhyaLD5gUdQTuprQGpJMo2tL9AmZhtw3iPH\nNu6RzBFp27492OM1t0vvbEsNkMgD3/wSCMev5rleor1bvTT+GkSEArEdpHRydtcN\nWeNYP84Yjw6OFSHdi2W0VojRGhxm7PZCMqswN/XaBg==\n-----END CERTIFICATE-----`;\n\n    ava.default('[unit][KeyUtil.parse] S/MIME key parsing of HTTPS cert', async t => {\n      // parsing throws because the domain name doesn't look like an e-mail\n      // address\n      await t.throwsAsync(() => KeyUtil.parse(httpsCert), { instanceOf: UnreportableError, message: 'This S/MIME x.509 certificate has an invalid recipient email: news.ycombinator.com' });\n    });\n\n    ava.default('[unit][KeyUtil.parse] Unknown key type parsing fails', async t => {\n      await t.throwsAsync(() => KeyUtil.parse('dummy string for unknown key'), { instanceOf: Error, message: 'Key type is unknown, expecting OpenPGP or x509 S/MIME' });\n    });\n\n    const expiredPgp = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\n=wYbc\n-----END PGP PRIVATE KEY BLOCK-----`;\n\n    ava.default('[unit][KeyUtil.parse] OpenPGP parsing of expired key', async t => {\n      const key = await KeyUtil.parse(expiredPgp);\n      expect(key.id).to.equal('3449178FCAAF758E24CB68BE62CB4E6F9ECA6FA1');\n      expect(key.allIds.length).to.equal(2);\n      expect(key.allIds[0]).to.equal('3449178FCAAF758E24CB68BE62CB4E6F9ECA6FA1');\n      expect(key.allIds[1]).to.equal('2D3391762FAC9394F7D5E9EDB30FE36B3AEC2F8F');\n      expect(key.type).to.equal('openpgp');\n      expect(key.usableForEncryption).equal(false);\n      expect(key.usableForSigning).equal(false);\n      expect(key.usableForEncryptionButExpired).equal(true);\n      expect(key.emails.length).to.equal(1);\n      expect(key.emails[0]).to.equal('flowcrypt@metacode.biz');\n      expect(key.identities.length).to.equal(1);\n      expect(key.identities[0]).to.equal('Testing <flowcrypt@metacode.biz>');\n      expect(key.isPublic).equal(false);\n      expect(key.isPrivate).equal(true);\n      expect(key.expiration).to.not.equal(undefined);\n      t.pass();\n    });\n\n    const notExpiredPgp = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxcMGBGCMK9QBCACtAfN1HqnNak1taNOaaZ7IeWomOjUCWJA4J1zr1N7ffQWNNGgqDeAuLnG0/pzA\nJWnj6DNC7l07TNI0/Lk+nY0+MGtQFbCjyGPwctBZ+qhXwv9nz1Xvv0D341ZLeGCGdQrGzNuaUZGa\n/VnuapE1Zbf16LkXyCdcXQSuqqZYDJHsCg6bdhJUh1xhXm3N4JuRcN98TTwOI9Ssz1Sv7SiXYseG\nBv1EtMDYdE9PC7jORqh9noD7a0RPJHLMXJHnUxnnf6fDReMVFuAB1KAqt9sSjZ3gQDjnCO/tmZd9\nkCpiEceYeLJ69PmedU7Bcyr9jaRFbvh6WQ6BeSioK8utiQRjAqCJABEBAAH+CQMIZHdUSa13/mqN\nRg1YXueB5XXU3aswug12CDw/aMB8d2m6OpTNnf+aHGYmId2YoGhYavTxQDOlekTKYRFVdNDUVpwX\ngl2g0PfASs2wCuJoQYkw8JO22eb7DS7ynGggspZm2VYVIIrXRBP29076AwkgHfaP74NXOjNmDOq4\nzGjDZ1Io7zGUju189oNzhrr5NTKucS8+MM0OI+hSLFrKsdt3NIaNRmM4Z6moGW978IzXWkmuTeF+\n/s6ulKux/fil6sRM2crcR2KqXe4C8okpiKOsB4TjgMRqkEDKsbnHWptlvG7UCC1/okCKkpIyBF1N\nsJuC6XWvYhm3HtyAfgwMsZijVb8YQU+oGL8bfJD0t9mPkNTegf9t6l/TQwzkHLprkSY2SRvFIZkn\nW4VANyQrsBWnDyPXUzoxXROmxdDIF9vEZHdyQ/dUmBR2ylnxbwPnrcUHfz/kb+By/vSmZRCYWA8f\ncKJJi1IgsYuXuRrhVavWM8V6h2M6PCCCBKoUwV7SKh2d60yVKKKHZdnjkyTKD6DxgwHcbTtzChUS\nUA6soC36Skd+uTX4TJRDyxEqz7whGSdohaMn/XU2asZbSkyI1R7Ae/S2I2kb3pyHzWOmFUlGYT5j\nXNTQ3teFt9N4nC0J40a/b0TcUfxcyii8QZxGSjAuRVK5/Cg+vOIShHq1pljA+ojlKgkYGO/dfqBo\n/0Z59Cv9DfE9oFTCJ3iV5q9yBekSxuGj6yHHV3A7RsHFeqvCQrGgTsnxKc5o42clVZFGRt/z+05N\njp/GbSgz0BwTEwXxIsMwJXINJBCIyBpfih49ma4mhnwnk9wbt6ZMGUb9oMFnUUlZjdHq7PkA3HN9\nzGgt3X9B1KukuPqOXD9SXJxgb388UOMOgS7KnGoyTi3wecsQ9bAsM8ZKyPBsLSMCfqi6h0JPQ8kI\nzSZUZXN0aW5nIDxleHBpcmF0aW9uXzEwMHllYXJzQHRlc3QuY29tPsLAjwQTAQgAORYhBHw7OLss\nin5pPCnfRVwIAzFmr5HjBQJgjCvbBQm7+B4AAhsDBQsJCAcCBhUICQoLAgUWAgMBAAAKCRBcCAMx\nZq+R4w0PB/4oAvFExHF/9G4dM/mohsmI9jbicEacYs1HafNeI/qEvVL4VKxZa6AG1pOyVPsqGkB5\nblYEmXyRMU/aB7rJa7qSvk/BKm1mg7O5SSPE/Nz4zYDxWI9pe2pXlCrQt8JoAKIXHkLtcjJiWLqP\nQL8bMAnWEeuBYejtJFtBXxu/QJKxCq/SmeQ6eGazQb+VG5IC/0q2Rc0RnjDfY8A2/Are8Hhdi1CK\n/VDUWrUMDYWPi0uZDztVDS+rcSZ96WpKKdWQ1+9/SyJ47bJLzLAgRdujKPvGKEKJEw8j3xhGYXQ9\n0M7d19qcny6aDj5EuTdBhNE9xSOj1Kd6eyLg8k0X1Dc6duxCx8MGBGCMK9sBCADy94Iwnek4nsq/\nlcoAZ/Uv+CwE/3LTiozbKfQB0evJSnz0i8FksAMc7YWMCH6/Wst06Q614VxQ+QqTIdAXNNtd8fYD\nkFrHDMdmAUcODvY/u0/fNcsdIZ/vts7WLsf7g8YF5FzIV9dV55LZcFOX2qIHhEtwYrrTHOffAsIl\nVS+W1HZ2Z+luHXP+GaC+E8gypEUwsUPjSv9ja2hSnA7G/0SR4NKpeBMusujkyTDJJPhWl7cdrMwr\nQQ9kXO39km5nVFw5y1tZ14pwMNLGTIeOj/w5G/yw4uXts57DWCC1wGfnj7wIwvqhlvFH75LC62Yi\nUXopG3fCYbJemPgawP4cCmKBABEBAAH+CQMITJPMMLWMjLKNmVda+7Icun0ep5gFLDpPVxFuiIle\nUwRhKXJFfHKAoKCc4KEl2cI0CtzesaPlJIDKDyEwdCSYGt1KqzNYJDW01ZRkV+OP+rTPuPthj8xV\nPVQYPexq9Dw+rjN4OWdjpY2Thv9xzQXyMGDM/pRvrCtWa3qB3J7MwWuCAhGrCjmwMfh8h+6rOIGm\nK0Q9nUXSDrMUD8PGHtJj3M/twMlapjCL2EfHkYyF9X110t1Xk8hlD4XGeRjsXyb+HqWW8ma0AJ6p\n6iekX0sc/WaolbHhwAVRmw9pXT4cS36i01t6vJRYuvQGaodsavxgtVBvYGAjF5g+/29D9rm8UvW5\nFe2Frs3tPkU2uedTJjs3LENiOcJ+RCzCa94NyB7smSueidcXyyvOaaVNJGI3sV7N7TNBTXnr/7v2\nkxy56A9bNEy8/kYary3MZQLXkT3kp8h4p5GWuEkOIarFBJiNC+axxo9sRR8x2khNKrqRBXh49acY\nkrGZo4p7kEZm5R5+PRFJ4hie0H4tCvQ6YzUvYDTWnWf4NdrUmdEep8RuSmE3G3RhD1Ye2bnHZm1i\nzv4OVphTQoHO41A4q4cLvTPUv96ugydWWCMjBcFpgSvR3k3onQ2hPm7z+78/tusSTiBfmxXac5yP\nAkHM2RbtLY5BQg99Xm66ftVY/v3Mk+ooXDo0cqDTWwCv682YQ0vM9tgZoF2B3m97JHEIsaIKMe+g\nPhSph5YMh5pJw9B1Usl7oevQt3YivtPaEzNpvcHHaf0iBc54zHhVJc11KEbzpX47Um1v05W7Zklx\nnL5wnptCxgoieBxId8jodAOfgaamRRuHm/6O54O04QzyGXkaPomXF9g1z0YwrpH+gizosU3Do00g\nWMpZvqGzbIs5rO13ha3hGqydaI+T95MJfdUyw59YpDXH53+QwsB8BBgBCAAmFiEEfDs4uyyKfmk8\nKd9FXAgDMWavkeMFAmCMK+EFCbv4HgACGwwACgkQXAgDMWavkeMkWgf/aQxWUqouGN177ELAOc9/\nyDgQDL50d+gRTWtN0cos2YDl3iZaHXTSh3f3m11RrDjHTi5DJ06tT4UFkBlUaV74YH48ShEJh7E0\n4Yb/6zmW0Fzj3MMZcrfKhyk/SzJi9Z3yXAM7PiCmgDug3KI75rBnkj2aF7u4+9tFApboAwfRwAzF\nZiiWTc8Qyg5cIAl+vLKm5YFa5ulz+XAwie5S7rQ8e/JFH6I92NEWvjH/T6gYMmGxxT5qX7jIYmig\nMTTRkC/bwsFxfOa28x/HZT/kTdIqxooDTabieSEc56CY5YPp4cvQL+HkJBY6ky5B+HRuGkbsXGmn\ncmKFmmDYm+rrWuAv6Q==\n=oWPu\n-----END PGP PRIVATE KEY BLOCK-----`;\n\n    ava.default('[unit][KeyUtil.parse] OpenPGP parsing of not-expired key', async t => {\n      const key = await KeyUtil.parse(notExpiredPgp);\n      expect(key.id).to.equal('7C3B38BB2C8A7E693C29DF455C08033166AF91E3');\n      expect(key.allIds.length).to.equal(2);\n      expect(key.allIds[0]).to.equal('7C3B38BB2C8A7E693C29DF455C08033166AF91E3');\n      expect(key.allIds[1]).to.equal('28A4CCBFA1AF056C3B73EA4DECF8F9D42D8DFED8');\n      expect(key.type).to.equal('openpgp');\n      expect(key.usableForEncryption).equal(true);\n      expect(key.usableForSigning).equal(true);\n      expect(key.usableForEncryptionButExpired).equal(false);\n      expect(key.usableForSigningButExpired).equal(false);\n      expect(key.emails.length).to.equal(1);\n      expect(key.emails[0]).to.equal('expiration_100years@test.com');\n      expect(key.identities.length).to.equal(1);\n      expect(key.identities[0]).to.equal('Testing <expiration_100years@test.com>');\n      expect(key.isPublic).equal(false);\n      expect(key.isPrivate).equal(true);\n      expect(key.expiration).to.not.equal(undefined);\n      t.pass();\n    });\n\n    const nonExpiringKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmDMEXylIoBYJKwYBBAHaRw8BAQdAMgtGtZnSa/oq2FHZ7Ow7rnCpRDJ5+WlojNXt\n6r74RdW0DE5vdCBFeHBpcmluZ4iQBBMWCAA4FiEEjdc3wIbaszE+t21fSpIVLfL9\nbb0FAl8pSKACGwMFCwkIBwIGFQoJCAsCBBYCAwECHgECF4AACgkQSpIVLfL9bb1J\n/QD8CDQrGNP3ZvSQUoA7kTQURLO9qkctY6Yn1+GsJR6M3zQA/ievQawWchCZVzgT\nSBC9rHNi6GbYSn3Tm+PnsUOe9g8NuDgEXylIoBIKKwYBBAGXVQEFAQEHQLU+tO+s\nCpD7n1C0Mg9Yzghr9pMps9UaexwMuxxVeWZcAwEIB4h4BBgWCAAgFiEEjdc3wIba\nszE+t21fSpIVLfL9bb0FAl8pSKACGwwACgkQSpIVLfL9bb39XgD6A91LwqK+CEzl\nMcqZHXuttXHc2wZ2nvjjtbzWSEzxvpAA/jdWwCNBg65Wh93Df5/6Ec05W8AgFwJH\n/NBHfzBA90AM\n=E46c\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n    ava.default('[unit][KeyUtil.parse] OpenPGP parsing of never expiring key', async t => {\n      const key = await KeyUtil.parse(nonExpiringKey);\n      expect(key.id).to.equal('8DD737C086DAB3313EB76D5F4A92152DF2FD6DBD');\n      expect(key.expiration).to.equal(undefined);\n      t.pass();\n    });\n\n    const pgpArmoredTwoKeys = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\n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\nzZFGf6poIjKUC8V2Zww6\n=Hjpw\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n    ava.default('[unit][KeyUtil.readMany] Parsing two OpenPGP armored together keys', async t => {\n      const { keys, errs } = await KeyUtil.readMany(Buf.fromUtfStr(pgpArmoredTwoKeys));\n      expect(keys.length).to.equal(2);\n      expect(errs.length).to.equal(0);\n      expect(keys.some(key => key.id === '5A5F75AEA28751C3EE8CFFC3AC5F0CE1BB2B99DD')).to.equal(true);\n      expect(keys.some(key => key.id === 'BBC75684E46EF0948D31359992C4E7841B3AFF74')).to.equal(true);\n      expect(keys.every(key => key.type === 'openpgp')).to.equal(true);\n      t.pass();\n    });\n\n    const pgpArmoredSeparate = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQENBFzYItQBCAD1FmP71FRRC3nkaIltLH2oZklMY+SAbnses8o5e3wj3DKQk3P4\nZTxALAl9g5GtYqYE5vA2SOSRiuiVD+ibYDOAAEjBBKYlfaFy1UCFAK5gibhP1o04\neEuRuAJt9JJO0aFTj+cwWx/wII+ledavdiWHg1T80JEoHV+EMlvNB51ydZGnSjPs\nntQTO4tQzp1knA9hS20O6g6gLakaNlEc1m3G445d8tWj7V3plLR+FegYWoCJkQ4F\n3W6jLSM4ErfLQpj6Ew6bk65wRC8XSNFJAImfVGd40tAtYcHFf/HE3D3NLH3OhFc3\nEUnaQtCEqrWqBD/HFdGvqmbVYL3KWusJCXafABEBAAG0IFRlc3QgV0tEIDx0ZXN0\nLXdrZEBtZXRhY29kZS5iaXo+iQFUBBMBCAA+FiEEWl91rqKHUcPujP/DrF8M4bsr\nmd0FAlzYItQCGwMFCQPCZwAFCwkIBwIGFQoJCAsCBBYCAwECHgECF4AACgkQrF8M\n4bsrmd3Ftwf+OhNoF3bq1o7QFJVt6bfIEN1Uqf2+h11pO60ZGJNjLm45rdy2Jt4r\nQ86h/XUONGDfV28Pj/Gwz7/ruB4YcFL83HwuGHHh/QZsbHvmopycSS7DQp6yiiSk\nM0sLBfbG5jxQpgahrsVqPDhWhvuNCGrWFqEPAmLWyz7CyvtVbglL4cB9V7W9eHFz\nFsLSITLR9LJybqqIIRXerpc/cj4ZI0ll/nZbMuFsY/CWbfdxk6CsFTAQ7gegXs/c\nQaKQuQJFtl46CFCjUMJJN3SSsaihOu5V3zVWJdW1GJXQWpe2Rir2MqzhSuW0Uw8g\n/nd2sNwmriQRfQd7d46YOLcBqVksGiWCb7kBDQRc2CLUAQgA10E6Da2YSXL/6VKJ\nYaFNgBi9p7pko6KzrSD8AGxjpDo7BV11jBNImZxP3WrmjPfFYuIET+Lt05St/fdn\ntkiHkkPimKNSmH46E0lRnULO3Tmo7Eiu/CMPI5Oj9KZr8fQBvFOh2qFr+dgflIHr\nWGO94tIeRq2jdZblGEtOY8kfqf7/WbzaVhIJM/zaYyeQFLv+CNkc2AMIDpsBmKPL\n7wrQzGi1JK4Xn7JdRgMoEVFJJFsDkByvp6mvwjRgXkG/UKnDf75vOJzCP1i/6ESb\nfu0+pz/gsiwPIcEnS+1F2LWmV2EQTf4FPz75J31bGixP2qIa+Macr+AepreugpFq\ngdUQjwARAQABiQE8BBgBCAAmFiEEWl91rqKHUcPujP/DrF8M4bsrmd0FAlzYItQC\nGwwFCQPCZwAACgkQrF8M4bsrmd3GZQf+OLkOd0ddebGvLgcQrUANuKASTbke+PUD\nlaTTpdJlhufLqXHAL3ydZjnmFXEOYQPzWr1DgaUEiEtiw4MO3lWKXj3+J200jPpg\n+XEFNXneXrZEJoG/q4h2hB0icP/1k1q+FsSgc3I6kVsGBmnMasJ+j9FhUJ/JECJS\ngQwP7QeE0O0oa8zQU+INc6viBkV1F3FP5PvIfVjfmw8yqlhZgeCSSavo/kEgyTlg\ncItxVc8FURPk2BkmWYjZ+N0uNOYrI7FGOHdoW4j9rmuOhtYHGLRC0mAcADIRcv7p\nZlBF2eTk0HMhizTvGmOWcv5htkCqxpCSNnjHLsM6YCl+CcW6a8U7/g==\n=46pe\n-----END PGP PUBLIC KEY BLOCK-----\n-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQENBF4pefQBCADjcgq0Wi7ZCDiTCnMnG5PTnTU5nWW7eg9ofEjV9SbDDiHV2SkJ\nZBynFzGgAaWs/x3FINwNffnE/Yc4iokd1wk3tlhcfvzLUMZW9ZrTPAGOioSKa621\nnQjTKkln2kuU60oeG5CJocIiLroLHay9N9kVvlidH4dVbC9+jyvdcjieq3RUnXVC\nzpF3vZN/aTgbjecyfQY4oeiMglpBImTdPw/7k3Xz6L7D2o8wIuVyS7KxTrIsmR1F\nuTkfAWzfhI4rZHxyzWmCWZnC+N+rLVdLOo4V7op6SZE1x3Hhy2BXChBzjIZbJ1/J\neIQLMk8WaszkGc0uXFXsF/fB+g9woa7cRjT5ABEBAAG0FXRlc3Qtd2tkQG1ldGFj\nb2RlLmJpeokBVAQTAQgAPhYhBLvHVoTkbvCUjTE1mZLE54QbOv90BQJeKXn0AhsD\nBQkDwmcABQsJCAcCBhUKCQgLAgQWAgMBAh4BAheAAAoJEJLE54QbOv908+YH+gM4\nkpkNL7IWUjRJqmuSybWT23BKtFq4/P1HhGyUKmIq/ZqjBIzR+rgmfM5qw/HYWO+l\nFGPoCeusooMauWWHZ5rbNrP05cwRlRvCg+0GXJ3Yw2tzOayXq5SL3QLa//P2z4yt\nWa9pl5EXIzAWNKlGiuTmZ19tDIrNg3tJQKhdd9MNRite4ZyMvkMB9l/d8PSIIa9J\nbbOaQZa0WH6lg417DHAhWIzcI8PLW9hXoeGkOy5z7ah9H7+rZJAcz/Z2Qfo0zu4+\nvQnzefA9vzd+d9CRr3ExZMNxpSykH4l4PbYjMpKfLRpdsLvvLnV2H06KZEcxBsn0\nczaln5Xm/0wga57IgFW5AQ0EXil59AEIAMW00JciIzastXINdy0Lx15ikpkwQe/o\nBO0zxifSRwsvpgh3KdvKV2DfrEagvVXpjv3GV0li5bvdn9mKwDkpVttHddV4u4Sy\nATEN733x9EjhcZf8CQRbqDnJKjpDLI2xpUf9R5coI1je9agNeyOsppXnVs371O4L\naVYzdXLUtZ6LqMN/F0xVbDEEZsFzBI+0Z0f1b0tHuExF3xvBg6bodS7Tnel3LP0x\nZGb1EiwNMo+9GbLkpr64YkUrXvY/L7jm0eQSYmxUTD5o+EDKhizxDCD7adqCzhhK\nXtpDsXH1M1N15SzJlchzbXBVY+cNC+6OCmsKFjbhGtFaEFSE/kdBMZMAEQEAAYkB\nNgQYAQgAIBYhBLvHVoTkbvCUjTE1mZLE54QbOv90BQJeKXn0AhsMAAoJEJLE54Qb\nOv900VcH/RGkjO1VfyKPgm17PttvC6PtvSAERvEhSRTy3i2ds4s3DXtG3Y1N6NU/\nYqolPFrY6PtFX0tTSeN4Zw1x9WckD0hI6qWsj0gcdwK05MmUn8TW0gKK2DwghLZt\n3vtn25PuQtzIz/ahwMkOYM5vfJLH3ZoWt7yF/zrvuul9t4bM6ZaNA8uGJf+bYObx\nCnSPBUoy8XAfrMg9YDF8djFjhGktbTMWY3feKbzPUHBfT6kii+D+Hmj/C2eb8gYx\nXPk9f8zmQi8NqUMzsOQokj9iq+UB1cC3korAsuCVmC3El6cJbQvWEAMEVOFdY3pA\nvpQiyk4ceuTNkUZ/qmgiMpQLxXZnDDo=\n=lQQh\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n    ava.default('[unit][KeyUtil.readMany] Parsing two OpenPGP armored separate keys', async t => {\n      const { keys, errs } = await KeyUtil.readMany(Buf.fromUtfStr(pgpArmoredSeparate));\n      expect(keys.length).to.equal(2);\n      expect(errs.length).to.equal(0);\n      expect(keys.some(key => key.id === '5A5F75AEA28751C3EE8CFFC3AC5F0CE1BB2B99DD')).to.equal(true);\n      expect(keys.some(key => key.id === 'BBC75684E46EF0948D31359992C4E7841B3AFF74')).to.equal(true);\n      expect(keys.every(key => key.type === 'openpgp')).to.equal(true);\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.readMany] Parsing one S/MIME key', async t => {\n      const { keys, errs } = await KeyUtil.readMany(Buf.fromUtfStr(testConstants.smimeCert));\n      expect(keys.length).to.equal(1);\n      expect(errs.length).to.equal(0);\n      expect(keys[0].id).to.equal('16BB407403A3ADC55E1E0E4AF93EEC8FB187C923');\n      expect(keys[0].type).to.equal('x509');\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.readMany] Parsing unarmored S/MIME certificate', async t => {\n      const pem = forge.pem.decode(testConstants.smimeCert)[0];\n      const { keys, errs } = await KeyUtil.readMany(Buf.fromRawBytesStr(pem.body));\n      expect(keys.length).to.equal(1);\n      expect(errs.length).to.equal(0);\n      expect(keys[0].id).to.equal('16BB407403A3ADC55E1E0E4AF93EEC8FB187C923');\n      expect(keys[0].type).to.equal('x509');\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.parse] issuerAndSerialNumber of S/MIME certificate is constructed according to PKCS#7', async t => {\n      const key = await KeyUtil.parse(testConstants.smimeCert);\n      const buf = Buf.with((await MsgUtil.encryptMessage(\n        { pubkeys: [key], data: Buf.fromUtfStr('anything'), armor: true }) as PgpMsgMethod.EncryptX509Result).data);\n      const raw = buf.toRawBytesStr();\n      expect(raw).to.include(key.issuerAndSerialNumber);\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.parse] Correctly extracting email from SubjectAltName of S/MIME certificate', async t => {\n      /*\n            // generate a key pair\n            const keys = forge.pki.rsa.generateKeyPair(2048);\n            // create a certification request (CSR)\n            const csr = forge.pki.createCertificationRequest();\n            csr.publicKey = keys.publicKey;\n            csr.setSubject([{\n              name: 'commonName',\n              value: 'Jack Doe'\n            }]);\n            // set (optional) attributes\n            const subjectAltName = {\n              name: 'subjectAltName',\n              altNames: [{\n                // 1 is RFC822Name type\n                type: 1,\n                value: 'email@embedded.in.subj.alt.name'\n              }]\n            }\n            const extensions = [subjectAltName];\n            (csr as any).setAttributes([{\n              name: 'extensionRequest',\n              extensions\n            }]);\n            csr.sign(keys.privateKey);\n            // issue a certificate based on the csr\n            const cert = forge.pki.createCertificate();\n            cert.serialNumber = '1';\n            cert.validity.notBefore = new Date();\n            cert.validity.notAfter = new Date();\n            cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 30);\n            cert.setSubject(csr.subject.attributes);\n            const caCertPem = fs.readFileSync(\"./ca.crt\", 'utf8');\n            const caKeyPem = fs.readFileSync(\"./ca.key\", 'utf8');\n            const caCert = forge.pki.certificateFromPem(caCertPem);\n            const caKey = forge.pki.decryptRsaPrivateKey(caKeyPem, '1234');\n            cert.setIssuer(caCert.subject.attributes);\n            cert.setExtensions([{\n              name: 'basicConstraints',\n              cA: true\n            }, {\n              name: 'keyUsage',\n              keyCertSign: true,\n              digitalSignature: true,\n              nonRepudiation: true,\n              keyEncipherment: true,\n              dataEncipherment: true\n            }, subjectAltName\n            ]);\n            cert.publicKey = csr.publicKey;\n            cert.sign(caKey);\n            const pem = forge.pki.certificateToPem(cert);\n      */\n      const pem = `-----BEGIN CERTIFICATE-----\nMIIETTCCAjWgAwIBAgIBATANBgkqhkiG9w0BAQUFADB0MRMwEQYDVQQIDApTb21l\nLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxFzAVBgNV\nBAMMDlNvbWUgQXV0aG9yaXR5MSEwHwYJKoZIhvcNAQkBFhJhdXRob3JpdHlAdGVz\ndC5jb20wIBcNMjEwNDE3MTIyMTMxWhgPMjA1MTA0MTcxMjIxMzFaMBMxETAPBgNV\nBAMTCEphY2sgRG9lMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyKOw\nVX51bduPdwSLR4u1O4HuOrELZjlOx8SWlOdU2yDZmp9iTZ/jP318xUs7XL1gIMDF\nmXuDZB+KU9rwvECOecazWp8vpfLV/Tn/lp5lDLz+QqwlSWruzz0Z49F6zCWfBMQQ\nY475a03pd0oo6Soxt89A5PXuQhIBgdniyxUeQe0Okd7MC5/w0R+95aqZB47ui7ur\nR7HcyGzkvfADXvdeZQsKSjja0lVFUJAJ6Uj2o0R9Z1YHtZKH9/D75IiYY3gqYJtt\nBZoZPOMpl7Jam5Hz7PVWV3aeeMsAAHALWK7qvfaNx3IOCVh5KYQZ544P7cGGgpuw\nUamKkF+wR7H4d7OYPwIDAQABo0kwRzAMBgNVHRMEBTADAQH/MAsGA1UdDwQEAwIC\n9DAqBgNVHREEIzAhgR9lbWFpbEBlbWJlZGRlZC5pbi5zdWJqLmFsdC5uYW1lMA0G\nCSqGSIb3DQEBBQUAA4ICAQCeGSsJNYsyQXnRal3L0HDF8PTj5zBa2jCSVAuwMe9Z\nLWSJEXetF6uwH3yJzCxe/ZGNheEUAMGnMC1lYwsZ8x/hO8WcnzGxC1kqS71jV0us\nrYZGsSb6dOoSigUfrzEcImx33n5yKYS8cHN/tUMvPiULX9RlSWnKlAfQClQeIxEA\n6Y1Jeu0AVP3ugMajxqHoA10JOOrqjKuvkkM3gha9iS+q0w0mqhJ8GzZfOTdFJj/G\n/erHQ/HWL7mqJoGh+i6I9N5qBNmdNEZazXJ/ACfR46Zav7nOXBF9CZ4k4g3mr/Po\n1L3FXotxDQaTITY4xrse/GNCd92Q2Pc3ASS1SWRozpefyY414qfDP4x7IYwFOnK/\nswVjxFEyniiliYOiUV7tEm5FYRkAaQIAMiAXsZQB5LwatJN7WCQMh3xfPiuW91wL\nQmq47Rku8zPVsmQ5oBF9Ip4RraLOapoL09abmhyS9CFiT+bqZYSa9erT81eZnEfY\np07CH3yZBVSw7nRTIS8ScDHRvTt+FzrcchVcPfXMfYeydosmgQdDFFy/fm2alb8B\nJKEHXc4KK04f6Fa90Uo+1hVInMziuLRWN6vubkHUDSXY4jhGm84OksTyW3AFKigC\njLwe8W9IMt765T5x5oux9MmPDXF05xHfm4qfH/BMO3a802x5u2gJjJjuknrFdgXY\n9Q==\n-----END CERTIFICATE-----`;\n      const key = await KeyUtil.parse(pem);\n      expect(key.emails.length).to.equal(1);\n      expect(key.emails[0]).to.equal('email@embedded.in.subj.alt.name');\n      t.pass();\n    });\n\n    const smimeAndPgp = testConstants.smimeCert + '\\r\\n' + expiredPgp;\n\n    ava.default('[unit][KeyUtil.readMany] Parsing one S/MIME and one OpenPGP armored keys', async t => {\n      const { keys, errs } = await KeyUtil.readMany(Buf.fromUtfStr(smimeAndPgp));\n      expect(keys.length).to.equal(2);\n      expect(errs.length).to.equal(0);\n      expect(keys.some(key => key.id === '16BB407403A3ADC55E1E0E4AF93EEC8FB187C923')).to.equal(true);\n      expect(keys.some(key => key.id === '3449178FCAAF758E24CB68BE62CB4E6F9ECA6FA1')).to.equal(true);\n      expect(keys.some(key => key.type === 'openpgp')).to.equal(true);\n      expect(keys.some(key => key.type === 'x509')).to.equal(true);\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.parse] key was never usable', async t => {\n      const expiredPubKey = '-----BEGIN PGP PUBLIC KEY BLOCK-----\\r\\nVersion: FlowCrypt Email Encryption 7.8.4\\r\\nComment: Seamlessly send and receive encrypted email\\r\\n\\r\\nxsBNBF8QF1cBCADFQRM0S6kJ1LxL+Y2hqz+w2PIbAKnNpV4gr1D0jEX9ygMY\\r\\nYxyjGP7QcK2umeBrioWBUET/5yu+KkSVFOxGwXw2m1MqJXZH6fPumgDBEAYg\\r\\n8afLXI/5Rh7Lp2Z3eBDog6W0I9EOHAB6iFHQgc5m+PUlehMZ23VUKxDpb4kW\\r\\nsIts1b8Zm0sSimUf15bz0nGxCf00bYf5lCuxBfgAQGK+FgpIAdc03a7VI4zJ\\r\\nc/A18PR4mlMeDfIj2yWKaL4ka8lr8d+qAP2Cu0I6GcNgBUl5yCWc/6S20J52\\r\\nKjoa48w1vdAYzK1hjTE7INLrB6WKOCPLoY0jRuqE+ksarw6JtNsAhNrFABEB\\r\\nAAHNKTxoYXMub2xkZXIua2V5Lm9uLmF0dGVzdGVyQHJlY2lwaWVudC5jb20+\\r\\nwsCTBBABCAAmBQJfEBpQBQkAAAACBgsJBwgDAgQVCAoCBBYCAQACGQECGwMC\\r\\nHgEAIQkQ0CoIfv1WLLMWIQQoKZEjISHFGWNfjmPQKgh+/VYss4EFB/9apXb/\\r\\nRYrf/FwK3NEeAuVAjq4sQFOC+e2sOO1Y1i74Hm5Q3YpL5FPWxg1zzQR3cKlw\\r\\ngwGiTBH9Re86KuB6XIIhropA94c0c5RGXf4Syb66hsp+xyb5laoazW274M26\\r\\nLhNou77CFgJ4UTOYPqNoDADcGPCoYzlU/tkp8q+vuIEBuizNkO+vOdFdrG9x\\r\\nON2n7aPVBWTHTy7PXVQr6wYfbj2c3cmH9ju5bZKoKoZ7niR3jQi+NUAHf09Z\\r\\nkwWGoYwD37iTtPWrn/nnMqp7nqJxpChsJvtfousgKHWUA1IsCXoSeExZuXYU\\r\\nVpJduSYQx5H6dy4QwmK8bzRfra/l5O6sRTbNzsBNBF8QF1cBCADL0rwgqVw3\\r\\nsQ6JD7j9eOkbcc0iNrxLqYWnBCu71opLWVQ0b8mw9DqT3WuXtvOVmEBkqDig\\r\\nq9Q78BbD2EfQhFNuvcE5GL38BvyUkpgZBC+vi9UrisQTStmLS5bSsT7aipwM\\r\\nGy3tXFIoHX8XQk8swbKa20fCYd5KKZr3wFBZ6mtXN3O1qgelZ4HEl/bCFz6c\\r\\nuvZUFLvLaMksXh7um2/bjnB6E9uktn/ts34rbYIuHxVTLs6bq4VbPiUilurz\\r\\n8uzAsU2HMw2QTQTaJzycJyYzdDxAIXrSmtFah2/wqSYC82r65sA17y3gtbHq\\r\\neP0pzbzbMQitPCV2poxIHJuiMYh4iWV9ABEBAAHCwHwEGAEIAA8FAl8QGlAF\\r\\nCQAAAAICGwwAIQkQ0CoIfv1WLLMWIQQoKZEjISHFGWNfjmPQKgh+/VYsswOo\\r\\nCAC2gkz5f7RLboxFxgbjleY/SWttf9j5pJGCfcaPzLGo8wCbnEUdhs+FqAml\\r\\nGDF1yZAexCQLBukVhil1yEnknaX1emeHB7d4g6cQFoKtSHeVZ0C9mmM+OJMn\\r\\nZoGVylTsOLMmVXM/CXyp9JUAlo/oZm1Zpb9RK5rvNJukH1f0DajQjWlC09Y9\\r\\nVLVDBxlJccsEdas1yojMDHMqNOMiNaAlA33mrY3ucAiKb4q3uP9IuDRuD83M\\r\\ncoDahY5p8xl6IbKQhnxoWtBgGJWrlwBZro83z9HzW4LmP99pPZqfLZQAevUL\\r\\n+oQiPqyh512p6O5usc1GkEoN9cn9b/qnvnRu5RMxC/vI\\r\\n=NveA\\r\\n-----END PGP PUBLIC KEY BLOCK-----\\r\\n';\n      const parsed = await KeyUtil.parse(expiredPubKey);\n      expect(parsed?.usableForEncryption).to.equal(false);\n      expect(parsed?.expiration).to.equal(1594890073000);\n      expect(parsed?.usableForEncryptionButExpired).to.equal(false); // because last signature was created as already expired, no intersection\n      t.pass();\n    });\n\n    ava.default('[unit][MsgUtil.decryptMessage] extracts Primary User ID from key', async t => {\n      const data = await GoogleData.withInitializedData('ci.tests.gmail@flowcrypt.test');\n      const msg: GmailMsg = data.getMessage('1766644f13510f58')!;\n      const enc = Buf.fromBase64Str(msg!.raw!).toUtfStr()\n        .match(/\\-\\-\\-\\-\\-BEGIN PGP SIGNED MESSAGE\\-\\-\\-\\-\\-.*\\-\\-\\-\\-\\-END PGP SIGNATURE\\-\\-\\-\\-\\-/s)![0];\n      const encryptedData = Buf.fromUtfStr(enc);\n      const pubkey = await KeyUtil.parse(testConstants.pubkey2864E326A5BE488A);\n      await ContactStore.update(undefined, 'president@forged.com', { name: 'President', pubkey });\n      const decrypted = await MsgUtil.decryptMessage({ kisWithPp: [], encryptedData });\n      expect(decrypted.success).to.equal(true);\n      const verifyRes = (decrypted as DecryptSuccess).signature!;\n      expect(verifyRes.match).to.be.true;\n      expect(verifyRes.signer?.primaryUserId).to.equal('A50 Sam <sams50sams50sept@gmail.com>');\n      t.pass();\n    });\n\n    ava.default('[unit][MsgUtil.verifyDetached] verifies Thunderbird html signed message', async t => {\n      const data = await GoogleData.withInitializedData('flowcrypt.compatibility@gmail.com');\n      const msg: GmailMsg = data.getMessage('1754cfd1b2f1d6e5')!;\n      const msgText = Buf.fromBase64Str(msg!.raw!).toUtfStr();\n      const sigText = msgText\n        .match(/\\-\\-\\-\\-\\-BEGIN PGP SIGNATURE\\-\\-\\-\\-\\-.*\\-\\-\\-\\-\\-END PGP SIGNATURE\\-\\-\\-\\-\\-/s)![0]\n        .replace(/=\\r\\n/g, '').replace(/=3D/g, '=');\n      const plaintext = msgText\n        .match(/Content\\-Type: multipart\\/mixed; boundary=\"vv8xtFOOk2SxbnIpwvxkobfET7PglPfc3\".*\\-\\-vv8xtFOOk2SxbnIpwvxkobfET7PglPfc3\\-\\-\\r?\\n/s)![0]\n        .replace(/\\r?\\n/g, '\\r\\n')!;\n      const pubkey = plaintext\n        .match(/\\-\\-\\-\\-\\-BEGIN PGP PUBLIC KEY BLOCK\\-\\-\\-\\-\\-.*\\-\\-\\-\\-\\-END PGP PUBLIC KEY BLOCK\\-\\-\\-\\-\\-/s)![0]\n        .replace(/=\\r\\n/g, '').replace(/=3D/g, '=');\n      const from = GmailParser.findHeader(msg, \"from\");\n      const contact = await ContactStore.obj({ email: from, pubkey });\n      await ContactStore.save(undefined, contact);\n      const result = await MsgUtil.verifyDetached({ plaintext: Buf.fromUtfStr(plaintext), sigText: Buf.fromUtfStr(sigText) });\n      expect(result.match).to.be.true;\n      t.pass();\n    });\n\n    ava.default('[unit][MsgUtil.verifyDetached] verifies Thunderbird text signed message', async t => {\n      const data = await GoogleData.withInitializedData('flowcrypt.compatibility@gmail.com');\n      const msg: GmailMsg = data.getMessage('1754cfc37886899e')!;\n      const msgText = Buf.fromBase64Str(msg!.raw!).toUtfStr();\n      const sigText = msgText\n        .match(/\\-\\-\\-\\-\\-BEGIN PGP SIGNATURE\\-\\-\\-\\-\\-.*\\-\\-\\-\\-\\-END PGP SIGNATURE\\-\\-\\-\\-\\-/s)![0]\n        .replace(/=\\r\\n/g, '').replace(/=3D/g, '=');\n      const plaintext = msgText\n        .match(/Content\\-Type: multipart\\/mixed; boundary=\"XWwnusC4nxhk2LRvLCC6Skcb8YiKQ4Lu0\".*\\-\\-XWwnusC4nxhk2LRvLCC6Skcb8YiKQ4Lu0\\-\\-\\r?\\n/s)![0]\n        .replace(/\\r?\\n/g, '\\r\\n')!;\n      const pubkey = plaintext\n        .match(/\\-\\-\\-\\-\\-BEGIN PGP PUBLIC KEY BLOCK\\-\\-\\-\\-\\-.*\\-\\-\\-\\-\\-END PGP PUBLIC KEY BLOCK\\-\\-\\-\\-\\-/s)![0]\n        .replace(/=\\r\\n/g, '').replace(/=3D/g, '=');\n      const from = GmailParser.findHeader(msg, \"from\");\n      const contact = await ContactStore.obj({ email: from, pubkey });\n      await ContactStore.save(undefined, contact);\n      const result = await MsgUtil.verifyDetached({ plaintext: Buf.fromUtfStr(plaintext), sigText: Buf.fromUtfStr(sigText) });\n      expect(result.match).to.be.true;\n      t.pass();\n    });\n\n    ava.default('[unit][MsgUtil.verifyDetached] verifies Firefox rich text signed message', async t => {\n      const data = await GoogleData.withInitializedData('flowcrypt.compatibility@gmail.com');\n      const msg: GmailMsg = data.getMessage('175ccd8755eab85f')!;\n      const msgText = Buf.fromBase64Str(msg!.raw!).toUtfStr();\n      const sigBase64 = msgText\n        .match(/Content\\-Type: application\\/pgp\\-signature;.*\\r\\n\\r\\n(.*)\\r\\n\\-\\-/s)![1];\n      const sigText = Buf.fromBase64Str(sigBase64);\n      const plaintext = msgText\n        .match(/Content\\-Type: multipart\\/mixed;\\r?\\n? boundary=\"\\-\\-\\-\\-sinikael\\-\\?=_2\\-16054595384320\\.6487848448108896\".*\\-\\-\\-\\-\\-\\-sinikael\\-\\?=_2\\-16054595384320\\.6487848448108896\\-\\-\\r?\\n/s)![0]\n        .replace(/\\r?\\n/g, '\\r\\n')!;\n      if ((await ContactStore.get(undefined, ['7FDE685548AEA788'])).length === 0) {\n        const contact = await ContactStore.obj({\n          email: 'flowcrypt.compatibility@gmail.com',\n          pubkey: testConstants.flowcryptcompatibilityPublicKey7FDE685548AEA788\n        });\n        await ContactStore.save(undefined, contact);\n      }\n      const result = await MsgUtil.verifyDetached({ plaintext: Buf.fromUtfStr(plaintext), sigText });\n      expect(result.match).to.be.true;\n      t.pass();\n    });\n\n    ava.default('[unit][MsgUtil.getSortedKeys,matchingKeyids] must be able to find matching keys', async t => {\n      const passphrase = 'some pass for testing';\n      const key1 = await OpenPGPKey.create([{ name: 'Key1', email: 'key1@test.com' }], 'curve25519', passphrase, 0);\n      const key2 = await OpenPGPKey.create([{ name: 'Key2', email: 'key2@test.com' }], 'curve25519', passphrase, 0);\n      const pub1 = await KeyUtil.parse(key1.public);\n      const pub2 = await KeyUtil.parse(key2.public);\n      // only encrypt with pub1\n      const { data } = await MsgUtil.encryptMessage({ pubkeys: [pub1], data: Buf.fromUtfStr('anything'), armor: true }) as PgpMsgMethod.EncryptPgpArmorResult;\n      const m = await opgp.message.readArmored(Buf.fromUint8(data).toUtfStr());\n      const parsed1 = await KeyUtil.parse(key1.private);\n      const parsed2 = await KeyUtil.parse(key2.private);\n      const kisWithPp: ExtendedKeyInfo[] = [ // supply both key1 and key2 for decrypt\n        { ... await KeyUtil.keyInfoObj(parsed1), type: parsed1.type, passphrase },\n        { ... await KeyUtil.keyInfoObj(parsed2), type: parsed2.type, passphrase },\n      ];\n      // we are testing a private method here because the outcome of this method is not directly testable from the\n      //   public method that uses it. It only makes the public method faster, which is hard to test.\n      // @ts-ignore - accessing private method\n      const sortedKeys = await MsgUtil.getSortedKeys(kisWithPp, m);\n      // point is that only one of the private keys should be used for decrypting, not two\n      expect(sortedKeys.prvMatching.length).to.equal(1);\n      expect(sortedKeys.signedBy.length).to.equal(0);\n      expect(sortedKeys.encryptedFor.length).to.equal(1);\n      expect(sortedKeys.prvForDecrypt.length).to.equal(1);\n      expect(sortedKeys.prvForDecryptDecrypted.length).to.equal(1);\n      // specifically the pub1\n      expect(sortedKeys.prvForDecryptDecrypted[0].ki.longid).to.equal(OpenPGPKey.fingerprintToLongid(pub1.id));\n      // also test MsgUtil.matchingKeyids\n      // @ts-ignore\n      const matching1 = MsgUtil.matchingKeyids(KeyUtil.getPubkeyLongids(pub1), m.getEncryptionKeyIds());\n      expect(matching1.length).to.equal(1);\n      // @ts-ignore\n      const matching2 = MsgUtil.matchingKeyids(KeyUtil.getPubkeyLongids(pub2), m.getEncryptionKeyIds());\n      expect(matching2.length).to.equal(0);\n      t.pass();\n    });\n\n    ava.default('[OpenPGPKey.fingerprintToLongid] only works for pgp', async t => {\n      // shorten pgp fingerprint to become longid\n      expect(OpenPGPKey.fingerprintToLongid('3449178FCAAF758E24CB68BE62CB4E6F9ECA6FA1')).to.equal('62CB4E6F9ECA6FA1');\n      // throw on s/mime id\n      expect(() => OpenPGPKey.fingerprintToLongid('63F7025E700F3945301FB2FBA5674F84')).\n        to.throw('Unexpected fingerprint format (len: 32): \"63F7025E700F3945301FB2FBA5674F84\"');\n      // throw on broken format\n      expect(() => OpenPGPKey.fingerprintToLongid('aaxx')).to.throw('Unexpected fingerprint format (len: 4): \"aaxx\"');\n      t.pass();\n    });\n\n    ava.default('[Attachment.sanitizeName] for special and unicode characters', async t => {\n      // slash\n      expect(Attachment.sanitizeName('abc/def')).to.equal('abc_def');\n      // backslash\n      expect(Attachment.sanitizeName('abc\\\\def')).to.equal('abc_def');\n      // combinations of slashes and backslashes\n      expect(Attachment.sanitizeName('abc\\\\/def')).to.equal('abc_def');\n      expect(Attachment.sanitizeName('abc/\\\\def')).to.equal('abc_def');\n      // trimming\n      expect(Attachment.sanitizeName('  1  ')).to.equal('1');\n      expect(Attachment.sanitizeName('    ')).to.equal('_');\n      // empty\n      expect(Attachment.sanitizeName('')).to.equal('_');\n      // cyrillic\n      const cyrillicName = '\\u0410\\u0411\\u0412';\n      expect(Attachment.sanitizeName(cyrillicName)).to.equal(cyrillicName);\n      t.pass();\n    });\n\n    // public key that allows to encrypt for primary key - to simulate a bug in other implementation that wrongly encrypts for primary when it shouldn't\n    // sec  rsa2048/F90C76AE611AFDEE\n    //      created: 2020-10-15  expires: never       usage: SCE\n    //      trust: ultimate      validity: ultimate\n    // ssb  rsa2048/4BA880ECE71397FC\n    //      created: 2020-10-15  expires: never       usage: E\n    const pubEncryptForPrimaryIsFine = `-----BEGIN PGP PUBLIC KEY BLOCK-----\\n\\nmQENBF+IL20BCACTJLnno0xB29YeNP9xV4bdkEE0zSo/UoFzRKpUupG+0El17oDw\\nQDUeW2YjZwLxMJVlRyo+eongpFYFbC+d5cwiHE/YP6uQPmniiEpa3ICZw87Jk/R2\\n5dTAVk9QuAlvkI1lWA0+1SDTFxuWD1LTEjcSS6so8pr2VOF6xFu5QKCkbX0/aQe5\\npoHryZ/RkUW4d+B3aTC56RnXSAfeegwn1VDF+J+t0jZ0rMzKs2IaDgqX5HzBqOOI\\nlIrr43ROHmceuTMZp19aoLYhFNn1lseyug/YQm4b6Hf6VVypNNUFdgbK8xrxowOq\\nb2cgSajgcZVMkTF5IQuyS/IIlobJGZeqZ33nABEBAAG0aVRlc3QgS2V5IFdoZW4g\\nTWVzc2FnZSBXcm9uZ2x5IGVuY3J5cHRlZCBmb3IgUHJpbWFyeSBLZXkgPHRlc3Qu\\nZmlsZS5lbmNyeXB0ZWQuZm9yLnByaW1hcnkua2V5QGV4YW1wbGUuY29tPokBTgQT\\nAQoAOAULCQgHAgYVCgkICwIEFgIDAQIeAQIXgBYhBL+zmJKJcURh2km3GfkMdq5h\\nGv3uBQJfjVbfAhsPAAoJEPkMdq5hGv3uqCEH/3gbq7JwKQf0NV0muZysc0aNt000\\nG3NtZkuYi83l8JMwlDq50lOMgL7gCngTB9ed822d27ClMsj8eP9XuKtw6e7gpvMc\\njMF2rACiQKYuZ0iVUK23Zi0fb17zN0BJ0gJ9BpEv5MjaYJ1G4QZDOKG23a/hVUUv\\nfRmwbBynSFMgVWQJHGQ9KcY2Jt8M3sLcxpuPO3QLWGivitbZDB2QrL/fALRQpc1Y\\nnNkgdUxpZE5dkos01IR5GjZeSmrYpP7UaHa/O3lCdLiskjtCNwWcTr1yJZdzmbZ4\\npw6Hu+kEIiYgmwPNodJpRYxZ8rR6ChJ4q1SE6J3iJ4SlGVdU0TM4L5nuJxy5AQ0E\\nX4gvbQEIANUO63F2tdT4zOt8gP2XBZwo8fbI59AEEgBaq7o3sluujAak3mK71LyT\\n4S4gvJLyGlAU9TV4JQxRuky6oCcyA1D6PNCYGiR6OJbmmzosrh34bYkfz3xjDu/d\\nNAKPDCJz2arcVuVbE5onjQd9afjaZh+4pVKs3lKn1UdBXIrei2LC98CemRWxUwfH\\nG0LswvnIg24ByvFBvOzBiB7m9340ComMnKGRpeze8uEubYNNQDexL2zCo2itUFKB\\nuPkQbCN7jXg/vnNLk2GXFlUYt20puEH4iyaJ/QFIZzzeqFRQWvI63JJ7zQZIGeok\\nS/0MLq1udNYxUqk014TEso0jvC1evX0AEQEAAYkBNgQYAQoAIBYhBL+zmJKJcURh\\n2km3GfkMdq5hGv3uBQJfiC9tAhsMAAoJEPkMdq5hGv3usZ4H/1N12NiLOVwQ3Zeq\\nVxUocwC/UjZX6JlAPg0h1Spx0RGdNuu4WMLnlF/1yzK+LE84WFYkvXXIzNi1LIyX\\nPh3YCPGFEec82MkLQFkLm7sjE4Xc3APYZJK2s5LSjyloZkprb7sbVjdWoBwAPClv\\nQsgAlHBeCrlWcLo7fzZdxmpvmJFHd/J7ajKsMCn5f9DXFCoCNdrv+s5Qf4jo6KaE\\nhZrQ75+T52Iq9R5Z2gS5G4jY3eW+iK2/xW5Q0x0UeoJG7u8WR56LSl0jS9lufuOS\\nyFkO3XIWLzDfz51EVy7ApK33D3GQTfOQ8tJEqW2p17rQTcXuhmg4Dgcf1b0dyVac\\n7jV1Tgs=\\n=4gfr\\n-----END PGP PUBLIC KEY BLOCK-----\\n`;\n    // a normal keypair\n    // sec  rsa2048/F90C76AE611AFDEE\n    //      created: 2020-10-15  expires: never       usage: SC\n    //      trust: ultimate      validity: ultimate\n    // ssb  rsa2048/4BA880ECE71397FC\n    //      created: 2020-10-15  expires: never       usage: E\n    const prvEncryptForSubkeyOnly = `-----BEGIN PGP PRIVATE KEY BLOCK-----\\n\\n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\\n1b0dyVac7jV1Tgs=\\n=4Jfy\\n-----END PGP PRIVATE KEY BLOCK-----\\n`;\n\n    ava.default('[MsgUtil.encryptMessage] do not decrypt message when encrypted for key not meant for encryption', async t => {\n      const data = Buf.fromUtfStr('hello');\n      const passphrase = 'pass phrase';\n      const tmpPrv = await KeyUtil.parse(prvEncryptForSubkeyOnly);\n      await KeyUtil.encrypt(tmpPrv, passphrase);\n      expect(tmpPrv.fullyEncrypted).to.equal(true);\n      const prvEncryptForSubkeyOnlyProtected = KeyUtil.armor(tmpPrv);\n      const { keys: [tmpPub] } = await opgp.key.readArmored(pubEncryptForPrimaryIsFine);\n      tmpPub.subKeys = [];\n      // removed subkey from the pubkey, which makes the structure into this - forcing opgp to encrypt for the primary\n      // sec  rsa2048/F90C76AE611AFDEE\n      //      created: 2020-10-15  expires: never       usage: SCE\n      //      trust: ultimate      validity: ultimate\n      const justPrimaryPub = tmpPub.armor();\n      const pubkeys = [await KeyUtil.parse(justPrimaryPub)];\n      const encrypted = await MsgUtil.encryptMessage({ pubkeys, data, armor: true }) as PgpMsgMethod.EncryptPgpArmorResult;\n      const parsed = await KeyUtil.parse(prvEncryptForSubkeyOnlyProtected);\n      const kisWithPp: ExtendedKeyInfo[] = [{ ... await KeyUtil.keyInfoObj(parsed), type: parsed.type, passphrase }];\n      const decrypted = await MsgUtil.decryptMessage({ kisWithPp, encryptedData: encrypted.data });\n      // todo - later we'll have an org rule for ignoring this, and then it will be expected to pass as follows:\n      // expect(decrypted.success).to.equal(true);\n      // expect(decrypted.content!.toUtfStr()).to.equal(data.toUtfStr());\n      expect(decrypted.success).to.equal(false);\n      expect((decrypted as DecryptError).error.type).to.equal('key_mismatch');\n      t.pass();\n    });\n\n    ava.default('[KeyUtil.diagnose] displays PK and SK usage', async t => {\n      const usageRegex = /\\[\\-\\] \\[(.*)\\]/;\n      const result1 = await KeyUtil.diagnose(await KeyUtil.parse(pubEncryptForPrimaryIsFine), '');\n      {\n        const pk0UsageStr = result1.get('Usage flags')!;\n        const sk0UsageStr = result1.get('SK 0 > Usage flags')!;\n        const pk0Usage = pk0UsageStr.match(usageRegex)![1].split(', ');\n        expect(pk0Usage).to.include('certify_keys');\n        expect(pk0Usage).to.include('sign_data');\n        expect(pk0Usage).to.include('encrypt_storage');\n        expect(pk0Usage).to.include('encrypt_communication');\n        const sk0Usage = sk0UsageStr.match(usageRegex)![1].split(', ');\n        expect(sk0Usage).to.not.include('certify_keys');\n        expect(sk0Usage).to.not.include('sign_data');\n        expect(sk0Usage).to.include('encrypt_storage');\n        expect(sk0Usage).to.include('encrypt_communication');\n      }\n      const result2 = await KeyUtil.diagnose(await KeyUtil.parse(prvEncryptForSubkeyOnly), '');\n      {\n        const pk0UsageStr = result2.get('Usage flags')!;\n        const sk0UsageStr = result2.get('SK 0 > Usage flags')!;\n        const pk0Usage = pk0UsageStr.match(usageRegex)![1].split(', ');\n        expect(pk0Usage).to.include('certify_keys');\n        expect(pk0Usage).to.include('sign_data');\n        expect(pk0Usage).to.not.include('encrypt_storage');\n        expect(pk0Usage).to.not.include('encrypt_communication');\n        const sk0Usage = sk0UsageStr.match(usageRegex)![1].split(', ');\n        expect(sk0Usage).to.not.include('certify_keys');\n        expect(sk0Usage).to.not.include('sign_data');\n        expect(sk0Usage).to.include('encrypt_storage');\n        expect(sk0Usage).to.include('encrypt_communication');\n      }\n      t.pass();\n    });\n\n    const dsaPrimaryKeyAndSubkeyBothHavePrivateKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nlQOBBF/BQGwRCACcZ4K6ArbIZATaPPBPOywi2KpCIv5HRTlxncS+xpc3YsrzBasM\nrJW13zbmW6HlO1ZBEeF8fUfCkPneZRSgNgSSGPj6+9DlcGZ4jNGe5Nk8TSs8S3WW\nleZqUE7XbbA6RbzT5MkPAB5Wn58o6d4J1KBBZLX369WD06B/sWa4iw1cMDGSEN3Y\nXEbA5VPD3vmskVtqVDmZvXYQWddfd6dmWbPkCwkc/c8ENw3FmRBOvgH7poPSieSp\n78/I6QNn1mhY4AOvkpPFVbvUsafp6/KX2zccOEh80Xrg6VIVuvCyVnnjuXo8/QaE\nFpfyXIfG2U9eXGjJKq8faSWJvXeQ5qGjc+ybAQDlCb3xSSVc511tzPowYwR+lmFu\nc5hb3CIzcD/l9Q5gZQgAjoHb81VB3whJhiehjO9wzRgE+wvfKwSVkp222FSXbRnf\n3jW3U+RmtdTev4/h+G0ZsLQxn5JTsjYUHkKpBIQ/tlgfzkLr9AsV4bzDP+xa3YQ+\nAYOeXL/bskSlxmDzQFTZtotSDBQ1W8cU/c8IvuuV1N7Qgg2nhe8spPXjkZpoxJ1S\nHPKPdvU0VeurMf1WRiXAtMx6cCTkMyHn1IHM6ZvchU7N4g2emCkj0bBt2G9FMabE\niyWKXuhO7M8H8f0/zkpZOubLcnTIFj+MdO45tKcd56mT2CBnfslR3M6SIO04jggF\n1yKTtzWF1hdAtIL0jEBt70/STYM1MBHXvItoFz2iXQf9ECJ2oJPGcfajaIN15ArX\nOTRlJTsYTMCtLDnJrKQNo/3Y2zPfcu/yJDkOdurnt26UNT8BvmlUhOV1jvTwDX7h\nKxl7TtZuRC7n5Qsd6MRl5G2w4I38/shx2abfJLSozWsh3M9nI4ZCkCQKBm+HZVN3\nEy5JjfRGFoYDIR6/PW5sTJ3WRH5Pu/qYv8eN20XXj9o3a8pALxIbom712oZnZ9sE\nciphM16eeNE+peGPGGK2s6cBCUMLZ7+NjsB7b7hCJmJyQ5KjWgGDCLREP58HRIyU\nH9jLR3NssIz/sEvx6BbNvS+BeIeQI3JxRdeJWKCuVTZ/TUSKvqadoJtm+8iWTcI5\n0P4HAwLcId661kE5p8XRQEp9fGBWlfSlfwhTHFk4i4EU6+s2rU428Egb+DWGE4g0\n5T+nWHg+jZRA1m/ItwZRjwwdS5mqZOlL3/0J/eh4cX5eH3xItD1EU0Egbm9uLWV4\ncGlyaW5nIFRlc3QgPGZsb3djcnlwdC50ZXN0LmtleS5pbXBvcnRlZEBnbWFpbC5j\nb20+iJAEExEIADgWIQRQC3RVBj0Fg3FTNPU5gmSNbovC5gUCX8FAbAIbAwULCQgH\nAgYVCgkICwIEFgIDAQIeAQIXgAAKCRA5gmSNbovC5gxxAQCCgjGMFhbW3MD1JlZu\nBykExD2HKhD3hWL0QbOgxTWhZwEArBpptZ1nMJ81BHU0mDouAycU2p+e0gu89EaN\n4eE8P8SdAmoEX8FAbBAIAJCDHSmnfqVP2gJnpVf+fznLstwYTAPmuiTneBufVSwD\nUzd3ADyQpI9e9Um0q4x0SgydyocLh0riy2UBsAoaA5f8wBWlbmKbMbMnfGqrxkWW\nJlYQyiETNLJ4ZCI+CkS5twz0Y29Df9SQ16DBLSc0hiIuFeicWTlwzfu2aSoflrIN\nJOsu2E0lpPZm8FQTpoOOpLDo9cn7UxK16MpEy65SzBwDq8aNEzGJLNSZzxzTDi7+\nFmMThANleMwooO7IJh/iuFLksJvRbsUxnp72w8/8yuco8xnqLVlw+YdveUrF1+JM\nhjCyHQSoFKFX9AooBfVtQOyv3gFe/SG2aFI/w8Jd4CcAAwUH/iUaTDJwYi5zN1hy\nuJpWTOTfvp3QL0kRYuhzq92/npjDv1QtuFqWHfFqfXp3YVOnpke86Fd7zqT/ybo2\nZpaDX3D9DOhpvRbFIggBz3jXmQyQFJnk1I1TZqxpdBcJry3m9C6xc8yG7bOjVLCV\nXq+rGKU3S2YeWigLuIimgNsvk0HvfyxkWjOeuu3kDFzgNot5nAkxBUiqIzszQjPS\nu3SAOiF9NMbU7VJcd66OTb5k3a6qfiyGVzznwltRmyNweNHaYYYAIQZBCN3OQu9t\n4igpCDgIh+egNZOTj7/08HFBwJVptNRIhs7ehG0k/H6wmJWwku3Ozp+eLGC/4P2s\nErZPT9X+BwMCMG9oyrTw077FyHlEcivdFLW40kDjBzFu8RFxKLISDjUDFY/SYSoU\nNXiz/0ZzdG7BuTb0fLuf8vW7Uo+8xXK5zlwmJz1seWnjaAeouCZKY+9f5nWIxp8H\nh3OIeAQYEQgAIBYhBFALdFUGPQWDcVM09TmCZI1ui8LmBQJfwUBsAhsMAAoJEDmC\nZI1ui8LmU2sA/RQXrsnhQhrDEFcZQ6CzGaQ1JYadhNxRjufMl5WVz22zAP9GlYs2\nJW/1mKoBRBfyKzP8ibuUyur7X6rryVL/dctxoA==\n=Pmsz\n-----END PGP PRIVATE KEY BLOCK-----`;\n\n    const rsaPrimaryKeyAndSubkeyBothHavePrivateKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\n=/3Ew\n-----END PGP PRIVATE KEY BLOCK-----`;\n\n    ava.default('[KeyUtil.diagnose] handles incorrect passphrase', async t => {\n      const result = await KeyUtil.diagnose(await KeyUtil.parse(rsaPrimaryKeyAndSubkeyBothHavePrivateKey), '4321');\n      expect(result.get('Is Private?')).to.equal('[-] true');\n      expect(result.get('User id 0')).to.equal('Test1 (rsa) <flowcrypt.test.key.imported@gmail.com>');\n      expect(result.get('Primary User')).to.equal('Test1 (rsa) <flowcrypt.test.key.imported@gmail.com>');\n      expect(result.get('Fingerprint')).to.equal('6628 5F84 B985 71BD 01C0 18EE 8B3B B9CF C476 EE16');\n      expect(result.get('Subkeys')).to.equal('[-] 1');\n      expect(result.get('Primary key algo')).to.equal('[-] rsa_encrypt_sign');\n      expect(result.get('key decrypt')).to.equal('[-] false');\n      expect(result.get('isFullyDecrypted')).to.equal('[-] false');\n      expect(result.get('isFullyEncrypted')).to.equal('[-] true');\n      expect(result.get('Primary key verify')).to.equal('[-] valid');\n      expect(result.get('Primary key creation?')).to.equal('[-] 1606140328 or 2020-11-23T14:05:28.000Z');\n      expect(result.get('Primary key expiration?')).to.equal('[-] -');\n      expect(result.has('Encrypt/Decrypt test: Encryption with key was successful')).to.be.true;\n      expect(result.has('Encrypt/Decrypt test: Skipping decryption because isPrivate:true isFullyDecrypted:false')).to.be.true;\n      expect(result.get('Sign/Verify test')).to.equal('[-] skipped, not fully decrypted');\n      expect(result.get('SK 0 > LongId')).to.equal('[-] 0485D618EAA64B05');\n      expect(result.get('SK 0 > Created')).to.equal('[-] 1606140328 or 2020-11-23T14:05:28.000Z');\n      expect(result.get('SK 0 > Algo')).to.equal('[-] rsa_encrypt_sign');\n      expect(result.get('SK 0 > Verify')).to.equal('[-] OK');\n      expect(result.get('SK 0 > Subkey tag')).to.equal('[-] 7');\n      expect(result.get('SK 0 > Subkey getBitSize')).to.equal('[-] 3072');\n      expect(result.get('SK 0 > Subkey decrypted')).to.equal('[-] false');\n      expect(result.get('SK 0 > Binding signature length')).to.equal('[-] 1');\n      expect(result.get('SK 0 > SIG 0 > Key flags')).to.equal('[-] 12');\n      expect(result.get('SK 0 > SIG 0 > Tag')).to.equal('[-] 2');\n      expect(result.get('SK 0 > SIG 0 > Version')).to.equal('[-] 4');\n      expect(result.get('SK 0 > SIG 0 > Public key algorithm')).to.equal('[-] 1');\n      expect(result.get('SK 0 > SIG 0 > Sig creation time')).to.equal('[-] 1606140328 or 2020-11-23T14:05:28.000Z');\n      expect(result.get('SK 0 > SIG 0 > Sig expiration time')).to.equal('[-] -');\n      expect(result.get('SK 0 > SIG 0 > Verified')).to.equal('[-] true');\n      expect(result.get('expiration')).to.equal('[-] undefined');\n      expect(result.get('internal dateBeforeExpiration')).to.equal('[-] undefined');\n      expect(result.get('internal usableForEncryptionButExpired')).to.equal('[-] false');\n      expect(result.get('internal usableForSigningButExpired')).to.equal('[-] false');\n      t.pass();\n    });\n\n    ava.default('[KeyUtil.diagnose] decrypts and successfully tests PK sign and SK encrypt', async t => {\n      const result = await KeyUtil.diagnose(await KeyUtil.parse(rsaPrimaryKeyAndSubkeyBothHavePrivateKey), '1234');\n      expect(result.get('Is Private?')).to.equal('[-] true');\n      expect(result.get('User id 0')).to.equal('Test1 (rsa) <flowcrypt.test.key.imported@gmail.com>');\n      expect(result.get('Primary User')).to.equal('Test1 (rsa) <flowcrypt.test.key.imported@gmail.com>');\n      expect(result.get('Fingerprint')).to.equal('6628 5F84 B985 71BD 01C0 18EE 8B3B B9CF C476 EE16');\n      expect(result.get('Subkeys')).to.equal('[-] 1');\n      expect(result.get('Primary key algo')).to.equal('[-] rsa_encrypt_sign');\n      expect(result.get('key decrypt')).to.equal('[-] true');\n      expect(result.get('isFullyDecrypted')).to.equal('[-] true');\n      expect(result.get('isFullyEncrypted')).to.equal('[-] false');\n      expect(result.get('Primary key verify')).to.equal('[-] valid');\n      expect(result.get('Primary key creation?')).to.equal('[-] 1606140328 or 2020-11-23T14:05:28.000Z');\n      expect(result.get('Primary key expiration?')).to.equal('[-] -');\n      expect(result.has('Encrypt/Decrypt test: Encryption with key was successful')).to.be.true;\n      expect(result.has('Encrypt/Decrypt test: Decryption with key succeeded')).to.be.true;\n      expect(result.get('Sign/Verify test')).to.equal('[-] sign msg ok|verify ok');\n      expect(result.get('SK 0 > LongId')).to.equal('[-] 0485D618EAA64B05');\n      expect(result.get('SK 0 > Created')).to.equal('[-] 1606140328 or 2020-11-23T14:05:28.000Z');\n      expect(result.get('SK 0 > Algo')).to.equal('[-] rsa_encrypt_sign');\n      expect(result.get('SK 0 > Verify')).to.equal('[-] OK');\n      expect(result.get('SK 0 > Subkey tag')).to.equal('[-] 7');\n      expect(result.get('SK 0 > Subkey getBitSize')).to.equal('[-] 3072');\n      expect(result.get('SK 0 > Subkey decrypted')).to.equal('[-] true');\n      expect(result.get('SK 0 > Binding signature length')).to.equal('[-] 1');\n      expect(result.get('SK 0 > SIG 0 > Key flags')).to.equal('[-] 12');\n      expect(result.get('SK 0 > SIG 0 > Tag')).to.equal('[-] 2');\n      expect(result.get('SK 0 > SIG 0 > Version')).to.equal('[-] 4');\n      expect(result.get('SK 0 > SIG 0 > Public key algorithm')).to.equal('[-] 1');\n      expect(result.get('SK 0 > SIG 0 > Sig creation time')).to.equal('[-] 1606140328 or 2020-11-23T14:05:28.000Z');\n      expect(result.get('SK 0 > SIG 0 > Sig expiration time')).to.equal('[-] -');\n      expect(result.get('SK 0 > SIG 0 > Verified')).to.equal('[-] true');\n      expect(result.get('expiration')).to.equal('[-] undefined');\n      expect(result.get('internal dateBeforeExpiration')).to.equal('[-] undefined');\n      expect(result.get('internal usableForEncryptionButExpired')).to.equal('[-] false');\n      expect(result.get('internal usableForSigningButExpired')).to.equal('[-] false');\n      t.pass();\n    });\n\n    const dsaPrimaryKeyIsMissingPrivateKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\noA==\n=e6+m\n-----END PGP PRIVATE KEY BLOCK-----`;\n\n    const rsaPrimaryKeyIsMissingPrivateKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\n=OeNi\n-----END PGP PRIVATE KEY BLOCK-----`;\n\n    const dsaExpiredPubkeysOnly = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\n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\nh4nt\n=lETP\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n    const rsaExpiredPubkeysOnly = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQENBF+323wBCADulm2pzzTL0gY/fMbYNHgq72j6XvNic4WncU8WDxytfnPNKqFI\nfJcWXPq8QBQIK8pwBRm4vHu5q7fDpId+c8pdZ3kVG2JQvWEFO83q4YJGEWPnLYYY\n6le9vSXTWQ7la24aTAEHfH17BdMIGET/so+owRzkBpUl72JuSuarQJJl3ePmu2Iv\nKaD2xSc0G2wm++ywZa255PHC4VmZ0lQ2xlZdGZPEWfSDVTchpHvPLQe0vSI/Eg4Q\ntRQYlYfLCQuOmkrCV+jqAsbDMHTNF2yE//CnlPA8unjLNdmw6DVhO85F3TIWR5NI\n1LOvxEc9MDsWqMuMizzHnnSAnPdLo/sm/fHtABEBAAG0OFJTQSBleHBpcmVkIFRl\nc3QgPGZsb3djcnlwdC50ZXN0LmtleS5pbXBvcnRlZEBnbWFpbC5jb20+iQFUBBMB\nCAA+FiEEQUF/y80YjGYEme19zhZF0KSimP0FAl+323wCGwMFCQABUYAFCwkIBwIG\nFQoJCAsCBBYCAwECHgECF4AACgkQzhZF0KSimP1rGAgAw/GI6PbRstEBiZs9udv0\nGttgIU4KnZh9jkr77JWRIH/MGrg2mTXazNt6LdlzOYPUdqB9bYo6tZnLox4x6tQK\n8y9TOOXgGcqdiridnEmb2W4eDGN9bfbbDf2c702u+EpITEiSwOi/ResDSsnqFpHJ\nsPf4wRrcPpwuecruDaEzPMAyziamWboCgpOzczjod935rhGXsCTcR6BausslmkOW\npUGWtpHw0QZWaHCxt3uUL9gMNNpn5Xmb2Qas2sJQPpSm441fgY7UUig7IoEp5tsp\nQZYG85PeUSV8387h3HUjwRsePxcyAZlkAlexC6Hj9w8LrTLMEQsyoFY2D/dSRSCx\ne7kBDQRft9t8AQgAwZUUmA8/e18vMWWiaNDhDro7g5XaETe/bCJfxBwmOtig8oin\nghJuDxejzK4B63VoQ3c4VDdl0rQb3utjS1bBZz0piJadtDAefbGIJL5yp6QT2bq7\nDCDWuNssrmbBe3SksgqGSehY5SPQD6juKtbPdeD17QsfuBolsh1yQgqW0S5tbB5i\nYUCrIJupbdKITR6dtgSOcDntIrktPk26iAq/9PdVQ218dM79SPgxzUugEsyTlUJe\n7CFrkNLrIVuHRAycHGZniIAnw0MWZBtTPY3XYkVyt2TXrE97A854HLP1lvhL0/py\nq/bfBXvrFONdlep03ZKNraY6BdrCnaSxHPI53QARAQABiQE8BBgBCAAmFiEEQUF/\ny80YjGYEme19zhZF0KSimP0FAl+323wCGwwFCQABUYAACgkQzhZF0KSimP0btQgA\nqH4mtWTOtanrs3zS+ORrZzlZacydNfX7BFqbrWBNx3Qn4ZUMYzroyXXrBKU2a0Ek\nWtn6JZO+3KF7NLjDKbPTP9oKA0RnBCxcEqd+Zt28+3g413RVOg/3GZ6cwctpmZId\nPzBbLiMWVh9yhWNXKhwCNcjRNRiEp5eMsMo7xrvIMwT1dZWo3B1SU8ojcadRAQpB\njzIGNwXIlC7ENE5V8LyvJmFlI3Y54EiylEkXbycrAtaCtcOc8VI97dcej0A5vx+B\nsGZik43btY7ooSmvfw154LBqk6j9bps8KS++T3ng2m62kWFelbR8ybjJmFkeDIdM\n31rxxiAYCGthro8UvpKojA==\n=AZcU\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n    const dsaExpiredPrimaryKeyIsMissingPrivateKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\nqWT+qXqeh4nt\n=/Vbx\n-----END PGP PRIVATE KEY BLOCK-----`;\n\n    const rsaExpiredPrimaryKeyIsMissingPrivateKey = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n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\njA==\n=lAqt\n-----END PGP PRIVATE KEY BLOCK-----`;\n\n    ava.default('[KeyUtil.diagnose] decrypts and tests PK missing private key and SK with private key', async t => {\n      const result = await KeyUtil.diagnose(await KeyUtil.parse(rsaPrimaryKeyIsMissingPrivateKey), '1234');\n      expect(result.get('Is Private?')).to.equal('[-] true');\n      expect(result.get('User id 0')).to.equal('Test1 (rsa) <flowcrypt.test.key.imported@gmail.com>');\n      expect(result.get('Primary User')).to.equal('Test1 (rsa) <flowcrypt.test.key.imported@gmail.com>');\n      expect(result.get('Fingerprint')).to.equal('6628 5F84 B985 71BD 01C0 18EE 8B3B B9CF C476 EE16');\n      expect(result.get('Subkeys')).to.equal('[-] 1');\n      expect(result.get('Primary key algo')).to.equal('[-] rsa_encrypt_sign');\n      expect(result.get('key decrypt')).to.equal('[-] true');\n      expect(result.get('isFullyDecrypted')).to.equal('[-] true');\n      expect(result.get('isFullyEncrypted')).to.equal('[-] false');\n      expect(result.get('Primary key verify')).to.equal('[-] valid');\n      expect(result.get('Primary key creation?')).to.equal('[-] 1606140328 or 2020-11-23T14:05:28.000Z');\n      expect(result.get('Primary key expiration?')).to.equal('[-] -');\n      expect(result.has('Encrypt/Decrypt test: Encryption with key was successful')).to.be.true;\n      expect(result.has('Encrypt/Decrypt test: Decryption with key succeeded')).to.be.true;\n      expect(result.get('Sign/Verify test')).to.equal('[-] Exception: Error: Missing private key parameters');\n      expect(result.get('SK 0 > LongId')).to.equal('[-] 0485D618EAA64B05');\n      expect(result.get('SK 0 > Created')).to.equal('[-] 1606140328 or 2020-11-23T14:05:28.000Z');\n      expect(result.get('SK 0 > Algo')).to.equal('[-] rsa_encrypt_sign');\n      expect(result.get('SK 0 > Verify')).to.equal('[-] OK');\n      expect(result.get('SK 0 > Subkey tag')).to.equal('[-] 7');\n      expect(result.get('SK 0 > Subkey getBitSize')).to.equal('[-] 3072');\n      expect(result.get('SK 0 > Subkey decrypted')).to.equal('[-] true');\n      expect(result.get('SK 0 > Binding signature length')).to.equal('[-] 1');\n      expect(result.get('SK 0 > SIG 0 > Key flags')).to.equal('[-] 12');\n      expect(result.get('SK 0 > SIG 0 > Tag')).to.equal('[-] 2');\n      expect(result.get('SK 0 > SIG 0 > Version')).to.equal('[-] 4');\n      expect(result.get('SK 0 > SIG 0 > Public key algorithm')).to.equal('[-] 1');\n      expect(result.get('SK 0 > SIG 0 > Sig creation time')).to.equal('[-] 1606140328 or 2020-11-23T14:05:28.000Z');\n      expect(result.get('SK 0 > SIG 0 > Sig expiration time')).to.equal('[-] -');\n      expect(result.get('SK 0 > SIG 0 > Verified')).to.equal('[-] true');\n      expect(result.get('expiration')).to.equal('[-] undefined');\n      expect(result.get('internal dateBeforeExpiration')).to.equal('[-] undefined');\n      expect(result.get('internal usableForEncryptionButExpired')).to.equal('[-] false');\n      expect(result.get('internal usableForSigningButExpired')).to.equal('[-] false');\n      t.pass();\n    });\n\n    ava.default('[KeyUtil.diagnose] decrypts and tests secure PK and insecure SK', async t => {\n      const result = await KeyUtil.diagnose(await KeyUtil.parse(testConstants.rsa1024subkeyOnly), '');\n      expect(result.get('Is Private?')).to.equal('[-] true');\n      expect(result.get('User id 0')).to.equal('rsa1024subkey@test');\n      expect(result.get('Primary User')).to.equal('rsa1024subkey@test');\n      expect(result.get('Fingerprint')).to.equal('B804 AF5A 259A 6673 F853 BEB2 B655 50F5 77CF 5CC5');\n      expect(result.get('Subkeys')).to.equal('[-] 1');\n      expect(result.get('Primary key algo')).to.equal('[-] rsa_encrypt_sign');\n      expect(result.get('Primary key verify')).to.equal('[-] valid');\n      expect(result.get('Primary key creation?')).to.equal('[-] 1611500681 or 2021-01-24T15:04:41.000Z');\n      expect(result.get('Primary key expiration?')).to.equal('[-] -');\n      expect(result.has('Encrypt/Decrypt test: Got error performing encryption/decryption test: Error: Error encrypting message: Could not find valid encryption key packet in key b65550f577cf5cc5')).to.be.true;\n      expect(result.get('Sign/Verify test')).to.equal('[-] sign msg ok|verify ok');\n      expect(result.get('SK 0 > LongId')).to.equal('[-] 1453C9506DBF5B6A');\n      expect(result.get('SK 0 > Created')).to.equal('[-] 1611500698 or 2021-01-24T15:04:58.000Z');\n      expect(result.get('SK 0 > Algo')).to.equal('[-] rsa_encrypt_sign');\n      expect(result.get('SK 0 > Verify')).to.equal('[-] OK');\n      expect(result.get('SK 0 > Subkey tag')).to.equal('[-] 7');\n      expect(result.get('SK 0 > Subkey getBitSize')).to.equal('[-] 1024');\n      expect(result.get('SK 0 > Subkey decrypted')).to.equal('[-] true');\n      expect(result.get('SK 0 > Binding signature length')).to.equal('[-] 1');\n      expect(result.get('SK 0 > SIG 0 > Key flags')).to.equal('[-] 12');\n      expect(result.get('SK 0 > SIG 0 > Tag')).to.equal('[-] 2');\n      expect(result.get('SK 0 > SIG 0 > Version')).to.equal('[-] 4');\n      expect(result.get('SK 0 > SIG 0 > Public key algorithm')).to.equal('[-] 1');\n      expect(result.get('SK 0 > SIG 0 > Sig creation time')).to.equal('[-] 1611500699 or 2021-01-24T15:04:59.000Z');\n      expect(result.get('SK 0 > SIG 0 > Sig expiration time')).to.equal('[-] -');\n      expect(result.get('SK 0 > SIG 0 > Verified')).to.equal('[-] true');\n      expect(result.get('expiration')).to.equal('[-] undefined');\n      expect(result.get('internal dateBeforeExpiration')).to.equal('[-] undefined');\n      expect(result.get('internal usableForEncryptionButExpired')).to.equal('[-] false');\n      expect(result.get('internal usableForSigningButExpired')).to.equal('[-] false');\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.parse] correctly handles signing/encryption detection for PKSK with private keys', async t => {\n      // testing encrypted key\n      const encryptedKey = await KeyUtil.parse(rsaPrimaryKeyAndSubkeyBothHavePrivateKey);\n      expect(encryptedKey.usableForSigning).to.be.true;\n      expect(encryptedKey.missingPrivateKeyForSigning).to.be.false;\n      expect(encryptedKey.usableForEncryption).to.be.true;\n      expect(encryptedKey.missingPrivateKeyForDecryption).to.be.false;\n      expect(await KeyUtil.decrypt(encryptedKey, '1234')).to.be.true;\n      const armoredKey = KeyUtil.armor(encryptedKey);\n      // testing decrypted key\n      const key = await KeyUtil.parse(armoredKey);\n      expect(key.usableForSigning).to.be.true;\n      expect(key.missingPrivateKeyForSigning).to.be.false;\n      expect(key.usableForEncryption).to.be.true;\n      expect(key.missingPrivateKeyForDecryption).to.be.false;\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.decrypt] correctly handles signing/encryption detection for PKSK with private keys', async t => {\n      const dsakey = await KeyUtil.parse(dsaPrimaryKeyAndSubkeyBothHavePrivateKey);\n      expect(await KeyUtil.decrypt(dsakey, '1234')).to.be.true;\n      expect(dsakey.usableForSigning).to.be.true;\n      expect(dsakey.missingPrivateKeyForSigning).to.be.false;\n      expect(dsakey.usableForEncryption).to.be.true;\n      expect(dsakey.missingPrivateKeyForDecryption).to.be.false;\n      const rsakey = await KeyUtil.parse(rsaPrimaryKeyAndSubkeyBothHavePrivateKey);\n      expect(await KeyUtil.decrypt(rsakey, '1234')).to.be.true;\n      expect(rsakey.usableForSigning).to.be.true;\n      expect(rsakey.missingPrivateKeyForSigning).to.be.false;\n      expect(rsakey.usableForEncryption).to.be.true;\n      expect(rsakey.missingPrivateKeyForDecryption).to.be.false;\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.parse] determines PK missing private key for signing', async t => {\n      // testing encrypted key\n      const encryptedKey = await KeyUtil.parse(rsaPrimaryKeyIsMissingPrivateKey);\n      expect(encryptedKey.usableForSigning).to.be.true;\n      expect(encryptedKey.missingPrivateKeyForSigning).to.be.true;\n      expect(encryptedKey.usableForEncryption).to.be.true;\n      expect(encryptedKey.missingPrivateKeyForDecryption).to.be.false;\n      expect(await KeyUtil.decrypt(encryptedKey, '1234')).to.be.true;\n      const armoredKey = KeyUtil.armor(encryptedKey);\n      // testing decrypted key\n      const key = await KeyUtil.parse(armoredKey);\n      expect(key.usableForSigning).to.be.true;\n      expect(key.missingPrivateKeyForSigning).to.be.true;\n      expect(key.usableForEncryption).to.be.true;\n      expect(key.missingPrivateKeyForDecryption).to.be.false;\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.decrypt] determines PK missing private key for signing', async t => {\n      const dsakey = await KeyUtil.parse(dsaPrimaryKeyIsMissingPrivateKey);\n      expect(await KeyUtil.decrypt(dsakey, '1234')).to.be.true;\n      expect(dsakey.usableForSigning).to.be.true;\n      expect(dsakey.missingPrivateKeyForSigning).to.be.true;\n      expect(dsakey.usableForEncryption).to.be.true;\n      expect(dsakey.missingPrivateKeyForDecryption).to.be.false;\n      const rsakey = await KeyUtil.parse(rsaPrimaryKeyIsMissingPrivateKey);\n      expect(await KeyUtil.decrypt(rsakey, '1234')).to.be.true;\n      expect(rsakey.usableForSigning).to.be.true;\n      expect(rsakey.missingPrivateKeyForSigning).to.be.true;\n      expect(rsakey.usableForEncryption).to.be.true;\n      expect(rsakey.missingPrivateKeyForDecryption).to.be.false;\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.parse] determines missing private key for encryption in expired key', async t => {\n      const dsakey = await KeyUtil.parse(dsaExpiredPubkeysOnly);\n      expect(dsakey.usableForEncryptionButExpired).to.be.true;\n      expect(dsakey.usableForSigningButExpired).to.be.true;\n      expect(dsakey.usableForSigning).to.be.false;\n      expect(dsakey.usableForEncryption).to.be.false;\n      expect(dsakey.missingPrivateKeyForSigning).to.be.true;\n      expect(dsakey.missingPrivateKeyForDecryption).to.be.true;\n      const rsakey = await KeyUtil.parse(rsaExpiredPubkeysOnly);\n      expect(rsakey.usableForEncryptionButExpired).to.be.true;\n      expect(rsakey.usableForSigningButExpired).to.be.true;\n      expect(rsakey.usableForSigning).to.be.false;\n      expect(rsakey.usableForEncryption).to.be.false;\n      expect(rsakey.missingPrivateKeyForSigning).to.be.true;\n      expect(rsakey.missingPrivateKeyForDecryption).to.be.true;\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.decrypt] handles PK missing private key for signing in expired key', async t => {\n      const dsakey = await KeyUtil.parse(dsaExpiredPrimaryKeyIsMissingPrivateKey);\n      expect(await KeyUtil.decrypt(dsakey, '1234')).to.be.true;\n      expect(dsakey.usableForEncryptionButExpired).to.be.true;\n      expect(dsakey.usableForSigningButExpired).to.be.true;\n      expect(dsakey.usableForSigning).to.be.false;\n      expect(dsakey.usableForEncryption).to.be.false;\n      expect(dsakey.missingPrivateKeyForSigning).to.be.true;\n      expect(dsakey.missingPrivateKeyForDecryption).to.be.false;\n      const rsakey = await KeyUtil.parse(rsaExpiredPrimaryKeyIsMissingPrivateKey);\n      expect(await KeyUtil.decrypt(rsakey, '1234')).to.be.true;\n      expect(rsakey.usableForEncryptionButExpired).to.be.true;\n      expect(rsakey.usableForSigningButExpired).to.be.true;\n      expect(rsakey.usableForSigning).to.be.false;\n      expect(rsakey.usableForEncryption).to.be.false;\n      expect(rsakey.missingPrivateKeyForSigning).to.be.true;\n      expect(rsakey.missingPrivateKeyForDecryption).to.be.false;\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.parseBinary] handles OpenPGP binary key', async t => {\n      const key = Buffer.from('mDMEX7JGnBYJKwYBBAHaRw8BAQdA8L8ZDEHJ3N8fojA1P0n9Tc2E0BTCl6AXq/b2ZoS5Evy0BlRl' +\n        'c3QgMYiQBBMWCAA4FiEExOEH3ZJIrCG1lTnB5pbLkt3W1hMFAl+yRpwCGwMFCwkIBwIGFQoJCAsC' +\n        'BBYCAwECHgECF4AACgkQ5pbLkt3W1hOHzAEAj3hiPLsaCeRGjLaYNvKNTetdfGLVSu2+cGMsHh8r' +\n        '+pgBANNxQyqE5+3LjHhecVVNErbgr1n6vTurE5Jhc1Go3x8F', 'base64');\n      const parsed = await KeyUtil.parseBinary(key, '');\n      expect(parsed.length).to.be.equal(1);\n      expect(parsed[0].id).to.be.equal('C4E107DD9248AC21B59539C1E696CB92DDD6D613');\n      t.pass();\n    });\n\n    ava.default('[unit][KeyUtil.parseBinary] handles PKCS#12 binary key', async t => {\n      const key = Buffer.from(`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`, 'base64');\n      const parsed = await KeyUtil.parseBinary(key, 'test');\n      expect(parsed.length).to.be.equal(1);\n      expect(parsed[0].id).to.be.equal('60EFFE4DF7B2114A77021459C273F0AA864AFF7F');\n      expect(parsed[0].type).to.be.equal('x509');\n      expect(parsed[0].emails.length).to.be.equal(1);\n      expect(parsed[0].emails[0]).to.be.equal('test@example.com');\n      expect(parsed[0].isPrivate).to.be.equal(false);\n      expect(parsed[0].isPublic).to.be.equal(true);\n      t.pass();\n    });\n\n    ava.default(`[unit][OpenPGPKey.parse] sets usableForEncryption and usableForSigning to false for RSA key less than 2048`, async t => {\n      const rsa1024secret = `-----BEGIN PGP PRIVATE KEY BLOCK-----\n\nxcEYBGAID1EBBACypl5K0IoqFjfpSrIhbhT5H5MjQg4MKRlgMfqXjo8pEeB6Yf88wvBni36iRdSn\novc7mbuOSPc+Z8ABqGPdW5AWs6K/gchWyIzuDQ32pRfUKc9SAAs0Ddyv/+S4XKUCLdX88yUsjnnK\n8beHnju57bIsiamo19HqsfZKJUQb4ZS33wARAQABAAP+M5ZH/ymV5A5Tadnocy/S/ZcpCVLfNJK/\noZ/9ATuoyk6/uAdJSVXvTq8gy6IHhLrR0pOTbcRTJOGXt8LUx4xToEcHw1uTIVmtw7EtDQdMPyKC\nHjFbIAhWGXbefQItohKBEDfucXgwI0YpNdIjk6mFc0IO6/XUIQg1bMg/UK0HA80CANEI9OQDNgAR\ncaikGHAl672KWBwTBM8XgytF7D+Bzt41eElKswMFYyMlRzZlSmkx3sJ+XdCHuC0skQIluV181EsC\nANrJwSfyOsPhqQ+GjNdg8uPEdLvIK6CLdMwEelvGPkXuyq58ACCgiFKlir2taNqfQfD+V1XGWqLy\nrzSplwgZJj0B/3EIZSiM8oC9eBsq9Eo29d/wEkspz14qsQsvl6IEAQzk6utsmWRViLrkijVPOTgb\nZbQm646+Japkh+lC1uz4F7WXK80McnNhMTAyNEB0ZXN0wsAIBBMBCAAzFiEE6aCtchH+fjctzmKs\nZywk4TigN/QFAmAID1ICGwMFCwkIBwIGFQgJCgsCBRYCAwEAAAoJEGcsJOE4oDf0LCwD+My9gLrB\nB3bjq694Yx5H6aLayc79fm6aL3bEBJGD6EQMqGTbN+Gfz6JcpCzOBW7Jn9Jc5PC+4d0JxK7TzBXE\nSxM2ViraS5ScW3GuqVoAw00/0NRYrXr7iTkzT8gAdEBNXdn/ozlCrNkR8JxOmcyqJtTwPkzMRy9D\nMtbTz6xoGaPHwRgEYAgPUgEEAN5qHMlEB1uwxr/bEL4ZWcSvEFRP7hSC2isB9JlomACDPHRQAi5q\ndOXaP3BD81mVm3FRKtc6UuLao641+RNmiTrDSKpmB7MIPRS4tO4DIBDj4g7xz0AXHs+OYqBi2+iU\nHy0dclP6TP2dWE1fT7bgfD3GaaKri6Zgfb5ZLQ+bGL03ABEBAAEAA/9uU5q1563yuKzOLJ+QfMi/\nvMtP11pVCFeqb8zicDS+RFsvoySB28Li5bEEQmCrNoAl5MpoewD0kNoSp6lHC1zUQQymouefK/W3\npD8bNcFRzpQ1m4iVkEG1o6Joq1wxQe+OHbxDxil8VluAGMWdXSzPUFH/JYu7z819E8C3NO0ZcQIA\n3nnloE/O6k382CLYEkEu2aXownXlhtuCNslif4vUMRePZvPTD93lUHnFZ0ZZcJTMq4YdFcuXlyZI\n2XlnHfe3nwIA/+3WRADntAcFFp/3HMSl1Jua9ic89rABgXXZqvxhy2cu+9wZR+GpHjZy9Pm/kOHS\nwjl+nI4Q6pQcdxCYn75zaQIAi8KOAoDDeNC8wjUS2FN84/2Asc78D0MQc442CqCQ70It8csDTanH\nxamPFeub/1JW7H0hkma1C5CEi2coHjeAbambwrYEGAEIACAWIQTpoK1yEf5+Ny3OYqxnLCThOKA3\n9AUCYAgPUwIbDAAKCRBnLCThOKA39O3dA/0RALQ6Sp35YWvHN4iYvInO9DZIEvaSBjpzNNDThRvp\nXfiBZBgRV34sZ8IjBXWnHmnJOioXG0LnZ7V37Zpa1PnPcqKd5kXg649NS+jXqyd7yjgIhyhB54VC\nr7V4UalYBHeiwKQhzrU8KfaVfVaYu7ctfitV5Ba/8SqxrblMAZAV6A==\n=pcI4\n-----END PGP PRIVATE KEY BLOCK-----`;\n      const key1 = await KeyUtil.parse(rsa1024secret);\n      expect(key1.usableForEncryption).to.equal(false);\n      expect(key1.usableForSigning).to.equal(false);\n      expect(key1.usableForEncryptionButExpired).to.equal(false);\n      expect(key1.usableForSigningButExpired).to.equal(false);\n      const rsa1024public = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxo0EYAgPUQEEALKmXkrQiioWN+lKsiFuFPkfkyNCDgwpGWAx+peOjykR4Hph/zzC8GeLfqJF1Kei\n9zuZu45I9z5nwAGoY91bkBazor+ByFbIjO4NDfalF9Qpz1IACzQN3K//5LhcpQIt1fzzJSyOecrx\nt4eeO7ntsiyJqajX0eqx9kolRBvhlLffABEBAAHNDHJzYTEwMjRAdGVzdMLACAQTAQgAMxYhBOmg\nrXIR/n43Lc5irGcsJOE4oDf0BQJgCA9SAhsDBQsJCAcCBhUICQoLAgUWAgMBAAAKCRBnLCThOKA3\n9CwsA/jMvYC6wQd246uveGMeR+mi2snO/X5umi92xASRg+hEDKhk2zfhn8+iXKQszgVuyZ/SXOTw\nvuHdCcSu08wVxEsTNlYq2kuUnFtxrqlaAMNNP9DUWK16+4k5M0/IAHRATV3Z/6M5QqzZEfCcTpnM\nqibU8D5MzEcvQzLW08+saBmjzo0EYAgPUgEEAN5qHMlEB1uwxr/bEL4ZWcSvEFRP7hSC2isB9Jlo\nmACDPHRQAi5qdOXaP3BD81mVm3FRKtc6UuLao641+RNmiTrDSKpmB7MIPRS4tO4DIBDj4g7xz0AX\nHs+OYqBi2+iUHy0dclP6TP2dWE1fT7bgfD3GaaKri6Zgfb5ZLQ+bGL03ABEBAAHCtgQYAQgAIBYh\nBOmgrXIR/n43Lc5irGcsJOE4oDf0BQJgCA9TAhsMAAoJEGcsJOE4oDf07d0D/REAtDpKnflha8c3\niJi8ic70NkgS9pIGOnM00NOFG+ld+IFkGBFXfixnwiMFdaceack6KhcbQudntXftmlrU+c9yop3m\nReDrj01L6NerJ3vKOAiHKEHnhUKvtXhRqVgEd6LApCHOtTwp9pV9Vpi7ty1+K1XkFr/xKrGtuUwB\nkBXo\n=PeOs\n-----END PGP PUBLIC KEY BLOCK-----`;\n      const key2 = await KeyUtil.parse(rsa1024public);\n      expect(key2.usableForEncryption).to.equal(false);\n      expect(key2.usableForSigning).to.equal(false);\n      expect(key2.usableForEncryptionButExpired).to.equal(false);\n      expect(key2.usableForSigningButExpired).to.equal(false);\n      t.pass();\n    });\n\n    ava.default(`[unit][OpenPGPKey.parse] sets usableForEncryption to false and usableForSigning to true for 2048/RSA PK and 1024/RSA SK`, async t => {\n      const key = await KeyUtil.parse(testConstants.rsa1024subkeyOnly);\n      expect(key.usableForEncryption).to.equal(false);\n      expect(key.usableForSigning).to.equal(true);\n      expect(key.usableForEncryptionButExpired).to.equal(false);\n      expect(key.usableForSigningButExpired).to.equal(false);\n      t.pass();\n    });\n\n    ava.default(`[unit][OpenPGPKey.decrypt] sets usableForEncryption to false and usableForSigning to true for 2048/RSA PK and 1024/RSA SK`, async t => {\n      const key = await KeyUtil.parse(testConstants.rsa1024subkeyOnlyEncrypted);\n      expect(key.usableForEncryption).to.equal(false);\n      expect(key.usableForSigning).to.equal(true);\n      expect(key.usableForEncryptionButExpired).to.equal(false);\n      expect(key.usableForSigningButExpired).to.equal(false);\n      expect(await KeyUtil.decrypt(key, '1234')).to.be.true;\n      expect(key.usableForEncryption).to.equal(false);\n      expect(key.usableForSigning).to.equal(true);\n      expect(key.usableForEncryptionButExpired).to.equal(false);\n      expect(key.usableForSigningButExpired).to.equal(false);\n      t.pass();\n    });\n\n    ava.default(`[unit][PgpArmor.dearmor] throws on incorrect sequence`, async t => {\n      await expect(PgpArmor.dearmor(`-----BEGIN PGP MESSAGE-----\n\nAAAAAAAAAAAAAAAAzzzzzzzzzzzzzzzzzzzzzzzzzzzz.....`)).to.eventually.be.rejectedWith('Misformed armored text');\n      t.pass();\n    });\n\n    ava.default(`[unit][PgpArmor.dearmor] correctly handles long string`, async t => {\n      const source = Buffer.from('The test string concatenated many times to produce large output'.repeat(100000));\n      const type = 3;\n      const armored = PgpArmor.armor(type, source);\n      const dearmored = await PgpArmor.dearmor(armored);\n      expect(dearmored.type).to.equal(type);\n      equals(\n        dearmored.data,\n        source\n      );\n      t.pass();\n    });\n\n  }\n};\n",
    "test/source/util/index.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport * as fs from 'fs';\n\nimport { ExtendedKeyInfo, KeyUtil } from '../core/crypto/key.js';\n\nexport type TestVariant = 'CONSUMER-MOCK' | 'ENTERPRISE-MOCK' | 'CONSUMER-LIVE-GMAIL' | 'UNIT-TESTS';\n\nexport const getParsedCliParams = () => {\n  let testVariant: TestVariant;\n  if (process.argv.includes('CONSUMER-MOCK')) {\n    testVariant = 'CONSUMER-MOCK';\n  } else if (process.argv.includes('ENTERPRISE-MOCK')) {\n    testVariant = 'ENTERPRISE-MOCK';\n  } else if (process.argv.includes('CONSUMER-LIVE-GMAIL')) {\n    testVariant = 'CONSUMER-LIVE-GMAIL';\n  } else if (process.argv.includes('UNIT-TESTS')) {\n    testVariant = 'UNIT-TESTS';\n  } else {\n    throw new Error('Unknown test type: specify CONSUMER-MOCK or ENTERPRISE-MOCK CONSUMER-LIVE-GMAIL');\n  }\n  const testGroup = (process.argv.includes('UNIT-TESTS') ? 'UNIT-TESTS'\n    : process.argv.includes('FLAKY-GROUP') ? 'FLAKY-GROUP' : 'STANDARD-GROUP') as\n    'FLAKY-GROUP' | 'STANDARD-GROUP' | 'UNIT-TESTS';\n  const buildDir = `build/chrome-${(testVariant === 'CONSUMER-LIVE-GMAIL' ? 'CONSUMER' : testVariant).toLowerCase()}`;\n  const poolSizeOne = process.argv.includes('--pool-size=1') || testGroup === 'FLAKY-GROUP';\n  const oneIfNotPooled = (suggestedPoolSize: number) => poolSizeOne ? Math.min(1, suggestedPoolSize) : suggestedPoolSize;\n  console.info(`TEST_VARIANT: ${testVariant}:${testGroup}, (build dir: ${buildDir}, poolSizeOne: ${poolSizeOne})`);\n  return { testVariant, testGroup, oneIfNotPooled, buildDir, isMock: testVariant.includes('-MOCK') };\n};\n\nexport type TestMessage = {\n  name?: string,\n  content: string[],\n  unexpectedContent?: string[],\n  password?: string,\n  params: string,\n  quoted?: boolean,\n  expectPercentageProgress?: boolean,\n  signature?: string[],\n};\n\ninterface TestSecretsInterface {\n  ci_admin_token: string;\n  auth: { google: { email: string, password?: string, secret_2fa?: string }[], };\n  keys: { title: string, passphrase: string, armored: string | null, longid: string | null }[];\n}\n\nexport class Config {\n\n  public static extensionId = '';\n\n  private static _secrets: TestSecretsInterface;\n\n  public static secrets = (): TestSecretsInterface => {\n    if (!Config._secrets) {\n      try {\n        Config._secrets = JSON.parse(fs.readFileSync('test/test-secrets.json', 'utf8'));\n        const data = JSON.parse(fs.readFileSync('test/testdata.json', 'utf8'));\n        Config._secrets.keys = data.keys;\n      } catch (e) {\n        console.error(`skipping loading test secrets because ${e}`);\n        Config._secrets = { auth: { google: [] }, keys: [] } as any as TestSecretsInterface;\n      }\n    }\n    return Config._secrets;\n  }\n\n  public static key = (title: string) => {\n    return Config.secrets().keys.filter(k => k.title === title)[0];\n  }\n\n  public static getKeyInfo = async (titles: string[]): Promise<ExtendedKeyInfo[]> => {\n    return await Promise.all(Config._secrets.keys\n      .filter(key => key.armored && titles.includes(key.title)).map(async key => {\n        const parsed = await KeyUtil.parse(key.armored!);\n        return { ...await KeyUtil.keyInfoObj(parsed), type: parsed.type, passphrase: key.passphrase };\n      }));\n  }\n\n}\n\nexport class Util {\n\n  public static sleep = async (seconds: number) => {\n    return await new Promise(resolve => setTimeout(resolve, seconds * 1000));\n  }\n\n  public static lousyRandom = () => {\n    return Math.random().toString(36).substring(2);\n  }\n\n  public static htmlEscape = (str: string) => {\n    return str.replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\//g, '&#x2F;');\n  }\n\n  public static deleteFileIfExists = (filename: string) => {\n    try {\n      fs.unlinkSync(filename);\n    } catch (e) {\n      // file didn't exist\n    }\n  }\n\n}\n",
    "test/source/util/parse.ts": "/* ©️ 2016 - present FlowCrypt a.s. Limitations apply. Contact human@flowcrypt.com */\n\nimport { ParsedMail, simpleParser } from \"mailparser\";\nimport { Buf } from '../core/buf';\n\ntype ThreadIdObject = {\n  threadId: string;\n};\n\nexport class ParseMsgResult {\n  public threadId?: string;\n  public mimeMsg: ParsedMail;\n  public base64: string;\n}\n\nconst strictParse = async (source: string): Promise<ParseMsgResult> => {\n  const lines = source.split('\\n');\n  const result = new ParseMsgResult();\n  if (lines[1] === 'Content-Type: application/json; charset=UTF-8' && lines[3]) {\n    const threadIdObject = JSON.parse(lines[3]) as ThreadIdObject;\n    result.threadId = threadIdObject.threadId;\n  } else {\n    throw new Error('ThreadId property doesn\\'t exist');\n  }\n  if (lines[6] === 'Content-Type: message/rfc822' && lines[7] === 'Content-Transfer-Encoding: base64' && lines[9]) {\n    result.base64 = lines[9];\n    result.mimeMsg = await convertBase64ToMimeMsg(lines[9]);\n  } else {\n    throw new Error('Base64 MIME Msg wasn\\'t found');\n  }\n  return result;\n};\n\nconst convertBase64ToMimeMsg = async (base64: string) => {\n  return await simpleParser(new Buffer(Buf.fromBase64Str(base64)), { keepCidLinks: true /* #3256 */ });\n};\n\nexport default { strictParse, convertBase64ToMimeMsg };\n"
  }
}