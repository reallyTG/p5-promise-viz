{
  "promises": {
    "0": {
      "source": "node_modules/jest-runner/build/runTest.js:372:23:372:23",
      "startTime": "928730075777066",
      "endTime": "928730075993412",
      "elapsedTime": "216346",
      "asyncId": 12,
      "triggerAsyncId": 4,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTestInternal",
      "userCode": false,
      "line": "\n\n  try {\n    await environment.setup();\n    let result;\n\n    try ",
      "startLine": 372,
      "startCol": 23,
      "endLine": 372,
      "endCol": 23,
      "file": "node_modules/jest-runner/build/runTest.js",
      "triggers": [
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13
      ],
      "uniqueid": 0
    },
    "1": {
      "source": "node_modules/jest-runner/build/runTest.js:472:40:472:40",
      "startTime": "928730073383980",
      "endTime": "928731678848657",
      "elapsedTime": "1605464677",
      "asyncId": 13,
      "triggerAsyncId": 12,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        27,
        28,
        28,
        28,
        29,
        28,
        29,
        30,
        28,
        30,
        31,
        29,
        27,
        30,
        28,
        31,
        31,
        32,
        33,
        34,
        35,
        31,
        36,
        33,
        37,
        38,
        41,
        43,
        28,
        29,
        30,
        31,
        32,
        33,
        28,
        34,
        26,
        30,
        29,
        25,
        37,
        39,
        28,
        29,
        30,
        31,
        32,
        33,
        36,
        38,
        28,
        28,
        31,
        33,
        28,
        28,
        28,
        28,
        29,
        29,
        29,
        30,
        30,
        30,
        31,
        34,
        31,
        36,
        31,
        32,
        35,
        37,
        29,
        26,
        30,
        29,
        25,
        26,
        36,
        35,
        25,
        26,
        35,
        34,
        25,
        26,
        34,
        33,
        25,
        30,
        26,
        40,
        39,
        25,
        26,
        33,
        32,
        25,
        32,
        29,
        32,
        29,
        32,
        29,
        29,
        31,
        32,
        35,
        37,
        26,
        34,
        33,
        25,
        31,
        34,
        34,
        31,
        34,
        31,
        31,
        32,
        35,
        35,
        38,
        33,
        40,
        36,
        37,
        38,
        32,
        39,
        40,
        32,
        34,
        33,
        41,
        33,
        42,
        43,
        32,
        35,
        36,
        44,
        34,
        45,
        39,
        41,
        46,
        47,
        48,
        33,
        34,
        51,
        53,
        35,
        34,
        36,
        37,
        38,
        39,
        35,
        35,
        38,
        40,
        38,
        40,
        40,
        41,
        44,
        46,
        35,
        36,
        37,
        40,
        42,
        26,
        37,
        36,
        25,
        26,
        37,
        36,
        25,
        26,
        37,
        36,
        25,
        26,
        38,
        37,
        25,
        26,
        43,
        42,
        25,
        26,
        39,
        38,
        25,
        26,
        50,
        49,
        25
      ],
      "line": "\n  sendMessageToJest\n) {\n  const {leakDetector, result} = await runTestInternal(\n    path,\n    globalConfig,\n    config",
      "startLine": 472,
      "startCol": 40,
      "endLine": 472,
      "endCol": 40,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 1
    },
    "2": {
      "source": "node_modules/jest-runner/build/runTest.js:380:22:380:22",
      "startTime": "928730081275523",
      "endTime": "928732326251346",
      "elapsedTime": "2244975823",
      "asyncId": 25,
      "triggerAsyncId": 13,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        38,
        48,
        38,
        44,
        40,
        43,
        38,
        41,
        42,
        38,
        40,
        44,
        46,
        43,
        42,
        45,
        44,
        48,
        50,
        41,
        43,
        42,
        42,
        44,
        45,
        46,
        58,
        45,
        45,
        51,
        47,
        45,
        47,
        45,
        47,
        45,
        47,
        46,
        48,
        51,
        53,
        47,
        49,
        58,
        60
      ],
      "line": "\n      }\n\n      result = await testFramework(\n        globalConfig,\n        config,\n        environment",
      "startLine": 380,
      "startCol": 22,
      "endLine": 380,
      "endCol": 22,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 2
    },
    "3": {
      "source": "node_modules/jest-jasmine2/build/index.js:233:13:233:13",
      "startTime": "928731649126139",
      "endTime": "928732061619402",
      "elapsedTime": "412493263",
      "asyncId": 42,
      "triggerAsyncId": 13,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " jasmine2",
      "userCode": false,
      "triggers": [
        62,
        43,
        63,
        43,
        55,
        57,
        63,
        43,
        43,
        43,
        43,
        53,
        54,
        61,
        88,
        65,
        43
      ],
      "line": "\n  }\n\n  await env.execute();\n  const results = await reporter.getResults();\n  return addSnapshotData(results, snapshotState);\n",
      "startLine": 233,
      "startCol": 13,
      "endLine": 233,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/index.js",
      "uniqueid": 3
    },
    "4": {
      "source": "node_modules/jest-runner/build/runTest.js:380:22:380:22",
      "startTime": "928731677518844",
      "endTime": "928732137379300",
      "elapsedTime": "459860456",
      "asyncId": 47,
      "triggerAsyncId": 25,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        48,
        60,
        62,
        73,
        140,
        142,
        139,
        137,
        296,
        298,
        295,
        293,
        232,
        234,
        231,
        229,
        58,
        59,
        71,
        93,
        75,
        68,
        48
      ],
      "line": "\n      }\n\n      result = await testFramework(\n        globalConfig,\n        config,\n        environment",
      "startLine": 380,
      "startCol": 22,
      "endLine": 380,
      "endCol": 22,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 4
    },
    "5": {
      "source": "node_modules/jest-jasmine2/build/index.js:233:13:233:13",
      "startTime": "928731616928562",
      "endTime": "928732325566392",
      "elapsedTime": "708637830",
      "asyncId": 49,
      "triggerAsyncId": 13,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " jasmine2",
      "userCode": false,
      "triggers": [
        50,
        50,
        50,
        50,
        56,
        58,
        56,
        59,
        50,
        821,
        823,
        820,
        818
      ],
      "line": "\n  }\n\n  await env.execute();\n  const results = await reporter.getResults();\n  return addSnapshotData(results, snapshotState);\n",
      "startLine": 233,
      "startCol": 13,
      "endLine": 233,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/index.js",
      "uniqueid": 5
    },
    "6": {
      "source": "node_modules/jest-runner/build/runTest.js:380:22:380:22",
      "startTime": "928731655266199",
      "endTime": "928732061732223",
      "elapsedTime": "406466024",
      "asyncId": 51,
      "triggerAsyncId": 25,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        52,
        97,
        99,
        105,
        96,
        103,
        116,
        71,
        60,
        105,
        107,
        113,
        104,
        111,
        124,
        52,
        52,
        64,
        60,
        76,
        52
      ],
      "line": "\n      }\n\n      result = await testFramework(\n        globalConfig,\n        config,\n        environment",
      "startLine": 380,
      "startCol": 22,
      "endLine": 380,
      "endCol": 22,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 6
    },
    "7": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731656267065",
      "endTime": "928732070774995",
      "elapsedTime": "414507930",
      "asyncId": 53,
      "triggerAsyncId": 25,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        66,
        68,
        83,
        191,
        193,
        199,
        54,
        190,
        197,
        210,
        73,
        64,
        65,
        81,
        101,
        54,
        54,
        54,
        54,
        54,
        62,
        54,
        59,
        62,
        59,
        62,
        62,
        62,
        1054,
        1056,
        1053,
        1051,
        54
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 7
    },
    "8": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731620371566",
      "endTime": "928732324843898",
      "elapsedTime": "704472332",
      "asyncId": 54,
      "triggerAsyncId": 53,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        55,
        55,
        65,
        67,
        86,
        55,
        423,
        425,
        440,
        63,
        64,
        84,
        104,
        88,
        421,
        422,
        438,
        455,
        55,
        55,
        65,
        67,
        74,
        64,
        72,
        88,
        55,
        55,
        59,
        67,
        69,
        88,
        55,
        59,
        64,
        65,
        66,
        86,
        106,
        90
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 8
    },
    "9": {
      "source": "node_modules/jest-runner/build/runTest.js:380:22:380:22",
      "startTime": "928731621663528",
      "endTime": "928732325671750",
      "elapsedTime": "704008222",
      "asyncId": 58,
      "triggerAsyncId": 25,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        382,
        384,
        390,
        380,
        381,
        388,
        407,
        59,
        59,
        505,
        507,
        515,
        503,
        504,
        513,
        531,
        59,
        59,
        69,
        71,
        115,
        117,
        123,
        84,
        114,
        121,
        134,
        59,
        59,
        104,
        106,
        112,
        111,
        113,
        59,
        119,
        103,
        110,
        123,
        78,
        110,
        117,
        130,
        59,
        59,
        59,
        67,
        68,
        82,
        102,
        86,
        72,
        91,
        59
      ],
      "line": "\n      }\n\n      result = await testFramework(\n        globalConfig,\n        config,\n        environment",
      "startLine": 380,
      "startCol": 22,
      "endLine": 380,
      "endCol": 22,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 9
    },
    "10": {
      "source": "node_modules/jest-runner/build/runTest.js:380:22:380:22",
      "startTime": "928731621964643",
      "endTime": "928732325987401",
      "elapsedTime": "704022758",
      "asyncId": 59,
      "triggerAsyncId": 58,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        60,
        452,
        454,
        461,
        60,
        450,
        451,
        459,
        478,
        60,
        60,
        654,
        656,
        664,
        652,
        653,
        662,
        680,
        80,
        164,
        166,
        172,
        69,
        163,
        170,
        183,
        60,
        71,
        73,
        80,
        60,
        60,
        148,
        150,
        156,
        147,
        154,
        167,
        60,
        60,
        69,
        70,
        78,
        98,
        60,
        60,
        69,
        60
      ],
      "line": "\n      }\n\n      result = await testFramework(\n        globalConfig,\n        config,\n        environment",
      "startLine": 380,
      "startCol": 22,
      "endLine": 380,
      "endCol": 22,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 10
    },
    "11": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731622292036",
      "endTime": "928732334711986",
      "elapsedTime": "712419950",
      "asyncId": 60,
      "triggerAsyncId": 25,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        75,
        77,
        68,
        86,
        73,
        74,
        84,
        106,
        61,
        61,
        578,
        580,
        586,
        576,
        577,
        584,
        603,
        83,
        61,
        207,
        209,
        215,
        206,
        213,
        226,
        61,
        61,
        185,
        187,
        193,
        184,
        191,
        204,
        61,
        61,
        170,
        172,
        180,
        168,
        169,
        178,
        195,
        82,
        1715,
        1717,
        1714,
        1712
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 11
    },
    "12": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731625973006",
      "endTime": "928732324671725",
      "elapsedTime": "698698719",
      "asyncId": 65,
      "triggerAsyncId": 54,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        86,
        89,
        87,
        91,
        95,
        66,
        66,
        66,
        79,
        79,
        66,
        282,
        284,
        291,
        280,
        281,
        289,
        306,
        66,
        66,
        87
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 12
    },
    "13": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731626302314",
      "endTime": "928732324703425",
      "elapsedTime": "698401111",
      "asyncId": 66,
      "triggerAsyncId": 54,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        76,
        79,
        77,
        81,
        87,
        67,
        67,
        84,
        364,
        366,
        374,
        362,
        363,
        372,
        389,
        67,
        67,
        84
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 13
    },
    "14": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731628779858",
      "endTime": "928731814032430",
      "elapsedTime": "185252572",
      "asyncId": 73,
      "triggerAsyncId": 72,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        74,
        74,
        95,
        98,
        96,
        100,
        104,
        74,
        74,
        85,
        224,
        226,
        232,
        223,
        230,
        243,
        74,
        74,
        260,
        262,
        268,
        259,
        266,
        279,
        74,
        74,
        74,
        74,
        132,
        134,
        140,
        74,
        74,
        131,
        138,
        151,
        74,
        74,
        74,
        74,
        303,
        305,
        311,
        301,
        302,
        309,
        326,
        74,
        74
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 14
    },
    "15": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731629184948",
      "endTime": "928731857195071",
      "elapsedTime": "228010123",
      "asyncId": 74,
      "triggerAsyncId": 73,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        76,
        82,
        87,
        89,
        97,
        86,
        95,
        111,
        75,
        75,
        105,
        108,
        106,
        110,
        114,
        75,
        82,
        257,
        259,
        265,
        256,
        263,
        276,
        75,
        75,
        293,
        295,
        301,
        292,
        299,
        312,
        75,
        75,
        84,
        87,
        85,
        89,
        95,
        75,
        75,
        84,
        87,
        85,
        89,
        95,
        75,
        75,
        171,
        173,
        86,
        179,
        88,
        94,
        170,
        177,
        190,
        75,
        85,
        92,
        108,
        75,
        75,
        75,
        361,
        363,
        370,
        359,
        360,
        368,
        385,
        75,
        75
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 15
    },
    "16": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731670171741",
      "endTime": "928732060963823",
      "elapsedTime": "390792082",
      "asyncId": 75,
      "triggerAsyncId": 47,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        81,
        145,
        147,
        155,
        144,
        153,
        166,
        76,
        76,
        290,
        292,
        298,
        289,
        296,
        309,
        76,
        326,
        328,
        334,
        76,
        325,
        332,
        345,
        76,
        76,
        100,
        107,
        99,
        98,
        97,
        96,
        105,
        109,
        113,
        76,
        103,
        97,
        96,
        101,
        105,
        109,
        76,
        210,
        212,
        218,
        128,
        130,
        136,
        209,
        216,
        229,
        76,
        127,
        134,
        147,
        96,
        76,
        457,
        459,
        465,
        455,
        456,
        463,
        480,
        76,
        76
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 16
    },
    "17": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731630100283",
      "endTime": "928731970792630",
      "elapsedTime": "340692347",
      "asyncId": 77,
      "triggerAsyncId": 76,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        78,
        78,
        83,
        78,
        356,
        358,
        364,
        355,
        362,
        375,
        78,
        392,
        394,
        400,
        78,
        391,
        398,
        411,
        78,
        78,
        88,
        288,
        290,
        296,
        287,
        294,
        307,
        78,
        78,
        665,
        667,
        674,
        663,
        664,
        672,
        689,
        78,
        78
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 17
    },
    "18": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731630433057",
      "endTime": "928732007125889",
      "elapsedTime": "376692832",
      "asyncId": 78,
      "triggerAsyncId": 77,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        92,
        94,
        102,
        91,
        100,
        116,
        79,
        79,
        389,
        391,
        397,
        388,
        395,
        408,
        99,
        425,
        427,
        433,
        424,
        431,
        444,
        79,
        79,
        85,
        85,
        327,
        329,
        335,
        326,
        333,
        346,
        79,
        79,
        759,
        761,
        768,
        757,
        758,
        766,
        783,
        79,
        79
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 18
    },
    "19": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731630737839",
      "endTime": "928732052287839",
      "elapsedTime": "421550000",
      "asyncId": 79,
      "triggerAsyncId": 78,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        207,
        209,
        217,
        206,
        215,
        228,
        80,
        80,
        80,
        458,
        460,
        466,
        457,
        464,
        477,
        80,
        80,
        81,
        366,
        368,
        374,
        365,
        372,
        385,
        100,
        881,
        883,
        891,
        879,
        880,
        889,
        906,
        80,
        80
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 19
    },
    "20": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731631060764",
      "endTime": "928732131371898",
      "elapsedTime": "500311134",
      "asyncId": 80,
      "triggerAsyncId": 79,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        302,
        304,
        312,
        301,
        310,
        323,
        81,
        81,
        491,
        493,
        499,
        490,
        497,
        510,
        81,
        81,
        86,
        81,
        1035,
        1037,
        1044,
        1033,
        1034,
        1042,
        1059,
        81,
        81
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 20
    },
    "21": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731631433022",
      "endTime": "928732302386119",
      "elapsedTime": "670953097",
      "asyncId": 81,
      "triggerAsyncId": 80,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        368,
        370,
        379,
        366,
        367,
        377,
        397,
        104,
        524,
        526,
        532,
        523,
        530,
        543,
        102,
        83,
        82,
        82,
        1296,
        1298,
        1305,
        1294,
        1295,
        1303,
        1320,
        82,
        82
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 21
    },
    "22": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731631768781",
      "endTime": "928732315491005",
      "elapsedTime": "683722224",
      "asyncId": 82,
      "triggerAsyncId": 81,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        83,
        83,
        88,
        95,
        97,
        103,
        94,
        101,
        117,
        83,
        83,
        1628,
        1630,
        1636,
        1626,
        1627,
        1634,
        1651,
        83,
        83
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 22
    },
    "23": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731632119408",
      "endTime": "928732324500233",
      "elapsedTime": "692380825",
      "asyncId": 83,
      "triggerAsyncId": 82,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        85,
        133,
        135,
        141,
        132,
        139,
        152,
        84,
        84,
        1679,
        1681,
        1687,
        1678,
        1685,
        1698,
        104
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 23
    },
    "24": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731632423799",
      "endTime": "928732324583890",
      "elapsedTime": "692160091",
      "asyncId": 84,
      "triggerAsyncId": 66,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        90,
        86,
        86,
        166,
        168,
        174,
        165,
        172,
        185,
        105,
        85
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 24
    },
    "25": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731708279086",
      "endTime": "928731721655792",
      "elapsedTime": "13376706",
      "asyncId": 89,
      "triggerAsyncId": 88,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        90,
        90,
        93,
        97,
        99,
        102,
        100,
        104,
        110,
        90,
        90
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 25
    },
    "26": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731634351182",
      "endTime": "928732324930600",
      "elapsedTime": "690579418",
      "asyncId": 90,
      "triggerAsyncId": 54,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        102,
        105,
        103,
        107,
        113,
        91,
        91,
        92,
        114,
        120,
        113,
        112,
        111,
        118,
        122,
        126,
        91
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 26
    },
    "27": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731710318980",
      "endTime": "928731737904061",
      "elapsedTime": "27585081",
      "asyncId": 92,
      "triggerAsyncId": 74,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        124,
        127,
        125,
        129,
        133,
        93,
        93,
        102,
        105,
        103,
        107,
        113,
        93,
        93,
        98,
        93,
        93,
        101
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 27
    },
    "28": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731711388505",
      "endTime": "928731711490466",
      "elapsedTime": "101961",
      "asyncId": 94,
      "triggerAsyncId": 74,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        95,
        95,
        100,
        95,
        95,
        118,
        124,
        117,
        116,
        115,
        122,
        126,
        130,
        95,
        100,
        102
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 28
    },
    "29": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731712660109",
      "endTime": "928731769704794",
      "elapsedTime": "57044685",
      "asyncId": 96,
      "triggerAsyncId": 75,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        104,
        119,
        122,
        120,
        124,
        128,
        97,
        97,
        102,
        117,
        120,
        118,
        122,
        126,
        97,
        106,
        97,
        97,
        102
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 29
    },
    "30": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731685027800",
      "endTime": "928731692903133",
      "elapsedTime": "7875333",
      "asyncId": 97,
      "triggerAsyncId": 75,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        138,
        131,
        131,
        130,
        129,
        136,
        140,
        156,
        98,
        98,
        104,
        108,
        110,
        116,
        107,
        114,
        130,
        118,
        98,
        98,
        100,
        98
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 30
    },
    "31": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731714141556",
      "endTime": "928731714373961",
      "elapsedTime": "232405",
      "asyncId": 99,
      "triggerAsyncId": 89,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        100,
        100,
        102,
        121,
        125,
        120,
        123,
        127,
        131,
        100,
        101
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 31
    },
    "32": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731641767114",
      "endTime": "928731838642724",
      "elapsedTime": "196875610",
      "asyncId": 100,
      "triggerAsyncId": 79,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        107,
        110,
        108,
        112,
        118,
        101,
        101,
        101,
        106
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 32
    },
    "33": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731685688558",
      "endTime": "928731713344863",
      "elapsedTime": "27656305",
      "asyncId": 103,
      "triggerAsyncId": 58,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        109,
        109,
        107,
        105,
        111
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 33
    },
    "34": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731639502018",
      "endTime": "928732324617864",
      "elapsedTime": "685115846",
      "asyncId": 104,
      "triggerAsyncId": 83,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        112,
        105,
        116,
        118,
        110
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 34
    },
    "35": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731687671836",
      "endTime": "928731759989672",
      "elapsedTime": "72317836",
      "asyncId": 105,
      "triggerAsyncId": 84,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        107,
        107,
        106,
        111
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 35
    },
    "36": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731694998190",
      "endTime": "928731713495615",
      "elapsedTime": "18497425",
      "asyncId": 109,
      "triggerAsyncId": 108,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        130,
        129,
        135,
        129,
        128,
        127,
        133,
        137,
        142,
        110,
        115,
        115
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 36
    },
    "37": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731697746021",
      "endTime": "928731722296102",
      "elapsedTime": "24550081",
      "asyncId": 110,
      "triggerAsyncId": 58,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        111,
        111,
        118
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 37
    },
    "38": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731722438299",
      "endTime": "928731735673079",
      "elapsedTime": "13234780",
      "asyncId": 111,
      "triggerAsyncId": 90,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        121,
        124,
        122,
        126,
        132,
        112,
        112,
        119
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 38
    },
    "39": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731723289865",
      "endTime": "928731735412190",
      "elapsedTime": "12122325",
      "asyncId": 112,
      "triggerAsyncId": 90,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        137,
        144,
        136,
        135,
        135,
        134,
        133,
        142,
        146,
        150,
        113,
        117
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 39
    },
    "40": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:31:28:31:28",
      "startTime": "928731724802150",
      "endTime": "928731732222740",
      "elapsedTime": "7420590",
      "asyncId": 113,
      "triggerAsyncId": 90,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        114,
        114,
        116
      ],
      "line": "\n      };\n\n      await roleController.getPermissions(ctx);\n\n      expect(findOne).toHaveBeenCalledWith({ id: ctx.params.id });\n      expect(notFound).toHaveBeenCalled()",
      "startLine": 31,
      "startCol": 28,
      "endLine": 31,
      "endCol": 28,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 40
    },
    "41": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:9:45:9:45",
      "startTime": "928731726253931",
      "endTime": "928731726398022",
      "elapsedTime": "144091",
      "asyncId": 114,
      "triggerAsyncId": 90,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        116,
        116,
        122,
        116,
        121,
        124,
        122,
        126,
        132,
        115,
        115,
        115
      ],
      "line": "\n  describe('getPermissions', () => {\n    test('Fails if role does not exist', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n      const notFound = jest.fn();\n\n      const ctx = createContext",
      "startLine": 9,
      "startCol": 45,
      "endLine": 9,
      "endCol": 45,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 41
    },
    "42": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:31:28:31:28",
      "startTime": "928731727205185",
      "endTime": "928731732384343",
      "elapsedTime": "5179158",
      "asyncId": 115,
      "triggerAsyncId": 114,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        121,
        117,
        126,
        121,
        123,
        121,
        140,
        134,
        133,
        138,
        142,
        146,
        116
      ],
      "line": "\n      };\n\n      await roleController.getPermissions(ctx);\n\n      expect(findOne).toHaveBeenCalledWith({ id: ctx.params.id });\n      expect(notFound).toHaveBeenCalled()",
      "startLine": 31,
      "startCol": 28,
      "endLine": 31,
      "endCol": 28,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 42
    },
    "43": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731727790542",
      "endTime": "928731735529279",
      "elapsedTime": "7738737",
      "asyncId": 116,
      "triggerAsyncId": 113,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        123,
        122,
        123,
        117,
        121
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 43
    },
    "44": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928731728456600",
      "endTime": "928731735799545",
      "elapsedTime": "7342945",
      "asyncId": 117,
      "triggerAsyncId": 112,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        119,
        118,
        118,
        120
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 44
    },
    "45": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731728949274",
      "endTime": "928731735927285",
      "elapsedTime": "6978011",
      "asyncId": 118,
      "triggerAsyncId": 90,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        124,
        125,
        128,
        126,
        130,
        136,
        119,
        119,
        119,
        124
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 45
    },
    "46": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731730072299",
      "endTime": "928731730219495",
      "elapsedTime": "147196",
      "asyncId": 120,
      "triggerAsyncId": 90,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        126,
        126,
        130,
        132,
        139,
        129,
        137,
        153,
        121,
        121,
        124
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 46
    },
    "47": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731702351564",
      "endTime": "928731705253785",
      "elapsedTime": "2902221",
      "asyncId": 121,
      "triggerAsyncId": 115,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        177,
        179,
        186,
        176,
        184,
        197,
        122,
        122,
        132,
        123,
        122,
        123
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 47
    },
    "48": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731731277699",
      "endTime": "928731736258546",
      "elapsedTime": "4980847",
      "asyncId": 122,
      "triggerAsyncId": 90,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        221,
        223,
        230,
        220,
        228,
        241,
        141,
        129,
        129,
        128,
        128,
        128
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 48
    },
    "49": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731731907690",
      "endTime": "928731736423826",
      "elapsedTime": "4516136",
      "asyncId": 124,
      "triggerAsyncId": 118,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        126,
        132
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 49
    },
    "50": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731739175254",
      "endTime": "928731768495968",
      "elapsedTime": "29320714",
      "asyncId": 127,
      "triggerAsyncId": 75,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        134,
        128,
        128,
        135,
        188,
        190,
        197,
        187,
        195,
        208,
        128,
        128,
        133,
        135
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 50
    },
    "51": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928731739779536",
      "endTime": "928731739920330",
      "elapsedTime": "140794",
      "asyncId": 128,
      "triggerAsyncId": 75,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        132,
        135,
        138,
        136,
        140,
        146,
        129,
        129,
        239,
        241,
        248,
        238,
        246,
        259,
        147
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 51
    },
    "52": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731708222600",
      "endTime": "928731708341784",
      "elapsedTime": "119184",
      "asyncId": 129,
      "triggerAsyncId": 108,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        137,
        138,
        131,
        147,
        150,
        148,
        152,
        156,
        130,
        130
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 52
    },
    "53": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731741217512",
      "endTime": "928731741332958",
      "elapsedTime": "115446",
      "asyncId": 130,
      "triggerAsyncId": 75,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        145,
        135,
        140,
        131,
        131,
        131,
        131
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 53
    },
    "54": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731741926541",
      "endTime": "928731756618102",
      "elapsedTime": "14691561",
      "asyncId": 131,
      "triggerAsyncId": 130,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        132,
        134,
        138,
        141,
        139,
        143,
        149,
        132,
        132,
        139,
        138,
        141,
        139,
        143,
        149,
        132,
        132
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 54
    },
    "55": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731742483816",
      "endTime": "928731768207697",
      "elapsedTime": "25723881",
      "asyncId": 132,
      "triggerAsyncId": 131,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        140,
        133,
        133,
        133,
        150,
        153,
        151,
        155,
        159,
        133,
        140,
        153,
        159,
        152,
        151,
        150,
        157,
        161,
        167,
        133
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 55
    },
    "56": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731743029458",
      "endTime": "928731768635349",
      "elapsedTime": "25605891",
      "asyncId": 133,
      "triggerAsyncId": 132,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        145,
        134,
        144,
        143,
        144,
        147,
        145,
        149,
        155,
        134,
        134,
        139,
        143,
        139
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 56
    },
    "57": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731743521731",
      "endTime": "928731768756346",
      "elapsedTime": "25234615",
      "asyncId": 134,
      "triggerAsyncId": 75,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        136,
        156,
        159,
        157,
        161,
        165,
        135,
        135,
        135,
        141,
        135,
        135,
        137
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 57
    },
    "58": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731744355815",
      "endTime": "928731744437869",
      "elapsedTime": "82054",
      "asyncId": 136,
      "triggerAsyncId": 75,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        141,
        137,
        142,
        142,
        139,
        157,
        163,
        156,
        155,
        154,
        161,
        165,
        169,
        137,
        143,
        146,
        144,
        148,
        154,
        137,
        137
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 58
    },
    "59": {
      "source": "node_modules/jest-runner/build/runTest.js:442:12:442:12",
      "startTime": "928731722619498",
      "endTime": "928731740374632",
      "elapsedTime": "17755134",
      "asyncId": 137,
      "triggerAsyncId": 47,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        147,
        138,
        155,
        158,
        156,
        160,
        164,
        138,
        152
      ],
      "line": "\n    } // Delay the resolution to allow log messages to be output.\n\n    return new Promise(resolve => {\n      setImmediate(() =>\n        resolve({\n          leakDetector",
      "startLine": 442,
      "startCol": 12,
      "endLine": 442,
      "endCol": 12,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 59
    },
    "60": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731750772013",
      "endTime": "928731750854377",
      "elapsedTime": "82364",
      "asyncId": 138,
      "triggerAsyncId": 131,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        139,
        140,
        139,
        139,
        145,
        144,
        140
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 60
    },
    "61": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731751373490",
      "endTime": "928731754994708",
      "elapsedTime": "3621218",
      "asyncId": 139,
      "triggerAsyncId": 131,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        145,
        150,
        153,
        151,
        155,
        161,
        140,
        140,
        144,
        151,
        147,
        145
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 61
    },
    "62": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731752234104",
      "endTime": "928731752334982",
      "elapsedTime": "100878",
      "asyncId": 141,
      "triggerAsyncId": 131,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        142,
        174,
        180,
        173,
        172,
        178,
        182,
        186,
        142,
        142
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 62
    },
    "63": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:446:34:446:34",
      "startTime": "928731730796226",
      "endTime": "928731730929837",
      "elapsedTime": "133611",
      "asyncId": 142,
      "triggerAsyncId": 47,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " DocumentImpl.close",
      "userCode": false,
      "triggers": [
        143,
        144,
        148,
        143,
        145
      ],
      "line": "\n    this._queue.resume();\n\n    const dummyPromise = Promise.resolve();\n\n    const onDOMContentLoad = () => {\n      const doc = this",
      "startLine": 446,
      "startCol": 34,
      "endLine": 446,
      "endCol": 34,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "uniqueid": 63
    },
    "64": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731753261269",
      "endTime": "928731756186362",
      "elapsedTime": "2925093",
      "asyncId": 143,
      "triggerAsyncId": 131,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        144,
        157,
        151,
        156,
        155,
        149,
        145,
        148,
        144
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 64
    },
    "65": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731753838110",
      "endTime": "928731756264709",
      "elapsedTime": "2426599",
      "asyncId": 145,
      "triggerAsyncId": 139,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        146,
        151,
        146
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 65
    },
    "66": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:456:14:456:14",
      "startTime": "928731735280242",
      "endTime": "928731735549016",
      "elapsedTime": "268774",
      "asyncId": 148,
      "triggerAsyncId": 143,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " onDOMContentLoad",
      "userCode": false,
      "triggers": [
        149,
        149,
        157,
        160,
        158,
        162,
        168,
        149,
        149,
        169,
        168,
        174,
        168,
        167,
        166,
        172,
        176,
        181,
        149,
        154,
        149
      ],
      "line": "\n      }\n\n      return new Promise(resolve => {\n        if (!this._deferQueue.tail) {\n          dispatchEvent();\n          return resolve()",
      "startLine": 456,
      "startCol": 14,
      "endLine": 456,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "uniqueid": 66
    },
    "67": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731757219098",
      "endTime": "928731767319913",
      "elapsedTime": "10100815",
      "asyncId": 150,
      "triggerAsyncId": 132,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        151,
        179,
        182,
        180,
        184,
        188,
        151,
        151,
        152,
        152,
        151,
        151,
        151,
        158
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 67
    },
    "68": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731757863096",
      "endTime": "928731767056610",
      "elapsedTime": "9193514",
      "asyncId": 151,
      "triggerAsyncId": 132,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        152,
        189,
        192,
        190,
        194,
        198,
        152,
        157,
        157,
        152,
        158,
        161,
        159,
        163,
        169,
        152,
        152,
        156
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 68
    },
    "69": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:70:28:70:28",
      "startTime": "928731758520087",
      "endTime": "928731766147906",
      "elapsedTime": "7627819",
      "asyncId": 152,
      "triggerAsyncId": 132,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        153,
        177,
        171,
        170,
        175,
        179,
        183,
        153,
        155
      ],
      "line": "\n      };\n\n      await roleController.getPermissions(ctx);\n\n      expect(findOneRole).toHaveBeenCalledWith({ id: ctx.params.id });\n      expect(findPermissions).toHaveBeenCalledWith({ role: ctx.params.id, _limit: -1 })",
      "startLine": 70,
      "startCol": 28,
      "endLine": 70,
      "endCol": 28,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 69
    },
    "70": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:48:49:48:49",
      "startTime": "928731759113289",
      "endTime": "928731759219618",
      "elapsedTime": "106329",
      "asyncId": 153,
      "triggerAsyncId": 132,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        163,
        154
      ],
      "line": "\n      ];\n\n      const findOneRole = jest.fn(() => Promise.resolve({ id: 1 }));\n      const findPermissions = jest.fn(() => Promise.resolve(permissions));\n      const sanitizePermission = jest.fn(perms => perms);",
      "startLine": 48,
      "startCol": 49,
      "endLine": 48,
      "endCol": 49,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 70
    },
    "71": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:70:28:70:28",
      "startTime": "928731759734594",
      "endTime": "928731764715661",
      "elapsedTime": "4981067",
      "asyncId": 154,
      "triggerAsyncId": 153,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        165,
        164,
        156,
        160,
        162,
        160,
        164
      ],
      "line": "\n      };\n\n      await roleController.getPermissions(ctx);\n\n      expect(findOneRole).toHaveBeenCalledWith({ id: ctx.params.id });\n      expect(findPermissions).toHaveBeenCalledWith({ role: ctx.params.id, _limit: -1 })",
      "startLine": 70,
      "startCol": 28,
      "endLine": 70,
      "endCol": 28,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 71
    },
    "72": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731760185068",
      "endTime": "928731767214896",
      "elapsedTime": "7029828",
      "asyncId": 155,
      "triggerAsyncId": 152,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        161,
        160,
        160,
        157
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 72
    },
    "73": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928731760615876",
      "endTime": "928731767450798",
      "elapsedTime": "6834922",
      "asyncId": 156,
      "triggerAsyncId": 151,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        158,
        157,
        161,
        159,
        159,
        162
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 73
    },
    "74": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731761111766",
      "endTime": "928731767570803",
      "elapsedTime": "6459037",
      "asyncId": 157,
      "triggerAsyncId": 132,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        159,
        163,
        165,
        158,
        158,
        158,
        158,
        163
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 74
    },
    "75": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731761887860",
      "endTime": "928731761987878",
      "elapsedTime": "100018",
      "asyncId": 159,
      "triggerAsyncId": 132,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        162,
        207,
        209,
        215,
        165,
        206,
        213,
        226,
        177
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 75
    },
    "76": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731689252399",
      "endTime": "928731749448852",
      "elapsedTime": "60196453",
      "asyncId": 160,
      "triggerAsyncId": 154,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        163,
        161,
        161,
        168,
        161
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 76
    },
    "77": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731762814247",
      "endTime": "928731767807828",
      "elapsedTime": "4993581",
      "asyncId": 161,
      "triggerAsyncId": 132,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        168,
        171,
        169,
        173,
        179,
        162,
        162,
        162,
        167
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 77
    },
    "78": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731690489979",
      "endTime": "928731749974989",
      "elapsedTime": "59485010",
      "asyncId": 162,
      "triggerAsyncId": 71,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        180,
        183,
        181,
        185,
        189,
        163,
        164
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 78
    },
    "79": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731763432105",
      "endTime": "928731767894590",
      "elapsedTime": "4462485",
      "asyncId": 163,
      "triggerAsyncId": 157,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        164,
        164,
        169,
        171
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 79
    },
    "80": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:49:53:49:53",
      "startTime": "928731764099246",
      "endTime": "928731764207358",
      "elapsedTime": "108112",
      "asyncId": 164,
      "triggerAsyncId": 154,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        174,
        171,
        174,
        172,
        176,
        182,
        165,
        165,
        165
      ],
      "line": "\n\n      const findOneRole = jest.fn(() => Promise.resolve({ id: 1 }));\n      const findPermissions = jest.fn(() => Promise.resolve(permissions));\n      const sanitizePermission = jest.fn(perms => perms);\n\n      const ctx = createContext(",
      "startLine": 49,
      "startCol": 53,
      "endLine": 49,
      "endCol": 53,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 80
    },
    "81": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731764611165",
      "endTime": "928731766295573",
      "elapsedTime": "1684408",
      "asyncId": 165,
      "triggerAsyncId": 164,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        166,
        183,
        186,
        184,
        188,
        192,
        166,
        173
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 81
    },
    "82": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928731740590677",
      "endTime": "928731740702807",
      "elapsedTime": "112130",
      "asyncId": 166,
      "triggerAsyncId": 84,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        167,
        168,
        173,
        167,
        167,
        174
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 82
    },
    "83": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731771286509",
      "endTime": "928732135828974",
      "elapsedTime": "364542465",
      "asyncId": 168,
      "triggerAsyncId": 60,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        169,
        169,
        170,
        170,
        190,
        197,
        189,
        188,
        187,
        186,
        195,
        199,
        203,
        169,
        169,
        169,
        179
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 83
    },
    "84": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731771765186",
      "endTime": "928732135868127",
      "elapsedTime": "364102941",
      "asyncId": 169,
      "triggerAsyncId": 60,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        176,
        175,
        170,
        171,
        179,
        175,
        170,
        170,
        176,
        179,
        177,
        181,
        187,
        170,
        170,
        176,
        176
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 84
    },
    "85": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928731772356755",
      "endTime": "928731772478563",
      "elapsedTime": "121808",
      "asyncId": 170,
      "triggerAsyncId": 60,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        171,
        176,
        183,
        182,
        182,
        180,
        183,
        181,
        185,
        191,
        171,
        171,
        178,
        176,
        188,
        191,
        189,
        193,
        197,
        171
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 85
    },
    "86": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731744421438",
      "endTime": "928731758990198",
      "elapsedTime": "14568760",
      "asyncId": 171,
      "triggerAsyncId": 170,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        172,
        173,
        194,
        199,
        193,
        192,
        197,
        201,
        205,
        172,
        172,
        174
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 86
    },
    "87": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731773521889",
      "endTime": "928731773588294",
      "elapsedTime": "66405",
      "asyncId": 172,
      "triggerAsyncId": 60,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        173,
        178,
        178,
        179,
        173,
        173,
        173
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 87
    },
    "88": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731774106986",
      "endTime": "928731835912125",
      "elapsedTime": "61805139",
      "asyncId": 173,
      "triggerAsyncId": 172,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        177,
        174,
        174,
        183,
        185,
        191,
        182,
        189,
        205,
        174,
        174
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 88
    },
    "89": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731774609137",
      "endTime": "928731927417159",
      "elapsedTime": "152808022",
      "asyncId": 174,
      "triggerAsyncId": 173,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        180,
        179,
        175,
        176,
        181,
        184,
        182,
        186,
        192,
        175,
        175,
        275,
        277,
        283,
        274,
        281,
        294,
        175,
        175
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 89
    },
    "90": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731775173405",
      "endTime": "928732135129202",
      "elapsedTime": "359955797",
      "asyncId": 175,
      "triggerAsyncId": 174,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        178,
        176,
        181,
        196,
        202,
        195,
        194,
        193,
        200,
        204,
        208,
        176,
        181,
        456,
        458,
        464,
        455,
        462,
        475,
        193
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 90
    },
    "91": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731775639820",
      "endTime": "928732135223699",
      "elapsedTime": "359583879",
      "asyncId": 176,
      "triggerAsyncId": 169,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        177,
        185,
        178,
        177
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 91
    },
    "92": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731776073142",
      "endTime": "928732135905147",
      "elapsedTime": "359832005",
      "asyncId": 177,
      "triggerAsyncId": 176,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        183
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 92
    },
    "93": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731776574822",
      "endTime": "928732135953938",
      "elapsedTime": "359379116",
      "asyncId": 178,
      "triggerAsyncId": 60,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        184
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 93
    },
    "94": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731777286867",
      "endTime": "928731777332522",
      "elapsedTime": "45655",
      "asyncId": 180,
      "triggerAsyncId": 60,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        181,
        186,
        188,
        191,
        189,
        193,
        199,
        181,
        181,
        182,
        182
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 94
    },
    "95": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731749528031",
      "endTime": "928731751942737",
      "elapsedTime": "2414706",
      "asyncId": 181,
      "triggerAsyncId": 169,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        182,
        200,
        203,
        201,
        205,
        209,
        182,
        182,
        187,
        187,
        183
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 95
    },
    "96": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731778166195",
      "endTime": "928731835472731",
      "elapsedTime": "57306536",
      "asyncId": 182,
      "triggerAsyncId": 173,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        183,
        210,
        213,
        211,
        215,
        219,
        183,
        184,
        188,
        190
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 96
    },
    "97": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928731778664459",
      "endTime": "928731778749699",
      "elapsedTime": "85240",
      "asyncId": 183,
      "triggerAsyncId": 173,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        184,
        184,
        185,
        185
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 97
    },
    "98": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731746963984",
      "endTime": "928731766043591",
      "elapsedTime": "19079607",
      "asyncId": 184,
      "triggerAsyncId": 60,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        191,
        190,
        190,
        192,
        185,
        187,
        186,
        186,
        190,
        192
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 98
    },
    "99": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731779806911",
      "endTime": "928731779881180",
      "elapsedTime": "74269",
      "asyncId": 185,
      "triggerAsyncId": 173,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        186,
        186,
        186
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 99
    },
    "100": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731780361891",
      "endTime": "928731789694867",
      "elapsedTime": "9332976",
      "asyncId": 186,
      "triggerAsyncId": 185,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        187,
        188,
        196,
        196,
        199,
        197,
        201,
        207,
        187,
        187
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 100
    },
    "101": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731780816894",
      "endTime": "928731835239845",
      "elapsedTime": "54422951",
      "asyncId": 187,
      "triggerAsyncId": 186,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        188,
        189,
        196,
        194,
        188,
        188,
        211,
        217,
        210,
        209,
        208,
        215,
        219,
        235,
        188
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 101
    },
    "102": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731781240428",
      "endTime": "928731835550938",
      "elapsedTime": "54310510",
      "asyncId": 188,
      "triggerAsyncId": 187,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        190,
        204,
        193,
        195,
        198,
        196,
        190,
        200,
        206,
        189,
        189
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 102
    },
    "103": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731781627384",
      "endTime": "928731835619667",
      "elapsedTime": "53992283",
      "asyncId": 189,
      "triggerAsyncId": 173,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        191,
        195,
        192,
        195,
        214,
        208,
        207,
        212,
        216,
        220,
        190
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 103
    },
    "104": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731782401114",
      "endTime": "928731782478329",
      "elapsedTime": "77215",
      "asyncId": 191,
      "triggerAsyncId": 173,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        194,
        199,
        202,
        200,
        204,
        210,
        192,
        192
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 104
    },
    "105": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731783325727",
      "endTime": "928732135272861",
      "elapsedTime": "351947134",
      "asyncId": 193,
      "triggerAsyncId": 175,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        194,
        194,
        194,
        194,
        201,
        224,
        231,
        223,
        222,
        221,
        229,
        233,
        237,
        194,
        196,
        201
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 105
    },
    "106": {
      "source": "node_modules/jest-each/build/bind.js:76:13:76:13",
      "startTime": "928731716242494",
      "endTime": "928731724466401",
      "elapsedTime": "8223907",
      "asyncId": 194,
      "triggerAsyncId": 175,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        201,
        204,
        202,
        206,
        212,
        195,
        195,
        201,
        204,
        202,
        206,
        212,
        195,
        195,
        195,
        199
      ],
      "line": "\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-each/build/bind.js",
      "uniqueid": 106
    },
    "107": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731784475392",
      "endTime": "928731784602160",
      "elapsedTime": "126768",
      "asyncId": 196,
      "triggerAsyncId": 186,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        198,
        197,
        197,
        197,
        202,
        198
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 107
    },
    "108": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731785038919",
      "endTime": "928731788315932",
      "elapsedTime": "3277013",
      "asyncId": 197,
      "triggerAsyncId": 186,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        203,
        204,
        207,
        205,
        209,
        215,
        198,
        198,
        203,
        203
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 108
    },
    "109": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731761506756",
      "endTime": "928731802306759",
      "elapsedTime": "40800003",
      "asyncId": 198,
      "triggerAsyncId": 64,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        216,
        219,
        217,
        221,
        225,
        199,
        208
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 109
    },
    "110": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731761922575",
      "endTime": "928731802377762",
      "elapsedTime": "40455187",
      "asyncId": 199,
      "triggerAsyncId": 64,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        209,
        201,
        205,
        205
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 110
    },
    "111": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928731762407184",
      "endTime": "928731762504516",
      "elapsedTime": "97332",
      "asyncId": 200,
      "triggerAsyncId": 64,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        202,
        206,
        206
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 111
    },
    "112": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731786721523",
      "endTime": "928731789261675",
      "elapsedTime": "2540152",
      "asyncId": 201,
      "triggerAsyncId": 186,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        207,
        203,
        203
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 112
    },
    "113": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731763457372",
      "endTime": "928731763514710",
      "elapsedTime": "57338",
      "asyncId": 202,
      "triggerAsyncId": 64,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        203,
        203,
        208,
        208,
        203,
        203
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 113
    },
    "114": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731787335834",
      "endTime": "928731789364287",
      "elapsedTime": "2028453",
      "asyncId": 203,
      "triggerAsyncId": 197,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        212,
        215,
        213,
        217,
        223,
        204,
        204,
        212,
        214,
        220,
        211,
        218,
        234,
        204,
        204
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 114
    },
    "115": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731764519363",
      "endTime": "928731801839854",
      "elapsedTime": "37320491",
      "asyncId": 204,
      "triggerAsyncId": 203,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        224,
        227,
        225,
        229,
        233,
        205,
        205,
        206,
        205,
        248,
        250,
        256,
        247,
        254,
        267,
        222
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 115
    },
    "116": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731765382832",
      "endTime": "928731802491826",
      "elapsedTime": "37108994",
      "asyncId": 206,
      "triggerAsyncId": 205,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        216,
        244,
        247,
        245,
        249,
        253,
        207,
        214,
        214
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 116
    },
    "117": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731765920760",
      "endTime": "928731802625897",
      "elapsedTime": "36705137",
      "asyncId": 207,
      "triggerAsyncId": 64,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        213
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 117
    },
    "118": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731790247443",
      "endTime": "928731834513132",
      "elapsedTime": "44265689",
      "asyncId": 208,
      "triggerAsyncId": 187,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        209,
        211,
        216
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 118
    },
    "119": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731790890859",
      "endTime": "928731834301315",
      "elapsedTime": "43410456",
      "asyncId": 209,
      "triggerAsyncId": 187,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        210,
        210,
        210,
        210,
        210,
        210,
        217,
        210,
        214
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 119
    },
    "120": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:103:28:103:28",
      "startTime": "928731791621348",
      "endTime": "928731833573651",
      "elapsedTime": "41952303",
      "asyncId": 210,
      "triggerAsyncId": 187,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        219,
        222,
        220,
        224,
        230,
        211,
        211,
        212,
        217,
        220,
        218,
        222,
        228,
        211,
        211,
        217,
        220,
        218,
        222,
        228,
        211,
        211,
        213
      ],
      "line": "\n      };\n\n      await roleController.updatePermissions(ctx);\n\n      expect(badRequest).toHaveBeenCalledWith(\n        'ValidationError'",
      "startLine": 103,
      "startCol": 28,
      "endLine": 103,
      "endCol": 28,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 120
    },
    "121": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:83:45:83:45",
      "startTime": "928731792222545",
      "endTime": "928731792342250",
      "elapsedTime": "119705",
      "asyncId": 211,
      "triggerAsyncId": 187,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        231,
        234,
        232,
        236,
        240,
        212,
        212,
        217,
        213,
        233,
        240,
        232,
        231,
        230,
        229,
        238,
        242,
        246,
        212,
        232,
        238,
        231,
        230,
        229,
        236,
        240,
        247,
        212,
        219,
        212
      ],
      "line": "\n    test('Fails on missing permissions input', async () => {\n      const badRequest = jest.fn();\n      const findOne = jest.fn(() => Promise.resolve({ id: 1 }));\n\n      const ctx = createContext(\n        ",
      "startLine": 83,
      "startCol": 45,
      "endLine": 83,
      "endCol": 45,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 121
    },
    "122": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:103:28:103:28",
      "startTime": "928731792815507",
      "endTime": "928731806816643",
      "elapsedTime": "14001136",
      "asyncId": 212,
      "triggerAsyncId": 211,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        250,
        243,
        243,
        214,
        242,
        241,
        248,
        252,
        268,
        213,
        213,
        218,
        213,
        213,
        218,
        223,
        226,
        222,
        222
      ],
      "line": "\n      };\n\n      await roleController.updatePermissions(ctx);\n\n      expect(badRequest).toHaveBeenCalledWith(\n        'ValidationError'",
      "startLine": 103,
      "startCol": 28,
      "endLine": 103,
      "endCol": 28,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 122
    },
    "123": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731793303572",
      "endTime": "928731834409298",
      "elapsedTime": "41105726",
      "asyncId": 213,
      "triggerAsyncId": 210,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        219,
        291,
        294,
        292,
        296,
        300,
        214,
        220,
        215,
        220,
        223,
        221,
        225,
        231,
        214,
        214
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 123
    },
    "124": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928731793733157",
      "endTime": "928731834624401",
      "elapsedTime": "40891244",
      "asyncId": 214,
      "triggerAsyncId": 209,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        218,
        220,
        235,
        241,
        234,
        233,
        232,
        239,
        243,
        247,
        215,
        215,
        215
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 124
    },
    "125": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731794099544",
      "endTime": "928731834710272",
      "elapsedTime": "40610728",
      "asyncId": 215,
      "triggerAsyncId": 187,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        217,
        225,
        228,
        226,
        230,
        236,
        216,
        216,
        221
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 125
    },
    "126": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731794885918",
      "endTime": "928731794992578",
      "elapsedTime": "106660",
      "asyncId": 217,
      "triggerAsyncId": 187,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        229,
        223,
        219,
        219
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 126
    },
    "127": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731771218491",
      "endTime": "928731785203778",
      "elapsedTime": "13985287",
      "asyncId": 218,
      "triggerAsyncId": 203,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        224,
        224
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 127
    },
    "128": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731795850276",
      "endTime": "928731834903514",
      "elapsedTime": "39053238",
      "asyncId": 219,
      "triggerAsyncId": 187,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        221,
        225
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 128
    },
    "129": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731771977143",
      "endTime": "928731772089184",
      "elapsedTime": "112041",
      "asyncId": 220,
      "triggerAsyncId": 203,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        226,
        229,
        222
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 129
    },
    "130": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731797303931",
      "endTime": "928731834996228",
      "elapsedTime": "37692297",
      "asyncId": 221,
      "triggerAsyncId": 215,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        230,
        227,
        223
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 130
    },
    "131": {
      "source": "packages/strapi-admin/controllers/role.js:110:13:110:13",
      "startTime": "928731798119660",
      "endTime": "928731833362465",
      "elapsedTime": "35242805",
      "asyncId": 222,
      "triggerAsyncId": 212,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.updatePermissions",
      "userCode": false,
      "triggers": [
        228,
        233
      ],
      "line": "\n        throw formatYupErrors(err);\n      }\n      await validatedUpdatePermissionsInput(input, role);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    ",
      "startLine": 110,
      "startCol": 13,
      "endLine": 110,
      "endCol": 13,
      "file": "packages/strapi-admin/controllers/role.js",
      "uniqueid": 131
    },
    "132": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731800712670",
      "endTime": "928731800828568",
      "elapsedTime": "115898",
      "asyncId": 223,
      "triggerAsyncId": 212,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        224,
        224,
        231,
        226,
        224
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 132
    },
    "133": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731801603480",
      "endTime": "928731807733742",
      "elapsedTime": "6130262",
      "asyncId": 224,
      "triggerAsyncId": 223,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        226,
        232,
        235,
        233,
        237,
        243,
        225,
        225,
        225,
        225
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 133
    },
    "134": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731802577947",
      "endTime": "928731807898391",
      "elapsedTime": "5320444",
      "asyncId": 225,
      "triggerAsyncId": 224,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        231,
        244,
        247,
        245,
        249,
        253,
        226,
        226,
        227,
        227
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 134
    },
    "135": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731803182891",
      "endTime": "928731807987217",
      "elapsedTime": "4804326",
      "asyncId": 226,
      "triggerAsyncId": 212,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        254,
        257,
        255,
        259,
        263,
        227,
        227,
        227,
        234,
        227,
        232,
        228
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 135
    },
    "136": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731804316666",
      "endTime": "928731808225734",
      "elapsedTime": "3909068",
      "asyncId": 228,
      "triggerAsyncId": 226,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        246,
        249,
        247,
        251,
        255,
        229,
        229,
        229
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 136
    },
    "137": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731804818858",
      "endTime": "928731817262785",
      "elapsedTime": "12443927",
      "asyncId": 229,
      "triggerAsyncId": 228,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        230,
        230,
        230,
        235,
        239,
        237,
        244,
        236,
        238,
        242,
        230
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 137
    },
    "138": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928731805837237",
      "endTime": "928731831775110",
      "elapsedTime": "25937873",
      "asyncId": 231,
      "triggerAsyncId": 230,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        233,
        232,
        249,
        252,
        250,
        254,
        258,
        232,
        247,
        236,
        234,
        239,
        247,
        250,
        257,
        232
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 138
    },
    "139": {
      "source": "packages/strapi-admin/controllers/role.js:110:13:110:13",
      "startTime": "928731806281630",
      "endTime": "928731832762531",
      "elapsedTime": "26480901",
      "asyncId": 232,
      "triggerAsyncId": 231,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.updatePermissions",
      "userCode": false,
      "triggers": [
        238,
        234,
        235,
        233,
        240,
        233,
        272
      ],
      "line": "\n        throw formatYupErrors(err);\n      }\n      await validatedUpdatePermissionsInput(input, role);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    ",
      "startLine": 110,
      "startCol": 13,
      "endLine": 110,
      "endCol": 13,
      "file": "packages/strapi-admin/controllers/role.js",
      "uniqueid": 139
    },
    "140": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731806717367",
      "endTime": "928731833682575",
      "elapsedTime": "26965208",
      "asyncId": 233,
      "triggerAsyncId": 222,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        239,
        234,
        244,
        243,
        243,
        238
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 140
    },
    "141": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:446:34:446:34",
      "startTime": "928731794159807",
      "endTime": "928731794261738",
      "elapsedTime": "101931",
      "asyncId": 234,
      "triggerAsyncId": 47,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " DocumentImpl.close",
      "userCode": false,
      "triggers": [
        236,
        249,
        236,
        237,
        235,
        237
      ],
      "line": "\n    this._queue.resume();\n\n    const dummyPromise = Promise.resolve();\n\n    const onDOMContentLoad = () => {\n      const doc = this",
      "startLine": 446,
      "startCol": 34,
      "endLine": 446,
      "endCol": 34,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "uniqueid": 141
    },
    "142": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731809873844",
      "endTime": "928731809976086",
      "elapsedTime": "102242",
      "asyncId": 236,
      "triggerAsyncId": 229,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        244,
        242,
        237
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 142
    },
    "143": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731810441017",
      "endTime": "928731816018402",
      "elapsedTime": "5577385",
      "asyncId": 237,
      "triggerAsyncId": 236,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        238,
        239,
        239,
        238,
        240
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 143
    },
    "144": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731811065137",
      "endTime": "928731811125440",
      "elapsedTime": "60303",
      "asyncId": 238,
      "triggerAsyncId": 229,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        244,
        247,
        244,
        244,
        239
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 144
    },
    "145": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731811580884",
      "endTime": "928731816104073",
      "elapsedTime": "4523189",
      "asyncId": 239,
      "triggerAsyncId": 238,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        240,
        242,
        245,
        241
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 145
    },
    "146": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731812072545",
      "endTime": "928731816496168",
      "elapsedTime": "4423623",
      "asyncId": 240,
      "triggerAsyncId": 237,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        245,
        241,
        241,
        243
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 146
    },
    "147": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731812574647",
      "endTime": "928731816603129",
      "elapsedTime": "4028482",
      "asyncId": 241,
      "triggerAsyncId": 239,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        249,
        242,
        242,
        242,
        244
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 147
    },
    "148": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731814629048",
      "endTime": "928731816759271",
      "elapsedTime": "2130223",
      "asyncId": 242,
      "triggerAsyncId": 229,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        247,
        243,
        250,
        253,
        251,
        255,
        261,
        243,
        243,
        243,
        245
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 148
    },
    "149": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731815821002",
      "endTime": "928731817016293",
      "elapsedTime": "1195291",
      "asyncId": 245,
      "triggerAsyncId": 242,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        257,
        256,
        255,
        251,
        251,
        246,
        246
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 149
    },
    "150": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731816415547",
      "endTime": "928731817342515",
      "elapsedTime": "926968",
      "asyncId": 246,
      "triggerAsyncId": 245,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        247,
        248
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 150
    },
    "151": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731818929530",
      "endTime": "928731818984112",
      "elapsedTime": "54582",
      "asyncId": 247,
      "triggerAsyncId": 231,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        248,
        253,
        248,
        255,
        248
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 151
    },
    "152": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731819367831",
      "endTime": "928731823966542",
      "elapsedTime": "4598711",
      "asyncId": 248,
      "triggerAsyncId": 247,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        254,
        256,
        249
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 152
    },
    "153": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731819739919",
      "endTime": "928731824387621",
      "elapsedTime": "4647702",
      "asyncId": 249,
      "triggerAsyncId": 248,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        251,
        257,
        258,
        251
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 153
    },
    "154": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731820107307",
      "endTime": "928731824489282",
      "elapsedTime": "4381975",
      "asyncId": 250,
      "triggerAsyncId": 231,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        256,
        252,
        255,
        255,
        251,
        251,
        252
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 154
    },
    "155": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731820887149",
      "endTime": "928731824652237",
      "elapsedTime": "3765088",
      "asyncId": 252,
      "triggerAsyncId": 250,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        253,
        253,
        259,
        262,
        260,
        264,
        270,
        253,
        253,
        270,
        273,
        271,
        275,
        279,
        253,
        253,
        253
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 155
    },
    "156": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731821279204",
      "endTime": "928731830776588",
      "elapsedTime": "9497384",
      "asyncId": 253,
      "triggerAsyncId": 252,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        260,
        263,
        261,
        265,
        271,
        254,
        254,
        254,
        274,
        280,
        273,
        272,
        271,
        278,
        282,
        286,
        254,
        254,
        261,
        263,
        267,
        254
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 156
    },
    "157": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928731822072712",
      "endTime": "928731831172861",
      "elapsedTime": "9100149",
      "asyncId": 255,
      "triggerAsyncId": 254,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        269,
        261,
        261,
        261,
        256,
        256
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 157
    },
    "158": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731822543314",
      "endTime": "928731831258942",
      "elapsedTime": "8715628",
      "asyncId": 256,
      "triggerAsyncId": 255,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        266,
        264,
        258
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 158
    },
    "159": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731822969463",
      "endTime": "928731831325627",
      "elapsedTime": "8356164",
      "asyncId": 257,
      "triggerAsyncId": 231,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        258,
        259
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 159
    },
    "160": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731823764754",
      "endTime": "928731831515924",
      "elapsedTime": "7751170",
      "asyncId": 259,
      "triggerAsyncId": 257,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        260,
        268,
        270,
        278,
        267,
        276,
        292,
        260,
        260,
        260,
        260,
        267,
        261,
        265,
        260
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 160
    },
    "161": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731824301620",
      "endTime": "928731831861021",
      "elapsedTime": "7559401",
      "asyncId": 260,
      "triggerAsyncId": 259,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        261,
        261,
        326,
        328,
        336,
        325,
        334,
        347,
        280,
        267,
        270,
        268,
        272,
        278,
        261,
        261,
        262,
        266
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 161
    },
    "162": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731825145181",
      "endTime": "928731825246361",
      "elapsedTime": "101180",
      "asyncId": 261,
      "triggerAsyncId": 253,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        271,
        270,
        270,
        272,
        262,
        262,
        279,
        282,
        280,
        284,
        288,
        262,
        267,
        269,
        262
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 162
    },
    "163": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731825614772",
      "endTime": "928731829685082",
      "elapsedTime": "4070310",
      "asyncId": 262,
      "triggerAsyncId": 261,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        263,
        263,
        263,
        264,
        265
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 163
    },
    "164": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731826099691",
      "endTime": "928731826192605",
      "elapsedTime": "92914",
      "asyncId": 263,
      "triggerAsyncId": 253,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        264,
        270,
        273,
        271,
        275,
        281,
        264,
        264,
        269,
        264
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 164
    },
    "165": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731826645774",
      "endTime": "928731829770011",
      "elapsedTime": "3124237",
      "asyncId": 264,
      "triggerAsyncId": 263,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        265,
        277,
        282,
        285,
        283,
        287,
        291,
        265,
        265,
        265,
        266
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 165
    },
    "166": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731827036367",
      "endTime": "928731830146356",
      "elapsedTime": "3109989",
      "asyncId": 265,
      "triggerAsyncId": 262,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        274,
        274,
        275,
        278,
        276,
        280,
        286,
        266,
        266,
        268
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 166
    },
    "167": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731827455492",
      "endTime": "928731830252135",
      "elapsedTime": "2796643",
      "asyncId": 266,
      "triggerAsyncId": 264,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        277,
        276,
        289,
        294,
        288,
        287,
        292,
        296,
        300,
        267,
        269
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 167
    },
    "168": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731827855191",
      "endTime": "928731830375426",
      "elapsedTime": "2520235",
      "asyncId": 267,
      "triggerAsyncId": 253,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        277,
        269,
        270
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 168
    },
    "169": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731829016769",
      "endTime": "928731830573808",
      "elapsedTime": "1557039",
      "asyncId": 270,
      "triggerAsyncId": 267,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        273,
        271,
        271,
        328,
        330,
        337,
        327,
        335,
        348,
        271,
        271,
        272,
        272,
        271
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 169
    },
    "170": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731830054765",
      "endTime": "928731830856598",
      "elapsedTime": "801833",
      "asyncId": 271,
      "triggerAsyncId": 270,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        274,
        283,
        286,
        284,
        288,
        294,
        272,
        272,
        372,
        374,
        381,
        371,
        379,
        392,
        272,
        272,
        277,
        279,
        277
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 170
    },
    "171": {
      "source": "packages/strapi-admin/validation/permission.js:13:39:13:39",
      "startTime": "928731832301827",
      "endTime": "928731832387027",
      "elapsedTime": "85200",
      "asyncId": 272,
      "triggerAsyncId": 232,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " handleReject",
      "userCode": false,
      "triggers": [
        275,
        295,
        298,
        296,
        300,
        304,
        273,
        273,
        416,
        418,
        425,
        415,
        423,
        436,
        273,
        273,
        280,
        282,
        277,
        273
      ],
      "line": "\nconst validators = require('./common-validators');\n\nconst handleReject = error => Promise.reject(formatYupErrors(error));\n\n// validatedUpdatePermissionsInput",
      "startLine": 13,
      "startCol": 39,
      "endLine": 13,
      "endCol": 39,
      "file": "packages/strapi-admin/validation/permission.js",
      "uniqueid": 171
    },
    "172": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731833101546",
      "endTime": "928731833458936",
      "elapsedTime": "357390",
      "asyncId": 273,
      "triggerAsyncId": 272,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        305,
        308,
        306,
        310,
        314,
        274,
        274,
        460,
        462,
        469,
        459,
        467,
        480,
        292,
        278,
        280,
        276
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 172
    },
    "173": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731836338484",
      "endTime": "928731926797687",
      "elapsedTime": "90459203",
      "asyncId": 274,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        315,
        318,
        316,
        320,
        324,
        275,
        275,
        277,
        290,
        279,
        275,
        282
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 173
    },
    "174": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928731836865973",
      "endTime": "928731836915706",
      "elapsedTime": "49733",
      "asyncId": 275,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        276,
        278,
        277
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 174
    },
    "175": {
      "source": "node_modules/jest-each/build/bind.js:76:13:76:13",
      "startTime": "928731767902696",
      "endTime": "928731772898521",
      "elapsedTime": "4995825",
      "asyncId": 276,
      "triggerAsyncId": 273,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        286,
        286,
        277,
        282
      ],
      "line": "\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-each/build/bind.js",
      "uniqueid": 175
    },
    "176": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731837875866",
      "endTime": "928731837956016",
      "elapsedTime": "80150",
      "asyncId": 277,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        278,
        278,
        278
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 176
    },
    "177": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731838470230",
      "endTime": "928731849194393",
      "elapsedTime": "10724163",
      "asyncId": 278,
      "triggerAsyncId": 277,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        279,
        284,
        285,
        288,
        286,
        290,
        296,
        279,
        279
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 177
    },
    "178": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731838956792",
      "endTime": "928731926622078",
      "elapsedTime": "87665286",
      "asyncId": 279,
      "triggerAsyncId": 278,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        280,
        281,
        285,
        300,
        306,
        299,
        298,
        297,
        304,
        308,
        324,
        280
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 178
    },
    "179": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731839369767",
      "endTime": "928731926871185",
      "elapsedTime": "87501418",
      "asyncId": 280,
      "triggerAsyncId": 279,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        281,
        281,
        289,
        286,
        290
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 179
    },
    "180": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731839770117",
      "endTime": "928731926942579",
      "elapsedTime": "87172462",
      "asyncId": 281,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        288,
        287,
        282,
        287,
        287,
        287
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 180
    },
    "181": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731840598019",
      "endTime": "928731840679562",
      "elapsedTime": "81543",
      "asyncId": 283,
      "triggerAsyncId": 174,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        284,
        285,
        284,
        284,
        289
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 181
    },
    "182": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731805259063",
      "endTime": "928731805364951",
      "elapsedTime": "105888",
      "asyncId": 284,
      "triggerAsyncId": 65,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        285,
        290,
        295,
        298,
        296,
        300,
        306,
        285,
        285,
        285,
        285
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 182
    },
    "183": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731841534514",
      "endTime": "928731841623702",
      "elapsedTime": "89188",
      "asyncId": 285,
      "triggerAsyncId": 278,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        307,
        310,
        308,
        312,
        316,
        286,
        286,
        294,
        296,
        302,
        293,
        300,
        316,
        286,
        286,
        287
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 183
    },
    "184": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731841991802",
      "endTime": "928731848461630",
      "elapsedTime": "6469828",
      "asyncId": 286,
      "triggerAsyncId": 278,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        317,
        320,
        318,
        322,
        326,
        287,
        287,
        291,
        293,
        330,
        332,
        338,
        329,
        336,
        349,
        304,
        292
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 184
    },
    "185": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731842684600",
      "endTime": "928731842737630",
      "elapsedTime": "53030",
      "asyncId": 288,
      "triggerAsyncId": 278,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        289,
        291
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 185
    },
    "186": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731807689459",
      "endTime": "928731842580796",
      "elapsedTime": "34891337",
      "asyncId": 289,
      "triggerAsyncId": 65,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        297,
        290
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 186
    },
    "187": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731847219411",
      "endTime": "928731849043341",
      "elapsedTime": "1823930",
      "asyncId": 290,
      "triggerAsyncId": 278,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        291,
        291,
        291
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 187
    },
    "188": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731808361449",
      "endTime": "928731808442180",
      "elapsedTime": "80731",
      "asyncId": 291,
      "triggerAsyncId": 65,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        293,
        292,
        298,
        301,
        299,
        303,
        309,
        292,
        292
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 188
    },
    "189": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731847801462",
      "endTime": "928731849109434",
      "elapsedTime": "1307972",
      "asyncId": 292,
      "triggerAsyncId": 286,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        298,
        293,
        293,
        300,
        298,
        313,
        319,
        312,
        311,
        310,
        317,
        321,
        325,
        293
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 189
    },
    "190": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731809258490",
      "endTime": "928731828253017",
      "elapsedTime": "18994527",
      "asyncId": 293,
      "triggerAsyncId": 285,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        300,
        303,
        301,
        305,
        311,
        294,
        294,
        308,
        301
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 190
    },
    "191": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731849500277",
      "endTime": "928731926052140",
      "elapsedTime": "76551863",
      "asyncId": 297,
      "triggerAsyncId": 279,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        315,
        318,
        316,
        320,
        324,
        298,
        305,
        307,
        310,
        308,
        312,
        318,
        298,
        298,
        305
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 191
    },
    "192": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731849918090",
      "endTime": "928731925945770",
      "elapsedTime": "76027680",
      "asyncId": 298,
      "triggerAsyncId": 279,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        299,
        299,
        301,
        300,
        319,
        322,
        320,
        324,
        328,
        299,
        303
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 192
    },
    "193": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:135:28:135:28",
      "startTime": "928731850430430",
      "endTime": "928731925534399",
      "elapsedTime": "75103969",
      "asyncId": 299,
      "triggerAsyncId": 279,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        304,
        300,
        305,
        302
      ],
      "line": "\n      };\n\n      await roleController.updatePermissions(ctx);\n\n      expect(badRequest).toHaveBeenCalledWith(\n        'ValidationError'",
      "startLine": 135,
      "startCol": 28,
      "endLine": 135,
      "endCol": 28,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 193
    },
    "194": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:115:45:115:45",
      "startTime": "928731850933273",
      "endTime": "928731850989238",
      "elapsedTime": "55965",
      "asyncId": 300,
      "triggerAsyncId": 279,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        302,
        301,
        303,
        301
      ],
      "line": "\n    test('Fails on missing action permission', async () => {\n      const badRequest = jest.fn();\n      const findOne = jest.fn(() => Promise.resolve({ id: 1 }));\n\n      const ctx = createContext(\n        ",
      "startLine": 115,
      "startCol": 45,
      "endLine": 115,
      "endCol": 45,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 194
    },
    "195": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:135:28:135:28",
      "startTime": "928731851451214",
      "endTime": "928731859987787",
      "elapsedTime": "8536573",
      "asyncId": 301,
      "triggerAsyncId": 300,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        311,
        307,
        306,
        302,
        302,
        310,
        312,
        315,
        311,
        311
      ],
      "line": "\n      };\n\n      await roleController.updatePermissions(ctx);\n\n      expect(badRequest).toHaveBeenCalledWith(\n        'ValidationError'",
      "startLine": 135,
      "startCol": 28,
      "endLine": 135,
      "endCol": 28,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 195
    },
    "196": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731851826788",
      "endTime": "928731926015531",
      "elapsedTime": "74188743",
      "asyncId": 302,
      "triggerAsyncId": 299,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        307,
        307
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 196
    },
    "197": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928731852267024",
      "endTime": "928731926106431",
      "elapsedTime": "73839407",
      "asyncId": 303,
      "triggerAsyncId": 298,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        305,
        304
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 197
    },
    "198": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731852648869",
      "endTime": "928731926196260",
      "elapsedTime": "73547391",
      "asyncId": 304,
      "triggerAsyncId": 279,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        305,
        305,
        310,
        305,
        310
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 198
    },
    "199": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731853375662",
      "endTime": "928731853433811",
      "elapsedTime": "58149",
      "asyncId": 306,
      "triggerAsyncId": 279,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        326,
        329,
        327,
        331,
        335,
        307,
        307,
        312,
        307,
        307,
        314,
        316,
        322,
        313,
        320,
        336,
        324
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 199
    },
    "200": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731815120229",
      "endTime": "928731815211139",
      "elapsedTime": "90910",
      "asyncId": 307,
      "triggerAsyncId": 297,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        345,
        338,
        338,
        337,
        336,
        343,
        347,
        354,
        308,
        308,
        309,
        308,
        308,
        309
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 200
    },
    "201": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731854112072",
      "endTime": "928731926370036",
      "elapsedTime": "72257964",
      "asyncId": 308,
      "triggerAsyncId": 279,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        356,
        359,
        357,
        361,
        365,
        309,
        314,
        309,
        314
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 201
    },
    "202": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731854571293",
      "endTime": "928731926443764",
      "elapsedTime": "71872471",
      "asyncId": 310,
      "triggerAsyncId": 304,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        318
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 202
    },
    "203": {
      "source": "packages/strapi-admin/controllers/role.js:110:13:110:13",
      "startTime": "928731854949121",
      "endTime": "928731925329285",
      "elapsedTime": "70380164",
      "asyncId": 311,
      "triggerAsyncId": 301,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.updatePermissions",
      "userCode": false,
      "triggers": [
        316,
        322
      ],
      "line": "\n        throw formatYupErrors(err);\n      }\n      await validatedUpdatePermissionsInput(input, role);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    ",
      "startLine": 110,
      "startCol": 13,
      "endLine": 110,
      "endCol": 13,
      "file": "packages/strapi-admin/controllers/role.js",
      "uniqueid": 203
    },
    "204": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731856093587",
      "endTime": "928731856178987",
      "elapsedTime": "85400",
      "asyncId": 312,
      "triggerAsyncId": 301,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        314,
        315,
        313
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 204
    },
    "205": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731856653156",
      "endTime": "928731860567093",
      "elapsedTime": "3913937",
      "asyncId": 313,
      "triggerAsyncId": 312,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        319,
        314,
        321,
        314
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 205
    },
    "206": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731857094834",
      "endTime": "928731860652122",
      "elapsedTime": "3557288",
      "asyncId": 314,
      "triggerAsyncId": 313,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        316,
        316
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 206
    },
    "207": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731857463144",
      "endTime": "928731860733404",
      "elapsedTime": "3270260",
      "asyncId": 315,
      "triggerAsyncId": 301,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        321,
        317,
        317,
        317
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 207
    },
    "208": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731858405831",
      "endTime": "928731860910306",
      "elapsedTime": "2504475",
      "asyncId": 317,
      "triggerAsyncId": 315,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        319,
        327,
        323,
        330,
        328,
        332,
        338,
        318,
        318,
        318,
        318
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 208
    },
    "209": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731858773020",
      "endTime": "928731865796045",
      "elapsedTime": "7023025",
      "asyncId": 318,
      "triggerAsyncId": 317,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        324,
        342,
        348,
        341,
        340,
        339,
        346,
        350,
        357,
        319,
        325,
        327,
        331,
        319
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 209
    },
    "210": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928731859409843",
      "endTime": "928731924319472",
      "elapsedTime": "64909629",
      "asyncId": 320,
      "triggerAsyncId": 319,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        326,
        336,
        339,
        346,
        321
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 210
    },
    "211": {
      "source": "packages/strapi-admin/controllers/role.js:110:13:110:13",
      "startTime": "928731859665623",
      "endTime": "928731924895622",
      "elapsedTime": "65229999",
      "asyncId": 321,
      "triggerAsyncId": 320,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.updatePermissions",
      "userCode": false,
      "triggers": [
        453
      ],
      "line": "\n        throw formatYupErrors(err);\n      }\n      await validatedUpdatePermissionsInput(input, role);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    ",
      "startLine": 110,
      "startCol": 13,
      "endLine": 110,
      "endCol": 13,
      "file": "packages/strapi-admin/controllers/role.js",
      "uniqueid": 211
    },
    "212": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731859934276",
      "endTime": "928731925608809",
      "elapsedTime": "65674533",
      "asyncId": 322,
      "triggerAsyncId": 311,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        330
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 212
    },
    "213": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731795449123",
      "endTime": "928731797915006",
      "elapsedTime": "2465883",
      "asyncId": 323,
      "triggerAsyncId": 317,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 213
    },
    "214": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731861296901",
      "endTime": "928731861358647",
      "elapsedTime": "61746",
      "asyncId": 325,
      "triggerAsyncId": 318,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        335,
        326,
        326,
        333,
        326
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 214
    },
    "215": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731861734260",
      "endTime": "928731864750795",
      "elapsedTime": "3016535",
      "asyncId": 326,
      "triggerAsyncId": 325,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        328,
        333,
        336,
        334,
        338,
        344,
        327,
        327,
        334,
        329
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 215
    },
    "216": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731862156772",
      "endTime": "928731862201917",
      "elapsedTime": "45145",
      "asyncId": 327,
      "triggerAsyncId": 318,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        333,
        336,
        345,
        348,
        346,
        350,
        354,
        328,
        329,
        328
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 216
    },
    "217": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731862500267",
      "endTime": "928731864829443",
      "elapsedTime": "2329176",
      "asyncId": 328,
      "triggerAsyncId": 327,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        329,
        329,
        329,
        329,
        334,
        330
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 217
    },
    "218": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731862867445",
      "endTime": "928731865185450",
      "elapsedTime": "2318005",
      "asyncId": 329,
      "triggerAsyncId": 326,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        338,
        341,
        339,
        343,
        349,
        330,
        330,
        336,
        339,
        337,
        341,
        347,
        330,
        330,
        330,
        330,
        337,
        332
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 218
    },
    "219": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731863221779",
      "endTime": "928731865285728",
      "elapsedTime": "2063949",
      "asyncId": 330,
      "triggerAsyncId": 328,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        350,
        353,
        351,
        355,
        359,
        331,
        331,
        331,
        331,
        348,
        351,
        349,
        353,
        357,
        331,
        337,
        340,
        338,
        342,
        348,
        331,
        331,
        333
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 219
    },
    "220": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731863567437",
      "endTime": "928731865463301",
      "elapsedTime": "1895864",
      "asyncId": 331,
      "triggerAsyncId": 318,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        360,
        363,
        361,
        365,
        369,
        332,
        332,
        339,
        342,
        340,
        344,
        350,
        332,
        332,
        352,
        358,
        351,
        350,
        349,
        356,
        360,
        364,
        332,
        334
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 220
    },
    "221": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731864596576",
      "endTime": "928731865616959",
      "elapsedTime": "1020383",
      "asyncId": 334,
      "triggerAsyncId": 331,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        340,
        352,
        355,
        353,
        357,
        361,
        335,
        335
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 221
    },
    "222": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731865111171",
      "endTime": "928731865860295",
      "elapsedTime": "749124",
      "asyncId": 335,
      "triggerAsyncId": 334,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 222
    },
    "223": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731866583481",
      "endTime": "928731866652490",
      "elapsedTime": "69009",
      "asyncId": 336,
      "triggerAsyncId": 320,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        344,
        338,
        337
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 223
    },
    "224": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731867059182",
      "endTime": "928731871115406",
      "elapsedTime": "4056224",
      "asyncId": 337,
      "triggerAsyncId": 336,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        342,
        343,
        339,
        338
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 224
    },
    "225": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731867486043",
      "endTime": "928731871427802",
      "elapsedTime": "3941759",
      "asyncId": 338,
      "triggerAsyncId": 337,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        339,
        341,
        340,
        344,
        340
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 225
    },
    "226": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731867848803",
      "endTime": "928731871506870",
      "elapsedTime": "3658067",
      "asyncId": 339,
      "triggerAsyncId": 320,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        340,
        345,
        341,
        347,
        341
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 226
    },
    "227": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731868650075",
      "endTime": "928731871734437",
      "elapsedTime": "3084362",
      "asyncId": 341,
      "triggerAsyncId": 339,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        344,
        347,
        342,
        342
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 227
    },
    "228": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731869056847",
      "endTime": "928731876365719",
      "elapsedTime": "7308872",
      "asyncId": 342,
      "triggerAsyncId": 341,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        343,
        350,
        352,
        356,
        343
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 228
    },
    "229": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928731869708219",
      "endTime": "928731923756416",
      "elapsedTime": "54048197",
      "asyncId": 344,
      "triggerAsyncId": 343,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        361,
        364,
        371,
        345
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 229
    },
    "230": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731870050530",
      "endTime": "928731923903041",
      "elapsedTime": "53852511",
      "asyncId": 345,
      "triggerAsyncId": 344,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        347,
        347
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 230
    },
    "231": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731870369318",
      "endTime": "928731923983602",
      "elapsedTime": "53614284",
      "asyncId": 346,
      "triggerAsyncId": 320,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        352,
        352,
        348
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 231
    },
    "232": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731870976175",
      "endTime": "928731924161886",
      "elapsedTime": "53185711",
      "asyncId": 348,
      "triggerAsyncId": 346,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        350,
        349
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 232
    },
    "233": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731871379702",
      "endTime": "928731924392979",
      "elapsedTime": "53013277",
      "asyncId": 349,
      "triggerAsyncId": 348,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        355,
        357
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 233
    },
    "234": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731872085715",
      "endTime": "928731872143343",
      "elapsedTime": "57628",
      "asyncId": 350,
      "triggerAsyncId": 342,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        355,
        352,
        355,
        351
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 234
    },
    "235": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731872477249",
      "endTime": "928731875354062",
      "elapsedTime": "2876813",
      "asyncId": 351,
      "triggerAsyncId": 350,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        352,
        357,
        353,
        354,
        354
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 235
    },
    "236": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731872840460",
      "endTime": "928731872887278",
      "elapsedTime": "46818",
      "asyncId": 352,
      "triggerAsyncId": 342,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        358,
        353,
        354,
        353
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 236
    },
    "237": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731873160370",
      "endTime": "928731875432870",
      "elapsedTime": "2272500",
      "asyncId": 353,
      "triggerAsyncId": 352,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        355,
        359,
        355
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 237
    },
    "238": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731873512270",
      "endTime": "928731875724246",
      "elapsedTime": "2211976",
      "asyncId": 354,
      "triggerAsyncId": 351,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        358,
        357
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 238
    },
    "239": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731873859089",
      "endTime": "928731875779259",
      "elapsedTime": "1920170",
      "asyncId": 355,
      "triggerAsyncId": 353,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        363,
        358
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 239
    },
    "240": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731874186984",
      "endTime": "928731875942936",
      "elapsedTime": "1755952",
      "asyncId": 356,
      "triggerAsyncId": 342,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        358,
        362,
        359
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 240
    },
    "241": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731875195956",
      "endTime": "928731876109408",
      "elapsedTime": "913452",
      "asyncId": 359,
      "triggerAsyncId": 356,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        366,
        369,
        367,
        371,
        377,
        360,
        360,
        369,
        360
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 241
    },
    "242": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731875677328",
      "endTime": "928731876416083",
      "elapsedTime": "738755",
      "asyncId": 360,
      "triggerAsyncId": 359,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        362,
        378,
        381,
        379,
        383,
        387,
        361,
        366,
        366
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 242
    },
    "243": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731877090357",
      "endTime": "928731877153636",
      "elapsedTime": "63279",
      "asyncId": 361,
      "triggerAsyncId": 344,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        367,
        363,
        362,
        362,
        362
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 243
    },
    "244": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731843261261",
      "endTime": "928731888060591",
      "elapsedTime": "44799330",
      "asyncId": 362,
      "triggerAsyncId": 66,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        368,
        369,
        372,
        370,
        374,
        380,
        363,
        363,
        363,
        373
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 244
    },
    "245": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731843547899",
      "endTime": "928731888160619",
      "elapsedTime": "44612720",
      "asyncId": 363,
      "triggerAsyncId": 66,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        381,
        384,
        382,
        386,
        390,
        364,
        364,
        364,
        370,
        365,
        370
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 245
    },
    "246": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731878469292",
      "endTime": "928731882260499",
      "elapsedTime": "3791207",
      "asyncId": 364,
      "triggerAsyncId": 344,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        373,
        375,
        381,
        372,
        379,
        395,
        365,
        365,
        366
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 246
    },
    "247": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731879303566",
      "endTime": "928731882375975",
      "elapsedTime": "3072409",
      "asyncId": 366,
      "triggerAsyncId": 364,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        378,
        368,
        367,
        367,
        367,
        367,
        367
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 247
    },
    "248": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731879645036",
      "endTime": "928731885384846",
      "elapsedTime": "5739810",
      "asyncId": 367,
      "triggerAsyncId": 366,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        375,
        375,
        373,
        377,
        379,
        385,
        376,
        383,
        399,
        368,
        368,
        375,
        378,
        368
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 248
    },
    "249": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928731880380955",
      "endTime": "928731923292988",
      "elapsedTime": "42912033",
      "asyncId": 369,
      "triggerAsyncId": 368,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        371,
        376,
        379,
        377,
        381,
        387,
        370,
        370,
        446,
        448,
        454,
        382,
        445,
        452,
        465,
        387,
        391,
        400,
        407,
        385,
        394,
        403,
        410,
        418,
        370
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 249
    },
    "250": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731880804790",
      "endTime": "928731923408945",
      "elapsedTime": "42604155",
      "asyncId": 370,
      "triggerAsyncId": 369,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        371,
        371,
        372,
        376,
        391,
        397,
        390,
        389,
        388,
        395,
        399,
        403,
        371,
        371,
        372
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 250
    },
    "251": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731881188119",
      "endTime": "928731923472825",
      "elapsedTime": "42284706",
      "asyncId": 371,
      "triggerAsyncId": 344,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        390,
        383,
        383,
        382,
        381,
        388,
        392,
        411,
        372,
        377,
        372,
        380,
        373
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 251
    },
    "252": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731881781521",
      "endTime": "928731923611755",
      "elapsedTime": "41830234",
      "asyncId": 373,
      "triggerAsyncId": 371,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        473,
        475,
        483,
        472,
        481,
        494,
        374,
        374,
        374
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 252
    },
    "253": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731882143389",
      "endTime": "928731923827449",
      "elapsedTime": "41684060",
      "asyncId": 374,
      "triggerAsyncId": 373,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        528,
        530,
        538,
        527,
        536,
        549,
        395,
        375,
        375
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 253
    },
    "254": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731882710262",
      "endTime": "928731882772970",
      "elapsedTime": "62708",
      "asyncId": 375,
      "triggerAsyncId": 367,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        376,
        383,
        386,
        384,
        388,
        394,
        376,
        376,
        376,
        376,
        376
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 254
    },
    "255": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731883076047",
      "endTime": "928731884637445",
      "elapsedTime": "1561398",
      "asyncId": 376,
      "triggerAsyncId": 375,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        395,
        398,
        396,
        400,
        404,
        377,
        377,
        386,
        389,
        378,
        387,
        391,
        397,
        377,
        377,
        384,
        377
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 255
    },
    "256": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731883449948",
      "endTime": "928731885012067",
      "elapsedTime": "1562119",
      "asyncId": 377,
      "triggerAsyncId": 376,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        405,
        408,
        406,
        410,
        414,
        378,
        383,
        402,
        409,
        401,
        400,
        400,
        399,
        398,
        407,
        411,
        415,
        378,
        379
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 256
    },
    "257": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731883811306",
      "endTime": "928731885083110",
      "elapsedTime": "1271804",
      "asyncId": 378,
      "triggerAsyncId": 367,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        380,
        380
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 257
    },
    "258": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731884512951",
      "endTime": "928731885237069",
      "elapsedTime": "724118",
      "asyncId": 380,
      "triggerAsyncId": 378,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        389,
        390,
        393,
        391,
        395,
        401,
        381,
        381,
        381
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 258
    },
    "259": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731884940212",
      "endTime": "928731885469394",
      "elapsedTime": "529182",
      "asyncId": 381,
      "triggerAsyncId": 380,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        389,
        386,
        386,
        383,
        402,
        405,
        403,
        407,
        411,
        382
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 259
    },
    "260": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731886051926",
      "endTime": "928731886109794",
      "elapsedTime": "57868",
      "asyncId": 382,
      "triggerAsyncId": 369,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        387,
        388,
        383
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 260
    },
    "261": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731886513631",
      "endTime": "928731906527239",
      "elapsedTime": "20013608",
      "asyncId": 383,
      "triggerAsyncId": 382,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        384,
        386,
        385,
        384
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 261
    },
    "262": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731886936484",
      "endTime": "928731907136802",
      "elapsedTime": "20200318",
      "asyncId": 384,
      "triggerAsyncId": 383,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        385,
        385,
        385,
        390,
        386
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 262
    },
    "263": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731887298242",
      "endTime": "928731907368686",
      "elapsedTime": "20070444",
      "asyncId": 385,
      "triggerAsyncId": 369,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        400,
        399,
        398,
        393,
        395,
        403,
        392,
        401,
        417,
        405,
        387
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 263
    },
    "264": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731888157613",
      "endTime": "928731907945507",
      "elapsedTime": "19787894",
      "asyncId": 387,
      "triggerAsyncId": 385,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        393,
        388,
        388
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 264
    },
    "265": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731888554507",
      "endTime": "928731920682925",
      "elapsedTime": "32128418",
      "asyncId": 388,
      "triggerAsyncId": 387,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        394,
        396,
        396,
        425,
        389
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 265
    },
    "266": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928731889330832",
      "endTime": "928731921940312",
      "elapsedTime": "32609480",
      "asyncId": 390,
      "triggerAsyncId": 389,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        393,
        392,
        414
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 266
    },
    "267": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731889848854",
      "endTime": "928731889896673",
      "elapsedTime": "47819",
      "asyncId": 391,
      "triggerAsyncId": 369,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        392,
        392,
        399,
        392,
        397,
        392
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 267
    },
    "268": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731890339864",
      "endTime": "928731906609493",
      "elapsedTime": "16269629",
      "asyncId": 392,
      "triggerAsyncId": 391,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        402,
        399,
        402,
        400,
        404,
        410,
        393,
        393,
        393
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 268
    },
    "269": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731890811979",
      "endTime": "928731907190422",
      "elapsedTime": "16378443",
      "asyncId": 393,
      "triggerAsyncId": 392,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        411,
        414,
        412,
        416,
        420,
        394,
        395
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 269
    },
    "270": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731891232347",
      "endTime": "928731907557600",
      "elapsedTime": "16325253",
      "asyncId": 394,
      "triggerAsyncId": 369,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        395,
        395,
        396
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 270
    },
    "271": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731892063646",
      "endTime": "928731908046507",
      "elapsedTime": "15982861",
      "asyncId": 396,
      "triggerAsyncId": 394,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        408,
        411,
        409,
        413,
        419,
        397,
        397,
        402,
        414,
        417,
        415,
        419,
        423,
        397,
        397,
        397
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 271
    },
    "272": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731892450841",
      "endTime": "928731922422245",
      "elapsedTime": "29971404",
      "asyncId": 397,
      "triggerAsyncId": 396,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        420,
        423,
        421,
        425,
        429,
        398,
        398,
        427,
        429,
        431,
        436,
        398
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 272
    },
    "273": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928731893151916",
      "endTime": "928731922922032",
      "elapsedTime": "29770116",
      "asyncId": 399,
      "triggerAsyncId": 398,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        409,
        440,
        443,
        441,
        445,
        449,
        400,
        401,
        406,
        415
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 273
    },
    "274": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731893556384",
      "endTime": "928731893610535",
      "elapsedTime": "54151",
      "asyncId": 400,
      "triggerAsyncId": 369,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        401,
        406,
        405,
        401
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 274
    },
    "275": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731894020484",
      "endTime": "928731906698700",
      "elapsedTime": "12678216",
      "asyncId": 401,
      "triggerAsyncId": 400,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        402,
        404,
        402
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 275
    },
    "276": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731894468063",
      "endTime": "928731907236498",
      "elapsedTime": "12768435",
      "asyncId": 402,
      "triggerAsyncId": 401,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        403,
        404,
        403,
        404,
        404
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 276
    },
    "277": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731894826505",
      "endTime": "928731907666114",
      "elapsedTime": "12839609",
      "asyncId": 403,
      "triggerAsyncId": 369,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        404,
        404,
        409,
        409,
        405
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 277
    },
    "278": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731895586750",
      "endTime": "928731908097111",
      "elapsedTime": "12510361",
      "asyncId": 405,
      "triggerAsyncId": 403,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        406,
        407,
        420,
        406,
        406
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 278
    },
    "279": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731897244357",
      "endTime": "928731921169687",
      "elapsedTime": "23925330",
      "asyncId": 406,
      "triggerAsyncId": 405,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema._validate",
      "userCode": false,
      "triggers": [
        407,
        412,
        441,
        416
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 279
    },
    "280": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731897663343",
      "endTime": "928731897701895",
      "elapsedTime": "38552",
      "asyncId": 407,
      "triggerAsyncId": 369,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        408,
        413,
        415,
        408
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 280
    },
    "281": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731898291540",
      "endTime": "928731906778981",
      "elapsedTime": "8487441",
      "asyncId": 408,
      "triggerAsyncId": 407,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        410,
        409,
        409
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 281
    },
    "282": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731898688013",
      "endTime": "928731907304906",
      "elapsedTime": "8616893",
      "asyncId": 409,
      "triggerAsyncId": 408,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        415,
        411
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 282
    },
    "283": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731899065090",
      "endTime": "928731907799634",
      "elapsedTime": "8734544",
      "asyncId": 410,
      "triggerAsyncId": 369,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        411,
        413,
        412
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 283
    },
    "284": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731899743903",
      "endTime": "928731908154429",
      "elapsedTime": "8410526",
      "asyncId": 412,
      "triggerAsyncId": 410,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        418,
        420,
        413,
        413
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 284
    },
    "285": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731900129215",
      "endTime": "928731922620897",
      "elapsedTime": "22491682",
      "asyncId": 413,
      "triggerAsyncId": 412,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema._validate",
      "userCode": false,
      "triggers": [
        416,
        414,
        443,
        446,
        417
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 285
    },
    "286": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731900498086",
      "endTime": "928731922232780",
      "elapsedTime": "21734694",
      "asyncId": 414,
      "triggerAsyncId": 390,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        415,
        416,
        419
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 286
    },
    "287": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731900908436",
      "endTime": "928731923026428",
      "elapsedTime": "22117992",
      "asyncId": 415,
      "triggerAsyncId": 399,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        424,
        421,
        416,
        416,
        420
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 287
    },
    "288": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731901236471",
      "endTime": "928731921693699",
      "elapsedTime": "20457228",
      "asyncId": 416,
      "triggerAsyncId": 406,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        417,
        417,
        423,
        426,
        424,
        428,
        434,
        417,
        417,
        421
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 288
    },
    "289": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731901576719",
      "endTime": "928731922866718",
      "elapsedTime": "21289999",
      "asyncId": 417,
      "triggerAsyncId": 413,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        427,
        418,
        435,
        438,
        436,
        440,
        444,
        418,
        422
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 289
    },
    "290": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731904557887",
      "endTime": "928731923080990",
      "elapsedTime": "18523103",
      "asyncId": 418,
      "triggerAsyncId": 369,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        419,
        419,
        426,
        419,
        423
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 290
    },
    "291": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731906360226",
      "endTime": "928731923209721",
      "elapsedTime": "16849495",
      "asyncId": 423,
      "triggerAsyncId": 418,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        452,
        455,
        453,
        457,
        461,
        424,
        424,
        443,
        448,
        442,
        441,
        446,
        450,
        454,
        424,
        425,
        424
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 291
    },
    "292": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731907076458",
      "endTime": "928731923342881",
      "elapsedTime": "16266423",
      "asyncId": 424,
      "triggerAsyncId": 423,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        462,
        465,
        463,
        467,
        471,
        425,
        432,
        430
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 292
    },
    "293": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731908569898",
      "endTime": "928731908644999",
      "elapsedTime": "75101",
      "asyncId": 425,
      "triggerAsyncId": 388,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        426,
        426,
        426
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 293
    },
    "294": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731909021815",
      "endTime": "928731919059982",
      "elapsedTime": "10038167",
      "asyncId": 426,
      "triggerAsyncId": 425,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        443,
        445,
        451,
        442,
        449,
        465,
        427,
        427,
        449
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 294
    },
    "295": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731909715004",
      "endTime": "928731909767202",
      "elapsedTime": "52198",
      "asyncId": 427,
      "triggerAsyncId": 397,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        429,
        428,
        428,
        479,
        481,
        487,
        478,
        485,
        498,
        428,
        428,
        428
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 295
    },
    "296": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731910147014",
      "endTime": "928731919396964",
      "elapsedTime": "9249950",
      "asyncId": 428,
      "triggerAsyncId": 427,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        434,
        435,
        438,
        436,
        440,
        446,
        429,
        429,
        512,
        514,
        520,
        511,
        518,
        531,
        429,
        429,
        433
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 296
    },
    "297": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731910508662",
      "endTime": "928731911136279",
      "elapsedTime": "627617",
      "asyncId": 429,
      "triggerAsyncId": 397,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        447,
        450,
        448,
        452,
        456,
        430,
        545,
        547,
        553,
        544,
        551,
        564,
        430,
        430,
        431,
        430
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 297
    },
    "298": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731911490483",
      "endTime": "928731919476243",
      "elapsedTime": "7985760",
      "asyncId": 430,
      "triggerAsyncId": 429,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        432,
        432,
        578,
        580,
        586,
        577,
        584,
        597,
        431,
        431,
        436,
        434
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 298
    },
    "299": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731911855216",
      "endTime": "928731911902004",
      "elapsedTime": "46788",
      "asyncId": 431,
      "triggerAsyncId": 397,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        437,
        437,
        611,
        613,
        619,
        610,
        617,
        630,
        432,
        432,
        432
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 299
    },
    "300": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731912318856",
      "endTime": "928731919513382",
      "elapsedTime": "7194526",
      "asyncId": 432,
      "triggerAsyncId": 431,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        644,
        646,
        652,
        643,
        650,
        663,
        433,
        433,
        435
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 300
    },
    "301": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731912686204",
      "endTime": "928731920792019",
      "elapsedTime": "8105815",
      "asyncId": 433,
      "triggerAsyncId": 428,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        677,
        679,
        685,
        676,
        683,
        696,
        434,
        434,
        437
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 301
    },
    "302": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731913069673",
      "endTime": "928731920859856",
      "elapsedTime": "7790183",
      "asyncId": 434,
      "triggerAsyncId": 430,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        710,
        712,
        718,
        709,
        716,
        729,
        435,
        435,
        438
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 302
    },
    "303": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731913440488",
      "endTime": "928731920942101",
      "elapsedTime": "7501613",
      "asyncId": 435,
      "triggerAsyncId": 432,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        437,
        743,
        745,
        751,
        742,
        749,
        762,
        453,
        437,
        439
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 303
    },
    "304": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731913849154",
      "endTime": "928731921570068",
      "elapsedTime": "7720914",
      "asyncId": 436,
      "triggerAsyncId": 397,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        442,
        437,
        442,
        440
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 304
    },
    "305": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731915589837",
      "endTime": "928731922036302",
      "elapsedTime": "6446465",
      "asyncId": 440,
      "triggerAsyncId": 436,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        442,
        446,
        450
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 305
    },
    "306": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731916097840",
      "endTime": "928731916148034",
      "elapsedTime": "50194",
      "asyncId": 441,
      "triggerAsyncId": 406,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        447,
        447,
        442
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 306
    },
    "307": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731916465859",
      "endTime": "928731919851787",
      "elapsedTime": "3385928",
      "asyncId": 442,
      "triggerAsyncId": 441,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        444,
        450,
        445,
        451
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 307
    },
    "308": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731916966949",
      "endTime": "928731917027993",
      "elapsedTime": "61044",
      "asyncId": 443,
      "triggerAsyncId": 413,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        449,
        444,
        444
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 308
    },
    "309": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731917425649",
      "endTime": "928731920228884",
      "elapsedTime": "2803235",
      "asyncId": 444,
      "triggerAsyncId": 443,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        445
      ],
      "uniqueid": 309
    },
    "310": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731917794009",
      "endTime": "928731921307636",
      "elapsedTime": "3513627",
      "asyncId": 445,
      "triggerAsyncId": 444,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        446,
        446,
        453,
        447
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 310
    },
    "311": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731918226039",
      "endTime": "928731921763731",
      "elapsedTime": "3537692",
      "asyncId": 446,
      "triggerAsyncId": 413,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        456,
        459,
        457,
        461,
        467,
        447,
        447,
        452,
        448
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 311
    },
    "312": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731918917245",
      "endTime": "928731922167187",
      "elapsedTime": "3249942",
      "asyncId": 448,
      "triggerAsyncId": 446,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        454,
        449,
        449,
        452
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 312
    },
    "313": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731919338024",
      "endTime": "928731920756713",
      "elapsedTime": "1418689",
      "asyncId": 449,
      "triggerAsyncId": 426,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        451,
        456,
        459,
        457,
        461,
        467,
        450,
        450
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 313
    },
    "314": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731919773941",
      "endTime": "928731922495994",
      "elapsedTime": "2722053",
      "asyncId": 450,
      "triggerAsyncId": 440,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        460,
        456,
        468,
        471,
        469,
        473,
        477,
        451
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 314
    },
    "315": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731920089923",
      "endTime": "928731921245129",
      "elapsedTime": "1155206",
      "asyncId": 451,
      "triggerAsyncId": 442,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        457,
        457
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 315
    },
    "316": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731920497958",
      "endTime": "928731922685519",
      "elapsedTime": "2187561",
      "asyncId": 452,
      "triggerAsyncId": 448,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        454
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 316
    },
    "317": {
      "source": "packages/strapi-admin/validation/permission.js:13:39:13:39",
      "startTime": "928731924717007",
      "endTime": "928731924764105",
      "elapsedTime": "47098",
      "asyncId": 453,
      "triggerAsyncId": 321,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " handleReject",
      "userCode": false,
      "triggers": [
        459,
        454
      ],
      "line": "\nconst validators = require('./common-validators');\n\nconst handleReject = error => Promise.reject(formatYupErrors(error));\n\n// validatedUpdatePermissionsInput",
      "startLine": 13,
      "startCol": 39,
      "endLine": 13,
      "endCol": 39,
      "file": "packages/strapi-admin/validation/permission.js",
      "uniqueid": 317
    },
    "318": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731925164135",
      "endTime": "928731925421137",
      "elapsedTime": "257002",
      "asyncId": 454,
      "triggerAsyncId": 453,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        455,
        455
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 318
    },
    "319": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731927758268",
      "endTime": "928732134922384",
      "elapsedTime": "207164116",
      "asyncId": 455,
      "triggerAsyncId": 175,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        464,
        466,
        474,
        463,
        472,
        488,
        456,
        456,
        464,
        463
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 319
    },
    "320": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928731928198944",
      "endTime": "928731928230984",
      "elapsedTime": "32040",
      "asyncId": 456,
      "triggerAsyncId": 175,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        522,
        524,
        532,
        521,
        530,
        543,
        476,
        458,
        461,
        461,
        458
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 320
    },
    "321": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731881232211",
      "endTime": "928731882851667",
      "elapsedTime": "1619456",
      "asyncId": 457,
      "triggerAsyncId": 449,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        458,
        463,
        465,
        463
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 321
    },
    "322": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928731929009073",
      "endTime": "928731929061541",
      "elapsedTime": "52468",
      "asyncId": 458,
      "triggerAsyncId": 175,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        459,
        459
      ],
      "uniqueid": 322
    },
    "323": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731929390358",
      "endTime": "928731935261003",
      "elapsedTime": "5870645",
      "asyncId": 459,
      "triggerAsyncId": 458,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        468,
        460,
        460,
        466,
        469,
        467,
        471,
        477,
        460,
        460
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 323
    },
    "324": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731929899943",
      "endTime": "928732134804283",
      "elapsedTime": "204904340",
      "asyncId": 460,
      "triggerAsyncId": 459,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        461,
        461,
        468,
        470,
        476,
        467,
        474,
        490,
        478,
        481,
        487,
        480,
        479,
        478,
        485,
        489,
        505,
        461
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 324
    },
    "325": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731930196809",
      "endTime": "928732134953803",
      "elapsedTime": "204756994",
      "asyncId": 461,
      "triggerAsyncId": 460,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        468,
        471,
        469,
        473,
        479,
        462,
        462,
        462
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 325
    },
    "326": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731930459041",
      "endTime": "928732134990733",
      "elapsedTime": "204531692",
      "asyncId": 462,
      "triggerAsyncId": 175,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        464,
        463,
        463,
        480,
        483,
        481,
        485,
        489,
        463
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 326
    },
    "327": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731931191193",
      "endTime": "928731931239925",
      "elapsedTime": "48732",
      "asyncId": 464,
      "triggerAsyncId": 175,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        483,
        486,
        484,
        488,
        492,
        465,
        465
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 327
    },
    "328": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731932024576",
      "endTime": "928731932084147",
      "elapsedTime": "59571",
      "asyncId": 466,
      "triggerAsyncId": 459,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        467,
        467,
        468
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 328
    },
    "329": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731932321622",
      "endTime": "928731934359112",
      "elapsedTime": "2037490",
      "asyncId": 467,
      "triggerAsyncId": 459,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        479,
        482,
        480,
        484,
        490,
        468,
        468,
        475,
        473
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 329
    },
    "330": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731932787265",
      "endTime": "928731932850854",
      "elapsedTime": "63589",
      "asyncId": 469,
      "triggerAsyncId": 459,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        501,
        504,
        502,
        506,
        510,
        470,
        470,
        475,
        475,
        475
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 330
    },
    "331": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731933441602",
      "endTime": "928731935011395",
      "elapsedTime": "1569793",
      "asyncId": 471,
      "triggerAsyncId": 459,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        473,
        481,
        484,
        482,
        486,
        492,
        472,
        472
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 331
    },
    "332": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731865384844",
      "endTime": "928731878965993",
      "elapsedTime": "13581149",
      "asyncId": 472,
      "triggerAsyncId": 471,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        482,
        478,
        496,
        495,
        501,
        495,
        494,
        493,
        499,
        503,
        508,
        473
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 332
    },
    "333": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731933753978",
      "endTime": "928731935083961",
      "elapsedTime": "1329983",
      "asyncId": 473,
      "triggerAsyncId": 467,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 333
    },
    "334": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731865940545",
      "endTime": "928731879345985",
      "elapsedTime": "13405440",
      "asyncId": 474,
      "triggerAsyncId": 460,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 334
    },
    "335": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731866503371",
      "endTime": "928731866567701",
      "elapsedTime": "64330",
      "asyncId": 476,
      "triggerAsyncId": 460,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        485,
        488,
        486,
        490,
        496,
        477,
        477
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 335
    },
    "336": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731935641766",
      "endTime": "928732134539456",
      "elapsedTime": "198897690",
      "asyncId": 478,
      "triggerAsyncId": 460,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        507,
        510,
        508,
        512,
        516,
        479,
        479,
        486,
        488,
        486
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 336
    },
    "337": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731936095517",
      "endTime": "928732134458395",
      "elapsedTime": "198362878",
      "asyncId": 479,
      "triggerAsyncId": 460,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        517,
        520,
        518,
        522,
        526,
        480,
        481,
        485,
        485,
        484
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 337
    },
    "338": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:189:28:189:28",
      "startTime": "928731936563845",
      "endTime": "928732132130180",
      "elapsedTime": "195566335",
      "asyncId": 480,
      "triggerAsyncId": 460,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        486,
        482,
        483
      ],
      "line": "\n      };\n\n      await roleController.updatePermissions(ctx);\n\n      expect(findOneRole).toHaveBeenCalledWith({ id: roleID });\n      expect(assignPermissions).toHaveBeenCalledWith(roleID, inputPermissions)",
      "startLine": 189,
      "startCol": 28,
      "endLine": 189,
      "endCol": 28,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 338
    },
    "339": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:149:49:149:49",
      "startTime": "928731937027143",
      "endTime": "928731937097194",
      "elapsedTime": "70051",
      "asyncId": 481,
      "triggerAsyncId": 460,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        482,
        487,
        482,
        483,
        482
      ],
      "line": "\n    test('Assign permissions if input is valid', async () => {\n      const roleID = 1;\n      const findOneRole = jest.fn(() => Promise.resolve({ id: roleID }));\n      const assignPermissions = jest.fn((roleID, permissions) => Promise.resolve(permissions));\n      const inputPermissions = [\n        ",
      "startLine": 149,
      "startCol": 49,
      "endLine": 149,
      "endCol": 49,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 339
    },
    "340": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:189:28:189:28",
      "startTime": "928731937443043",
      "endTime": "928731943856806",
      "elapsedTime": "6413763",
      "asyncId": 482,
      "triggerAsyncId": 481,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        489,
        492,
        490,
        494,
        500,
        483,
        483,
        488,
        483,
        483,
        493,
        496,
        492
      ],
      "line": "\n      };\n\n      await roleController.updatePermissions(ctx);\n\n      expect(findOneRole).toHaveBeenCalledWith({ id: roleID });\n      expect(assignPermissions).toHaveBeenCalledWith(roleID, inputPermissions)",
      "startLine": 189,
      "startCol": 28,
      "endLine": 189,
      "endCol": 28,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 340
    },
    "341": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731937773703",
      "endTime": "928732134499652",
      "elapsedTime": "196725949",
      "asyncId": 483,
      "triggerAsyncId": 480,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        485,
        501,
        504,
        502,
        506,
        510,
        484,
        492,
        494,
        500,
        491,
        498,
        514,
        484,
        484
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 341
    },
    "342": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928731938067133",
      "endTime": "928732134579402",
      "elapsedTime": "196512269",
      "asyncId": 484,
      "triggerAsyncId": 479,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        490,
        528,
        530,
        536,
        527,
        534,
        547,
        502
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 342
    },
    "343": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731938290101",
      "endTime": "928732134613054",
      "elapsedTime": "196322953",
      "asyncId": 485,
      "triggerAsyncId": 460,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        487,
        486,
        491
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 343
    },
    "344": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731938698636",
      "endTime": "928731938726800",
      "elapsedTime": "28164",
      "asyncId": 487,
      "triggerAsyncId": 460,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 344
    },
    "345": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731939282441",
      "endTime": "928732134712481",
      "elapsedTime": "195430040",
      "asyncId": 489,
      "triggerAsyncId": 460,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        491
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 345
    },
    "346": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731939584277",
      "endTime": "928732134744841",
      "elapsedTime": "195160564",
      "asyncId": 491,
      "triggerAsyncId": 485,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        493,
        499
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 346
    },
    "347": {
      "source": "packages/strapi-admin/controllers/role.js:110:13:110:13",
      "startTime": "928731939971533",
      "endTime": "928732130072062",
      "elapsedTime": "190100529",
      "asyncId": 492,
      "triggerAsyncId": 482,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.updatePermissions",
      "userCode": false,
      "triggers": [
        498,
        503
      ],
      "line": "\n        throw formatYupErrors(err);\n      }\n      await validatedUpdatePermissionsInput(input, role);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    ",
      "startLine": 110,
      "startCol": 13,
      "endLine": 110,
      "endCol": 13,
      "file": "packages/strapi-admin/controllers/role.js",
      "uniqueid": 347
    },
    "348": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731941047199",
      "endTime": "928731941113744",
      "elapsedTime": "66545",
      "asyncId": 493,
      "triggerAsyncId": 482,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        495,
        494,
        494,
        500,
        494
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 348
    },
    "349": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731941424897",
      "endTime": "928731944330875",
      "elapsedTime": "2905978",
      "asyncId": 494,
      "triggerAsyncId": 493,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        500,
        501,
        504,
        502,
        506,
        512,
        495,
        495,
        498,
        495,
        495,
        495
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 349
    },
    "350": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731941718388",
      "endTime": "928731944380117",
      "elapsedTime": "2661729",
      "asyncId": 495,
      "triggerAsyncId": 494,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        513,
        516,
        514,
        518,
        522,
        496,
        497,
        505,
        508,
        506,
        510,
        516,
        496,
        496,
        497
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 350
    },
    "351": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731942047875",
      "endTime": "928731944450178",
      "elapsedTime": "2402303",
      "asyncId": 496,
      "triggerAsyncId": 482,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        506,
        517,
        520,
        518,
        522,
        526,
        497,
        498
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 351
    },
    "352": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731942702973",
      "endTime": "928731944576966",
      "elapsedTime": "1873993",
      "asyncId": 498,
      "triggerAsyncId": 496,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        504,
        499,
        499
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 352
    },
    "353": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731942988498",
      "endTime": "928731948448604",
      "elapsedTime": "5460106",
      "asyncId": 499,
      "triggerAsyncId": 498,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        505,
        506,
        508,
        512,
        500
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 353
    },
    "354": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928731943446727",
      "endTime": "928732020561265",
      "elapsedTime": "77114538",
      "asyncId": 501,
      "triggerAsyncId": 500,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        503,
        503,
        503,
        517,
        520,
        527,
        502
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 354
    },
    "355": {
      "source": "packages/strapi-admin/controllers/role.js:110:13:110:13",
      "startTime": "928731943631173",
      "endTime": "928732024430969",
      "elapsedTime": "80799796",
      "asyncId": 502,
      "triggerAsyncId": 501,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.updatePermissions",
      "userCode": false,
      "triggers": [
        508,
        508,
        508,
        664,
        667
      ],
      "line": "\n        throw formatYupErrors(err);\n      }\n      await validatedUpdatePermissionsInput(input, role);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    ",
      "startLine": 110,
      "startCol": 13,
      "endLine": 110,
      "endCol": 13,
      "file": "packages/strapi-admin/controllers/role.js",
      "uniqueid": 355
    },
    "356": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731943834134",
      "endTime": "928732132067402",
      "elapsedTime": "188233268",
      "asyncId": 503,
      "triggerAsyncId": 492,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        514,
        815
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 356
    },
    "357": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731944904029",
      "endTime": "928731944948372",
      "elapsedTime": "44343",
      "asyncId": 506,
      "triggerAsyncId": 499,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        512,
        507
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 357
    },
    "358": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731945204352",
      "endTime": "928731947797834",
      "elapsedTime": "2593482",
      "asyncId": 507,
      "triggerAsyncId": 506,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        509,
        508,
        508,
        510
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 358
    },
    "359": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731945484808",
      "endTime": "928731945549118",
      "elapsedTime": "64310",
      "asyncId": 508,
      "triggerAsyncId": 499,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        514,
        518,
        520,
        527,
        517,
        525,
        541,
        509,
        509,
        509
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 359
    },
    "360": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731945857887",
      "endTime": "928731947863066",
      "elapsedTime": "2005179",
      "asyncId": 509,
      "triggerAsyncId": 508,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        565,
        567,
        574,
        564,
        572,
        585,
        510,
        510,
        520,
        511
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 360
    },
    "361": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731946175022",
      "endTime": "928731948113105",
      "elapsedTime": "1938083",
      "asyncId": 510,
      "triggerAsyncId": 507,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        609,
        611,
        618,
        608,
        616,
        629,
        529,
        517,
        517,
        513
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 361
    },
    "362": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731946485193",
      "endTime": "928731948178638",
      "elapsedTime": "1693445",
      "asyncId": 511,
      "triggerAsyncId": 509,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        513,
        512,
        519,
        514
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 362
    },
    "363": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731946761571",
      "endTime": "928731948284686",
      "elapsedTime": "1523115",
      "asyncId": 512,
      "triggerAsyncId": 499,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        518,
        515
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 363
    },
    "364": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731947674883",
      "endTime": "928731948355630",
      "elapsedTime": "680747",
      "asyncId": 515,
      "triggerAsyncId": 512,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        522,
        525,
        523,
        527,
        533,
        516,
        516,
        574,
        576,
        582,
        573,
        580,
        593,
        516,
        516,
        516
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 364
    },
    "365": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731948086685",
      "endTime": "928731948503627",
      "elapsedTime": "416942",
      "asyncId": 516,
      "triggerAsyncId": 515,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        534,
        537,
        535,
        539,
        543,
        517,
        625,
        627,
        633,
        624,
        631,
        644,
        534
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 365
    },
    "366": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731949026227",
      "endTime": "928731949073816",
      "elapsedTime": "47589",
      "asyncId": 517,
      "triggerAsyncId": 501,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        519,
        526,
        519,
        518,
        518
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 366
    },
    "367": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731949489505",
      "endTime": "928731954384531",
      "elapsedTime": "4895026",
      "asyncId": 518,
      "triggerAsyncId": 517,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        524,
        524,
        519
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 367
    },
    "368": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731949928468",
      "endTime": "928731956553698",
      "elapsedTime": "6625230",
      "asyncId": 519,
      "triggerAsyncId": 518,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        521
      ],
      "uniqueid": 368
    },
    "369": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731950386857",
      "endTime": "928731956629880",
      "elapsedTime": "6243023",
      "asyncId": 520,
      "triggerAsyncId": 501,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        521,
        521,
        522
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 369
    },
    "370": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731951172420",
      "endTime": "928731956819486",
      "elapsedTime": "5647066",
      "asyncId": 522,
      "triggerAsyncId": 520,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        544,
        547,
        545,
        549,
        553,
        523,
        523,
        524,
        523,
        523
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 370
    },
    "371": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731951459858",
      "endTime": "928731962580225",
      "elapsedTime": "11120367",
      "asyncId": 523,
      "triggerAsyncId": 522,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        554,
        557,
        555,
        559,
        563,
        524,
        529,
        531,
        531,
        531,
        533,
        537,
        524
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 371
    },
    "372": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928731952331332",
      "endTime": "928732020236606",
      "elapsedTime": "67905274",
      "asyncId": 525,
      "triggerAsyncId": 524,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        534,
        537,
        535,
        539,
        545,
        526,
        526,
        542,
        545,
        552,
        526
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 372
    },
    "373": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731952797967",
      "endTime": "928732020336163",
      "elapsedTime": "67538196",
      "asyncId": 526,
      "triggerAsyncId": 525,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        546,
        549,
        547,
        551,
        555,
        527,
        527,
        527,
        527,
        527,
        527,
        528
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 373
    },
    "374": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731953198508",
      "endTime": "928732020380276",
      "elapsedTime": "67181768",
      "asyncId": 527,
      "triggerAsyncId": 501,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        537,
        556,
        559,
        557,
        561,
        565,
        528,
        528,
        534,
        537,
        535,
        539,
        545,
        528,
        528,
        537,
        540,
        538,
        542,
        548,
        528,
        528,
        535,
        529
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 374
    },
    "375": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731954209463",
      "endTime": "928732020462760",
      "elapsedTime": "66253297",
      "asyncId": 529,
      "triggerAsyncId": 527,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        530
      ],
      "uniqueid": 375
    },
    "376": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731954971672",
      "endTime": "928732020620566",
      "elapsedTime": "65648894",
      "asyncId": 530,
      "triggerAsyncId": 529,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        531,
        531,
        531,
        531
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 376
    },
    "377": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731957309054",
      "endTime": "928731957405664",
      "elapsedTime": "96610",
      "asyncId": 531,
      "triggerAsyncId": 523,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        540,
        543,
        541,
        545,
        551,
        532,
        532,
        538,
        541,
        539,
        543,
        549,
        532,
        532,
        532
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 377
    },
    "378": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731957869023",
      "endTime": "928731961261523",
      "elapsedTime": "3392500",
      "asyncId": 532,
      "triggerAsyncId": 531,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        552,
        555,
        553,
        557,
        561,
        533,
        533,
        534,
        550,
        553,
        551,
        555,
        559,
        533,
        535
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 378
    },
    "379": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731958352079",
      "endTime": "928731958425687",
      "elapsedTime": "73608",
      "asyncId": 533,
      "triggerAsyncId": 523,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        562,
        565,
        563,
        567,
        571,
        534,
        534,
        539,
        534
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 379
    },
    "380": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731958828191",
      "endTime": "928731961325623",
      "elapsedTime": "2497432",
      "asyncId": 534,
      "triggerAsyncId": 533,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        572,
        575,
        573,
        577,
        581,
        535,
        536,
        536,
        536,
        536
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 380
    },
    "381": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731959253759",
      "endTime": "928731961669568",
      "elapsedTime": "2415809",
      "asyncId": 535,
      "triggerAsyncId": 532,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        541,
        541,
        541,
        538
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 381
    },
    "382": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731959646054",
      "endTime": "928731961745209",
      "elapsedTime": "2099155",
      "asyncId": 536,
      "triggerAsyncId": 534,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        539
      ],
      "uniqueid": 382
    },
    "383": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731960013233",
      "endTime": "928731961861878",
      "elapsedTime": "1848645",
      "asyncId": 537,
      "triggerAsyncId": 523,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        539,
        540
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 383
    },
    "384": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731961165523",
      "endTime": "928731962421918",
      "elapsedTime": "1256395",
      "asyncId": 540,
      "triggerAsyncId": 537,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        542,
        541
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 384
    },
    "385": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731961631426",
      "endTime": "928731962665114",
      "elapsedTime": "1033688",
      "asyncId": 541,
      "triggerAsyncId": 540,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        547
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 385
    },
    "386": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731963361038",
      "endTime": "928731963406804",
      "elapsedTime": "45766",
      "asyncId": 542,
      "triggerAsyncId": 525,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        543
      ],
      "uniqueid": 386
    },
    "387": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731963836399",
      "endTime": "928731968145588",
      "elapsedTime": "4309189",
      "asyncId": 543,
      "triggerAsyncId": 542,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        544
      ],
      "uniqueid": 387
    },
    "388": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731964254774",
      "endTime": "928731968421194",
      "elapsedTime": "4166420",
      "asyncId": 544,
      "triggerAsyncId": 543,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        546,
        552,
        546
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 388
    },
    "389": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731964615901",
      "endTime": "928731968487589",
      "elapsedTime": "3871688",
      "asyncId": 545,
      "triggerAsyncId": 525,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        551,
        547
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 389
    },
    "390": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731965440136",
      "endTime": "928731968581014",
      "elapsedTime": "3140878",
      "asyncId": 547,
      "triggerAsyncId": 545,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        553,
        553,
        548,
        548,
        548,
        548
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 390
    },
    "391": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731965830137",
      "endTime": "928731971649786",
      "elapsedTime": "5819649",
      "asyncId": 548,
      "triggerAsyncId": 547,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        555,
        558,
        556,
        560,
        566,
        549,
        549,
        556,
        559,
        549
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 391
    },
    "392": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928731966618635",
      "endTime": "928732019753300",
      "elapsedTime": "53134665",
      "asyncId": 550,
      "triggerAsyncId": 549,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        555,
        552,
        563,
        572,
        581,
        588,
        566,
        575,
        584,
        591,
        599,
        551
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 392
    },
    "393": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731967027051",
      "endTime": "928732019892932",
      "elapsedTime": "52865881",
      "asyncId": 551,
      "triggerAsyncId": 550,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        552,
        554,
        557,
        553
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 393
    },
    "394": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731967405961",
      "endTime": "928732019957133",
      "elapsedTime": "52551172",
      "asyncId": 552,
      "triggerAsyncId": 525,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        554,
        553,
        554
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 394
    },
    "395": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731968036874",
      "endTime": "928732020085002",
      "elapsedTime": "52048128",
      "asyncId": 554,
      "triggerAsyncId": 552,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        556,
        555
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 395
    },
    "396": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731968392350",
      "endTime": "928732020290417",
      "elapsedTime": "51898067",
      "asyncId": 555,
      "triggerAsyncId": 554,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        561,
        557
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 396
    },
    "397": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731968979521",
      "endTime": "928731969033071",
      "elapsedTime": "53550",
      "asyncId": 556,
      "triggerAsyncId": 548,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        558,
        562,
        562,
        557
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 397
    },
    "398": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731969432019",
      "endTime": "928731971080639",
      "elapsedTime": "1648620",
      "asyncId": 557,
      "triggerAsyncId": 556,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        563,
        572,
        558
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 398
    },
    "399": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731969919342",
      "endTime": "928731971393726",
      "elapsedTime": "1474384",
      "asyncId": 558,
      "triggerAsyncId": 557,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        560
      ],
      "uniqueid": 399
    },
    "400": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731970319853",
      "endTime": "928731971451194",
      "elapsedTime": "1131341",
      "asyncId": 559,
      "triggerAsyncId": 548,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        567,
        561
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 400
    },
    "401": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731921824304",
      "endTime": "928732059885802",
      "elapsedTime": "138061498",
      "asyncId": 560,
      "triggerAsyncId": 68,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        561,
        582
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 401
    },
    "402": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731922228192",
      "endTime": "928732059945474",
      "elapsedTime": "137717282",
      "asyncId": 561,
      "triggerAsyncId": 68,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        579,
        562,
        579
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 402
    },
    "403": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731971328755",
      "endTime": "928731971705791",
      "elapsedTime": "377036",
      "asyncId": 562,
      "triggerAsyncId": 561,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        564,
        563,
        565
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 403
    },
    "404": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731972298643",
      "endTime": "928731972355479",
      "elapsedTime": "56836",
      "asyncId": 563,
      "triggerAsyncId": 550,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        569,
        568,
        564,
        565,
        564
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 404
    },
    "405": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731972801335",
      "endTime": "928731990568812",
      "elapsedTime": "17767477",
      "asyncId": 564,
      "triggerAsyncId": 563,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        573,
        568,
        565,
        565,
        565
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 405
    },
    "406": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731973282747",
      "endTime": "928731992184240",
      "elapsedTime": "18901493",
      "asyncId": 565,
      "triggerAsyncId": 564,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        566,
        569,
        586,
        588,
        594,
        585,
        592,
        608,
        566,
        566,
        567
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 406
    },
    "407": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731973637503",
      "endTime": "928731992363396",
      "elapsedTime": "18725893",
      "asyncId": 566,
      "triggerAsyncId": 550,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        568,
        622,
        624,
        630,
        621,
        628,
        641,
        567,
        567,
        568
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 407
    },
    "408": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731974480883",
      "endTime": "928731992757434",
      "elapsedTime": "18276551",
      "asyncId": 568,
      "triggerAsyncId": 566,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        576,
        579,
        577,
        581,
        587,
        569,
        569,
        574,
        569,
        688,
        690,
        696,
        687,
        694,
        707,
        569,
        569,
        569,
        569
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 408
    },
    "409": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731974879020",
      "endTime": "928732004078517",
      "elapsedTime": "29199497",
      "asyncId": 569,
      "triggerAsyncId": 568,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        588,
        591,
        589,
        593,
        597,
        570,
        570,
        570,
        570,
        721,
        723,
        729,
        720,
        727,
        740,
        570,
        570,
        606,
        570
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 409
    },
    "410": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928731975631320",
      "endTime": "928732018819801",
      "elapsedTime": "43188481",
      "asyncId": 571,
      "triggerAsyncId": 570,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        572,
        787,
        789,
        795,
        786,
        793,
        806,
        572,
        634,
        572,
        637,
        642,
        595
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 410
    },
    "411": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731926231997",
      "endTime": "928732005456790",
      "elapsedTime": "79224793",
      "asyncId": 572,
      "triggerAsyncId": 571,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        574,
        573,
        820,
        822,
        828,
        819,
        826,
        839,
        573,
        573
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 411
    },
    "412": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731926557216",
      "endTime": "928732014079054",
      "elapsedTime": "87521838",
      "asyncId": 573,
      "triggerAsyncId": 572,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        579,
        581,
        574,
        853,
        855,
        861,
        852,
        859,
        872,
        574,
        574
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 412
    },
    "413": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731926893367",
      "endTime": "928732022766619",
      "elapsedTime": "95873252",
      "asyncId": 574,
      "triggerAsyncId": 573,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        576,
        886,
        888,
        894,
        885,
        892,
        905,
        575,
        575
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 413
    },
    "414": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731927224057",
      "endTime": "928732032106257",
      "elapsedTime": "104882200",
      "asyncId": 575,
      "triggerAsyncId": 574,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        577,
        919,
        921,
        927,
        918,
        925,
        938,
        576,
        576
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 414
    },
    "415": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731927518509",
      "endTime": "928732041283220",
      "elapsedTime": "113764711",
      "asyncId": 576,
      "triggerAsyncId": 575,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        585,
        578,
        577,
        577,
        952,
        954,
        960,
        951,
        958,
        971,
        577,
        577
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 415
    },
    "416": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731927840803",
      "endTime": "928732051344280",
      "elapsedTime": "123503477",
      "asyncId": 577,
      "triggerAsyncId": 576,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        582,
        582,
        583,
        585,
        584,
        587,
        585,
        589,
        595,
        578,
        578,
        578,
        578,
        985,
        987,
        993,
        984,
        991,
        1004,
        578,
        578
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 416
    },
    "417": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731928159039",
      "endTime": "928732059618601",
      "elapsedTime": "131459562",
      "asyncId": 578,
      "triggerAsyncId": 577,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        605,
        598,
        597,
        596,
        603,
        607,
        614,
        579,
        608,
        610,
        612,
        617,
        579,
        1018,
        1020,
        1026,
        1017,
        1024,
        1037,
        596
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 417
    },
    "418": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731928397356",
      "endTime": "928732059799069",
      "elapsedTime": "131401713",
      "asyncId": 579,
      "triggerAsyncId": 561,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        580,
        580,
        580
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 418
    },
    "419": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928731928698501",
      "endTime": "928732059999144",
      "elapsedTime": "131300643",
      "asyncId": 580,
      "triggerAsyncId": 579,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        581,
        581,
        581,
        581,
        646,
        649,
        654,
        596
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 419
    },
    "420": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731929058275",
      "endTime": "928732060065138",
      "elapsedTime": "131006863",
      "asyncId": 581,
      "triggerAsyncId": 68,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        589,
        591,
        599,
        588,
        597,
        613,
        601,
        588,
        591,
        589,
        593,
        599,
        582,
        582,
        582
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 420
    },
    "421": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731982098624",
      "endTime": "928731992290128",
      "elapsedTime": "10191504",
      "asyncId": 583,
      "triggerAsyncId": 582,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        588,
        588,
        585
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 421
    },
    "422": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731982462806",
      "endTime": "928731992544966",
      "elapsedTime": "10082160",
      "asyncId": 584,
      "triggerAsyncId": 550,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        586,
        586
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 422
    },
    "423": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731983368344",
      "endTime": "928731992846672",
      "elapsedTime": "9478328",
      "asyncId": 586,
      "triggerAsyncId": 584,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        587,
        587,
        587,
        587
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 423
    },
    "424": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731983796977",
      "endTime": "928732004436067",
      "elapsedTime": "20639090",
      "asyncId": 587,
      "triggerAsyncId": 586,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema._validate",
      "userCode": false,
      "triggers": [
        595,
        597,
        605,
        594,
        603,
        619,
        607,
        622,
        597
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 424
    },
    "425": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731984293748",
      "endTime": "928731984359512",
      "elapsedTime": "65764",
      "asyncId": 588,
      "triggerAsyncId": 550,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        589,
        598,
        590,
        590,
        589,
        589,
        589
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 425
    },
    "426": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731984748671",
      "endTime": "928731990711449",
      "elapsedTime": "5962778",
      "asyncId": 589,
      "triggerAsyncId": 588,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        595,
        595,
        599,
        602,
        600,
        604,
        610,
        590,
        590,
        590
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 426
    },
    "427": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731985187634",
      "endTime": "928731992324252",
      "elapsedTime": "7136618",
      "asyncId": 590,
      "triggerAsyncId": 589,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        611,
        614,
        612,
        616,
        620,
        591,
        592
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 427
    },
    "428": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731985578206",
      "endTime": "928731992651466",
      "elapsedTime": "7073260",
      "asyncId": 591,
      "triggerAsyncId": 550,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        592,
        592,
        593
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 428
    },
    "429": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731986324996",
      "endTime": "928731992903728",
      "elapsedTime": "6578732",
      "asyncId": 593,
      "triggerAsyncId": 591,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        616,
        619,
        617,
        621,
        625,
        594,
        594,
        594,
        594
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 429
    },
    "430": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928731986724976",
      "endTime": "928732009947749",
      "elapsedTime": "23222773",
      "asyncId": 594,
      "triggerAsyncId": 593,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema._validate",
      "userCode": false,
      "triggers": [
        604,
        626,
        629,
        627,
        631,
        635,
        595,
        595,
        624,
        627,
        598
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 430
    },
    "431": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731987188755",
      "endTime": "928732019038721",
      "elapsedTime": "31849966",
      "asyncId": 595,
      "triggerAsyncId": 571,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        636,
        639,
        637,
        641,
        645,
        596,
        600
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 431
    },
    "432": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731934211155",
      "endTime": "928732059831730",
      "elapsedTime": "125620575",
      "asyncId": 596,
      "triggerAsyncId": 578,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        604,
        601
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 432
    },
    "433": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731987988224",
      "endTime": "928732004862025",
      "elapsedTime": "16873801",
      "asyncId": 597,
      "triggerAsyncId": 587,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        598,
        598,
        602,
        602
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 433
    },
    "434": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731988753328",
      "endTime": "928732019564256",
      "elapsedTime": "30810928",
      "asyncId": 599,
      "triggerAsyncId": 550,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        622,
        625,
        623,
        627,
        631,
        600,
        600,
        605,
        600,
        601,
        604
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 434
    },
    "435": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731990487229",
      "endTime": "928732019669122",
      "elapsedTime": "29181893",
      "asyncId": 604,
      "triggerAsyncId": 599,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        606,
        605
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 435
    },
    "436": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731992128756",
      "endTime": "928732019819915",
      "elapsedTime": "27691159",
      "asyncId": 605,
      "triggerAsyncId": 604,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        611
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 436
    },
    "437": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731993339716",
      "endTime": "928731993369542",
      "elapsedTime": "29826",
      "asyncId": 606,
      "triggerAsyncId": 569,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        607
      ],
      "uniqueid": 437
    },
    "438": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731993764662",
      "endTime": "928732002878487",
      "elapsedTime": "9113825",
      "asyncId": 607,
      "triggerAsyncId": 606,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        630
      ],
      "uniqueid": 438
    },
    "439": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731994212622",
      "endTime": "928731994256985",
      "elapsedTime": "44363",
      "asyncId": 608,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        617,
        609
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 439
    },
    "440": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731994636116",
      "endTime": "928732003085014",
      "elapsedTime": "8448898",
      "asyncId": 609,
      "triggerAsyncId": 608,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        614
      ],
      "uniqueid": 440
    },
    "441": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731995179224",
      "endTime": "928731995223848",
      "elapsedTime": "44624",
      "asyncId": 610,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        612,
        618,
        612,
        611
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 441
    },
    "442": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731995574295",
      "endTime": "928732003137012",
      "elapsedTime": "7562717",
      "asyncId": 611,
      "triggerAsyncId": 610,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        617,
        612,
        612,
        615,
        613,
        615
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 442
    },
    "443": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928731996609205",
      "endTime": "928731996643830",
      "elapsedTime": "34625",
      "asyncId": 612,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        620,
        623,
        621,
        625,
        631,
        613,
        613,
        617,
        616,
        616,
        618,
        613
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 443
    },
    "444": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928731996955804",
      "endTime": "928732003192936",
      "elapsedTime": "6237132",
      "asyncId": 613,
      "triggerAsyncId": 612,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        632,
        635,
        633,
        637,
        641,
        614,
        614,
        614,
        614,
        616
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 444
    },
    "445": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731997314066",
      "endTime": "928732004229951",
      "elapsedTime": "6915885",
      "asyncId": 614,
      "triggerAsyncId": 609,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        642,
        645,
        643,
        647,
        651,
        615,
        621,
        624,
        622,
        626,
        632,
        615,
        615,
        618
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 445
    },
    "446": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731997710630",
      "endTime": "928732004282759",
      "elapsedTime": "6572129",
      "asyncId": 615,
      "triggerAsyncId": 611,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        633,
        636,
        634,
        638,
        642,
        616,
        619
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 446
    },
    "447": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928731998079491",
      "endTime": "928732004322714",
      "elapsedTime": "6243223",
      "asyncId": 616,
      "triggerAsyncId": 613,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        618,
        618,
        620
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 447
    },
    "448": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928731998450416",
      "endTime": "928732004742431",
      "elapsedTime": "6292015",
      "asyncId": 617,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        623,
        619,
        621
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 448
    },
    "449": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928731999803012",
      "endTime": "928732009255852",
      "elapsedTime": "9452840",
      "asyncId": 621,
      "triggerAsyncId": 617,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        627,
        623,
        622,
        629,
        631
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 449
    },
    "450": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732000264928",
      "endTime": "928732000307177",
      "elapsedTime": "42249",
      "asyncId": 622,
      "triggerAsyncId": 587,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        624,
        628,
        623,
        623
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 450
    },
    "451": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732000660309",
      "endTime": "928732003406156",
      "elapsedTime": "2745847",
      "asyncId": 623,
      "triggerAsyncId": 622,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        629,
        632
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 451
    },
    "452": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732001073283",
      "endTime": "928732001101456",
      "elapsedTime": "28173",
      "asyncId": 624,
      "triggerAsyncId": 594,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        632,
        625,
        625,
        625
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 452
    },
    "453": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732001487650",
      "endTime": "928732003732608",
      "elapsedTime": "2244958",
      "asyncId": 625,
      "triggerAsyncId": 624,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        632,
        635,
        633,
        637,
        643,
        626,
        626,
        626
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 453
    },
    "454": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732001845882",
      "endTime": "928732004576100",
      "elapsedTime": "2730218",
      "asyncId": 626,
      "triggerAsyncId": 625,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        628,
        644,
        647,
        645,
        649,
        653,
        627,
        628
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 454
    },
    "455": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732002175920",
      "endTime": "928732004912059",
      "elapsedTime": "2736139",
      "asyncId": 627,
      "triggerAsyncId": 594,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        633,
        628,
        628,
        629
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 455
    },
    "456": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732002798608",
      "endTime": "928732009370577",
      "elapsedTime": "6571969",
      "asyncId": 629,
      "triggerAsyncId": 627,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        656,
        649,
        648,
        647,
        654,
        658,
        662,
        630,
        633
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 456
    },
    "457": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732003064446",
      "endTime": "928732004136625",
      "elapsedTime": "1072179",
      "asyncId": 630,
      "triggerAsyncId": 607,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 457
    },
    "458": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732003383514",
      "endTime": "928732009807987",
      "elapsedTime": "6424473",
      "asyncId": 631,
      "triggerAsyncId": 621,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 458
    },
    "459": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732003687073",
      "endTime": "928732004511027",
      "elapsedTime": "823954",
      "asyncId": 632,
      "triggerAsyncId": 623,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        638,
        634,
        634
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 459
    },
    "460": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732003966397",
      "endTime": "928732010011088",
      "elapsedTime": "6044691",
      "asyncId": 633,
      "triggerAsyncId": 629,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        636,
        639,
        635,
        639
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 460
    },
    "461": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732005425291",
      "endTime": "928732005450078",
      "elapsedTime": "24787",
      "asyncId": 634,
      "triggerAsyncId": 571,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        635,
        640,
        635
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 461
    },
    "462": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732005845860",
      "endTime": "928732009446810",
      "elapsedTime": "3600950",
      "asyncId": 635,
      "triggerAsyncId": 634,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        637,
        636
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 462
    },
    "463": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732006266729",
      "endTime": "928732010057976",
      "elapsedTime": "3791247",
      "asyncId": 636,
      "triggerAsyncId": 635,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        638,
        642,
        638
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 463
    },
    "464": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732006624740",
      "endTime": "928732010223977",
      "elapsedTime": "3599237",
      "asyncId": 637,
      "triggerAsyncId": 571,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        643,
        643,
        639
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 464
    },
    "465": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732007397699",
      "endTime": "928732014757125",
      "elapsedTime": "7359426",
      "asyncId": 639,
      "triggerAsyncId": 637,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        640,
        640
      ],
      "uniqueid": 465
    },
    "466": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732007689265",
      "endTime": "928732016413800",
      "elapsedTime": "8724535",
      "asyncId": 640,
      "triggerAsyncId": 639,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema._validate",
      "userCode": false,
      "triggers": [
        658,
        641
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 466
    },
    "467": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732008080148",
      "endTime": "928732016609567",
      "elapsedTime": "8529419",
      "asyncId": 641,
      "triggerAsyncId": 640,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        643
      ],
      "uniqueid": 467
    },
    "468": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732008439572",
      "endTime": "928732017538288",
      "elapsedTime": "9098716",
      "asyncId": 642,
      "triggerAsyncId": 571,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        644,
        644
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 468
    },
    "469": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732009153320",
      "endTime": "928732017964217",
      "elapsedTime": "8810897",
      "asyncId": 644,
      "triggerAsyncId": 642,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        646,
        645
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 469
    },
    "470": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732009664819",
      "endTime": "928732018905611",
      "elapsedTime": "9240792",
      "asyncId": 645,
      "triggerAsyncId": 644,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        651
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 470
    },
    "471": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732010748800",
      "endTime": "928732010787363",
      "elapsedTime": "38563",
      "asyncId": 646,
      "triggerAsyncId": 580,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        648,
        647,
        647,
        647
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 471
    },
    "472": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732011198173",
      "endTime": "928732014833207",
      "elapsedTime": "3635034",
      "asyncId": 647,
      "triggerAsyncId": 646,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        653,
        662,
        654,
        657,
        655,
        659,
        665,
        648,
        648,
        655,
        648
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 472
    },
    "473": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732011662283",
      "endTime": "928732015956313",
      "elapsedTime": "4294030",
      "asyncId": 648,
      "triggerAsyncId": 647,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        666,
        669,
        667,
        671,
        675,
        649,
        653,
        650
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 473
    },
    "474": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732012012840",
      "endTime": "928732016280951",
      "elapsedTime": "4268111",
      "asyncId": 649,
      "triggerAsyncId": 580,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        657,
        650,
        652,
        651
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 474
    },
    "475": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732012802901",
      "endTime": "928732016537512",
      "elapsedTime": "3734611",
      "asyncId": 651,
      "triggerAsyncId": 649,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        652,
        652
      ],
      "uniqueid": 475
    },
    "476": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732013170039",
      "endTime": "928732018634734",
      "elapsedTime": "5464695",
      "asyncId": 652,
      "triggerAsyncId": 651,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema._validate",
      "userCode": false,
      "triggers": [
        653,
        655,
        663,
        661,
        653
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 476
    },
    "477": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732013590879",
      "endTime": "928732018958380",
      "elapsedTime": "5367501",
      "asyncId": 653,
      "triggerAsyncId": 652,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        658,
        654,
        660,
        660,
        655
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 477
    },
    "478": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732013931397",
      "endTime": "928732019084296",
      "elapsedTime": "5152899",
      "asyncId": 654,
      "triggerAsyncId": 580,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        656,
        660,
        662,
        656
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 478
    },
    "479": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732014589851",
      "endTime": "928732019272349",
      "elapsedTime": "4682498",
      "asyncId": 656,
      "triggerAsyncId": 654,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        657,
        657,
        668,
        657
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 479
    },
    "480": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732015074910",
      "endTime": "928732019440834",
      "elapsedTime": "4365924",
      "asyncId": 657,
      "triggerAsyncId": 656,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        665,
        667,
        669,
        676,
        666,
        674,
        690,
        658,
        665,
        658,
        658,
        658
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 480
    },
    "481": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732015447880",
      "endTime": "928732015486221",
      "elapsedTime": "38341",
      "asyncId": 658,
      "triggerAsyncId": 640,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        659,
        714,
        716,
        723,
        713,
        721,
        734,
        659,
        659,
        665,
        668,
        666,
        670,
        676,
        659,
        659,
        659
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 481
    },
    "482": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732015839534",
      "endTime": "928732016033437",
      "elapsedTime": "193903",
      "asyncId": 659,
      "triggerAsyncId": 658,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        660,
        758,
        760,
        767,
        757,
        765,
        778,
        678,
        677,
        680,
        678,
        682,
        686,
        660,
        660
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 482
    },
    "483": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732016242459",
      "endTime": "928732016480075",
      "elapsedTime": "237616",
      "asyncId": 660,
      "triggerAsyncId": 659,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        661,
        661,
        661,
        661
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 483
    },
    "484": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732016997715",
      "endTime": "928732017047087",
      "elapsedTime": "49372",
      "asyncId": 661,
      "triggerAsyncId": 652,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        672,
        674,
        682,
        671,
        680,
        696,
        662,
        662,
        662
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 484
    },
    "485": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732017456415",
      "endTime": "928732017684923",
      "elapsedTime": "228508",
      "asyncId": 662,
      "triggerAsyncId": 661,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        734,
        736,
        744,
        733,
        742,
        755,
        663,
        663,
        663
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 485
    },
    "486": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732017910566",
      "endTime": "928732018679578",
      "elapsedTime": "769012",
      "asyncId": 663,
      "triggerAsyncId": 662,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        806,
        808,
        816,
        805,
        814,
        827,
        664,
        664,
        673
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 486
    },
    "487": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732021040613",
      "endTime": "928732021058798",
      "elapsedTime": "18185",
      "asyncId": 664,
      "triggerAsyncId": 502,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        880,
        882,
        890,
        879,
        888,
        901,
        684,
        670,
        670,
        665
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 487
    },
    "488": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732021387764",
      "endTime": "928732024512402",
      "elapsedTime": "3124638",
      "asyncId": 665,
      "triggerAsyncId": 664,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        666,
        667,
        666
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 488
    },
    "489": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732021774850",
      "endTime": "928732024560782",
      "elapsedTime": "2785932",
      "asyncId": 666,
      "triggerAsyncId": 665,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        675,
        668,
        672,
        668
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 489
    },
    "490": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732022235784",
      "endTime": "928732024622388",
      "elapsedTime": "2386604",
      "asyncId": 667,
      "triggerAsyncId": 502,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        673,
        668,
        668,
        669
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 490
    },
    "491": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732023141101",
      "endTime": "928732024694703",
      "elapsedTime": "1553602",
      "asyncId": 669,
      "triggerAsyncId": 667,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        670,
        670,
        719,
        721,
        727,
        718,
        725,
        738,
        687,
        670,
        670
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 491
    },
    "492": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732023476550",
      "endTime": "928732026031329",
      "elapsedTime": "2554779",
      "asyncId": 670,
      "triggerAsyncId": 669,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        681,
        684,
        682,
        686,
        692,
        671,
        671,
        671,
        674,
        671
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 492
    },
    "493": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928732024164710",
      "endTime": "928732066888319",
      "elapsedTime": "42723609",
      "asyncId": 672,
      "triggerAsyncId": 671,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        703,
        706,
        704,
        708,
        712,
        673,
        677,
        680,
        687,
        673
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 493
    },
    "494": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732024401965",
      "endTime": "928732076125064",
      "elapsedTime": "51723099",
      "asyncId": 673,
      "triggerAsyncId": 672,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        747,
        750
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 494
    },
    "495": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732025096176",
      "endTime": "928732025120862",
      "elapsedTime": "24686",
      "asyncId": 674,
      "triggerAsyncId": 670,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        675,
        675,
        675
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 495
    },
    "496": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732025509972",
      "endTime": "928732025630057",
      "elapsedTime": "120085",
      "asyncId": 675,
      "triggerAsyncId": 674,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        687,
        690,
        688,
        692,
        698,
        676,
        676,
        676
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 496
    },
    "497": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732025890074",
      "endTime": "928732026111149",
      "elapsedTime": "221075",
      "asyncId": 676,
      "triggerAsyncId": 675,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        699,
        702,
        700,
        704,
        708,
        677,
        677,
        684,
        684
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 497
    },
    "498": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732026673082",
      "endTime": "928732026704241",
      "elapsedTime": "31159",
      "asyncId": 677,
      "triggerAsyncId": 672,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        711,
        716,
        710,
        709,
        714,
        718,
        722,
        678,
        678,
        679,
        678
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 498
    },
    "499": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732027123657",
      "endTime": "928732031693042",
      "elapsedTime": "4569385",
      "asyncId": 678,
      "triggerAsyncId": 677,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        723,
        726,
        724,
        728,
        732,
        679,
        684,
        679
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 499
    },
    "500": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732027588608",
      "endTime": "928732032168053",
      "elapsedTime": "4579445",
      "asyncId": 679,
      "triggerAsyncId": 678,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        680,
        680,
        680,
        680,
        681
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 500
    },
    "501": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732027995020",
      "endTime": "928732032260546",
      "elapsedTime": "4265526",
      "asyncId": 680,
      "triggerAsyncId": 672,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        687,
        690,
        688,
        692,
        698,
        681,
        681,
        690,
        693,
        691,
        695,
        701,
        681,
        681,
        682
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 501
    },
    "502": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732029089041",
      "endTime": "928732032398475",
      "elapsedTime": "3309434",
      "asyncId": 682,
      "triggerAsyncId": 680,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        688,
        683,
        683
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 502
    },
    "503": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732029453675",
      "endTime": "928732035671099",
      "elapsedTime": "6217424",
      "asyncId": 683,
      "triggerAsyncId": 682,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        691,
        694,
        684
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 503
    },
    "504": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928732030142415",
      "endTime": "928732066552850",
      "elapsedTime": "36410435",
      "asyncId": 685,
      "triggerAsyncId": 684,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        698,
        701,
        708,
        686
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 504
    },
    "505": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732030546473",
      "endTime": "928732066664429",
      "elapsedTime": "36117956",
      "asyncId": 686,
      "triggerAsyncId": 685,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        688
      ],
      "uniqueid": 505
    },
    "506": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732030901388",
      "endTime": "928732066700947",
      "elapsedTime": "35799559",
      "asyncId": 687,
      "triggerAsyncId": 672,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        689,
        689,
        695,
        689
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 506
    },
    "507": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732031565543",
      "endTime": "928732066798170",
      "elapsedTime": "35232627",
      "asyncId": 689,
      "triggerAsyncId": 687,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        690
      ],
      "uniqueid": 507
    },
    "508": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732032144208",
      "endTime": "928732066938052",
      "elapsedTime": "34793844",
      "asyncId": 690,
      "triggerAsyncId": 689,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        692,
        691,
        691
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 508
    },
    "509": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732033062339",
      "endTime": "928732033115860",
      "elapsedTime": "53521",
      "asyncId": 691,
      "triggerAsyncId": 683,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        697,
        698,
        701,
        699,
        703,
        709,
        692,
        692,
        692
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 509
    },
    "510": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732033508496",
      "endTime": "928732035042561",
      "elapsedTime": "1534065",
      "asyncId": 692,
      "triggerAsyncId": 691,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        710,
        713,
        711,
        715,
        719,
        693,
        693
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 510
    },
    "511": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732033844435",
      "endTime": "928732035350699",
      "elapsedTime": "1506264",
      "asyncId": 693,
      "triggerAsyncId": 692,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        695,
        695
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 511
    },
    "512": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732034194712",
      "endTime": "928732035432492",
      "elapsedTime": "1237780",
      "asyncId": 694,
      "triggerAsyncId": 683,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        700,
        696
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 512
    },
    "513": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732034890226",
      "endTime": "928732035532550",
      "elapsedTime": "642324",
      "asyncId": 696,
      "triggerAsyncId": 694,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        697
      ],
      "uniqueid": 513
    },
    "514": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732035284365",
      "endTime": "928732035748665",
      "elapsedTime": "464300",
      "asyncId": 697,
      "triggerAsyncId": 696,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 514
    },
    "515": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732036363267",
      "endTime": "928732036413191",
      "elapsedTime": "49924",
      "asyncId": 698,
      "triggerAsyncId": 685,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        700,
        699
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 515
    },
    "516": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732036851152",
      "endTime": "928732040977196",
      "elapsedTime": "4126044",
      "asyncId": 699,
      "triggerAsyncId": 698,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        701,
        701,
        705,
        700
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 516
    },
    "517": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732037312436",
      "endTime": "928732041290985",
      "elapsedTime": "3978549",
      "asyncId": 700,
      "triggerAsyncId": 699,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        706,
        706,
        702
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 517
    },
    "518": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732037675818",
      "endTime": "928732041343292",
      "elapsedTime": "3667474",
      "asyncId": 701,
      "triggerAsyncId": 685,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        703
      ],
      "uniqueid": 518
    },
    "519": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732038492669",
      "endTime": "928732041482093",
      "elapsedTime": "2989424",
      "asyncId": 703,
      "triggerAsyncId": 701,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        705,
        707,
        704,
        704
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 519
    },
    "520": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732038819852",
      "endTime": "928732042717549",
      "elapsedTime": "3897697",
      "asyncId": 704,
      "triggerAsyncId": 703,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        710,
        706,
        712,
        705
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 520
    },
    "521": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928732039522970",
      "endTime": "928732066211540",
      "elapsedTime": "26688570",
      "asyncId": 706,
      "triggerAsyncId": 705,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        715,
        718,
        725,
        707
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 521
    },
    "522": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732039921457",
      "endTime": "928732066307019",
      "elapsedTime": "26385562",
      "asyncId": 707,
      "triggerAsyncId": 706,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        709
      ],
      "uniqueid": 522
    },
    "523": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732040230947",
      "endTime": "928732066363485",
      "elapsedTime": "26132538",
      "asyncId": 708,
      "triggerAsyncId": 685,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        714,
        710
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 523
    },
    "524": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732040871178",
      "endTime": "928732066465125",
      "elapsedTime": "25593947",
      "asyncId": 710,
      "triggerAsyncId": 708,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        713,
        712,
        711
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 524
    },
    "525": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732041243726",
      "endTime": "928732066596342",
      "elapsedTime": "25352616",
      "asyncId": 711,
      "triggerAsyncId": 710,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        712,
        717
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 525
    },
    "526": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732041877825",
      "endTime": "928732041916968",
      "elapsedTime": "39143",
      "asyncId": 712,
      "triggerAsyncId": 704,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        713,
        713,
        713
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 526
    },
    "527": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732042307861",
      "endTime": "928732042398100",
      "elapsedTime": "90239",
      "asyncId": 713,
      "triggerAsyncId": 712,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        722,
        720,
        723,
        721,
        725,
        731,
        714,
        714,
        714
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 527
    },
    "528": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732042620938",
      "endTime": "928732042768384",
      "elapsedTime": "147446",
      "asyncId": 714,
      "triggerAsyncId": 713,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        720,
        732,
        735,
        733,
        737,
        741,
        715
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 528
    },
    "529": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732043321130",
      "endTime": "928732043356146",
      "elapsedTime": "35016",
      "asyncId": 715,
      "triggerAsyncId": 706,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        716
      ],
      "uniqueid": 529
    },
    "530": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732043804466",
      "endTime": "928732047925662",
      "elapsedTime": "4121196",
      "asyncId": 716,
      "triggerAsyncId": 715,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        717,
        717,
        717
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 530
    },
    "531": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732044269849",
      "endTime": "928732048179858",
      "elapsedTime": "3910009",
      "asyncId": 717,
      "triggerAsyncId": 716,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        725,
        728,
        726,
        730,
        736,
        718,
        718,
        719
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 531
    },
    "532": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732044771189",
      "endTime": "928732048222819",
      "elapsedTime": "3451630",
      "asyncId": 718,
      "triggerAsyncId": 706,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        737,
        740,
        738,
        742,
        746,
        719,
        719,
        726,
        720
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 532
    },
    "533": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732045525953",
      "endTime": "928732048295154",
      "elapsedTime": "2769201",
      "asyncId": 720,
      "triggerAsyncId": 718,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        722,
        728,
        721,
        721
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 533
    },
    "534": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732045912308",
      "endTime": "928732049440531",
      "elapsedTime": "3528223",
      "asyncId": 721,
      "triggerAsyncId": 720,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        727,
        722,
        722,
        729,
        722
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 534
    },
    "535": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928732046638138",
      "endTime": "928732065863648",
      "elapsedTime": "19225510",
      "asyncId": 723,
      "triggerAsyncId": 722,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        725,
        744,
        743,
        749,
        743,
        742,
        741,
        747,
        751,
        756,
        724,
        724,
        724,
        732,
        735,
        740,
        724
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 535
    },
    "536": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732046974579",
      "endTime": "928732065969897",
      "elapsedTime": "18995318",
      "asyncId": 724,
      "triggerAsyncId": 723,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        730,
        731,
        734,
        732,
        736,
        742,
        725,
        725,
        726
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 536
    },
    "537": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732047242511",
      "endTime": "928732066030791",
      "elapsedTime": "18788280",
      "asyncId": 725,
      "triggerAsyncId": 706,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        727,
        743,
        746,
        744,
        748,
        752,
        726,
        727
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 537
    },
    "538": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732047830994",
      "endTime": "928732066104840",
      "elapsedTime": "18273846",
      "asyncId": 727,
      "triggerAsyncId": 725,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        728
      ],
      "uniqueid": 538
    },
    "539": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732048125306",
      "endTime": "928732066249722",
      "elapsedTime": "18124416",
      "asyncId": 728,
      "triggerAsyncId": 727,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 539
    },
    "540": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732048679836",
      "endTime": "928732048713739",
      "elapsedTime": "33903",
      "asyncId": 729,
      "triggerAsyncId": 721,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        731,
        730
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 540
    },
    "541": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732049052755",
      "endTime": "928732049141201",
      "elapsedTime": "88446",
      "asyncId": 730,
      "triggerAsyncId": 729,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        736,
        731
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 541
    },
    "542": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732049350342",
      "endTime": "928732049505654",
      "elapsedTime": "155312",
      "asyncId": 731,
      "triggerAsyncId": 730,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        733
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 542
    },
    "543": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732051946249",
      "endTime": "928732052012332",
      "elapsedTime": "66083",
      "asyncId": 732,
      "triggerAsyncId": 723,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        734,
        738,
        733
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 543
    },
    "544": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732052470061",
      "endTime": "928732061253286",
      "elapsedTime": "8783225",
      "asyncId": 733,
      "triggerAsyncId": 732,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        743,
        739,
        734
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 544
    },
    "545": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732053219185",
      "endTime": "928732061792557",
      "elapsedTime": "8573372",
      "asyncId": 734,
      "triggerAsyncId": 733,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        736
      ],
      "uniqueid": 545
    },
    "546": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732053901855",
      "endTime": "928732061875993",
      "elapsedTime": "7974138",
      "asyncId": 735,
      "triggerAsyncId": 723,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        737
      ],
      "uniqueid": 546
    },
    "547": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732056561030",
      "endTime": "928732061961553",
      "elapsedTime": "5400523",
      "asyncId": 737,
      "triggerAsyncId": 735,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        746,
        749,
        747,
        751,
        757,
        738,
        738,
        739,
        738,
        738
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 547
    },
    "548": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732057344488",
      "endTime": "928732064902426",
      "elapsedTime": "7557938",
      "asyncId": 738,
      "triggerAsyncId": 737,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " StringSchema._validate",
      "userCode": false,
      "triggers": [
        758,
        761,
        759,
        763,
        767,
        739,
        739,
        744,
        744,
        739
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 548
    },
    "549": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732058899643",
      "endTime": "928732065595646",
      "elapsedTime": "6696003",
      "asyncId": 739,
      "triggerAsyncId": 738,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        771,
        784,
        770,
        769,
        768,
        782,
        786,
        790,
        740,
        740,
        741
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 549
    },
    "550": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732059980179",
      "endTime": "928732065646631",
      "elapsedTime": "5666452",
      "asyncId": 740,
      "triggerAsyncId": 723,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        795,
        798,
        796,
        800,
        804,
        741,
        742
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 550
    },
    "551": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732061178876",
      "endTime": "928732065768670",
      "elapsedTime": "4589794",
      "asyncId": 742,
      "triggerAsyncId": 740,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        750,
        746,
        743
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 551
    },
    "552": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732061448602",
      "endTime": "928732065904224",
      "elapsedTime": "4455622",
      "asyncId": 743,
      "triggerAsyncId": 742,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        745,
        745
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 552
    },
    "553": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732062704897",
      "endTime": "928732062744541",
      "elapsedTime": "39644",
      "asyncId": 744,
      "triggerAsyncId": 738,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        754,
        750,
        745
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 553
    },
    "554": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732064451501",
      "endTime": "928732064555376",
      "elapsedTime": "103875",
      "asyncId": 745,
      "triggerAsyncId": 744,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        746,
        746,
        746
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 554
    },
    "555": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732064797029",
      "endTime": "928732064941279",
      "elapsedTime": "144250",
      "asyncId": 746,
      "triggerAsyncId": 745,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        748,
        753,
        756,
        754,
        758,
        764,
        747,
        747
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 555
    },
    "556": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732068123935",
      "endTime": "928732068155214",
      "elapsedTime": "31279",
      "asyncId": 747,
      "triggerAsyncId": 673,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        753,
        749,
        765,
        768,
        766,
        770,
        774,
        748,
        753,
        748
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 556
    },
    "557": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732069273891",
      "endTime": "928732076167694",
      "elapsedTime": "6893803",
      "asyncId": 748,
      "triggerAsyncId": 747,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        754,
        749
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 557
    },
    "558": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732070462298",
      "endTime": "928732076203000",
      "elapsedTime": "5740702",
      "asyncId": 749,
      "triggerAsyncId": 748,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        751
      ],
      "uniqueid": 558
    },
    "559": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732071776362",
      "endTime": "928732076253014",
      "elapsedTime": "4476652",
      "asyncId": 750,
      "triggerAsyncId": 673,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        752
      ],
      "uniqueid": 559
    },
    "560": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732073448907",
      "endTime": "928732076367588",
      "elapsedTime": "2918681",
      "asyncId": 752,
      "triggerAsyncId": 750,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        753,
        753
      ],
      "uniqueid": 560
    },
    "561": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732074363943",
      "endTime": "928732080086670",
      "elapsedTime": "5722727",
      "asyncId": 753,
      "triggerAsyncId": 752,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        755,
        761,
        757,
        754
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 561
    },
    "562": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928732075475917",
      "endTime": "928732098938530",
      "elapsedTime": "23462613",
      "asyncId": 755,
      "triggerAsyncId": 754,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        760,
        763,
        770,
        756
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 562
    },
    "563": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732076075291",
      "endTime": "928732108379016",
      "elapsedTime": "32303725",
      "asyncId": 756,
      "triggerAsyncId": 755,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        757,
        757,
        781,
        784
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 563
    },
    "564": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732077858583",
      "endTime": "928732077887287",
      "elapsedTime": "28704",
      "asyncId": 757,
      "triggerAsyncId": 753,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        766,
        764,
        767,
        765,
        769,
        775,
        758,
        758,
        767,
        758
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 564
    },
    "565": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732079199858",
      "endTime": "928732079271131",
      "elapsedTime": "71273",
      "asyncId": 758,
      "triggerAsyncId": 757,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        760,
        764,
        776,
        779,
        777,
        781,
        785,
        759,
        764,
        759
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 565
    },
    "566": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732079979489",
      "endTime": "928732080133719",
      "elapsedTime": "154230",
      "asyncId": 759,
      "triggerAsyncId": 758,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        765
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 566
    },
    "567": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732081357813",
      "endTime": "928732081400934",
      "elapsedTime": "43121",
      "asyncId": 760,
      "triggerAsyncId": 755,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        761,
        761,
        761
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 567
    },
    "568": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732082514070",
      "endTime": "928732091978122",
      "elapsedTime": "9464052",
      "asyncId": 761,
      "triggerAsyncId": 760,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        769,
        772,
        770,
        774,
        780,
        762,
        762,
        762,
        762,
        762
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 568
    },
    "569": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732083510418",
      "endTime": "928732092156466",
      "elapsedTime": "8646048",
      "asyncId": 762,
      "triggerAsyncId": 761,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        781,
        784,
        782,
        786,
        790,
        763,
        763,
        771,
        773,
        779,
        770,
        777,
        793,
        763,
        763,
        764
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 569
    },
    "570": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732084650986",
      "endTime": "928732092202632",
      "elapsedTime": "7551646",
      "asyncId": 763,
      "triggerAsyncId": 755,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        791,
        794,
        792,
        796,
        800,
        764,
        815,
        817,
        823,
        814,
        821,
        834,
        781,
        765
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 570
    },
    "571": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732086568180",
      "endTime": "928732092412115",
      "elapsedTime": "5843935",
      "asyncId": 765,
      "triggerAsyncId": 763,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        767,
        771,
        766,
        766
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 571
    },
    "572": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732087512641",
      "endTime": "928732098528882",
      "elapsedTime": "11016241",
      "asyncId": 766,
      "triggerAsyncId": 765,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        772,
        774,
        777,
        767
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 572
    },
    "573": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928732088951127",
      "endTime": "928732098682350",
      "elapsedTime": "9731223",
      "asyncId": 768,
      "triggerAsyncId": 767,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        783,
        769
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 573
    },
    "574": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732089517699",
      "endTime": "928732098726121",
      "elapsedTime": "9208422",
      "asyncId": 769,
      "triggerAsyncId": 768,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        781,
        771,
        771
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 574
    },
    "575": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732090576875",
      "endTime": "928732098776326",
      "elapsedTime": "8199451",
      "asyncId": 770,
      "triggerAsyncId": 755,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        780,
        776,
        778,
        772
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 575
    },
    "576": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732091900416",
      "endTime": "928732098885450",
      "elapsedTime": "6985034",
      "asyncId": 772,
      "triggerAsyncId": 770,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        773,
        773
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 576
    },
    "577": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732092136158",
      "endTime": "928732098972383",
      "elapsedTime": "6836225",
      "asyncId": 773,
      "triggerAsyncId": 772,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        774,
        774,
        774
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 577
    },
    "578": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732093027669",
      "endTime": "928732093051454",
      "elapsedTime": "23785",
      "asyncId": 774,
      "triggerAsyncId": 766,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        775,
        775,
        784,
        787,
        785,
        789,
        795,
        775,
        775,
        775
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 578
    },
    "579": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732094343005",
      "endTime": "928732097671464",
      "elapsedTime": "3328459",
      "asyncId": 775,
      "triggerAsyncId": 774,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        792,
        791,
        776,
        793,
        800,
        807,
        799,
        798,
        797,
        796,
        805,
        809,
        813,
        776,
        776
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 579
    },
    "580": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732094900781",
      "endTime": "928732098273964",
      "elapsedTime": "3373183",
      "asyncId": 776,
      "triggerAsyncId": 775,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        777,
        790,
        790,
        778,
        778
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 580
    },
    "581": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732095796810",
      "endTime": "928732098333656",
      "elapsedTime": "2536846",
      "asyncId": 777,
      "triggerAsyncId": 766,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        778,
        783,
        779
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 581
    },
    "582": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732097586836",
      "endTime": "928732098457809",
      "elapsedTime": "870973",
      "asyncId": 779,
      "triggerAsyncId": 777,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        780,
        780,
        780
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 582
    },
    "583": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732098248236",
      "endTime": "928732098591108",
      "elapsedTime": "342872",
      "asyncId": 780,
      "triggerAsyncId": 779,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        797,
        799,
        805,
        796,
        803,
        819,
        781,
        781
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 583
    },
    "584": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732099990612",
      "endTime": "928732100036568",
      "elapsedTime": "45956",
      "asyncId": 781,
      "triggerAsyncId": 756,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        783,
        833,
        835,
        841,
        832,
        839,
        852,
        782,
        782,
        782
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 584
    },
    "585": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732100716202",
      "endTime": "928732108420605",
      "elapsedTime": "7704403",
      "asyncId": 782,
      "triggerAsyncId": 781,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        788,
        788,
        866,
        868,
        874,
        865,
        872,
        885,
        783,
        783,
        783
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 585
    },
    "586": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732102260988",
      "endTime": "928732108466100",
      "elapsedTime": "6205112",
      "asyncId": 783,
      "triggerAsyncId": 782,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        899,
        901,
        907,
        898,
        905,
        918,
        784,
        784,
        785
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 586
    },
    "587": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732102990936",
      "endTime": "928732108499833",
      "elapsedTime": "5508897",
      "asyncId": 784,
      "triggerAsyncId": 756,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        932,
        934,
        940,
        931,
        938,
        951,
        785,
        785,
        786,
        786
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 587
    },
    "588": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732105602712",
      "endTime": "928732108599470",
      "elapsedTime": "2996758",
      "asyncId": 786,
      "triggerAsyncId": 784,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        998,
        1000,
        1006,
        997,
        1004,
        1017,
        787,
        787,
        794,
        787,
        787
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 588
    },
    "589": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732106318754",
      "endTime": "928732110781009",
      "elapsedTime": "4462255",
      "asyncId": 787,
      "triggerAsyncId": 786,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        1031,
        1033,
        1039,
        1030,
        1037,
        1050,
        788,
        788,
        791,
        788
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 589
    },
    "590": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928732107750959",
      "endTime": "928732129995028",
      "elapsedTime": "22244069",
      "asyncId": 789,
      "triggerAsyncId": 788,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        1097,
        1099,
        1105,
        1096,
        1103,
        1116,
        807,
        790,
        790,
        794,
        797,
        804,
        790
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 590
    },
    "591": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732108360452",
      "endTime": "928732130110414",
      "elapsedTime": "21749962",
      "asyncId": 790,
      "triggerAsyncId": 789,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        791,
        797,
        800,
        798,
        802,
        808,
        791,
        791
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 591
    },
    "592": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732109377879",
      "endTime": "928732109404779",
      "elapsedTime": "26900",
      "asyncId": 791,
      "triggerAsyncId": 787,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        794,
        793,
        809,
        812,
        810,
        814,
        818,
        792,
        792
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 592
    },
    "593": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732110019041",
      "endTime": "928732110087810",
      "elapsedTime": "68769",
      "asyncId": 792,
      "triggerAsyncId": 791,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        793,
        798,
        793
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 593
    },
    "594": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732110713904",
      "endTime": "928732110825823",
      "elapsedTime": "111919",
      "asyncId": 793,
      "triggerAsyncId": 792,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 594
    },
    "595": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732112151719",
      "endTime": "928732112174682",
      "elapsedTime": "22963",
      "asyncId": 794,
      "triggerAsyncId": 789,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        795
      ],
      "uniqueid": 595
    },
    "596": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732113113532",
      "endTime": "928732122385944",
      "elapsedTime": "9272412",
      "asyncId": 795,
      "triggerAsyncId": 794,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        797,
        796
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 596
    },
    "597": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732113976560",
      "endTime": "928732122609152",
      "elapsedTime": "8632592",
      "asyncId": 796,
      "triggerAsyncId": 795,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        802,
        804,
        806,
        798
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 597
    },
    "598": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732114729772",
      "endTime": "928732122646823",
      "elapsedTime": "7917051",
      "asyncId": 797,
      "triggerAsyncId": 789,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        804,
        799,
        799
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 598
    },
    "599": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732116335572",
      "endTime": "928732122741751",
      "elapsedTime": "6406179",
      "asyncId": 799,
      "triggerAsyncId": 797,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        800,
        800,
        802,
        800,
        800
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 599
    },
    "600": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732117012310",
      "endTime": "928732128778497",
      "elapsedTime": "11766187",
      "asyncId": 800,
      "triggerAsyncId": 799,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        810,
        813,
        811,
        815,
        821,
        801,
        801,
        801,
        808,
        811,
        801
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 600
    },
    "601": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928732118210566",
      "endTime": "928732129437452",
      "elapsedTime": "11226886",
      "asyncId": 802,
      "triggerAsyncId": 801,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        817,
        803
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 601
    },
    "602": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732119065159",
      "endTime": "928732129473129",
      "elapsedTime": "10407970",
      "asyncId": 803,
      "triggerAsyncId": 802,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        805
      ],
      "uniqueid": 602
    },
    "603": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732120224261",
      "endTime": "928732129505650",
      "elapsedTime": "9281389",
      "asyncId": 804,
      "triggerAsyncId": 789,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        812,
        806
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 603
    },
    "604": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732122296737",
      "endTime": "928732129928523",
      "elapsedTime": "7631786",
      "asyncId": 806,
      "triggerAsyncId": 804,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        807
      ],
      "uniqueid": 604
    },
    "605": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732122585598",
      "endTime": "928732130032768",
      "elapsedTime": "7447170",
      "asyncId": 807,
      "triggerAsyncId": 806,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        808,
        810
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 605
    },
    "606": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732124340187",
      "endTime": "928732124361777",
      "elapsedTime": "21590",
      "asyncId": 808,
      "triggerAsyncId": 800,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        809,
        809,
        813,
        809,
        809
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 606
    },
    "607": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732124782617",
      "endTime": "928732128380742",
      "elapsedTime": "3598125",
      "asyncId": 809,
      "triggerAsyncId": 808,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        818,
        821,
        819,
        823,
        829,
        810,
        810,
        811,
        810
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 607
    },
    "608": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732125783513",
      "endTime": "928732128604350",
      "elapsedTime": "2820837",
      "asyncId": 810,
      "triggerAsyncId": 809,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        830,
        833,
        831,
        835,
        839,
        811,
        811,
        811,
        812,
        816,
        812
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 608
    },
    "609": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732126442458",
      "endTime": "928732128639657",
      "elapsedTime": "2197199",
      "asyncId": 811,
      "triggerAsyncId": 800,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        843,
        856,
        842,
        841,
        840,
        854,
        858,
        862,
        812,
        812,
        817,
        813
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 609
    },
    "610": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732128303196",
      "endTime": "928732128707965",
      "elapsedTime": "404769",
      "asyncId": 813,
      "triggerAsyncId": 811,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        814,
        814
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 610
    },
    "611": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732128576689",
      "endTime": "928732128814535",
      "elapsedTime": "237846",
      "asyncId": 814,
      "triggerAsyncId": 813,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        815,
        822
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 611
    },
    "612": {
      "source": "packages/strapi-admin/controllers/__tests__/role.test.js:150:74:150:74",
      "startTime": "928732131180410",
      "endTime": "928732131215365",
      "elapsedTime": "34955",
      "asyncId": 815,
      "triggerAsyncId": 503,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        816,
        816
      ],
      "line": "\n      const roleID = 1;\n      const findOneRole = jest.fn(() => Promise.resolve({ id: roleID }));\n      const assignPermissions = jest.fn((roleID, permissions) => Promise.resolve(permissions));\n      const inputPermissions = [\n        {\n          action: 'test'",
      "startLine": 150,
      "startCol": 74,
      "endLine": 150,
      "endCol": 74,
      "file": "packages/strapi-admin/controllers/__tests__/role.test.js",
      "uniqueid": 612
    },
    "613": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732132031936",
      "endTime": "928732132162881",
      "elapsedTime": "130945",
      "asyncId": 816,
      "triggerAsyncId": 815,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 613
    },
    "614": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732138566225",
      "endTime": "928732138894270",
      "elapsedTime": "328045",
      "asyncId": 817,
      "triggerAsyncId": 26,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        818,
        818
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 614
    },
    "615": {
      "source": "node_modules/jest-runner/build/runTest.js:442:12:442:12",
      "startTime": "928732139561761",
      "endTime": "928732154693908",
      "elapsedTime": "15132147",
      "asyncId": 818,
      "triggerAsyncId": 49,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        820,
        825,
        828,
        826,
        830,
        836,
        819,
        819,
        833
      ],
      "line": "\n    } // Delay the resolution to allow log messages to be output.\n\n    return new Promise(resolve => {\n      setImmediate(() =>\n        resolve({\n          leakDetector",
      "startLine": 442,
      "startCol": 12,
      "endLine": 442,
      "endCol": 12,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 615
    },
    "616": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731988208126",
      "endTime": "928732006143117",
      "elapsedTime": "17934991",
      "asyncId": 819,
      "triggerAsyncId": 818,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        825,
        841,
        848,
        840,
        839,
        827,
        838,
        837,
        846,
        850,
        854,
        820
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 616
    },
    "617": {
      "source": "node_modules/jest-runner/build/runTest.js:453:23:453:23",
      "startTime": "928732140213172",
      "endTime": "928732150289281",
      "elapsedTime": "10076109",
      "asyncId": 820,
      "triggerAsyncId": 49,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTestInternal",
      "userCode": false,
      "line": "\n    var _runtime$teardown;\n\n    await environment.teardown(); // TODO: this function might be missing, remove ? in Jest 26\n\n    (_runtime$teardown = runtime.teardown) === null ||\n    _runtime$teardown === void ",
      "startLine": 453,
      "startCol": 23,
      "endLine": 453,
      "endCol": 23,
      "file": "node_modules/jest-runner/build/runTest.js",
      "triggers": [
        828
      ],
      "uniqueid": 617
    },
    "618": {
      "source": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js:132:11:132:11",
      "startTime": "928732145713273",
      "endTime": "928732145737719",
      "elapsedTime": "24446",
      "asyncId": 821,
      "triggerAsyncId": 49,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueMutationObserverMicrotask",
      "userCode": false,
      "line": "\n  mutationObserverMicrotaskQueueFlag = true;\n\n  Promise.resolve().then(() => {\n    notifyMutationObservers();\n  });\n",
      "startLine": 132,
      "startCol": 11,
      "endLine": 132,
      "endCol": 11,
      "file": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js",
      "triggers": [
        822
      ],
      "uniqueid": 618
    },
    "619": {
      "source": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js:132:21:132:21",
      "startTime": "928732146470382",
      "endTime": "928732150884076",
      "elapsedTime": "4413694",
      "asyncId": 822,
      "triggerAsyncId": 821,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueMutationObserverMicrotask",
      "userCode": false,
      "triggers": [
        824,
        823,
        823
      ],
      "line": "\n  mutationObserverMicrotaskQueueFlag = true;\n\n  Promise.resolve().then(() => {\n    notifyMutationObservers();\n  });\n",
      "startLine": 132,
      "startCol": 21,
      "endLine": 132,
      "endCol": 21,
      "file": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js",
      "uniqueid": 619
    },
    "620": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:446:34:446:34",
      "startTime": "928732147754499",
      "endTime": "928732147777091",
      "elapsedTime": "22592",
      "asyncId": 823,
      "triggerAsyncId": 49,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " DocumentImpl.close",
      "userCode": false,
      "triggers": [
        829,
        830,
        833,
        831,
        835,
        841,
        824,
        824,
        824,
        826
      ],
      "line": "\n    this._queue.resume();\n\n    const dummyPromise = Promise.resolve();\n\n    const onDOMContentLoad = () => {\n      const doc = this",
      "startLine": 446,
      "startCol": 34,
      "endLine": 446,
      "endCol": 34,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "uniqueid": 620
    },
    "621": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:116:8:116:8",
      "startTime": "928732148203501",
      "endTime": "928732152100716",
      "elapsedTime": "3897215",
      "asyncId": 824,
      "triggerAsyncId": 823,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ResourceQueue.push",
      "userCode": false,
      "triggers": [
        842,
        845,
        843,
        847,
        851,
        825,
        829,
        825
      ],
      "line": "\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check()",
      "startLine": 116,
      "startCol": 8,
      "endLine": 116,
      "endCol": 8,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 621
    },
    "622": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:116:8:116:8",
      "startTime": "928732149345642",
      "endTime": "928732152137816",
      "elapsedTime": "2792174",
      "asyncId": 826,
      "triggerAsyncId": 823,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ResourceQueue.push",
      "userCode": false,
      "triggers": [
        832,
        827
      ],
      "line": "\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check()",
      "startLine": 116,
      "startCol": 8,
      "endLine": 116,
      "endCol": 8,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 622
    },
    "623": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732150788126",
      "endTime": "928732152351998",
      "elapsedTime": "1563872",
      "asyncId": 828,
      "triggerAsyncId": 820,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 623
    },
    "624": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:456:14:456:14",
      "startTime": "928732151395545",
      "endTime": "928732151597002",
      "elapsedTime": "201457",
      "asyncId": 829,
      "triggerAsyncId": 824,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " onDOMContentLoad",
      "userCode": false,
      "line": "\n      }\n\n      return new Promise(resolve => {\n        if (!this._deferQueue.tail) {\n          dispatchEvent();\n          return resolve()",
      "startLine": 456,
      "startCol": 14,
      "endLine": 456,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "triggers": [
        830
      ],
      "uniqueid": 624
    },
    "625": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:80:14:80:14",
      "startTime": "928732152083274",
      "endTime": "928732153507373",
      "elapsedTime": "1424099",
      "asyncId": 830,
      "triggerAsyncId": 829,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.check",
      "userCode": false,
      "triggers": [
        832,
        832,
        831
      ],
      "line": "\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check()",
      "startLine": 80,
      "startCol": 14,
      "endLine": 80,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 625
    },
    "626": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:478:14:478:14",
      "startTime": "928732152865400",
      "endTime": "928732152980946",
      "elapsedTime": "115546",
      "asyncId": 831,
      "triggerAsyncId": 830,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " onLoad",
      "userCode": false,
      "triggers": [
        837,
        837,
        832
      ],
      "line": "\n      }\n\n      return new Promise(resolve => {\n        if (this._asyncQueue.count() === 0) {\n          dispatchEvent();\n          return resolve()",
      "startLine": 478,
      "startCol": 14,
      "endLine": 478,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "uniqueid": 626
    },
    "627": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:80:14:80:14",
      "startTime": "928732153477908",
      "endTime": "928732154051243",
      "elapsedTime": "573335",
      "asyncId": 832,
      "triggerAsyncId": 831,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.check",
      "userCode": false,
      "triggers": [
        840
      ],
      "line": "\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check()",
      "startLine": 80,
      "startCol": 14,
      "endLine": 80,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 627
    },
    "628": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732154033900",
      "endTime": "928732154762226",
      "elapsedTime": "728326",
      "asyncId": 833,
      "triggerAsyncId": 818,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 628
    },
    "629": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732001623505",
      "endTime": "928732002602820",
      "elapsedTime": "979315",
      "asyncId": 835,
      "triggerAsyncId": 823,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        836,
        836
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 629
    },
    "630": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731992213695",
      "endTime": "928732005749098",
      "elapsedTime": "13535403",
      "asyncId": 837,
      "triggerAsyncId": 819,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        855,
        858,
        856,
        860,
        864,
        838,
        847
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 630
    },
    "631": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731992704265",
      "endTime": "928732005639874",
      "elapsedTime": "12935609",
      "asyncId": 838,
      "triggerAsyncId": 819,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [
        845
      ],
      "uniqueid": 631
    },
    "632": {
      "source": "packages/strapi-admin/services/role.js:208:32:208:32",
      "startTime": "928731993328715",
      "endTime": "928731995991136",
      "elapsedTime": "2662421",
      "asyncId": 840,
      "triggerAsyncId": 819,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.createRolesIfNoneExist",
      "userCode": false,
      "triggers": [
        855,
        843
      ],
      "line": "\n */\nconst createRolesIfNoneExist = async () => {\n  const someRolesExist = await exists();\n  if (someRolesExist) {\n    return;\n  ",
      "startLine": 208,
      "startCol": 32,
      "endLine": 208,
      "endCol": 32,
      "file": "packages/strapi-admin/services/role.js",
      "uniqueid": 632
    },
    "633": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732002903103",
      "endTime": "928732003211371",
      "elapsedTime": "308268",
      "asyncId": 842,
      "triggerAsyncId": 824,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        852,
        844
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 633
    },
    "634": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732003396338",
      "endTime": "928732004610304",
      "elapsedTime": "1213966",
      "asyncId": 843,
      "triggerAsyncId": 824,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        844,
        845,
        857,
        856,
        855,
        849
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 634
    },
    "635": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928731994499290",
      "endTime": "928732005686301",
      "elapsedTime": "11187011",
      "asyncId": 844,
      "triggerAsyncId": 839,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        845,
        850
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 635
    },
    "636": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928731994720244",
      "endTime": "928732005805745",
      "elapsedTime": "11085501",
      "asyncId": 845,
      "triggerAsyncId": 838,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        846
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 636
    },
    "637": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731994898979",
      "endTime": "928732005858133",
      "elapsedTime": "10959154",
      "asyncId": 846,
      "triggerAsyncId": 819,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        847,
        847,
        852
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 637
    },
    "638": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731995308456",
      "endTime": "928731995327362",
      "elapsedTime": "18906",
      "asyncId": 848,
      "triggerAsyncId": 819,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        849
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 638
    },
    "639": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732004506439",
      "endTime": "928732005096355",
      "elapsedTime": "589916",
      "asyncId": 849,
      "triggerAsyncId": 843,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        850
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 639
    },
    "640": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731995665636",
      "endTime": "928732005969872",
      "elapsedTime": "10304236",
      "asyncId": 850,
      "triggerAsyncId": 819,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        851
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 640
    },
    "641": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732005704525",
      "endTime": "928732013766347",
      "elapsedTime": "8061822",
      "asyncId": 852,
      "triggerAsyncId": 573,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        860
      ],
      "uniqueid": 641
    },
    "642": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732005989810",
      "endTime": "928732006032379",
      "elapsedTime": "42569",
      "asyncId": 853,
      "triggerAsyncId": 573,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 642
    },
    "643": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732006591758",
      "endTime": "928732006643655",
      "elapsedTime": "51897",
      "asyncId": 855,
      "triggerAsyncId": 573,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        857,
        860,
        856,
        856
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 643
    },
    "644": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732006944159",
      "endTime": "928732011015150",
      "elapsedTime": "4070991",
      "asyncId": 856,
      "triggerAsyncId": 855,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        862,
        859,
        863,
        866,
        864,
        868,
        874,
        857,
        857
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 644
    },
    "645": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732007218293",
      "endTime": "928732013659848",
      "elapsedTime": "6441555",
      "asyncId": 857,
      "triggerAsyncId": 856,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        858,
        875,
        878,
        876,
        880,
        884,
        858
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 645
    },
    "646": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732007443555",
      "endTime": "928732013841448",
      "elapsedTime": "6397893",
      "asyncId": 858,
      "triggerAsyncId": 857,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 646
    },
    "647": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732007620907",
      "endTime": "928732013886242",
      "elapsedTime": "6265335",
      "asyncId": 859,
      "triggerAsyncId": 573,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 647
    },
    "648": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732008042127",
      "endTime": "928732008063417",
      "elapsedTime": "21290",
      "asyncId": 861,
      "triggerAsyncId": 573,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        862
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 648
    },
    "649": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928731998545254",
      "endTime": "928731999866781",
      "elapsedTime": "1321527",
      "asyncId": 862,
      "triggerAsyncId": 861,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        865,
        864,
        863
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 649
    },
    "650": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732008485899",
      "endTime": "928732008527857",
      "elapsedTime": "41958",
      "asyncId": 863,
      "triggerAsyncId": 856,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        866,
        868,
        865
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 650
    },
    "651": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732008705430",
      "endTime": "928732010392172",
      "elapsedTime": "1686742",
      "asyncId": 864,
      "triggerAsyncId": 856,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        867,
        867,
        870
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 651
    },
    "652": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732009104438",
      "endTime": "928732009139664",
      "elapsedTime": "35226",
      "asyncId": 866,
      "triggerAsyncId": 856,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 652
    },
    "653": {
      "source": "packages/strapi-admin/services/role.js:225:28:225:28",
      "startTime": "928731999652439",
      "endTime": "928732000072156",
      "elapsedTime": "419717",
      "asyncId": 867,
      "triggerAsyncId": 864,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.createRolesIfNoneExist",
      "userCode": false,
      "line": "\n  await strapi.admin.services.user.assignARoleToAll(superAdminRole.id);\n\n  const editorRole = await create({\n    name: 'Editor',\n    code: 'strapi-editor',\n    description: 'Editors can manage and publish contents including those of other users.'",
      "startLine": 225,
      "startCol": 28,
      "endLine": 225,
      "endCol": 28,
      "file": "packages/strapi-admin/services/role.js",
      "triggers": [],
      "uniqueid": 653
    },
    "654": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732009594106",
      "endTime": "928732010833339",
      "elapsedTime": "1239233",
      "asyncId": 868,
      "triggerAsyncId": 856,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        869,
        869,
        871,
        870,
        869
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 654
    },
    "655": {
      "source": "packages/strapi-admin/services/role.js:231:28:231:28",
      "startTime": "928732000277702",
      "endTime": "928732001590783",
      "elapsedTime": "1313081",
      "asyncId": 869,
      "triggerAsyncId": 868,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.createRolesIfNoneExist",
      "userCode": false,
      "triggers": [
        871,
        876,
        879,
        877,
        881,
        887,
        870,
        870,
        874
      ],
      "line": "\n  });\n\n  const authorRole = await create({\n    name: 'Author',\n    code: 'strapi-author',\n    description: 'Authors can manage the content they have created.'",
      "startLine": 231,
      "startCol": 28,
      "endLine": 231,
      "endCol": 28,
      "file": "packages/strapi-admin/services/role.js",
      "uniqueid": 655
    },
    "656": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732009869723",
      "endTime": "928732010908731",
      "elapsedTime": "1039008",
      "asyncId": 870,
      "triggerAsyncId": 864,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        876,
        888,
        891,
        889,
        893,
        897,
        871,
        873
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 656
    },
    "657": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:365:43:365:43",
      "startTime": "928732000728517",
      "endTime": "928732000745549",
      "elapsedTime": "17032",
      "asyncId": 871,
      "triggerAsyncId": 868,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      ];\n\n      const count = jest.fn(() => Promise.resolve(0));\n      let id = 1;\n      const create = jest.fn(role => ({ ...role, id: id++ }));\n      const getAll = jest.fn(() => actions)",
      "startLine": 365,
      "startCol": 43,
      "endLine": 365,
      "endCol": 43,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [
        872
      ],
      "uniqueid": 657
    },
    "658": {
      "source": "packages/strapi-admin/services/role.js:231:28:231:28",
      "startTime": "928732001176557",
      "endTime": "928732001628003",
      "elapsedTime": "451446",
      "asyncId": 873,
      "triggerAsyncId": 870,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.createRolesIfNoneExist",
      "userCode": false,
      "line": "\n  });\n\n  const authorRole = await create({\n    name: 'Author',\n    code: 'strapi-author',\n    description: 'Authors can manage the content they have created.'",
      "startLine": 231,
      "startCol": 28,
      "endLine": 231,
      "endCol": 28,
      "file": "packages/strapi-admin/services/role.js",
      "triggers": [],
      "uniqueid": 658
    },
    "659": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732011305544",
      "endTime": "928732011561294",
      "elapsedTime": "255750",
      "asyncId": 875,
      "triggerAsyncId": 857,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        876,
        877
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 659
    },
    "660": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732011819217",
      "endTime": "928732012995212",
      "elapsedTime": "1175995",
      "asyncId": 876,
      "triggerAsyncId": 857,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        878,
        877,
        882
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 660
    },
    "661": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732012233985",
      "endTime": "928732012282927",
      "elapsedTime": "48942",
      "asyncId": 878,
      "triggerAsyncId": 857,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 661
    },
    "662": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732007420552",
      "endTime": "928732052036117",
      "elapsedTime": "44615565",
      "asyncId": 879,
      "triggerAsyncId": 79,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        889,
        890
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 662
    },
    "663": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732007663457",
      "endTime": "928732052072545",
      "elapsedTime": "44409088",
      "asyncId": 880,
      "triggerAsyncId": 79,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        887,
        887
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 663
    },
    "664": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732007966204",
      "endTime": "928732008024925",
      "elapsedTime": "58721",
      "asyncId": 881,
      "triggerAsyncId": 79,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 664
    },
    "665": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732012926172",
      "endTime": "928732013551605",
      "elapsedTime": "625433",
      "asyncId": 882,
      "triggerAsyncId": 876,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        883,
        883
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 665
    },
    "666": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732008555689",
      "endTime": "928732008586257",
      "elapsedTime": "30568",
      "asyncId": 883,
      "triggerAsyncId": 79,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        892,
        895,
        893,
        897,
        903,
        884,
        884,
        884,
        884
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 666
    },
    "667": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732008888213",
      "endTime": "928732026288621",
      "elapsedTime": "17400408",
      "asyncId": 884,
      "triggerAsyncId": 883,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        904,
        907,
        905,
        909,
        913,
        885,
        885,
        894,
        896,
        902,
        893,
        900,
        916,
        885,
        885
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 667
    },
    "668": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732009186572",
      "endTime": "928732039344876",
      "elapsedTime": "30158304",
      "asyncId": 885,
      "triggerAsyncId": 884,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        917,
        930,
        916,
        915,
        914,
        928,
        932,
        936,
        886,
        886,
        893,
        944,
        946,
        952,
        943,
        950,
        963,
        886,
        886
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 668
    },
    "669": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732009461367",
      "endTime": "928732051763366",
      "elapsedTime": "42301999",
      "asyncId": 886,
      "triggerAsyncId": 885,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        941,
        944,
        942,
        946,
        950,
        887,
        987,
        989,
        995,
        986,
        993,
        1006,
        904
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 669
    },
    "670": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732009705655",
      "endTime": "928732051896425",
      "elapsedTime": "42190770",
      "asyncId": 887,
      "triggerAsyncId": 880,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        888
      ],
      "uniqueid": 670
    },
    "671": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732009983877",
      "endTime": "928732052109094",
      "elapsedTime": "42125217",
      "asyncId": 888,
      "triggerAsyncId": 887,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        890,
        889,
        889
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 671
    },
    "672": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732010280493",
      "endTime": "928732052154349",
      "elapsedTime": "41873856",
      "asyncId": 889,
      "triggerAsyncId": 79,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        895,
        896,
        899,
        897,
        901,
        907,
        890,
        890
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 672
    },
    "673": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732016208165",
      "endTime": "928732022591300",
      "elapsedTime": "6383135",
      "asyncId": 891,
      "triggerAsyncId": 890,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 673
    },
    "674": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732016381860",
      "endTime": "928732022635173",
      "elapsedTime": "6253313",
      "asyncId": 892,
      "triggerAsyncId": 574,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        894
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 674
    },
    "675": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732011250271",
      "endTime": "928732025985142",
      "elapsedTime": "14734871",
      "asyncId": 893,
      "triggerAsyncId": 884,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        899,
        901
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 675
    },
    "676": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732016798451",
      "endTime": "928732016832224",
      "elapsedTime": "33773",
      "asyncId": 894,
      "triggerAsyncId": 574,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 676
    },
    "677": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731011093564",
      "endTime": "928731011748452",
      "elapsedTime": "654888",
      "asyncId": 895,
      "triggerAsyncId": 889,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 677
    },
    "678": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732017340147",
      "endTime": "928732017401943",
      "elapsedTime": "61796",
      "asyncId": 896,
      "triggerAsyncId": 889,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        897,
        897,
        898
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 678
    },
    "679": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732017680935",
      "endTime": "928732019263582",
      "elapsedTime": "1582647",
      "asyncId": 897,
      "triggerAsyncId": 889,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        907,
        910,
        908,
        912,
        918,
        903,
        898,
        898
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 679
    },
    "680": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732012846593",
      "endTime": "928732025812489",
      "elapsedTime": "12965896",
      "asyncId": 898,
      "triggerAsyncId": 897,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        906,
        930,
        922,
        921,
        920,
        919,
        928,
        932,
        939,
        899
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 680
    },
    "681": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732013139622",
      "endTime": "928732026048391",
      "elapsedTime": "12908769",
      "asyncId": 899,
      "triggerAsyncId": 898,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 681
    },
    "682": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732013365446",
      "endTime": "928732026115156",
      "elapsedTime": "12749710",
      "asyncId": 900,
      "triggerAsyncId": 884,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 682
    },
    "683": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732013730510",
      "endTime": "928732013779021",
      "elapsedTime": "48511",
      "asyncId": 902,
      "triggerAsyncId": 884,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        909,
        912,
        910,
        914,
        920,
        903,
        903
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 683
    },
    "684": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732018764537",
      "endTime": "928732019792814",
      "elapsedTime": "1028277",
      "asyncId": 903,
      "triggerAsyncId": 897,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        921,
        924,
        922,
        926,
        930,
        904
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 684
    },
    "685": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732014254953",
      "endTime": "928732051924698",
      "elapsedTime": "37669745",
      "asyncId": 904,
      "triggerAsyncId": 886,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        906
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 685
    },
    "686": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732020199206",
      "endTime": "928732020475354",
      "elapsedTime": "276148",
      "asyncId": 908,
      "triggerAsyncId": 890,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        914,
        910
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 686
    },
    "687": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732020675980",
      "endTime": "928732021820626",
      "elapsedTime": "1144646",
      "asyncId": 909,
      "triggerAsyncId": 890,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        911,
        915
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 687
    },
    "688": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732021046184",
      "endTime": "928732021064609",
      "elapsedTime": "18425",
      "asyncId": 911,
      "triggerAsyncId": 890,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 688
    },
    "689": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732015979717",
      "endTime": "928732017155761",
      "elapsedTime": "1176044",
      "asyncId": 912,
      "triggerAsyncId": 897,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 689
    },
    "690": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732021453117",
      "endTime": "928732022285086",
      "elapsedTime": "831969",
      "asyncId": 913,
      "triggerAsyncId": 890,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 690
    },
    "691": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732016258128",
      "endTime": "928732017200926",
      "elapsedTime": "942798",
      "asyncId": 914,
      "triggerAsyncId": 908,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        929
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 691
    },
    "692": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732021701222",
      "endTime": "928732022322767",
      "elapsedTime": "621545",
      "asyncId": 915,
      "triggerAsyncId": 909,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        927
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 692
    },
    "693": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732023034361",
      "endTime": "928732031598725",
      "elapsedTime": "8564364",
      "asyncId": 918,
      "triggerAsyncId": 575,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        919,
        926
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 693
    },
    "694": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732017669664",
      "endTime": "928732025342127",
      "elapsedTime": "7672463",
      "asyncId": 919,
      "triggerAsyncId": 898,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        920,
        929
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 694
    },
    "695": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732018087017",
      "endTime": "928732025205471",
      "elapsedTime": "7118454",
      "asyncId": 920,
      "triggerAsyncId": 898,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        921,
        921,
        927
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 695
    },
    "696": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:439:25:439:25",
      "startTime": "928732018519558",
      "endTime": "928732024998944",
      "elapsedTime": "6479386",
      "asyncId": 921,
      "triggerAsyncId": 898,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        938,
        937,
        922,
        923,
        926,
        922,
        922
      ],
      "line": "\n      };\n\n      await roleService.displayWarningIfNoSuperAdmin();\n\n      expect(warn).toHaveBeenCalledTimes(0);\n    })",
      "startLine": 439,
      "startCol": 25,
      "endLine": 439,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "uniqueid": 696
    },
    "697": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732024272672",
      "endTime": "928732028746749",
      "elapsedTime": "4474077",
      "asyncId": 922,
      "triggerAsyncId": 921,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        923,
        928,
        923,
        925,
        929,
        932,
        930,
        934,
        940,
        923,
        923
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 697
    },
    "698": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732024567956",
      "endTime": "928732031478811",
      "elapsedTime": "6910855",
      "asyncId": 923,
      "triggerAsyncId": 922,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        924,
        924,
        941,
        944,
        942,
        946,
        950,
        924
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 698
    },
    "699": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732024796044",
      "endTime": "928732031656704",
      "elapsedTime": "6860660",
      "asyncId": 924,
      "triggerAsyncId": 923,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        925,
        936,
        935,
        935
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 699
    },
    "700": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732025017719",
      "endTime": "928732031718139",
      "elapsedTime": "6700420",
      "asyncId": 925,
      "triggerAsyncId": 575,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        941
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 700
    },
    "701": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732025456281",
      "endTime": "928732025518167",
      "elapsedTime": "61886",
      "asyncId": 927,
      "triggerAsyncId": 575,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 701
    },
    "702": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732020402608",
      "endTime": "928732025461872",
      "elapsedTime": "5059264",
      "asyncId": 928,
      "triggerAsyncId": 898,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        934,
        934
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 702
    },
    "703": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732026127860",
      "endTime": "928732026174958",
      "elapsedTime": "47098",
      "asyncId": 929,
      "triggerAsyncId": 922,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        931
      ],
      "uniqueid": 703
    },
    "704": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732026393238",
      "endTime": "928732027975484",
      "elapsedTime": "1582246",
      "asyncId": 930,
      "triggerAsyncId": 922,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        936
      ],
      "uniqueid": 704
    },
    "705": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732026785162",
      "endTime": "928732026824776",
      "elapsedTime": "39614",
      "asyncId": 932,
      "triggerAsyncId": 922,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 705
    },
    "706": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732027265342",
      "endTime": "928732028513282",
      "elapsedTime": "1247940",
      "asyncId": 934,
      "triggerAsyncId": 922,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        935,
        935
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 706
    },
    "707": {
      "source": "packages/strapi-admin/services/role.js:78:29:78:29",
      "startTime": "928732021675073",
      "endTime": "928732022962596",
      "elapsedTime": "1287523",
      "asyncId": 935,
      "triggerAsyncId": 924,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " findOneWithUsersCount",
      "userCode": false,
      "triggers": [
        942,
        945,
        943,
        947,
        953,
        936,
        936,
        937
      ],
      "line": "\n\n  if (role) {\n    role.usersCount = await getUsersCount(role.id);\n  }\n\n  return role",
      "startLine": 78,
      "startCol": 29,
      "endLine": 78,
      "endCol": 29,
      "file": "packages/strapi-admin/services/role.js",
      "uniqueid": 707
    },
    "708": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732027526021",
      "endTime": "928732028595335",
      "elapsedTime": "1069314",
      "asyncId": 936,
      "triggerAsyncId": 930,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        954,
        957,
        955,
        959,
        963,
        937,
        940
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 708
    },
    "709": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732022330582",
      "endTime": "928732023098080",
      "elapsedTime": "767498",
      "asyncId": 937,
      "triggerAsyncId": 935,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        940
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 709
    },
    "710": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732029022366",
      "endTime": "928732029274899",
      "elapsedTime": "252533",
      "asyncId": 941,
      "triggerAsyncId": 923,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        943,
        942,
        943
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 710
    },
    "711": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732029549815",
      "endTime": "928732030786423",
      "elapsedTime": "1236608",
      "asyncId": 942,
      "triggerAsyncId": 923,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        948,
        944,
        948
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 711
    },
    "712": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732026536406",
      "endTime": "928732039048491",
      "elapsedTime": "12512085",
      "asyncId": 943,
      "triggerAsyncId": 885,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        949,
        951
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 712
    },
    "713": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732029944535",
      "endTime": "928732029970964",
      "elapsedTime": "26429",
      "asyncId": 944,
      "triggerAsyncId": 923,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 713
    },
    "714": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731021945998",
      "endTime": "928731021966236",
      "elapsedTime": "20238",
      "asyncId": 945,
      "triggerAsyncId": 935,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 714
    },
    "715": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732030458659",
      "endTime": "928732031284236",
      "elapsedTime": "825577",
      "asyncId": 946,
      "triggerAsyncId": 923,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        947,
        947
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 715
    },
    "716": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732027943043",
      "endTime": "928732032638385",
      "elapsedTime": "4695342",
      "asyncId": 947,
      "triggerAsyncId": 946,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        954,
        957,
        955,
        959,
        965,
        948,
        948
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 716
    },
    "717": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732028283431",
      "endTime": "928732038916974",
      "elapsedTime": "10633543",
      "asyncId": 948,
      "triggerAsyncId": 947,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        977,
        969,
        968,
        967,
        966,
        975,
        979,
        983,
        949
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 717
    },
    "718": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732028539922",
      "endTime": "928732039098284",
      "elapsedTime": "10558362",
      "asyncId": 949,
      "triggerAsyncId": 948,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 718
    },
    "719": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732028794308",
      "endTime": "928732039151775",
      "elapsedTime": "10357467",
      "asyncId": 950,
      "triggerAsyncId": 885,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 719
    },
    "720": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732032407852",
      "endTime": "928732040950306",
      "elapsedTime": "8542454",
      "asyncId": 951,
      "triggerAsyncId": 576,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        961,
        959
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 720
    },
    "721": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732032733833",
      "endTime": "928732032779559",
      "elapsedTime": "45726",
      "asyncId": 952,
      "triggerAsyncId": 576,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        958,
        958
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 721
    },
    "722": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732033348015",
      "endTime": "928732033372551",
      "elapsedTime": "24536",
      "asyncId": 954,
      "triggerAsyncId": 576,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        956,
        956,
        955,
        955
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 722
    },
    "723": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732033650892",
      "endTime": "928732038129358",
      "elapsedTime": "4478466",
      "asyncId": 955,
      "triggerAsyncId": 954,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        956,
        956,
        961,
        961,
        962,
        965,
        963,
        967,
        973,
        956,
        956
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 723
    },
    "724": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732033950374",
      "endTime": "928732040825753",
      "elapsedTime": "6875379",
      "asyncId": 956,
      "triggerAsyncId": 955,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        965,
        967,
        976,
        964,
        974,
        990,
        957,
        957,
        974,
        977,
        975,
        979,
        983,
        957
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 724
    },
    "725": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732034220450",
      "endTime": "928732041023263",
      "elapsedTime": "6802813",
      "asyncId": 957,
      "triggerAsyncId": 956,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        1034,
        1036,
        1045,
        1033,
        1043,
        1056,
        978
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 725
    },
    "726": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732034459709",
      "endTime": "928732041088395",
      "elapsedTime": "6628686",
      "asyncId": 958,
      "triggerAsyncId": 576,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        959
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 726
    },
    "727": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732034875278",
      "endTime": "928732034922676",
      "elapsedTime": "47398",
      "asyncId": 960,
      "triggerAsyncId": 576,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 727
    },
    "728": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732031242758",
      "endTime": "928732032520824",
      "elapsedTime": "1278066",
      "asyncId": 961,
      "triggerAsyncId": 955,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 728
    },
    "729": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732035509467",
      "endTime": "928732035547207",
      "elapsedTime": "37740",
      "asyncId": 962,
      "triggerAsyncId": 955,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        964
      ],
      "uniqueid": 729
    },
    "730": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732036268610",
      "endTime": "928732036327209",
      "elapsedTime": "58599",
      "asyncId": 965,
      "triggerAsyncId": 955,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 730
    },
    "731": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732032929911",
      "endTime": "928732038562650",
      "elapsedTime": "5632739",
      "asyncId": 966,
      "triggerAsyncId": 948,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        976
      ],
      "uniqueid": 731
    },
    "732": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732033320092",
      "endTime": "928732038454227",
      "elapsedTime": "5134135",
      "asyncId": 967,
      "triggerAsyncId": 948,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        968,
        968,
        968,
        968,
        974
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 732
    },
    "733": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:455:25:455:25",
      "startTime": "928732033669227",
      "endTime": "928732038224777",
      "elapsedTime": "4555550",
      "asyncId": 968,
      "triggerAsyncId": 948,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        981,
        984,
        982,
        986,
        992,
        969,
        969,
        975,
        978,
        976,
        980,
        986,
        969,
        969,
        973
      ],
      "line": "\n      };\n\n      await roleService.displayWarningIfNoSuperAdmin();\n\n      expect(warn).toHaveBeenCalledWith(\"Your application doesn't have a super admin role.\");\n    })",
      "startLine": 455,
      "startCol": 25,
      "endLine": 455,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "uniqueid": 733
    },
    "734": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732037026961",
      "endTime": "928732037987773",
      "elapsedTime": "960812",
      "asyncId": 969,
      "triggerAsyncId": 963,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        993,
        996,
        994,
        998,
        1002,
        970,
        970,
        987,
        990,
        988,
        992,
        996,
        970,
        970,
        972
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 734
    },
    "735": {
      "source": "packages/strapi-admin/services/role.js:202:43:202:43",
      "startTime": "928732034354792",
      "endTime": "928732034645196",
      "elapsedTime": "290404",
      "asyncId": 970,
      "triggerAsyncId": 969,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " getSuperAdminWithUsersCount",
      "userCode": false,
      "triggers": [
        1003,
        1006,
        1004,
        1008,
        1012,
        971,
        971,
        971
      ],
      "line": "\n * @returns {Promise<role>}\n */\nconst getSuperAdminWithUsersCount = () => findOneWithUsersCount({ code: SUPER_ADMIN_CODE });\n\n/** Create superAdmin, Author and Editor role is no role already exist\n * @returns {Promise<>",
      "startLine": 202,
      "startCol": 43,
      "endLine": 202,
      "endCol": 43,
      "file": "packages/strapi-admin/services/role.js",
      "uniqueid": 735
    },
    "736": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:455:25:455:25",
      "startTime": "928732034930170",
      "endTime": "928732038171166",
      "elapsedTime": "3240996",
      "asyncId": 972,
      "triggerAsyncId": 969,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        1023,
        1026,
        1024,
        1028,
        1032,
        973,
        984
      ],
      "line": "\n      };\n\n      await roleService.displayWarningIfNoSuperAdmin();\n\n      expect(warn).toHaveBeenCalledWith(\"Your application doesn't have a super admin role.\");\n    })",
      "startLine": 455,
      "startCol": 25,
      "endLine": 455,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "uniqueid": 736
    },
    "737": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732035225615",
      "endTime": "928732038512125",
      "elapsedTime": "3286510",
      "asyncId": 973,
      "triggerAsyncId": 968,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 737
    },
    "738": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732038371552",
      "endTime": "928732038671985",
      "elapsedTime": "300433",
      "asyncId": 974,
      "triggerAsyncId": 956,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        976
      ],
      "uniqueid": 738
    },
    "739": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732038932794",
      "endTime": "928732040251897",
      "elapsedTime": "1319103",
      "asyncId": 975,
      "triggerAsyncId": 956,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        977,
        981,
        981
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 739
    },
    "740": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732039377438",
      "endTime": "928732039413275",
      "elapsedTime": "35837",
      "asyncId": 977,
      "triggerAsyncId": 956,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 740
    },
    "741": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731028609499",
      "endTime": "928731028625660",
      "elapsedTime": "16161",
      "asyncId": 978,
      "triggerAsyncId": 968,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 741
    },
    "742": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732039878477",
      "endTime": "928732040669059",
      "elapsedTime": "790582",
      "asyncId": 979,
      "triggerAsyncId": 956,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 742
    },
    "743": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928731028969153",
      "endTime": "928731029856236",
      "elapsedTime": "887083",
      "asyncId": 980,
      "triggerAsyncId": 968,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 743
    },
    "744": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732040190211",
      "endTime": "928732040714073",
      "elapsedTime": "523862",
      "asyncId": 981,
      "triggerAsyncId": 975,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        983
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 744
    },
    "745": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731029191831",
      "endTime": "928731029890551",
      "elapsedTime": "698720",
      "asyncId": 982,
      "triggerAsyncId": 976,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        988
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 745
    },
    "746": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732041597669",
      "endTime": "928732051152300",
      "elapsedTime": "9554631",
      "asyncId": 984,
      "triggerAsyncId": 577,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        985,
        992
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 746
    },
    "747": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732041888314",
      "endTime": "928732041922368",
      "elapsedTime": "34054",
      "asyncId": 985,
      "triggerAsyncId": 577,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "triggers": [],
      "uniqueid": 747
    },
    "748": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732039630933",
      "endTime": "928732051521192",
      "elapsedTime": "11890259",
      "asyncId": 986,
      "triggerAsyncId": 886,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        994
      ],
      "uniqueid": 748
    },
    "749": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732042546278",
      "endTime": "928732042596752",
      "elapsedTime": "50474",
      "asyncId": 987,
      "triggerAsyncId": 577,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        989,
        988,
        988
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 749
    },
    "750": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732042918405",
      "endTime": "928732047126994",
      "elapsedTime": "4208589",
      "asyncId": 988,
      "triggerAsyncId": 987,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        994,
        995,
        998,
        996,
        1000,
        1006,
        989,
        989
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 750
    },
    "751": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732043231602",
      "endTime": "928732051049378",
      "elapsedTime": "7817776",
      "asyncId": 989,
      "triggerAsyncId": 988,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        990,
        990,
        1007,
        1010,
        1008,
        1012,
        1016,
        990
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 751
    },
    "752": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732043494265",
      "endTime": "928732051187146",
      "elapsedTime": "7692881",
      "asyncId": 990,
      "triggerAsyncId": 989,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        997,
        1000,
        998,
        1002,
        1008,
        991,
        991
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 752
    },
    "753": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732041274033",
      "endTime": "928732051421906",
      "elapsedTime": "10147873",
      "asyncId": 991,
      "triggerAsyncId": 990,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1020,
        1012,
        1011,
        1010,
        1009,
        1018,
        1022,
        1029,
        992
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 753
    },
    "754": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732041587190",
      "endTime": "928732051581054",
      "elapsedTime": "9993864",
      "asyncId": 992,
      "triggerAsyncId": 991,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 754
    },
    "755": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732041769021",
      "endTime": "928732051638231",
      "elapsedTime": "9869210",
      "asyncId": 993,
      "triggerAsyncId": 886,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        995
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 755
    },
    "756": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732044725953",
      "endTime": "928732044777630",
      "elapsedTime": "51677",
      "asyncId": 995,
      "triggerAsyncId": 988,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        997
      ],
      "uniqueid": 756
    },
    "757": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732044983476",
      "endTime": "928732046563508",
      "elapsedTime": "1580032",
      "asyncId": 996,
      "triggerAsyncId": 988,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1002
      ],
      "uniqueid": 757
    },
    "758": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732045478174",
      "endTime": "928732045495436",
      "elapsedTime": "17262",
      "asyncId": 998,
      "triggerAsyncId": 988,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1004
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 758
    },
    "759": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732045882331",
      "endTime": "928732047023480",
      "elapsedTime": "1141149",
      "asyncId": 1000,
      "triggerAsyncId": 988,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        1001,
        1001
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 759
    },
    "760": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731033426669",
      "endTime": "928731037179835",
      "elapsedTime": "3753166",
      "asyncId": 1001,
      "triggerAsyncId": 1000,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1008,
        1011,
        1009,
        1013,
        1019,
        1002,
        1002
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 760
    },
    "761": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732046176112",
      "endTime": "928732047069186",
      "elapsedTime": "893074",
      "asyncId": 1002,
      "triggerAsyncId": 996,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1020,
        1023,
        1021,
        1025,
        1029,
        1003
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 761
    },
    "762": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731033867406",
      "endTime": "928731039271637",
      "elapsedTime": "5404231",
      "asyncId": 1003,
      "triggerAsyncId": 1002,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        1005
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 762
    },
    "763": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732047343110",
      "endTime": "928732048165481",
      "elapsedTime": "822371",
      "asyncId": 1007,
      "triggerAsyncId": 989,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1009
      ],
      "uniqueid": 763
    },
    "764": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732048394421",
      "endTime": "928732050439334",
      "elapsedTime": "2044913",
      "asyncId": 1008,
      "triggerAsyncId": 989,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1010,
        1014
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 764
    },
    "765": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732045453918",
      "endTime": "928732051139967",
      "elapsedTime": "5686049",
      "asyncId": 1009,
      "triggerAsyncId": 991,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1015,
        1019
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 765
    },
    "766": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732045770482",
      "endTime": "928732051061189",
      "elapsedTime": "5290707",
      "asyncId": 1010,
      "triggerAsyncId": 991,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [
        1017
      ],
      "uniqueid": 766
    },
    "767": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:471:25:471:25",
      "startTime": "928732046076475",
      "endTime": "928732050863068",
      "elapsedTime": "4786593",
      "asyncId": 1011,
      "triggerAsyncId": 991,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      };\n\n      await roleService.displayWarningIfNoSuperAdmin();\n\n      expect(warn).toHaveBeenCalledWith(\"Your application doesn't have a super admin user.\");\n    })",
      "startLine": 471,
      "startCol": 25,
      "endLine": 471,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [
        1016
      ],
      "uniqueid": 767
    },
    "768": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732049108599",
      "endTime": "928732050896251",
      "elapsedTime": "1787652",
      "asyncId": 1012,
      "triggerAsyncId": 989,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        1013,
        1015
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 768
    },
    "769": {
      "source": "packages/strapi-admin/services/role.js:202:43:202:43",
      "startTime": "928732046672352",
      "endTime": "928732046954451",
      "elapsedTime": "282099",
      "asyncId": 1013,
      "triggerAsyncId": 1012,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " getSuperAdminWithUsersCount",
      "userCode": false,
      "triggers": [
        1015,
        1014
      ],
      "line": "\n * @returns {Promise<role>}\n */\nconst getSuperAdminWithUsersCount = () => findOneWithUsersCount({ code: SUPER_ADMIN_CODE });\n\n/** Create superAdmin, Author and Editor role is no role already exist\n * @returns {Promise<>",
      "startLine": 202,
      "startCol": 43,
      "endLine": 202,
      "endCol": 43,
      "file": "packages/strapi-admin/services/role.js",
      "uniqueid": 769
    },
    "770": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732050347562",
      "endTime": "928732050939552",
      "elapsedTime": "591990",
      "asyncId": 1014,
      "triggerAsyncId": 1008,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1020,
        1026,
        1025,
        1025
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 770
    },
    "771": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:471:25:471:25",
      "startTime": "928732047191706",
      "endTime": "928732050793758",
      "elapsedTime": "3602052",
      "asyncId": 1015,
      "triggerAsyncId": 1012,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        1031
      ],
      "line": "\n      };\n\n      await roleService.displayWarningIfNoSuperAdmin();\n\n      expect(warn).toHaveBeenCalledWith(\"Your application doesn't have a super admin user.\");\n    })",
      "startLine": 471,
      "startCol": 25,
      "endLine": 471,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "uniqueid": 771
    },
    "772": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732047376622",
      "endTime": "928732051106555",
      "elapsedTime": "3729933",
      "asyncId": 1016,
      "triggerAsyncId": 1011,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 772
    },
    "773": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732051623484",
      "endTime": "928732059462649",
      "elapsedTime": "7839165",
      "asyncId": 1017,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1025
      ],
      "uniqueid": 773
    },
    "774": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732051975924",
      "endTime": "928732052208921",
      "elapsedTime": "232997",
      "asyncId": 1018,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        1024
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 774
    },
    "775": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732052756137",
      "endTime": "928732052802153",
      "elapsedTime": "46016",
      "asyncId": 1020,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "triggers": [
        1022,
        1021,
        1021
      ],
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 775
    },
    "776": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732053183889",
      "endTime": "928732057109097",
      "elapsedTime": "3925208",
      "asyncId": 1021,
      "triggerAsyncId": 1020,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1027,
        1028,
        1031,
        1029,
        1033,
        1039,
        1022,
        1022
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 776
    },
    "777": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732053501043",
      "endTime": "928732059351380",
      "elapsedTime": "5850337",
      "asyncId": 1022,
      "triggerAsyncId": 1021,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1040,
        1043,
        1041,
        1045,
        1049,
        1023
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 777
    },
    "778": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732053732938",
      "endTime": "928732059498706",
      "elapsedTime": "5765768",
      "asyncId": 1023,
      "triggerAsyncId": 1022,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        1025
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 778
    },
    "779": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732053912425",
      "endTime": "928732059536387",
      "elapsedTime": "5623962",
      "asyncId": 1024,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1030
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 779
    },
    "780": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732054314578",
      "endTime": "928732054369161",
      "elapsedTime": "54583",
      "asyncId": 1026,
      "triggerAsyncId": 578,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1030
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 780
    },
    "781": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732049517235",
      "endTime": "928732050181992",
      "elapsedTime": "664757",
      "asyncId": 1027,
      "triggerAsyncId": 1025,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 781
    },
    "782": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732054777146",
      "endTime": "928732054827329",
      "elapsedTime": "50183",
      "asyncId": 1028,
      "triggerAsyncId": 1021,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1030
      ],
      "uniqueid": 782
    },
    "783": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732055047402",
      "endTime": "928732056533197",
      "elapsedTime": "1485795",
      "asyncId": 1029,
      "triggerAsyncId": 1021,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1035
      ],
      "uniqueid": 783
    },
    "784": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732055419590",
      "endTime": "928732055456760",
      "elapsedTime": "37170",
      "asyncId": 1031,
      "triggerAsyncId": 1021,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1032
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 784
    },
    "785": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732050745388",
      "endTime": "928732050902923",
      "elapsedTime": "157535",
      "asyncId": 1032,
      "triggerAsyncId": 1031,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 785
    },
    "786": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732052582471",
      "endTime": "928732131135986",
      "elapsedTime": "78553515",
      "asyncId": 1033,
      "triggerAsyncId": 80,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1044,
        1034,
        1034,
        1043
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 786
    },
    "787": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732052786143",
      "endTime": "928732131187523",
      "elapsedTime": "78401380",
      "asyncId": 1034,
      "triggerAsyncId": 80,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1041,
        1044,
        1042,
        1046,
        1052,
        1035,
        1035,
        1040,
        1040
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 787
    },
    "788": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732056112248",
      "endTime": "928732057055136",
      "elapsedTime": "942888",
      "asyncId": 1035,
      "triggerAsyncId": 1029,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1053,
        1056,
        1054,
        1058,
        1062,
        1036
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 788
    },
    "789": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928731042456206",
      "endTime": "928731047195019",
      "elapsedTime": "4738813",
      "asyncId": 1036,
      "triggerAsyncId": 1035,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "triggers": [
        1037,
        1037
      ],
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "uniqueid": 789
    },
    "790": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732054051766",
      "endTime": "928732065678250",
      "elapsedTime": "11626484",
      "asyncId": 1038,
      "triggerAsyncId": 1037,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1059,
        1062,
        1060,
        1064,
        1068,
        1039,
        1039,
        1047,
        1049,
        1055,
        1046,
        1053,
        1069,
        1039,
        1039
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 790
    },
    "791": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732054358881",
      "endTime": "928732130926353",
      "elapsedTime": "76567472",
      "asyncId": 1039,
      "triggerAsyncId": 1038,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1069,
        1072,
        1070,
        1074,
        1078,
        1040,
        1040,
        1089,
        1091,
        1097,
        1088,
        1095,
        1108,
        1057
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 791
    },
    "792": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732054573453",
      "endTime": "928732131037021",
      "elapsedTime": "76463568",
      "asyncId": 1040,
      "triggerAsyncId": 1034,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1079,
        1082,
        1080,
        1084,
        1088,
        1041,
        1041,
        1042,
        1041
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 792
    },
    "793": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:45:12:45:12",
      "startTime": "928732054762548",
      "endTime": "928732131238428",
      "elapsedTime": "76475880",
      "asyncId": 1041,
      "triggerAsyncId": 1040,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1089,
        1092,
        1090,
        1094,
        1098,
        1042,
        1043,
        1047
      ],
      "line": "\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve()",
      "startLine": 45,
      "startCol": 12,
      "endLine": 45,
      "endCol": 12,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 793
    },
    "794": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732055035760",
      "endTime": "928732131274015",
      "elapsedTime": "76238255",
      "asyncId": 1042,
      "triggerAsyncId": 80,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1048
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 794
    },
    "795": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732055463001",
      "endTime": "928732055501764",
      "elapsedTime": "38763",
      "asyncId": 1044,
      "triggerAsyncId": 80,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 795
    },
    "796": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732058487791",
      "endTime": "928732059201068",
      "elapsedTime": "713277",
      "asyncId": 1045,
      "triggerAsyncId": 1022,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 796
    },
    "797": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732055939965",
      "endTime": "928732065472134",
      "elapsedTime": "9532169",
      "asyncId": 1046,
      "triggerAsyncId": 1038,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1054
      ],
      "uniqueid": 797
    },
    "798": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732058719345",
      "endTime": "928732059247966",
      "elapsedTime": "528621",
      "asyncId": 1047,
      "triggerAsyncId": 1041,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1049
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 798
    },
    "799": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928731044439564",
      "endTime": "928731045159744",
      "elapsedTime": "720180",
      "asyncId": 1048,
      "triggerAsyncId": 1042,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1054
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 799
    },
    "800": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732062051412",
      "endTime": "928732062391940",
      "elapsedTime": "340528",
      "asyncId": 1050,
      "triggerAsyncId": 26,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        1060,
        1063,
        1061,
        1065,
        1071,
        1051,
        1051
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 800
    },
    "801": {
      "source": "node_modules/jest-runner/build/runTest.js:442:12:442:12",
      "startTime": "928732063910597",
      "endTime": "928732073206433",
      "elapsedTime": "9295836",
      "asyncId": 1051,
      "triggerAsyncId": 53,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        1075,
        1081,
        1074,
        1073,
        1072,
        1079,
        1083,
        1087,
        1052,
        1066
      ],
      "line": "\n    } // Delay the resolution to allow log messages to be output.\n\n    return new Promise(resolve => {\n      setImmediate(() =>\n        resolve({\n          leakDetector",
      "startLine": 442,
      "startCol": 12,
      "endLine": 442,
      "endCol": 12,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 801
    },
    "802": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732057640273",
      "endTime": "928732065517379",
      "elapsedTime": "7877106",
      "asyncId": 1052,
      "triggerAsyncId": 1051,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 802
    },
    "803": {
      "source": "node_modules/jest-runner/build/runTest.js:453:23:453:23",
      "startTime": "928732064396818",
      "endTime": "928732070540816",
      "elapsedTime": "6143998",
      "asyncId": 1053,
      "triggerAsyncId": 53,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTestInternal",
      "userCode": false,
      "triggers": [
        1055,
        1061
      ],
      "line": "\n    var _runtime$teardown;\n\n    await environment.teardown(); // TODO: this function might be missing, remove ? in Jest 26\n\n    (_runtime$teardown = runtime.teardown) === null ||\n    _runtime$teardown === void ",
      "startLine": 453,
      "startCol": 23,
      "endLine": 453,
      "endCol": 23,
      "file": "node_modules/jest-runner/build/runTest.js",
      "uniqueid": 803
    },
    "804": {
      "source": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js:132:11:132:11",
      "startTime": "928732067586247",
      "endTime": "928732067605002",
      "elapsedTime": "18755",
      "asyncId": 1054,
      "triggerAsyncId": 53,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueMutationObserverMicrotask",
      "userCode": false,
      "triggers": [
        1060,
        1055
      ],
      "line": "\n  mutationObserverMicrotaskQueueFlag = true;\n\n  Promise.resolve().then(() => {\n    notifyMutationObservers();\n  });\n",
      "startLine": 132,
      "startCol": 11,
      "endLine": 132,
      "endCol": 11,
      "file": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js",
      "uniqueid": 804
    },
    "805": {
      "source": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js:132:21:132:21",
      "startTime": "928732068028166",
      "endTime": "928732070824367",
      "elapsedTime": "2796201",
      "asyncId": 1055,
      "triggerAsyncId": 1054,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueMutationObserverMicrotask",
      "userCode": false,
      "line": "\n  mutationObserverMicrotaskQueueFlag = true;\n\n  Promise.resolve().then(() => {\n    notifyMutationObservers();\n  });\n",
      "startLine": 132,
      "startCol": 21,
      "endLine": 132,
      "endCol": 21,
      "file": "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js",
      "triggers": [],
      "uniqueid": 805
    },
    "806": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:446:34:446:34",
      "startTime": "928732069225620",
      "endTime": "928732069263962",
      "elapsedTime": "38342",
      "asyncId": 1056,
      "triggerAsyncId": 53,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " DocumentImpl.close",
      "userCode": false,
      "line": "\n    this._queue.resume();\n\n    const dummyPromise = Promise.resolve();\n\n    const onDOMContentLoad = () => {\n      const doc = this",
      "startLine": 446,
      "startCol": 34,
      "endLine": 446,
      "endCol": 34,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "triggers": [
        1057,
        1059
      ],
      "uniqueid": 806
    },
    "807": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732058604681",
      "endTime": "928732131080172",
      "elapsedTime": "72475491",
      "asyncId": 1057,
      "triggerAsyncId": 1039,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1062,
        1058
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 807
    },
    "808": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732070741061",
      "endTime": "928732071756415",
      "elapsedTime": "1015354",
      "asyncId": 1061,
      "triggerAsyncId": 1053,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        1067
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 808
    },
    "809": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:456:14:456:14",
      "startTime": "928732071027969",
      "endTime": "928732071180856",
      "elapsedTime": "152887",
      "asyncId": 1062,
      "triggerAsyncId": 1057,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " onDOMContentLoad",
      "userCode": false,
      "line": "\n      }\n\n      return new Promise(resolve => {\n        if (!this._deferQueue.tail) {\n          dispatchEvent();\n          return resolve()",
      "startLine": 456,
      "startCol": 14,
      "endLine": 456,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "triggers": [
        1063
      ],
      "uniqueid": 809
    },
    "810": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:80:14:80:14",
      "startTime": "928732071374198",
      "endTime": "928732072298571",
      "elapsedTime": "924373",
      "asyncId": 1063,
      "triggerAsyncId": 1062,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.check",
      "userCode": false,
      "triggers": [
        1071,
        1064
      ],
      "line": "\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check()",
      "startLine": 80,
      "startCol": 14,
      "endLine": 80,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "uniqueid": 810
    },
    "811": {
      "source": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js:478:14:478:14",
      "startTime": "928732071964775",
      "endTime": "928732072079630",
      "elapsedTime": "114855",
      "asyncId": 1064,
      "triggerAsyncId": 1063,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " onLoad",
      "userCode": false,
      "line": "\n      }\n\n      return new Promise(resolve => {\n        if (this._asyncQueue.count() === 0) {\n          dispatchEvent();\n          return resolve()",
      "startLine": 478,
      "startCol": 14,
      "endLine": 478,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js",
      "triggers": [
        1065
      ],
      "uniqueid": 811
    },
    "812": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:80:14:80:14",
      "startTime": "928732072270699",
      "endTime": "928732072586520",
      "elapsedTime": "315821",
      "asyncId": 1065,
      "triggerAsyncId": 1064,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.check",
      "userCode": false,
      "line": "\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check()",
      "startLine": 80,
      "startCol": 14,
      "endLine": 80,
      "endCol": 14,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "triggers": [],
      "uniqueid": 812
    },
    "813": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732072564309",
      "endTime": "928732073298696",
      "elapsedTime": "734387",
      "asyncId": 1066,
      "triggerAsyncId": 1051,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1067,
        1067
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 813
    },
    "814": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732060334102",
      "endTime": "928732061301316",
      "elapsedTime": "967214",
      "asyncId": 1067,
      "triggerAsyncId": 1061,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1074,
        1077,
        1075,
        1079,
        1085,
        1068,
        1068
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 814
    },
    "815": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928731048842738",
      "endTime": "928731053931427",
      "elapsedTime": "5088689",
      "asyncId": 1068,
      "triggerAsyncId": 1067,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1086,
        1089,
        1087,
        1091,
        1095,
        1069
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 815
    },
    "816": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731049189859",
      "endTime": "928731054075788",
      "elapsedTime": "4885929",
      "asyncId": 1070,
      "triggerAsyncId": 788,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1076
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 816
    },
    "817": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732061612349",
      "endTime": "928732065131315",
      "elapsedTime": "3518966",
      "asyncId": 1072,
      "triggerAsyncId": 1051,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1080
      ],
      "uniqueid": 817
    },
    "818": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732061911630",
      "endTime": "928732065052577",
      "elapsedTime": "3140947",
      "asyncId": 1073,
      "triggerAsyncId": 1051,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [
        1078
      ],
      "uniqueid": 818
    },
    "819": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:487:25:487:25",
      "startTime": "928732062278768",
      "endTime": "928732064521512",
      "elapsedTime": "2242744",
      "asyncId": 1074,
      "triggerAsyncId": 1051,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        1076,
        1077
      ],
      "line": "\n      };\n\n      await roleService.resetSuperAdminPermissions();\n\n      expect(createMany).toHaveBeenCalledTimes(0);\n    })",
      "startLine": 487,
      "startCol": 25,
      "endLine": 487,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "uniqueid": 819
    },
    "820": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:479:51:479:51",
      "startTime": "928732062591304",
      "endTime": "928732062608516",
      "elapsedTime": "17212",
      "asyncId": 1075,
      "triggerAsyncId": 1051,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        1081,
        1076
      ],
      "line": "\n  describe('resetSuperAdminPermissions', () => {\n    test('No superAdmin role exist', async () => {\n      const getSuperAdmin = jest.fn(() => Promise.resolve(undefined));\n      const createMany = jest.fn();\n\n      global.strapi = ",
      "startLine": 479,
      "startCol": 51,
      "endLine": 479,
      "endCol": 51,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "uniqueid": 820
    },
    "821": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:487:25:487:25",
      "startTime": "928732062868053",
      "endTime": "928732064582116",
      "elapsedTime": "1714063",
      "asyncId": 1076,
      "triggerAsyncId": 1075,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      };\n\n      await roleService.resetSuperAdminPermissions();\n\n      expect(createMany).toHaveBeenCalledTimes(0);\n    })",
      "startLine": 487,
      "startCol": 25,
      "endLine": 487,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [],
      "uniqueid": 821
    },
    "822": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732063102252",
      "endTime": "928732065098644",
      "elapsedTime": "1996392",
      "asyncId": 1077,
      "triggerAsyncId": 1074,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 822
    },
    "823": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928732063309149",
      "endTime": "928732065163826",
      "elapsedTime": "1854677",
      "asyncId": 1078,
      "triggerAsyncId": 1073,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 823
    },
    "824": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732063472536",
      "endTime": "928732065195235",
      "elapsedTime": "1722699",
      "asyncId": 1079,
      "triggerAsyncId": 1051,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1081,
        1085
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 824
    },
    "825": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732063811842",
      "endTime": "928732063844252",
      "elapsedTime": "32410",
      "asyncId": 1081,
      "triggerAsyncId": 1051,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 825
    },
    "826": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928730923795206",
      "endTime": "928730923832837",
      "elapsedTime": "37631",
      "asyncId": 1082,
      "triggerAsyncId": 1040,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 826
    },
    "827": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732064198737",
      "endTime": "928732065273842",
      "elapsedTime": "1075105",
      "asyncId": 1083,
      "triggerAsyncId": 1051,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 827
    },
    "828": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928730924207900",
      "endTime": "928730924879038",
      "elapsedTime": "671138",
      "asyncId": 1084,
      "triggerAsyncId": 1040,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 828
    },
    "829": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732064440670",
      "endTime": "928732065318065",
      "elapsedTime": "877395",
      "asyncId": 1085,
      "triggerAsyncId": 1079,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 829
    },
    "830": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731051824207",
      "endTime": "928731052495205",
      "elapsedTime": "670998",
      "asyncId": 1086,
      "triggerAsyncId": 1068,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1088
      ],
      "uniqueid": 830
    },
    "831": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732065985877",
      "endTime": "928732130758960",
      "elapsedTime": "64773083",
      "asyncId": 1088,
      "triggerAsyncId": 1039,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1096
      ],
      "uniqueid": 831
    },
    "832": {
      "source": "node_modules/jest-jasmine2/build/PCancelable.js:40:5:40:5",
      "startTime": "928732066295377",
      "endTime": "928732066319392",
      "elapsedTime": "24015",
      "asyncId": 1089,
      "triggerAsyncId": 1039,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " new PCancelable",
      "userCode": false,
      "triggers": [
        1091
      ],
      "line": "\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);",
      "startLine": 40,
      "startCol": 5,
      "endLine": 40,
      "endCol": 5,
      "file": "node_modules/jest-jasmine2/build/PCancelable.js",
      "uniqueid": 832
    },
    "833": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928730925392030",
      "endTime": "928730926370323",
      "elapsedTime": "978293",
      "asyncId": 1090,
      "triggerAsyncId": 1041,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1096
      ],
      "uniqueid": 833
    },
    "834": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732066903477",
      "endTime": "928732066925779",
      "elapsedTime": "22302",
      "asyncId": 1091,
      "triggerAsyncId": 1039,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1092,
        1092
      ],
      "uniqueid": 834
    },
    "835": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732067230771",
      "endTime": "928732070710824",
      "elapsedTime": "3480053",
      "asyncId": 1092,
      "triggerAsyncId": 1091,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1099,
        1102,
        1100,
        1104,
        1110,
        1093,
        1093
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 835
    },
    "836": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732067519442",
      "endTime": "928732130642121",
      "elapsedTime": "63122679",
      "asyncId": 1093,
      "triggerAsyncId": 1092,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1114,
        1120,
        1113,
        1112,
        1111,
        1118,
        1122,
        1139,
        1094
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 836
    },
    "837": {
      "source": "node_modules/jest-jasmine2/build/jasmine/Spec.js:182:21:182:21",
      "startTime": "928732067737230",
      "endTime": "928732130798884",
      "elapsedTime": "63061654",
      "asyncId": 1094,
      "triggerAsyncId": 1093,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Spec.execute",
      "userCode": false,
      "line": "\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain)",
      "startLine": 182,
      "startCol": 21,
      "endLine": 182,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmine/Spec.js",
      "triggers": [],
      "uniqueid": 837
    },
    "838": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732067893503",
      "endTime": "928732130834912",
      "elapsedTime": "62941409",
      "asyncId": 1095,
      "triggerAsyncId": 1039,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 838
    },
    "839": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732068238179",
      "endTime": "928732068258187",
      "elapsedTime": "20008",
      "asyncId": 1097,
      "triggerAsyncId": 1039,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 839
    },
    "840": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732068639271",
      "endTime": "928732068659309",
      "elapsedTime": "20038",
      "asyncId": 1099,
      "triggerAsyncId": 1092,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1109,
        1100,
        1100,
        1101
      ],
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 840
    },
    "841": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732068823486",
      "endTime": "928732070206469",
      "elapsedTime": "1382983",
      "asyncId": 1100,
      "triggerAsyncId": 1092,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1106,
        1106,
        1107,
        1110,
        1108,
        1112,
        1118,
        1101,
        1101,
        1106
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 841
    },
    "842": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732069125813",
      "endTime": "928732069141172",
      "elapsedTime": "15359",
      "asyncId": 1102,
      "triggerAsyncId": 1092,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 842
    },
    "843": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731056122184",
      "endTime": "928731062114187",
      "elapsedTime": "5992003",
      "asyncId": 1103,
      "triggerAsyncId": 789,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1104,
        1104
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 843
    },
    "844": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732069534730",
      "endTime": "928732070601099",
      "elapsedTime": "1066369",
      "asyncId": 1104,
      "triggerAsyncId": 1092,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "triggers": [
        1113,
        1115,
        1125,
        1112,
        1123,
        1139,
        1105,
        1105
      ],
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 844
    },
    "845": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928731056451381",
      "endTime": "928731056462933",
      "elapsedTime": "11552",
      "asyncId": 1105,
      "triggerAsyncId": 789,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1193,
        1195,
        1205,
        1192,
        1203,
        1216,
        1127
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 845
    },
    "846": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732069787453",
      "endTime": "928732070643969",
      "elapsedTime": "856516",
      "asyncId": 1106,
      "triggerAsyncId": 1100,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1107
      ],
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "uniqueid": 846
    },
    "847": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928731056857853",
      "endTime": "928731056877159",
      "elapsedTime": "19306",
      "asyncId": 1107,
      "triggerAsyncId": 1100,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1109
      ],
      "uniqueid": 847
    },
    "848": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:28:19:28:19",
      "startTime": "928732070948049",
      "endTime": "928732130392493",
      "elapsedTime": "59444444",
      "asyncId": 1111,
      "triggerAsyncId": 1093,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];",
      "startLine": 28,
      "startCol": 19,
      "endLine": 28,
      "endCol": 19,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1119
      ],
      "uniqueid": 848
    },
    "849": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732071294679",
      "endTime": "928732130313875",
      "elapsedTime": "59019196",
      "asyncId": 1112,
      "triggerAsyncId": 1093,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        1124,
        1117
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 849
    },
    "850": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:567:25:567:25",
      "startTime": "928732071667798",
      "endTime": "928732129674827",
      "elapsedTime": "58007029",
      "asyncId": 1113,
      "triggerAsyncId": 1093,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      };\n\n      await roleService.resetSuperAdminPermissions();\n\n      expect(deleteByIds).toHaveBeenCalledWith([2]);\n      expect(createMany).toHaveBeenCalledWith",
      "startLine": 567,
      "startCol": 25,
      "endLine": 567,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [
        1116
      ],
      "uniqueid": 850
    },
    "851": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:546:51:546:51",
      "startTime": "928732071988269",
      "endTime": "928732072016282",
      "elapsedTime": "28013",
      "asyncId": 1114,
      "triggerAsyncId": 1093,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      ]); // cloned, otherwise it is modified inside resetSuperAdminPermissions()\n      const deleteByIds = jest.fn();\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: roleId }));\n      const createMany = jest.fn(() => []);\n      const removeUnkownConditionIds = jest.fn(conds => conds);",
      "startLine": 546,
      "startCol": 51,
      "endLine": 546,
      "endCol": 51,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [
        1115
      ],
      "uniqueid": 851
    },
    "852": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:567:25:567:25",
      "startTime": "928732072259658",
      "endTime": "928732078803254",
      "elapsedTime": "6543596",
      "asyncId": 1115,
      "triggerAsyncId": 1114,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        1116,
        1116,
        1126,
        1129,
        1125
      ],
      "line": "\n      };\n\n      await roleService.resetSuperAdminPermissions();\n\n      expect(deleteByIds).toHaveBeenCalledWith([2]);\n      expect(createMany).toHaveBeenCalledWith",
      "startLine": 567,
      "startCol": 25,
      "endLine": 567,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "uniqueid": 852
    },
    "853": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732072475362",
      "endTime": "928732130359331",
      "elapsedTime": "57883969",
      "asyncId": 1116,
      "triggerAsyncId": 1113,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        1130,
        1133,
        1131,
        1135,
        1141,
        1117,
        1117
      ],
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 853
    },
    "854": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:109:21:109:21",
      "startTime": "928732072679605",
      "endTime": "928732130427408",
      "elapsedTime": "57747803",
      "asyncId": 1117,
      "triggerAsyncId": 1112,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "triggers": [
        1142,
        1145,
        1143,
        1147,
        1151,
        1118,
        1118
      ],
      "line": "\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) ",
      "startLine": 109,
      "startCol": 21,
      "endLine": 109,
      "endCol": 21,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "uniqueid": 854
    },
    "855": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732072855885",
      "endTime": "928732130469156",
      "elapsedTime": "57613271",
      "asyncId": 1118,
      "triggerAsyncId": 1093,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1152,
        1155,
        1153,
        1157,
        1161,
        1119,
        1119,
        1124
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 855
    },
    "856": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928732073195743",
      "endTime": "928732073227462",
      "elapsedTime": "31719",
      "asyncId": 1120,
      "triggerAsyncId": 1093,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "triggers": [
        1172,
        1175,
        1173,
        1177,
        1181,
        1121,
        1121,
        1126
      ],
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 856
    },
    "857": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:20:10:20:10",
      "startTime": "928732073592065",
      "endTime": "928732130556670",
      "elapsedTime": "56964605",
      "asyncId": 1122,
      "triggerAsyncId": 1093,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " pTimeout",
      "userCode": false,
      "line": "\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => ",
      "startLine": 20,
      "startCol": 10,
      "endLine": 20,
      "endCol": 10,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 857
    },
    "858": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:51:23:51:23",
      "startTime": "928730933681769",
      "endTime": "928730947745122",
      "elapsedTime": "14063353",
      "asyncId": 1123,
      "triggerAsyncId": 1104,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " mapper",
      "userCode": false,
      "line": "\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise",
      "startLine": 51,
      "startCol": 23,
      "endLine": 51,
      "endCol": 23,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [],
      "uniqueid": 858
    },
    "859": {
      "source": "node_modules/jest-jasmine2/build/pTimeout.js:22:13:22:13",
      "startTime": "928732073805255",
      "endTime": "928732130588710",
      "elapsedTime": "56783455",
      "asyncId": 1124,
      "triggerAsyncId": 1118,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val)",
      "startLine": 22,
      "startCol": 13,
      "endLine": 22,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/pTimeout.js",
      "triggers": [],
      "uniqueid": 859
    },
    "860": {
      "source": "packages/strapi-admin/services/role.js:374:9:374:9",
      "startTime": "928732074252374",
      "endTime": "928732129612661",
      "elapsedTime": "55360287",
      "asyncId": 1125,
      "triggerAsyncId": 1115,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.resetSuperAdminPermissions",
      "userCode": false,
      "triggers": [
        1288,
        1290,
        1137
      ],
      "line": "\n  });\n\n  await assignPermissions(superAdminRole.id, permissions);\n};\n\nmodule.exports = ",
      "startLine": 374,
      "startCol": 9,
      "endLine": 374,
      "endCol": 9,
      "file": "packages/strapi-admin/services/role.js",
      "uniqueid": 860
    },
    "861": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732075212724",
      "endTime": "928732075233833",
      "elapsedTime": "21109",
      "asyncId": 1126,
      "triggerAsyncId": 1115,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1127
      ],
      "uniqueid": 861
    },
    "862": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732075504060",
      "endTime": "928732079248740",
      "elapsedTime": "3744680",
      "asyncId": 1127,
      "triggerAsyncId": 1126,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1128
      ],
      "uniqueid": 862
    },
    "863": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732076064841",
      "endTime": "928732079339059",
      "elapsedTime": "3274218",
      "asyncId": 1128,
      "triggerAsyncId": 1127,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1130
      ],
      "uniqueid": 863
    },
    "864": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732076354394",
      "endTime": "928732079381809",
      "elapsedTime": "3027415",
      "asyncId": 1129,
      "triggerAsyncId": 1115,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1131
      ],
      "uniqueid": 864
    },
    "865": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732077175734",
      "endTime": "928732079518706",
      "elapsedTime": "2342972",
      "asyncId": 1131,
      "triggerAsyncId": 1129,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        1137,
        1132,
        1132
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 865
    },
    "866": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732077437003",
      "endTime": "928732083381507",
      "elapsedTime": "5944504",
      "asyncId": 1132,
      "triggerAsyncId": 1131,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1140,
        1140,
        1143,
        1133
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 866
    },
    "867": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928732077938904",
      "endTime": "928732125976495",
      "elapsedTime": "48037591",
      "asyncId": 1134,
      "triggerAsyncId": 1133,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1147,
        1156,
        1165,
        1174,
        1150,
        1159,
        1168,
        1177,
        1187,
        1135
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 867
    },
    "868": {
      "source": "packages/strapi-admin/services/role.js:374:9:374:9",
      "startTime": "928732078591047",
      "endTime": "928732126529511",
      "elapsedTime": "47938464",
      "asyncId": 1136,
      "triggerAsyncId": 1135,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.resetSuperAdminPermissions",
      "userCode": false,
      "triggers": [
        1141,
        1137,
        1286
      ],
      "line": "\n  });\n\n  await assignPermissions(superAdminRole.id, permissions);\n};\n\nmodule.exports = ",
      "startLine": 374,
      "startCol": 9,
      "endLine": 374,
      "endCol": 9,
      "file": "packages/strapi-admin/services/role.js",
      "uniqueid": 868
    },
    "869": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732078777917",
      "endTime": "928732129702569",
      "elapsedTime": "50924652",
      "asyncId": 1137,
      "triggerAsyncId": 1125,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 869
    },
    "870": {
      "source": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js:116:8:116:8",
      "startTime": "928731071959182",
      "endTime": "928731073759216",
      "elapsedTime": "1800034",
      "asyncId": 1138,
      "triggerAsyncId": 1135,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ResourceQueue.push",
      "userCode": false,
      "line": "\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check()",
      "startLine": 116,
      "startCol": 8,
      "endLine": 116,
      "endCol": 8,
      "file": "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js",
      "triggers": [
        1139
      ],
      "uniqueid": 870
    },
    "871": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732079998876",
      "endTime": "928732080052106",
      "elapsedTime": "53230",
      "asyncId": 1140,
      "triggerAsyncId": 1132,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1141
      ],
      "uniqueid": 871
    },
    "872": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732081753405",
      "endTime": "928732082974253",
      "elapsedTime": "1220848",
      "asyncId": 1141,
      "triggerAsyncId": 1140,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " validate",
      "userCode": false,
      "triggers": [
        1142,
        1142
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 872
    },
    "873": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732082105985",
      "endTime": "928732083183175",
      "elapsedTime": "1077190",
      "asyncId": 1142,
      "triggerAsyncId": 1141,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1144,
        1143,
        1144
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 873
    },
    "874": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732082353319",
      "endTime": "928732083230644",
      "elapsedTime": "877325",
      "asyncId": 1143,
      "triggerAsyncId": 1132,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        1149,
        1144,
        1145
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 874
    },
    "875": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732082894594",
      "endTime": "928732083313449",
      "elapsedTime": "418855",
      "asyncId": 1145,
      "triggerAsyncId": 1143,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1146
      ],
      "uniqueid": 875
    },
    "876": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732083163468",
      "endTime": "928732083425579",
      "elapsedTime": "262111",
      "asyncId": 1146,
      "triggerAsyncId": 1145,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 876
    },
    "877": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732084370581",
      "endTime": "928732084391690",
      "elapsedTime": "21109",
      "asyncId": 1147,
      "triggerAsyncId": 1134,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1148
      ],
      "uniqueid": 877
    },
    "878": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732084699738",
      "endTime": "928732097827276",
      "elapsedTime": "13127538",
      "asyncId": 1148,
      "triggerAsyncId": 1147,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1149
      ],
      "uniqueid": 878
    },
    "879": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732085057629",
      "endTime": "928732098161343",
      "elapsedTime": "13103714",
      "asyncId": 1149,
      "triggerAsyncId": 1148,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1151
      ],
      "uniqueid": 879
    },
    "880": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732085319209",
      "endTime": "928732098338264",
      "elapsedTime": "13019055",
      "asyncId": 1150,
      "triggerAsyncId": 1134,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1152
      ],
      "uniqueid": 880
    },
    "881": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732085891873",
      "endTime": "928732098715181",
      "elapsedTime": "12823308",
      "asyncId": 1152,
      "triggerAsyncId": 1150,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        1154,
        1153,
        1153
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 881
    },
    "882": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732087535003",
      "endTime": "928732101952970",
      "elapsedTime": "14417967",
      "asyncId": 1153,
      "triggerAsyncId": 1152,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        1159,
        1194,
        1154
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 882
    },
    "883": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928732088054737",
      "endTime": "928732125243741",
      "elapsedTime": "37189004",
      "asyncId": 1155,
      "triggerAsyncId": 1154,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        1206,
        1209,
        1216,
        1183
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 883
    },
    "884": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732088475035",
      "endTime": "928732088491957",
      "elapsedTime": "16922",
      "asyncId": 1156,
      "triggerAsyncId": 1134,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1157
      ],
      "uniqueid": 884
    },
    "885": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732088760039",
      "endTime": "928732097883612",
      "elapsedTime": "9123573",
      "asyncId": 1157,
      "triggerAsyncId": 1156,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1158
      ],
      "uniqueid": 885
    },
    "886": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732089068608",
      "endTime": "928732098198132",
      "elapsedTime": "9129524",
      "asyncId": 1158,
      "triggerAsyncId": 1157,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1160
      ],
      "uniqueid": 886
    },
    "887": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732089348342",
      "endTime": "928732098461756",
      "elapsedTime": "9113414",
      "asyncId": 1159,
      "triggerAsyncId": 1134,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1161
      ],
      "uniqueid": 887
    },
    "888": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732089912399",
      "endTime": "928732098762600",
      "elapsedTime": "8850201",
      "asyncId": 1161,
      "triggerAsyncId": 1159,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1162,
        1162
      ],
      "uniqueid": 888
    },
    "889": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732090165333",
      "endTime": "928732102048790",
      "elapsedTime": "11883457",
      "asyncId": 1162,
      "triggerAsyncId": 1161,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        1164,
        1196,
        1163
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 889
    },
    "890": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928732090599077",
      "endTime": "928732125359678",
      "elapsedTime": "34760601",
      "asyncId": 1164,
      "triggerAsyncId": 1163,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        1219,
        1222,
        1229,
        1184
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 890
    },
    "891": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732090914778",
      "endTime": "928732090932592",
      "elapsedTime": "17814",
      "asyncId": 1165,
      "triggerAsyncId": 1134,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1166
      ],
      "uniqueid": 891
    },
    "892": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732091316782",
      "endTime": "928732097931612",
      "elapsedTime": "6614830",
      "asyncId": 1166,
      "triggerAsyncId": 1165,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1167
      ],
      "uniqueid": 892
    },
    "893": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732091661989",
      "endTime": "928732098240812",
      "elapsedTime": "6578823",
      "asyncId": 1167,
      "triggerAsyncId": 1166,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1169
      ],
      "uniqueid": 893
    },
    "894": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732091953385",
      "endTime": "928732098533591",
      "elapsedTime": "6580206",
      "asyncId": 1168,
      "triggerAsyncId": 1134,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1170
      ],
      "uniqueid": 894
    },
    "895": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732092473731",
      "endTime": "928732098799559",
      "elapsedTime": "6325828",
      "asyncId": 1170,
      "triggerAsyncId": 1168,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1171,
        1171
      ],
      "uniqueid": 895
    },
    "896": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732092687722",
      "endTime": "928732102133359",
      "elapsedTime": "9445637",
      "asyncId": 1171,
      "triggerAsyncId": 1170,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        1198,
        1172
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 896
    },
    "897": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928732093128588",
      "endTime": "928732125440189",
      "elapsedTime": "32311601",
      "asyncId": 1173,
      "triggerAsyncId": 1172,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        1179,
        1232,
        1235,
        1242,
        1185
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 897
    },
    "898": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732093441245",
      "endTime": "928732093453477",
      "elapsedTime": "12232",
      "asyncId": 1174,
      "triggerAsyncId": 1134,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1175
      ],
      "uniqueid": 898
    },
    "899": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732093724145",
      "endTime": "928732097978219",
      "elapsedTime": "4254074",
      "asyncId": 1175,
      "triggerAsyncId": 1174,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema.validate [as _typeError]",
      "userCode": false,
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1176
      ],
      "uniqueid": 899
    },
    "900": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732094026482",
      "endTime": "928732098278763",
      "elapsedTime": "4252281",
      "asyncId": 1176,
      "triggerAsyncId": 1175,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1178
      ],
      "uniqueid": 900
    },
    "901": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732094299864",
      "endTime": "928732098628909",
      "elapsedTime": "4329045",
      "asyncId": 1177,
      "triggerAsyncId": 1134,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1179
      ],
      "uniqueid": 901
    },
    "902": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732094829356",
      "endTime": "928732098860463",
      "elapsedTime": "4031107",
      "asyncId": 1179,
      "triggerAsyncId": 1177,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1180,
        1180
      ],
      "uniqueid": 902
    },
    "903": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732095053847",
      "endTime": "928732102260517",
      "elapsedTime": "7206670",
      "asyncId": 1180,
      "triggerAsyncId": 1179,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        1200,
        1181
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 903
    },
    "904": {
      "source": "packages/strapi-utils/node_modules/yup/lib/object.js:208:134:208:134",
      "startTime": "928732095498391",
      "endTime": "928732125538123",
      "elapsedTime": "30039732",
      "asyncId": 1182,
      "triggerAsyncId": 1181,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ObjectSchema._validate",
      "userCode": false,
      "triggers": [
        1184,
        1245,
        1248,
        1255,
        1186
      ],
      "line": "\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0]",
      "startLine": 208,
      "startCol": 134,
      "endLine": 208,
      "endCol": 134,
      "file": "packages/strapi-utils/node_modules/yup/lib/object.js",
      "uniqueid": 904
    },
    "905": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732095751164",
      "endTime": "928732125603485",
      "elapsedTime": "29852321",
      "asyncId": 1183,
      "triggerAsyncId": 1155,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1189,
        1188
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 905
    },
    "906": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732095998308",
      "endTime": "928732125638851",
      "elapsedTime": "29640543",
      "asyncId": 1184,
      "triggerAsyncId": 1164,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1189
      ],
      "uniqueid": 906
    },
    "907": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732096233359",
      "endTime": "928732125679287",
      "elapsedTime": "29445928",
      "asyncId": 1185,
      "triggerAsyncId": 1173,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1190
      ],
      "uniqueid": 907
    },
    "908": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732096455074",
      "endTime": "928732125710626",
      "elapsedTime": "29255552",
      "asyncId": 1186,
      "triggerAsyncId": 1182,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1191
      ],
      "uniqueid": 908
    },
    "909": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732096661671",
      "endTime": "928732125866548",
      "elapsedTime": "29204877",
      "asyncId": 1187,
      "triggerAsyncId": 1134,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1192
      ],
      "uniqueid": 909
    },
    "910": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732097752176",
      "endTime": "928732125922663",
      "elapsedTime": "28170487",
      "asyncId": 1192,
      "triggerAsyncId": 1187,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        1204,
        1193
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 910
    },
    "911": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732098142738",
      "endTime": "928732126012803",
      "elapsedTime": "27870065",
      "asyncId": 1193,
      "triggerAsyncId": 1192,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 911
    },
    "912": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732099126662",
      "endTime": "928732099156969",
      "elapsedTime": "30307",
      "asyncId": 1194,
      "triggerAsyncId": 1153,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1195
      ],
      "uniqueid": 912
    },
    "913": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732099408250",
      "endTime": "928732101214416",
      "elapsedTime": "1806166",
      "asyncId": 1195,
      "triggerAsyncId": 1194,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        1196,
        1196,
        1202
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 913
    },
    "914": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732099699606",
      "endTime": "928732099733189",
      "elapsedTime": "33583",
      "asyncId": 1196,
      "triggerAsyncId": 1162,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        1207,
        1210,
        1208,
        1212,
        1218,
        1197,
        1197,
        1197
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 914
    },
    "915": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732099958752",
      "endTime": "928732101402158",
      "elapsedTime": "1443406",
      "asyncId": 1197,
      "triggerAsyncId": 1196,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        1219,
        1222,
        1220,
        1224,
        1228,
        1198,
        1198,
        1203
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 915
    },
    "916": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732100277770",
      "endTime": "928732100307396",
      "elapsedTime": "29626",
      "asyncId": 1198,
      "triggerAsyncId": 1171,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        1229,
        1232,
        1230,
        1234,
        1238,
        1199,
        1199,
        1199
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 916
    },
    "917": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732100557314",
      "endTime": "928732101572457",
      "elapsedTime": "1015143",
      "asyncId": 1199,
      "triggerAsyncId": 1198,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        1239,
        1242,
        1240,
        1244,
        1248,
        1200,
        1200,
        1204
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 917
    },
    "918": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732100841778",
      "endTime": "928732100863618",
      "elapsedTime": "21840",
      "asyncId": 1200,
      "triggerAsyncId": 1180,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        1249,
        1252,
        1250,
        1254,
        1258,
        1201,
        1201,
        1201
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 918
    },
    "919": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732101131130",
      "endTime": "928732101753416",
      "elapsedTime": "622286",
      "asyncId": 1201,
      "triggerAsyncId": 1200,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        1259,
        1262,
        1260,
        1264,
        1268,
        1202,
        1205
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 919
    },
    "920": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732101368986",
      "endTime": "928732101993597",
      "elapsedTime": "624611",
      "asyncId": 1202,
      "triggerAsyncId": 1195,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 920
    },
    "921": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732101538994",
      "endTime": "928732102077704",
      "elapsedTime": "538710",
      "asyncId": 1203,
      "triggerAsyncId": 1197,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 921
    },
    "922": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732101724843",
      "endTime": "928732102182150",
      "elapsedTime": "457307",
      "asyncId": 1204,
      "triggerAsyncId": 1199,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 922
    },
    "923": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732101899761",
      "endTime": "928732102314218",
      "elapsedTime": "414457",
      "asyncId": 1205,
      "triggerAsyncId": 1201,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 923
    },
    "924": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732102935272",
      "endTime": "928732102952103",
      "elapsedTime": "16831",
      "asyncId": 1206,
      "triggerAsyncId": 1155,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1207
      ],
      "uniqueid": 924
    },
    "925": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732103234793",
      "endTime": "928732116633741",
      "elapsedTime": "13398948",
      "asyncId": 1207,
      "triggerAsyncId": 1206,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        1209,
        1208
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 925
    },
    "926": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732103564762",
      "endTime": "928732117294449",
      "elapsedTime": "13729687",
      "asyncId": 1208,
      "triggerAsyncId": 1207,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1214,
        1210
      ],
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 926
    },
    "927": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732103840789",
      "endTime": "928732117447536",
      "elapsedTime": "13606747",
      "asyncId": 1209,
      "triggerAsyncId": 1155,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1211
      ],
      "uniqueid": 927
    },
    "928": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732104409235",
      "endTime": "928732117716200",
      "elapsedTime": "13306965",
      "asyncId": 1211,
      "triggerAsyncId": 1209,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1212,
        1212
      ],
      "uniqueid": 928
    },
    "929": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732104648383",
      "endTime": "928732120857007",
      "elapsedTime": "16208624",
      "asyncId": 1212,
      "triggerAsyncId": 1211,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1262,
        1213
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 929
    },
    "930": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928732105147378",
      "endTime": "928732124281066",
      "elapsedTime": "19133688",
      "asyncId": 1214,
      "triggerAsyncId": 1213,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1274,
        1215
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 930
    },
    "931": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732105475744",
      "endTime": "928732124629259",
      "elapsedTime": "19153515",
      "asyncId": 1215,
      "triggerAsyncId": 1214,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1217
      ],
      "uniqueid": 931
    },
    "932": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732105697289",
      "endTime": "928732124785512",
      "elapsedTime": "19088223",
      "asyncId": 1216,
      "triggerAsyncId": 1155,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1218
      ],
      "uniqueid": 932
    },
    "933": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732106163042",
      "endTime": "928732125106424",
      "elapsedTime": "18943382",
      "asyncId": 1218,
      "triggerAsyncId": 1216,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1258
      ],
      "uniqueid": 933
    },
    "934": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732106563824",
      "endTime": "928732106587819",
      "elapsedTime": "23995",
      "asyncId": 1219,
      "triggerAsyncId": 1164,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "triggers": [
        1221,
        1220
      ],
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 934
    },
    "935": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732106866672",
      "endTime": "928732116807026",
      "elapsedTime": "9940354",
      "asyncId": 1220,
      "triggerAsyncId": 1219,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "triggers": [
        1226,
        1221
      ],
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "uniqueid": 935
    },
    "936": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732107173757",
      "endTime": "928732117338562",
      "elapsedTime": "10164805",
      "asyncId": 1221,
      "triggerAsyncId": 1220,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1223
      ],
      "uniqueid": 936
    },
    "937": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732107444535",
      "endTime": "928732117505315",
      "elapsedTime": "10060780",
      "asyncId": 1222,
      "triggerAsyncId": 1164,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1224
      ],
      "uniqueid": 937
    },
    "938": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732108038318",
      "endTime": "928732117756185",
      "elapsedTime": "9717867",
      "asyncId": 1224,
      "triggerAsyncId": 1222,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1225,
        1225
      ],
      "uniqueid": 938
    },
    "939": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732108284229",
      "endTime": "928732120997641",
      "elapsedTime": "12713412",
      "asyncId": 1225,
      "triggerAsyncId": 1224,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1264,
        1226
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 939
    },
    "940": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928732108773226",
      "endTime": "928732124403506",
      "elapsedTime": "15630280",
      "asyncId": 1227,
      "triggerAsyncId": 1226,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1276,
        1228
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 940
    },
    "941": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732109046047",
      "endTime": "928732124662321",
      "elapsedTime": "15616274",
      "asyncId": 1228,
      "triggerAsyncId": 1227,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1230
      ],
      "uniqueid": 941
    },
    "942": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732109265589",
      "endTime": "928732124865372",
      "elapsedTime": "15599783",
      "asyncId": 1229,
      "triggerAsyncId": 1164,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        1231,
        1231
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 942
    },
    "943": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732109708388",
      "endTime": "928732125139105",
      "elapsedTime": "15430717",
      "asyncId": 1231,
      "triggerAsyncId": 1229,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1259
      ],
      "uniqueid": 943
    },
    "944": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732110080266",
      "endTime": "928732110096236",
      "elapsedTime": "15970",
      "asyncId": 1232,
      "triggerAsyncId": 1173,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1233
      ],
      "uniqueid": 944
    },
    "945": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732110360250",
      "endTime": "928732116958179",
      "elapsedTime": "6597929",
      "asyncId": 1233,
      "triggerAsyncId": 1232,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1234
      ],
      "uniqueid": 945
    },
    "946": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732110646117",
      "endTime": "928732117380701",
      "elapsedTime": "6734584",
      "asyncId": 1234,
      "triggerAsyncId": 1233,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1236
      ],
      "uniqueid": 946
    },
    "947": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732110918497",
      "endTime": "928732117566539",
      "elapsedTime": "6648042",
      "asyncId": 1235,
      "triggerAsyncId": 1173,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1237
      ],
      "uniqueid": 947
    },
    "948": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732111457237",
      "endTime": "928732117785550",
      "elapsedTime": "6328313",
      "asyncId": 1237,
      "triggerAsyncId": 1235,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1238,
        1238
      ],
      "uniqueid": 948
    },
    "949": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732111713888",
      "endTime": "928732121087650",
      "elapsedTime": "9373762",
      "asyncId": 1238,
      "triggerAsyncId": 1237,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1266,
        1239
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 949
    },
    "950": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928732112214136",
      "endTime": "928732124495178",
      "elapsedTime": "12281042",
      "asyncId": 1240,
      "triggerAsyncId": 1239,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1246,
        1278,
        1241
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 950
    },
    "951": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732112454316",
      "endTime": "928732124707696",
      "elapsedTime": "12253380",
      "asyncId": 1241,
      "triggerAsyncId": 1240,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1243
      ],
      "uniqueid": 951
    },
    "952": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732112668468",
      "endTime": "928732124937026",
      "elapsedTime": "12268558",
      "asyncId": 1242,
      "triggerAsyncId": 1173,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1244
      ],
      "uniqueid": 952
    },
    "953": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732113098634",
      "endTime": "928732125168660",
      "elapsedTime": "12070026",
      "asyncId": 1244,
      "triggerAsyncId": 1242,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1260
      ],
      "uniqueid": 953
    },
    "954": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:29:29:29:29",
      "startTime": "928732113493394",
      "endTime": "928732113518451",
      "elapsedTime": "25057",
      "asyncId": 1245,
      "triggerAsyncId": 1182,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " runTest",
      "userCode": false,
      "line": "\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\")",
      "startLine": 29,
      "startCol": 29,
      "endLine": 29,
      "endCol": 29,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1246
      ],
      "uniqueid": 954
    },
    "955": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js:112:44:112:44",
      "startTime": "928732113816990",
      "endTime": "928732117149277",
      "elapsedTime": "3332287",
      "asyncId": 1246,
      "triggerAsyncId": 1245,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema.validate [as _typeError]",
      "userCode": false,
      "line": "\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  ",
      "startLine": 112,
      "startCol": 44,
      "endLine": 112,
      "endCol": 44,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js",
      "triggers": [
        1247
      ],
      "uniqueid": 955
    },
    "956": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732114122373",
      "endTime": "928732117417780",
      "elapsedTime": "3295407",
      "asyncId": 1247,
      "triggerAsyncId": 1246,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1249
      ],
      "uniqueid": 956
    },
    "957": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732114384995",
      "endTime": "928732117632994",
      "elapsedTime": "3247999",
      "asyncId": 1248,
      "triggerAsyncId": 1182,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1250
      ],
      "uniqueid": 957
    },
    "958": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732114918305",
      "endTime": "928732117814614",
      "elapsedTime": "2896309",
      "asyncId": 1250,
      "triggerAsyncId": 1248,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        1256,
        1251,
        1251
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 958
    },
    "959": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732115151071",
      "endTime": "928732121158583",
      "elapsedTime": "6007512",
      "asyncId": 1251,
      "triggerAsyncId": 1250,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1268,
        1252
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 959
    },
    "960": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928732115641381",
      "endTime": "928732124566952",
      "elapsedTime": "8925571",
      "asyncId": 1253,
      "triggerAsyncId": 1252,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1280,
        1254
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 960
    },
    "961": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:60:31:60:31",
      "startTime": "928732115881120",
      "endTime": "928732124747691",
      "elapsedTime": "8866571",
      "asyncId": 1254,
      "triggerAsyncId": 1253,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: valu",
      "startLine": 60,
      "startCol": 31,
      "endLine": 60,
      "endCol": 31,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1256
      ],
      "uniqueid": 961
    },
    "962": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732116105701",
      "endTime": "928732125010674",
      "elapsedTime": "8904973",
      "asyncId": 1255,
      "triggerAsyncId": 1182,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1257
      ],
      "uniqueid": 962
    },
    "963": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732116571865",
      "endTime": "928732125195951",
      "elapsedTime": "8624086",
      "asyncId": 1257,
      "triggerAsyncId": 1255,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1261
      ],
      "uniqueid": 963
    },
    "964": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732116781608",
      "endTime": "928732125286852",
      "elapsedTime": "8505244",
      "asyncId": 1258,
      "triggerAsyncId": 1218,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 964
    },
    "965": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732116942189",
      "endTime": "928732125389985",
      "elapsedTime": "8447796",
      "asyncId": 1259,
      "triggerAsyncId": 1231,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1261
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 965
    },
    "966": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732117120182",
      "endTime": "928732125472931",
      "elapsedTime": "8352749",
      "asyncId": 1260,
      "triggerAsyncId": 1244,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1266
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 966
    },
    "967": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732117276406",
      "endTime": "928732125565534",
      "elapsedTime": "8289128",
      "asyncId": 1261,
      "triggerAsyncId": 1257,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 967
    },
    "968": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732118105990",
      "endTime": "928732118129635",
      "elapsedTime": "23645",
      "asyncId": 1262,
      "triggerAsyncId": 1212,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1263
      ],
      "uniqueid": 968
    },
    "969": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732118374614",
      "endTime": "928732120117842",
      "elapsedTime": "1743228",
      "asyncId": 1263,
      "triggerAsyncId": 1262,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1270
      ],
      "uniqueid": 969
    },
    "970": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732118644821",
      "endTime": "928732118673755",
      "elapsedTime": "28934",
      "asyncId": 1264,
      "triggerAsyncId": 1225,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1265
      ],
      "uniqueid": 970
    },
    "971": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732118911771",
      "endTime": "928732120300023",
      "elapsedTime": "1388252",
      "asyncId": 1265,
      "triggerAsyncId": 1264,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1271
      ],
      "uniqueid": 971
    },
    "972": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732119211393",
      "endTime": "928732119228244",
      "elapsedTime": "16851",
      "asyncId": 1266,
      "triggerAsyncId": 1238,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1267
      ],
      "uniqueid": 972
    },
    "973": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732119462533",
      "endTime": "928732120450866",
      "elapsedTime": "988333",
      "asyncId": 1267,
      "triggerAsyncId": 1266,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1272
      ],
      "uniqueid": 973
    },
    "974": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732119765331",
      "endTime": "928732119790298",
      "elapsedTime": "24967",
      "asyncId": 1268,
      "triggerAsyncId": 1251,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1269
      ],
      "uniqueid": 974
    },
    "975": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732120053351",
      "endTime": "928732120618841",
      "elapsedTime": "565490",
      "asyncId": 1269,
      "triggerAsyncId": 1268,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1273
      ],
      "uniqueid": 975
    },
    "976": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732120268134",
      "endTime": "928732120901952",
      "elapsedTime": "633818",
      "asyncId": 1270,
      "triggerAsyncId": 1263,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1285
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 976
    },
    "977": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732120434175",
      "endTime": "928732121044369",
      "elapsedTime": "610194",
      "asyncId": 1271,
      "triggerAsyncId": 1265,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 977
    },
    "978": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732120602861",
      "endTime": "928732121112757",
      "elapsedTime": "509896",
      "asyncId": 1272,
      "triggerAsyncId": 1267,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1280
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 978
    },
    "979": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732120791184",
      "endTime": "928732121192456",
      "elapsedTime": "401272",
      "asyncId": 1273,
      "triggerAsyncId": 1269,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1274
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 979
    },
    "980": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732121596373",
      "endTime": "928732121616110",
      "elapsedTime": "19737",
      "asyncId": 1274,
      "triggerAsyncId": 1214,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1275
      ],
      "uniqueid": 980
    },
    "981": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732121842194",
      "endTime": "928732123561918",
      "elapsedTime": "1719724",
      "asyncId": 1275,
      "triggerAsyncId": 1274,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        1276,
        1278,
        1282
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 981
    },
    "982": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732122152887",
      "endTime": "928732122177533",
      "elapsedTime": "24646",
      "asyncId": 1276,
      "triggerAsyncId": 1227,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        1281,
        1277,
        1277
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 982
    },
    "983": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732122429946",
      "endTime": "928732123723621",
      "elapsedTime": "1293675",
      "asyncId": 1277,
      "triggerAsyncId": 1276,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1283
      ],
      "uniqueid": 983
    },
    "984": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732122702086",
      "endTime": "928732122734808",
      "elapsedTime": "32722",
      "asyncId": 1278,
      "triggerAsyncId": 1240,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "triggers": [
        1279,
        1279
      ],
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 984
    },
    "985": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732122963647",
      "endTime": "928732123888891",
      "elapsedTime": "925244",
      "asyncId": 1279,
      "triggerAsyncId": 1278,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1284
      ],
      "uniqueid": 985
    },
    "986": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732123244764",
      "endTime": "928732123272085",
      "elapsedTime": "27321",
      "asyncId": 1280,
      "triggerAsyncId": 1253,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1281
      ],
      "uniqueid": 986
    },
    "987": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732123492368",
      "endTime": "928732124082745",
      "elapsedTime": "590377",
      "asyncId": 1281,
      "triggerAsyncId": 1280,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "triggers": [
        1282,
        1285
      ],
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "uniqueid": 987
    },
    "988": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732123704035",
      "endTime": "928732124320130",
      "elapsedTime": "616095",
      "asyncId": 1282,
      "triggerAsyncId": 1275,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1283
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 988
    },
    "989": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732123866750",
      "endTime": "928732124437510",
      "elapsedTime": "570760",
      "asyncId": 1283,
      "triggerAsyncId": 1277,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1284
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 989
    },
    "990": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732124054001",
      "endTime": "928732124524462",
      "elapsedTime": "470461",
      "asyncId": 1284,
      "triggerAsyncId": 1279,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 990
    },
    "991": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732124222797",
      "endTime": "928732124592801",
      "elapsedTime": "370004",
      "asyncId": 1285,
      "triggerAsyncId": 1281,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 991
    },
    "992": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:546:51:546:51",
      "startTime": "928732126319618",
      "endTime": "928732126343552",
      "elapsedTime": "23934",
      "asyncId": 1286,
      "triggerAsyncId": 1136,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      ]); // cloned, otherwise it is modified inside resetSuperAdminPermissions()\n      const deleteByIds = jest.fn();\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: roleId }));\n      const createMany = jest.fn(() => []);\n      const removeUnkownConditionIds = jest.fn(conds => conds);",
      "startLine": 546,
      "startCol": 51,
      "endLine": 546,
      "endCol": 51,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [
        1287
      ],
      "uniqueid": 992
    },
    "993": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732126508632",
      "endTime": "928732127111272",
      "elapsedTime": "602640",
      "asyncId": 1287,
      "triggerAsyncId": 1286,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 993
    },
    "994": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732126881761",
      "endTime": "928732127076867",
      "elapsedTime": "195106",
      "asyncId": 1288,
      "triggerAsyncId": 1125,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        1289
      ],
      "uniqueid": 994
    },
    "995": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732127044316",
      "endTime": "928732128947714",
      "elapsedTime": "1903398",
      "asyncId": 1289,
      "triggerAsyncId": 1288,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 995
    },
    "996": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732128749894",
      "endTime": "928732128914081",
      "elapsedTime": "164187",
      "asyncId": 1290,
      "triggerAsyncId": 1125,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        1291
      ],
      "uniqueid": 996
    },
    "997": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732128902489",
      "endTime": "928732129576994",
      "elapsedTime": "674505",
      "asyncId": 1291,
      "triggerAsyncId": 1290,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        1292
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 997
    },
    "998": {
      "source": "packages/strapi-admin/services/role.js:328:38:328:38",
      "startTime": "928732129147749",
      "endTime": "928732129370577",
      "elapsedTime": "222828",
      "asyncId": 1292,
      "triggerAsyncId": 1291,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " assignPermissions",
      "userCode": false,
      "line": "\n\n  if (permissionsToAdd.length > 0) {\n    const createdPermissions = await addPermissions(roleId, permissionsToAdd);\n    permissionsToReturn.push(...createdPermissions.map(p => ({ ...p, role: p.role.id })));\n  }",
      "startLine": 328,
      "startCol": 38,
      "endLine": 328,
      "endCol": 38,
      "file": "packages/strapi-admin/services/role.js",
      "triggers": [
        1293
      ],
      "uniqueid": 998
    },
    "999": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732129554612",
      "endTime": "928732129645973",
      "elapsedTime": "91361",
      "asyncId": 1293,
      "triggerAsyncId": 1292,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 999
    },
    "1000": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732132611793",
      "endTime": "928732132633604",
      "elapsedTime": "21811",
      "asyncId": 1298,
      "triggerAsyncId": 81,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1299,
        1299
      ],
      "uniqueid": 1000
    },
    "1001": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732132886708",
      "endTime": "928732182517926",
      "elapsedTime": "49631218",
      "asyncId": 1299,
      "triggerAsyncId": 1298,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1308,
        1310,
        1316,
        1307,
        1314,
        1330,
        1300,
        1300
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 1001
    },
    "1002": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732133131888",
      "endTime": "928732302074986",
      "elapsedTime": "168943098",
      "asyncId": 1300,
      "triggerAsyncId": 1299,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1377,
        1379,
        1385,
        1376,
        1383,
        1396,
        1318
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 1002
    },
    "1003": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732137544460",
      "endTime": "928732137571079",
      "elapsedTime": "26619",
      "asyncId": 1310,
      "triggerAsyncId": 1299,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1311,
        1311
      ],
      "uniqueid": 1003
    },
    "1004": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732138297932",
      "endTime": "928732147894872",
      "elapsedTime": "9596940",
      "asyncId": 1311,
      "triggerAsyncId": 1310,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1321,
        1324,
        1322,
        1326,
        1332,
        1312,
        1312
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 1004
    },
    "1005": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732139061994",
      "endTime": "928732182237360",
      "elapsedTime": "43175366",
      "asyncId": 1312,
      "triggerAsyncId": 1311,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1336,
        1351,
        1339,
        1335,
        1334,
        1333,
        1349,
        1353,
        1357,
        1313
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 1005
    },
    "1006": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:600:25:600:25",
      "startTime": "928732150486160",
      "endTime": "928732181163297",
      "elapsedTime": "30677137",
      "asyncId": 1335,
      "triggerAsyncId": 1312,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        1372,
        1374,
        1347
      ],
      "line": "\n      };\n\n      await roleService.assignPermissions(1, []);\n\n      expect(deleteByIds).toHaveBeenCalledWith([3]);\n    })",
      "startLine": 600,
      "startCol": 25,
      "endLine": 600,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "uniqueid": 1006
    },
    "1007": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732155337704",
      "endTime": "928732166850185",
      "elapsedTime": "11512481",
      "asyncId": 1339,
      "triggerAsyncId": 1312,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1341
      ],
      "uniqueid": 1007
    },
    "1008": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732157487625",
      "endTime": "928732166948039",
      "elapsedTime": "9460414",
      "asyncId": 1341,
      "triggerAsyncId": 1339,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1342,
        1342
      ],
      "uniqueid": 1008
    },
    "1009": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732158310547",
      "endTime": "928732173395746",
      "elapsedTime": "15085199",
      "asyncId": 1342,
      "triggerAsyncId": 1341,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1358,
        1361,
        1343
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 1009
    },
    "1010": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928732159751518",
      "endTime": "928732175534946",
      "elapsedTime": "15783428",
      "asyncId": 1344,
      "triggerAsyncId": 1343,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1365,
        1345
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 1010
    },
    "1011": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:600:25:600:25",
      "startTime": "928732160909088",
      "endTime": "928732177624433",
      "elapsedTime": "16715345",
      "asyncId": 1346,
      "triggerAsyncId": 1345,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        1368
      ],
      "line": "\n      };\n\n      await roleService.assignPermissions(1, []);\n\n      expect(deleteByIds).toHaveBeenCalledWith([3]);\n    })",
      "startLine": 600,
      "startCol": 25,
      "endLine": 600,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "uniqueid": 1011
    },
    "1012": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732161848319",
      "endTime": "928732181708919",
      "elapsedTime": "19860600",
      "asyncId": 1347,
      "triggerAsyncId": 1335,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 1012
    },
    "1013": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:584:51:584:51",
      "startTime": "928732176736779",
      "endTime": "928732176762767",
      "elapsedTime": "25988",
      "asyncId": 1368,
      "triggerAsyncId": 1346,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n    test('Delete previous permissions', async () => {\n      const createMany = jest.fn(() => Promise.resolve([]));\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: 0 }));\n      const sendDidUpdateRolePermissions = jest.fn();\n      const find = jest.fn(() => Promise.resolve([{ id: 3 }]));\n      const deleteByIds = jest.fn()",
      "startLine": 584,
      "startCol": 51,
      "endLine": 584,
      "endCol": 51,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [
        1369
      ],
      "uniqueid": 1013
    },
    "1014": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732177595138",
      "endTime": "928732179197061",
      "elapsedTime": "1601923",
      "asyncId": 1369,
      "triggerAsyncId": 1368,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        1370
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 1014
    },
    "1015": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:586:42:586:42",
      "startTime": "928732178720648",
      "endTime": "928732178739443",
      "elapsedTime": "18795",
      "asyncId": 1370,
      "triggerAsyncId": 1369,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: 0 }));\n      const sendDidUpdateRolePermissions = jest.fn();\n      const find = jest.fn(() => Promise.resolve([{ id: 3 }]));\n      const deleteByIds = jest.fn();\n      const getAll = jest.fn(() => []);",
      "startLine": 586,
      "startCol": 42,
      "endLine": 586,
      "endCol": 42,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [
        1371
      ],
      "uniqueid": 1015
    },
    "1016": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732179178596",
      "endTime": "928732179893737",
      "elapsedTime": "715141",
      "asyncId": 1371,
      "triggerAsyncId": 1370,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 1016
    },
    "1017": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732179461687",
      "endTime": "928732179852449",
      "elapsedTime": "390762",
      "asyncId": 1372,
      "triggerAsyncId": 1335,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        1373
      ],
      "uniqueid": 1017
    },
    "1018": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732179840517",
      "endTime": "928732181128712",
      "elapsedTime": "1288195",
      "asyncId": 1373,
      "triggerAsyncId": 1372,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 1018
    },
    "1019": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732180539167",
      "endTime": "928732181088587",
      "elapsedTime": "549420",
      "asyncId": 1374,
      "triggerAsyncId": 1335,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        1375
      ],
      "uniqueid": 1019
    },
    "1020": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732181076714",
      "endTime": "928732181192662",
      "elapsedTime": "115948",
      "asyncId": 1375,
      "triggerAsyncId": 1374,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 1020
    },
    "1021": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732185845223",
      "endTime": "928732185862295",
      "elapsedTime": "17072",
      "asyncId": 1379,
      "triggerAsyncId": 1300,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1380,
        1380
      ],
      "uniqueid": 1021
    },
    "1022": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732187363419",
      "endTime": "928732196533700",
      "elapsedTime": "9170281",
      "asyncId": 1380,
      "triggerAsyncId": 1379,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1387,
        1390,
        1388,
        1392,
        1398,
        1381,
        1381
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 1022
    },
    "1023": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732188289606",
      "endTime": "928732301826260",
      "elapsedTime": "113536654",
      "asyncId": 1381,
      "triggerAsyncId": 1380,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1402,
        1417,
        1405,
        1401,
        1400,
        1399,
        1415,
        1419,
        1423,
        1382
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 1023
    },
    "1024": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:643:25:643:25",
      "startTime": "928732198539610",
      "endTime": "928732300873984",
      "elapsedTime": "102334374",
      "asyncId": 1401,
      "triggerAsyncId": 1381,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        1624,
        1413
      ],
      "line": "\n      };\n\n      await roleService.assignPermissions(1, permissionsToAssign);\n\n      expect(createMany).toHaveBeenCalledTimes(1);\n      expect(createMany).toHaveBeenCalledWith(",
      "startLine": 643,
      "startCol": 25,
      "endLine": 643,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "uniqueid": 1024
    },
    "1025": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:59:18:59:18",
      "startTime": "928732203040106",
      "endTime": "928732217769769",
      "elapsedTime": "14729663",
      "asyncId": 1405,
      "triggerAsyncId": 1381,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " settled",
      "userCode": false,
      "line": "\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true",
      "startLine": 59,
      "startCol": 18,
      "endLine": 59,
      "endCol": 18,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1407
      ],
      "uniqueid": 1025
    },
    "1026": {
      "source": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js:82:37:82:37",
      "startTime": "928732205955151",
      "endTime": "928732217844349",
      "elapsedTime": "11889198",
      "asyncId": 1407,
      "triggerAsyncId": 1405,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " collectErrors",
      "userCode": false,
      "line": "\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) ",
      "startLine": 82,
      "startCol": 37,
      "endLine": 82,
      "endCol": 37,
      "file": "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js",
      "triggers": [
        1408,
        1408
      ],
      "uniqueid": 1026
    },
    "1027": {
      "source": "packages/strapi-utils/node_modules/yup/lib/mixed.js:304:8:304:8",
      "startTime": "928732207146504",
      "endTime": "928732222660246",
      "elapsedTime": "15513742",
      "asyncId": 1408,
      "triggerAsyncId": 1407,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1424,
        1427,
        1409
      ],
      "line": "\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync",
      "startLine": 304,
      "startCol": 8,
      "endLine": 304,
      "endCol": 8,
      "file": "packages/strapi-utils/node_modules/yup/lib/mixed.js",
      "uniqueid": 1027
    },
    "1028": {
      "source": "packages/strapi-utils/node_modules/yup/lib/array.js:122:137:122:137",
      "startTime": "928732209283621",
      "endTime": "928732297590810",
      "elapsedTime": "88307189",
      "asyncId": 1410,
      "triggerAsyncId": 1409,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " ArraySchema._validate",
      "userCode": false,
      "triggers": [
        1431,
        1440,
        1449,
        1458,
        1467,
        1434,
        1443,
        1452,
        1461,
        1470,
        1481,
        1411
      ],
      "line": "\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value",
      "startLine": 122,
      "startCol": 137,
      "endLine": 122,
      "endCol": 137,
      "file": "packages/strapi-utils/node_modules/yup/lib/array.js",
      "uniqueid": 1028
    },
    "1029": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:643:25:643:25",
      "startTime": "928732211375071",
      "endTime": "928732298146992",
      "elapsedTime": "86771921",
      "asyncId": 1412,
      "triggerAsyncId": 1411,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "triggers": [
        1616
      ],
      "line": "\n      };\n\n      await roleService.assignPermissions(1, permissionsToAssign);\n\n      expect(createMany).toHaveBeenCalledTimes(1);\n      expect(createMany).toHaveBeenCalledWith(",
      "startLine": 643,
      "startCol": 25,
      "endLine": 643,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "uniqueid": 1029
    },
    "1030": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732211916917",
      "endTime": "928732301470242",
      "elapsedTime": "89553325",
      "asyncId": 1413,
      "triggerAsyncId": 1401,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 1030
    },
    "1031": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:611:51:611:51",
      "startTime": "928732297944242",
      "endTime": "928732297955974",
      "elapsedTime": "11732",
      "asyncId": 1616,
      "triggerAsyncId": 1412,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n\n      const createMany = jest.fn(() => Promise.resolve([]));\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: 0 }));\n      const sendDidUpdateRolePermissions = jest.fn();\n      const find = jest.fn(() => Promise.resolve([]));\n      const getAll = jest.fn(() => permissions.map(perm => ({ actionId: perm.action })))",
      "startLine": 611,
      "startCol": 51,
      "endLine": 611,
      "endCol": 51,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [
        1617
      ],
      "uniqueid": 1031
    },
    "1032": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732298123869",
      "endTime": "928732298923668",
      "elapsedTime": "799799",
      "asyncId": 1617,
      "triggerAsyncId": 1616,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        1618
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 1032
    },
    "1033": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:613:42:613:42",
      "startTime": "928732298723683",
      "endTime": "928732298753128",
      "elapsedTime": "29445",
      "asyncId": 1618,
      "triggerAsyncId": 1617,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: 0 }));\n      const sendDidUpdateRolePermissions = jest.fn();\n      const find = jest.fn(() => Promise.resolve([]));\n      const getAll = jest.fn(() => permissions.map(perm => ({ actionId: perm.action })));\n      const removeUnkownConditionIds = jest.fn(conds => _.intersection(conds, ['cond']));",
      "startLine": 613,
      "startCol": 42,
      "endLine": 613,
      "endCol": 42,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [
        1619
      ],
      "uniqueid": 1033
    },
    "1034": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732298904612",
      "endTime": "928732299861176",
      "elapsedTime": "956564",
      "asyncId": 1619,
      "triggerAsyncId": 1618,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "triggers": [
        1621,
        1620,
        1620
      ],
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "uniqueid": 1034
    },
    "1035": {
      "source": "packages/strapi-admin/services/role.js:328:38:328:38",
      "startTime": "928732299161564",
      "endTime": "928732300026205",
      "elapsedTime": "864641",
      "asyncId": 1620,
      "triggerAsyncId": 1619,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.assignPermissions",
      "userCode": false,
      "line": "\n\n  if (permissionsToAdd.length > 0) {\n    const createdPermissions = await addPermissions(roleId, permissionsToAdd);\n    permissionsToReturn.push(...createdPermissions.map(p => ({ ...p, role: p.role.id })));\n  }",
      "startLine": 328,
      "startCol": 38,
      "endLine": 328,
      "endCol": 38,
      "file": "packages/strapi-admin/services/role.js",
      "triggers": [
        1622
      ],
      "uniqueid": 1035
    },
    "1036": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:610:48:610:48",
      "startTime": "928732299627758",
      "endTime": "928732299641865",
      "elapsedTime": "14107",
      "asyncId": 1621,
      "triggerAsyncId": 1619,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n        .map((v, i) => ({ action: `action-${i}` }));\n\n      const createMany = jest.fn(() => Promise.resolve([]));\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: 0 }));\n      const sendDidUpdateRolePermissions = jest.fn();\n      const find = jest.fn(() => Promise.resolve([]))",
      "startLine": 610,
      "startCol": 48,
      "endLine": 610,
      "endCol": 48,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [
        1623
      ],
      "uniqueid": 1036
    },
    "1037": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732299846308",
      "endTime": "928732300838889",
      "elapsedTime": "992581",
      "asyncId": 1622,
      "triggerAsyncId": 1620,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 1037
    },
    "1038": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732299989566",
      "endTime": "928732300057023",
      "elapsedTime": "67457",
      "asyncId": 1623,
      "triggerAsyncId": 1621,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 1038
    },
    "1039": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732300223335",
      "endTime": "928732300412639",
      "elapsedTime": "189304",
      "asyncId": 1624,
      "triggerAsyncId": 1401,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [
        1625
      ],
      "uniqueid": 1039
    },
    "1040": {
      "source": "(/internal/process/task_queues:96:5:96:5)",
      "startTime": "928732300391600",
      "endTime": "928732300907647",
      "elapsedTime": "516047",
      "asyncId": 1625,
      "triggerAsyncId": 1624,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " processTicksAndRejections",
      "userCode": false,
      "line": "<promise not in user code>",
      "startLine": 0,
      "startCol": 0,
      "endLine": 0,
      "endCol": 0,
      "file": "",
      "triggers": [],
      "uniqueid": 1040
    },
    "1041": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732303531746",
      "endTime": "928732303554128",
      "elapsedTime": "22382",
      "asyncId": 1630,
      "triggerAsyncId": 82,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1631,
        1631
      ],
      "uniqueid": 1041
    },
    "1042": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732303798246",
      "endTime": "928732315130780",
      "elapsedTime": "11332534",
      "asyncId": 1631,
      "triggerAsyncId": 1630,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1639,
        1641,
        1647,
        1638,
        1645,
        1661,
        1649
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 1042
    },
    "1043": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:76:13:76:13",
      "startTime": "928732305826849",
      "endTime": "928732305855282",
      "elapsedTime": "28433",
      "asyncId": 1641,
      "triggerAsyncId": 1631,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " queueRunner",
      "userCode": false,
      "line": "\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token)",
      "startLine": 76,
      "startCol": 13,
      "endLine": 76,
      "endCol": 13,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "triggers": [
        1642,
        1642
      ],
      "uniqueid": 1043
    },
    "1044": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732306101884",
      "endTime": "928732310757952",
      "elapsedTime": "4656068",
      "asyncId": 1642,
      "triggerAsyncId": 1641,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1652,
        1655,
        1653,
        1657,
        1663,
        1643,
        1643
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 1044
    },
    "1045": {
      "source": "node_modules/jest-jasmine2/build/queueRunner.js:75:30:75:30",
      "startTime": "928732306332877",
      "endTime": "928732314769322",
      "elapsedTime": "8436445",
      "asyncId": 1643,
      "triggerAsyncId": 1642,
      "io": "",
      "createdIn": 1626205014924,
      "functionName": "",
      "userCode": false,
      "triggers": [
        1666,
        1671,
        1665,
        1664,
        1669,
        1673,
        1677,
        1644
      ],
      "line": "\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return ",
      "startLine": 75,
      "startCol": 30,
      "endLine": 75,
      "endCol": 30,
      "file": "node_modules/jest-jasmine2/build/queueRunner.js",
      "uniqueid": 1045
    },
    "1046": {
      "source": "packages/strapi-admin/services/__tests__/role.test.js:679:25:679:25",
      "startTime": "928732311581647",
      "endTime": "928732311712793",
      "elapsedTime": "131146",
      "asyncId": 1666,
      "triggerAsyncId": 1643,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.<anonymous>",
      "userCode": false,
      "line": "\n      };\n\n      await roleService.addPermissions(roleId, permissions);\n      expect(createMany).toHaveBeenCalledWith(\n        expect.arrayContaining(\n          permissions.map(permission => (",
      "startLine": 679,
      "startCol": 25,
      "endLine": 679,
      "endCol": 25,
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "triggers": [
        1667
      ],
      "uniqueid": 1046
    },
    "1047": {
      "source": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:106:37:106:37",
      "startTime": "928732311936041",
      "endTime": "928732313922595",
      "elapsedTime": "1986554",
      "asyncId": 1667,
      "triggerAsyncId": 1666,
      "io": false,
      "createdIn": 1626205014924,
      "functionName": " Object.asyncJestTest",
      "userCode": false,
      "line": "\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => ",
      "startLine": 106,
      "startCol": 37,
      "endLine": 106,
      "endCol": 37,
      "file": "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js",
      "triggers": [],
      "uniqueid": 1047
    }
  },
  "antipatterns": {
    "0": {
      "patternID": "pattern2",
      "file": "packages/strapi/bin/strapi.js",
      "startLine": "48",
      "startCol": "3",
      "endLine": "51",
      "endCol": "6"
    },
    "1": {
      "patternID": "pattern2",
      "file": "packages/strapi/lib/hooks/index.js",
      "startLine": "36",
      "startCol": "7",
      "endLine": "37",
      "endCol": "40"
    },
    "2": {
      "patternID": "pattern2",
      "file": "packages/strapi/lib/middlewares/index.js",
      "startLine": "52",
      "startCol": "7",
      "endLine": "53",
      "endCol": "40"
    },
    "3": {
      "patternID": "pattern2",
      "file": "packages/strapi-admin/ee/admin/containers/Roles/CreatePage/index.js",
      "startLine": "72",
      "startCol": "5",
      "endLine": "95",
      "endCol": "8"
    },
    "4": {
      "patternID": "pattern2",
      "file": "packages/strapi-admin/services/permission/engine.js",
      "startLine": "108",
      "startCol": "11",
      "endLine": "109",
      "endCol": "30"
    },
    "5": {
      "patternID": "pattern2",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/CreatePage/index.js",
      "startLine": "63",
      "startCol": "5",
      "endLine": "78",
      "endCol": "8"
    },
    "6": {
      "patternID": "pattern2",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/EditPage/index.js",
      "startLine": "68",
      "startCol": "5",
      "endLine": "81",
      "endCol": "8"
    },
    "7": {
      "patternID": "pattern2",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/ListPage/index.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "62",
      "endCol": "8"
    },
    "8": {
      "patternID": "pattern5",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "41",
      "startCol": "19",
      "endLine": "62",
      "endCol": "1"
    },
    "9": {
      "patternID": "pattern5",
      "file": "packages/strapi/lib/hooks/index.js",
      "startLine": "22",
      "startCol": "22",
      "endLine": "51",
      "endCol": "3"
    },
    "10": {
      "patternID": "pattern5",
      "file": "packages/strapi/lib/load/glob.js",
      "startLine": "8",
      "startCol": "18",
      "endLine": "15",
      "endCol": "1"
    },
    "11": {
      "patternID": "pattern5",
      "file": "packages/strapi/lib/middlewares/index.js",
      "startLine": "39",
      "startCol": "22",
      "endLine": "67",
      "endCol": "3"
    },
    "12": {
      "patternID": "pattern5",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/tests/useFetchPluginsFromMarketPlace.test.js",
      "startLine": "28",
      "startCol": "28",
      "endLine": "32",
      "endCol": "5"
    },
    "13": {
      "patternID": "pattern5",
      "file": "packages/strapi-admin/index.js",
      "startLine": "39",
      "startCol": "1",
      "endLine": "80",
      "endCol": "1"
    },
    "14": {
      "patternID": "pattern5",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "87",
      "startCol": "18",
      "endLine": "87",
      "endCol": "88"
    },
    "15": {
      "patternID": "pattern5",
      "file": "packages/strapi-admin/services/__tests__/token.test.js",
      "startLine": "5",
      "startCol": "15",
      "endLine": "5",
      "endCol": "71"
    },
    "16": {
      "patternID": "pattern5",
      "file": "packages/strapi-helper-plugin/lib/src/utils/request.js",
      "startLine": "68",
      "startCol": "1",
      "endLine": "91",
      "endCol": "1"
    },
    "17": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/ListView/index.js",
      "startLine": "163",
      "startCol": "16",
      "endLine": "167",
      "endCol": "3"
    },
    "18": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "131",
      "startCol": "21",
      "endLine": "149",
      "endCol": "1"
    },
    "19": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-upload/admin/src/components/EditForm/index.js",
      "startLine": "151",
      "startCol": "30",
      "endLine": "177",
      "endCol": "5"
    },
    "20": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-upload/utils/file.js",
      "startLine": "8",
      "startCol": "24",
      "endLine": "18",
      "endCol": "4"
    },
    "21": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/Jwt.js",
      "startLine": "50",
      "startCol": "9",
      "endLine": "64",
      "endCol": "3"
    },
    "22": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "27",
      "startCol": "17",
      "endLine": "105",
      "endCol": "1"
    },
    "23": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "425",
      "startCol": "35",
      "endLine": "438",
      "endCol": "9"
    },
    "24": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "440",
      "startCol": "33",
      "endLine": "453",
      "endCol": "9"
    },
    "25": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "87",
      "startCol": "15",
      "endLine": "100",
      "endCol": "3"
    },
    "26": {
      "patternID": "pattern5",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "122",
      "startCol": "13",
      "endLine": "142",
      "endCol": "3"
    },
    "27": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-email-amazon-ses/lib/index.js",
      "startLine": "11",
      "startCol": "13",
      "endLine": "37",
      "endCol": "7"
    },
    "28": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-email-mailgun/lib/index.js",
      "startLine": "14",
      "startCol": "13",
      "endLine": "38",
      "endCol": "7"
    },
    "29": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-email-sendgrid/lib/index.js",
      "startLine": "11",
      "startCol": "13",
      "endLine": "35",
      "endCol": "7"
    },
    "30": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-email-sendmail/lib/index.js",
      "startLine": "13",
      "startCol": "13",
      "endLine": "37",
      "endCol": "7"
    },
    "31": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-aws-s3/lib/index.js",
      "startLine": "20",
      "startCol": "13",
      "endLine": "44",
      "endCol": "7"
    },
    "32": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-aws-s3/lib/index.js",
      "startLine": "45",
      "startCol": "13",
      "endLine": "63",
      "endCol": "7"
    },
    "33": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-cloudinary/lib/index.js",
      "startLine": "17",
      "startCol": "13",
      "endLine": "59",
      "endCol": "7"
    },
    "34": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-local/lib/index.js",
      "startLine": "27",
      "startCol": "13",
      "endLine": "46",
      "endCol": "7"
    },
    "35": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-local/lib/index.js",
      "startLine": "47",
      "startCol": "13",
      "endLine": "64",
      "endCol": "7"
    },
    "36": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-rackspace/lib/index.js",
      "startLine": "19",
      "startCol": "23",
      "endLine": "25",
      "endCol": "8"
    },
    "37": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-rackspace/lib/index.js",
      "startLine": "28",
      "startCol": "13",
      "endLine": "52",
      "endCol": "7"
    },
    "38": {
      "patternID": "pattern5",
      "file": "packages/strapi-provider-upload-rackspace/lib/index.js",
      "startLine": "53",
      "startCol": "13",
      "endLine": "60",
      "endCol": "7"
    },
    "39": {
      "patternID": "pattern5",
      "file": "test/helpers/test-app-generator.js",
      "startLine": "11",
      "startCol": "22",
      "endLine": "18",
      "endCol": "1"
    },
    "40": {
      "patternID": "pattern3",
      "file": "examples/getstarted/api/homepage/config/policies/test.js",
      "startLine": "4",
      "startCol": "3",
      "endLine": "4",
      "endCol": "14"
    },
    "41": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "208",
      "startCol": "5",
      "endLine": "214",
      "endCol": "5"
    },
    "42": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "217",
      "startCol": "7",
      "endLine": "217",
      "endCol": "32"
    },
    "43": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "223",
      "startCol": "7",
      "endLine": "223",
      "endCol": "29"
    },
    "44": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "254",
      "startCol": "7",
      "endLine": "254",
      "endCol": "80"
    },
    "45": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "312",
      "startCol": "9",
      "endLine": "312",
      "endCol": "20"
    },
    "46": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "325",
      "startCol": "5",
      "endLine": "325",
      "endCol": "25"
    },
    "47": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "339",
      "startCol": "5",
      "endLine": "339",
      "endCol": "30"
    },
    "48": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "373",
      "startCol": "22",
      "endLine": "373",
      "endCol": "59"
    },
    "49": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/Strapi.js",
      "startLine": "432",
      "startCol": "5",
      "endLine": "432",
      "endCol": "38"
    },
    "50": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/__tests__/admin-reset.test.js",
      "startLine": "61",
      "startCol": "7",
      "endLine": "63",
      "endCol": "8"
    },
    "51": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/__tests__/admin-reset.test.js",
      "startLine": "89",
      "startCol": "7",
      "endLine": "91",
      "endCol": "8"
    },
    "52": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/admin-reset.js",
      "startLine": "27",
      "startCol": "21",
      "endLine": "27",
      "endCol": "58"
    },
    "53": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/admin-reset.js",
      "startLine": "47",
      "startCol": "3",
      "endLine": "47",
      "endCol": "69"
    },
    "54": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationDump.js",
      "startLine": "17",
      "startCol": "17",
      "endLine": "17",
      "endCol": "53"
    },
    "55": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationDump.js",
      "startLine": "24",
      "startCol": "21",
      "endLine": "26",
      "endCol": "76"
    },
    "56": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "31",
      "startCol": "5",
      "endLine": "31",
      "endCol": "33"
    },
    "57": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "93",
      "startCol": "24",
      "endLine": "93",
      "endCol": "76"
    },
    "58": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "96",
      "startCol": "9",
      "endLine": "96",
      "endCol": "68"
    },
    "59": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "99",
      "startCol": "9",
      "endLine": "99",
      "endCol": "49"
    },
    "60": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "121",
      "startCol": "28",
      "endLine": "121",
      "endCol": "79"
    },
    "61": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "124",
      "startCol": "9",
      "endLine": "124",
      "endCol": "91"
    },
    "62": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "127",
      "startCol": "9",
      "endLine": "127",
      "endCol": "49"
    },
    "63": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "149",
      "startCol": "24",
      "endLine": "149",
      "endCol": "76"
    },
    "64": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/configurationRestore.js",
      "startLine": "157",
      "startCol": "7",
      "endLine": "157",
      "endCol": "47"
    },
    "65": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/install.js",
      "startLine": "22",
      "startCol": "7",
      "endLine": "22",
      "endCol": "49"
    },
    "66": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/install.js",
      "startLine": "24",
      "startCol": "7",
      "endLine": "24",
      "endCol": "62"
    },
    "67": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/install.js",
      "startLine": "40",
      "startCol": "7",
      "endLine": "40",
      "endCol": "42"
    },
    "68": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/uninstall.js",
      "startLine": "11",
      "startCol": "19",
      "endLine": "19",
      "endCol": "4"
    },
    "69": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/uninstall.js",
      "startLine": "40",
      "startCol": "7",
      "endLine": "40",
      "endCol": "52"
    },
    "70": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/uninstall.js",
      "startLine": "42",
      "startCol": "7",
      "endLine": "42",
      "endCol": "51"
    },
    "71": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/commands/uninstall.js",
      "startLine": "60",
      "startCol": "7",
      "endLine": "60",
      "endCol": "42"
    },
    "72": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/__tests__/fs.test.js",
      "startLine": "30",
      "startCol": "7",
      "endLine": "30",
      "endCol": "50"
    },
    "73": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/__tests__/fs.test.js",
      "startLine": "41",
      "startCol": "7",
      "endLine": "41",
      "endCol": "56"
    },
    "74": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/__tests__/fs.test.js",
      "startLine": "52",
      "startCol": "7",
      "endLine": "52",
      "endCol": "67"
    },
    "75": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/__tests__/fs.test.js",
      "startLine": "70",
      "startCol": "7",
      "endLine": "70",
      "endCol": "91"
    },
    "76": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-admin.js",
      "startLine": "14",
      "startCol": "27",
      "endLine": "17",
      "endCol": "4"
    },
    "77": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-admin.js",
      "startLine": "29",
      "startCol": "27",
      "endLine": "32",
      "endCol": "6"
    },
    "78": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-components.js",
      "startLine": "11",
      "startCol": "9",
      "endLine": "11",
      "endCol": "35"
    },
    "79": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-hooks.js",
      "startLine": "16",
      "startCol": "3",
      "endLine": "24",
      "endCol": "4"
    },
    "80": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-hooks.js",
      "startLine": "53",
      "startCol": "24",
      "endLine": "53",
      "endCol": "51"
    },
    "81": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-hooks.js",
      "startLine": "57",
      "startCol": "18",
      "endLine": "57",
      "endCol": "68"
    },
    "82": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "20",
      "startCol": "3",
      "endLine": "20",
      "endCol": "77"
    },
    "83": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "22",
      "startCol": "3",
      "endLine": "22",
      "endCol": "52"
    },
    "84": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "24",
      "startCol": "3",
      "endLine": "24",
      "endCol": "58"
    },
    "85": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "26",
      "startCol": "3",
      "endLine": "26",
      "endCol": "69"
    },
    "86": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "28",
      "startCol": "3",
      "endLine": "28",
      "endCol": "65"
    },
    "87": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "30",
      "startCol": "3",
      "endLine": "30",
      "endCol": "49"
    },
    "88": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "68",
      "startCol": "26",
      "endLine": "68",
      "endCol": "53"
    },
    "89": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-middlewares.js",
      "startLine": "72",
      "startCol": "20",
      "endLine": "72",
      "endCol": "72"
    },
    "90": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-modules.js",
      "startLine": "24",
      "startCol": "76",
      "endLine": "32",
      "endCol": "4"
    },
    "91": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core/load-plugins.js",
      "startLine": "36",
      "startCol": "28",
      "endLine": "39",
      "endCol": "4"
    },
    "92": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/__tests__/service.test.js",
      "startLine": "82",
      "startCol": "9",
      "endLine": "82",
      "endCol": "43"
    },
    "93": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/__tests__/service.test.js",
      "startLine": "115",
      "startCol": "9",
      "endLine": "115",
      "endCol": "43"
    },
    "94": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/__tests__/service.test.js",
      "startLine": "150",
      "startCol": "9",
      "endLine": "150",
      "endCol": "30"
    },
    "95": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "36",
      "startCol": "22",
      "endLine": "36",
      "endCol": "46"
    },
    "96": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "49",
      "startCol": "18",
      "endLine": "49",
      "endCol": "62"
    },
    "97": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "51",
      "startCol": "18",
      "endLine": "51",
      "endCol": "63"
    },
    "98": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "58",
      "startCol": "22",
      "endLine": "58",
      "endCol": "43"
    },
    "99": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "80",
      "startCol": "20",
      "endLine": "80",
      "endCol": "50"
    },
    "100": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "82",
      "startCol": "20",
      "endLine": "82",
      "endCol": "48"
    },
    "101": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "95",
      "startCol": "22",
      "endLine": "95",
      "endCol": "71"
    },
    "102": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "121",
      "startCol": "18",
      "endLine": "121",
      "endCol": "54"
    },
    "103": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "123",
      "startCol": "18",
      "endLine": "123",
      "endCol": "55"
    },
    "104": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "138",
      "startCol": "18",
      "endLine": "138",
      "endCol": "77"
    },
    "105": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "140",
      "startCol": "18",
      "endLine": "140",
      "endCol": "78"
    },
    "106": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/controller.js",
      "startLine": "152",
      "startCol": "22",
      "endLine": "152",
      "endCol": "64"
    },
    "107": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/service.js",
      "startLine": "98",
      "startCol": "22",
      "endLine": "98",
      "endCol": "38"
    },
    "108": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/core-api/service.js",
      "startLine": "123",
      "startCol": "22",
      "endLine": "123",
      "endCol": "38"
    },
    "109": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/hooks/index.js",
      "startLine": "58",
      "startCol": "3",
      "endLine": "65",
      "endCol": "3"
    },
    "110": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/load/load-files.js",
      "startLine": "35",
      "startCol": "13",
      "endLine": "35",
      "endCol": "44"
    },
    "111": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/boom/index.js",
      "startLine": "75",
      "startCol": "11",
      "endLine": "75",
      "endCol": "22"
    },
    "112": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/boom/index.js",
      "startLine": "96",
      "startCol": "9",
      "endLine": "96",
      "endCol": "20"
    },
    "113": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/cors/index.js",
      "startLine": "39",
      "startCol": "28",
      "endLine": "39",
      "endCol": "44"
    },
    "114": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/csp/index.js",
      "startLine": "17",
      "startCol": "39",
      "endLine": "17",
      "endCol": "50"
    },
    "115": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/middlewares/csp/index.js",
      "startLine": "16",
      "startCol": "22",
      "endLine": "23",
      "endCol": "7"
    },
    "116": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/csp/index.js",
      "startLine": "19",
      "startCol": "16",
      "endLine": "22",
      "endCol": "9"
    },
    "117": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/hsts/index.js",
      "startLine": "23",
      "startCol": "16",
      "endLine": "26",
      "endCol": "9"
    },
    "118": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/middlewares/hsts/index.js",
      "startLine": "20",
      "startCol": "22",
      "endLine": "27",
      "endCol": "7"
    },
    "119": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/index.js",
      "startLine": "74",
      "startCol": "3",
      "endLine": "81",
      "endCol": "3"
    },
    "120": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/index.js",
      "startLine": "113",
      "startCol": "3",
      "endLine": "116",
      "endCol": "4"
    },
    "121": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/logger/index.js",
      "startLine": "56",
      "startCol": "11",
      "endLine": "56",
      "endCol": "22"
    },
    "122": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/p3p/index.js",
      "startLine": "22",
      "startCol": "16",
      "endLine": "25",
      "endCol": "9"
    },
    "123": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/middlewares/p3p/index.js",
      "startLine": "19",
      "startCol": "22",
      "endLine": "26",
      "endCol": "7"
    },
    "124": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/parser/index.js",
      "startLine": "48",
      "startCol": "23",
      "endLine": "51",
      "endCol": "23"
    },
    "125": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/poweredBy/index.js",
      "startLine": "7",
      "startCol": "9",
      "endLine": "7",
      "endCol": "20"
    },
    "126": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/public/index.js",
      "startLine": "35",
      "startCol": "11",
      "endLine": "35",
      "endCol": "22"
    },
    "127": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/public/serve-static.js",
      "startLine": "14",
      "startCol": "5",
      "endLine": "18",
      "endCol": "6"
    },
    "128": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/public/serve-static.js",
      "startLine": "16",
      "startCol": "7",
      "endLine": "16",
      "endCol": "18"
    },
    "129": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/responseTime/index.js",
      "startLine": "17",
      "startCol": "9",
      "endLine": "17",
      "endCol": "20"
    },
    "130": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/responses/index.js",
      "startLine": "9",
      "startCol": "9",
      "endLine": "9",
      "endCol": "20"
    },
    "131": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/responses/index.js",
      "startLine": "13",
      "startCol": "11",
      "endLine": "13",
      "endCol": "31"
    },
    "132": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/router/utils/routerChecker.js",
      "startLine": "79",
      "startCol": "22",
      "endLine": "79",
      "endCol": "33"
    },
    "133": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xframe/index.js",
      "startLine": "21",
      "startCol": "18",
      "endLine": "21",
      "endCol": "66"
    },
    "134": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/middlewares/xframe/index.js",
      "startLine": "19",
      "startCol": "22",
      "endLine": "30",
      "endCol": "7"
    },
    "135": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xframe/index.js",
      "startLine": "26",
      "startCol": "18",
      "endLine": "26",
      "endCol": "56"
    },
    "136": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xframe/index.js",
      "startLine": "29",
      "startCol": "9",
      "endLine": "29",
      "endCol": "20"
    },
    "137": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xss/index.js",
      "startLine": "13",
      "startCol": "18",
      "endLine": "18",
      "endCol": "22"
    },
    "138": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/middlewares/xss/index.js",
      "startLine": "11",
      "startCol": "22",
      "endLine": "27",
      "endCol": "7"
    },
    "139": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xss/index.js",
      "startLine": "23",
      "startCol": "18",
      "endLine": "23",
      "endCol": "67"
    },
    "140": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/middlewares/xss/index.js",
      "startLine": "26",
      "startCol": "9",
      "endLine": "26",
      "endCol": "20"
    },
    "141": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-service.test.js",
      "startLine": "40",
      "startCol": "22",
      "endLine": "40",
      "endCol": "69"
    },
    "142": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-service.test.js",
      "startLine": "69",
      "startCol": "7",
      "endLine": "71",
      "endCol": "7"
    },
    "143": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-service.test.js",
      "startLine": "130",
      "startCol": "9",
      "endLine": "139",
      "endCol": "10"
    },
    "144": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-service.test.js",
      "startLine": "150",
      "startCol": "9",
      "endLine": "159",
      "endCol": "10"
    },
    "145": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-service.test.js",
      "startLine": "174",
      "startCol": "9",
      "endLine": "176",
      "endCol": "9"
    },
    "146": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "27",
      "startCol": "9",
      "endLine": "32",
      "endCol": "10"
    },
    "147": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "48",
      "startCol": "22",
      "endLine": "48",
      "endCol": "79"
    },
    "148": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "68",
      "startCol": "22",
      "endLine": "68",
      "endCol": "79"
    },
    "149": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "93",
      "startCol": "9",
      "endLine": "97",
      "endCol": "10"
    },
    "150": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "99",
      "startCol": "9",
      "endLine": "103",
      "endCol": "10"
    },
    "151": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "119",
      "startCol": "22",
      "endLine": "119",
      "endCol": "79"
    },
    "152": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "147",
      "startCol": "9",
      "endLine": "151",
      "endCol": "10"
    },
    "153": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "174",
      "startCol": "9",
      "endLine": "178",
      "endCol": "10"
    },
    "154": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "195",
      "startCol": "22",
      "endLine": "195",
      "endCol": "79"
    },
    "155": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "227",
      "startCol": "9",
      "endLine": "235",
      "endCol": "10"
    },
    "156": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "253",
      "startCol": "9",
      "endLine": "261",
      "endCol": "10"
    },
    "157": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "287",
      "startCol": "9",
      "endLine": "292",
      "endCol": "10"
    },
    "158": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "308",
      "startCol": "22",
      "endLine": "308",
      "endCol": "98"
    },
    "159": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "328",
      "startCol": "22",
      "endLine": "328",
      "endCol": "98"
    },
    "160": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "347",
      "startCol": "20",
      "endLine": "347",
      "endCol": "93"
    },
    "161": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "350",
      "startCol": "16",
      "endLine": "354",
      "endCol": "9"
    },
    "162": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "371",
      "startCol": "22",
      "endLine": "371",
      "endCol": "98"
    },
    "163": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "393",
      "startCol": "22",
      "endLine": "393",
      "endCol": "98"
    },
    "164": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "417",
      "startCol": "9",
      "endLine": "421",
      "endCol": "10"
    },
    "165": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "437",
      "startCol": "22",
      "endLine": "437",
      "endCol": "98"
    },
    "166": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "469",
      "startCol": "9",
      "endLine": "479",
      "endCol": "10"
    },
    "167": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/__tests__/entity-validator.test.js",
      "startLine": "497",
      "startCol": "9",
      "endLine": "509",
      "endCol": "10"
    },
    "168": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/core-store.js",
      "startLine": "49",
      "startCol": "20",
      "endLine": "49",
      "endCol": "62"
    },
    "169": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/core-store.js",
      "startLine": "88",
      "startCol": "20",
      "endLine": "88",
      "endCol": "62"
    },
    "170": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/core-store.js",
      "startLine": "96",
      "startCol": "9",
      "endLine": "96",
      "endCol": "66"
    },
    "171": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/core-store.js",
      "startLine": "104",
      "startCol": "9",
      "endLine": "104",
      "endCol": "49"
    },
    "172": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "29",
      "startCol": "23",
      "endLine": "29",
      "endCol": "84"
    },
    "173": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "75",
      "startCol": "21",
      "endLine": "75",
      "endCol": "49"
    },
    "174": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "83",
      "startCol": "23",
      "endLine": "83",
      "endCol": "95"
    },
    "175": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "85",
      "startCol": "17",
      "endLine": "85",
      "endCol": "55"
    },
    "176": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "89",
      "startCol": "15",
      "endLine": "89",
      "endCol": "73"
    },
    "177": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "108",
      "startCol": "27",
      "endLine": "108",
      "endCol": "63"
    },
    "178": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "112",
      "startCol": "23",
      "endLine": "114",
      "endCol": "6"
    },
    "179": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "116",
      "startCol": "17",
      "endLine": "116",
      "endCol": "63"
    },
    "180": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "120",
      "startCol": "15",
      "endLine": "120",
      "endCol": "73"
    },
    "181": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-service.js",
      "startLine": "138",
      "startCol": "19",
      "endLine": "138",
      "endCol": "54"
    },
    "182": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/entity-validator/index.js",
      "startLine": "177",
      "startCol": "12",
      "endLine": "177",
      "endCol": "64"
    },
    "183": {
      "patternID": "pattern1",
      "file": "packages/strapi/lib/services/entity-validator/index.js",
      "startLine": "174",
      "startCol": "48",
      "endLine": "181",
      "endCol": "1"
    },
    "184": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/metrics/middleware.js",
      "startLine": "29",
      "startCol": "5",
      "endLine": "29",
      "endCol": "16"
    },
    "185": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/metrics/sender.js",
      "startLine": "58",
      "startCol": "19",
      "endLine": "58",
      "endCol": "66"
    },
    "186": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/utils/upload-files.js",
      "startLine": "69",
      "startCol": "3",
      "endLine": "69",
      "endCol": "77"
    },
    "187": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-runner.js",
      "startLine": "70",
      "startCol": "7",
      "endLine": "73",
      "endCol": "8"
    },
    "188": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-runner.js",
      "startLine": "104",
      "startCol": "20",
      "endLine": "104",
      "endCol": "35"
    },
    "189": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-store.js",
      "startLine": "61",
      "startCol": "23",
      "endLine": "61",
      "endCol": "49"
    },
    "190": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-store.js",
      "startLine": "67",
      "startCol": "22",
      "endLine": "67",
      "endCol": "57"
    },
    "191": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-store.js",
      "startLine": "76",
      "startCol": "23",
      "endLine": "76",
      "endCol": "75"
    },
    "192": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/webhook-store.js",
      "startLine": "81",
      "startCol": "23",
      "endLine": "81",
      "endCol": "57"
    },
    "193": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/services/worker-queue.js",
      "startLine": "49",
      "startCol": "7",
      "endLine": "49",
      "endCol": "32"
    },
    "194": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/utils/index.js",
      "startLine": "17",
      "startCol": "38",
      "endLine": "17",
      "endCol": "92"
    },
    "195": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/utils/openBrowser.js",
      "startLine": "106",
      "startCol": "5",
      "endLine": "106",
      "endCol": "66"
    },
    "196": {
      "patternID": "pattern3",
      "file": "packages/strapi/lib/utils/update-notifier/index.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "56",
      "endCol": "45"
    },
    "197": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "54",
      "startCol": "5",
      "endLine": "57",
      "endCol": "14"
    },
    "198": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "60",
      "startCol": "10",
      "endLine": "60",
      "endCol": "44"
    },
    "199": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "65",
      "startCol": "5",
      "endLine": "65",
      "endCol": "27"
    },
    "200": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "83",
      "endCol": "6"
    },
    "201": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "92",
      "startCol": "17",
      "endLine": "95",
      "endCol": "6"
    },
    "202": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "115",
      "startCol": "17",
      "endLine": "119",
      "endCol": "6"
    },
    "203": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "129",
      "startCol": "17",
      "endLine": "132",
      "endCol": "6"
    },
    "204": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "147",
      "startCol": "19",
      "endLine": "151",
      "endCol": "8"
    },
    "205": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "168",
      "startCol": "19",
      "endLine": "172",
      "endCol": "8"
    },
    "206": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "191",
      "startCol": "19",
      "endLine": "195",
      "endCol": "8"
    },
    "207": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "213",
      "startCol": "19",
      "endLine": "217",
      "endCol": "8"
    },
    "208": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "56",
      "endCol": "14"
    },
    "209": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "59",
      "startCol": "10",
      "endLine": "59",
      "endCol": "44"
    },
    "210": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "64",
      "startCol": "5",
      "endLine": "64",
      "endCol": "27"
    },
    "211": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "76",
      "startCol": "17",
      "endLine": "80",
      "endCol": "6"
    },
    "212": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "89",
      "startCol": "17",
      "endLine": "92",
      "endCol": "6"
    },
    "213": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "110",
      "startCol": "17",
      "endLine": "114",
      "endCol": "6"
    },
    "214": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "124",
      "startCol": "17",
      "endLine": "127",
      "endCol": "6"
    },
    "215": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "142",
      "startCol": "19",
      "endLine": "146",
      "endCol": "8"
    },
    "216": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "161",
      "startCol": "19",
      "endLine": "165",
      "endCol": "8"
    },
    "217": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "182",
      "startCol": "19",
      "endLine": "186",
      "endCol": "8"
    },
    "218": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-compo.test.e2e.js",
      "startLine": "202",
      "startCol": "19",
      "endLine": "206",
      "endCol": "8"
    },
    "219": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "55",
      "startCol": "5",
      "endLine": "58",
      "endCol": "14"
    },
    "220": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "61",
      "startCol": "10",
      "endLine": "61",
      "endCol": "44"
    },
    "221": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "66",
      "startCol": "5",
      "endLine": "66",
      "endCol": "27"
    },
    "222": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "80",
      "startCol": "17",
      "endLine": "84",
      "endCol": "6"
    },
    "223": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "93",
      "startCol": "17",
      "endLine": "96",
      "endCol": "6"
    },
    "224": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "118",
      "startCol": "17",
      "endLine": "122",
      "endCol": "6"
    },
    "225": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "132",
      "startCol": "17",
      "endLine": "135",
      "endCol": "6"
    },
    "226": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "150",
      "startCol": "19",
      "endLine": "154",
      "endCol": "8"
    },
    "227": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "171",
      "startCol": "19",
      "endLine": "175",
      "endCol": "8"
    },
    "228": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "194",
      "startCol": "19",
      "endLine": "198",
      "endCol": "8"
    },
    "229": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "216",
      "startCol": "19",
      "endLine": "220",
      "endCol": "8"
    },
    "230": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "54",
      "startCol": "5",
      "endLine": "57",
      "endCol": "14"
    },
    "231": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "60",
      "startCol": "10",
      "endLine": "60",
      "endCol": "44"
    },
    "232": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "65",
      "startCol": "5",
      "endLine": "65",
      "endCol": "27"
    },
    "233": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "77",
      "startCol": "17",
      "endLine": "81",
      "endCol": "6"
    },
    "234": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "90",
      "startCol": "17",
      "endLine": "93",
      "endCol": "6"
    },
    "235": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "113",
      "startCol": "17",
      "endLine": "117",
      "endCol": "6"
    },
    "236": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "127",
      "startCol": "17",
      "endLine": "130",
      "endCol": "6"
    },
    "237": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "145",
      "startCol": "19",
      "endLine": "149",
      "endCol": "8"
    },
    "238": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "164",
      "startCol": "19",
      "endLine": "168",
      "endCol": "8"
    },
    "239": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "185",
      "startCol": "19",
      "endLine": "189",
      "endCol": "8"
    },
    "240": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "205",
      "startCol": "19",
      "endLine": "209",
      "endCol": "8"
    },
    "241": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "52",
      "startCol": "5",
      "endLine": "55",
      "endCol": "14"
    },
    "242": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "58",
      "startCol": "10",
      "endLine": "58",
      "endCol": "44"
    },
    "243": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "63",
      "startCol": "5",
      "endLine": "63",
      "endCol": "27"
    },
    "244": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "71",
      "startCol": "17",
      "endLine": "75",
      "endCol": "6"
    },
    "245": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "89",
      "startCol": "17",
      "endLine": "93",
      "endCol": "6"
    },
    "246": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "103",
      "startCol": "17",
      "endLine": "106",
      "endCol": "6"
    },
    "247": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "129",
      "startCol": "17",
      "endLine": "133",
      "endCol": "6"
    },
    "248": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "148",
      "startCol": "17",
      "endLine": "152",
      "endCol": "6"
    },
    "249": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "162",
      "startCol": "17",
      "endLine": "165",
      "endCol": "6"
    },
    "250": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "180",
      "startCol": "19",
      "endLine": "184",
      "endCol": "8"
    },
    "251": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "196",
      "startCol": "19",
      "endLine": "200",
      "endCol": "8"
    },
    "252": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dp.test.e2e.js",
      "startLine": "211",
      "startCol": "19",
      "endLine": "215",
      "endCol": "8"
    },
    "253": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "56",
      "endCol": "14"
    },
    "254": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "59",
      "startCol": "10",
      "endLine": "59",
      "endCol": "44"
    },
    "255": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "64",
      "startCol": "5",
      "endLine": "64",
      "endCol": "27"
    },
    "256": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "83",
      "endCol": "6"
    },
    "257": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "92",
      "startCol": "17",
      "endLine": "95",
      "endCol": "6"
    },
    "258": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "116",
      "startCol": "17",
      "endLine": "120",
      "endCol": "6"
    },
    "259": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "130",
      "startCol": "17",
      "endLine": "133",
      "endCol": "6"
    },
    "260": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "148",
      "startCol": "19",
      "endLine": "152",
      "endCol": "8"
    },
    "261": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "170",
      "startCol": "19",
      "endLine": "174",
      "endCol": "8"
    },
    "262": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "194",
      "startCol": "19",
      "endLine": "198",
      "endCol": "8"
    },
    "263": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "217",
      "startCol": "19",
      "endLine": "221",
      "endCol": "8"
    },
    "264": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic-dz.test.e2e.js",
      "startLine": "240",
      "startCol": "19",
      "endLine": "244",
      "endCol": "8"
    },
    "265": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "46",
      "startCol": "5",
      "endLine": "49",
      "endCol": "14"
    },
    "266": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "52",
      "startCol": "10",
      "endLine": "52",
      "endCol": "44"
    },
    "267": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "57",
      "startCol": "5",
      "endLine": "57",
      "endCol": "27"
    },
    "268": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "65",
      "startCol": "17",
      "endLine": "69",
      "endCol": "6"
    },
    "269": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "78",
      "startCol": "17",
      "endLine": "81",
      "endCol": "6"
    },
    "270": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "102",
      "startCol": "17",
      "endLine": "106",
      "endCol": "6"
    },
    "271": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/api/basic.test.e2e.js",
      "startLine": "116",
      "startCol": "17",
      "endLine": "119",
      "endCol": "6"
    },
    "272": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "85",
      "startCol": "5",
      "endLine": "89",
      "endCol": "14"
    },
    "273": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "92",
      "startCol": "10",
      "endLine": "92",
      "endCol": "44"
    },
    "274": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "99",
      "startCol": "5",
      "endLine": "99",
      "endCol": "27"
    },
    "275": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "105",
      "startCol": "21",
      "endLine": "111",
      "endCol": "10"
    },
    "276": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "120",
      "startCol": "21",
      "endLine": "126",
      "endCol": "10"
    },
    "277": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "136",
      "startCol": "21",
      "endLine": "142",
      "endCol": "10"
    },
    "278": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "154",
      "startCol": "21",
      "endLine": "161",
      "endCol": "10"
    },
    "279": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "169",
      "startCol": "21",
      "endLine": "176",
      "endCol": "10"
    },
    "280": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "186",
      "startCol": "21",
      "endLine": "193",
      "endCol": "10"
    },
    "281": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/deepFiltering.test.e2e.js",
      "startLine": "200",
      "startCol": "21",
      "endLine": "207",
      "endCol": "10"
    },
    "282": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "25",
      "startCol": "5",
      "endLine": "29",
      "endCol": "14"
    },
    "283": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "32",
      "startCol": "10",
      "endLine": "32",
      "endCol": "44"
    },
    "284": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "37",
      "startCol": "5",
      "endLine": "37",
      "endCol": "27"
    },
    "285": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "49",
      "startCol": "24",
      "endLine": "55",
      "endCol": "8"
    },
    "286": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "65",
      "startCol": "24",
      "endLine": "71",
      "endCol": "8"
    },
    "287": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "81",
      "startCol": "24",
      "endLine": "87",
      "endCol": "8"
    },
    "288": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "102",
      "startCol": "24",
      "endLine": "106",
      "endCol": "8"
    },
    "289": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "124",
      "startCol": "24",
      "endLine": "128",
      "endCol": "8"
    },
    "290": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "147",
      "startCol": "24",
      "endLine": "151",
      "endCol": "8"
    },
    "291": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "170",
      "startCol": "24",
      "endLine": "174",
      "endCol": "8"
    },
    "292": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "191",
      "startCol": "24",
      "endLine": "195",
      "endCol": "8"
    },
    "293": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "213",
      "startCol": "24",
      "endLine": "217",
      "endCol": "8"
    },
    "294": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "242",
      "startCol": "24",
      "endLine": "248",
      "endCol": "8"
    },
    "295": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "258",
      "startCol": "24",
      "endLine": "264",
      "endCol": "8"
    },
    "296": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "280",
      "startCol": "24",
      "endLine": "284",
      "endCol": "8"
    },
    "297": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "302",
      "startCol": "24",
      "endLine": "306",
      "endCol": "8"
    },
    "298": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "323",
      "startCol": "24",
      "endLine": "327",
      "endCol": "8"
    },
    "299": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "344",
      "startCol": "24",
      "endLine": "348",
      "endCol": "8"
    },
    "300": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "365",
      "startCol": "24",
      "endLine": "369",
      "endCol": "8"
    },
    "301": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "385",
      "startCol": "24",
      "endLine": "389",
      "endCol": "8"
    },
    "302": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "400",
      "startCol": "24",
      "endLine": "403",
      "endCol": "8"
    },
    "303": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "410",
      "startCol": "24",
      "endLine": "413",
      "endCol": "8"
    },
    "304": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "420",
      "startCol": "24",
      "endLine": "423",
      "endCol": "8"
    },
    "305": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "430",
      "startCol": "24",
      "endLine": "433",
      "endCol": "8"
    },
    "306": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "441",
      "startCol": "24",
      "endLine": "444",
      "endCol": "8"
    },
    "307": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "465",
      "startCol": "24",
      "endLine": "471",
      "endCol": "8"
    },
    "308": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "485",
      "startCol": "24",
      "endLine": "489",
      "endCol": "8"
    },
    "309": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "505",
      "startCol": "24",
      "endLine": "509",
      "endCol": "8"
    },
    "310": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "526",
      "startCol": "24",
      "endLine": "530",
      "endCol": "8"
    },
    "311": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "554",
      "startCol": "7",
      "endLine": "574",
      "endCol": "8"
    },
    "312": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "578",
      "startCol": "37",
      "endLine": "584",
      "endCol": "8"
    },
    "313": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "588",
      "startCol": "43",
      "endLine": "595",
      "endCol": "8"
    },
    "314": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "601",
      "startCol": "43",
      "endLine": "607",
      "endCol": "8"
    },
    "315": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "613",
      "startCol": "37",
      "endLine": "619",
      "endCol": "8"
    },
    "316": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "623",
      "startCol": "43",
      "endLine": "630",
      "endCol": "8"
    },
    "317": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "634",
      "startCol": "7",
      "endLine": "637",
      "endCol": "8"
    },
    "318": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/endpoint.test.e2e.js",
      "startLine": "639",
      "startCol": "40",
      "endLine": "642",
      "endCol": "8"
    },
    "319": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "87",
      "startCol": "5",
      "endLine": "90",
      "endCol": "14"
    },
    "320": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "93",
      "startCol": "10",
      "endLine": "93",
      "endCol": "44"
    },
    "321": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "100",
      "startCol": "5",
      "endLine": "100",
      "endCol": "27"
    },
    "322": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "106",
      "startCol": "21",
      "endLine": "112",
      "endCol": "10"
    },
    "323": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "120",
      "startCol": "21",
      "endLine": "126",
      "endCol": "10"
    },
    "324": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "134",
      "startCol": "21",
      "endLine": "140",
      "endCol": "10"
    },
    "325": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "148",
      "startCol": "21",
      "endLine": "154",
      "endCol": "10"
    },
    "326": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "162",
      "startCol": "21",
      "endLine": "168",
      "endCol": "10"
    },
    "327": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "176",
      "startCol": "21",
      "endLine": "182",
      "endCol": "10"
    },
    "328": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "193",
      "startCol": "21",
      "endLine": "199",
      "endCol": "10"
    },
    "329": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "208",
      "startCol": "22",
      "endLine": "214",
      "endCol": "10"
    },
    "330": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "220",
      "startCol": "22",
      "endLine": "226",
      "endCol": "10"
    },
    "331": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "232",
      "startCol": "21",
      "endLine": "238",
      "endCol": "10"
    },
    "332": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "242",
      "startCol": "22",
      "endLine": "248",
      "endCol": "10"
    },
    "333": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "256",
      "startCol": "21",
      "endLine": "262",
      "endCol": "10"
    },
    "334": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "268",
      "startCol": "22",
      "endLine": "274",
      "endCol": "10"
    },
    "335": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "280",
      "startCol": "21",
      "endLine": "286",
      "endCol": "10"
    },
    "336": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "290",
      "startCol": "22",
      "endLine": "296",
      "endCol": "10"
    },
    "337": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "305",
      "startCol": "21",
      "endLine": "311",
      "endCol": "10"
    },
    "338": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "317",
      "startCol": "21",
      "endLine": "323",
      "endCol": "10"
    },
    "339": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "332",
      "startCol": "21",
      "endLine": "338",
      "endCol": "10"
    },
    "340": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "344",
      "startCol": "21",
      "endLine": "350",
      "endCol": "10"
    },
    "341": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "358",
      "startCol": "21",
      "endLine": "364",
      "endCol": "10"
    },
    "342": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "370",
      "startCol": "21",
      "endLine": "376",
      "endCol": "10"
    },
    "343": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "382",
      "startCol": "21",
      "endLine": "388",
      "endCol": "10"
    },
    "344": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "396",
      "startCol": "21",
      "endLine": "402",
      "endCol": "10"
    },
    "345": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "408",
      "startCol": "21",
      "endLine": "414",
      "endCol": "10"
    },
    "346": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "420",
      "startCol": "21",
      "endLine": "426",
      "endCol": "10"
    },
    "347": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "434",
      "startCol": "21",
      "endLine": "440",
      "endCol": "10"
    },
    "348": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "444",
      "startCol": "22",
      "endLine": "450",
      "endCol": "10"
    },
    "349": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "456",
      "startCol": "21",
      "endLine": "462",
      "endCol": "10"
    },
    "350": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "468",
      "startCol": "21",
      "endLine": "474",
      "endCol": "10"
    },
    "351": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "480",
      "startCol": "21",
      "endLine": "486",
      "endCol": "10"
    },
    "352": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "492",
      "startCol": "21",
      "endLine": "498",
      "endCol": "10"
    },
    "353": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "506",
      "startCol": "21",
      "endLine": "512",
      "endCol": "10"
    },
    "354": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "516",
      "startCol": "22",
      "endLine": "522",
      "endCol": "10"
    },
    "355": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "528",
      "startCol": "21",
      "endLine": "534",
      "endCol": "10"
    },
    "356": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "540",
      "startCol": "21",
      "endLine": "546",
      "endCol": "10"
    },
    "357": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "552",
      "startCol": "21",
      "endLine": "558",
      "endCol": "10"
    },
    "358": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "564",
      "startCol": "21",
      "endLine": "570",
      "endCol": "10"
    },
    "359": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "578",
      "startCol": "21",
      "endLine": "584",
      "endCol": "10"
    },
    "360": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "588",
      "startCol": "22",
      "endLine": "594",
      "endCol": "10"
    },
    "361": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "600",
      "startCol": "21",
      "endLine": "606",
      "endCol": "10"
    },
    "362": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "612",
      "startCol": "21",
      "endLine": "618",
      "endCol": "10"
    },
    "363": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "624",
      "startCol": "21",
      "endLine": "630",
      "endCol": "10"
    },
    "364": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "636",
      "startCol": "21",
      "endLine": "642",
      "endCol": "10"
    },
    "365": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "650",
      "startCol": "21",
      "endLine": "656",
      "endCol": "10"
    },
    "366": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "660",
      "startCol": "22",
      "endLine": "666",
      "endCol": "10"
    },
    "367": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "672",
      "startCol": "21",
      "endLine": "678",
      "endCol": "10"
    },
    "368": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "684",
      "startCol": "21",
      "endLine": "690",
      "endCol": "10"
    },
    "369": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "696",
      "startCol": "21",
      "endLine": "702",
      "endCol": "10"
    },
    "370": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "708",
      "startCol": "21",
      "endLine": "714",
      "endCol": "10"
    },
    "371": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "724",
      "startCol": "21",
      "endLine": "739",
      "endCol": "10"
    },
    "372": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "745",
      "startCol": "21",
      "endLine": "760",
      "endCol": "10"
    },
    "373": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "768",
      "startCol": "21",
      "endLine": "788",
      "endCol": "10"
    },
    "374": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "794",
      "startCol": "21",
      "endLine": "818",
      "endCol": "10"
    },
    "375": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "825",
      "startCol": "19",
      "endLine": "831",
      "endCol": "8"
    },
    "376": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "837",
      "startCol": "19",
      "endLine": "843",
      "endCol": "8"
    },
    "377": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "849",
      "startCol": "19",
      "endLine": "855",
      "endCol": "8"
    },
    "378": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "861",
      "startCol": "19",
      "endLine": "867",
      "endCol": "8"
    },
    "379": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "873",
      "startCol": "19",
      "endLine": "879",
      "endCol": "8"
    },
    "380": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "885",
      "startCol": "19",
      "endLine": "891",
      "endCol": "8"
    },
    "381": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "897",
      "startCol": "19",
      "endLine": "903",
      "endCol": "8"
    },
    "382": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "909",
      "startCol": "19",
      "endLine": "915",
      "endCol": "8"
    },
    "383": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "921",
      "startCol": "19",
      "endLine": "927",
      "endCol": "8"
    },
    "384": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "933",
      "startCol": "19",
      "endLine": "939",
      "endCol": "8"
    },
    "385": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "947",
      "startCol": "17",
      "endLine": "954",
      "endCol": "8"
    },
    "386": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "958",
      "startCol": "13",
      "endLine": "965",
      "endCol": "8"
    },
    "387": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "969",
      "startCol": "13",
      "endLine": "976",
      "endCol": "8"
    },
    "388": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "982",
      "startCol": "17",
      "endLine": "989",
      "endCol": "8"
    },
    "389": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "993",
      "startCol": "13",
      "endLine": "1000",
      "endCol": "8"
    },
    "390": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1005",
      "startCol": "13",
      "endLine": "1012",
      "endCol": "8"
    },
    "391": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1018",
      "startCol": "17",
      "endLine": "1025",
      "endCol": "8"
    },
    "392": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1033",
      "startCol": "19",
      "endLine": "1039",
      "endCol": "8"
    },
    "393": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1047",
      "startCol": "19",
      "endLine": "1053",
      "endCol": "8"
    },
    "394": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1059",
      "startCol": "20",
      "endLine": "1065",
      "endCol": "8"
    },
    "395": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1073",
      "startCol": "19",
      "endLine": "1079",
      "endCol": "8"
    },
    "396": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1089",
      "startCol": "19",
      "endLine": "1095",
      "endCol": "8"
    },
    "397": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1101",
      "startCol": "19",
      "endLine": "1108",
      "endCol": "8"
    },
    "398": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1114",
      "startCol": "19",
      "endLine": "1120",
      "endCol": "8"
    },
    "399": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1126",
      "startCol": "19",
      "endLine": "1133",
      "endCol": "8"
    },
    "400": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1141",
      "startCol": "19",
      "endLine": "1147",
      "endCol": "8"
    },
    "401": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1153",
      "startCol": "19",
      "endLine": "1159",
      "endCol": "8"
    },
    "402": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/filtering.test.e2e.js",
      "startLine": "1165",
      "startCol": "19",
      "endLine": "1171",
      "endCol": "8"
    },
    "403": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "136",
      "startCol": "5",
      "endLine": "154",
      "endCol": "14"
    },
    "404": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "157",
      "startCol": "10",
      "endLine": "157",
      "endCol": "44"
    },
    "405": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "164",
      "startCol": "5",
      "endLine": "164",
      "endCol": "27"
    },
    "406": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "173",
      "startCol": "21",
      "endLine": "173",
      "endCol": "74"
    },
    "407": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "179",
      "startCol": "21",
      "endLine": "179",
      "endCol": "80"
    },
    "408": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/publication-state.test.e2e.js",
      "startLine": "192",
      "startCol": "21",
      "endLine": "195",
      "endCol": "10"
    },
    "409": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "124",
      "startCol": "5",
      "endLine": "127",
      "endCol": "14"
    },
    "410": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "130",
      "startCol": "10",
      "endLine": "130",
      "endCol": "44"
    },
    "411": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "137",
      "startCol": "5",
      "endLine": "137",
      "endCol": "27"
    },
    "412": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "142",
      "startCol": "19",
      "endLine": "148",
      "endCol": "8"
    },
    "413": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "156",
      "startCol": "19",
      "endLine": "162",
      "endCol": "8"
    },
    "414": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "170",
      "startCol": "19",
      "endLine": "176",
      "endCol": "8"
    },
    "415": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "184",
      "startCol": "19",
      "endLine": "190",
      "endCol": "8"
    },
    "416": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "200",
      "startCol": "19",
      "endLine": "207",
      "endCol": "8"
    },
    "417": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "214",
      "startCol": "19",
      "endLine": "221",
      "endCol": "8"
    },
    "418": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "228",
      "startCol": "19",
      "endLine": "231",
      "endCol": "8"
    },
    "419": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/search.test.e2e.js",
      "startLine": "238",
      "startCol": "19",
      "endLine": "245",
      "endCol": "8"
    },
    "420": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "26",
      "startCol": "5",
      "endLine": "26",
      "endCol": "47"
    },
    "421": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "29",
      "startCol": "10",
      "endLine": "29",
      "endCol": "44"
    },
    "422": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "34",
      "startCol": "5",
      "endLine": "34",
      "endCol": "27"
    },
    "423": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "38",
      "startCol": "17",
      "endLine": "41",
      "endCol": "6"
    },
    "424": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "47",
      "startCol": "17",
      "endLine": "53",
      "endCol": "6"
    },
    "425": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "65",
      "startCol": "17",
      "endLine": "71",
      "endCol": "6"
    },
    "426": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "81",
      "startCol": "17",
      "endLine": "84",
      "endCol": "6"
    },
    "427": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "94",
      "startCol": "17",
      "endLine": "97",
      "endCol": "6"
    },
    "428": {
      "patternID": "pattern3",
      "file": "packages/strapi/tests/single-type.test.e2e.js",
      "startLine": "105",
      "startCol": "20",
      "endLine": "108",
      "endCol": "6"
    },
    "429": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/components/Users/ModalCreateBody/index.js",
      "startLine": "54",
      "startCol": "28",
      "endLine": "57",
      "endCol": "12"
    },
    "430": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Admin/index.js",
      "startLine": "101",
      "startCol": "9",
      "endLine": "107",
      "endCol": "10"
    },
    "431": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Admin/index.js",
      "startLine": "116",
      "startCol": "24",
      "endLine": "116",
      "endCol": "77"
    },
    "432": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Admin/index.js",
      "startLine": "138",
      "startCol": "11",
      "endLine": "138",
      "endCol": "87"
    },
    "433": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Admin/index.js",
      "startLine": "177",
      "startCol": "24",
      "endLine": "177",
      "endCol": "86"
    },
    "434": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/App/index.js",
      "startLine": "44",
      "startCol": "13",
      "endLine": "47",
      "endCol": "10"
    },
    "435": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/App/index.js",
      "startLine": "64",
      "startCol": "26",
      "endLine": "64",
      "endCol": "72"
    },
    "436": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/AuthPage/index.js",
      "startLine": "58",
      "startCol": "15",
      "endLine": "60",
      "endCol": "11"
    },
    "437": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/AuthPage/index.js",
      "startLine": "134",
      "startCol": "7",
      "endLine": "139",
      "endCol": "8"
    },
    "438": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/AuthPage/index.js",
      "startLine": "158",
      "startCol": "11",
      "endLine": "163",
      "endCol": "8"
    },
    "439": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/AuthPage/index.js",
      "startLine": "199",
      "startCol": "11",
      "endLine": "204",
      "endCol": "8"
    },
    "440": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/AuthPage/index.js",
      "startLine": "243",
      "startCol": "11",
      "endLine": "248",
      "endCol": "8"
    },
    "441": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/HomePage/hooks.js",
      "startLine": "18",
      "startCol": "26",
      "endLine": "23",
      "endCol": "9"
    },
    "442": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/InstalledPluginsPage/index.js",
      "startLine": "23",
      "startCol": "24",
      "endLine": "23",
      "endCol": "92"
    },
    "443": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "78",
      "startCol": "27",
      "endLine": "78",
      "endCol": "79"
    },
    "444": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "90",
      "startCol": "24",
      "endLine": "90",
      "endCol": "67"
    },
    "445": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "97",
      "startCol": "45",
      "endLine": "99",
      "endCol": "7"
    },
    "446": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "104",
      "startCol": "41",
      "endLine": "104",
      "endCol": "97"
    },
    "447": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "141",
      "startCol": "37",
      "endLine": "141",
      "endCol": "89"
    },
    "448": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/LeftMenu/index.js",
      "startLine": "142",
      "startCol": "37",
      "endLine": "142",
      "endCol": "89"
    },
    "449": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/MarketplacePage/index.js",
      "startLine": "38",
      "startCol": "24",
      "endLine": "38",
      "endCol": "90"
    },
    "450": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Onboarding/index.js",
      "startLine": "25",
      "startCol": "26",
      "endLine": "27",
      "endCol": "10"
    },
    "451": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Roles/EditPage/index.js",
      "startLine": "87",
      "startCol": "7",
      "endLine": "90",
      "endCol": "8"
    },
    "452": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Roles/EditPage/index.js",
      "startLine": "93",
      "startCol": "9",
      "endLine": "98",
      "endCol": "10"
    },
    "453": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Users/ListPage/index.js",
      "startLine": "72",
      "startCol": "11",
      "endLine": "72",
      "endCol": "67"
    },
    "454": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Users/ListPage/index.js",
      "startLine": "178",
      "startCol": "7",
      "endLine": "183",
      "endCol": "8"
    },
    "455": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js",
      "startLine": "57",
      "startCol": "26",
      "endLine": "59",
      "endCol": "10"
    },
    "456": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js",
      "startLine": "168",
      "startCol": "7",
      "endLine": "168",
      "endCol": "64"
    },
    "457": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js",
      "startLine": "195",
      "startCol": "24",
      "endLine": "198",
      "endCol": "8"
    },
    "458": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js",
      "startLine": "261",
      "startCol": "24",
      "endLine": "264",
      "endCol": "8"
    },
    "459": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js",
      "startLine": "363",
      "startCol": "7",
      "endLine": "366",
      "endCol": "8"
    },
    "460": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/ListView/index.js",
      "startLine": "127",
      "startCol": "24",
      "endLine": "129",
      "endCol": "8"
    },
    "461": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/ListView/index.js",
      "startLine": "167",
      "startCol": "7",
      "endLine": "169",
      "endCol": "8"
    },
    "462": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/ListView/index.js",
      "startLine": "192",
      "startCol": "7",
      "endLine": "195",
      "endCol": "8"
    },
    "463": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/containers/Webhooks/ListView/index.js",
      "startLine": "244",
      "startCol": "7",
      "endLine": "247",
      "endCol": "8"
    },
    "464": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchPermissionsLayout/index.js",
      "startLine": "15",
      "startCol": "24",
      "endLine": "15",
      "endCol": "77"
    },
    "465": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/index.js",
      "startLine": "19",
      "startCol": "26",
      "endLine": "22",
      "endCol": "10"
    },
    "466": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/tests/useFetchPluginsFromMarketPlace.test.js",
      "startLine": "18",
      "startCol": "5",
      "endLine": "18",
      "endCol": "29"
    },
    "467": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/tests/useFetchPluginsFromMarketPlace.test.js",
      "startLine": "38",
      "startCol": "5",
      "endLine": "38",
      "endCol": "29"
    },
    "468": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useFetchRole/index.js",
      "startLine": "26",
      "startCol": "55",
      "endLine": "30",
      "endCol": "7"
    },
    "469": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useModels/index.js",
      "startLine": "19",
      "startCol": "62",
      "endLine": "23",
      "endCol": "7"
    },
    "470": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useRolesList/index.js",
      "startLine": "24",
      "startCol": "24",
      "endLine": "24",
      "endCol": "71"
    },
    "471": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useSettingsMenu/index.js",
      "startLine": "18",
      "startCol": "31",
      "endLine": "18",
      "endCol": "83"
    },
    "472": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useSettingsMenu/index.js",
      "startLine": "36",
      "startCol": "20",
      "endLine": "36",
      "endCol": "72"
    },
    "473": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useUsersForm/index.js",
      "startLine": "17",
      "startCol": "26",
      "endLine": "17",
      "endCol": "67"
    },
    "474": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/hooks/useUsersForm/index.js",
      "startLine": "77",
      "startCol": "26",
      "endLine": "80",
      "endCol": "10"
    },
    "475": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/admin/src/utils/checkFormValidity.js",
      "startLine": "7",
      "startCol": "5",
      "endLine": "7",
      "endCol": "54"
    },
    "476": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "19",
      "startCol": "3",
      "endLine": "19",
      "endCol": "68"
    },
    "477": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "20",
      "startCol": "3",
      "endLine": "20",
      "endCol": "75"
    },
    "478": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "21",
      "startCol": "3",
      "endLine": "21",
      "endCol": "49"
    },
    "479": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "22",
      "startCol": "3",
      "endLine": "22",
      "endCol": "59"
    },
    "480": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "23",
      "startCol": "3",
      "endLine": "23",
      "endCol": "63"
    },
    "481": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "24",
      "startCol": "3",
      "endLine": "24",
      "endCol": "65"
    },
    "482": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/config/functions/bootstrap.js",
      "startLine": "25",
      "startCol": "3",
      "endLine": "25",
      "endCol": "70"
    },
    "483": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "50",
      "startCol": "22",
      "endLine": "50",
      "endCol": "61"
    },
    "484": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "56",
      "startCol": "21",
      "endLine": "56",
      "endCol": "61"
    },
    "485": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "69",
      "startCol": "7",
      "endLine": "72",
      "endCol": "8"
    },
    "486": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "79",
      "startCol": "21",
      "endLine": "79",
      "endCol": "65"
    },
    "487": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "91",
      "startCol": "7",
      "endLine": "94",
      "endCol": "8"
    },
    "488": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "101",
      "startCol": "21",
      "endLine": "101",
      "endCol": "61"
    },
    "489": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "107",
      "startCol": "28",
      "endLine": "110",
      "endCol": "6"
    },
    "490": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "123",
      "startCol": "21",
      "endLine": "123",
      "endCol": "61"
    },
    "491": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "129",
      "startCol": "5",
      "endLine": "129",
      "endCol": "47"
    },
    "492": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "144",
      "startCol": "23",
      "endLine": "144",
      "endCol": "63"
    },
    "493": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "148",
      "startCol": "7",
      "endLine": "148",
      "endCol": "49"
    },
    "494": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "158",
      "startCol": "21",
      "endLine": "158",
      "endCol": "61"
    },
    "495": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/Webhooks.js",
      "startLine": "160",
      "startCol": "22",
      "endLine": "160",
      "endCol": "80"
    },
    "496": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/admin.js",
      "startLine": "22",
      "startCol": "22",
      "endLine": "22",
      "endCol": "62"
    },
    "497": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/admin.js",
      "startLine": "50",
      "startCol": "7",
      "endLine": "50",
      "endCol": "68"
    },
    "498": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/admin.js",
      "startLine": "90",
      "startCol": "7",
      "endLine": "90",
      "endCol": "76"
    },
    "499": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authenticated-user.js",
      "startLine": "18",
      "startCol": "7",
      "endLine": "18",
      "endCol": "45"
    },
    "500": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authenticated-user.js",
      "startLine": "23",
      "startCol": "25",
      "endLine": "23",
      "endCol": "93"
    },
    "501": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authenticated-user.js",
      "startLine": "33",
      "startCol": "29",
      "endLine": "33",
      "endCol": "69"
    },
    "502": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "64",
      "startCol": "7",
      "endLine": "64",
      "endCol": "60"
    },
    "503": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "71",
      "startCol": "30",
      "endLine": "73",
      "endCol": "5"
    },
    "504": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "86",
      "startCol": "7",
      "endLine": "86",
      "endCol": "44"
    },
    "505": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "91",
      "startCol": "18",
      "endLine": "91",
      "endCol": "65"
    },
    "506": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "105",
      "startCol": "7",
      "endLine": "105",
      "endCol": "49"
    },
    "507": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "110",
      "startCol": "22",
      "endLine": "110",
      "endCol": "62"
    },
    "508": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "116",
      "startCol": "28",
      "endLine": "116",
      "endCol": "75"
    },
    "509": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "124",
      "startCol": "18",
      "endLine": "129",
      "endCol": "6"
    },
    "510": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "131",
      "startCol": "5",
      "endLine": "131",
      "endCol": "54"
    },
    "511": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "145",
      "startCol": "7",
      "endLine": "145",
      "endCol": "46"
    },
    "512": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "159",
      "startCol": "7",
      "endLine": "159",
      "endCol": "45"
    },
    "513": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/authentication.js",
      "startLine": "164",
      "startCol": "18",
      "endLine": "164",
      "endCol": "70"
    },
    "514": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/permission.js",
      "startLine": "15",
      "startCol": "7",
      "endLine": "15",
      "endCol": "48"
    },
    "515": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "15",
      "startCol": "18",
      "endLine": "15",
      "endCol": "79"
    },
    "516": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "31",
      "startCol": "19",
      "endLine": "31",
      "endCol": "74"
    },
    "517": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "46",
      "startCol": "7",
      "endLine": "46",
      "endCol": "53"
    },
    "518": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "51",
      "startCol": "18",
      "endLine": "51",
      "endCol": "65"
    },
    "519": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "60",
      "startCol": "25",
      "endLine": "60",
      "endCol": "89"
    },
    "520": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "76",
      "startCol": "18",
      "endLine": "76",
      "endCol": "65"
    },
    "521": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "82",
      "startCol": "25",
      "endLine": "82",
      "endCol": "98"
    },
    "522": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "100",
      "startCol": "18",
      "endLine": "100",
      "endCol": "65"
    },
    "523": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/role.js",
      "startLine": "132",
      "startCol": "25",
      "endLine": "135",
      "endCol": "5"
    },
    "524": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "15",
      "startCol": "7",
      "endLine": "15",
      "endCol": "43"
    },
    "525": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "22",
      "startCol": "31",
      "endLine": "24",
      "endCol": "6"
    },
    "526": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "30",
      "startCol": "25",
      "endLine": "30",
      "endCol": "75"
    },
    "527": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "41",
      "startCol": "37",
      "endLine": "41",
      "endCol": "87"
    },
    "528": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "54",
      "startCol": "18",
      "endLine": "54",
      "endCol": "65"
    },
    "529": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "70",
      "startCol": "7",
      "endLine": "70",
      "endCol": "42"
    },
    "530": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "76",
      "startCol": "32",
      "endLine": "79",
      "endCol": "8"
    },
    "531": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "86",
      "startCol": "25",
      "endLine": "86",
      "endCol": "78"
    },
    "532": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "100",
      "startCol": "25",
      "endLine": "100",
      "endCol": "71"
    },
    "533": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/controllers/user.js",
      "startLine": "123",
      "startCol": "19",
      "endLine": "123",
      "endCol": "72"
    },
    "534": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/admin/containers/Roles/CreatePage/index.js",
      "startLine": "88",
      "startCol": "11",
      "endLine": "91",
      "endCol": "12"
    },
    "535": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/admin/containers/Roles/ListPage/index.js",
      "startLine": "96",
      "startCol": "9",
      "endLine": "101",
      "endCol": "10"
    },
    "536": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "24",
      "startCol": "16",
      "endLine": "24",
      "endCol": "72"
    },
    "537": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "43",
      "startCol": "19",
      "endLine": "43",
      "endCol": "68"
    },
    "538": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "64",
      "startCol": "19",
      "endLine": "64",
      "endCol": "72"
    },
    "539": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "80",
      "startCol": "18",
      "endLine": "80",
      "endCol": "65"
    },
    "540": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "90",
      "startCol": "7",
      "endLine": "90",
      "endCol": "50"
    },
    "541": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/controllers/role.js",
      "startLine": "99",
      "startCol": "25",
      "endLine": "102",
      "endCol": "5"
    },
    "542": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/validation/role.js",
      "startLine": "27",
      "startCol": "32",
      "endLine": "27",
      "endCol": "79"
    },
    "543": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/ee/validation/role.js",
      "startLine": "37",
      "startCol": "28",
      "endLine": "37",
      "endCol": "75"
    },
    "544": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "145",
      "startCol": "3",
      "endLine": "145",
      "endCol": "21"
    },
    "545": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "148",
      "startCol": "7",
      "endLine": "148",
      "endCol": "71"
    },
    "546": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "149",
      "startCol": "5",
      "endLine": "149",
      "endCol": "45"
    },
    "547": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "150",
      "startCol": "5",
      "endLine": "150",
      "endCol": "37"
    },
    "548": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "153",
      "startCol": "3",
      "endLine": "153",
      "endCol": "28"
    },
    "549": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "160",
      "startCol": "3",
      "endLine": "160",
      "endCol": "90"
    },
    "550": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "162",
      "startCol": "3",
      "endLine": "162",
      "endCol": "50"
    },
    "551": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "163",
      "startCol": "3",
      "endLine": "163",
      "endCol": "78"
    },
    "552": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "164",
      "startCol": "3",
      "endLine": "167",
      "endCol": "3"
    },
    "553": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "170",
      "startCol": "3",
      "endLine": "170",
      "endCol": "92"
    },
    "554": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "174",
      "startCol": "3",
      "endLine": "174",
      "endCol": "49"
    },
    "555": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "200",
      "startCol": "3",
      "endLine": "200",
      "endCol": "29"
    },
    "556": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "206",
      "startCol": "3",
      "endLine": "206",
      "endCol": "74"
    },
    "557": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "227",
      "startCol": "3",
      "endLine": "234",
      "endCol": "3"
    },
    "558": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "335",
      "startCol": "11",
      "endLine": "338",
      "endCol": "11"
    },
    "559": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/index.js",
      "startLine": "361",
      "startCol": "9",
      "endLine": "361",
      "endCol": "66"
    },
    "560": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/middlewares/auth/index.js",
      "startLine": "39",
      "startCol": "25",
      "endLine": "39",
      "endCol": "98"
    },
    "561": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/middlewares/auth/index.js",
      "startLine": "47",
      "startCol": "35",
      "endLine": "49",
      "endCol": "11"
    },
    "562": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/action-provider.test.js",
      "startLine": "32",
      "startCol": "7",
      "endLine": "32",
      "endCol": "56"
    },
    "563": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/action-provider.test.js",
      "startLine": "42",
      "startCol": "7",
      "endLine": "42",
      "endCol": "58"
    },
    "564": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/action-provider.test.js",
      "startLine": "75",
      "startCol": "7",
      "endLine": "75",
      "endCol": "52"
    },
    "565": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "startLine": "37",
      "startCol": "19",
      "endLine": "37",
      "endCol": "53"
    },
    "566": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "startLine": "62",
      "startCol": "19",
      "endLine": "62",
      "endCol": "53"
    },
    "567": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "startLine": "87",
      "startCol": "19",
      "endLine": "87",
      "endCol": "53"
    },
    "568": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "startLine": "109",
      "startCol": "20",
      "endLine": "109",
      "endCol": "47"
    },
    "569": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/auth.test.js",
      "startLine": "111",
      "startCol": "23",
      "endLine": "111",
      "endCol": "60"
    },
    "570": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permission.test.js",
      "startLine": "16",
      "startCol": "7",
      "endLine": "16",
      "endCol": "47"
    },
    "571": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "152",
      "startCol": "23",
      "endLine": "152",
      "endCol": "60"
    },
    "572": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "187",
      "startCol": "23",
      "endLine": "187",
      "endCol": "60"
    },
    "573": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "217",
      "startCol": "23",
      "endLine": "217",
      "endCol": "60"
    },
    "574": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "229",
      "startCol": "19",
      "endLine": "229",
      "endCol": "56"
    },
    "575": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "257",
      "startCol": "23",
      "endLine": "257",
      "endCol": "46"
    },
    "576": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "271",
      "startCol": "7",
      "endLine": "271",
      "endCol": "71"
    },
    "577": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "286",
      "startCol": "7",
      "endLine": "286",
      "endCol": "71"
    },
    "578": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "306",
      "startCol": "7",
      "endLine": "306",
      "endCol": "71"
    },
    "579": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/permissions.engine.test.js",
      "startLine": "321",
      "startCol": "7",
      "endLine": "321",
      "endCol": "71"
    },
    "580": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "startLine": "42",
      "startCol": "25",
      "endLine": "42",
      "endCol": "66"
    },
    "581": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/role.test.js",
      "startLine": "84",
      "startCol": "26",
      "endLine": "84",
      "endCol": "49"
    },
    "582": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/user.test.js",
      "startLine": "765",
      "startCol": "7",
      "endLine": "767",
      "endCol": "7"
    },
    "583": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/__tests__/user.test.js",
      "startLine": "787",
      "startCol": "9",
      "endLine": "791",
      "endCol": "9"
    },
    "584": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/auth.js",
      "startLine": "29",
      "startCol": "16",
      "endLine": "29",
      "endCol": "69"
    },
    "585": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/auth.js",
      "startLine": "35",
      "startCol": "19",
      "endLine": "35",
      "endCol": "65"
    },
    "586": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/auth.js",
      "startLine": "54",
      "startCol": "16",
      "endLine": "54",
      "endCol": "85"
    },
    "587": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/auth.js",
      "startLine": "61",
      "startCol": "3",
      "endLine": "61",
      "endCol": "78"
    },
    "588": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/auth.js",
      "startLine": "93",
      "startCol": "24",
      "endLine": "95",
      "endCol": "52"
    },
    "589": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/metrics.js",
      "startLine": "4",
      "startCol": "25",
      "endLine": "4",
      "endCol": "64"
    },
    "590": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/metrics.js",
      "startLine": "5",
      "startCol": "25",
      "endLine": "5",
      "endCol": "64"
    },
    "591": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission/engine.js",
      "startLine": "35",
      "startCol": "25",
      "endLine": "35",
      "endCol": "88"
    },
    "592": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission/engine.js",
      "startLine": "108",
      "startCol": "5",
      "endLine": "115",
      "endCol": "28"
    },
    "593": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission.js",
      "startLine": "100",
      "startCol": "17",
      "endLine": "100",
      "endCol": "90"
    },
    "594": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission.js",
      "startLine": "133",
      "startCol": "5",
      "endLine": "139",
      "endCol": "6"
    },
    "595": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission.js",
      "startLine": "149",
      "startCol": "22",
      "endLine": "149",
      "endCol": "91"
    },
    "596": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/permission.js",
      "startLine": "157",
      "startCol": "25",
      "endLine": "164",
      "endCol": "5"
    },
    "597": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "75",
      "startCol": "16",
      "endLine": "75",
      "endCol": "76"
    },
    "598": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "99",
      "startCol": "17",
      "endLine": "99",
      "endCol": "82"
    },
    "599": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "139",
      "startCol": "22",
      "endLine": "139",
      "endCol": "70"
    },
    "600": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "159",
      "startCol": "26",
      "endLine": "159",
      "endCol": "46"
    },
    "601": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "175",
      "startCol": "3",
      "endLine": "175",
      "endCol": "62"
    },
    "602": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "177",
      "startCol": "22",
      "endLine": "177",
      "endCol": "79"
    },
    "603": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "223",
      "startCol": "3",
      "endLine": "223",
      "endCol": "70"
    },
    "604": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "276",
      "startCol": "27",
      "endLine": "276",
      "endCol": "67"
    },
    "605": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "291",
      "startCol": "5",
      "endLine": "291",
      "endCol": "47"
    },
    "606": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "296",
      "startCol": "22",
      "endLine": "296",
      "endCol": "69"
    },
    "607": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "307",
      "startCol": "31",
      "endLine": "310",
      "endCol": "4"
    },
    "608": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "324",
      "startCol": "5",
      "endLine": "324",
      "endCol": "90"
    },
    "609": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "333",
      "startCol": "5",
      "endLine": "333",
      "endCol": "70"
    },
    "610": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/role.js",
      "startLine": "350",
      "startCol": "26",
      "endLine": "350",
      "endCol": "73"
    },
    "611": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "34",
      "startCol": "25",
      "endLine": "34",
      "endCol": "90"
    },
    "612": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "38",
      "startCol": "23",
      "endLine": "38",
      "endCol": "70"
    },
    "613": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "40",
      "startCol": "3",
      "endLine": "40",
      "endCol": "57"
    },
    "614": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "55",
      "startCol": "28",
      "endLine": "55",
      "endCol": "89"
    },
    "615": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "79",
      "startCol": "28",
      "endLine": "79",
      "endCol": "93"
    },
    "616": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "106",
      "startCol": "5",
      "endLine": "106",
      "endCol": "46"
    },
    "617": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "122",
      "startCol": "26",
      "endLine": "122",
      "endCol": "87"
    },
    "618": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "133",
      "startCol": "11",
      "endLine": "133",
      "endCol": "63"
    },
    "619": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "142",
      "startCol": "16",
      "endLine": "142",
      "endCol": "81"
    },
    "620": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "158",
      "startCol": "24",
      "endLine": "158",
      "endCol": "89"
    },
    "621": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "202",
      "startCol": "24",
      "endLine": "202",
      "endCol": "85"
    },
    "622": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "205",
      "startCol": "30",
      "endLine": "205",
      "endCol": "91"
    },
    "623": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "226",
      "startCol": "26",
      "endLine": "226",
      "endCol": "87"
    },
    "624": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "227",
      "startCol": "34",
      "endLine": "229",
      "endCol": "54"
    },
    "625": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "248",
      "startCol": "13",
      "endLine": "248",
      "endCol": "75"
    },
    "626": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "250",
      "startCol": "13",
      "endLine": "252",
      "endCol": "6"
    },
    "627": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "254",
      "startCol": "22",
      "endLine": "254",
      "endCol": "77"
    },
    "628": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "255",
      "startCol": "13",
      "endLine": "257",
      "endCol": "6"
    },
    "629": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "282",
      "startCol": "22",
      "endLine": "287",
      "endCol": "31"
    },
    "630": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "291",
      "startCol": "7",
      "endLine": "291",
      "endCol": "54"
    },
    "631": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "294",
      "startCol": "5",
      "endLine": "294",
      "endCol": "81"
    },
    "632": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "310",
      "startCol": "26",
      "endLine": "310",
      "endCol": "66"
    },
    "633": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "318",
      "startCol": "5",
      "endLine": "320",
      "endCol": "82"
    },
    "634": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "321",
      "startCol": "5",
      "endLine": "323",
      "endCol": "83"
    },
    "635": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "325",
      "startCol": "5",
      "endLine": "325",
      "endCol": "87"
    },
    "636": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/services/user.js",
      "startLine": "326",
      "startCol": "5",
      "endLine": "326",
      "endCol": "70"
    },
    "637": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "21",
      "startCol": "10",
      "endLine": "21",
      "endCol": "44"
    },
    "638": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "25",
      "startCol": "24",
      "endLine": "28",
      "endCol": "8"
    },
    "639": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "30",
      "startCol": "24",
      "endLine": "30",
      "endCol": "54"
    },
    "640": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "36",
      "startCol": "7",
      "endLine": "36",
      "endCol": "54"
    },
    "641": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "44",
      "startCol": "19",
      "endLine": "48",
      "endCol": "8"
    },
    "642": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "64",
      "startCol": "19",
      "endLine": "71",
      "endCol": "8"
    },
    "643": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "82",
      "startCol": "19",
      "endLine": "89",
      "endCol": "8"
    },
    "644": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "100",
      "startCol": "19",
      "endLine": "106",
      "endCol": "8"
    },
    "645": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "119",
      "startCol": "23",
      "endLine": "123",
      "endCol": "8"
    },
    "646": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "128",
      "startCol": "19",
      "endLine": "134",
      "endCol": "8"
    },
    "647": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "143",
      "startCol": "19",
      "endLine": "149",
      "endCol": "8"
    },
    "648": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "160",
      "startCol": "19",
      "endLine": "164",
      "endCol": "8"
    },
    "649": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "189",
      "startCol": "14",
      "endLine": "189",
      "endCol": "45"
    },
    "650": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "193",
      "startCol": "7",
      "endLine": "193",
      "endCol": "41"
    },
    "651": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "197",
      "startCol": "19",
      "endLine": "201",
      "endCol": "8"
    },
    "652": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "214",
      "startCol": "19",
      "endLine": "218",
      "endCol": "8"
    },
    "653": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "232",
      "startCol": "19",
      "endLine": "236",
      "endCol": "8"
    },
    "654": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "258",
      "startCol": "14",
      "endLine": "258",
      "endCol": "45"
    },
    "655": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "262",
      "startCol": "7",
      "endLine": "262",
      "endCol": "41"
    },
    "656": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "266",
      "startCol": "19",
      "endLine": "272",
      "endCol": "8"
    },
    "657": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "290",
      "startCol": "19",
      "endLine": "301",
      "endCol": "8"
    },
    "658": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "321",
      "startCol": "19",
      "endLine": "328",
      "endCol": "8"
    },
    "659": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "346",
      "startCol": "19",
      "endLine": "350",
      "endCol": "8"
    },
    "660": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "367",
      "startCol": "19",
      "endLine": "376",
      "endCol": "8"
    },
    "661": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "397",
      "startCol": "19",
      "endLine": "401",
      "endCol": "8"
    },
    "662": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "414",
      "startCol": "19",
      "endLine": "420",
      "endCol": "8"
    },
    "663": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-auth.test.e2e.js",
      "startLine": "425",
      "startCol": "30",
      "endLine": "431",
      "endCol": "8"
    },
    "664": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "13",
      "startCol": "10",
      "endLine": "13",
      "endCol": "44"
    },
    "665": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "22",
      "startCol": "19",
      "endLine": "26",
      "endCol": "8"
    },
    "666": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "41",
      "startCol": "19",
      "endLine": "45",
      "endCol": "8"
    },
    "667": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "54",
      "startCol": "19",
      "endLine": "58",
      "endCol": "8"
    },
    "668": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "64",
      "startCol": "19",
      "endLine": "70",
      "endCol": "8"
    },
    "669": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "81",
      "startCol": "19",
      "endLine": "87",
      "endCol": "8"
    },
    "670": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "98",
      "startCol": "19",
      "endLine": "104",
      "endCol": "8"
    },
    "671": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js",
      "startLine": "120",
      "startCol": "19",
      "endLine": "124",
      "endCol": "8"
    },
    "672": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permission.test.e2e.js",
      "startLine": "14",
      "startCol": "10",
      "endLine": "14",
      "endCol": "44"
    },
    "673": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permission.test.e2e.js",
      "startLine": "22",
      "startCol": "15",
      "endLine": "25",
      "endCol": "6"
    },
    "674": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "72",
      "startCol": "24",
      "endLine": "72",
      "endCol": "58"
    },
    "675": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "76",
      "startCol": "20",
      "endLine": "76",
      "endCol": "61"
    },
    "676": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "79",
      "startCol": "27",
      "endLine": "79",
      "endCol": "97"
    },
    "677": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "93",
      "startCol": "29",
      "endLine": "93",
      "endCol": "66"
    },
    "678": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "95",
      "startCol": "36",
      "endLine": "95",
      "endCol": "93"
    },
    "679": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "110",
      "startCol": "7",
      "endLine": "110",
      "endCol": "42"
    },
    "680": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "113",
      "startCol": "7",
      "endLine": "113",
      "endCol": "58"
    },
    "681": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "117",
      "startCol": "7",
      "endLine": "117",
      "endCol": "72"
    },
    "682": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "128",
      "startCol": "7",
      "endLine": "128",
      "endCol": "29"
    },
    "683": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "134",
      "startCol": "19",
      "endLine": "138",
      "endCol": "8"
    },
    "684": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "148",
      "startCol": "19",
      "endLine": "151",
      "endCol": "8"
    },
    "685": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "161",
      "startCol": "19",
      "endLine": "164",
      "endCol": "8"
    },
    "686": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "174",
      "startCol": "19",
      "endLine": "177",
      "endCol": "8"
    },
    "687": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js",
      "startLine": "186",
      "startCol": "19",
      "endLine": "189",
      "endCol": "8"
    },
    "688": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "29",
      "startCol": "10",
      "endLine": "29",
      "endCol": "44"
    },
    "689": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "59",
      "startCol": "19",
      "endLine": "62",
      "endCol": "8"
    },
    "690": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "79",
      "startCol": "19",
      "endLine": "82",
      "endCol": "8"
    },
    "691": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "95",
      "startCol": "19",
      "endLine": "98",
      "endCol": "8"
    },
    "692": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "124",
      "startCol": "19",
      "endLine": "128",
      "endCol": "10"
    },
    "693": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "147",
      "startCol": "15",
      "endLine": "151",
      "endCol": "10"
    },
    "694": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "206",
      "startCol": "19",
      "endLine": "210",
      "endCol": "10"
    },
    "695": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "223",
      "startCol": "15",
      "endLine": "227",
      "endCol": "10"
    },
    "696": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "254",
      "startCol": "19",
      "endLine": "258",
      "endCol": "10"
    },
    "697": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "270",
      "startCol": "21",
      "endLine": "274",
      "endCol": "10"
    },
    "698": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "289",
      "startCol": "21",
      "endLine": "293",
      "endCol": "10"
    },
    "699": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "305",
      "startCol": "21",
      "endLine": "308",
      "endCol": "10"
    },
    "700": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "328",
      "startCol": "21",
      "endLine": "331",
      "endCol": "10"
    },
    "701": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "356",
      "startCol": "21",
      "endLine": "360",
      "endCol": "10"
    },
    "702": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "375",
      "startCol": "21",
      "endLine": "379",
      "endCol": "10"
    },
    "703": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "394",
      "startCol": "21",
      "endLine": "398",
      "endCol": "10"
    },
    "704": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "413",
      "startCol": "21",
      "endLine": "417",
      "endCol": "10"
    },
    "705": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "428",
      "startCol": "21",
      "endLine": "432",
      "endCol": "12"
    },
    "706": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "440",
      "startCol": "19",
      "endLine": "443",
      "endCol": "14"
    },
    "707": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "450",
      "startCol": "21",
      "endLine": "454",
      "endCol": "12"
    },
    "708": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "458",
      "startCol": "17",
      "endLine": "461",
      "endCol": "12"
    },
    "709": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "472",
      "startCol": "21",
      "endLine": "476",
      "endCol": "12"
    },
    "710": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "481",
      "startCol": "19",
      "endLine": "484",
      "endCol": "14"
    },
    "711": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "494",
      "startCol": "21",
      "endLine": "497",
      "endCol": "12"
    },
    "712": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "501",
      "startCol": "17",
      "endLine": "504",
      "endCol": "12"
    },
    "713": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "512",
      "startCol": "21",
      "endLine": "515",
      "endCol": "12"
    },
    "714": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "522",
      "startCol": "17",
      "endLine": "525",
      "endCol": "12"
    },
    "715": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "531",
      "startCol": "21",
      "endLine": "534",
      "endCol": "12"
    },
    "716": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "541",
      "startCol": "17",
      "endLine": "544",
      "endCol": "12"
    },
    "717": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "557",
      "startCol": "21",
      "endLine": "561",
      "endCol": "10"
    },
    "718": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "572",
      "startCol": "21",
      "endLine": "575",
      "endCol": "10"
    },
    "719": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "581",
      "startCol": "21",
      "endLine": "585",
      "endCol": "10"
    },
    "720": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "594",
      "startCol": "21",
      "endLine": "597",
      "endCol": "10"
    },
    "721": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "606",
      "startCol": "21",
      "endLine": "622",
      "endCol": "10"
    },
    "722": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "654",
      "startCol": "21",
      "endLine": "666",
      "endCol": "10"
    },
    "723": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "678",
      "startCol": "21",
      "endLine": "688",
      "endCol": "10"
    },
    "724": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "700",
      "startCol": "21",
      "endLine": "703",
      "endCol": "10"
    },
    "725": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-role.test.e2e.js",
      "startLine": "733",
      "startCol": "21",
      "endLine": "737",
      "endCol": "10"
    },
    "726": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "58",
      "startCol": "10",
      "endLine": "58",
      "endCol": "44"
    },
    "727": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "64",
      "startCol": "23",
      "endLine": "64",
      "endCol": "53"
    },
    "728": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "68",
      "startCol": "31",
      "endLine": "68",
      "endCol": "61"
    },
    "729": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "74",
      "startCol": "7",
      "endLine": "74",
      "endCol": "53"
    },
    "730": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "86",
      "startCol": "17",
      "endLine": "90",
      "endCol": "6"
    },
    "731": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "111",
      "startCol": "17",
      "endLine": "115",
      "endCol": "6"
    },
    "732": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "135",
      "startCol": "19",
      "endLine": "139",
      "endCol": "8"
    },
    "733": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "153",
      "startCol": "17",
      "endLine": "157",
      "endCol": "6"
    },
    "734": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "175",
      "startCol": "17",
      "endLine": "179",
      "endCol": "6"
    },
    "735": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "193",
      "startCol": "17",
      "endLine": "196",
      "endCol": "6"
    },
    "736": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "216",
      "startCol": "19",
      "endLine": "219",
      "endCol": "8"
    },
    "737": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "227",
      "startCol": "19",
      "endLine": "230",
      "endCol": "8"
    },
    "738": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "239",
      "startCol": "17",
      "endLine": "242",
      "endCol": "6"
    },
    "739": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "249",
      "startCol": "17",
      "endLine": "252",
      "endCol": "6"
    },
    "740": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "259",
      "startCol": "17",
      "endLine": "265",
      "endCol": "6"
    },
    "741": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "273",
      "startCol": "17",
      "endLine": "276",
      "endCol": "6"
    },
    "742": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "283",
      "startCol": "17",
      "endLine": "286",
      "endCol": "6"
    },
    "743": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "298",
      "startCol": "17",
      "endLine": "304",
      "endCol": "6"
    },
    "744": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "320",
      "startCol": "17",
      "endLine": "324",
      "endCol": "6"
    },
    "745": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "335",
      "startCol": "17",
      "endLine": "338",
      "endCol": "6"
    },
    "746": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/tests/admin-user.test.e2e.js",
      "startLine": "349",
      "startCol": "17",
      "endLine": "352",
      "endCol": "6"
    },
    "747": {
      "patternID": "pattern3",
      "file": "packages/strapi-admin/validation/permission.js",
      "startLine": "105",
      "startCol": "7",
      "endLine": "105",
      "endCol": "77"
    },
    "748": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "107",
      "startCol": "18",
      "endLine": "107",
      "endCol": "71"
    },
    "749": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "213",
      "startCol": "23",
      "endLine": "213",
      "endCol": "59"
    },
    "750": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "278",
      "startCol": "5",
      "endLine": "278",
      "endCol": "28"
    },
    "751": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "285",
      "startCol": "23",
      "endLine": "287",
      "endCol": "3"
    },
    "752": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "294",
      "startCol": "5",
      "endLine": "296",
      "endCol": "6"
    },
    "753": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "318",
      "startCol": "11",
      "endLine": "318",
      "endCol": "55"
    },
    "754": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "321",
      "startCol": "11",
      "endLine": "325",
      "endCol": "11"
    },
    "755": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "328",
      "startCol": "11",
      "endLine": "328",
      "endCol": "43"
    },
    "756": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "340",
      "startCol": "11",
      "endLine": "340",
      "endCol": "80"
    },
    "757": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "341",
      "startCol": "11",
      "endLine": "341",
      "endCol": "54"
    },
    "758": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "345",
      "startCol": "11",
      "endLine": "345",
      "endCol": "62"
    },
    "759": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "362",
      "startCol": "11",
      "endLine": "370",
      "endCol": "11"
    },
    "760": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "371",
      "startCol": "11",
      "endLine": "375",
      "endCol": "12"
    },
    "761": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "379",
      "startCol": "11",
      "endLine": "379",
      "endCol": "60"
    },
    "762": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/build-database-schema.js",
      "startLine": "407",
      "startCol": "3",
      "endLine": "407",
      "endCol": "80"
    },
    "763": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/generate-component-relations.js",
      "startLine": "76",
      "startCol": "9",
      "endLine": "76",
      "endCol": "49"
    },
    "764": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/generate-component-relations.js",
      "startLine": "78",
      "startCol": "5",
      "endLine": "97",
      "endCol": "6"
    },
    "765": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/index.js",
      "startLine": "84",
      "startCol": "31",
      "endLine": "89",
      "endCol": "6"
    },
    "766": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/index.js",
      "startLine": "92",
      "startCol": "7",
      "endLine": "92",
      "endCol": "30"
    },
    "767": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/index.js",
      "startLine": "155",
      "startCol": "5",
      "endLine": "155",
      "endCol": "99"
    },
    "768": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/create-migration-runner.js",
      "startLine": "9",
      "startCol": "9",
      "endLine": "9",
      "endCol": "48"
    },
    "769": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/create-migration-runner.js",
      "startLine": "17",
      "startCol": "9",
      "endLine": "17",
      "endCol": "47"
    },
    "770": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/create-migration-runner.js",
      "startLine": "24",
      "startCol": "5",
      "endLine": "24",
      "endCol": "45"
    },
    "771": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js",
      "startLine": "30",
      "startCol": "37",
      "endLine": "33",
      "endCol": "5"
    },
    "772": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js",
      "startLine": "36",
      "startCol": "7",
      "endLine": "38",
      "endCol": "44"
    },
    "773": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js",
      "startLine": "45",
      "startCol": "9",
      "endLine": "47",
      "endCol": "10"
    },
    "774": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js",
      "startLine": "63",
      "startCol": "5",
      "endLine": "65",
      "endCol": "42"
    },
    "775": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js",
      "startLine": "67",
      "startCol": "5",
      "endLine": "69",
      "endCol": "42"
    },
    "776": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/mount-models.js",
      "startLine": "697",
      "startCol": "7",
      "endLine": "697",
      "endCol": "28"
    },
    "777": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "56",
      "startCol": "14",
      "endLine": "56",
      "endCol": "30"
    },
    "778": {
      "patternID": "pattern1",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "54",
      "startCol": "28",
      "endLine": "60",
      "endCol": "3"
    },
    "779": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "66",
      "startCol": "21",
      "endLine": "66",
      "endCol": "83"
    },
    "780": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "111",
      "startCol": "21",
      "endLine": "111",
      "endCol": "76"
    },
    "781": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "122",
      "startCol": "19",
      "endLine": "122",
      "endCol": "66"
    },
    "782": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "137",
      "startCol": "13",
      "endLine": "141",
      "endCol": "14"
    },
    "783": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "157",
      "startCol": "19",
      "endLine": "157",
      "endCol": "86"
    },
    "784": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "165",
      "startCol": "5",
      "endLine": "165",
      "endCol": "52"
    },
    "785": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "169",
      "startCol": "7",
      "endLine": "169",
      "endCol": "87"
    },
    "786": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "178",
      "startCol": "23",
      "endLine": "178",
      "endCol": "81"
    },
    "787": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "186",
      "startCol": "21",
      "endLine": "186",
      "endCol": "73"
    },
    "788": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "258",
      "startCol": "13",
      "endLine": "267",
      "endCol": "13"
    },
    "789": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "292",
      "startCol": "11",
      "endLine": "303",
      "endCol": "11"
    },
    "790": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "385",
      "startCol": "13",
      "endLine": "394",
      "endCol": "13"
    },
    "791": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "424",
      "startCol": "11",
      "endLine": "435",
      "endCol": "11"
    },
    "792": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "457",
      "startCol": "20",
      "endLine": "471",
      "endCol": "8"
    },
    "793": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "495",
      "startCol": "7",
      "endLine": "506",
      "endCol": "33"
    },
    "794": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "511",
      "startCol": "9",
      "endLine": "511",
      "endCol": "71"
    },
    "795": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "527",
      "startCol": "20",
      "endLine": "533",
      "endCol": "51"
    },
    "796": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "548",
      "startCol": "7",
      "endLine": "550",
      "endCol": "49"
    },
    "797": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "552",
      "startCol": "7",
      "endLine": "554",
      "endCol": "86"
    },
    "798": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "574",
      "startCol": "23",
      "endLine": "580",
      "endCol": "46"
    },
    "799": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "582",
      "startCol": "11",
      "endLine": "584",
      "endCol": "82"
    },
    "800": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "586",
      "startCol": "11",
      "endLine": "591",
      "endCol": "53"
    },
    "801": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "597",
      "startCol": "34",
      "endLine": "606",
      "endCol": "15"
    },
    "802": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "615",
      "startCol": "15",
      "endLine": "620",
      "endCol": "15"
    },
    "803": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/queries.js",
      "startLine": "624",
      "startCol": "11",
      "endLine": "629",
      "endCol": "53"
    },
    "804": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "29",
      "startCol": "10",
      "endLine": "38",
      "endCol": "3"
    },
    "805": {
      "patternID": "pattern1",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "28",
      "startCol": "26",
      "endLine": "39",
      "endCol": "1"
    },
    "806": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "42",
      "startCol": "10",
      "endLine": "58",
      "endCol": "6"
    },
    "807": {
      "patternID": "pattern1",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "41",
      "startCol": "29",
      "endLine": "59",
      "endCol": "1"
    },
    "808": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "63",
      "startCol": "20",
      "endLine": "68",
      "endCol": "6"
    },
    "809": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "87",
      "startCol": "23",
      "endLine": "87",
      "endCol": "56"
    },
    "810": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "292",
      "startCol": "32",
      "endLine": "300",
      "endCol": "39"
    },
    "811": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "368",
      "startCol": "5",
      "endLine": "368",
      "endCol": "38"
    },
    "812": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "372",
      "startCol": "7",
      "endLine": "377",
      "endCol": "8"
    },
    "813": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/relations.js",
      "startLine": "380",
      "startCol": "20",
      "endLine": "384",
      "endCol": "6"
    },
    "814": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/utils/connectivity.js",
      "startLine": "56",
      "startCol": "3",
      "endLine": "56",
      "endCol": "71"
    },
    "815": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/utils/store-definition.js",
      "startLine": "11",
      "startCol": "27",
      "endLine": "11",
      "endCol": "70"
    },
    "816": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-bookshelf/lib/utils/store-definition.js",
      "startLine": "17",
      "startCol": "15",
      "endLine": "19",
      "endCol": "12"
    },
    "817": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/database-migration.js",
      "startLine": "31",
      "startCol": "5",
      "endLine": "42",
      "endCol": "13"
    },
    "818": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/database-migration.js",
      "startLine": "44",
      "startCol": "5",
      "endLine": "44",
      "endCol": "62"
    },
    "819": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/database-migration.js",
      "startLine": "45",
      "startCol": "5",
      "endLine": "45",
      "endCol": "95"
    },
    "820": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/index.js",
      "startLine": "113",
      "startCol": "9",
      "endLine": "113",
      "endCol": "64"
    },
    "821": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/index.js",
      "startLine": "121",
      "startCol": "29",
      "endLine": "121",
      "endCol": "77"
    },
    "822": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/index.js",
      "startLine": "202",
      "startCol": "5",
      "endLine": "213",
      "endCol": "5"
    },
    "823": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "64",
      "startCol": "14",
      "endLine": "64",
      "endCol": "30"
    },
    "824": {
      "patternID": "pattern1",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "62",
      "startCol": "28",
      "endLine": "68",
      "endCol": "3"
    },
    "825": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "93",
      "startCol": "30",
      "endLine": "97",
      "endCol": "11"
    },
    "826": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "105",
      "startCol": "11",
      "endLine": "105",
      "endCol": "39"
    },
    "827": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "109",
      "startCol": "34",
      "endLine": "109",
      "endCol": "98"
    },
    "828": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "116",
      "startCol": "11",
      "endLine": "116",
      "endCol": "39"
    },
    "829": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "133",
      "startCol": "30",
      "endLine": "146",
      "endCol": "9"
    },
    "830": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "158",
      "startCol": "9",
      "endLine": "158",
      "endCol": "37"
    },
    "831": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "201",
      "startCol": "30",
      "endLine": "203",
      "endCol": "11"
    },
    "832": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "210",
      "startCol": "11",
      "endLine": "210",
      "endCol": "39"
    },
    "833": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "231",
      "startCol": "11",
      "endLine": "231",
      "endCol": "39"
    },
    "834": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "243",
      "startCol": "30",
      "endLine": "253",
      "endCol": "9"
    },
    "835": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "265",
      "startCol": "9",
      "endLine": "265",
      "endCol": "37"
    },
    "836": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "325",
      "startCol": "7",
      "endLine": "331",
      "endCol": "7"
    },
    "837": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "368",
      "startCol": "7",
      "endLine": "370",
      "endCol": "73"
    },
    "838": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "387",
      "startCol": "11",
      "endLine": "389",
      "endCol": "77"
    },
    "839": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "410",
      "startCol": "11",
      "endLine": "419",
      "endCol": "11"
    },
    "840": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "438",
      "startCol": "21",
      "endLine": "438",
      "endCol": "79"
    },
    "841": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "465",
      "startCol": "21",
      "endLine": "465",
      "endCol": "59"
    },
    "842": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "480",
      "startCol": "19",
      "endLine": "480",
      "endCol": "62"
    },
    "843": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "495",
      "startCol": "5",
      "endLine": "495",
      "endCol": "44"
    },
    "844": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "503",
      "startCol": "23",
      "endLine": "503",
      "endCol": "77"
    },
    "845": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "510",
      "startCol": "21",
      "endLine": "510",
      "endCol": "57"
    },
    "846": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "515",
      "startCol": "19",
      "endLine": "517",
      "endCol": "34"
    },
    "847": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/queries.js",
      "startLine": "527",
      "startCol": "5",
      "endLine": "527",
      "endCol": "51"
    },
    "848": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/relations.js",
      "startLine": "32",
      "startCol": "3",
      "endLine": "46",
      "endCol": "3"
    },
    "849": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/relations.js",
      "startLine": "70",
      "startCol": "3",
      "endLine": "82",
      "endCol": "3"
    },
    "850": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/relations.js",
      "startLine": "91",
      "startCol": "19",
      "endLine": "94",
      "endCol": "13"
    },
    "851": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/relations.js",
      "startLine": "373",
      "startCol": "5",
      "endLine": "378",
      "endCol": "5"
    },
    "852": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/relations.js",
      "startLine": "380",
      "startCol": "27",
      "endLine": "384",
      "endCol": "25"
    },
    "853": {
      "patternID": "pattern3",
      "file": "packages/strapi-connector-mongoose/lib/utils/store-definition.js",
      "startLine": "20",
      "startCol": "3",
      "endLine": "36",
      "endCol": "3"
    },
    "854": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/connector-registry.js",
      "startLine": "30",
      "startCol": "9",
      "endLine": "30",
      "endCol": "36"
    },
    "855": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/database-manager.js",
      "startLine": "36",
      "startCol": "5",
      "endLine": "36",
      "endCol": "38"
    },
    "856": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/database-manager.js",
      "startLine": "44",
      "startCol": "5",
      "endLine": "44",
      "endCol": "85"
    },
    "857": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/__tests__/create-query.test.js",
      "startLine": "24",
      "startCol": "9",
      "endLine": "24",
      "endCol": "35"
    },
    "858": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/__tests__/create-query.test.js",
      "startLine": "57",
      "startCol": "9",
      "endLine": "57",
      "endCol": "39"
    },
    "859": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/__tests__/paginated-queries.test.js",
      "startLine": "62",
      "startCol": "20",
      "endLine": "62",
      "endCol": "43"
    },
    "860": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/__tests__/paginated-queries.test.js",
      "startLine": "85",
      "startCol": "20",
      "endLine": "85",
      "endCol": "43"
    },
    "861": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/helpers.js",
      "startLine": "15",
      "startCol": "18",
      "endLine": "15",
      "endCol": "44"
    },
    "862": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/paginated-queries.js",
      "startLine": "11",
      "startCol": "19",
      "endLine": "11",
      "endCol": "46"
    },
    "863": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/paginated-queries.js",
      "startLine": "24",
      "startCol": "17",
      "endLine": "24",
      "endCol": "35"
    },
    "864": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/relations-counts-queries.js",
      "startLine": "9",
      "startCol": "21",
      "endLine": "9",
      "endCol": "71"
    },
    "865": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/relations-counts-queries.js",
      "startLine": "27",
      "startCol": "37",
      "endLine": "27",
      "endCol": "68"
    },
    "866": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/queries/relations-counts-queries.js",
      "startLine": "30",
      "startCol": "22",
      "endLine": "35",
      "endCol": "5"
    },
    "867": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/lib/utils/lifecycles.js",
      "startLine": "7",
      "startCol": "5",
      "endLine": "7",
      "endCol": "46"
    },
    "868": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "47",
      "startCol": "8",
      "endLine": "47",
      "endCol": "42"
    },
    "869": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "60",
      "startCol": "7",
      "endLine": "63",
      "endCol": "16"
    },
    "870": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "66",
      "startCol": "12",
      "endLine": "66",
      "endCol": "46"
    },
    "871": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "73",
      "startCol": "7",
      "endLine": "73",
      "endCol": "29"
    },
    "872": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "78",
      "startCol": "24",
      "endLine": "81",
      "endCol": "10"
    },
    "873": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "107",
      "startCol": "24",
      "endLine": "110",
      "endCol": "10"
    },
    "874": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "128",
      "startCol": "21",
      "endLine": "131",
      "endCol": "10"
    },
    "875": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "151",
      "startCol": "24",
      "endLine": "154",
      "endCol": "10"
    },
    "876": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "164",
      "startCol": "19",
      "endLine": "168",
      "endCol": "10"
    },
    "877": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-draft-publish.test.e2e.js",
      "startLine": "175",
      "startCol": "15",
      "endLine": "179",
      "endCol": "10"
    },
    "878": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "41",
      "startCol": "8",
      "endLine": "41",
      "endCol": "42"
    },
    "879": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "46",
      "startCol": "5",
      "endLine": "49",
      "endCol": "14"
    },
    "880": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "52",
      "startCol": "10",
      "endLine": "52",
      "endCol": "44"
    },
    "881": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "59",
      "startCol": "5",
      "endLine": "59",
      "endCol": "27"
    },
    "882": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "64",
      "startCol": "22",
      "endLine": "67",
      "endCol": "8"
    },
    "883": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "76",
      "startCol": "24",
      "endLine": "80",
      "endCol": "8"
    },
    "884": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "91",
      "startCol": "19",
      "endLine": "95",
      "endCol": "8"
    },
    "885": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-required-attribute.test.e2e.js",
      "startLine": "110",
      "startCol": "19",
      "endLine": "114",
      "endCol": "8"
    },
    "886": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "41",
      "startCol": "8",
      "endLine": "41",
      "endCol": "42"
    },
    "887": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "46",
      "startCol": "5",
      "endLine": "49",
      "endCol": "14"
    },
    "888": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "52",
      "startCol": "10",
      "endLine": "52",
      "endCol": "44"
    },
    "889": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "59",
      "startCol": "5",
      "endLine": "59",
      "endCol": "27"
    },
    "890": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "64",
      "startCol": "22",
      "endLine": "67",
      "endCol": "8"
    },
    "891": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "74",
      "startCol": "24",
      "endLine": "78",
      "endCol": "8"
    },
    "892": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "89",
      "startCol": "19",
      "endLine": "93",
      "endCol": "8"
    },
    "893": {
      "patternID": "pattern3",
      "file": "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js",
      "startLine": "108",
      "startCol": "19",
      "endLine": "112",
      "endCol": "8"
    },
    "894": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-cli-db-project.js",
      "startLine": "12",
      "startCol": "3",
      "endLine": "12",
      "endCol": "63"
    },
    "895": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "17",
      "startCol": "3",
      "endLine": "17",
      "endCol": "63"
    },
    "896": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "19",
      "startCol": "25",
      "endLine": "25",
      "endCol": "4"
    },
    "897": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "29",
      "startCol": "3",
      "endLine": "29",
      "endCol": "58"
    },
    "898": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "133",
      "startCol": "22",
      "endLine": "141",
      "endCol": "4"
    },
    "899": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "143",
      "startCol": "21",
      "endLine": "145",
      "endCol": "3"
    },
    "900": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "174",
      "startCol": "5",
      "endLine": "174",
      "endCol": "38"
    },
    "901": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-customized-project.js",
      "startLine": "181",
      "startCol": "3",
      "endLine": "181",
      "endCol": "47"
    },
    "902": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "26",
      "startCol": "5",
      "endLine": "26",
      "endCol": "54"
    },
    "903": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "29",
      "startCol": "22",
      "endLine": "29",
      "endCol": "68"
    },
    "904": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "34",
      "endCol": "5"
    },
    "905": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "36",
      "startCol": "5",
      "endLine": "36",
      "endCol": "61"
    },
    "906": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "51",
      "endCol": "5"
    },
    "907": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "53",
      "endCol": "61"
    },
    "908": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "56",
      "startCol": "5",
      "endLine": "56",
      "endCol": "55"
    },
    "909": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "59",
      "startCol": "5",
      "endLine": "65",
      "endCol": "5"
    },
    "910": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "68",
      "startCol": "5",
      "endLine": "68",
      "endCol": "81"
    },
    "911": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "69",
      "startCol": "5",
      "endLine": "69",
      "endCol": "67"
    },
    "912": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "81",
      "startCol": "5",
      "endLine": "81",
      "endCol": "36"
    },
    "913": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "85",
      "startCol": "3",
      "endLine": "85",
      "endCol": "70"
    },
    "914": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "104",
      "startCol": "7",
      "endLine": "104",
      "endCol": "18"
    },
    "915": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "110",
      "startCol": "5",
      "endLine": "110",
      "endCol": "71"
    },
    "916": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "113",
      "startCol": "5",
      "endLine": "117",
      "endCol": "6"
    },
    "917": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-project.js",
      "startLine": "144",
      "startCol": "3",
      "endLine": "144",
      "endCol": "56"
    },
    "918": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "12",
      "startCol": "3",
      "endLine": "12",
      "endCol": "59"
    },
    "919": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "27",
      "startCol": "5",
      "endLine": "27",
      "endCol": "56"
    },
    "920": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "29",
      "startCol": "5",
      "endLine": "35",
      "endCol": "6"
    },
    "921": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "37",
      "startCol": "5",
      "endLine": "37",
      "endCol": "55"
    },
    "922": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "43",
      "endCol": "6"
    },
    "923": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "52",
      "startCol": "5",
      "endLine": "52",
      "endCol": "57"
    },
    "924": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "54",
      "startCol": "5",
      "endLine": "60",
      "endCol": "6"
    },
    "925": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/create-quickstart-project.js",
      "startLine": "62",
      "startCol": "5",
      "endLine": "66",
      "endCol": "6"
    },
    "926": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/generate-new.js",
      "startLine": "22",
      "startCol": "7",
      "endLine": "22",
      "endCol": "38"
    },
    "927": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/generate-new.js",
      "startLine": "23",
      "startCol": "18",
      "endLine": "23",
      "endCol": "47"
    },
    "928": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/generate-new.js",
      "startLine": "33",
      "startCol": "19",
      "endLine": "33",
      "endCol": "51"
    },
    "929": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/generate-new.js",
      "startLine": "43",
      "startCol": "3",
      "endLine": "43",
      "endCol": "57"
    },
    "930": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/generate-new.js",
      "startLine": "66",
      "startCol": "18",
      "endLine": "82",
      "endCol": "4"
    },
    "931": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "40",
      "startCol": "24",
      "endLine": "40",
      "endCol": "75"
    },
    "932": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "58",
      "startCol": "3",
      "endLine": "58",
      "endCol": "32"
    },
    "933": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "72",
      "startCol": "22",
      "endLine": "72",
      "endCol": "53"
    },
    "934": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "81",
      "startCol": "26",
      "endLine": "81",
      "endCol": "61"
    },
    "935": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "107",
      "startCol": "18",
      "endLine": "107",
      "endCol": "48"
    },
    "936": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "199",
      "startCol": "20",
      "endLine": "199",
      "endCol": "40"
    },
    "937": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "232",
      "startCol": "3",
      "endLine": "232",
      "endCol": "67"
    },
    "938": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/merge-template.js",
      "startLine": "238",
      "startCol": "3",
      "endLine": "238",
      "endCol": "77"
    },
    "939": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/usage.js",
      "startLine": "10",
      "startCol": "5",
      "endLine": "10",
      "endCol": "24"
    },
    "940": {
      "patternID": "pattern3",
      "file": "packages/strapi-generate-new/lib/utils/usage.js",
      "startLine": "20",
      "startCol": "5",
      "endLine": "20",
      "endCol": "24"
    },
    "941": {
      "patternID": "pattern3",
      "file": "packages/strapi-helper-plugin/lib/src/hooks/useUserPermissions/index.js",
      "startLine": "51",
      "startCol": "25",
      "endLine": "51",
      "endCol": "58"
    },
    "942": {
      "patternID": "pattern3",
      "file": "packages/strapi-helper-plugin/lib/src/utils/hasPermissions.js",
      "startLine": "41",
      "startCol": "24",
      "endLine": "47",
      "endCol": "8"
    },
    "943": {
      "patternID": "pattern3",
      "file": "packages/strapi-hook-redis/lib/index.js",
      "startLine": "100",
      "startCol": "20",
      "endLine": "100",
      "endCol": "29"
    },
    "944": {
      "patternID": "pattern1",
      "file": "packages/strapi-hook-redis/lib/index.js",
      "startLine": "86",
      "startCol": "23",
      "endLine": "135",
      "endCol": "9"
    },
    "945": {
      "patternID": "pattern3",
      "file": "packages/strapi-hook-redis/lib/index.js",
      "startLine": "103",
      "startCol": "23",
      "endLine": "103",
      "endCol": "45"
    },
    "946": {
      "patternID": "pattern3",
      "file": "packages/strapi-hook-redis/lib/index.js",
      "startLine": "106",
      "startCol": "21",
      "endLine": "106",
      "endCol": "30"
    },
    "947": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/DraggedFieldWithPreview/DynamicComponent.js",
      "startLine": "19",
      "startCol": "27",
      "endLine": "22",
      "endCol": "9"
    },
    "948": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/InputUID/index.js",
      "startLine": "72",
      "startCol": "24",
      "endLine": "79",
      "endCol": "8"
    },
    "949": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/InputUID/index.js",
      "startLine": "99",
      "startCol": "20",
      "endLine": "106",
      "endCol": "8"
    },
    "950": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/RelationPreviewList/RelationPreviewTooltip.js",
      "startLine": "25",
      "startCol": "29",
      "endLine": "28",
      "endCol": "10"
    },
    "951": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/SelectWrapper/index.js",
      "startLine": "108",
      "startCol": "22",
      "endLine": "113",
      "endCol": "10"
    },
    "952": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/components/SettingsViewWrapper/index.js",
      "startLine": "214",
      "startCol": "15",
      "endLine": "214",
      "endCol": "37"
    },
    "953": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "109",
      "startCol": "22",
      "endLine": "109",
      "endCol": "73"
    },
    "954": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "171",
      "startCol": "26",
      "endLine": "173",
      "endCol": "10"
    },
    "955": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "201",
      "startCol": "26",
      "endLine": "201",
      "endCol": "74"
    },
    "956": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "230",
      "startCol": "20",
      "endLine": "230",
      "endCol": "62"
    },
    "957": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "256",
      "startCol": "26",
      "endLine": "256",
      "endCol": "73"
    },
    "958": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js",
      "startLine": "283",
      "startCol": "24",
      "endLine": "283",
      "endCol": "66"
    },
    "959": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/ComponentSetttingsView/index.js",
      "startLine": "25",
      "startCol": "26",
      "endLine": "28",
      "endCol": "10"
    },
    "960": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/EditSettingsView/index.js",
      "startLine": "124",
      "startCol": "24",
      "endLine": "124",
      "endCol": "73"
    },
    "961": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/EditView/DeleteLink/index.js",
      "startLine": "27",
      "startCol": "7",
      "endLine": "27",
      "endCol": "37"
    },
    "962": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/EditViewDataManagerProvider/index.js",
      "startLine": "190",
      "startCol": "9",
      "endLine": "190",
      "endCol": "68"
    },
    "963": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/EditViewDataManagerProvider/index.js",
      "startLine": "285",
      "startCol": "9",
      "endLine": "285",
      "endCol": "69"
    },
    "964": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/EditViewDataManagerProvider/index.js",
      "startLine": "322",
      "startCol": "7",
      "endLine": "322",
      "endCol": "64"
    },
    "965": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/ListSettingsView/index.js",
      "startLine": "94",
      "startCol": "24",
      "endLine": "97",
      "endCol": "8"
    },
    "966": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/ListView/index.js",
      "startLine": "160",
      "startCol": "41",
      "endLine": "160",
      "endCol": "90"
    },
    "967": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/ListView/index.js",
      "startLine": "195",
      "startCol": "7",
      "endLine": "198",
      "endCol": "8"
    },
    "968": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/ListView/index.js",
      "startLine": "222",
      "startCol": "7",
      "endLine": "224",
      "endCol": "8"
    },
    "969": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/Main/index.js",
      "startLine": "33",
      "startCol": "58",
      "endLine": "37",
      "endCol": "9"
    },
    "970": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "84",
      "startCol": "22",
      "endLine": "84",
      "endCol": "82"
    },
    "971": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "137",
      "startCol": "26",
      "endLine": "139",
      "endCol": "10"
    },
    "972": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "168",
      "startCol": "26",
      "endLine": "168",
      "endCol": "73"
    },
    "973": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "195",
      "startCol": "20",
      "endLine": "195",
      "endCol": "62"
    },
    "974": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "220",
      "startCol": "26",
      "endLine": "220",
      "endCol": "73"
    },
    "975": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js",
      "startLine": "249",
      "startCol": "24",
      "endLine": "249",
      "endCol": "66"
    },
    "976": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/admin/src/hooks/useFetchContentTypeLayout/index.js",
      "startLine": "26",
      "startCol": "26",
      "endLine": "29",
      "endCol": "10"
    },
    "977": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/config/functions/bootstrap.js",
      "startLine": "6",
      "startCol": "3",
      "endLine": "6",
      "endCol": "53"
    },
    "978": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/config/functions/bootstrap.js",
      "startLine": "7",
      "startCol": "3",
      "endLine": "7",
      "endCol": "56"
    },
    "979": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/config/functions/bootstrap.js",
      "startLine": "8",
      "startCol": "3",
      "endLine": "8",
      "endCol": "54"
    },
    "980": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/config/policies/routing.js",
      "startLine": "22",
      "startCol": "14",
      "endLine": "22",
      "endCol": "76"
    },
    "981": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-content-manager/config/policies/routing.js",
      "startLine": "5",
      "startCol": "18",
      "endLine": "27",
      "endCol": "1"
    },
    "982": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/config/policies/routing.js",
      "startLine": "26",
      "startCol": "3",
      "endLine": "26",
      "endCol": "14"
    },
    "983": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "31",
      "startCol": "37",
      "endLine": "31",
      "endCol": "87"
    },
    "984": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "50",
      "startCol": "20",
      "endLine": "50",
      "endCol": "73"
    },
    "985": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "81",
      "startCol": "5",
      "endLine": "86",
      "endCol": "8"
    },
    "986": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "82",
      "startCol": "22",
      "endLine": "82",
      "endCol": "72"
    },
    "987": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "85",
      "startCol": "7",
      "endLine": "85",
      "endCol": "78"
    },
    "988": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "101",
      "startCol": "20",
      "endLine": "101",
      "endCol": "73"
    },
    "989": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "117",
      "startCol": "5",
      "endLine": "121",
      "endCol": "8"
    },
    "990": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "118",
      "startCol": "29",
      "endLine": "118",
      "endCol": "87"
    },
    "991": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "135",
      "startCol": "20",
      "endLine": "135",
      "endCol": "73"
    },
    "992": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "145",
      "startCol": "20",
      "endLine": "145",
      "endCol": "60"
    },
    "993": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "161",
      "startCol": "20",
      "endLine": "161",
      "endCol": "73"
    },
    "994": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "171",
      "startCol": "20",
      "endLine": "171",
      "endCol": "61"
    },
    "995": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "187",
      "startCol": "20",
      "endLine": "187",
      "endCol": "73"
    },
    "996": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "197",
      "startCol": "20",
      "endLine": "197",
      "endCol": "63"
    },
    "997": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "208",
      "startCol": "5",
      "endLine": "208",
      "endCol": "39"
    },
    "998": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "225",
      "startCol": "21",
      "endLine": "225",
      "endCol": "68"
    },
    "999": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "252",
      "startCol": "20",
      "endLine": "252",
      "endCol": "73"
    },
    "1000": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "264",
      "startCol": "31",
      "endLine": "264",
      "endCol": "83"
    },
    "1001": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "266",
      "startCol": "22",
      "endLine": "269",
      "endCol": "7"
    },
    "1002": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "272",
      "startCol": "22",
      "endLine": "275",
      "endCol": "7"
    },
    "1003": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/collection-types.js",
      "startLine": "278",
      "startCol": "20",
      "endLine": "278",
      "endCol": "77"
    },
    "1004": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/components.js",
      "startLine": "25",
      "startCol": "27",
      "endLine": "25",
      "endCol": "77"
    },
    "1005": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/components.js",
      "startLine": "26",
      "startCol": "38",
      "endLine": "26",
      "endCol": "99"
    },
    "1006": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/components.js",
      "startLine": "50",
      "startCol": "15",
      "endLine": "54",
      "endCol": "8"
    },
    "1007": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/components.js",
      "startLine": "62",
      "startCol": "30",
      "endLine": "62",
      "endCol": "89"
    },
    "1008": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "19",
      "startCol": "7",
      "endLine": "19",
      "endCol": "30"
    },
    "1009": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "35",
      "startCol": "25",
      "endLine": "35",
      "endCol": "69"
    },
    "1010": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "41",
      "startCol": "27",
      "endLine": "41",
      "endCol": "81"
    },
    "1011": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "48",
      "startCol": "24",
      "endLine": "48",
      "endCol": "89"
    },
    "1012": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "66",
      "startCol": "25",
      "endLine": "66",
      "endCol": "69"
    },
    "1013": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "78",
      "startCol": "15",
      "endLine": "82",
      "endCol": "8"
    },
    "1014": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "90",
      "startCol": "30",
      "endLine": "90",
      "endCol": "93"
    },
    "1015": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/content-types.js",
      "startLine": "92",
      "startCol": "5",
      "endLine": "92",
      "endCol": "80"
    },
    "1016": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/relations.js",
      "startLine": "45",
      "startCol": "18",
      "endLine": "45",
      "endCol": "62"
    },
    "1017": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/relations.js",
      "startLine": "47",
      "startCol": "18",
      "endLine": "47",
      "endCol": "60"
    },
    "1018": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/relations.js",
      "startLine": "55",
      "startCol": "9",
      "endLine": "55",
      "endCol": "66"
    },
    "1019": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/relations.js",
      "startLine": "56",
      "startCol": "9",
      "endLine": "56",
      "endCol": "69"
    },
    "1020": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "14",
      "startCol": "18",
      "endLine": "14",
      "endCol": "52"
    },
    "1021": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "73",
      "startCol": "5",
      "endLine": "88",
      "endCol": "8"
    },
    "1022": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "75",
      "startCol": "27",
      "endLine": "75",
      "endCol": "77"
    },
    "1023": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "78",
      "startCol": "9",
      "endLine": "78",
      "endCol": "80"
    },
    "1024": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "86",
      "startCol": "29",
      "endLine": "86",
      "endCol": "87"
    },
    "1025": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "112",
      "startCol": "27",
      "endLine": "112",
      "endCol": "67"
    },
    "1026": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "138",
      "startCol": "29",
      "endLine": "138",
      "endCol": "70"
    },
    "1027": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/single-types.js",
      "startLine": "164",
      "startCol": "31",
      "endLine": "164",
      "endCol": "74"
    },
    "1028": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "12",
      "startCol": "45",
      "endLine": "12",
      "endCol": "92"
    },
    "1029": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "14",
      "startCol": "5",
      "endLine": "14",
      "endCol": "49"
    },
    "1030": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "19",
      "startCol": "13",
      "endLine": "19",
      "endCol": "78"
    },
    "1031": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "24",
      "startCol": "46",
      "endLine": "26",
      "endCol": "5"
    },
    "1032": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "28",
      "startCol": "5",
      "endLine": "28",
      "endCol": "49"
    },
    "1033": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "32",
      "startCol": "25",
      "endLine": "32",
      "endCol": "95"
    },
    "1034": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/controllers/uid.js",
      "startLine": "37",
      "startCol": "11",
      "endLine": "37",
      "endCol": "74"
    },
    "1035": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/content-types.test.js",
      "startLine": "23",
      "startCol": "5",
      "endLine": "23",
      "endCol": "31"
    },
    "1036": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/content-types.test.js",
      "startLine": "34",
      "startCol": "5",
      "endLine": "38",
      "endCol": "6"
    },
    "1037": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/content-types.test.js",
      "startLine": "55",
      "startCol": "5",
      "endLine": "59",
      "endCol": "6"
    },
    "1038": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/content-types.test.js",
      "startLine": "77",
      "startCol": "5",
      "endLine": "77",
      "endCol": "34"
    },
    "1039": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/entity-manager.test.js",
      "startLine": "31",
      "startCol": "7",
      "endLine": "31",
      "endCol": "48"
    },
    "1040": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/__tests__/entity-manager.test.js",
      "startLine": "58",
      "startCol": "7",
      "endLine": "58",
      "endCol": "50"
    },
    "1041": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/components.js",
      "startLine": "40",
      "startCol": "27",
      "endLine": "40",
      "endCol": "84"
    },
    "1042": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/components.js",
      "startLine": "50",
      "startCol": "5",
      "endLine": "50",
      "endCol": "80"
    },
    "1043": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/configuration.js",
      "startLine": "42",
      "startCol": "28",
      "endLine": "44",
      "endCol": "5"
    },
    "1044": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/configuration.js",
      "startLine": "64",
      "startCol": "5",
      "endLine": "64",
      "endCol": "80"
    },
    "1045": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/configuration.js",
      "startLine": "67",
      "startCol": "5",
      "endLine": "67",
      "endCol": "82"
    },
    "1046": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/configuration.js",
      "startLine": "70",
      "startCol": "5",
      "endLine": "70",
      "endCol": "80"
    },
    "1047": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/content-types.js",
      "startLine": "50",
      "startCol": "27",
      "endLine": "50",
      "endCol": "86"
    },
    "1048": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/content-types.js",
      "startLine": "59",
      "startCol": "5",
      "endLine": "59",
      "endCol": "82"
    },
    "1049": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/entity-manager.js",
      "startLine": "14",
      "startCol": "18",
      "endLine": "14",
      "endCol": "40"
    },
    "1050": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/entity-manager.js",
      "startLine": "43",
      "startCol": "19",
      "endLine": "43",
      "endCol": "48"
    },
    "1051": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/entity-manager.js",
      "startLine": "122",
      "startCol": "5",
      "endLine": "122",
      "endCol": "87"
    },
    "1052": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/metrics.js",
      "startLine": "24",
      "startCol": "5",
      "endLine": "24",
      "endCol": "61"
    },
    "1053": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/uid.js",
      "startLine": "32",
      "startCol": "31",
      "endLine": "37",
      "endCol": "60"
    },
    "1054": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/uid.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "58",
      "endCol": "6"
    },
    "1055": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/utils/configuration/index.js",
      "startLine": "10",
      "startCol": "5",
      "endLine": "12",
      "endCol": "30"
    },
    "1056": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/utils/configuration/index.js",
      "startLine": "25",
      "startCol": "16",
      "endLine": "25",
      "endCol": "51"
    },
    "1057": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/utils/store.js",
      "startLine": "27",
      "startCol": "18",
      "endLine": "27",
      "endCol": "69"
    },
    "1058": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/services/utils/store.js",
      "startLine": "32",
      "startCol": "25",
      "endLine": "32",
      "endCol": "76"
    },
    "1059": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "54",
      "startCol": "5",
      "endLine": "57",
      "endCol": "14"
    },
    "1060": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "60",
      "startCol": "10",
      "endLine": "60",
      "endCol": "44"
    },
    "1061": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "65",
      "startCol": "5",
      "endLine": "65",
      "endCol": "27"
    },
    "1062": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "83",
      "endCol": "6"
    },
    "1063": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "92",
      "startCol": "17",
      "endLine": "95",
      "endCol": "6"
    },
    "1064": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "115",
      "startCol": "17",
      "endLine": "119",
      "endCol": "6"
    },
    "1065": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "129",
      "startCol": "17",
      "endLine": "132",
      "endCol": "6"
    },
    "1066": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "147",
      "startCol": "19",
      "endLine": "151",
      "endCol": "8"
    },
    "1067": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "168",
      "startCol": "19",
      "endLine": "172",
      "endCol": "8"
    },
    "1068": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "191",
      "startCol": "19",
      "endLine": "195",
      "endCol": "8"
    },
    "1069": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js",
      "startLine": "213",
      "startCol": "19",
      "endLine": "217",
      "endCol": "8"
    },
    "1070": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "56",
      "endCol": "14"
    },
    "1071": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "59",
      "startCol": "10",
      "endLine": "59",
      "endCol": "44"
    },
    "1072": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "64",
      "startCol": "5",
      "endLine": "64",
      "endCol": "27"
    },
    "1073": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "76",
      "startCol": "17",
      "endLine": "80",
      "endCol": "6"
    },
    "1074": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "89",
      "startCol": "17",
      "endLine": "92",
      "endCol": "6"
    },
    "1075": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "110",
      "startCol": "17",
      "endLine": "114",
      "endCol": "6"
    },
    "1076": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "124",
      "startCol": "17",
      "endLine": "127",
      "endCol": "6"
    },
    "1077": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "142",
      "startCol": "19",
      "endLine": "146",
      "endCol": "8"
    },
    "1078": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "161",
      "startCol": "19",
      "endLine": "165",
      "endCol": "8"
    },
    "1079": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "182",
      "startCol": "19",
      "endLine": "186",
      "endCol": "8"
    },
    "1080": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js",
      "startLine": "202",
      "startCol": "19",
      "endLine": "206",
      "endCol": "8"
    },
    "1081": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "57",
      "startCol": "5",
      "endLine": "60",
      "endCol": "14"
    },
    "1082": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "63",
      "startCol": "10",
      "endLine": "63",
      "endCol": "44"
    },
    "1083": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "68",
      "startCol": "5",
      "endLine": "68",
      "endCol": "27"
    },
    "1084": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "82",
      "startCol": "17",
      "endLine": "87",
      "endCol": "6"
    },
    "1085": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "96",
      "startCol": "17",
      "endLine": "100",
      "endCol": "6"
    },
    "1086": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "122",
      "startCol": "17",
      "endLine": "126",
      "endCol": "6"
    },
    "1087": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "136",
      "startCol": "17",
      "endLine": "139",
      "endCol": "6"
    },
    "1088": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "155",
      "startCol": "19",
      "endLine": "160",
      "endCol": "8"
    },
    "1089": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "178",
      "startCol": "19",
      "endLine": "183",
      "endCol": "8"
    },
    "1090": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "201",
      "startCol": "19",
      "endLine": "206",
      "endCol": "8"
    },
    "1091": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js",
      "startLine": "224",
      "startCol": "19",
      "endLine": "229",
      "endCol": "8"
    },
    "1092": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "56",
      "startCol": "5",
      "endLine": "59",
      "endCol": "14"
    },
    "1093": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "62",
      "startCol": "10",
      "endLine": "62",
      "endCol": "44"
    },
    "1094": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "67",
      "startCol": "5",
      "endLine": "67",
      "endCol": "27"
    },
    "1095": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "84",
      "endCol": "6"
    },
    "1096": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "93",
      "startCol": "17",
      "endLine": "97",
      "endCol": "6"
    },
    "1097": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "117",
      "startCol": "17",
      "endLine": "121",
      "endCol": "6"
    },
    "1098": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "131",
      "startCol": "17",
      "endLine": "134",
      "endCol": "6"
    },
    "1099": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "150",
      "startCol": "19",
      "endLine": "155",
      "endCol": "8"
    },
    "1100": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "171",
      "startCol": "19",
      "endLine": "176",
      "endCol": "8"
    },
    "1101": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "192",
      "startCol": "19",
      "endLine": "197",
      "endCol": "8"
    },
    "1102": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js",
      "startLine": "213",
      "startCol": "19",
      "endLine": "218",
      "endCol": "8"
    },
    "1103": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "56",
      "startCol": "5",
      "endLine": "59",
      "endCol": "14"
    },
    "1104": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "62",
      "startCol": "10",
      "endLine": "62",
      "endCol": "44"
    },
    "1105": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "67",
      "startCol": "5",
      "endLine": "67",
      "endCol": "27"
    },
    "1106": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "82",
      "startCol": "17",
      "endLine": "87",
      "endCol": "6"
    },
    "1107": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "96",
      "startCol": "17",
      "endLine": "100",
      "endCol": "6"
    },
    "1108": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "123",
      "startCol": "17",
      "endLine": "127",
      "endCol": "6"
    },
    "1109": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "137",
      "startCol": "17",
      "endLine": "140",
      "endCol": "6"
    },
    "1110": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "157",
      "startCol": "21",
      "endLine": "163",
      "endCol": "10"
    },
    "1111": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "182",
      "startCol": "21",
      "endLine": "188",
      "endCol": "10"
    },
    "1112": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "207",
      "startCol": "21",
      "endLine": "213",
      "endCol": "10"
    },
    "1113": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "232",
      "startCol": "21",
      "endLine": "238",
      "endCol": "10"
    },
    "1114": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js",
      "startLine": "256",
      "startCol": "21",
      "endLine": "262",
      "endCol": "10"
    },
    "1115": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "52",
      "startCol": "5",
      "endLine": "55",
      "endCol": "14"
    },
    "1116": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "58",
      "startCol": "10",
      "endLine": "58",
      "endCol": "44"
    },
    "1117": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "63",
      "startCol": "5",
      "endLine": "63",
      "endCol": "27"
    },
    "1118": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "71",
      "startCol": "17",
      "endLine": "75",
      "endCol": "6"
    },
    "1119": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "89",
      "startCol": "17",
      "endLine": "93",
      "endCol": "6"
    },
    "1120": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "102",
      "startCol": "17",
      "endLine": "105",
      "endCol": "6"
    },
    "1121": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "128",
      "startCol": "17",
      "endLine": "132",
      "endCol": "6"
    },
    "1122": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "147",
      "startCol": "17",
      "endLine": "151",
      "endCol": "6"
    },
    "1123": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "163",
      "startCol": "20",
      "endLine": "166",
      "endCol": "6"
    },
    "1124": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "176",
      "startCol": "20",
      "endLine": "179",
      "endCol": "6"
    },
    "1125": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "188",
      "startCol": "20",
      "endLine": "191",
      "endCol": "6"
    },
    "1126": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "201",
      "startCol": "20",
      "endLine": "204",
      "endCol": "6"
    },
    "1127": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "211",
      "startCol": "17",
      "endLine": "214",
      "endCol": "6"
    },
    "1128": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "229",
      "startCol": "19",
      "endLine": "233",
      "endCol": "8"
    },
    "1129": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "244",
      "startCol": "19",
      "endLine": "248",
      "endCol": "8"
    },
    "1130": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js",
      "startLine": "263",
      "startCol": "19",
      "endLine": "267",
      "endCol": "8"
    },
    "1131": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "56",
      "endCol": "14"
    },
    "1132": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "59",
      "startCol": "10",
      "endLine": "59",
      "endCol": "44"
    },
    "1133": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "64",
      "startCol": "5",
      "endLine": "64",
      "endCol": "27"
    },
    "1134": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "83",
      "endCol": "6"
    },
    "1135": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "92",
      "startCol": "17",
      "endLine": "95",
      "endCol": "6"
    },
    "1136": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "116",
      "startCol": "17",
      "endLine": "120",
      "endCol": "6"
    },
    "1137": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "130",
      "startCol": "17",
      "endLine": "133",
      "endCol": "6"
    },
    "1138": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "148",
      "startCol": "19",
      "endLine": "152",
      "endCol": "8"
    },
    "1139": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "170",
      "startCol": "19",
      "endLine": "174",
      "endCol": "8"
    },
    "1140": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "194",
      "startCol": "19",
      "endLine": "198",
      "endCol": "8"
    },
    "1141": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "217",
      "startCol": "19",
      "endLine": "221",
      "endCol": "8"
    },
    "1142": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js",
      "startLine": "240",
      "startCol": "19",
      "endLine": "244",
      "endCol": "8"
    },
    "1143": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "115",
      "startCol": "5",
      "endLine": "119",
      "endCol": "14"
    },
    "1144": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "122",
      "startCol": "10",
      "endLine": "122",
      "endCol": "44"
    },
    "1145": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "130",
      "startCol": "5",
      "endLine": "130",
      "endCol": "27"
    },
    "1146": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "135",
      "startCol": "19",
      "endLine": "138",
      "endCol": "8"
    },
    "1147": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "149",
      "startCol": "19",
      "endLine": "152",
      "endCol": "8"
    },
    "1148": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "163",
      "startCol": "19",
      "endLine": "166",
      "endCol": "8"
    },
    "1149": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "177",
      "startCol": "19",
      "endLine": "180",
      "endCol": "8"
    },
    "1150": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "193",
      "startCol": "19",
      "endLine": "199",
      "endCol": "8"
    },
    "1151": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "209",
      "startCol": "19",
      "endLine": "215",
      "endCol": "8"
    },
    "1152": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "225",
      "startCol": "19",
      "endLine": "231",
      "endCol": "8"
    },
    "1153": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "241",
      "startCol": "19",
      "endLine": "247",
      "endCol": "8"
    },
    "1154": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "256",
      "startCol": "19",
      "endLine": "262",
      "endCol": "8"
    },
    "1155": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "272",
      "startCol": "19",
      "endLine": "278",
      "endCol": "8"
    },
    "1156": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "287",
      "startCol": "19",
      "endLine": "293",
      "endCol": "8"
    },
    "1157": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "304",
      "startCol": "17",
      "endLine": "310",
      "endCol": "8"
    },
    "1158": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "319",
      "startCol": "13",
      "endLine": "325",
      "endCol": "8"
    },
    "1159": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "336",
      "startCol": "17",
      "endLine": "342",
      "endCol": "8"
    },
    "1160": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "351",
      "startCol": "13",
      "endLine": "357",
      "endCol": "8"
    },
    "1161": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "368",
      "startCol": "17",
      "endLine": "374",
      "endCol": "8"
    },
    "1162": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js",
      "startLine": "383",
      "startCol": "13",
      "endLine": "389",
      "endCol": "8"
    },
    "1163": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "35",
      "startCol": "5",
      "endLine": "35",
      "endCol": "49"
    },
    "1164": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "38",
      "startCol": "10",
      "endLine": "38",
      "endCol": "44"
    },
    "1165": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "43",
      "startCol": "5",
      "endLine": "43",
      "endCol": "27"
    },
    "1166": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "51",
      "startCol": "17",
      "endLine": "55",
      "endCol": "6"
    },
    "1167": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "64",
      "startCol": "17",
      "endLine": "67",
      "endCol": "6"
    },
    "1168": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "88",
      "startCol": "17",
      "endLine": "92",
      "endCol": "6"
    },
    "1169": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "102",
      "startCol": "17",
      "endLine": "105",
      "endCol": "6"
    },
    "1170": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "120",
      "startCol": "19",
      "endLine": "124",
      "endCol": "8"
    },
    "1171": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "136",
      "startCol": "19",
      "endLine": "140",
      "endCol": "8"
    },
    "1172": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js",
      "startLine": "151",
      "startCol": "19",
      "endLine": "155",
      "endCol": "8"
    },
    "1173": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "108",
      "startCol": "5",
      "endLine": "113",
      "endCol": "14"
    },
    "1174": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "116",
      "startCol": "10",
      "endLine": "116",
      "endCol": "44"
    },
    "1175": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "123",
      "startCol": "5",
      "endLine": "123",
      "endCol": "27"
    },
    "1176": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "129",
      "startCol": "36",
      "endLine": "129",
      "endCol": "89"
    },
    "1177": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "137",
      "startCol": "36",
      "endLine": "137",
      "endCol": "97"
    },
    "1178": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "149",
      "startCol": "36",
      "endLine": "149",
      "endCol": "71"
    },
    "1179": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "161",
      "startCol": "36",
      "endLine": "161",
      "endCol": "89"
    },
    "1180": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js",
      "startLine": "181",
      "startCol": "36",
      "endLine": "183",
      "endCol": "7"
    },
    "1181": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "41",
      "startCol": "5",
      "endLine": "44",
      "endCol": "14"
    },
    "1182": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "47",
      "startCol": "10",
      "endLine": "47",
      "endCol": "44"
    },
    "1183": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "53",
      "endCol": "27"
    },
    "1184": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "58",
      "startCol": "19",
      "endLine": "69",
      "endCol": "8"
    },
    "1185": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "86",
      "startCol": "21",
      "endLine": "90",
      "endCol": "10"
    },
    "1186": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "97",
      "startCol": "19",
      "endLine": "105",
      "endCol": "8"
    },
    "1187": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "111",
      "startCol": "19",
      "endLine": "115",
      "endCol": "8"
    },
    "1188": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "121",
      "startCol": "19",
      "endLine": "144",
      "endCol": "8"
    },
    "1189": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "150",
      "startCol": "19",
      "endLine": "152",
      "endCol": "8"
    },
    "1190": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "161",
      "startCol": "19",
      "endLine": "172",
      "endCol": "8"
    },
    "1191": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "174",
      "startCol": "22",
      "endLine": "174",
      "endCol": "52"
    },
    "1192": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "187",
      "startCol": "19",
      "endLine": "187",
      "endCol": "35"
    },
    "1193": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "231",
      "startCol": "21",
      "endLine": "242",
      "endCol": "10"
    },
    "1194": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "244",
      "startCol": "27",
      "endLine": "248",
      "endCol": "10"
    },
    "1195": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "253",
      "startCol": "24",
      "endLine": "253",
      "endCol": "54"
    },
    "1196": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "264",
      "startCol": "19",
      "endLine": "275",
      "endCol": "8"
    },
    "1197": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "284",
      "startCol": "25",
      "endLine": "295",
      "endCol": "8"
    },
    "1198": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "307",
      "startCol": "22",
      "endLine": "307",
      "endCol": "52"
    },
    "1199": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "321",
      "startCol": "19",
      "endLine": "332",
      "endCol": "8"
    },
    "1200": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "334",
      "startCol": "25",
      "endLine": "336",
      "endCol": "8"
    },
    "1201": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "344",
      "startCol": "22",
      "endLine": "344",
      "endCol": "52"
    },
    "1202": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "354",
      "startCol": "19",
      "endLine": "365",
      "endCol": "8"
    },
    "1203": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "367",
      "startCol": "25",
      "endLine": "375",
      "endCol": "8"
    },
    "1204": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "379",
      "startCol": "22",
      "endLine": "379",
      "endCol": "52"
    },
    "1205": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "386",
      "startCol": "19",
      "endLine": "397",
      "endCol": "8"
    },
    "1206": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "399",
      "startCol": "25",
      "endLine": "422",
      "endCol": "8"
    },
    "1207": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "426",
      "startCol": "22",
      "endLine": "426",
      "endCol": "52"
    },
    "1208": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "433",
      "startCol": "19",
      "endLine": "442",
      "endCol": "8"
    },
    "1209": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "444",
      "startCol": "25",
      "endLine": "455",
      "endCol": "8"
    },
    "1210": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "476",
      "startCol": "22",
      "endLine": "476",
      "endCol": "52"
    },
    "1211": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "493",
      "startCol": "19",
      "endLine": "504",
      "endCol": "8"
    },
    "1212": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "506",
      "startCol": "25",
      "endLine": "515",
      "endCol": "8"
    },
    "1213": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "521",
      "startCol": "19",
      "endLine": "535",
      "endCol": "8"
    },
    "1214": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "537",
      "startCol": "25",
      "endLine": "556",
      "endCol": "8"
    },
    "1215": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "582",
      "startCol": "22",
      "endLine": "582",
      "endCol": "52"
    },
    "1216": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "591",
      "startCol": "19",
      "endLine": "605",
      "endCol": "8"
    },
    "1217": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "607",
      "startCol": "25",
      "endLine": "607",
      "endCol": "58"
    },
    "1218": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js",
      "startLine": "612",
      "startCol": "22",
      "endLine": "612",
      "endCol": "52"
    },
    "1219": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "42",
      "endCol": "14"
    },
    "1220": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "45",
      "startCol": "10",
      "endLine": "45",
      "endCol": "44"
    },
    "1221": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "27"
    },
    "1222": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "64",
      "endCol": "8"
    },
    "1223": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "81",
      "startCol": "21",
      "endLine": "85",
      "endCol": "10"
    },
    "1224": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "92",
      "startCol": "19",
      "endLine": "96",
      "endCol": "8"
    },
    "1225": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "103",
      "startCol": "19",
      "endLine": "105",
      "endCol": "8"
    },
    "1226": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "114",
      "startCol": "19",
      "endLine": "125",
      "endCol": "8"
    },
    "1227": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "127",
      "startCol": "22",
      "endLine": "127",
      "endCol": "52"
    },
    "1228": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "140",
      "startCol": "19",
      "endLine": "140",
      "endCol": "35"
    },
    "1229": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "184",
      "startCol": "21",
      "endLine": "192",
      "endCol": "10"
    },
    "1230": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "194",
      "startCol": "27",
      "endLine": "198",
      "endCol": "10"
    },
    "1231": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "203",
      "startCol": "24",
      "endLine": "203",
      "endCol": "54"
    },
    "1232": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "214",
      "startCol": "19",
      "endLine": "225",
      "endCol": "8"
    },
    "1233": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "234",
      "startCol": "25",
      "endLine": "245",
      "endCol": "8"
    },
    "1234": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "257",
      "startCol": "22",
      "endLine": "257",
      "endCol": "52"
    },
    "1235": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "271",
      "startCol": "19",
      "endLine": "282",
      "endCol": "8"
    },
    "1236": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "284",
      "startCol": "25",
      "endLine": "286",
      "endCol": "8"
    },
    "1237": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "294",
      "startCol": "22",
      "endLine": "294",
      "endCol": "52"
    },
    "1238": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "304",
      "startCol": "19",
      "endLine": "312",
      "endCol": "8"
    },
    "1239": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "314",
      "startCol": "25",
      "endLine": "318",
      "endCol": "8"
    },
    "1240": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "328",
      "startCol": "22",
      "endLine": "328",
      "endCol": "52"
    },
    "1241": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "335",
      "startCol": "19",
      "endLine": "343",
      "endCol": "8"
    },
    "1242": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "345",
      "startCol": "25",
      "endLine": "353",
      "endCol": "8"
    },
    "1243": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "371",
      "startCol": "22",
      "endLine": "371",
      "endCol": "52"
    },
    "1244": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "385",
      "startCol": "19",
      "endLine": "393",
      "endCol": "8"
    },
    "1245": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "395",
      "startCol": "25",
      "endLine": "404",
      "endCol": "8"
    },
    "1246": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "410",
      "startCol": "19",
      "endLine": "424",
      "endCol": "8"
    },
    "1247": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "426",
      "startCol": "25",
      "endLine": "445",
      "endCol": "8"
    },
    "1248": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "470",
      "startCol": "22",
      "endLine": "470",
      "endCol": "52"
    },
    "1249": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "479",
      "startCol": "19",
      "endLine": "493",
      "endCol": "8"
    },
    "1250": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "495",
      "startCol": "25",
      "endLine": "495",
      "endCol": "58"
    },
    "1251": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js",
      "startLine": "500",
      "startCol": "22",
      "endLine": "500",
      "endCol": "52"
    },
    "1252": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "41",
      "startCol": "5",
      "endLine": "44",
      "endCol": "14"
    },
    "1253": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "47",
      "startCol": "10",
      "endLine": "47",
      "endCol": "44"
    },
    "1254": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "53",
      "startCol": "5",
      "endLine": "53",
      "endCol": "27"
    },
    "1255": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "58",
      "startCol": "19",
      "endLine": "66",
      "endCol": "8"
    },
    "1256": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "81",
      "startCol": "19",
      "endLine": "89",
      "endCol": "8"
    },
    "1257": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "106",
      "startCol": "21",
      "endLine": "110",
      "endCol": "10"
    },
    "1258": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "117",
      "startCol": "19",
      "endLine": "121",
      "endCol": "8"
    },
    "1259": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "127",
      "startCol": "19",
      "endLine": "150",
      "endCol": "8"
    },
    "1260": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "158",
      "startCol": "19",
      "endLine": "169",
      "endCol": "8"
    },
    "1261": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "171",
      "startCol": "22",
      "endLine": "171",
      "endCol": "52"
    },
    "1262": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "184",
      "startCol": "19",
      "endLine": "184",
      "endCol": "35"
    },
    "1263": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "228",
      "startCol": "21",
      "endLine": "236",
      "endCol": "10"
    },
    "1264": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "238",
      "startCol": "27",
      "endLine": "242",
      "endCol": "10"
    },
    "1265": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "247",
      "startCol": "24",
      "endLine": "247",
      "endCol": "54"
    },
    "1266": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "258",
      "startCol": "19",
      "endLine": "269",
      "endCol": "8"
    },
    "1267": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "278",
      "startCol": "25",
      "endLine": "289",
      "endCol": "8"
    },
    "1268": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "301",
      "startCol": "22",
      "endLine": "301",
      "endCol": "52"
    },
    "1269": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "315",
      "startCol": "19",
      "endLine": "326",
      "endCol": "8"
    },
    "1270": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "328",
      "startCol": "25",
      "endLine": "330",
      "endCol": "8"
    },
    "1271": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "338",
      "startCol": "22",
      "endLine": "338",
      "endCol": "52"
    },
    "1272": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "348",
      "startCol": "19",
      "endLine": "356",
      "endCol": "8"
    },
    "1273": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "358",
      "startCol": "25",
      "endLine": "362",
      "endCol": "8"
    },
    "1274": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "366",
      "startCol": "22",
      "endLine": "366",
      "endCol": "52"
    },
    "1275": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "373",
      "startCol": "19",
      "endLine": "381",
      "endCol": "8"
    },
    "1276": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "383",
      "startCol": "25",
      "endLine": "406",
      "endCol": "8"
    },
    "1277": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "410",
      "startCol": "22",
      "endLine": "410",
      "endCol": "52"
    },
    "1278": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "417",
      "startCol": "19",
      "endLine": "425",
      "endCol": "8"
    },
    "1279": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "427",
      "startCol": "25",
      "endLine": "435",
      "endCol": "8"
    },
    "1280": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "453",
      "startCol": "22",
      "endLine": "453",
      "endCol": "52"
    },
    "1281": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "467",
      "startCol": "19",
      "endLine": "475",
      "endCol": "8"
    },
    "1282": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "477",
      "startCol": "25",
      "endLine": "486",
      "endCol": "8"
    },
    "1283": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "492",
      "startCol": "19",
      "endLine": "506",
      "endCol": "8"
    },
    "1284": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "508",
      "startCol": "25",
      "endLine": "527",
      "endCol": "8"
    },
    "1285": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "552",
      "startCol": "22",
      "endLine": "552",
      "endCol": "52"
    },
    "1286": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "561",
      "startCol": "19",
      "endLine": "575",
      "endCol": "8"
    },
    "1287": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "577",
      "startCol": "25",
      "endLine": "577",
      "endCol": "58"
    },
    "1288": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js",
      "startLine": "582",
      "startCol": "22",
      "endLine": "582",
      "endCol": "52"
    },
    "1289": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "42",
      "endCol": "14"
    },
    "1290": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "45",
      "startCol": "10",
      "endLine": "45",
      "endCol": "44"
    },
    "1291": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "27"
    },
    "1292": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "64",
      "endCol": "8"
    },
    "1293": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "79",
      "startCol": "19",
      "endLine": "87",
      "endCol": "8"
    },
    "1294": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "104",
      "startCol": "21",
      "endLine": "108",
      "endCol": "10"
    },
    "1295": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "115",
      "startCol": "19",
      "endLine": "119",
      "endCol": "8"
    },
    "1296": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "126",
      "startCol": "19",
      "endLine": "128",
      "endCol": "8"
    },
    "1297": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "136",
      "startCol": "19",
      "endLine": "147",
      "endCol": "8"
    },
    "1298": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "149",
      "startCol": "22",
      "endLine": "149",
      "endCol": "52"
    },
    "1299": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "162",
      "startCol": "19",
      "endLine": "162",
      "endCol": "35"
    },
    "1300": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "206",
      "startCol": "21",
      "endLine": "214",
      "endCol": "10"
    },
    "1301": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "216",
      "startCol": "27",
      "endLine": "220",
      "endCol": "10"
    },
    "1302": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "225",
      "startCol": "24",
      "endLine": "225",
      "endCol": "54"
    },
    "1303": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "236",
      "startCol": "19",
      "endLine": "247",
      "endCol": "8"
    },
    "1304": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "256",
      "startCol": "25",
      "endLine": "267",
      "endCol": "8"
    },
    "1305": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "279",
      "startCol": "22",
      "endLine": "279",
      "endCol": "52"
    },
    "1306": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "293",
      "startCol": "19",
      "endLine": "304",
      "endCol": "8"
    },
    "1307": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "306",
      "startCol": "25",
      "endLine": "308",
      "endCol": "8"
    },
    "1308": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "316",
      "startCol": "22",
      "endLine": "316",
      "endCol": "52"
    },
    "1309": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "326",
      "startCol": "19",
      "endLine": "334",
      "endCol": "8"
    },
    "1310": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "336",
      "startCol": "25",
      "endLine": "340",
      "endCol": "8"
    },
    "1311": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "350",
      "startCol": "22",
      "endLine": "350",
      "endCol": "52"
    },
    "1312": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "357",
      "startCol": "19",
      "endLine": "365",
      "endCol": "8"
    },
    "1313": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "367",
      "startCol": "25",
      "endLine": "375",
      "endCol": "8"
    },
    "1314": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "393",
      "startCol": "22",
      "endLine": "393",
      "endCol": "52"
    },
    "1315": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "407",
      "startCol": "19",
      "endLine": "415",
      "endCol": "8"
    },
    "1316": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "417",
      "startCol": "25",
      "endLine": "426",
      "endCol": "8"
    },
    "1317": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "432",
      "startCol": "19",
      "endLine": "446",
      "endCol": "8"
    },
    "1318": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "448",
      "startCol": "25",
      "endLine": "467",
      "endCol": "8"
    },
    "1319": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "492",
      "startCol": "22",
      "endLine": "492",
      "endCol": "52"
    },
    "1320": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "501",
      "startCol": "19",
      "endLine": "515",
      "endCol": "8"
    },
    "1321": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "517",
      "startCol": "25",
      "endLine": "517",
      "endCol": "58"
    },
    "1322": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js",
      "startLine": "522",
      "startCol": "22",
      "endLine": "522",
      "endCol": "52"
    },
    "1323": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "42",
      "endCol": "14"
    },
    "1324": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "45",
      "startCol": "10",
      "endLine": "45",
      "endCol": "44"
    },
    "1325": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "27"
    },
    "1326": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "62",
      "endCol": "8"
    },
    "1327": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "74",
      "startCol": "19",
      "endLine": "80",
      "endCol": "8"
    },
    "1328": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "94",
      "startCol": "21",
      "endLine": "98",
      "endCol": "10"
    },
    "1329": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "105",
      "startCol": "19",
      "endLine": "109",
      "endCol": "8"
    },
    "1330": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "116",
      "startCol": "19",
      "endLine": "118",
      "endCol": "8"
    },
    "1331": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "127",
      "startCol": "19",
      "endLine": "127",
      "endCol": "35"
    },
    "1332": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "159",
      "startCol": "21",
      "endLine": "165",
      "endCol": "10"
    },
    "1333": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "167",
      "startCol": "27",
      "endLine": "171",
      "endCol": "10"
    },
    "1334": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "176",
      "startCol": "24",
      "endLine": "176",
      "endCol": "54"
    },
    "1335": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "187",
      "startCol": "19",
      "endLine": "193",
      "endCol": "8"
    },
    "1336": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "195",
      "startCol": "25",
      "endLine": "197",
      "endCol": "8"
    },
    "1337": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "205",
      "startCol": "22",
      "endLine": "205",
      "endCol": "52"
    },
    "1338": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "215",
      "startCol": "19",
      "endLine": "221",
      "endCol": "8"
    },
    "1339": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "223",
      "startCol": "25",
      "endLine": "227",
      "endCol": "8"
    },
    "1340": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "237",
      "startCol": "22",
      "endLine": "237",
      "endCol": "52"
    },
    "1341": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "244",
      "startCol": "19",
      "endLine": "250",
      "endCol": "8"
    },
    "1342": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "252",
      "startCol": "25",
      "endLine": "258",
      "endCol": "8"
    },
    "1343": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "269",
      "startCol": "22",
      "endLine": "269",
      "endCol": "52"
    },
    "1344": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "281",
      "startCol": "19",
      "endLine": "287",
      "endCol": "8"
    },
    "1345": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "289",
      "startCol": "25",
      "endLine": "296",
      "endCol": "8"
    },
    "1346": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "302",
      "startCol": "19",
      "endLine": "308",
      "endCol": "8"
    },
    "1347": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "310",
      "startCol": "25",
      "endLine": "317",
      "endCol": "8"
    },
    "1348": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "330",
      "startCol": "22",
      "endLine": "330",
      "endCol": "52"
    },
    "1349": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "339",
      "startCol": "19",
      "endLine": "345",
      "endCol": "8"
    },
    "1350": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "347",
      "startCol": "25",
      "endLine": "347",
      "endCol": "58"
    },
    "1351": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js",
      "startLine": "352",
      "startCol": "22",
      "endLine": "352",
      "endCol": "52"
    },
    "1352": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "39",
      "startCol": "5",
      "endLine": "42",
      "endCol": "14"
    },
    "1353": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "45",
      "startCol": "10",
      "endLine": "45",
      "endCol": "44"
    },
    "1354": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "27"
    },
    "1355": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "56",
      "startCol": "19",
      "endLine": "62",
      "endCol": "8"
    },
    "1356": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "74",
      "startCol": "19",
      "endLine": "80",
      "endCol": "8"
    },
    "1357": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "94",
      "startCol": "21",
      "endLine": "98",
      "endCol": "10"
    },
    "1358": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "105",
      "startCol": "19",
      "endLine": "109",
      "endCol": "8"
    },
    "1359": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "115",
      "startCol": "19",
      "endLine": "117",
      "endCol": "8"
    },
    "1360": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "125",
      "startCol": "19",
      "endLine": "125",
      "endCol": "35"
    },
    "1361": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "158",
      "startCol": "21",
      "endLine": "164",
      "endCol": "10"
    },
    "1362": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "166",
      "startCol": "27",
      "endLine": "170",
      "endCol": "10"
    },
    "1363": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "175",
      "startCol": "24",
      "endLine": "175",
      "endCol": "54"
    },
    "1364": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "186",
      "startCol": "19",
      "endLine": "192",
      "endCol": "8"
    },
    "1365": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "194",
      "startCol": "25",
      "endLine": "196",
      "endCol": "8"
    },
    "1366": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "204",
      "startCol": "22",
      "endLine": "204",
      "endCol": "52"
    },
    "1367": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "214",
      "startCol": "19",
      "endLine": "220",
      "endCol": "8"
    },
    "1368": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "222",
      "startCol": "25",
      "endLine": "226",
      "endCol": "8"
    },
    "1369": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "230",
      "startCol": "22",
      "endLine": "230",
      "endCol": "52"
    },
    "1370": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "237",
      "startCol": "19",
      "endLine": "243",
      "endCol": "8"
    },
    "1371": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "245",
      "startCol": "25",
      "endLine": "251",
      "endCol": "8"
    },
    "1372": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "262",
      "startCol": "22",
      "endLine": "262",
      "endCol": "52"
    },
    "1373": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "274",
      "startCol": "19",
      "endLine": "280",
      "endCol": "8"
    },
    "1374": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "282",
      "startCol": "25",
      "endLine": "289",
      "endCol": "8"
    },
    "1375": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "295",
      "startCol": "19",
      "endLine": "301",
      "endCol": "8"
    },
    "1376": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "303",
      "startCol": "25",
      "endLine": "310",
      "endCol": "8"
    },
    "1377": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "323",
      "startCol": "22",
      "endLine": "323",
      "endCol": "52"
    },
    "1378": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "332",
      "startCol": "19",
      "endLine": "338",
      "endCol": "8"
    },
    "1379": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "340",
      "startCol": "25",
      "endLine": "340",
      "endCol": "58"
    },
    "1380": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js",
      "startLine": "345",
      "startCol": "22",
      "endLine": "345",
      "endCol": "52"
    },
    "1381": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "32",
      "startCol": "5",
      "endLine": "32",
      "endCol": "47"
    },
    "1382": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "35",
      "startCol": "10",
      "endLine": "35",
      "endCol": "44"
    },
    "1383": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "40",
      "startCol": "5",
      "endLine": "40",
      "endCol": "27"
    },
    "1384": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "45",
      "startCol": "19",
      "endLine": "49",
      "endCol": "8"
    },
    "1385": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "65",
      "startCol": "19",
      "endLine": "73",
      "endCol": "8"
    },
    "1386": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "85",
      "startCol": "19",
      "endLine": "93",
      "endCol": "8"
    },
    "1387": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "107",
      "startCol": "19",
      "endLine": "115",
      "endCol": "8"
    },
    "1388": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "120",
      "startCol": "7",
      "endLine": "126",
      "endCol": "8"
    },
    "1389": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "128",
      "startCol": "25",
      "endLine": "136",
      "endCol": "8"
    },
    "1390": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "143",
      "startCol": "19",
      "endLine": "153",
      "endCol": "8"
    },
    "1391": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "158",
      "startCol": "7",
      "endLine": "164",
      "endCol": "8"
    },
    "1392": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "166",
      "startCol": "25",
      "endLine": "176",
      "endCol": "8"
    },
    "1393": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "183",
      "startCol": "19",
      "endLine": "193",
      "endCol": "8"
    },
    "1394": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "198",
      "startCol": "7",
      "endLine": "204",
      "endCol": "8"
    },
    "1395": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "206",
      "startCol": "25",
      "endLine": "216",
      "endCol": "8"
    },
    "1396": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "221",
      "startCol": "7",
      "endLine": "227",
      "endCol": "8"
    },
    "1397": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "229",
      "startCol": "24",
      "endLine": "239",
      "endCol": "8"
    },
    "1398": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "248",
      "startCol": "19",
      "endLine": "252",
      "endCol": "8"
    },
    "1399": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "268",
      "startCol": "19",
      "endLine": "276",
      "endCol": "8"
    },
    "1400": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "287",
      "startCol": "19",
      "endLine": "295",
      "endCol": "8"
    },
    "1401": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "307",
      "startCol": "19",
      "endLine": "315",
      "endCol": "8"
    },
    "1402": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "329",
      "startCol": "19",
      "endLine": "337",
      "endCol": "8"
    },
    "1403": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "348",
      "startCol": "7",
      "endLine": "354",
      "endCol": "8"
    },
    "1404": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js",
      "startLine": "356",
      "startCol": "19",
      "endLine": "364",
      "endCol": "8"
    },
    "1405": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "86",
      "startCol": "5",
      "endLine": "90",
      "endCol": "14"
    },
    "1406": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "93",
      "startCol": "10",
      "endLine": "93",
      "endCol": "44"
    },
    "1407": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "99",
      "startCol": "5",
      "endLine": "99",
      "endCol": "27"
    },
    "1408": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "104",
      "startCol": "19",
      "endLine": "121",
      "endCol": "8"
    },
    "1409": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "145",
      "startCol": "19",
      "endLine": "151",
      "endCol": "8"
    },
    "1410": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "159",
      "startCol": "19",
      "endLine": "170",
      "endCol": "8"
    },
    "1411": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "176",
      "startCol": "19",
      "endLine": "185",
      "endCol": "8"
    },
    "1412": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "193",
      "startCol": "25",
      "endLine": "193",
      "endCol": "43"
    },
    "1413": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "196",
      "startCol": "19",
      "endLine": "196",
      "endCol": "65"
    },
    "1414": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "222",
      "startCol": "19",
      "endLine": "222",
      "endCol": "55"
    },
    "1415": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "262",
      "startCol": "25",
      "endLine": "262",
      "endCol": "43"
    },
    "1416": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "267",
      "startCol": "19",
      "endLine": "273",
      "endCol": "8"
    },
    "1417": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "281",
      "startCol": "25",
      "endLine": "281",
      "endCol": "43"
    },
    "1418": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "286",
      "startCol": "19",
      "endLine": "290",
      "endCol": "8"
    },
    "1419": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "314",
      "startCol": "25",
      "endLine": "314",
      "endCol": "43"
    },
    "1420": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "319",
      "startCol": "19",
      "endLine": "334",
      "endCol": "8"
    },
    "1421": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "355",
      "startCol": "25",
      "endLine": "355",
      "endCol": "43"
    },
    "1422": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "360",
      "startCol": "19",
      "endLine": "371",
      "endCol": "8"
    },
    "1423": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "377",
      "startCol": "25",
      "endLine": "377",
      "endCol": "43"
    },
    "1424": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "382",
      "startCol": "19",
      "endLine": "391",
      "endCol": "8"
    },
    "1425": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "399",
      "startCol": "25",
      "endLine": "399",
      "endCol": "43"
    },
    "1426": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js",
      "startLine": "404",
      "startCol": "19",
      "endLine": "404",
      "endCol": "68"
    },
    "1427": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "77",
      "startCol": "5",
      "endLine": "82",
      "endCol": "14"
    },
    "1428": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "86",
      "startCol": "14",
      "endLine": "86",
      "endCol": "48"
    },
    "1429": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "88",
      "startCol": "10",
      "endLine": "88",
      "endCol": "44"
    },
    "1430": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "94",
      "startCol": "5",
      "endLine": "94",
      "endCol": "27"
    },
    "1431": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "99",
      "startCol": "22",
      "endLine": "99",
      "endCol": "38"
    },
    "1432": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "104",
      "startCol": "19",
      "endLine": "119",
      "endCol": "8"
    },
    "1433": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "148",
      "startCol": "22",
      "endLine": "148",
      "endCol": "38"
    },
    "1434": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "153",
      "startCol": "19",
      "endLine": "168",
      "endCol": "8"
    },
    "1435": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "173",
      "startCol": "25",
      "endLine": "173",
      "endCol": "41"
    },
    "1436": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "177",
      "startCol": "25",
      "endLine": "192",
      "endCol": "8"
    },
    "1437": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "219",
      "startCol": "22",
      "endLine": "219",
      "endCol": "38"
    },
    "1438": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "224",
      "startCol": "19",
      "endLine": "239",
      "endCol": "8"
    },
    "1439": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "243",
      "startCol": "22",
      "endLine": "243",
      "endCol": "72"
    },
    "1440": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "271",
      "startCol": "22",
      "endLine": "271",
      "endCol": "38"
    },
    "1441": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js",
      "startLine": "276",
      "startCol": "19",
      "endLine": "292",
      "endCol": "8"
    },
    "1442": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1443": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1444": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1445": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "35",
      "startCol": "17",
      "endLine": "42",
      "endCol": "5"
    },
    "1446": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "52",
      "startCol": "17",
      "endLine": "59",
      "endCol": "5"
    },
    "1447": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "68",
      "startCol": "17",
      "endLine": "70",
      "endCol": "5"
    },
    "1448": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "82",
      "startCol": "17",
      "endLine": "89",
      "endCol": "5"
    },
    "1449": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js",
      "startLine": "92",
      "startCol": "23",
      "endLine": "99",
      "endCol": "5"
    },
    "1450": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1451": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1452": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1453": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1454": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "50",
      "startCol": "15",
      "endLine": "55",
      "endCol": "5"
    },
    "1455": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "61",
      "startCol": "15",
      "endLine": "66",
      "endCol": "5"
    },
    "1456": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "73",
      "startCol": "11",
      "endLine": "75",
      "endCol": "6"
    },
    "1457": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "84",
      "startCol": "17",
      "endLine": "86",
      "endCol": "5"
    },
    "1458": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "97",
      "startCol": "17",
      "endLine": "104",
      "endCol": "5"
    },
    "1459": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js",
      "startLine": "106",
      "startCol": "23",
      "endLine": "113",
      "endCol": "5"
    },
    "1460": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1461": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1462": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1463": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "38",
      "endCol": "6"
    },
    "1464": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "56",
      "startCol": "17",
      "endLine": "60",
      "endCol": "6"
    },
    "1465": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "71",
      "startCol": "19",
      "endLine": "78",
      "endCol": "7"
    },
    "1466": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "85",
      "startCol": "17",
      "endLine": "85",
      "endCol": "96"
    },
    "1467": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "98",
      "startCol": "17",
      "endLine": "102",
      "endCol": "6"
    },
    "1468": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js",
      "startLine": "105",
      "startCol": "23",
      "endLine": "112",
      "endCol": "5"
    },
    "1469": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1470": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1471": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1472": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1473": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "52",
      "startCol": "17",
      "endLine": "59",
      "endCol": "5"
    },
    "1474": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "70",
      "startCol": "17",
      "endLine": "77",
      "endCol": "5"
    },
    "1475": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "86",
      "startCol": "17",
      "endLine": "93",
      "endCol": "5"
    },
    "1476": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "99",
      "startCol": "17",
      "endLine": "101",
      "endCol": "5"
    },
    "1477": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "114",
      "startCol": "17",
      "endLine": "121",
      "endCol": "5"
    },
    "1478": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js",
      "startLine": "124",
      "startCol": "23",
      "endLine": "131",
      "endCol": "5"
    },
    "1479": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1480": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1481": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1482": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "35",
      "startCol": "17",
      "endLine": "42",
      "endCol": "5"
    },
    "1483": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "52",
      "startCol": "17",
      "endLine": "59",
      "endCol": "5"
    },
    "1484": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "68",
      "startCol": "17",
      "endLine": "70",
      "endCol": "5"
    },
    "1485": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "81",
      "startCol": "17",
      "endLine": "88",
      "endCol": "5"
    },
    "1486": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js",
      "startLine": "90",
      "startCol": "23",
      "endLine": "97",
      "endCol": "5"
    },
    "1487": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1488": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1489": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1490": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1491": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "50",
      "startCol": "17",
      "endLine": "57",
      "endCol": "5"
    },
    "1492": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "63",
      "startCol": "17",
      "endLine": "70",
      "endCol": "5"
    },
    "1493": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "79",
      "endCol": "98"
    },
    "1494": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "93",
      "startCol": "17",
      "endLine": "100",
      "endCol": "5"
    },
    "1495": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js",
      "startLine": "102",
      "startCol": "23",
      "endLine": "109",
      "endCol": "5"
    },
    "1496": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "23",
      "startCol": "5",
      "endLine": "23",
      "endCol": "44"
    },
    "1497": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "26",
      "startCol": "10",
      "endLine": "26",
      "endCol": "44"
    },
    "1498": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "31",
      "startCol": "5",
      "endLine": "31",
      "endCol": "27"
    },
    "1499": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "35",
      "startCol": "17",
      "endLine": "42",
      "endCol": "5"
    },
    "1500": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "51",
      "startCol": "17",
      "endLine": "53",
      "endCol": "5"
    },
    "1501": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "64",
      "startCol": "17",
      "endLine": "71",
      "endCol": "5"
    },
    "1502": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "73",
      "startCol": "23",
      "endLine": "80",
      "endCol": "5"
    },
    "1503": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "90",
      "startCol": "17",
      "endLine": "97",
      "endCol": "5"
    },
    "1504": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js",
      "startLine": "106",
      "startCol": "17",
      "endLine": "113",
      "endCol": "5"
    },
    "1505": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1506": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1507": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1508": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "35",
      "startCol": "17",
      "endLine": "42",
      "endCol": "5"
    },
    "1509": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "52",
      "startCol": "17",
      "endLine": "59",
      "endCol": "5"
    },
    "1510": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "68",
      "startCol": "17",
      "endLine": "68",
      "endCol": "98"
    },
    "1511": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "86",
      "endCol": "5"
    },
    "1512": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js",
      "startLine": "88",
      "startCol": "23",
      "endLine": "95",
      "endCol": "5"
    },
    "1513": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1514": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1515": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1516": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1517": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "51",
      "startCol": "17",
      "endLine": "58",
      "endCol": "5"
    },
    "1518": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "67",
      "startCol": "17",
      "endLine": "69",
      "endCol": "5"
    },
    "1519": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "80",
      "startCol": "17",
      "endLine": "87",
      "endCol": "5"
    },
    "1520": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js",
      "startLine": "89",
      "startCol": "24",
      "endLine": "96",
      "endCol": "5"
    },
    "1521": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1522": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1523": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1524": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "37",
      "startCol": "17",
      "endLine": "41",
      "endCol": "6"
    },
    "1525": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "58",
      "startCol": "17",
      "endLine": "62",
      "endCol": "6"
    },
    "1526": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "71",
      "startCol": "17",
      "endLine": "71",
      "endCol": "96"
    },
    "1527": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "86",
      "startCol": "17",
      "endLine": "92",
      "endCol": "6"
    },
    "1528": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js",
      "startLine": "94",
      "startCol": "23",
      "endLine": "103",
      "endCol": "5"
    },
    "1529": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1530": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1531": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1532": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1533": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "50",
      "startCol": "17",
      "endLine": "57",
      "endCol": "5"
    },
    "1534": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "64",
      "startCol": "17",
      "endLine": "66",
      "endCol": "5"
    },
    "1535": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "76",
      "startCol": "17",
      "endLine": "83",
      "endCol": "5"
    },
    "1536": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js",
      "startLine": "85",
      "startCol": "23",
      "endLine": "92",
      "endCol": "5"
    },
    "1537": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1538": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1539": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1540": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1541": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "50",
      "startCol": "17",
      "endLine": "52",
      "endCol": "5"
    },
    "1542": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "63",
      "startCol": "17",
      "endLine": "68",
      "endCol": "5"
    },
    "1543": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js",
      "startLine": "70",
      "startCol": "23",
      "endLine": "75",
      "endCol": "5"
    },
    "1544": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1545": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1546": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1547": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "41",
      "endCol": "5"
    },
    "1548": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "50",
      "startCol": "17",
      "endLine": "52",
      "endCol": "5"
    },
    "1549": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "63",
      "startCol": "17",
      "endLine": "68",
      "endCol": "5"
    },
    "1550": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js",
      "startLine": "70",
      "startCol": "23",
      "endLine": "75",
      "endCol": "5"
    },
    "1551": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1552": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1553": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1554": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "38",
      "endCol": "6"
    },
    "1555": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "47",
      "startCol": "17",
      "endLine": "47",
      "endCol": "96"
    },
    "1556": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "58",
      "startCol": "17",
      "endLine": "60",
      "endCol": "6"
    },
    "1557": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js",
      "startLine": "62",
      "startCol": "23",
      "endLine": "67",
      "endCol": "5"
    },
    "1558": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "22",
      "startCol": "5",
      "endLine": "22",
      "endCol": "44"
    },
    "1559": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "25",
      "startCol": "10",
      "endLine": "25",
      "endCol": "44"
    },
    "1560": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "30",
      "endCol": "27"
    },
    "1561": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "34",
      "startCol": "17",
      "endLine": "38",
      "endCol": "6"
    },
    "1562": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "49",
      "startCol": "19",
      "endLine": "56",
      "endCol": "7"
    },
    "1563": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "65",
      "startCol": "19",
      "endLine": "72",
      "endCol": "7"
    },
    "1564": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "79",
      "startCol": "17",
      "endLine": "79",
      "endCol": "96"
    },
    "1565": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "89",
      "startCol": "17",
      "endLine": "93",
      "endCol": "6"
    },
    "1566": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js",
      "startLine": "95",
      "startCol": "23",
      "endLine": "102",
      "endCol": "5"
    },
    "1567": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "24",
      "startCol": "7",
      "endLine": "24",
      "endCol": "49"
    },
    "1568": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "27",
      "startCol": "12",
      "endLine": "27",
      "endCol": "46"
    },
    "1569": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "32",
      "startCol": "7",
      "endLine": "32",
      "endCol": "29"
    },
    "1570": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "36",
      "startCol": "19",
      "endLine": "40",
      "endCol": "8"
    },
    "1571": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "49",
      "startCol": "19",
      "endLine": "53",
      "endCol": "8"
    },
    "1572": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "60",
      "startCol": "27",
      "endLine": "67",
      "endCol": "7"
    },
    "1573": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "73",
      "startCol": "19",
      "endLine": "77",
      "endCol": "8"
    },
    "1574": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "100",
      "startCol": "7",
      "endLine": "100",
      "endCol": "49"
    },
    "1575": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "103",
      "startCol": "12",
      "endLine": "103",
      "endCol": "46"
    },
    "1576": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "108",
      "startCol": "7",
      "endLine": "108",
      "endCol": "29"
    },
    "1577": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "112",
      "startCol": "19",
      "endLine": "119",
      "endCol": "7"
    },
    "1578": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "128",
      "startCol": "19",
      "endLine": "135",
      "endCol": "7"
    },
    "1579": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "142",
      "startCol": "27",
      "endLine": "149",
      "endCol": "7"
    },
    "1580": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js",
      "startLine": "155",
      "startCol": "19",
      "endLine": "162",
      "endCol": "7"
    },
    "1581": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "31",
      "startCol": "5",
      "endLine": "37",
      "endCol": "6"
    },
    "1582": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "43",
      "startCol": "5",
      "endLine": "48",
      "endCol": "14"
    },
    "1583": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "51",
      "startCol": "10",
      "endLine": "51",
      "endCol": "44"
    },
    "1584": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "56",
      "startCol": "5",
      "endLine": "56",
      "endCol": "27"
    },
    "1585": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "61",
      "startCol": "19",
      "endLine": "64",
      "endCol": "8"
    },
    "1586": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "102",
      "startCol": "22",
      "endLine": "108",
      "endCol": "8"
    },
    "1587": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "121",
      "startCol": "22",
      "endLine": "127",
      "endCol": "8"
    },
    "1588": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "140",
      "startCol": "22",
      "endLine": "146",
      "endCol": "8"
    },
    "1589": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "165",
      "startCol": "22",
      "endLine": "169",
      "endCol": "8"
    },
    "1590": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "190",
      "startCol": "22",
      "endLine": "194",
      "endCol": "8"
    },
    "1591": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "216",
      "startCol": "22",
      "endLine": "220",
      "endCol": "8"
    },
    "1592": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "242",
      "startCol": "22",
      "endLine": "246",
      "endCol": "8"
    },
    "1593": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "266",
      "startCol": "22",
      "endLine": "270",
      "endCol": "8"
    },
    "1594": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "291",
      "startCol": "22",
      "endLine": "295",
      "endCol": "8"
    },
    "1595": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "310",
      "startCol": "36",
      "endLine": "316",
      "endCol": "8"
    },
    "1596": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "318",
      "startCol": "35",
      "endLine": "326",
      "endCol": "8"
    },
    "1597": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "328",
      "startCol": "36",
      "endLine": "331",
      "endCol": "8"
    },
    "1598": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "333",
      "startCol": "35",
      "endLine": "341",
      "endCol": "8"
    },
    "1599": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "350",
      "startCol": "32",
      "endLine": "353",
      "endCol": "8"
    },
    "1600": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "358",
      "startCol": "7",
      "endLine": "364",
      "endCol": "8"
    },
    "1601": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "366",
      "startCol": "33",
      "endLine": "369",
      "endCol": "8"
    },
    "1602": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "389",
      "startCol": "36",
      "endLine": "395",
      "endCol": "8"
    },
    "1603": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "403",
      "startCol": "22",
      "endLine": "407",
      "endCol": "8"
    },
    "1604": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "433",
      "startCol": "22",
      "endLine": "439",
      "endCol": "8"
    },
    "1605": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "452",
      "startCol": "22",
      "endLine": "458",
      "endCol": "8"
    },
    "1606": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "477",
      "startCol": "22",
      "endLine": "481",
      "endCol": "8"
    },
    "1607": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "501",
      "startCol": "22",
      "endLine": "505",
      "endCol": "8"
    },
    "1608": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "524",
      "startCol": "22",
      "endLine": "528",
      "endCol": "8"
    },
    "1609": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "547",
      "startCol": "22",
      "endLine": "551",
      "endCol": "8"
    },
    "1610": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "570",
      "startCol": "22",
      "endLine": "574",
      "endCol": "8"
    },
    "1611": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "592",
      "startCol": "22",
      "endLine": "596",
      "endCol": "8"
    },
    "1612": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "609",
      "startCol": "22",
      "endLine": "612",
      "endCol": "8"
    },
    "1613": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "621",
      "startCol": "22",
      "endLine": "624",
      "endCol": "8"
    },
    "1614": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "633",
      "startCol": "22",
      "endLine": "636",
      "endCol": "8"
    },
    "1615": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "645",
      "startCol": "22",
      "endLine": "648",
      "endCol": "8"
    },
    "1616": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "658",
      "startCol": "22",
      "endLine": "661",
      "endCol": "8"
    },
    "1617": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "684",
      "startCol": "22",
      "endLine": "690",
      "endCol": "8"
    },
    "1618": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "706",
      "startCol": "22",
      "endLine": "710",
      "endCol": "8"
    },
    "1619": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "729",
      "startCol": "22",
      "endLine": "733",
      "endCol": "8"
    },
    "1620": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "752",
      "startCol": "22",
      "endLine": "756",
      "endCol": "8"
    },
    "1621": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "771",
      "startCol": "37",
      "endLine": "777",
      "endCol": "8"
    },
    "1622": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "779",
      "startCol": "43",
      "endLine": "786",
      "endCol": "8"
    },
    "1623": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "792",
      "startCol": "37",
      "endLine": "798",
      "endCol": "8"
    },
    "1624": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "800",
      "startCol": "43",
      "endLine": "807",
      "endCol": "8"
    },
    "1625": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "811",
      "startCol": "43",
      "endLine": "817",
      "endCol": "8"
    },
    "1626": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "823",
      "startCol": "37",
      "endLine": "829",
      "endCol": "8"
    },
    "1627": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "831",
      "startCol": "43",
      "endLine": "838",
      "endCol": "8"
    },
    "1628": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "840",
      "startCol": "7",
      "endLine": "843",
      "endCol": "8"
    },
    "1629": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/index.test.e2e.js",
      "startLine": "845",
      "startCol": "40",
      "endLine": "848",
      "endCol": "8"
    },
    "1630": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "93",
      "startCol": "7",
      "endLine": "97",
      "endCol": "16"
    },
    "1631": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "100",
      "startCol": "12",
      "endLine": "100",
      "endCol": "46"
    },
    "1632": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "108",
      "startCol": "7",
      "endLine": "108",
      "endCol": "29"
    },
    "1633": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "112",
      "startCol": "19",
      "endLine": "115",
      "endCol": "8"
    },
    "1634": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "124",
      "startCol": "19",
      "endLine": "130",
      "endCol": "8"
    },
    "1635": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "141",
      "startCol": "7",
      "endLine": "145",
      "endCol": "16"
    },
    "1636": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "148",
      "startCol": "12",
      "endLine": "148",
      "endCol": "46"
    },
    "1637": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "156",
      "startCol": "7",
      "endLine": "156",
      "endCol": "29"
    },
    "1638": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "160",
      "startCol": "19",
      "endLine": "163",
      "endCol": "8"
    },
    "1639": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js",
      "startLine": "179",
      "startCol": "19",
      "endLine": "185",
      "endCol": "8"
    },
    "1640": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "121",
      "startCol": "5",
      "endLine": "124",
      "endCol": "14"
    },
    "1641": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "127",
      "startCol": "10",
      "endLine": "127",
      "endCol": "44"
    },
    "1642": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "134",
      "startCol": "5",
      "endLine": "134",
      "endCol": "27"
    },
    "1643": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "139",
      "startCol": "19",
      "endLine": "145",
      "endCol": "8"
    },
    "1644": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "153",
      "startCol": "19",
      "endLine": "159",
      "endCol": "8"
    },
    "1645": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "167",
      "startCol": "19",
      "endLine": "173",
      "endCol": "8"
    },
    "1646": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "181",
      "startCol": "19",
      "endLine": "187",
      "endCol": "8"
    },
    "1647": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "197",
      "startCol": "19",
      "endLine": "204",
      "endCol": "8"
    },
    "1648": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "211",
      "startCol": "19",
      "endLine": "218",
      "endCol": "8"
    },
    "1649": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "225",
      "startCol": "19",
      "endLine": "229",
      "endCol": "8"
    },
    "1650": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/search.test.e2e.js",
      "startLine": "236",
      "startCol": "19",
      "endLine": "243",
      "endCol": "8"
    },
    "1651": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "25",
      "startCol": "5",
      "endLine": "25",
      "endCol": "44"
    },
    "1652": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "28",
      "startCol": "10",
      "endLine": "28",
      "endCol": "44"
    },
    "1653": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "33",
      "startCol": "5",
      "endLine": "33",
      "endCol": "27"
    },
    "1654": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "37",
      "startCol": "17",
      "endLine": "40",
      "endCol": "6"
    },
    "1655": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "55",
      "startCol": "17",
      "endLine": "58",
      "endCol": "6"
    },
    "1656": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "64",
      "startCol": "17",
      "endLine": "70",
      "endCol": "6"
    },
    "1657": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js",
      "startLine": "80",
      "startCol": "17",
      "endLine": "83",
      "endCol": "6"
    },
    "1658": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-manager/utils/wrap-bad-request.js",
      "startLine": "5",
      "startCol": "5",
      "endLine": "5",
      "endCol": "21"
    },
    "1659": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "80",
      "startCol": "11",
      "endLine": "87",
      "endCol": "7"
    },
    "1660": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "229",
      "startCol": "9",
      "endLine": "229",
      "endCol": "61"
    },
    "1661": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "278",
      "startCol": "9",
      "endLine": "278",
      "endCol": "61"
    },
    "1662": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "313",
      "startCol": "7",
      "endLine": "313",
      "endCol": "62"
    },
    "1663": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "447",
      "startCol": "7",
      "endLine": "447",
      "endCol": "55"
    },
    "1664": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "495",
      "startCol": "7",
      "endLine": "495",
      "endCol": "28"
    },
    "1665": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js",
      "startLine": "500",
      "startCol": "5",
      "endLine": "500",
      "endCol": "32"
    },
    "1666": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/FormModal/index.js",
      "startLine": "459",
      "startCol": "5",
      "endLine": "459",
      "endCol": "64"
    },
    "1667": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/admin/src/containers/LeftMenu/index.js",
      "startLine": "94",
      "startCol": "7",
      "endLine": "94",
      "endCol": "18"
    },
    "1668": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ComponentCategories.js",
      "startLine": "10",
      "startCol": "7",
      "endLine": "10",
      "endCol": "43"
    },
    "1669": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ComponentCategories.js",
      "startLine": "22",
      "startCol": "21",
      "endLine": "22",
      "endCol": "75"
    },
    "1670": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ComponentCategories.js",
      "startLine": "37",
      "startCol": "5",
      "endLine": "37",
      "endCol": "55"
    },
    "1671": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/Components.js",
      "startLine": "60",
      "startCol": "7",
      "endLine": "60",
      "endCol": "40"
    },
    "1672": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/Components.js",
      "startLine": "71",
      "startCol": "25",
      "endLine": "74",
      "endCol": "8"
    },
    "1673": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/Components.js",
      "startLine": "99",
      "startCol": "7",
      "endLine": "99",
      "endCol": "46"
    },
    "1674": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/Components.js",
      "startLine": "110",
      "startCol": "25",
      "endLine": "113",
      "endCol": "8"
    },
    "1675": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/Components.js",
      "startLine": "142",
      "startCol": "25",
      "endLine": "142",
      "endCol": "67"
    },
    "1676": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "16",
      "startCol": "7",
      "endLine": "16",
      "endCol": "30"
    },
    "1677": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "50",
      "startCol": "7",
      "endLine": "50",
      "endCol": "42"
    },
    "1678": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "60",
      "startCol": "27",
      "endLine": "63",
      "endCol": "8"
    },
    "1679": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "66",
      "startCol": "9",
      "endLine": "66",
      "endCol": "92"
    },
    "1680": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "68",
      "startCol": "9",
      "endLine": "68",
      "endCol": "87"
    },
    "1681": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "76",
      "startCol": "7",
      "endLine": "76",
      "endCol": "86"
    },
    "1682": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "90",
      "startCol": "7",
      "endLine": "90",
      "endCol": "48"
    },
    "1683": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "100",
      "startCol": "25",
      "endLine": "103",
      "endCol": "8"
    },
    "1684": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js",
      "startLine": "126",
      "startCol": "25",
      "endLine": "126",
      "endCol": "71"
    },
    "1685": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "30",
      "startCol": "7",
      "endLine": "30",
      "endCol": "63"
    },
    "1686": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "34",
      "startCol": "7",
      "endLine": "34",
      "endCol": "74"
    },
    "1687": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "35",
      "startCol": "7",
      "endLine": "35",
      "endCol": "82"
    },
    "1688": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "39",
      "startCol": "7",
      "endLine": "39",
      "endCol": "59"
    },
    "1689": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "57",
      "startCol": "7",
      "endLine": "63",
      "endCol": "8"
    },
    "1690": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "80",
      "startCol": "7",
      "endLine": "84",
      "endCol": "8"
    },
    "1691": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "128",
      "startCol": "7",
      "endLine": "132",
      "endCol": "8"
    },
    "1692": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js",
      "startLine": "150",
      "startCol": "7",
      "endLine": "152",
      "endCol": "8"
    },
    "1693": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ComponentCategories.js",
      "startLine": "48",
      "startCol": "3",
      "endLine": "48",
      "endCol": "28"
    },
    "1694": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ComponentCategories.js",
      "startLine": "70",
      "startCol": "3",
      "endLine": "70",
      "endCol": "28"
    },
    "1695": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/Components.js",
      "startLine": "54",
      "startCol": "3",
      "endLine": "54",
      "endCol": "28"
    },
    "1696": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/Components.js",
      "startLine": "83",
      "startCol": "3",
      "endLine": "83",
      "endCol": "28"
    },
    "1697": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/Components.js",
      "startLine": "92",
      "startCol": "3",
      "endLine": "92",
      "endCol": "28"
    },
    "1698": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "71",
      "startCol": "3",
      "endLine": "71",
      "endCol": "28"
    },
    "1699": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "121",
      "startCol": "5",
      "endLine": "121",
      "endCol": "30"
    },
    "1700": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "165",
      "startCol": "24",
      "endLine": "165",
      "endCol": "54"
    },
    "1701": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "201",
      "startCol": "7",
      "endLine": "201",
      "endCol": "32"
    },
    "1702": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "210",
      "startCol": "3",
      "endLine": "210",
      "endCol": "28"
    },
    "1703": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "221",
      "startCol": "3",
      "endLine": "221",
      "endCol": "28"
    },
    "1704": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/ContentTypes.js",
      "startLine": "246",
      "startCol": "7",
      "endLine": "246",
      "endCol": "32"
    },
    "1705": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "34",
      "startCol": "3",
      "endLine": "34",
      "endCol": "41"
    },
    "1706": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "47",
      "startCol": "3",
      "endLine": "47",
      "endCol": "35"
    },
    "1707": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "49",
      "startCol": "16",
      "endLine": "49",
      "endCol": "46"
    },
    "1708": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "51",
      "startCol": "5",
      "endLine": "51",
      "endCol": "34"
    },
    "1709": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "65",
      "startCol": "18",
      "endLine": "65",
      "endCol": "47"
    },
    "1710": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "71",
      "startCol": "3",
      "endLine": "71",
      "endCol": "29"
    },
    "1711": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "72",
      "startCol": "3",
      "endLine": "72",
      "endCol": "41"
    },
    "1712": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "94",
      "startCol": "26",
      "endLine": "94",
      "endCol": "53"
    },
    "1713": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "102",
      "startCol": "7",
      "endLine": "110",
      "endCol": "7"
    },
    "1714": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "134",
      "startCol": "21",
      "endLine": "134",
      "endCol": "45"
    },
    "1715": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "139",
      "startCol": "18",
      "endLine": "139",
      "endCol": "41"
    },
    "1716": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "144",
      "startCol": "7",
      "endLine": "144",
      "endCol": "30"
    },
    "1717": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "148",
      "startCol": "17",
      "endLine": "148",
      "endCol": "41"
    },
    "1718": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/api-handler.js",
      "startLine": "150",
      "startCol": "5",
      "endLine": "150",
      "endCol": "28"
    },
    "1719": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "216",
      "startCol": "9",
      "endLine": "216",
      "endCol": "37"
    },
    "1720": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "218",
      "startCol": "22",
      "endLine": "218",
      "endCol": "56"
    },
    "1721": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "220",
      "startCol": "11",
      "endLine": "220",
      "endCol": "44"
    },
    "1722": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "227",
      "startCol": "9",
      "endLine": "227",
      "endCol": "38"
    },
    "1723": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "229",
      "startCol": "9",
      "endLine": "240",
      "endCol": "9"
    },
    "1724": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "244",
      "startCol": "11",
      "endLine": "244",
      "endCol": "39"
    },
    "1725": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "246",
      "startCol": "24",
      "endLine": "246",
      "endCol": "58"
    },
    "1726": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "248",
      "startCol": "13",
      "endLine": "248",
      "endCol": "46"
    },
    "1727": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "269",
      "startCol": "9",
      "endLine": "269",
      "endCol": "34"
    },
    "1728": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "271",
      "startCol": "22",
      "endLine": "271",
      "endCol": "49"
    },
    "1729": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "273",
      "startCol": "11",
      "endLine": "273",
      "endCol": "37"
    },
    "1730": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "279",
      "startCol": "9",
      "endLine": "279",
      "endCol": "41"
    },
    "1731": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "280",
      "startCol": "9",
      "endLine": "280",
      "endCol": "76"
    },
    "1732": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "284",
      "startCol": "11",
      "endLine": "284",
      "endCol": "36"
    },
    "1733": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "286",
      "startCol": "24",
      "endLine": "286",
      "endCol": "51"
    },
    "1734": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js",
      "startLine": "288",
      "startCol": "13",
      "endLine": "288",
      "endCol": "39"
    },
    "1735": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "12",
      "startCol": "8",
      "endLine": "12",
      "endCol": "42"
    },
    "1736": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "18",
      "startCol": "10",
      "endLine": "18",
      "endCol": "44"
    },
    "1737": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "27",
      "startCol": "19",
      "endLine": "33",
      "endCol": "8"
    },
    "1738": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "47",
      "startCol": "19",
      "endLine": "65",
      "endCol": "8"
    },
    "1739": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "78",
      "startCol": "19",
      "endLine": "89",
      "endCol": "8"
    },
    "1740": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "100",
      "startCol": "19",
      "endLine": "103",
      "endCol": "8"
    },
    "1741": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "127",
      "startCol": "19",
      "endLine": "130",
      "endCol": "8"
    },
    "1742": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "139",
      "startCol": "19",
      "endLine": "142",
      "endCol": "8"
    },
    "1743": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "173",
      "startCol": "19",
      "endLine": "176",
      "endCol": "8"
    },
    "1744": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "185",
      "startCol": "19",
      "endLine": "193",
      "endCol": "8"
    },
    "1745": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "206",
      "startCol": "19",
      "endLine": "217",
      "endCol": "8"
    },
    "1746": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "228",
      "startCol": "22",
      "endLine": "231",
      "endCol": "8"
    },
    "1747": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "247",
      "startCol": "19",
      "endLine": "250",
      "endCol": "8"
    },
    "1748": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "259",
      "startCol": "19",
      "endLine": "262",
      "endCol": "8"
    },
    "1749": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js",
      "startLine": "273",
      "startCol": "22",
      "endLine": "276",
      "endCol": "8"
    },
    "1750": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "16",
      "startCol": "8",
      "endLine": "16",
      "endCol": "42"
    },
    "1751": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "22",
      "startCol": "10",
      "endLine": "22",
      "endCol": "44"
    },
    "1752": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "48",
      "startCol": "19",
      "endLine": "61",
      "endCol": "8"
    },
    "1753": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "72",
      "startCol": "19",
      "endLine": "75",
      "endCol": "8"
    },
    "1754": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "82",
      "startCol": "19",
      "endLine": "96",
      "endCol": "8"
    },
    "1755": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "107",
      "startCol": "19",
      "endLine": "110",
      "endCol": "8"
    },
    "1756": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "121",
      "startCol": "19",
      "endLine": "135",
      "endCol": "8"
    },
    "1757": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "146",
      "startCol": "19",
      "endLine": "149",
      "endCol": "8"
    },
    "1758": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "156",
      "startCol": "19",
      "endLine": "172",
      "endCol": "8"
    },
    "1759": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "185",
      "startCol": "25",
      "endLine": "199",
      "endCol": "8"
    },
    "1760": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "209",
      "startCol": "21",
      "endLine": "215",
      "endCol": "10"
    },
    "1761": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "220",
      "startCol": "25",
      "endLine": "234",
      "endCol": "8"
    },
    "1762": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "245",
      "startCol": "19",
      "endLine": "262",
      "endCol": "8"
    },
    "1763": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js",
      "startLine": "273",
      "startCol": "19",
      "endLine": "276",
      "endCol": "8"
    },
    "1764": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/config/functions/bootstrap.js",
      "startLine": "20",
      "startCol": "28",
      "endLine": "20",
      "endCol": "67"
    },
    "1765": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/config/policies/index.js",
      "startLine": "9",
      "startCol": "18",
      "endLine": "9",
      "endCol": "57"
    },
    "1766": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/config/policies/index.js",
      "startLine": "12",
      "startCol": "12",
      "endLine": "12",
      "endCol": "23"
    },
    "1767": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-documentation/config/policies/index.js",
      "startLine": "3",
      "startCol": "18",
      "endLine": "33",
      "endCol": "1"
    },
    "1768": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/config/policies/index.js",
      "startLine": "22",
      "startCol": "19",
      "endLine": "25",
      "endCol": "3"
    },
    "1769": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/config/policies/index.js",
      "startLine": "32",
      "startCol": "3",
      "endLine": "32",
      "endCol": "14"
    },
    "1770": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "23",
      "startCol": "20",
      "endLine": "23",
      "endCol": "52"
    },
    "1771": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "75",
      "startCol": "11",
      "endLine": "75",
      "endCol": "41"
    },
    "1772": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "76",
      "startCol": "11",
      "endLine": "76",
      "endCol": "54"
    },
    "1773": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "88",
      "startCol": "20",
      "endLine": "88",
      "endCol": "59"
    },
    "1774": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "36",
      "startCol": "14",
      "endLine": "101",
      "endCol": "3"
    },
    "1775": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "123",
      "startCol": "9",
      "endLine": "123",
      "endCol": "39"
    },
    "1776": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "124",
      "startCol": "9",
      "endLine": "124",
      "endCol": "48"
    },
    "1777": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "135",
      "startCol": "18",
      "endLine": "135",
      "endCol": "57"
    },
    "1778": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "103",
      "startCol": "18",
      "endLine": "145",
      "endCol": "3"
    },
    "1779": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "152",
      "startCol": "42",
      "endLine": "159",
      "endCol": "12"
    },
    "1780": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "161",
      "startCol": "21",
      "endLine": "164",
      "endCol": "5"
    },
    "1781": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "249",
      "startCol": "7",
      "endLine": "249",
      "endCol": "48"
    },
    "1782": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "269",
      "startCol": "24",
      "endLine": "269",
      "endCol": "63"
    },
    "1783": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "292",
      "startCol": "29",
      "endLine": "294",
      "endCol": "8"
    },
    "1784": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/controllers/Documentation.js",
      "startLine": "299",
      "startCol": "5",
      "endLine": "299",
      "endCol": "63"
    },
    "1785": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/middlewares/documentation/index.js",
      "startLine": "52",
      "startCol": "16",
      "endLine": "55",
      "endCol": "21"
    },
    "1786": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-documentation/middlewares/documentation/index.js",
      "startLine": "49",
      "startCol": "53",
      "endLine": "56",
      "endCol": "7"
    },
    "1787": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/services/Documentation.js",
      "startLine": "247",
      "startCol": "9",
      "endLine": "247",
      "endCol": "42"
    },
    "1788": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/services/Documentation.js",
      "startLine": "297",
      "startCol": "12",
      "endLine": "297",
      "endCol": "45"
    },
    "1789": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-documentation/services/Documentation.js",
      "startLine": "219",
      "startCol": "24",
      "endLine": "298",
      "endCol": "3"
    },
    "1790": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-documentation/services/Documentation.js",
      "startLine": "1844",
      "startCol": "20",
      "endLine": "1851",
      "endCol": "12"
    },
    "1791": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-email/controllers/Email.js",
      "startLine": "12",
      "startCol": "7",
      "endLine": "12",
      "endCol": "61"
    },
    "1792": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/hooks/graphql/index.js",
      "startLine": "154",
      "startCol": "9",
      "endLine": "154",
      "endCol": "27"
    },
    "1793": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/hooks/graphql/load-config.js",
      "startLine": "16",
      "startCol": "20",
      "endLine": "16",
      "endCol": "81"
    },
    "1794": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/hooks/graphql/load-config.js",
      "startLine": "34",
      "startCol": "53",
      "endLine": "39",
      "endCol": "4"
    },
    "1795": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/build-aggregation.js",
      "startLine": "261",
      "startCol": "22",
      "endLine": "267",
      "endCol": "8"
    },
    "1796": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "36",
      "startCol": "7",
      "endLine": "36",
      "endCol": "35"
    },
    "1797": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "48",
      "startCol": "5",
      "endLine": "48",
      "endCol": "33"
    },
    "1798": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "50",
      "startCol": "20",
      "endLine": "50",
      "endCol": "36"
    },
    "1799": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "97",
      "startCol": "7",
      "endLine": "97",
      "endCol": "35"
    },
    "1800": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "110",
      "startCol": "5",
      "endLine": "110",
      "endCol": "33"
    },
    "1801": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/resolvers-builder.js",
      "startLine": "112",
      "startCol": "20",
      "endLine": "112",
      "endCol": "36"
    },
    "1802": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/type-definitions.js",
      "startLine": "53",
      "startCol": "19",
      "endLine": "53",
      "endCol": "53"
    },
    "1803": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/type-definitions.js",
      "startLine": "197",
      "startCol": "27",
      "endLine": "197",
      "endCol": "80"
    },
    "1804": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/services/type-definitions.js",
      "startLine": "256",
      "startCol": "31",
      "endLine": "258",
      "endCol": "70"
    },
    "1805": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "33",
      "startCol": "5",
      "endLine": "33",
      "endCol": "51"
    },
    "1806": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "36",
      "startCol": "10",
      "endLine": "36",
      "endCol": "44"
    },
    "1807": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "49",
      "startCol": "5",
      "endLine": "49",
      "endCol": "27"
    },
    "1808": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "62",
      "startCol": "19",
      "endLine": "79",
      "endCol": "8"
    },
    "1809": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "94",
      "startCol": "19",
      "endLine": "105",
      "endCol": "8"
    },
    "1810": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "121",
      "startCol": "19",
      "endLine": "132",
      "endCol": "8"
    },
    "1811": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "143",
      "startCol": "19",
      "endLine": "154",
      "endCol": "8"
    },
    "1812": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "165",
      "startCol": "19",
      "endLine": "176",
      "endCol": "8"
    },
    "1813": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "187",
      "startCol": "19",
      "endLine": "204",
      "endCol": "8"
    },
    "1814": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "329",
      "startCol": "19",
      "endLine": "342",
      "endCol": "8"
    },
    "1815": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "361",
      "startCol": "19",
      "endLine": "375",
      "endCol": "8"
    },
    "1816": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "387",
      "startCol": "19",
      "endLine": "408",
      "endCol": "8"
    },
    "1817": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js",
      "startLine": "427",
      "startCol": "21",
      "endLine": "446",
      "endCol": "10"
    },
    "1818": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "110",
      "startCol": "5",
      "endLine": "113",
      "endCol": "14"
    },
    "1819": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "116",
      "startCol": "10",
      "endLine": "116",
      "endCol": "44"
    },
    "1820": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "129",
      "startCol": "5",
      "endLine": "129",
      "endCol": "27"
    },
    "1821": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "147",
      "startCol": "19",
      "endLine": "168",
      "endCol": "8"
    },
    "1822": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "181",
      "startCol": "19",
      "endLine": "196",
      "endCol": "8"
    },
    "1823": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "212",
      "startCol": "19",
      "endLine": "240",
      "endCol": "8"
    },
    "1824": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "259",
      "startCol": "19",
      "endLine": "278",
      "endCol": "8"
    },
    "1825": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "299",
      "startCol": "19",
      "endLine": "318",
      "endCol": "8"
    },
    "1826": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "339",
      "startCol": "19",
      "endLine": "358",
      "endCol": "8"
    },
    "1827": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "370",
      "startCol": "19",
      "endLine": "401",
      "endCol": "8"
    },
    "1828": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "418",
      "startCol": "21",
      "endLine": "442",
      "endCol": "10"
    },
    "1829": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "456",
      "startCol": "19",
      "endLine": "475",
      "endCol": "8"
    },
    "1830": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "494",
      "startCol": "21",
      "endLine": "512",
      "endCol": "10"
    },
    "1831": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "532",
      "startCol": "19",
      "endLine": "548",
      "endCol": "8"
    },
    "1832": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "565",
      "startCol": "19",
      "endLine": "574",
      "endCol": "8"
    },
    "1833": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "591",
      "startCol": "19",
      "endLine": "613",
      "endCol": "8"
    },
    "1834": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "632",
      "startCol": "19",
      "endLine": "641",
      "endCol": "8"
    },
    "1835": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "659",
      "startCol": "27",
      "endLine": "679",
      "endCol": "8"
    },
    "1836": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js",
      "startLine": "682",
      "startCol": "24",
      "endLine": "695",
      "endCol": "8"
    },
    "1837": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "45",
      "startCol": "5",
      "endLine": "45",
      "endCol": "55"
    },
    "1838": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "48",
      "startCol": "10",
      "endLine": "48",
      "endCol": "44"
    },
    "1839": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "61",
      "startCol": "5",
      "endLine": "61",
      "endCol": "27"
    },
    "1840": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "66",
      "startCol": "19",
      "endLine": "74",
      "endCol": "8"
    },
    "1841": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "87",
      "startCol": "7",
      "endLine": "89",
      "endCol": "8"
    },
    "1842": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "91",
      "startCol": "19",
      "endLine": "100",
      "endCol": "8"
    },
    "1843": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "116",
      "startCol": "19",
      "endLine": "124",
      "endCol": "8"
    },
    "1844": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "137",
      "startCol": "25",
      "endLine": "155",
      "endCol": "8"
    },
    "1845": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "167",
      "startCol": "22",
      "endLine": "176",
      "endCol": "8"
    },
    "1846": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "188",
      "startCol": "25",
      "endLine": "199",
      "endCol": "8"
    },
    "1847": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js",
      "startLine": "211",
      "startCol": "22",
      "endLine": "220",
      "endCol": "8"
    },
    "1848": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js",
      "startLine": "66",
      "startCol": "7",
      "endLine": "68",
      "endCol": "8"
    },
    "1849": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js",
      "startLine": "87",
      "startCol": "20",
      "endLine": "89",
      "endCol": "8"
    },
    "1850": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js",
      "startLine": "110",
      "startCol": "25",
      "endLine": "112",
      "endCol": "8"
    },
    "1851": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js",
      "startLine": "132",
      "startCol": "29",
      "endLine": "132",
      "endCol": "78"
    },
    "1852": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js",
      "startLine": "230",
      "startCol": "7",
      "endLine": "230",
      "endCol": "71"
    },
    "1853": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/Initializer/index.js",
      "startLine": "21",
      "startCol": "26",
      "endLine": "21",
      "endCol": "69"
    },
    "1854": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepper/InputModalStepper.js",
      "startLine": "196",
      "startCol": "9",
      "endLine": "196",
      "endCol": "55"
    },
    "1855": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepper/InputModalStepper.js",
      "startLine": "258",
      "startCol": "26",
      "endLine": "268",
      "endCol": "7"
    },
    "1856": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "83",
      "startCol": "7",
      "endLine": "115",
      "endCol": "7"
    },
    "1857": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "137",
      "startCol": "7",
      "endLine": "140",
      "endCol": "7"
    },
    "1858": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "336",
      "startCol": "14",
      "endLine": "338",
      "endCol": "8"
    },
    "1859": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "331",
      "startCol": "35",
      "endLine": "348",
      "endCol": "3"
    },
    "1860": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "352",
      "startCol": "30",
      "endLine": "352",
      "endCol": "97"
    },
    "1861": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "366",
      "startCol": "14",
      "endLine": "368",
      "endCol": "8"
    },
    "1862": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "361",
      "startCol": "30",
      "endLine": "378",
      "endCol": "3"
    },
    "1863": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "421",
      "startCol": "32",
      "endLine": "431",
      "endCol": "11"
    },
    "1864": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js",
      "startLine": "474",
      "startCol": "5",
      "endLine": "474",
      "endCol": "31"
    },
    "1865": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "91",
      "startCol": "7",
      "endLine": "124",
      "endCol": "7"
    },
    "1866": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "186",
      "startCol": "7",
      "endLine": "188",
      "endCol": "8"
    },
    "1867": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "208",
      "startCol": "7",
      "endLine": "211",
      "endCol": "7"
    },
    "1868": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "332",
      "startCol": "7",
      "endLine": "342",
      "endCol": "7"
    },
    "1869": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "418",
      "startCol": "11",
      "endLine": "428",
      "endCol": "11"
    },
    "1870": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js",
      "startLine": "462",
      "startCol": "5",
      "endLine": "462",
      "endCol": "31"
    },
    "1871": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/SettingsPage/index.js",
      "startLine": "25",
      "startCol": "24",
      "endLine": "25",
      "endCol": "90"
    },
    "1872": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/admin/src/containers/SettingsPage/index.js",
      "startLine": "50",
      "startCol": "7",
      "endLine": "53",
      "endCol": "8"
    },
    "1873": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/functions/bootstrap.js",
      "startLine": "16",
      "startCol": "18",
      "endLine": "16",
      "endCol": "41"
    },
    "1874": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/functions/bootstrap.js",
      "startLine": "19",
      "startCol": "5",
      "endLine": "24",
      "endCol": "6"
    },
    "1875": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/functions/bootstrap.js",
      "startLine": "33",
      "startCol": "12",
      "endLine": "33",
      "endCol": "28"
    },
    "1876": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-upload/config/functions/bootstrap.js",
      "startLine": "31",
      "startCol": "37",
      "endLine": "37",
      "endCol": "1"
    },
    "1877": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/functions/bootstrap.js",
      "startLine": "80",
      "startCol": "3",
      "endLine": "80",
      "endCol": "76"
    },
    "1878": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "35",
      "startCol": "33",
      "endLine": "37",
      "endCol": "11"
    },
    "1879": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "47",
      "startCol": "25",
      "endLine": "47",
      "endCol": "96"
    },
    "1880": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "58",
      "startCol": "18",
      "endLine": "58",
      "endCol": "85"
    },
    "1881": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "57",
      "startCol": "19",
      "endLine": "59",
      "endCol": "9"
    },
    "1882": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "65",
      "startCol": "24",
      "endLine": "65",
      "endCol": "99"
    },
    "1883": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "67",
      "startCol": "32",
      "endLine": "67",
      "endCol": "87"
    },
    "1884": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "77",
      "startCol": "52",
      "endLine": "77",
      "endCol": "63"
    },
    "1885": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/config/schema.graphql.js",
      "startLine": "82",
      "startCol": "28",
      "endLine": "82",
      "endCol": "53"
    },
    "1886": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/Upload.js",
      "startLine": "65",
      "startCol": "5",
      "endLine": "65",
      "endCol": "69"
    },
    "1887": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/Upload.js",
      "startLine": "71",
      "startCol": "21",
      "endLine": "73",
      "endCol": "6"
    },
    "1888": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "40",
      "startCol": "19",
      "endLine": "40",
      "endCol": "76"
    },
    "1889": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "75",
      "startCol": "19",
      "endLine": "75",
      "endCol": "76"
    },
    "1890": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "93",
      "startCol": "5",
      "endLine": "93",
      "endCol": "63"
    },
    "1891": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "108",
      "startCol": "18",
      "endLine": "108",
      "endCol": "45"
    },
    "1892": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "110",
      "startCol": "5",
      "endLine": "110",
      "endCol": "65"
    },
    "1893": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "124",
      "startCol": "18",
      "endLine": "124",
      "endCol": "74"
    },
    "1894": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "139",
      "startCol": "18",
      "endLine": "139",
      "endCol": "47"
    },
    "1895": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "140",
      "startCol": "18",
      "endLine": "140",
      "endCol": "80"
    },
    "1896": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "163",
      "startCol": "18",
      "endLine": "163",
      "endCol": "47"
    },
    "1897": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "164",
      "startCol": "27",
      "endLine": "164",
      "endCol": "90"
    },
    "1898": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "186",
      "startCol": "18",
      "endLine": "186",
      "endCol": "47"
    },
    "1899": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "187",
      "startCol": "27",
      "endLine": "187",
      "endCol": "79"
    },
    "1900": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "194",
      "startCol": "16",
      "endLine": "194",
      "endCol": "72"
    },
    "1901": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/admin.js",
      "startLine": "203",
      "startCol": "7",
      "endLine": "203",
      "endCol": "97"
    },
    "1902": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "19",
      "startCol": "19",
      "endLine": "19",
      "endCol": "80"
    },
    "1903": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "29",
      "startCol": "18",
      "endLine": "29",
      "endCol": "74"
    },
    "1904": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "41",
      "startCol": "16",
      "endLine": "41",
      "endCol": "77"
    },
    "1905": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "49",
      "startCol": "18",
      "endLine": "49",
      "endCol": "77"
    },
    "1906": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "55",
      "startCol": "5",
      "endLine": "55",
      "endCol": "63"
    },
    "1907": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "65",
      "startCol": "18",
      "endLine": "65",
      "endCol": "45"
    },
    "1908": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "67",
      "startCol": "5",
      "endLine": "67",
      "endCol": "65"
    },
    "1909": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "73",
      "startCol": "18",
      "endLine": "73",
      "endCol": "74"
    },
    "1910": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "83",
      "startCol": "18",
      "endLine": "83",
      "endCol": "47"
    },
    "1911": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "85",
      "startCol": "20",
      "endLine": "85",
      "endCol": "96"
    },
    "1912": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "105",
      "startCol": "27",
      "endLine": "108",
      "endCol": "6"
    },
    "1913": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "106",
      "startCol": "13",
      "endLine": "106",
      "endCol": "42"
    },
    "1914": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "118",
      "startCol": "27",
      "endLine": "121",
      "endCol": "6"
    },
    "1915": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/controllers/upload/api.js",
      "startLine": "119",
      "startCol": "13",
      "endLine": "119",
      "endCol": "42"
    },
    "1916": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "93",
      "startCol": "20",
      "endLine": "93",
      "endCol": "63"
    },
    "1917": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "111",
      "startCol": "30",
      "endLine": "111",
      "endCol": "55"
    },
    "1918": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "140",
      "startCol": "12",
      "endLine": "142",
      "endCol": "5"
    },
    "1919": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "128",
      "startCol": "15",
      "endLine": "143",
      "endCol": "3"
    },
    "1920": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "154",
      "startCol": "5",
      "endLine": "154",
      "endCol": "57"
    },
    "1921": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "156",
      "startCol": "27",
      "endLine": "156",
      "endCol": "59"
    },
    "1922": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "158",
      "startCol": "7",
      "endLine": "158",
      "endCol": "64"
    },
    "1923": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "163",
      "startCol": "21",
      "endLine": "163",
      "endCol": "61"
    },
    "1924": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "170",
      "startCol": "9",
      "endLine": "170",
      "endCol": "57"
    },
    "1925": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "177",
      "startCol": "31",
      "endLine": "177",
      "endCol": "66"
    },
    "1926": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "191",
      "startCol": "20",
      "endLine": "191",
      "endCol": "43"
    },
    "1927": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "215",
      "startCol": "20",
      "endLine": "215",
      "endCol": "43"
    },
    "1928": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "232",
      "startCol": "7",
      "endLine": "232",
      "endCol": "57"
    },
    "1929": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "235",
      "startCol": "9",
      "endLine": "239",
      "endCol": "9"
    },
    "1930": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "243",
      "startCol": "5",
      "endLine": "243",
      "endCol": "57"
    },
    "1931": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "248",
      "startCol": "27",
      "endLine": "248",
      "endCol": "59"
    },
    "1932": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "250",
      "startCol": "7",
      "endLine": "250",
      "endCol": "64"
    },
    "1933": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "255",
      "startCol": "21",
      "endLine": "255",
      "endCol": "61"
    },
    "1934": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "262",
      "startCol": "9",
      "endLine": "262",
      "endCol": "57"
    },
    "1935": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "269",
      "startCol": "31",
      "endLine": "269",
      "endCol": "66"
    },
    "1936": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "288",
      "startCol": "17",
      "endLine": "288",
      "endCol": "79"
    },
    "1937": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "302",
      "startCol": "17",
      "endLine": "302",
      "endCol": "71"
    },
    "1938": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "335",
      "startCol": "7",
      "endLine": "335",
      "endCol": "55"
    },
    "1939": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "338",
      "startCol": "9",
      "endLine": "342",
      "endCol": "9"
    },
    "1940": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "346",
      "startCol": "19",
      "endLine": "348",
      "endCol": "6"
    },
    "1941": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "360",
      "startCol": "27",
      "endLine": "373",
      "endCol": "5"
    },
    "1942": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/Upload.js",
      "startLine": "375",
      "startCol": "5",
      "endLine": "375",
      "endCol": "81"
    },
    "1943": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "36",
      "startCol": "29",
      "endLine": "36",
      "endCol": "60"
    },
    "1944": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "39",
      "startCol": "21",
      "endLine": "39",
      "endCol": "73"
    },
    "1945": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "42",
      "startCol": "39",
      "endLine": "42",
      "endCol": "65"
    },
    "1946": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "65",
      "startCol": "7",
      "endLine": "65",
      "endCol": "63"
    },
    "1947": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "101",
      "startCol": "7",
      "endLine": "101",
      "endCol": "63"
    },
    "1948": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "109",
      "startCol": "30",
      "endLine": "109",
      "endCol": "61"
    },
    "1949": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "124",
      "startCol": "19",
      "endLine": "128",
      "endCol": "4"
    },
    "1950": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "131",
      "startCol": "37",
      "endLine": "131",
      "endCol": "63"
    },
    "1951": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/services/image-manipulation.js",
      "startLine": "156",
      "startCol": "22",
      "endLine": "156",
      "endCol": "47"
    },
    "1952": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "17",
      "startCol": "10",
      "endLine": "17",
      "endCol": "44"
    },
    "1953": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "47",
      "startCol": "17",
      "endLine": "47",
      "endCol": "71"
    },
    "1954": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "87",
      "startCol": "17",
      "endLine": "87",
      "endCol": "71"
    },
    "1955": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "103",
      "startCol": "17",
      "endLine": "126",
      "endCol": "6"
    },
    "1956": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "142",
      "startCol": "17",
      "endLine": "159",
      "endCol": "6"
    },
    "1957": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "174",
      "startCol": "17",
      "endLine": "191",
      "endCol": "6"
    },
    "1958": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js",
      "startLine": "228",
      "startCol": "17",
      "endLine": "228",
      "endCol": "71"
    },
    "1959": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "16",
      "startCol": "10",
      "endLine": "16",
      "endCol": "44"
    },
    "1960": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "25",
      "startCol": "19",
      "endLine": "25",
      "endCol": "70"
    },
    "1961": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "39",
      "startCol": "25",
      "endLine": "46",
      "endCol": "8"
    },
    "1962": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "56",
      "startCol": "22",
      "endLine": "56",
      "endCol": "73"
    },
    "1963": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "70",
      "startCol": "19",
      "endLine": "76",
      "endCol": "8"
    },
    "1964": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "98",
      "startCol": "19",
      "endLine": "98",
      "endCol": "76"
    },
    "1965": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-upload/tests/upload.test.e2e.js",
      "startLine": "103",
      "startCol": "19",
      "endLine": "109",
      "endCol": "8"
    },
    "1966": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/AdvancedSettings/index.js",
      "startLine": "45",
      "startCol": "22",
      "endLine": "45",
      "endCol": "88"
    },
    "1967": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/AdvancedSettings/index.js",
      "startLine": "95",
      "startCol": "9",
      "endLine": "95",
      "endCol": "87"
    },
    "1968": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/EmailTemplates/index.js",
      "startLine": "100",
      "startCol": "9",
      "endLine": "100",
      "endCol": "85"
    },
    "1969": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/EmailTemplates/index.js",
      "startLine": "107",
      "startCol": "11",
      "endLine": "110",
      "endCol": "12"
    },
    "1970": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/Providers/index.js",
      "startLine": "140",
      "startCol": "9",
      "endLine": "140",
      "endCol": "86"
    },
    "1971": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/containers/Providers/index.js",
      "startLine": "146",
      "startCol": "11",
      "endLine": "149",
      "endCol": "12"
    },
    "1972": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/hooks/useFetchRole/index.js",
      "startLine": "26",
      "startCol": "24",
      "endLine": "26",
      "endCol": "87"
    },
    "1973": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/hooks/useForm/index.js",
      "startLine": "25",
      "startCol": "22",
      "endLine": "25",
      "endCol": "86"
    },
    "1974": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/hooks/usePlugins/index.js",
      "startLine": "24",
      "startCol": "59",
      "endLine": "28",
      "endCol": "7"
    },
    "1975": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/admin/src/hooks/useRolesList/index.js",
      "startLine": "35",
      "startCol": "25",
      "endLine": "35",
      "endCol": "86"
    },
    "1976": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "134",
      "startCol": "28",
      "endLine": "134",
      "endCol": "66"
    },
    "1977": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "145",
      "startCol": "5",
      "endLine": "145",
      "endCol": "63"
    },
    "1978": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "148",
      "startCol": "9",
      "endLine": "148",
      "endCol": "47"
    },
    "1979": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "189",
      "startCol": "5",
      "endLine": "189",
      "endCol": "50"
    },
    "1980": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "192",
      "startCol": "9",
      "endLine": "192",
      "endCol": "50"
    },
    "1981": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "202",
      "startCol": "5",
      "endLine": "202",
      "endCol": "53"
    },
    "1982": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "205",
      "startCol": "3",
      "endLine": "205",
      "endCol": "82"
    },
    "1983": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js",
      "startLine": "213",
      "startCol": "5",
      "endLine": "217",
      "endCol": "5"
    },
    "1984": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/isAuthenticated.js",
      "startLine": "8",
      "startCol": "3",
      "endLine": "8",
      "endCol": "14"
    },
    "1985": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "15",
      "startCol": "22",
      "endLine": "15",
      "endCol": "89"
    },
    "1986": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "22",
      "startCol": "24",
      "endLine": "24",
      "endCol": "48"
    },
    "1987": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "36",
      "startCol": "14",
      "endLine": "36",
      "endCol": "25"
    },
    "1988": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "5",
      "startCol": "18",
      "endLine": "89",
      "endCol": "1"
    },
    "1989": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "39",
      "startCol": "19",
      "endLine": "43",
      "endCol": "6"
    },
    "1990": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "46",
      "startCol": "13",
      "endLine": "46",
      "endCol": "48"
    },
    "1991": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "63",
      "startCol": "12",
      "endLine": "63",
      "endCol": "90"
    },
    "1992": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "67",
      "startCol": "22",
      "endLine": "76",
      "endCol": "3"
    },
    "1993": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "84",
      "startCol": "12",
      "endLine": "84",
      "endCol": "98"
    },
    "1994": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/policies/permissions.js",
      "startLine": "88",
      "startCol": "3",
      "endLine": "88",
      "endCol": "14"
    },
    "1995": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "82",
      "startCol": "11",
      "endLine": "82",
      "endCol": "97"
    },
    "1996": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "93",
      "startCol": "11",
      "endLine": "93",
      "endCol": "98"
    },
    "1997": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "104",
      "startCol": "11",
      "endLine": "106",
      "endCol": "11"
    },
    "1998": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "118",
      "startCol": "11",
      "endLine": "120",
      "endCol": "11"
    },
    "1999": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "132",
      "startCol": "11",
      "endLine": "134",
      "endCol": "11"
    },
    "2000": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "146",
      "startCol": "11",
      "endLine": "146",
      "endCol": "84"
    },
    "2001": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "160",
      "startCol": "11",
      "endLine": "160",
      "endCol": "84"
    },
    "2002": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "177",
      "startCol": "11",
      "endLine": "177",
      "endCol": "85"
    },
    "2003": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "182",
      "startCol": "11",
      "endLine": "182",
      "endCol": "85"
    },
    "2004": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "195",
      "startCol": "11",
      "endLine": "195",
      "endCol": "86"
    },
    "2005": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "214",
      "startCol": "11",
      "endLine": "214",
      "endCol": "86"
    },
    "2006": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "230",
      "startCol": "11",
      "endLine": "230",
      "endCol": "92"
    },
    "2007": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "246",
      "startCol": "11",
      "endLine": "246",
      "endCol": "91"
    },
    "2008": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/config/schema.graphql.js",
      "startLine": "263",
      "startCol": "11",
      "endLine": "267",
      "endCol": "11"
    },
    "2009": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "25",
      "startCol": "19",
      "endLine": "29",
      "endCol": "6"
    },
    "2010": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "32",
      "startCol": "18",
      "endLine": "32",
      "endCol": "50"
    },
    "2011": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "71",
      "startCol": "20",
      "endLine": "71",
      "endCol": "81"
    },
    "2012": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "84",
      "startCol": "15",
      "endLine": "84",
      "endCol": "50"
    },
    "2013": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "118",
      "startCol": "29",
      "endLine": "120",
      "endCol": "70"
    },
    "2014": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "141",
      "startCol": "18",
      "endLine": "141",
      "endCol": "50"
    },
    "2015": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "154",
      "startCol": "25",
      "endLine": "157",
      "endCol": "9"
    },
    "2016": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "186",
      "startCol": "20",
      "endLine": "188",
      "endCol": "58"
    },
    "2017": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "200",
      "startCol": "24",
      "endLine": "202",
      "endCol": "8"
    },
    "2018": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "205",
      "startCol": "7",
      "endLine": "207",
      "endCol": "72"
    },
    "2019": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "241",
      "startCol": "25",
      "endLine": "248",
      "endCol": "12"
    },
    "2020": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "290",
      "startCol": "25",
      "endLine": "294",
      "endCol": "6"
    },
    "2021": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "297",
      "startCol": "18",
      "endLine": "299",
      "endCol": "46"
    },
    "2022": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "315",
      "startCol": "22",
      "endLine": "321",
      "endCol": "6"
    },
    "2023": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "323",
      "startCol": "22",
      "endLine": "325",
      "endCol": "6"
    },
    "2024": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "331",
      "startCol": "24",
      "endLine": "338",
      "endCol": "5"
    },
    "2025": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "340",
      "startCol": "23",
      "endLine": "345",
      "endCol": "5"
    },
    "2026": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "349",
      "startCol": "7",
      "endLine": "359",
      "endCol": "8"
    },
    "2027": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "365",
      "startCol": "5",
      "endLine": "365",
      "endCol": "99"
    },
    "2028": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "371",
      "startCol": "25",
      "endLine": "375",
      "endCol": "6"
    },
    "2029": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "377",
      "startCol": "22",
      "endLine": "379",
      "endCol": "6"
    },
    "2030": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "430",
      "startCol": "18",
      "endLine": "432",
      "endCol": "51"
    },
    "2031": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "460",
      "startCol": "23",
      "endLine": "460",
      "endCol": "98"
    },
    "2032": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "462",
      "startCol": "18",
      "endLine": "464",
      "endCol": "6"
    },
    "2033": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "491",
      "startCol": "20",
      "endLine": "491",
      "endCol": "81"
    },
    "2034": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "499",
      "startCol": "11",
      "endLine": "499",
      "endCol": "93"
    },
    "2035": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "534",
      "startCol": "18",
      "endLine": "534",
      "endCol": "67"
    },
    "2036": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "540",
      "startCol": "5",
      "endLine": "540",
      "endCol": "89"
    },
    "2037": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "550",
      "startCol": "24",
      "endLine": "557",
      "endCol": "14"
    },
    "2038": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "578",
      "startCol": "18",
      "endLine": "580",
      "endCol": "6"
    },
    "2039": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/Auth.js",
      "startLine": "591",
      "startCol": "7",
      "endLine": "591",
      "endCol": "89"
    },
    "2040": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "51",
      "startCol": "15",
      "endLine": "51",
      "endCol": "89"
    },
    "2041": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "53",
      "startCol": "15",
      "endLine": "53",
      "endCol": "99"
    },
    "2042": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "65",
      "startCol": "16",
      "endLine": "67",
      "endCol": "6"
    },
    "2043": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "83",
      "startCol": "14",
      "endLine": "83",
      "endCol": "91"
    },
    "2044": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "81",
      "startCol": "14",
      "endLine": "86",
      "endCol": "3"
    },
    "2045": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "85",
      "startCol": "16",
      "endLine": "85",
      "endCol": "87"
    },
    "2046": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "94",
      "startCol": "18",
      "endLine": "94",
      "endCol": "87"
    },
    "2047": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/User.js",
      "startLine": "107",
      "startCol": "18",
      "endLine": "107",
      "endCol": "94"
    },
    "2048": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "24",
      "startCol": "7",
      "endLine": "26",
      "endCol": "7"
    },
    "2049": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "37",
      "startCol": "24",
      "endLine": "37",
      "endCol": "98"
    },
    "2050": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "53",
      "startCol": "7",
      "endLine": "56",
      "endCol": "7"
    },
    "2051": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "67",
      "startCol": "27",
      "endLine": "69",
      "endCol": "46"
    },
    "2052": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "89",
      "startCol": "21",
      "endLine": "91",
      "endCol": "5"
    },
    "2053": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "92",
      "startCol": "18",
      "endLine": "95",
      "endCol": "5"
    },
    "2054": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "106",
      "startCol": "21",
      "endLine": "106",
      "endCol": "98"
    },
    "2055": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "116",
      "startCol": "22",
      "endLine": "118",
      "endCol": "45"
    },
    "2056": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "134",
      "startCol": "18",
      "endLine": "136",
      "endCol": "6"
    },
    "2057": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "149",
      "startCol": "7",
      "endLine": "152",
      "endCol": "7"
    },
    "2058": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "163",
      "startCol": "7",
      "endLine": "170",
      "endCol": "14"
    },
    "2059": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "189",
      "startCol": "5",
      "endLine": "196",
      "endCol": "37"
    },
    "2060": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "203",
      "startCol": "17",
      "endLine": "210",
      "endCol": "14"
    },
    "2061": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "211",
      "startCol": "14",
      "endLine": "211",
      "endCol": "91"
    },
    "2062": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "220",
      "startCol": "5",
      "endLine": "227",
      "endCol": "39"
    },
    "2063": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "233",
      "startCol": "23",
      "endLine": "240",
      "endCol": "12"
    },
    "2064": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js",
      "startLine": "258",
      "startCol": "5",
      "endLine": "265",
      "endCol": "49"
    },
    "2065": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "22",
      "startCol": "18",
      "endLine": "22",
      "endCol": "80"
    },
    "2066": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "31",
      "startCol": "7",
      "endLine": "31",
      "endCol": "99"
    },
    "2067": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "66",
      "startCol": "22",
      "endLine": "73",
      "endCol": "12"
    },
    "2068": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "79",
      "startCol": "34",
      "endLine": "81",
      "endCol": "28"
    },
    "2069": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "95",
      "startCol": "33",
      "endLine": "97",
      "endCol": "48"
    },
    "2070": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "122",
      "startCol": "27",
      "endLine": "124",
      "endCol": "53"
    },
    "2071": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "130",
      "startCol": "20",
      "endLine": "130",
      "endCol": "84"
    },
    "2072": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "143",
      "startCol": "29",
      "endLine": "150",
      "endCol": "12"
    },
    "2073": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "179",
      "startCol": "36",
      "endLine": "181",
      "endCol": "30"
    },
    "2074": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "196",
      "startCol": "33",
      "endLine": "198",
      "endCol": "48"
    },
    "2075": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/admin.js",
      "startLine": "220",
      "startCol": "18",
      "endLine": "220",
      "endCol": "97"
    },
    "2076": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "21",
      "startCol": "22",
      "endLine": "28",
      "endCol": "12"
    },
    "2077": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "36",
      "startCol": "34",
      "endLine": "38",
      "endCol": "28"
    },
    "2078": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "52",
      "startCol": "33",
      "endLine": "54",
      "endCol": "48"
    },
    "2079": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "77",
      "startCol": "27",
      "endLine": "79",
      "endCol": "53"
    },
    "2080": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "85",
      "startCol": "20",
      "endLine": "85",
      "endCol": "84"
    },
    "2081": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "98",
      "startCol": "29",
      "endLine": "105",
      "endCol": "12"
    },
    "2082": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "110",
      "startCol": "18",
      "endLine": "112",
      "endCol": "6"
    },
    "2083": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "127",
      "startCol": "36",
      "endLine": "129",
      "endCol": "30"
    },
    "2084": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "144",
      "startCol": "33",
      "endLine": "146",
      "endCol": "48"
    },
    "2085": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/controllers/user/api.js",
      "startLine": "169",
      "startCol": "18",
      "endLine": "169",
      "endCol": "97"
    },
    "2086": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "47",
      "startCol": "23",
      "endLine": "49",
      "endCol": "10"
    },
    "2087": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "51",
      "startCol": "26",
      "endLine": "58",
      "endCol": "16"
    },
    "2088": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "86",
      "startCol": "29",
      "endLine": "88",
      "endCol": "55"
    },
    "2089": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "97",
      "startCol": "29",
      "endLine": "97",
      "endCol": "90"
    },
    "2090": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/Providers.js",
      "startLine": "117",
      "startCol": "17",
      "endLine": "124",
      "endCol": "10"
    },
    "2091": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "41",
      "startCol": "25",
      "endLine": "43",
      "endCol": "7"
    },
    "2092": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "55",
      "startCol": "25",
      "endLine": "57",
      "endCol": "7"
    },
    "2093": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "128",
      "startCol": "25",
      "endLine": "132",
      "endCol": "6"
    },
    "2094": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "134",
      "startCol": "22",
      "endLine": "136",
      "endCol": "67"
    },
    "2095": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "146",
      "startCol": "24",
      "endLine": "150",
      "endCol": "6"
    },
    "2096": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "152",
      "startCol": "23",
      "endLine": "152",
      "endCol": "95"
    },
    "2097": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/User.js",
      "startLine": "155",
      "startCol": "5",
      "endLine": "165",
      "endCol": "6"
    },
    "2098": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "46",
      "startCol": "18",
      "endLine": "48",
      "endCol": "55"
    },
    "2099": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "79",
      "startCol": "12",
      "endLine": "79",
      "endCol": "45"
    },
    "2100": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "41",
      "startCol": "19",
      "endLine": "80",
      "endCol": "3"
    },
    "2101": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "83",
      "startCol": "18",
      "endLine": "85",
      "endCol": "56"
    },
    "2102": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "119",
      "startCol": "12",
      "endLine": "119",
      "endCol": "45"
    },
    "2103": {
      "patternID": "pattern1",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "82",
      "startCol": "19",
      "endLine": "120",
      "endCol": "3"
    },
    "2104": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "191",
      "startCol": "18",
      "endLine": "193",
      "endCol": "47"
    },
    "2105": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "221",
      "startCol": "19",
      "endLine": "221",
      "endCol": "93"
    },
    "2106": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "224",
      "startCol": "27",
      "endLine": "226",
      "endCol": "37"
    },
    "2107": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "256",
      "startCol": "19",
      "endLine": "256",
      "endCol": "78"
    },
    "2108": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "259",
      "startCol": "27",
      "endLine": "261",
      "endCol": "27"
    },
    "2109": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "317",
      "startCol": "7",
      "endLine": "328",
      "endCol": "7"
    },
    "2110": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "330",
      "startCol": "7",
      "endLine": "335",
      "endCol": "7"
    },
    "2111": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "340",
      "startCol": "23",
      "endLine": "340",
      "endCol": "77"
    },
    "2112": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "343",
      "startCol": "7",
      "endLine": "347",
      "endCol": "8"
    },
    "2113": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "349",
      "startCol": "7",
      "endLine": "353",
      "endCol": "8"
    },
    "2114": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "360",
      "startCol": "35",
      "endLine": "363",
      "endCol": "6"
    },
    "2115": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "365",
      "startCol": "5",
      "endLine": "367",
      "endCol": "68"
    },
    "2116": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "369",
      "startCol": "5",
      "endLine": "398",
      "endCol": "5"
    },
    "2117": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "402",
      "startCol": "5",
      "endLine": "402",
      "endCol": "78"
    },
    "2118": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/services/UsersPermissions.js",
      "startLine": "405",
      "startCol": "5",
      "endLine": "405",
      "endCol": "88"
    },
    "2119": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "14",
      "startCol": "15",
      "endLine": "14",
      "endCol": "49"
    },
    "2120": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "24",
      "startCol": "19",
      "endLine": "39",
      "endCol": "8"
    },
    "2121": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "55",
      "startCol": "19",
      "endLine": "74",
      "endCol": "8"
    },
    "2122": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "95",
      "startCol": "19",
      "endLine": "115",
      "endCol": "8"
    },
    "2123": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "131",
      "startCol": "19",
      "endLine": "149",
      "endCol": "8"
    },
    "2124": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "170",
      "startCol": "19",
      "endLine": "188",
      "endCol": "8"
    },
    "2125": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js",
      "startLine": "204",
      "startCol": "19",
      "endLine": "222",
      "endCol": "8"
    },
    "2126": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "45",
      "startCol": "10",
      "endLine": "45",
      "endCol": "44"
    },
    "2127": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "47",
      "startCol": "17",
      "endLine": "47",
      "endCol": "38"
    },
    "2128": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "52",
      "startCol": "5",
      "endLine": "52",
      "endCol": "26"
    },
    "2129": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "57",
      "startCol": "17",
      "endLine": "65",
      "endCol": "6"
    },
    "2130": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "72",
      "startCol": "17",
      "endLine": "75",
      "endCol": "6"
    },
    "2131": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js",
      "startLine": "86",
      "startCol": "17",
      "endLine": "89",
      "endCol": "6"
    },
    "2132": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-api.test.e2e.js",
      "startLine": "15",
      "startCol": "10",
      "endLine": "15",
      "endCol": "44"
    },
    "2133": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-api.test.e2e.js",
      "startLine": "29",
      "startCol": "17",
      "endLine": "33",
      "endCol": "6"
    },
    "2134": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-api.test.e2e.js",
      "startLine": "47",
      "startCol": "17",
      "endLine": "50",
      "endCol": "6"
    },
    "2135": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-graphql.test.e2e.js",
      "startLine": "16",
      "startCol": "10",
      "endLine": "16",
      "endCol": "44"
    },
    "2136": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-graphql.test.e2e.js",
      "startLine": "39",
      "startCol": "19",
      "endLine": "54",
      "endCol": "8"
    },
    "2137": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-graphql.test.e2e.js",
      "startLine": "74",
      "startCol": "19",
      "endLine": "92",
      "endCol": "8"
    },
    "2138": {
      "patternID": "pattern3",
      "file": "packages/strapi-plugin-users-permissions/tests/users-graphql.test.e2e.js",
      "startLine": "112",
      "startCol": "19",
      "endLine": "129",
      "endCol": "8"
    },
    "2139": {
      "patternID": "pattern3",
      "file": "packages/strapi-provider-upload-cloudinary/lib/index.js",
      "startLine": "63",
      "startCol": "28",
      "endLine": "67",
      "endCol": "12"
    },
    "2140": {
      "patternID": "pattern3",
      "file": "packages/strapi-utils/lib/policy.js",
      "startLine": "68",
      "startCol": "5",
      "endLine": "68",
      "endCol": "16"
    },
    "2141": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "9",
      "startCol": "16",
      "endLine": "9",
      "endCol": "53"
    },
    "2142": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "19",
      "startCol": "3",
      "endLine": "19",
      "endCol": "69"
    },
    "2143": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "27",
      "startCol": "29",
      "endLine": "27",
      "endCol": "51"
    },
    "2144": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "39",
      "startCol": "7",
      "endLine": "39",
      "endCol": "58"
    },
    "2145": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "45",
      "startCol": "3",
      "endLine": "45",
      "endCol": "66"
    },
    "2146": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "49",
      "startCol": "23",
      "endLine": "49",
      "endCol": "46"
    },
    "2147": {
      "patternID": "pattern3",
      "file": "scripts/front/reorder-admin-translation-files.js",
      "startLine": "72",
      "startCol": "3",
      "endLine": "72",
      "endCol": "72"
    },
    "2148": {
      "patternID": "pattern3",
      "file": "scripts/link.js",
      "startLine": "10",
      "startCol": "23",
      "endLine": "10",
      "endCol": "46"
    },
    "2149": {
      "patternID": "pattern3",
      "file": "scripts/link.js",
      "startLine": "19",
      "startCol": "3",
      "endLine": "19",
      "endCol": "85"
    },
    "2150": {
      "patternID": "pattern3",
      "file": "scripts/open-api/serve.js",
      "startLine": "23",
      "startCol": "9",
      "endLine": "23",
      "endCol": "45"
    },
    "2151": {
      "patternID": "pattern3",
      "file": "scripts/open-api/serve.js",
      "startLine": "35",
      "startCol": "16",
      "endLine": "35",
      "endCol": "51"
    },
    "2152": {
      "patternID": "pattern3",
      "file": "scripts/unlink.js",
      "startLine": "10",
      "startCol": "23",
      "endLine": "10",
      "endCol": "46"
    },
    "2153": {
      "patternID": "pattern3",
      "file": "scripts/unlink.js",
      "startLine": "19",
      "startCol": "3",
      "endLine": "19",
      "endCol": "87"
    },
    "2154": {
      "patternID": "pattern3",
      "file": "test/e2e.js",
      "startLine": "55",
      "startCol": "5",
      "endLine": "59",
      "endCol": "6"
    },
    "2155": {
      "patternID": "pattern3",
      "file": "test/helpers/agent.js",
      "startLine": "71",
      "startCol": "31",
      "endLine": "71",
      "endCol": "57"
    },
    "2156": {
      "patternID": "pattern3",
      "file": "test/helpers/agent.js",
      "startLine": "79",
      "startCol": "31",
      "endLine": "79",
      "endCol": "74"
    },
    "2157": {
      "patternID": "pattern3",
      "file": "test/helpers/auth.js",
      "startLine": "15",
      "startCol": "3",
      "endLine": "23",
      "endCol": "4"
    },
    "2158": {
      "patternID": "pattern3",
      "file": "test/helpers/auth.js",
      "startLine": "27",
      "startCol": "20",
      "endLine": "34",
      "endCol": "4"
    },
    "2159": {
      "patternID": "pattern3",
      "file": "test/helpers/builder/index.js",
      "startLine": "68",
      "startCol": "9",
      "endLine": "68",
      "endCol": "31"
    },
    "2160": {
      "patternID": "pattern3",
      "file": "test/helpers/builder/index.js",
      "startLine": "85",
      "startCol": "9",
      "endLine": "85",
      "endCol": "33"
    },
    "2161": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "28",
      "startCol": "23",
      "endLine": "33",
      "endCol": "4"
    },
    "2162": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "35",
      "startCol": "3",
      "endLine": "35",
      "endCol": "17"
    },
    "2163": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "43",
      "startCol": "24",
      "endLine": "50",
      "endCol": "3"
    },
    "2164": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "52",
      "startCol": "3",
      "endLine": "52",
      "endCol": "17"
    },
    "2165": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "60",
      "startCol": "28",
      "endLine": "67",
      "endCol": "4"
    },
    "2166": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "69",
      "startCol": "3",
      "endLine": "69",
      "endCol": "17"
    },
    "2167": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "87",
      "startCol": "21",
      "endLine": "87",
      "endCol": "73"
    },
    "2168": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "89",
      "startCol": "3",
      "endLine": "89",
      "endCol": "17"
    },
    "2169": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "108",
      "startCol": "23",
      "endLine": "108",
      "endCol": "69"
    },
    "2170": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "110",
      "startCol": "3",
      "endLine": "110",
      "endCol": "17"
    },
    "2171": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "119",
      "startCol": "24",
      "endLine": "119",
      "endCol": "89"
    },
    "2172": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "121",
      "startCol": "3",
      "endLine": "121",
      "endCol": "17"
    },
    "2173": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "135",
      "startCol": "3",
      "endLine": "135",
      "endCol": "36"
    },
    "2174": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "137",
      "startCol": "3",
      "endLine": "137",
      "endCol": "17"
    },
    "2175": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "149",
      "startCol": "20",
      "endLine": "149",
      "endCol": "57"
    },
    "2176": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "155",
      "startCol": "3",
      "endLine": "155",
      "endCol": "17"
    },
    "2177": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "166",
      "startCol": "18",
      "endLine": "166",
      "endCol": "63"
    },
    "2178": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "169",
      "startCol": "3",
      "endLine": "169",
      "endCol": "17"
    },
    "2179": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "177",
      "startCol": "3",
      "endLine": "177",
      "endCol": "70"
    },
    "2180": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "179",
      "startCol": "3",
      "endLine": "179",
      "endCol": "17"
    },
    "2181": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "191",
      "startCol": "14",
      "endLine": "196",
      "endCol": "4"
    },
    "2182": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "198",
      "startCol": "3",
      "endLine": "198",
      "endCol": "17"
    },
    "2183": {
      "patternID": "pattern3",
      "file": "test/helpers/models.js",
      "startLine": "209",
      "startCol": "3",
      "endLine": "209",
      "endCol": "17"
    },
    "2184": {
      "patternID": "pattern3",
      "file": "test/helpers/strapi.js",
      "startLine": "27",
      "startCol": "3",
      "endLine": "31",
      "endCol": "42"
    },
    "2185": {
      "patternID": "pattern3",
      "file": "test/helpers/strapi.js",
      "startLine": "36",
      "startCol": "5",
      "endLine": "36",
      "endCol": "60"
    },
    "2186": {
      "patternID": "pattern3",
      "file": "test/helpers/utils.js",
      "startLine": "8",
      "startCol": "18",
      "endLine": "8",
      "endCol": "76"
    },
    "2187": {
      "patternID": "pattern3",
      "file": "test/helpers/utils.js",
      "startLine": "24",
      "startCol": "28",
      "endLine": "24",
      "endCol": "89"
    },
    "2188": {
      "patternID": "pattern3",
      "file": "test/helpers/utils.js",
      "startLine": "41",
      "startCol": "20",
      "endLine": "41",
      "endCol": "54"
    }
  },
  "files": {
    "node_modules/jest-jasmine2/build/queueRunner.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = queueRunner;\n\nvar _jestUtil = require('jest-util');\n\nvar _PCancelable = _interopRequireDefault(require('./PCancelable'));\n\nvar _pTimeout = _interopRequireDefault(require('./pTimeout'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction queueRunner(options) {\n  const token = new _PCancelable.default((onCancel, resolve) => {\n    onCancel(resolve);\n  });\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];\n\n        if (err) {\n          options.fail.apply(null, args);\n        }\n\n        resolve();\n      };\n\n      next.fail = function (...args) {\n        options.fail.apply(null, args);\n        resolve();\n      };\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve();\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise;\n    }\n\n    const timeoutMs = timeout();\n    return (0, _pTimeout.default)(\n      promise,\n      timeoutMs,\n      options.clearTimeout,\n      options.setTimeout,\n      () => {\n        initError.message =\n          'Timeout - Async callback was not invoked within the ' +\n          (0, _jestUtil.formatTime)(timeoutMs) +\n          ' timeout specified by jest.setTimeout.';\n        initError.stack = initError.message + initError.stack;\n        options.onException(initError);\n      }\n    );\n  };\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token),\n    catch: result.catch.bind(result),\n    then: result.then.bind(result)\n  };\n}\n",
    "node_modules/jest-runner/build/runTest.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = runTest;\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _sourceMapSupport() {\n  const data = _interopRequireDefault(require('source-map-support'));\n\n  _sourceMapSupport = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _console() {\n  const data = require('@jest/console');\n\n  _console = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction docblock() {\n  const data = _interopRequireWildcard(require('jest-docblock'));\n\n  docblock = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestLeakDetector() {\n  const data = _interopRequireDefault(require('jest-leak-detector'));\n\n  _jestLeakDetector = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRuntime() {\n  const data = _interopRequireDefault(require('jest-runtime'));\n\n  _jestRuntime = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction freezeConsole(testConsole, config) {\n  // @ts-expect-error: `_log` is `private` - we should figure out some proper API here\n  testConsole._log = function fakeConsolePush(_type, message) {\n    const error = new (_jestUtil().ErrorWithStack)(\n      `${_chalk().default.red(\n        `${_chalk().default.bold(\n          'Cannot log after tests are done.'\n        )} Did you forget to wait for something async in your test?`\n      )}\\nAttempted to log \"${message}\".`,\n      fakeConsolePush\n    );\n    const formattedError = (0, _jestMessageUtil().formatExecError)(\n      error,\n      config,\n      {\n        noStackTrace: false\n      },\n      undefined,\n      true\n    );\n    process.stderr.write('\\n' + formattedError + '\\n'); // TODO: set exit code in Jest 25\n    // process.exitCode = 1;\n  };\n} // Keeping the core of \"runTest\" as a separate function (as \"runTestInternal\")\n// is key to be able to detect memory leaks. Since all variables are local to\n// the function, when \"runTestInternal\" finishes its execution, they can all be\n// freed, UNLESS something else is leaking them (and that's why we can detect\n// the leak!).\n//\n// If we had all the code in a single function, we should manually nullify all\n// references to verify if there is a leak, which is not maintainable and error\n// prone. That's why \"runTestInternal\" CANNOT be inlined inside \"runTest\".\n\nasync function runTestInternal(\n  path,\n  globalConfig,\n  config,\n  resolver,\n  context,\n  sendMessageToJest\n) {\n  const testSource = fs().readFileSync(path, 'utf8');\n  const docblockPragmas = docblock().parse(docblock().extract(testSource));\n  const customEnvironment = docblockPragmas['jest-environment'];\n  let testEnvironment = config.testEnvironment;\n\n  if (customEnvironment) {\n    if (Array.isArray(customEnvironment)) {\n      throw new Error(\n        `You can only define a single test environment through docblocks, got \"${customEnvironment.join(\n          ', '\n        )}\"`\n      );\n    }\n\n    testEnvironment = (0, _jestConfig().getTestEnvironment)({\n      ...config,\n      testEnvironment: customEnvironment\n    });\n  }\n\n  const TestEnvironment = (0, _jestUtil().interopRequireDefault)(\n    require(testEnvironment)\n  ).default;\n  const testFramework = (0, _jestUtil().interopRequireDefault)(\n    process.env.JEST_CIRCUS === '1' // eslint-disable-next-line import/no-extraneous-dependencies\n      ? require('jest-circus/runner')\n      : require(config.testRunner)\n  ).default;\n  const Runtime = (0, _jestUtil().interopRequireDefault)(\n    config.moduleLoader ? require(config.moduleLoader) : require('jest-runtime')\n  ).default;\n  const consoleOut = globalConfig.useStderr ? process.stderr : process.stdout;\n\n  const consoleFormatter = (type, message) =>\n    (0, _console().getConsoleOutput)(\n      config.cwd,\n      !!globalConfig.verbose, // 4 = the console call is buried 4 stack frames deep\n      _console().BufferedConsole.write([], type, message, 4),\n      config,\n      globalConfig\n    );\n\n  let testConsole;\n\n  if (globalConfig.silent) {\n    testConsole = new (_console().NullConsole)(\n      consoleOut,\n      consoleOut,\n      consoleFormatter\n    );\n  } else if (globalConfig.verbose) {\n    testConsole = new (_console().CustomConsole)(\n      consoleOut,\n      consoleOut,\n      consoleFormatter\n    );\n  } else {\n    testConsole = new (_console().BufferedConsole)();\n  }\n\n  const environment = new TestEnvironment(config, {\n    console: testConsole,\n    docblockPragmas,\n    testPath: path\n  });\n  const leakDetector = config.detectLeaks\n    ? new (_jestLeakDetector().default)(environment)\n    : null;\n  const cacheFS = {\n    [path]: testSource\n  };\n  (0, _jestUtil().setGlobal)(environment.global, 'console', testConsole);\n  const runtime = new Runtime(\n    config,\n    environment,\n    resolver,\n    cacheFS,\n    {\n      changedFiles:\n        context === null || context === void 0 ? void 0 : context.changedFiles,\n      collectCoverage: globalConfig.collectCoverage,\n      collectCoverageFrom: globalConfig.collectCoverageFrom,\n      collectCoverageOnlyFrom: globalConfig.collectCoverageOnlyFrom,\n      coverageProvider: globalConfig.coverageProvider,\n      sourcesRelatedToTestsInChangedFiles:\n        context === null || context === void 0\n          ? void 0\n          : context.sourcesRelatedToTestsInChangedFiles\n    },\n    path\n  );\n  const start = Date.now();\n\n  for (const path of config.setupFiles) {\n    var _runtime$unstable_sho;\n\n    // TODO: remove ? in Jest 26\n    const esm =\n      (_runtime$unstable_sho = runtime.unstable_shouldLoadAsEsm) === null ||\n      _runtime$unstable_sho === void 0\n        ? void 0\n        : _runtime$unstable_sho.call(runtime, path);\n\n    if (esm) {\n      await runtime.unstable_importModule(path);\n    } else {\n      runtime.requireModule(path);\n    }\n  }\n\n  const sourcemapOptions = {\n    environment: 'node',\n    handleUncaughtExceptions: false,\n    retrieveSourceMap: source => {\n      const sourceMaps = runtime.getSourceMaps();\n      const sourceMapSource = sourceMaps && sourceMaps[source];\n\n      if (sourceMapSource) {\n        try {\n          return {\n            map: JSON.parse(fs().readFileSync(sourceMapSource, 'utf8')),\n            url: source\n          };\n        } catch {}\n      }\n\n      return null;\n    }\n  }; // For tests\n\n  runtime\n    .requireInternalModule(\n      require.resolve('source-map-support'),\n      'source-map-support'\n    )\n    .install(sourcemapOptions); // For runtime errors\n\n  _sourceMapSupport().default.install(sourcemapOptions);\n\n  if (\n    environment.global &&\n    environment.global.process &&\n    environment.global.process.exit\n  ) {\n    const realExit = environment.global.process.exit;\n\n    environment.global.process.exit = function exit(...args) {\n      const error = new (_jestUtil().ErrorWithStack)(\n        `process.exit called with \"${args.join(', ')}\"`,\n        exit\n      );\n      const formattedError = (0, _jestMessageUtil().formatExecError)(\n        error,\n        config,\n        {\n          noStackTrace: false\n        },\n        undefined,\n        true\n      );\n      process.stderr.write(formattedError);\n      return realExit(...args);\n    };\n  } // if we don't have `getVmContext` on the env skip coverage\n\n  const collectV8Coverage =\n    globalConfig.coverageProvider === 'v8' &&\n    typeof environment.getVmContext === 'function';\n\n  try {\n    await environment.setup();\n    let result;\n\n    try {\n      if (collectV8Coverage) {\n        await runtime.collectV8Coverage();\n      }\n\n      result = await testFramework(\n        globalConfig,\n        config,\n        environment,\n        runtime,\n        path,\n        sendMessageToJest\n      );\n    } catch (err) {\n      // Access stack before uninstalling sourcemaps\n      err.stack;\n      throw err;\n    } finally {\n      if (collectV8Coverage) {\n        await runtime.stopCollectingV8Coverage();\n      }\n    }\n\n    freezeConsole(testConsole, config);\n    const testCount =\n      result.numPassingTests +\n      result.numFailingTests +\n      result.numPendingTests +\n      result.numTodoTests;\n    const end = Date.now();\n    const testRuntime = end - start;\n    result.perfStats = {\n      end,\n      runtime: testRuntime,\n      slow: testRuntime / 1000 > config.slowTestThreshold,\n      start\n    };\n    result.testFilePath = path;\n    result.console = testConsole.getBuffer();\n    result.skipped = testCount === result.numPendingTests;\n    result.displayName = config.displayName;\n    const coverage = runtime.getAllCoverageInfoCopy();\n\n    if (coverage) {\n      const coverageKeys = Object.keys(coverage);\n\n      if (coverageKeys.length) {\n        result.coverage = coverage;\n      }\n    }\n\n    if (collectV8Coverage) {\n      const v8Coverage = runtime.getAllV8CoverageInfoCopy();\n\n      if (v8Coverage && v8Coverage.length > 0) {\n        result.v8Coverage = v8Coverage;\n      }\n    }\n\n    if (globalConfig.logHeapUsage) {\n      if (global.gc) {\n        global.gc();\n      }\n\n      result.memoryUsage = process.memoryUsage().heapUsed;\n    } // Delay the resolution to allow log messages to be output.\n\n    return new Promise(resolve => {\n      setImmediate(() =>\n        resolve({\n          leakDetector,\n          result\n        })\n      );\n    });\n  } finally {\n    var _runtime$teardown;\n\n    await environment.teardown(); // TODO: this function might be missing, remove ? in Jest 26\n\n    (_runtime$teardown = runtime.teardown) === null ||\n    _runtime$teardown === void 0\n      ? void 0\n      : _runtime$teardown.call(runtime);\n\n    _sourceMapSupport().default.resetRetrieveHandlers();\n  }\n}\n\nasync function runTest(\n  path,\n  globalConfig,\n  config,\n  resolver,\n  context,\n  sendMessageToJest\n) {\n  const {leakDetector, result} = await runTestInternal(\n    path,\n    globalConfig,\n    config,\n    resolver,\n    context,\n    sendMessageToJest\n  );\n\n  if (leakDetector) {\n    // We wanna allow a tiny but time to pass to allow last-minute cleanup\n    await new Promise(resolve => setTimeout(resolve, 100)); // Resolve leak detector, outside the \"runTestInternal\" closure.\n\n    result.leaks = await leakDetector.isLeaking();\n  } else {\n    result.leaks = false;\n  }\n\n  return result;\n}\n",
    "node_modules/jest-jasmine2/build/jasmine/Spec.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _assert = require('assert');\n\nvar _ExpectationFailed = _interopRequireDefault(\n  require('../ExpectationFailed')\n);\n\nvar _assertionErrorMessage = _interopRequireDefault(\n  require('../assertionErrorMessage')\n);\n\nvar _expectationResultFactory = _interopRequireDefault(\n  require('../expectationResultFactory')\n);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nclass Spec {\n  static isPendingSpecException(e) {\n    return !!(\n      e &&\n      e.toString &&\n      e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1\n    );\n  }\n\n  constructor(attrs) {\n    _defineProperty(this, 'id', void 0);\n\n    _defineProperty(this, 'description', void 0);\n\n    _defineProperty(this, 'resultCallback', void 0);\n\n    _defineProperty(this, 'queueableFn', void 0);\n\n    _defineProperty(this, 'beforeAndAfterFns', void 0);\n\n    _defineProperty(this, 'userContext', void 0);\n\n    _defineProperty(this, 'onStart', void 0);\n\n    _defineProperty(this, 'getSpecName', void 0);\n\n    _defineProperty(this, 'queueRunnerFactory', void 0);\n\n    _defineProperty(this, 'throwOnExpectationFailure', void 0);\n\n    _defineProperty(this, 'initError', void 0);\n\n    _defineProperty(this, 'result', void 0);\n\n    _defineProperty(this, 'disabled', void 0);\n\n    _defineProperty(this, 'currentRun', void 0);\n\n    _defineProperty(this, 'markedTodo', void 0);\n\n    _defineProperty(this, 'markedPending', void 0);\n\n    _defineProperty(this, 'expand', void 0);\n\n    this.resultCallback = attrs.resultCallback || function () {};\n\n    this.id = attrs.id;\n    this.description = attrs.description || '';\n    this.queueableFn = attrs.queueableFn;\n\n    this.beforeAndAfterFns =\n      attrs.beforeAndAfterFns ||\n      function () {\n        return {\n          befores: [],\n          afters: []\n        };\n      };\n\n    this.userContext =\n      attrs.userContext ||\n      function () {\n        return {};\n      };\n\n    this.onStart = attrs.onStart || function () {};\n\n    this.getSpecName =\n      attrs.getSpecName ||\n      function () {\n        return '';\n      };\n\n    this.queueRunnerFactory = attrs.queueRunnerFactory || function () {};\n\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n    this.initError = new Error();\n    this.initError.name = ''; // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    this.initError.stack = this.initError.stack;\n    this.queueableFn.initError = this.initError; // @ts-expect-error\n\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: [],\n      passedExpectations: [],\n      pendingReason: '',\n      testPath: attrs.getTestPath()\n    };\n  }\n\n  addExpectationResult(passed, data, isError) {\n    const expectationResult = (0, _expectationResultFactory.default)(\n      data,\n      this.initError\n    );\n\n    if (passed) {\n      this.result.passedExpectations.push(expectationResult);\n    } else {\n      this.result.failedExpectations.push(expectationResult);\n\n      if (this.throwOnExpectationFailure && !isError) {\n        throw new _ExpectationFailed.default();\n      }\n    }\n  }\n\n  execute(onComplete, enabled) {\n    const self = this;\n    this.onStart(this);\n\n    if (\n      !this.isExecutable() ||\n      this.markedPending ||\n      this.markedTodo ||\n      enabled === false\n    ) {\n      complete(enabled);\n      return;\n    }\n\n    const fns = this.beforeAndAfterFns();\n    const allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\n    this.currentRun = this.queueRunnerFactory({\n      queueableFns: allFns,\n\n      onException() {\n        // @ts-expect-error\n        self.onException.apply(self, arguments);\n      },\n\n      userContext: this.userContext(),\n      setTimeout,\n      clearTimeout,\n      fail: () => {}\n    });\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain);\n      self.resultCallback(self.result);\n\n      if (onComplete) {\n        onComplete();\n      }\n    }\n  }\n\n  cancel() {\n    if (this.currentRun) {\n      this.currentRun.cancel();\n    }\n  }\n\n  onException(error) {\n    if (Spec.isPendingSpecException(error)) {\n      this.pend(extractCustomPendingMessage(error));\n      return;\n    }\n\n    if (error instanceof _ExpectationFailed.default) {\n      return;\n    }\n\n    this.addExpectationResult(\n      false,\n      {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        error: this.isAssertionError(error)\n          ? (0, _assertionErrorMessage.default)(error, {\n              expand: this.expand\n            })\n          : error\n      },\n      true\n    );\n  }\n\n  disable() {\n    this.disabled = true;\n  }\n\n  pend(message) {\n    this.markedPending = true;\n\n    if (message) {\n      this.result.pendingReason = message;\n    }\n  }\n\n  todo() {\n    this.markedTodo = true;\n  }\n\n  getResult() {\n    this.result.status = this.status();\n    return this.result;\n  }\n\n  status(enabled) {\n    if (this.disabled || enabled === false) {\n      return 'disabled';\n    }\n\n    if (this.markedTodo) {\n      return 'todo';\n    }\n\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'passed';\n    }\n  }\n\n  isExecutable() {\n    return !this.disabled;\n  }\n\n  getFullName() {\n    return this.getSpecName(this);\n  }\n\n  isAssertionError(error) {\n    return (\n      error instanceof _assert.AssertionError ||\n      (error && error.name === _assert.AssertionError.name)\n    );\n  }\n}\n\nexports.default = Spec;\n\n_defineProperty(Spec, 'pendingSpecExceptionMessage', void 0);\n\nSpec.pendingSpecExceptionMessage = '=> marked Pending';\n\nconst extractCustomPendingMessage = function (e) {\n  const fullMessage = e.toString();\n  const boilerplateStart = fullMessage.indexOf(\n    Spec.pendingSpecExceptionMessage\n  );\n  const boilerplateEnd =\n    boilerplateStart + Spec.pendingSpecExceptionMessage.length;\n  return fullMessage.substr(boilerplateEnd);\n};\n",
    "node_modules/jest-jasmine2/build/pTimeout.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = pTimeout;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// A specialized version of `p-timeout` that does not touch globals.\n// It does not throw on timeout.\nfunction pTimeout(promise, ms, clearTimeout, setTimeout, onTimeout) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val);\n      },\n      err => {\n        clearTimeout(timer);\n        reject(err);\n      }\n    );\n  });\n}\n",
    "packages/strapi-admin/controllers/__tests__/role.test.js": "'use strict';\n\nconst createContext = require('../../../../test/helpers/create-context');\nconst roleController = require('../role');\n\ndescribe('Role controller', () => {\n  describe('getPermissions', () => {\n    test('Fails if role does not exist', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n      const notFound = jest.fn();\n\n      const ctx = createContext(\n        {\n          params: { id: 1 },\n        },\n        {\n          notFound,\n        }\n      );\n\n      global.strapi = {\n        admin: {\n          services: {\n            role: {\n              findOne,\n            },\n          },\n        },\n      };\n\n      await roleController.getPermissions(ctx);\n\n      expect(findOne).toHaveBeenCalledWith({ id: ctx.params.id });\n      expect(notFound).toHaveBeenCalled();\n    });\n\n    test('Finds permissions correctly', async () => {\n      const permissions = [\n        {\n          action: 'test1',\n        },\n        {\n          action: 'test2',\n          subject: 'model1',\n        },\n      ];\n\n      const findOneRole = jest.fn(() => Promise.resolve({ id: 1 }));\n      const findPermissions = jest.fn(() => Promise.resolve(permissions));\n      const sanitizePermission = jest.fn(perms => perms);\n\n      const ctx = createContext({\n        params: { id: 1 },\n      });\n\n      global.strapi = {\n        admin: {\n          services: {\n            role: {\n              findOne: findOneRole,\n            },\n            permission: {\n              find: findPermissions,\n              sanitizePermission,\n            },\n          },\n        },\n      };\n\n      await roleController.getPermissions(ctx);\n\n      expect(findOneRole).toHaveBeenCalledWith({ id: ctx.params.id });\n      expect(findPermissions).toHaveBeenCalledWith({ role: ctx.params.id, _limit: -1 });\n      expect(ctx.body).toEqual({\n        data: permissions,\n      });\n    });\n  });\n\n  describe('updatePermissions', () => {\n    test('Fails on missing permissions input', async () => {\n      const badRequest = jest.fn();\n      const findOne = jest.fn(() => Promise.resolve({ id: 1 }));\n\n      const ctx = createContext(\n        {\n          params: { id: 1 },\n          body: {},\n        },\n        { badRequest }\n      );\n\n      global.strapi = {\n        admin: {\n          services: {\n            role: {\n              findOne,\n            },\n          },\n        },\n      };\n\n      await roleController.updatePermissions(ctx);\n\n      expect(badRequest).toHaveBeenCalledWith(\n        'ValidationError',\n        expect.objectContaining({\n          permissions: expect.arrayContaining([]),\n        })\n      );\n    });\n\n    test('Fails on missing action permission', async () => {\n      const badRequest = jest.fn();\n      const findOne = jest.fn(() => Promise.resolve({ id: 1 }));\n\n      const ctx = createContext(\n        {\n          params: { id: 1 },\n          body: {\n            permissions: [{}],\n          },\n        },\n        { badRequest }\n      );\n      global.strapi = {\n        admin: {\n          services: {\n            role: { findOne },\n            permission: { conditionProvider: { getAll: jest.fn(() => []) } },\n          },\n        },\n      };\n\n      await roleController.updatePermissions(ctx);\n\n      expect(badRequest).toHaveBeenCalledWith(\n        'ValidationError',\n        expect.objectContaining({\n          'permissions[0].action': expect.arrayContaining([\n            'permissions[0].action is a required field',\n          ]),\n        })\n      );\n    });\n\n    test('Assign permissions if input is valid', async () => {\n      const roleID = 1;\n      const findOneRole = jest.fn(() => Promise.resolve({ id: roleID }));\n      const assignPermissions = jest.fn((roleID, permissions) => Promise.resolve(permissions));\n      const inputPermissions = [\n        {\n          action: 'test',\n          subject: 'model1',\n          fields: ['title'],\n          conditions: ['admin::is-creator'],\n        },\n      ];\n\n      const ctx = createContext({\n        params: { id: roleID },\n        body: {\n          permissions: inputPermissions,\n        },\n      });\n\n      global.strapi = {\n        admin: {\n          services: {\n            role: {\n              assignPermissions,\n              findOne: findOneRole,\n              getSuperAdmin: jest.fn(() => undefined),\n            },\n            permission: {\n              conditionProvider: {\n                getAll: jest.fn(() => [{ id: 'admin::is-creator' }]),\n              },\n              actionProvider: {\n                getAll: jest.fn(() => [{ actionId: 'test', subjects: ['model1'] }]),\n                getAllByMap: jest.fn(),\n                getByActionId: jest.fn(() => ({ options: { fieldsRestriction: true } })),\n              },\n            },\n          },\n        },\n      };\n\n      await roleController.updatePermissions(ctx);\n\n      expect(findOneRole).toHaveBeenCalledWith({ id: roleID });\n      expect(assignPermissions).toHaveBeenCalledWith(roleID, inputPermissions);\n\n      expect(ctx.body).toEqual({\n        data: inputPermissions,\n      });\n    });\n  });\n});\n",
    "node_modules/jest-jasmine2/build/jasmineAsyncInstall.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = jasmineAsyncInstall;\n\nvar _co = _interopRequireDefault(require('co'));\n\nvar _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));\n\nvar _throat = _interopRequireDefault(require('throat'));\n\nvar _isError = _interopRequireDefault(require('./isError'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction isPromise(obj) {\n  return obj && typeof obj.then === 'function';\n}\n\nconst doneFnNoop = () => {};\n\ndoneFnNoop.fail = () => {};\n\nfunction promisifyLifeCycleFunction(originalFn, env) {\n  return function (fn, timeout) {\n    if (!fn) {\n      // @ts-expect-error: missing fn arg is handled by originalFn\n      return originalFn.call(env);\n    }\n\n    const hasDoneCallback = typeof fn === 'function' && fn.length > 0;\n\n    if (hasDoneCallback) {\n      // Jasmine will handle it\n      return originalFn.call(env, fn, timeout);\n    }\n\n    const extraError = new Error(); // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    extraError.stack = extraError.stack; // We make *all* functions async and run `done` right away if they\n    // didn't return a promise.\n\n    const asyncJestLifecycle = function (done) {\n      const wrappedFn = (0, _isGeneratorFn.default)(fn)\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) {\n            extraError.message = message;\n          }\n\n          done.fail(checkIsError ? error : extraError);\n        });\n      } else {\n        done();\n      }\n    };\n\n    return originalFn.call(env, asyncJestLifecycle, timeout);\n  };\n} // Similar to promisifyLifeCycleFunction but throws an error\n// when the return value is neither a Promise nor `undefined`\n\nfunction promisifyIt(originalFn, env, jasmine) {\n  return function (specName, fn, timeout) {\n    if (!fn) {\n      // @ts-expect-error: missing fn arg is handled by originalFn\n      const spec = originalFn.call(env, specName);\n      spec.pend('not implemented');\n      return spec;\n    }\n\n    const hasDoneCallback = fn.length > 0;\n\n    if (hasDoneCallback) {\n      return originalFn.call(env, specName, fn, timeout);\n    }\n\n    const extraError = new Error(); // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    extraError.stack = extraError.stack;\n\n    const asyncJestTest = function (done) {\n      const wrappedFn = (0, _isGeneratorFn.default)(fn)\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) {\n            extraError.message = message;\n          }\n\n          if (jasmine.Spec.isPendingSpecException(error)) {\n            env.pending(message);\n            done();\n          } else {\n            done.fail(checkIsError ? error : extraError);\n          }\n        });\n      } else if (returnValue === undefined) {\n        done();\n      } else {\n        done.fail(\n          new Error(\n            'Jest: `it` and `test` must return either a Promise or undefined.'\n          )\n        );\n      }\n    };\n\n    return originalFn.call(env, specName, asyncJestTest, timeout);\n  };\n}\n\nfunction makeConcurrent(originalFn, env, mutex) {\n  const concurrentFn = function (specName, fn, timeout) {\n    let promise = Promise.resolve();\n    const spec = originalFn.call(env, specName, () => promise, timeout);\n\n    if (env != null && !env.specFilter(spec)) {\n      return spec;\n    }\n\n    try {\n      promise = mutex(() => {\n        const promise = fn();\n\n        if (isPromise(promise)) {\n          return promise;\n        }\n\n        throw new Error(\n          `Jest: concurrent test \"${spec.getFullName()}\" must return a Promise.`\n        );\n      });\n    } catch (error) {\n      promise = Promise.reject(error);\n    }\n\n    return spec;\n  }; // each is binded after the function is made concurrent, so for now it is made noop\n\n  concurrentFn.each = () => () => {};\n\n  return concurrentFn;\n}\n\nfunction jasmineAsyncInstall(globalConfig, global) {\n  const jasmine = global.jasmine;\n  const mutex = (0, _throat.default)(globalConfig.maxConcurrency);\n  const env = jasmine.getEnv();\n  env.it = promisifyIt(env.it, env, jasmine);\n  env.fit = promisifyIt(env.fit, env, jasmine);\n\n  global.it.concurrent = (env => {\n    const concurrent = makeConcurrent(env.it, env, mutex);\n    concurrent.only = makeConcurrent(env.fit, env, mutex);\n    concurrent.skip = makeConcurrent(env.xit, env, mutex);\n    return concurrent;\n  })(env);\n\n  global.fit.concurrent = makeConcurrent(env.fit, env, mutex);\n  env.afterAll = promisifyLifeCycleFunction(env.afterAll, env);\n  env.afterEach = promisifyLifeCycleFunction(env.afterEach, env);\n  env.beforeAll = promisifyLifeCycleFunction(env.beforeAll, env);\n  env.beforeEach = promisifyLifeCycleFunction(env.beforeEach, env);\n}\n",
    "node_modules/jest-jasmine2/build/PCancelable.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nclass CancelError extends Error {\n  constructor() {\n    super('Promise was canceled');\n    this.name = 'CancelError';\n  }\n}\n\nclass PCancelable extends Promise {\n  constructor(executor) {\n    super(resolve => resolve());\n\n    _defineProperty(this, '_pending', true);\n\n    _defineProperty(this, '_canceled', false);\n\n    _defineProperty(this, '_promise', void 0);\n\n    _defineProperty(this, '_cancel', void 0);\n\n    _defineProperty(this, '_reject', () => {});\n\n    this._promise = new Promise((resolve, reject) => {\n      this._reject = reject;\n      return executor(\n        fn => {\n          this._cancel = fn;\n        },\n        val => {\n          this._pending = false;\n          resolve(val);\n        },\n        err => {\n          this._pending = false;\n          reject(err);\n        }\n      );\n    });\n  }\n\n  then(onFulfilled, onRejected) {\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    return this._promise.catch(onRejected);\n  }\n\n  cancel() {\n    if (!this._pending || this._canceled) {\n      return;\n    }\n\n    if (typeof this._cancel === 'function') {\n      try {\n        this._cancel();\n      } catch (err) {\n        this._reject(err);\n      }\n    }\n\n    this._canceled = true;\n\n    this._reject(new CancelError());\n  }\n}\n\nexports.default = PCancelable;\n",
    "packages/strapi-utils/node_modules/yup/lib/util/runValidations.js": "\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.propagateErrors = propagateErrors;\nexports.settled = settled;\nexports.collectErrors = collectErrors;\nexports.default = runValidations;\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar _synchronousPromise = require(\"synchronous-promise\");\n\nvar _ValidationError = _interopRequireDefault(require(\"../ValidationError\"));\n\nvar promise = function promise(sync) {\n  return sync ? _synchronousPromise.SynchronousPromise : Promise;\n};\n\nvar unwrapError = function unwrapError(errors) {\n  if (errors === void 0) {\n    errors = [];\n  }\n\n  return errors.inner && errors.inner.length ? errors.inner : [].concat(errors);\n};\n\nfunction scopeToValue(promises, value, sync) {\n  //console.log('scopeToValue', promises, value)\n  var p = promise(sync).all(promises); //console.log('scopeToValue B', p)\n\n  var b = p.catch(function (err) {\n    if (err.name === 'ValidationError') err.value = value;\n    throw err;\n  }); //console.log('scopeToValue c', b)\n\n  var c = b.then(function () {\n    return value;\n  }); //console.log('scopeToValue d', c)\n\n  return c;\n}\n/**\n * If not failing on the first error, catch the errors\n * and collect them in an array\n */\n\n\nfunction propagateErrors(endEarly, errors) {\n  return endEarly ? null : function (err) {\n    errors.push(err);\n    return err.value;\n  };\n}\n\nfunction settled(promises, sync) {\n  var Promise = promise(sync);\n  return Promise.all(promises.map(function (p) {\n    return Promise.resolve(p).then(function (value) {\n      return {\n        fulfilled: true,\n        value: value\n      };\n    }, function (value) {\n      return {\n        fulfilled: false,\n        value: value\n      };\n    });\n  }));\n}\n\nfunction collectErrors(_ref) {\n  var validations = _ref.validations,\n      value = _ref.value,\n      path = _ref.path,\n      sync = _ref.sync,\n      errors = _ref.errors,\n      sort = _ref.sort;\n  errors = unwrapError(errors);\n  return settled(validations, sync).then(function (results) {\n    var nestedErrors = results.filter(function (r) {\n      return !r.fulfilled;\n    }).reduce(function (arr, _ref2) {\n      var error = _ref2.value;\n\n      // we are only collecting validation errors\n      if (!_ValidationError.default.isError(error)) {\n        throw error;\n      }\n\n      return arr.concat(error);\n    }, []);\n    if (sort) nestedErrors.sort(sort); //show parent errors after the nested ones: name.first, name\n\n    errors = nestedErrors.concat(errors);\n    if (errors.length) throw new _ValidationError.default(errors, value, path);\n    return value;\n  });\n}\n\nfunction runValidations(_ref3) {\n  var endEarly = _ref3.endEarly,\n      options = (0, _objectWithoutPropertiesLoose2.default)(_ref3, [\"endEarly\"]);\n  if (endEarly) return scopeToValue(options.validations, options.value, options.sync);\n  return collectErrors(options);\n}",
    "node_modules/jsdom/lib/jsdom/living/nodes/Document-impl.js": "\"use strict\";\n\nconst { CookieJar } = require(\"tough-cookie\");\n\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst idlUtils = require(\"../generated/utils\");\nconst NODE_TYPE = require(\"../node-type\");\nconst { mixin, memoizeQuery } = require(\"../../utils\");\nconst { firstChildWithLocalName, firstChildWithLocalNames, firstDescendantWithLocalName } =\n  require(\"../helpers/traversal\");\nconst whatwgURL = require(\"whatwg-url\");\nconst StyleSheetList = require(\"../generated/StyleSheetList.js\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst eventAccessors = require(\"../helpers/create-event-accessor\");\nconst { asciiLowercase, stripAndCollapseASCIIWhitespace } = require(\"../helpers/strings\");\nconst { childTextContent } = require(\"../helpers/text\");\nconst { HTML_NS, SVG_NS } = require(\"../helpers/namespaces\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst { parseIntoDocument } = require(\"../../browser/parser\");\nconst History = require(\"../generated/History\");\nconst Location = require(\"../generated/Location\");\nconst HTMLCollection = require(\"../generated/HTMLCollection\");\nconst NodeList = require(\"../generated/NodeList\");\nconst validateName = require(\"../helpers/validate-names\").name;\nconst { validateAndExtract } = require(\"../helpers/validate-names\");\nconst { fireAnEvent } = require(\"../helpers/events\");\nconst { shadowIncludingInclusiveDescendantsIterator } = require(\"../helpers/shadow-dom\");\nconst { enqueueCECallbackReaction } = require(\"../helpers/custom-elements\");\nconst { createElement, internalCreateElementNSSteps } = require(\"../helpers/create-element\");\n\nconst DocumentOrShadowRootImpl = require(\"./DocumentOrShadowRoot-impl\").implementation;\nconst GlobalEventHandlersImpl = require(\"./GlobalEventHandlers-impl\").implementation;\nconst NonElementParentNodeImpl = require(\"./NonElementParentNode-impl\").implementation;\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\n\nconst { clone, listOfElementsWithQualifiedName, listOfElementsWithNamespaceAndLocalName,\n  listOfElementsWithClassNames } = require(\"../node\");\nconst generatedAttr = require(\"../generated/Attr\");\nconst Comment = require(\"../generated/Comment\");\nconst ProcessingInstruction = require(\"../generated/ProcessingInstruction\");\nconst CDATASection = require(\"../generated/CDATASection\");\nconst Text = require(\"../generated/Text\");\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\nconst DOMImplementation = require(\"../generated/DOMImplementation\");\nconst TreeWalker = require(\"../generated/TreeWalker\");\nconst NodeIterator = require(\"../generated/NodeIterator\");\nconst ShadowRoot = require(\"../generated/ShadowRoot\");\nconst Range = require(\"../generated/Range\");\nconst documents = require(\"../documents.js\");\n\nconst CustomEvent = require(\"../generated/CustomEvent\");\nconst ErrorEvent = require(\"../generated/ErrorEvent\");\nconst Event = require(\"../generated/Event\");\nconst FocusEvent = require(\"../generated/FocusEvent\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent\");\nconst KeyboardEvent = require(\"../generated/KeyboardEvent\");\nconst MessageEvent = require(\"../generated/MessageEvent\");\nconst MouseEvent = require(\"../generated/MouseEvent\");\nconst PopStateEvent = require(\"../generated/PopStateEvent\");\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\nconst TouchEvent = require(\"../generated/TouchEvent\");\nconst UIEvent = require(\"../generated/UIEvent\");\n\nconst RequestManager = require(\"../../browser/resources/request-manager\");\nconst AsyncResourceQueue = require(\"../../browser/resources/async-resource-queue\");\nconst ResourceQueue = require(\"../../browser/resources/resource-queue\");\nconst PerDocumentResourceLoader = require(\"../../browser/resources/per-document-resource-loader\");\n\nfunction clearChildNodes(node) {\n  for (let child = domSymbolTree.firstChild(node); child; child = domSymbolTree.firstChild(node)) {\n    node.removeChild(child);\n  }\n}\n\nfunction pad(number) {\n  if (number < 10) {\n    return \"0\" + number;\n  }\n  return number;\n}\n\nfunction toLastModifiedString(date) {\n  return pad(date.getMonth() + 1) +\n    \"/\" + pad(date.getDate()) +\n    \"/\" + date.getFullYear() +\n    \" \" + pad(date.getHours()) +\n    \":\" + pad(date.getMinutes()) +\n    \":\" + pad(date.getSeconds());\n}\n\nconst eventInterfaceTable = {\n  customevent: CustomEvent,\n  errorevent: ErrorEvent,\n  event: Event,\n  events: Event,\n  focusevent: FocusEvent,\n  hashchangeevent: HashChangeEvent,\n  htmlevents: Event,\n  keyboardevent: KeyboardEvent,\n  messageevent: MessageEvent,\n  mouseevent: MouseEvent,\n  mouseevents: MouseEvent,\n  popstateevent: PopStateEvent,\n  progressevent: ProgressEvent,\n  svgevents: Event,\n  touchevent: TouchEvent,\n  uievent: UIEvent,\n  uievents: UIEvent\n};\n\nclass DocumentImpl extends NodeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    this._initGlobalEvents();\n\n    this._ownerDocument = this;\n    this.nodeType = NODE_TYPE.DOCUMENT_NODE;\n    if (!privateData.options) {\n      privateData.options = {};\n    }\n    if (!privateData.options.parsingMode) {\n      privateData.options.parsingMode = \"xml\";\n    }\n    if (!privateData.options.encoding) {\n      privateData.options.encoding = \"UTF-8\";\n    }\n    if (!privateData.options.contentType) {\n      privateData.options.contentType = privateData.options.parsingMode === \"xml\" ? \"application/xml\" : \"text/html\";\n    }\n\n    this._parsingMode = privateData.options.parsingMode;\n\n    this._implementation = DOMImplementation.createImpl(this._globalObject, [], {\n      ownerDocument: this\n    });\n\n    this._defaultView = privateData.options.defaultView || null;\n    this._global = privateData.options.global;\n    this._ids = Object.create(null);\n    this._attached = true;\n    this._currentScript = null;\n    this._pageShowingFlag = false;\n    this._cookieJar = privateData.options.cookieJar;\n    this._parseOptions = privateData.options.parseOptions;\n    this._scriptingDisabled = privateData.options.scriptingDisabled;\n    if (this._cookieJar === undefined) {\n      this._cookieJar = new CookieJar(null, { looseMode: true });\n    }\n\n    this.contentType = privateData.options.contentType;\n    this._encoding = privateData.options.encoding;\n\n    const urlOption = privateData.options.url === undefined ? \"about:blank\" : privateData.options.url;\n    const parsed = whatwgURL.parseURL(urlOption);\n    if (parsed === null) {\n      throw new TypeError(`Could not parse \"${urlOption}\" as a URL`);\n    }\n\n    this._URL = parsed;\n    this._origin = whatwgURL.serializeURLOrigin(parsed);\n\n    this._location = Location.createImpl(this._globalObject, [], { relevantDocument: this });\n    this._history = History.createImpl(this._globalObject, [], {\n      window: this._defaultView,\n      document: this,\n      actAsIfLocationReloadCalled: () => this._location.reload()\n    });\n\n    this._workingNodeIterators = [];\n    this._workingNodeIteratorsMax = privateData.options.concurrentNodeIterators === undefined ?\n                                    10 :\n                                    Number(privateData.options.concurrentNodeIterators);\n\n    if (isNaN(this._workingNodeIteratorsMax)) {\n      throw new TypeError(\"The 'concurrentNodeIterators' option must be a Number\");\n    }\n\n    if (this._workingNodeIteratorsMax < 0) {\n      throw new RangeError(\"The 'concurrentNodeIterators' option must be a non negative Number\");\n    }\n\n    this._referrer = privateData.options.referrer || \"\";\n    this._lastModified = toLastModifiedString(privateData.options.lastModified || new Date());\n    this._asyncQueue = new AsyncResourceQueue();\n    this._queue = new ResourceQueue({ asyncQueue: this._asyncQueue, paused: false });\n    this._deferQueue = new ResourceQueue({ paused: true });\n    this._requestManager = new RequestManager();\n    this._currentDocumentReadiness = privateData.options.readyState || \"loading\";\n\n    this._lastFocusedElement = null;\n\n    this._resourceLoader = new PerDocumentResourceLoader(this);\n\n    // Each Document in a browsing context can also have a latest entry. This is the entry for that Document\n    // to which the browsing context's session history was most recently traversed. When a Document is created,\n    // it initially has no latest entry.\n    this._latestEntry = null;\n\n    // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#throw-on-dynamic-markup-insertion-counter\n    this._throwOnDynamicMarkupInsertionCounter = 0;\n  }\n\n  _getTheParent(event) {\n    if (event.type === \"load\" || !this._defaultView) {\n      return null;\n    }\n\n    return idlUtils.implForWrapper(this._defaultView);\n  }\n\n  get compatMode() {\n    return this._parsingMode === \"xml\" || this.doctype ? \"CSS1Compat\" : \"BackCompat\";\n  }\n  get charset() {\n    return this._encoding;\n  }\n  get characterSet() {\n    return this._encoding;\n  }\n  get inputEncoding() {\n    return this._encoding;\n  }\n  get doctype() {\n    for (const childNode of domSymbolTree.childrenIterator(this)) {\n      if (childNode.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n        return childNode;\n      }\n    }\n    return null;\n  }\n  get URL() {\n    return whatwgURL.serializeURL(this._URL);\n  }\n  get documentURI() {\n    return whatwgURL.serializeURL(this._URL);\n  }\n  get location() {\n    return this._defaultView ? this._location : null;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-documentelement\n  get documentElement() {\n    for (const childNode of domSymbolTree.childrenIterator(this)) {\n      if (childNode.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        return childNode;\n      }\n    }\n\n    return null;\n  }\n\n  get implementation() {\n    return this._implementation;\n  }\n  set implementation(implementation) {\n    this._implementation = implementation;\n  }\n\n  get defaultView() {\n    return this._defaultView;\n  }\n\n  get currentScript() {\n    return this._currentScript;\n  }\n\n  get readyState() {\n    return this._currentDocumentReadiness;\n  }\n\n  set readyState(state) {\n    this._currentDocumentReadiness = state;\n    fireAnEvent(\"readystatechange\", this);\n  }\n\n  hasFocus() {\n    return Boolean(this._lastFocusedElement);\n  }\n\n  _descendantRemoved(parent, child) {\n    if (child.tagName === \"STYLE\") {\n      this.styleSheets._remove(child.sheet);\n    }\n\n    super._descendantRemoved.apply(this, arguments);\n  }\n\n  write() {\n    let text = \"\";\n    for (let i = 0; i < arguments.length; ++i) {\n      text += String(arguments[i]);\n    }\n\n    if (this._parsingMode === \"xml\") {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot use document.write on XML documents\",\n        \"InvalidStateError\"\n      ]);\n    }\n\n    if (this._throwOnDynamicMarkupInsertionCounter > 0) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot use document.write while a custom element upgrades\",\n        \"InvalidStateError\"\n      ]);\n    }\n\n    if (this._writeAfterElement) {\n      // If called from an script element directly (during the first tick),\n      // the new elements are inserted right after that element.\n      const tempDiv = this.createElement(\"div\");\n      tempDiv.innerHTML = text;\n\n      let child = tempDiv.firstChild;\n      let previous = this._writeAfterElement;\n      const parent = this._writeAfterElement.parentNode;\n\n      while (child) {\n        const node = child;\n        child = child.nextSibling;\n\n        node._isMovingDueToDocumentWrite = true; // hack for script execution\n        parent.insertBefore(node, previous.nextSibling);\n        node._isMovingDueToDocumentWrite = false;\n\n        previous = node;\n      }\n    } else if (this.readyState === \"loading\") {\n      // During page loading, document.write appends to the current element\n      // Find the last child that has been added to the document.\n      if (this.lastChild) {\n        let node = this;\n        while (node.lastChild && node.lastChild.nodeType === NODE_TYPE.ELEMENT_NODE) {\n          node = node.lastChild;\n        }\n        node.innerHTML = text;\n      } else {\n        clearChildNodes(this);\n        parseIntoDocument(text, this);\n      }\n    } else if (text) {\n      clearChildNodes(this);\n      parseIntoDocument(text, this);\n    }\n  }\n\n  writeln() {\n    this.write(...arguments, \"\\n\");\n  }\n\n  // This is implemented separately for Document (which has a _ids cache) and DocumentFragment (which does not).\n  getElementById(id) {\n    if (!this._ids[id]) {\n      return null;\n    }\n\n    // Let's find the first element with where it's root is the document.\n    const matchElement = this._ids[id].find(candidate => {\n      let root = candidate;\n      while (domSymbolTree.parent(root)) {\n        root = domSymbolTree.parent(root);\n      }\n\n      return root === this;\n    });\n\n    return matchElement || null;\n  }\n\n  get referrer() {\n    return this._referrer || \"\";\n  }\n  get lastModified() {\n    return this._lastModified;\n  }\n  get images() {\n    return this.getElementsByTagName(\"IMG\");\n  }\n  get embeds() {\n    return this.getElementsByTagName(\"EMBED\");\n  }\n  get plugins() {\n    return this.embeds;\n  }\n  get links() {\n    return HTMLCollection.createImpl(this._globalObject, [], {\n      element: this,\n      query: () => domSymbolTree.treeToArray(this, {\n        filter: node => (node._localName === \"a\" || node._localName === \"area\") &&\n                        node.hasAttributeNS(null, \"href\") &&\n                        node._namespaceURI === HTML_NS\n      })\n    });\n  }\n  get forms() {\n    return this.getElementsByTagName(\"FORM\");\n  }\n  get scripts() {\n    return this.getElementsByTagName(\"SCRIPT\");\n  }\n  get anchors() {\n    return HTMLCollection.createImpl(this._globalObject, [], {\n      element: this,\n      query: () => domSymbolTree.treeToArray(this, {\n        filter: node => node._localName === \"a\" &&\n                        node.hasAttributeNS(null, \"name\") &&\n                        node._namespaceURI === HTML_NS\n      })\n    });\n  }\n\n  // The applets attribute must return an\n  // HTMLCollection rooted at the Document node,\n  // whose filter matches nothing.\n  // (It exists for historical reasons.)\n  get applets() {\n    return HTMLCollection.createImpl(this._globalObject, [], {\n      element: this,\n      query: () => []\n    });\n  }\n\n  open() {\n    let child = domSymbolTree.firstChild(this);\n    while (child) {\n      this.removeChild(child);\n      child = domSymbolTree.firstChild(this);\n    }\n    this._modified();\n    return this;\n  }\n  close(noQueue) {\n    // In some cases like when creating an empty iframe, I want to emit the\n    // events right away to avoid problems if later I asign the property src.\n    if (noQueue) {\n      this.readyState = \"complete\";\n\n      fireAnEvent(\"DOMContentLoaded\", this, undefined, { bubbles: true });\n      fireAnEvent(\"load\", this);\n\n      return;\n    }\n    this._queue.resume();\n\n    const dummyPromise = Promise.resolve();\n\n    const onDOMContentLoad = () => {\n      const doc = this;\n      function dispatchEvent() {\n        // https://html.spec.whatwg.org/#the-end\n        doc.readyState = \"interactive\";\n        fireAnEvent(\"DOMContentLoaded\", doc, undefined, { bubbles: true });\n      }\n\n      return new Promise(resolve => {\n        if (!this._deferQueue.tail) {\n          dispatchEvent();\n          return resolve();\n        }\n\n        this._deferQueue.setListener(() => {\n          dispatchEvent();\n          resolve();\n        });\n\n        return this._deferQueue.resume();\n      });\n    };\n\n    const onLoad = () => {\n      const doc = this;\n      function dispatchEvent() {\n        doc.readyState = \"complete\";\n        fireAnEvent(\"load\", doc);\n      }\n\n      return new Promise(resolve => {\n        if (this._asyncQueue.count() === 0) {\n          dispatchEvent();\n          return resolve();\n        }\n\n        return this._asyncQueue.setListener(() => {\n          dispatchEvent();\n          resolve();\n        });\n      });\n    };\n\n    this._queue.push(dummyPromise, onDOMContentLoad, null);\n    // Set the readyState to 'complete' once all resources are loaded.\n    // As a side-effect the document's load-event will be dispatched.\n    this._queue.push(dummyPromise, onLoad, null, true);\n  }\n\n  getElementsByName(elementName) {\n    return NodeList.createImpl(this._globalObject, [], {\n      element: this,\n      query: () => domSymbolTree.treeToArray(this, {\n        filter: node => node.getAttributeNS && node.getAttributeNS(null, \"name\") === elementName\n      })\n    });\n  }\n\n  get title() {\n    const { documentElement } = this;\n    let value = \"\";\n\n    if (documentElement && documentElement._localName === \"svg\") {\n      const svgTitleElement = firstChildWithLocalName(documentElement, \"title\", SVG_NS);\n\n      if (svgTitleElement) {\n        value = childTextContent(svgTitleElement);\n      }\n    } else {\n      const titleElement = firstDescendantWithLocalName(this, \"title\");\n\n      if (titleElement) {\n        value = childTextContent(titleElement);\n      }\n    }\n\n    value = stripAndCollapseASCIIWhitespace(value);\n\n    return value;\n  }\n\n  set title(value) {\n    const { documentElement } = this;\n    let element;\n\n    if (documentElement && documentElement._localName === \"svg\") {\n      element = firstChildWithLocalName(documentElement, \"title\", SVG_NS);\n\n      if (!element) {\n        element = this.createElementNS(SVG_NS, \"title\");\n\n        this._insert(element, documentElement.firstChild);\n      }\n\n      element.textContent = value;\n    } else if (documentElement && documentElement._namespaceURI === HTML_NS) {\n      const titleElement = firstDescendantWithLocalName(this, \"title\");\n      const headElement = this.head;\n\n      if (titleElement === null && headElement === null) {\n        return;\n      }\n\n      if (titleElement !== null) {\n        element = titleElement;\n      } else {\n        element = this.createElement(\"title\");\n        headElement._append(element);\n      }\n\n      element.textContent = value;\n    }\n  }\n\n  get dir() {\n    return this.documentElement ? this.documentElement.dir : \"\";\n  }\n  set dir(value) {\n    if (this.documentElement) {\n      this.documentElement.dir = value;\n    }\n  }\n\n  get head() {\n    return this.documentElement ? firstChildWithLocalName(this.documentElement, \"head\") : null;\n  }\n\n  get body() {\n    const { documentElement } = this;\n    if (!documentElement || documentElement._localName !== \"html\" ||\n        documentElement._namespaceURI !== HTML_NS) {\n      return null;\n    }\n\n    return firstChildWithLocalNames(this.documentElement, new Set([\"body\", \"frameset\"]));\n  }\n\n  set body(value) {\n    if (value === null ||\n        value._namespaceURI !== HTML_NS ||\n        (value._localName !== \"body\" && value._localName !== \"frameset\")) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot set the body to null or a non-body/frameset element\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    const bodyElement = this.body;\n    if (value === bodyElement) {\n      return;\n    }\n\n    if (bodyElement !== null) {\n      bodyElement.parentNode._replace(value, bodyElement);\n      return;\n    }\n\n    const { documentElement } = this;\n    if (documentElement === null) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot set the body when there is no document element\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    documentElement._append(value);\n  }\n\n  _runPreRemovingSteps(oldNode) {\n    // https://html.spec.whatwg.org/#focus-fixup-rule\n    if (oldNode === this.activeElement) {\n      this._lastFocusedElement = this.body;\n    }\n    for (const activeNodeIterator of this._workingNodeIterators) {\n      activeNodeIterator._preRemovingSteps(oldNode);\n    }\n  }\n\n  createEvent(type) {\n    const typeLower = type.toLowerCase();\n    const eventWrapper = eventInterfaceTable[typeLower] || null;\n\n    if (!eventWrapper) {\n      throw DOMException.create(this._globalObject, [\n        \"The provided event type (\\\"\" + type + \"\\\") is invalid\",\n        \"NotSupportedError\"\n      ]);\n    }\n\n    const impl = eventWrapper.createImpl(this._globalObject, [\"\"]);\n    impl._initializedFlag = false;\n    return impl;\n  }\n\n  createRange() {\n    return Range.createImpl(this._globalObject, [], {\n      start: { node: this, offset: 0 },\n      end: { node: this, offset: 0 }\n    });\n  }\n\n  createProcessingInstruction(target, data) {\n    validateName(this._globalObject, target);\n\n    if (data.includes(\"?>\")) {\n      throw DOMException.create(this._globalObject, [\n        \"Processing instruction data cannot contain the string \\\"?>\\\"\",\n        \"InvalidCharacterError\"\n      ]);\n    }\n\n    return ProcessingInstruction.createImpl(this._globalObject, [], {\n      ownerDocument: this,\n      target,\n      data\n    });\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-createcdatasection\n  createCDATASection(data) {\n    if (this._parsingMode === \"html\") {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot create CDATA sections in HTML documents\",\n        \"NotSupportedError\"\n      ]);\n    }\n\n    if (data.includes(\"]]>\")) {\n      throw DOMException.create(this._globalObject, [\n        \"CDATA section data cannot contain the string \\\"]]>\\\"\",\n        \"InvalidCharacterError\"\n      ]);\n    }\n\n    return CDATASection.createImpl(this._globalObject, [], {\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createTextNode(data) {\n    return Text.createImpl(this._globalObject, [], {\n      ownerDocument: this,\n      data\n    });\n  }\n\n  createComment(data) {\n    return Comment.createImpl(this._globalObject, [], {\n      ownerDocument: this,\n      data\n    });\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-createelement\n  createElement(localName, options) {\n    validateName(this._globalObject, localName);\n\n    if (this._parsingMode === \"html\") {\n      localName = asciiLowercase(localName);\n    }\n\n    let isValue = null;\n    if (options && options.is !== undefined) {\n      isValue = options.is;\n    }\n\n    const namespace = this._parsingMode === \"html\" || this.contentType === \"application/xhtml+xml\" ? HTML_NS : null;\n\n    return createElement(this, localName, namespace, null, isValue, true);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-createelementns\n  createElementNS(namespace, qualifiedName, options) {\n    return internalCreateElementNSSteps(this, namespace, qualifiedName, options);\n  }\n\n  createDocumentFragment() {\n    return DocumentFragment.createImpl(this._globalObject, [], { ownerDocument: this });\n  }\n\n  createAttribute(localName) {\n    validateName(this._globalObject, localName);\n\n    if (this._parsingMode === \"html\") {\n      localName = asciiLowercase(localName);\n    }\n\n    return this._createAttribute({ localName });\n  }\n\n  createAttributeNS(namespace, name) {\n    if (namespace === undefined) {\n      namespace = null;\n    }\n    namespace = namespace !== null ? String(namespace) : namespace;\n\n    const extracted = validateAndExtract(this._globalObject, namespace, name);\n    return this._createAttribute({\n      namespace: extracted.namespace,\n      namespacePrefix: extracted.prefix,\n      localName: extracted.localName\n    });\n  }\n\n  // Using this helper function rather than directly calling generatedAttr.createImpl may be preferred in some files,\n  // to avoid introducing a potentially cyclic dependency on generated/Attr.js.\n  _createAttribute({\n    localName,\n    value,\n    namespace,\n    namespacePrefix\n  }) {\n    return generatedAttr.createImpl(this._globalObject, [], {\n      localName,\n      value,\n      namespace,\n      namespacePrefix,\n      ownerDocument: this\n    });\n  }\n\n  createTreeWalker(root, whatToShow, filter) {\n    return TreeWalker.createImpl(this._globalObject, [], { root, whatToShow, filter });\n  }\n\n  createNodeIterator(root, whatToShow, filter) {\n    const nodeIterator = NodeIterator.createImpl(this._globalObject, [], { root, whatToShow, filter });\n\n    this._workingNodeIterators.push(nodeIterator);\n    while (this._workingNodeIterators.length > this._workingNodeIteratorsMax) {\n      const toInactivate = this._workingNodeIterators.shift();\n      toInactivate._working = false;\n    }\n\n    return nodeIterator;\n  }\n\n  importNode(node, deep) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot import a document node\",\n        \"NotSupportedError\"\n      ]);\n    } else if (ShadowRoot.isImpl(node)) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot adopt a shadow root\",\n        \"NotSupportedError\"\n      ]);\n    }\n\n    return clone(node, this, deep);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-document-adoptnode\n  adoptNode(node) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot adopt a document node\",\n        \"NotSupportedError\"\n      ]);\n    } else if (ShadowRoot.isImpl(node)) {\n      throw DOMException.create(this._globalObject, [\n        \"Cannot adopt a shadow root\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    this._adoptNode(node);\n\n    return node;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-adopt\n  _adoptNode(node) {\n    const newDocument = this;\n    const oldDocument = node._ownerDocument;\n\n    const parent = domSymbolTree.parent(node);\n    if (parent) {\n      parent._remove(node);\n    }\n\n    if (oldDocument !== newDocument) {\n      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {\n        inclusiveDescendant._ownerDocument = newDocument;\n      }\n\n      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {\n        if (inclusiveDescendant._ceState === \"custom\") {\n          enqueueCECallbackReaction(inclusiveDescendant, \"adoptedCallback\", [\n            idlUtils.wrapperForImpl(oldDocument),\n            idlUtils.wrapperForImpl(newDocument)\n          ]);\n        }\n      }\n\n      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {\n        if (inclusiveDescendant._adoptingSteps) {\n          inclusiveDescendant._adoptingSteps(oldDocument);\n        }\n      }\n    }\n  }\n\n  get cookie() {\n    return this._cookieJar.getCookieStringSync(this.URL, { http: false });\n  }\n  set cookie(cookieStr) {\n    cookieStr = String(cookieStr);\n    this._cookieJar.setCookieSync(cookieStr, this.URL, {\n      http: false,\n      ignoreError: true\n    });\n  }\n\n  // The clear(), captureEvents(), and releaseEvents() methods must do nothing\n  clear() {}\n\n  captureEvents() {}\n\n  releaseEvents() {}\n\n  get styleSheets() {\n    if (!this._styleSheets) {\n      this._styleSheets = StyleSheetList.createImpl(this._globalObject);\n    }\n\n    // TODO: each style and link element should register its sheet on creation\n    // and remove it on removal.\n    return this._styleSheets;\n  }\n\n  get hidden() {\n    if (this._defaultView && this._defaultView._pretendToBeVisual) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get visibilityState() {\n    if (this._defaultView && this._defaultView._pretendToBeVisual) {\n      return \"visible\";\n    }\n\n    return \"prerender\";\n  }\n\n  // https://w3c.github.io/selection-api/#extensions-to-document-interface\n  getSelection() {\n    return this._defaultView ? this._defaultView._selection : null;\n  }\n\n  // Needed to ensure that the resulting document has the correct prototype chain:\n  // https://dom.spec.whatwg.org/#concept-node-clone says \"that implements the same interfaces as node\".\n  _cloneDocument() {\n    const copy = documents.createImpl(\n      this._globalObject,\n      {\n        contentType: this.contentType,\n        encoding: this._encoding,\n        parsingMode: this._parsingMode\n      }\n    );\n\n    copy._URL = this._URL;\n    copy._origin = this._origin;\n    return copy;\n  }\n}\n\neventAccessors.createEventAccessor(DocumentImpl.prototype, \"readystatechange\");\nmixin(DocumentImpl.prototype, DocumentOrShadowRootImpl.prototype);\nmixin(DocumentImpl.prototype, GlobalEventHandlersImpl.prototype);\nmixin(DocumentImpl.prototype, NonElementParentNodeImpl.prototype);\nmixin(DocumentImpl.prototype, ParentNodeImpl.prototype);\n\nDocumentImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\n\nDocumentImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\n\nDocumentImpl.prototype.getElementsByClassName = memoizeQuery(function getElementsByClassName(classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\n\nmodule.exports = {\n  implementation: DocumentImpl\n};\n",
    "packages/strapi-utils/node_modules/yup/lib/mixed.js": "\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = SchemaType;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _has = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _cloneDeepWith = _interopRequireDefault(require(\"lodash/cloneDeepWith\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"lodash/toArray\"));\n\nvar _locale = require(\"./locale\");\n\nvar _Condition = _interopRequireDefault(require(\"./Condition\"));\n\nvar _runValidations = _interopRequireDefault(require(\"./util/runValidations\"));\n\nvar _prependDeep = _interopRequireDefault(require(\"./util/prependDeep\"));\n\nvar _isSchema = _interopRequireDefault(require(\"./util/isSchema\"));\n\nvar _createValidation = _interopRequireDefault(require(\"./util/createValidation\"));\n\nvar _printValue = _interopRequireDefault(require(\"./util/printValue\"));\n\nvar _Reference = _interopRequireDefault(require(\"./Reference\"));\n\nvar _reach = require(\"./util/reach\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar RefSet = /*#__PURE__*/function () {\n  function RefSet() {\n    this.list = new Set();\n    this.refs = new Map();\n  }\n\n  var _proto = RefSet.prototype;\n\n  _proto.describe = function describe() {\n    var description = [];\n\n    for (var _iterator = _createForOfIteratorHelperLoose(this.list), _step; !(_step = _iterator()).done;) {\n      var item = _step.value;\n      description.push(item);\n    }\n\n    for (var _iterator2 = _createForOfIteratorHelperLoose(this.refs), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n          ref = _step2$value[1];\n      description.push(ref.describe());\n    }\n\n    return description;\n  };\n\n  _proto.toArray = function toArray() {\n    return (0, _toArray2.default)(this.list).concat((0, _toArray2.default)(this.refs.values()));\n  };\n\n  _proto.add = function add(value) {\n    _Reference.default.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);\n  };\n\n  _proto.delete = function _delete(value) {\n    _Reference.default.isRef(value) ? this.refs.delete(value.key) : this.list.delete(value);\n  };\n\n  _proto.has = function has(value, resolve) {\n    if (this.list.has(value)) return true;\n    var item,\n        values = this.refs.values();\n\n    while (item = values.next(), !item.done) {\n      if (resolve(item.value) === value) return true;\n    }\n\n    return false;\n  };\n\n  _proto.clone = function clone() {\n    var next = new RefSet();\n    next.list = new Set(this.list);\n    next.refs = new Map(this.refs);\n    return next;\n  };\n\n  _proto.merge = function merge(newItems, removeItems) {\n    var next = this.clone();\n    newItems.list.forEach(function (value) {\n      return next.add(value);\n    });\n    newItems.refs.forEach(function (value) {\n      return next.add(value);\n    });\n    removeItems.list.forEach(function (value) {\n      return next.delete(value);\n    });\n    removeItems.refs.forEach(function (value) {\n      return next.delete(value);\n    });\n    return next;\n  };\n\n  (0, _createClass2.default)(RefSet, [{\n    key: \"size\",\n    get: function get() {\n      return this.list.size + this.refs.size;\n    }\n  }]);\n  return RefSet;\n}();\n\nfunction SchemaType(options) {\n  var _this = this;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  if (!(this instanceof SchemaType)) return new SchemaType();\n  this._deps = [];\n  this._conditions = [];\n  this._options = {\n    abortEarly: true,\n    recursive: true\n  };\n  this._exclusive = Object.create(null);\n  this._whitelist = new RefSet();\n  this._blacklist = new RefSet();\n  this.tests = [];\n  this.transforms = [];\n  this.withMutation(function () {\n    _this.typeError(_locale.mixed.notType);\n  });\n  if ((0, _has.default)(options, 'default')) this._defaultDefault = options.default;\n  this.type = options.type || 'mixed'; // TODO: remove\n\n  this._type = options.type || 'mixed';\n}\n\nvar proto = SchemaType.prototype = {\n  __isYupSchema__: true,\n  constructor: SchemaType,\n  clone: function clone() {\n    var _this2 = this;\n\n    if (this._mutate) return this; // if the nested value is a schema we can skip cloning, since\n    // they are already immutable\n\n    return (0, _cloneDeepWith.default)(this, function (value) {\n      if ((0, _isSchema.default)(value) && value !== _this2) return value;\n    });\n  },\n  label: function label(_label) {\n    var next = this.clone();\n    next._label = _label;\n    return next;\n  },\n  meta: function meta(obj) {\n    if (arguments.length === 0) return this._meta;\n    var next = this.clone();\n    next._meta = (0, _extends2.default)(next._meta || {}, obj);\n    return next;\n  },\n  withMutation: function withMutation(fn) {\n    var before = this._mutate;\n    this._mutate = true;\n    var result = fn(this);\n    this._mutate = before;\n    return result;\n  },\n  concat: function concat(schema) {\n    if (!schema || schema === this) return this;\n    if (schema._type !== this._type && this._type !== 'mixed') throw new TypeError(\"You cannot `concat()` schema's of different types: \" + this._type + \" and \" + schema._type);\n    var next = (0, _prependDeep.default)(schema.clone(), this); // new undefined default is overridden by old non-undefined one, revert\n\n    if ((0, _has.default)(schema, '_default')) next._default = schema._default;\n    next.tests = this.tests;\n    next._exclusive = this._exclusive; // manually merge the blacklist/whitelist (the other `schema` takes\n    // precedence in case of conflicts)\n\n    next._whitelist = this._whitelist.merge(schema._whitelist, schema._blacklist);\n    next._blacklist = this._blacklist.merge(schema._blacklist, schema._whitelist); // manually add the new tests to ensure\n    // the deduping logic is consistent\n\n    next.withMutation(function (next) {\n      schema.tests.forEach(function (fn) {\n        next.test(fn.OPTIONS);\n      });\n    });\n    return next;\n  },\n  isType: function isType(v) {\n    if (this._nullable && v === null) return true;\n    return !this._typeCheck || this._typeCheck(v);\n  },\n  resolve: function resolve(options) {\n    var schema = this;\n\n    if (schema._conditions.length) {\n      var conditions = schema._conditions;\n      schema = schema.clone();\n      schema._conditions = [];\n      schema = conditions.reduce(function (schema, condition) {\n        return condition.resolve(schema, options);\n      }, schema);\n      schema = schema.resolve(options);\n    }\n\n    return schema;\n  },\n  cast: function cast(value, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var resolvedSchema = this.resolve((0, _extends2.default)({}, options, {\n      value: value\n    }));\n\n    var result = resolvedSchema._cast(value, options);\n\n    if (value !== undefined && options.assert !== false && resolvedSchema.isType(result) !== true) {\n      var formattedValue = (0, _printValue.default)(value);\n      var formattedResult = (0, _printValue.default)(result);\n      throw new TypeError(\"The value of \" + (options.path || 'field') + \" could not be cast to a value \" + (\"that satisfies the schema type: \\\"\" + resolvedSchema._type + \"\\\". \\n\\n\") + (\"attempted value: \" + formattedValue + \" \\n\") + (formattedResult !== formattedValue ? \"result of cast: \" + formattedResult : ''));\n    }\n\n    return result;\n  },\n  _cast: function _cast(rawValue) {\n    var _this3 = this;\n\n    var value = rawValue === undefined ? rawValue : this.transforms.reduce(function (value, fn) {\n      return fn.call(_this3, value, rawValue);\n    }, rawValue);\n\n    if (value === undefined && (0, _has.default)(this, '_default')) {\n      value = this.default();\n    }\n\n    return value;\n  },\n  _validate: function _validate(_value, options) {\n    var _this4 = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var value = _value;\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n\n    var isStrict = this._option('strict', options);\n\n    var endEarly = this._option('abortEarly', options);\n\n    var sync = options.sync;\n    var path = options.path;\n    var label = this._label;\n\n    if (!isStrict) {\n      value = this._cast(value, (0, _extends2.default)({\n        assert: false\n      }, options));\n    } // value is cast, we can check if it meets type requirements\n\n\n    var validationParams = {\n      value: value,\n      path: path,\n      schema: this,\n      options: options,\n      label: label,\n      originalValue: originalValue,\n      sync: sync\n    };\n\n    if (options.from) {\n      validationParams.from = options.from;\n    }\n\n    var initialTests = [];\n    if (this._typeError) initialTests.push(this._typeError(validationParams));\n    if (this._whitelistError) initialTests.push(this._whitelistError(validationParams));\n    if (this._blacklistError) initialTests.push(this._blacklistError(validationParams));\n    return (0, _runValidations.default)({\n      validations: initialTests,\n      endEarly: endEarly,\n      value: value,\n      path: path,\n      sync: sync\n    }).then(function (value) {\n      return (0, _runValidations.default)({\n        path: path,\n        sync: sync,\n        value: value,\n        endEarly: endEarly,\n        validations: _this4.tests.map(function (fn) {\n          return fn(validationParams);\n        })\n      });\n    });\n  },\n  validate: function validate(value, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var schema = this.resolve((0, _extends2.default)({}, options, {\n      value: value\n    }));\n    return schema._validate(value, options);\n  },\n  validateSync: function validateSync(value, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var schema = this.resolve((0, _extends2.default)({}, options, {\n      value: value\n    }));\n    var result, err;\n\n    schema._validate(value, (0, _extends2.default)({}, options, {\n      sync: true\n    })).then(function (r) {\n      return result = r;\n    }).catch(function (e) {\n      return err = e;\n    });\n\n    if (err) throw err;\n    return result;\n  },\n  isValid: function isValid(value, options) {\n    return this.validate(value, options).then(function () {\n      return true;\n    }).catch(function (err) {\n      if (err.name === 'ValidationError') return false;\n      throw err;\n    });\n  },\n  isValidSync: function isValidSync(value, options) {\n    try {\n      this.validateSync(value, options);\n      return true;\n    } catch (err) {\n      if (err.name === 'ValidationError') return false;\n      throw err;\n    }\n  },\n  getDefault: function getDefault(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var schema = this.resolve(options);\n    return schema.default();\n  },\n  default: function _default(def) {\n    if (arguments.length === 0) {\n      var defaultValue = (0, _has.default)(this, '_default') ? this._default : this._defaultDefault;\n      return typeof defaultValue === 'function' ? defaultValue.call(this) : (0, _cloneDeepWith.default)(defaultValue);\n    }\n\n    var next = this.clone();\n    next._default = def;\n    return next;\n  },\n  strict: function strict(isStrict) {\n    if (isStrict === void 0) {\n      isStrict = true;\n    }\n\n    var next = this.clone();\n    next._options.strict = isStrict;\n    return next;\n  },\n  _isPresent: function _isPresent(value) {\n    return value != null;\n  },\n  required: function required(message) {\n    if (message === void 0) {\n      message = _locale.mixed.required;\n    }\n\n    return this.test({\n      message: message,\n      name: 'required',\n      exclusive: true,\n      test: function test(value) {\n        return this.schema._isPresent(value);\n      }\n    });\n  },\n  notRequired: function notRequired() {\n    var next = this.clone();\n    next.tests = next.tests.filter(function (test) {\n      return test.OPTIONS.name !== 'required';\n    });\n    return next;\n  },\n  nullable: function nullable(isNullable) {\n    if (isNullable === void 0) {\n      isNullable = true;\n    }\n\n    var next = this.clone();\n    next._nullable = isNullable;\n    return next;\n  },\n  transform: function transform(fn) {\n    var next = this.clone();\n    next.transforms.push(fn);\n    return next;\n  },\n\n  /**\n   * Adds a test function to the schema's queue of tests.\n   * tests can be exclusive or non-exclusive.\n   *\n   * - exclusive tests, will replace any existing tests of the same name.\n   * - non-exclusive: can be stacked\n   *\n   * If a non-exclusive test is added to a schema with an exclusive test of the same name\n   * the exclusive test is removed and further tests of the same name will be stacked.\n   *\n   * If an exclusive test is added to a schema with non-exclusive tests of the same name\n   * the previous tests are removed and further tests of the same name will replace each other.\n   */\n  test: function test() {\n    var opts;\n\n    if (arguments.length === 1) {\n      if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'function') {\n        opts = {\n          test: arguments.length <= 0 ? undefined : arguments[0]\n        };\n      } else {\n        opts = arguments.length <= 0 ? undefined : arguments[0];\n      }\n    } else if (arguments.length === 2) {\n      opts = {\n        name: arguments.length <= 0 ? undefined : arguments[0],\n        test: arguments.length <= 1 ? undefined : arguments[1]\n      };\n    } else {\n      opts = {\n        name: arguments.length <= 0 ? undefined : arguments[0],\n        message: arguments.length <= 1 ? undefined : arguments[1],\n        test: arguments.length <= 2 ? undefined : arguments[2]\n      };\n    }\n\n    if (opts.message === undefined) opts.message = _locale.mixed.default;\n    if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');\n    var next = this.clone();\n    var validate = (0, _createValidation.default)(opts);\n    var isExclusive = opts.exclusive || opts.name && next._exclusive[opts.name] === true;\n\n    if (opts.exclusive && !opts.name) {\n      throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');\n    }\n\n    next._exclusive[opts.name] = !!opts.exclusive;\n    next.tests = next.tests.filter(function (fn) {\n      if (fn.OPTIONS.name === opts.name) {\n        if (isExclusive) return false;\n        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;\n      }\n\n      return true;\n    });\n    next.tests.push(validate);\n    return next;\n  },\n  when: function when(keys, options) {\n    if (arguments.length === 1) {\n      options = keys;\n      keys = '.';\n    }\n\n    var next = this.clone(),\n        deps = [].concat(keys).map(function (key) {\n      return new _Reference.default(key);\n    });\n    deps.forEach(function (dep) {\n      if (dep.isSibling) next._deps.push(dep.key);\n    });\n\n    next._conditions.push(new _Condition.default(deps, options));\n\n    return next;\n  },\n  typeError: function typeError(message) {\n    var next = this.clone();\n    next._typeError = (0, _createValidation.default)({\n      message: message,\n      name: 'typeError',\n      test: function test(value) {\n        if (value !== undefined && !this.schema.isType(value)) return this.createError({\n          params: {\n            type: this.schema._type\n          }\n        });\n        return true;\n      }\n    });\n    return next;\n  },\n  oneOf: function oneOf(enums, message) {\n    if (message === void 0) {\n      message = _locale.mixed.oneOf;\n    }\n\n    var next = this.clone();\n    enums.forEach(function (val) {\n      next._whitelist.add(val);\n\n      next._blacklist.delete(val);\n    });\n    next._whitelistError = (0, _createValidation.default)({\n      message: message,\n      name: 'oneOf',\n      test: function test(value) {\n        if (value === undefined) return true;\n        var valids = this.schema._whitelist;\n        return valids.has(value, this.resolve) ? true : this.createError({\n          params: {\n            values: valids.toArray().join(', ')\n          }\n        });\n      }\n    });\n    return next;\n  },\n  notOneOf: function notOneOf(enums, message) {\n    if (message === void 0) {\n      message = _locale.mixed.notOneOf;\n    }\n\n    var next = this.clone();\n    enums.forEach(function (val) {\n      next._blacklist.add(val);\n\n      next._whitelist.delete(val);\n    });\n    next._blacklistError = (0, _createValidation.default)({\n      message: message,\n      name: 'notOneOf',\n      test: function test(value) {\n        var invalids = this.schema._blacklist;\n        if (invalids.has(value, this.resolve)) return this.createError({\n          params: {\n            values: invalids.toArray().join(', ')\n          }\n        });\n        return true;\n      }\n    });\n    return next;\n  },\n  strip: function strip(_strip) {\n    if (_strip === void 0) {\n      _strip = true;\n    }\n\n    var next = this.clone();\n    next._strip = _strip;\n    return next;\n  },\n  _option: function _option(key, overrides) {\n    return (0, _has.default)(overrides, key) ? overrides[key] : this._options[key];\n  },\n  describe: function describe() {\n    var next = this.clone();\n    var description = {\n      type: next._type,\n      meta: next._meta,\n      label: next._label,\n      tests: next.tests.map(function (fn) {\n        return {\n          name: fn.OPTIONS.name,\n          params: fn.OPTIONS.params\n        };\n      }).filter(function (n, idx, list) {\n        return list.findIndex(function (c) {\n          return c.name === n.name;\n        }) === idx;\n      })\n    };\n    if (next._whitelist.size) description.oneOf = next._whitelist.describe();\n    if (next._blacklist.size) description.notOneOf = next._blacklist.describe();\n    return description;\n  },\n  defined: function defined(message) {\n    if (message === void 0) {\n      message = _locale.mixed.defined;\n    }\n\n    return this.nullable().test({\n      message: message,\n      name: 'defined',\n      exclusive: true,\n      test: function test(value) {\n        return value !== undefined;\n      }\n    });\n  }\n};\n\nvar _loop = function _loop() {\n  var method = _arr[_i];\n\n  proto[method + \"At\"] = function (path, value, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _getIn = (0, _reach.getIn)(this, path, value, options.context),\n        parent = _getIn.parent,\n        parentPath = _getIn.parentPath,\n        schema = _getIn.schema;\n\n    return schema[method](parent && parent[parentPath], (0, _extends2.default)({}, options, {\n      parent: parent,\n      path: path\n    }));\n  };\n};\n\nfor (var _i = 0, _arr = ['validate', 'validateSync']; _i < _arr.length; _i++) {\n  _loop();\n}\n\nfor (var _i2 = 0, _arr2 = ['equals', 'is']; _i2 < _arr2.length; _i2++) {\n  var alias = _arr2[_i2];\n  proto[alias] = proto.oneOf;\n}\n\nfor (var _i3 = 0, _arr3 = ['not', 'nope']; _i3 < _arr3.length; _i3++) {\n  var _alias = _arr3[_i3];\n  proto[_alias] = proto.notOneOf;\n}\n\nproto.optional = proto.notRequired;\nmodule.exports = exports.default;",
    "packages/strapi-utils/node_modules/yup/lib/object.js": "\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = ObjectSchema;\n\nvar _taggedTemplateLiteralLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/taggedTemplateLiteralLoose\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _has = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _snakeCase2 = _interopRequireDefault(require(\"lodash/snakeCase\"));\n\nvar _camelCase2 = _interopRequireDefault(require(\"lodash/camelCase\"));\n\nvar _mapKeys = _interopRequireDefault(require(\"lodash/mapKeys\"));\n\nvar _mapValues = _interopRequireDefault(require(\"lodash/mapValues\"));\n\nvar _propertyExpr = require(\"property-expr\");\n\nvar _mixed = _interopRequireDefault(require(\"./mixed\"));\n\nvar _locale = require(\"./locale.js\");\n\nvar _sortFields = _interopRequireDefault(require(\"./util/sortFields\"));\n\nvar _sortByKeyOrder = _interopRequireDefault(require(\"./util/sortByKeyOrder\"));\n\nvar _inherits = _interopRequireDefault(require(\"./util/inherits\"));\n\nvar _makePath = _interopRequireDefault(require(\"./util/makePath\"));\n\nvar _runValidations = _interopRequireWildcard(require(\"./util/runValidations\"));\n\nvar _synchronousPromise = require(\"synchronous-promise\");\n\nfunction _templateObject3() {\n  var data = (0, _taggedTemplateLiteralLoose2.default)([\"\", \"[\\\"\", \"\\\"]\"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject2() {\n  var data = (0, _taggedTemplateLiteralLoose2.default)([\"\", \".\", \"\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = (0, _taggedTemplateLiteralLoose2.default)([\"\", \".\", \"\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nvar isObject = function isObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n};\n\nvar promise = function promise(sync) {\n  return sync ? _synchronousPromise.SynchronousPromise : Promise;\n};\n\nfunction unknown(ctx, value) {\n  var known = Object.keys(ctx.fields);\n  return Object.keys(value).filter(function (key) {\n    return known.indexOf(key) === -1;\n  });\n}\n\nfunction ObjectSchema(spec) {\n  var _this2 = this;\n\n  if (!(this instanceof ObjectSchema)) return new ObjectSchema(spec);\n\n  _mixed.default.call(this, {\n    type: 'object',\n    default: function _default() {\n      var _this = this;\n\n      if (!this._nodes.length) return undefined;\n      var dft = {};\n\n      this._nodes.forEach(function (key) {\n        dft[key] = _this.fields[key].default ? _this.fields[key].default() : undefined;\n      });\n\n      return dft;\n    }\n  });\n\n  this.fields = Object.create(null);\n  this._nodes = [];\n  this._excludedEdges = [];\n  this.withMutation(function () {\n    _this2.transform(function coerce(value) {\n      if (typeof value === 'string') {\n        try {\n          value = JSON.parse(value);\n        } catch (err) {\n          value = null;\n        }\n      }\n\n      if (this.isType(value)) return value;\n      return null;\n    });\n\n    if (spec) {\n      _this2.shape(spec);\n    }\n  });\n}\n\n(0, _inherits.default)(ObjectSchema, _mixed.default, {\n  _typeCheck: function _typeCheck(value) {\n    return isObject(value) || typeof value === 'function';\n  },\n  _cast: function _cast(_value, options) {\n    var _this3 = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var value = _mixed.default.prototype._cast.call(this, _value, options); //should ignore nulls here\n\n\n    if (value === undefined) return this.default();\n    if (!this._typeCheck(value)) return value;\n    var fields = this.fields;\n    var strip = this._option('stripUnknown', options) === true;\n\n    var props = this._nodes.concat(Object.keys(value).filter(function (v) {\n      return _this3._nodes.indexOf(v) === -1;\n    }));\n\n    var intermediateValue = {}; // is filled during the transform below\n\n    var innerOptions = (0, _extends2.default)({}, options, {\n      parent: intermediateValue,\n      __validating: options.__validating || false\n    });\n    var isChanged = false;\n    props.forEach(function (prop) {\n      var field = fields[prop];\n      var exists = (0, _has.default)(value, prop);\n\n      if (field) {\n        var fieldValue;\n        var strict = field._options && field._options.strict; // safe to mutate since this is fired in sequence\n\n        innerOptions.path = (0, _makePath.default)(_templateObject(), options.path, prop);\n        innerOptions.value = value[prop];\n        field = field.resolve(innerOptions);\n\n        if (field._strip === true) {\n          isChanged = isChanged || prop in value;\n          return;\n        }\n\n        fieldValue = !options.__validating || !strict ? field.cast(value[prop], innerOptions) : value[prop];\n        if (fieldValue !== undefined) intermediateValue[prop] = fieldValue;\n      } else if (exists && !strip) intermediateValue[prop] = value[prop];\n\n      if (intermediateValue[prop] !== value[prop]) isChanged = true;\n    });\n    return isChanged ? intermediateValue : value;\n  },\n  _validate: function _validate(_value, opts) {\n    var _this4 = this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    var endEarly, recursive;\n    var sync = opts.sync;\n    var errors = [];\n    var originalValue = opts.originalValue != null ? opts.originalValue : _value;\n    var from = [{\n      schema: this,\n      value: originalValue\n    }].concat(opts.from || []);\n    endEarly = this._option('abortEarly', opts);\n    recursive = this._option('recursive', opts);\n    opts = (0, _extends2.default)({}, opts, {\n      __validating: true,\n      originalValue: originalValue,\n      from: from\n    });\n    return _mixed.default.prototype._validate.call(this, _value, opts).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !isObject(value)) {\n        // only iterate though actual objects\n        if (errors.length) throw errors[0];\n        return value;\n      }\n\n      from = originalValue ? [].concat(from) : [{\n        schema: _this4,\n        value: originalValue || value\n      }].concat(opts.from || []);\n      originalValue = originalValue || value;\n\n      var validations = _this4._nodes.map(function (key) {\n        var path = key.indexOf('.') === -1 ? (0, _makePath.default)(_templateObject2(), opts.path, key) : (0, _makePath.default)(_templateObject3(), opts.path, key);\n        var field = _this4.fields[key];\n        var innerOptions = (0, _extends2.default)({}, opts, {\n          path: path,\n          from: from,\n          parent: value,\n          originalValue: originalValue[key]\n        });\n\n        if (field && field.validate) {\n          // inner fields are always strict:\n          // 1. this isn't strict so the casting will also have cast inner values\n          // 2. this is strict in which case the nested values weren't cast either\n          innerOptions.strict = true;\n          return field.validate(value[key], innerOptions);\n        }\n\n        return promise(sync).resolve(true);\n      });\n\n      return (0, _runValidations.default)({\n        sync: sync,\n        validations: validations,\n        value: value,\n        errors: errors,\n        endEarly: endEarly,\n        path: opts.path,\n        sort: (0, _sortByKeyOrder.default)(_this4.fields)\n      });\n    });\n  },\n  concat: function concat(schema) {\n    var next = _mixed.default.prototype.concat.call(this, schema);\n\n    next._nodes = (0, _sortFields.default)(next.fields, next._excludedEdges);\n    return next;\n  },\n  shape: function shape(schema, excludes) {\n    if (excludes === void 0) {\n      excludes = [];\n    }\n\n    var next = this.clone();\n    var fields = (0, _extends2.default)(next.fields, schema);\n    next.fields = fields;\n\n    if (excludes.length) {\n      if (!Array.isArray(excludes[0])) excludes = [excludes];\n      var keys = excludes.map(function (_ref) {\n        var first = _ref[0],\n            second = _ref[1];\n        return first + \"-\" + second;\n      });\n      next._excludedEdges = next._excludedEdges.concat(keys);\n    }\n\n    next._nodes = (0, _sortFields.default)(fields, next._excludedEdges);\n    return next;\n  },\n  from: function from(_from, to, alias) {\n    var fromGetter = (0, _propertyExpr.getter)(_from, true);\n    return this.transform(function (obj) {\n      if (obj == null) return obj;\n      var newObj = obj;\n\n      if ((0, _has.default)(obj, _from)) {\n        newObj = (0, _extends2.default)({}, obj);\n        if (!alias) delete newObj[_from];\n        newObj[to] = fromGetter(obj);\n      }\n\n      return newObj;\n    });\n  },\n  noUnknown: function noUnknown(noAllow, message) {\n    if (noAllow === void 0) {\n      noAllow = true;\n    }\n\n    if (message === void 0) {\n      message = _locale.object.noUnknown;\n    }\n\n    if (typeof noAllow === 'string') {\n      message = noAllow;\n      noAllow = true;\n    }\n\n    var next = this.test({\n      name: 'noUnknown',\n      exclusive: true,\n      message: message,\n      test: function test(value) {\n        if (value == null) return true;\n        var unknownKeys = unknown(this.schema, value);\n        return !noAllow || unknownKeys.length === 0 || this.createError({\n          params: {\n            unknown: unknownKeys.join(', ')\n          }\n        });\n      }\n    });\n    next._options.stripUnknown = noAllow;\n    return next;\n  },\n  unknown: function unknown(allow, message) {\n    if (allow === void 0) {\n      allow = true;\n    }\n\n    if (message === void 0) {\n      message = _locale.object.noUnknown;\n    }\n\n    return this.noUnknown(!allow, message);\n  },\n  transformKeys: function transformKeys(fn) {\n    return this.transform(function (obj) {\n      return obj && (0, _mapKeys.default)(obj, function (_, key) {\n        return fn(key);\n      });\n    });\n  },\n  camelCase: function camelCase() {\n    return this.transformKeys(_camelCase2.default);\n  },\n  snakeCase: function snakeCase() {\n    return this.transformKeys(_snakeCase2.default);\n  },\n  constantCase: function constantCase() {\n    return this.transformKeys(function (key) {\n      return (0, _snakeCase2.default)(key).toUpperCase();\n    });\n  },\n  describe: function describe() {\n    var base = _mixed.default.prototype.describe.call(this);\n\n    base.fields = (0, _mapValues.default)(this.fields, function (value) {\n      return value.describe();\n    });\n    return base;\n  }\n});\nmodule.exports = exports.default;",
    "node_modules/jest-each/build/bind.js": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _array = _interopRequireDefault(require('./table/array'));\n\nvar _template = _interopRequireDefault(require('./table/template'));\n\nvar _validation = require('./validation');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nvar _default = (cb, supportsDone = true) => (table, ...taggedTemplateData) =>\n  function eachBind(title, test, timeout) {\n    try {\n      const tests = isArrayTable(taggedTemplateData)\n        ? buildArrayTests(title, table)\n        : buildTemplateTests(title, table, taggedTemplateData);\n      return tests.forEach(row =>\n        cb(\n          row.title,\n          applyArguments(supportsDone, row.arguments, test),\n          timeout\n        )\n      );\n    } catch (e) {\n      const error = new (_jestUtil().ErrorWithStack)(e.message, eachBind);\n      return cb(title, () => {\n        throw error;\n      });\n    }\n  };\n\nexports.default = _default;\n\nconst isArrayTable = data => data.length === 0;\n\nconst buildArrayTests = (title, table) => {\n  (0, _validation.validateArrayTable)(table);\n  return (0, _array.default)(title, table);\n};\n\nconst buildTemplateTests = (title, table, taggedTemplateData) => {\n  const headings = getHeadingKeys(table[0]);\n  (0, _validation.validateTemplateTableHeadings)(headings, taggedTemplateData);\n  return (0, _template.default)(title, headings, taggedTemplateData);\n};\n\nconst getHeadingKeys = headings => headings.replace(/\\s/g, '').split('|');\n\nconst applyArguments = (supportsDone, params, test) =>\n  supportsDone && params.length < test.length\n    ? done => test(...params, done)\n    : () => test(...params);\n",
    "packages/strapi-utils/node_modules/yup/lib/util/createValidation.js": "\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.createErrorFactory = createErrorFactory;\nexports.default = createValidation;\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _mapValues = _interopRequireDefault(require(\"lodash/mapValues\"));\n\nvar _ValidationError = _interopRequireDefault(require(\"../ValidationError\"));\n\nvar _Reference = _interopRequireDefault(require(\"../Reference\"));\n\nvar _synchronousPromise = require(\"synchronous-promise\");\n\nvar formatError = _ValidationError.default.formatError;\n\nvar thenable = function thenable(p) {\n  return p && typeof p.then === 'function' && typeof p.catch === 'function';\n};\n\nfunction runTest(testFn, ctx, value, sync) {\n  var result = testFn.call(ctx, value);\n  if (!sync) return Promise.resolve(result);\n\n  if (thenable(result)) {\n    throw new Error(\"Validation test of type: \\\"\" + ctx.type + \"\\\" returned a Promise during a synchronous validate. \" + \"This test will finish after the validate call has returned\");\n  }\n\n  return _synchronousPromise.SynchronousPromise.resolve(result);\n}\n\nfunction resolveParams(oldParams, newParams, resolve) {\n  return (0, _mapValues.default)((0, _extends2.default)({}, oldParams, newParams), resolve);\n}\n\nfunction createErrorFactory(_ref) {\n  var value = _ref.value,\n      label = _ref.label,\n      resolve = _ref.resolve,\n      originalValue = _ref.originalValue,\n      opts = (0, _objectWithoutPropertiesLoose2.default)(_ref, [\"value\", \"label\", \"resolve\", \"originalValue\"]);\n  return function createError(_temp) {\n    var _ref2 = _temp === void 0 ? {} : _temp,\n        _ref2$path = _ref2.path,\n        path = _ref2$path === void 0 ? opts.path : _ref2$path,\n        _ref2$message = _ref2.message,\n        message = _ref2$message === void 0 ? opts.message : _ref2$message,\n        _ref2$type = _ref2.type,\n        type = _ref2$type === void 0 ? opts.name : _ref2$type,\n        params = _ref2.params;\n\n    params = (0, _extends2.default)({\n      path: path,\n      value: value,\n      originalValue: originalValue,\n      label: label\n    }, resolveParams(opts.params, params, resolve));\n    return (0, _extends2.default)(new _ValidationError.default(formatError(message, params), value, path, type), {\n      params: params\n    });\n  };\n}\n\nfunction createValidation(options) {\n  var name = options.name,\n      message = options.message,\n      test = options.test,\n      params = options.params;\n\n  function validate(_ref3) {\n    var value = _ref3.value,\n        path = _ref3.path,\n        label = _ref3.label,\n        options = _ref3.options,\n        originalValue = _ref3.originalValue,\n        sync = _ref3.sync,\n        rest = (0, _objectWithoutPropertiesLoose2.default)(_ref3, [\"value\", \"path\", \"label\", \"options\", \"originalValue\", \"sync\"]);\n    var parent = options.parent;\n\n    var resolve = function resolve(item) {\n      return _Reference.default.isRef(item) ? item.getValue({\n        value: value,\n        parent: parent,\n        context: options.context\n      }) : item;\n    };\n\n    var createError = createErrorFactory({\n      message: message,\n      path: path,\n      value: value,\n      originalValue: originalValue,\n      params: params,\n      label: label,\n      resolve: resolve,\n      name: name\n    });\n    var ctx = (0, _extends2.default)({\n      path: path,\n      parent: parent,\n      type: name,\n      createError: createError,\n      resolve: resolve,\n      options: options\n    }, rest);\n    return runTest(test, ctx, value, sync).then(function (validOrError) {\n      if (_ValidationError.default.isError(validOrError)) throw validOrError;else if (!validOrError) throw createError();\n    });\n  }\n\n  validate.OPTIONS = options;\n  return validate;\n}",
    "packages/strapi-admin/controllers/role.js": "'use strict';\n\nconst { yup, formatYupErrors } = require('strapi-utils');\nconst { validateRoleUpdateInput } = require('../validation/role');\nconst { validatedUpdatePermissionsInput } = require('../validation/permission');\nconst { EDITOR_CODE, AUTHOR_CODE, SUPER_ADMIN_CODE } = require('../services/constants');\n\nmodule.exports = {\n  /**\n   * Returns on role by id\n   * @param {KoaContext} ctx - koa context\n   */\n  async findOne(ctx) {\n    const { id } = ctx.params;\n    const role = await strapi.admin.services.role.findOneWithUsersCount({ id });\n\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    ctx.body = {\n      data: role,\n    };\n  },\n\n  /**\n   * Returns every roles\n   * @param {KoaContext} ctx - koa context\n   */\n  async findAll(ctx) {\n    const roles = await strapi.admin.services.role.findAllWithUsersCount();\n\n    ctx.body = {\n      data: roles,\n    };\n  },\n\n  /**\n   * Updates a role by id\n   * @param {KoaContext} ctx - koa context\n   */\n  async update(ctx) {\n    const { id } = ctx.params;\n\n    try {\n      await validateRoleUpdateInput(ctx.request.body);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const role = await strapi.admin.services.role.findOne({ id });\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    if (role.code === SUPER_ADMIN_CODE) {\n      return ctx.badRequest(\"Super admin can't be edited.\");\n    }\n\n    const updatedRole = await strapi.admin.services.role.update({ id }, ctx.request.body);\n\n    const sanitizedRole = strapi.admin.services.role.sanitizeRole(updatedRole);\n\n    ctx.body = {\n      data: sanitizedRole,\n    };\n  },\n\n  /**\n   * Returns the permissions assigned to a role\n   * @param {KoaContext} ctx - koa context\n   */\n  async getPermissions(ctx) {\n    const { id } = ctx.params;\n\n    const role = await strapi.admin.services.role.findOne({ id });\n\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    const permissions = await strapi.admin.services.permission.find({ role: role.id, _limit: -1 });\n    const sanitizedPermissions = permissions.map(\n      strapi.admin.services.permission.sanitizePermission\n    );\n\n    ctx.body = {\n      data: sanitizedPermissions,\n    };\n  },\n\n  /**\n   * Updates the permissions assigned to a role\n   * @param {KoaContext} ctx - koa context\n   */\n  async updatePermissions(ctx) {\n    const { id } = ctx.params;\n    const input = ctx.request.body;\n\n    const role = await strapi.admin.services.role.findOne({ id });\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    try {\n      if (role.code === SUPER_ADMIN_CODE) {\n        const err = new yup.ValidationError(\"Super admin permissions can't be edited.\");\n        throw formatYupErrors(err);\n      }\n      await validatedUpdatePermissionsInput(input, role);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    let existingPermissions = strapi.admin.services.permission.actionProvider.getAllByMap();\n    let permissionsToAssign;\n    if ([EDITOR_CODE, AUTHOR_CODE].includes(role.code)) {\n      permissionsToAssign = input.permissions.filter(\n        p => existingPermissions.get(p.action).section !== 'contentTypes'\n      );\n      const modifiedPermissions = input.permissions\n        .filter(p => existingPermissions.get(p.action).section === 'contentTypes')\n        .map(p => ({\n          ...p,\n          conditions: role.code === AUTHOR_CODE ? ['admin::is-creator'] : [],\n        }));\n      permissionsToAssign.push(...modifiedPermissions);\n    } else {\n      permissionsToAssign = input.permissions;\n    }\n\n    const permissions = await strapi.admin.services.role.assignPermissions(\n      role.id,\n      permissionsToAssign\n    );\n\n    ctx.body = {\n      data: permissions,\n    };\n  },\n};\n",
    "packages/strapi-utils/node_modules/yup/lib/array.js": "\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _taggedTemplateLiteralLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/taggedTemplateLiteralLoose\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _inherits = _interopRequireDefault(require(\"./util/inherits\"));\n\nvar _isAbsent = _interopRequireDefault(require(\"./util/isAbsent\"));\n\nvar _isSchema = _interopRequireDefault(require(\"./util/isSchema\"));\n\nvar _makePath = _interopRequireDefault(require(\"./util/makePath\"));\n\nvar _printValue = _interopRequireDefault(require(\"./util/printValue\"));\n\nvar _mixed = _interopRequireDefault(require(\"./mixed\"));\n\nvar _locale = require(\"./locale\");\n\nvar _runValidations = _interopRequireWildcard(require(\"./util/runValidations\"));\n\nfunction _templateObject2() {\n  var data = (0, _taggedTemplateLiteralLoose2.default)([\"\", \"[\", \"]\"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = (0, _taggedTemplateLiteralLoose2.default)([\"\", \"[\", \"]\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _default = ArraySchema;\nexports.default = _default;\n\nfunction ArraySchema(type) {\n  var _this = this;\n\n  if (!(this instanceof ArraySchema)) return new ArraySchema(type);\n\n  _mixed.default.call(this, {\n    type: 'array'\n  }); // `undefined` specifically means uninitialized, as opposed to\n  // \"no subtype\"\n\n\n  this._subType = undefined;\n  this.innerType = undefined;\n  this.withMutation(function () {\n    _this.transform(function (values) {\n      if (typeof values === 'string') try {\n        values = JSON.parse(values);\n      } catch (err) {\n        values = null;\n      }\n      return this.isType(values) ? values : null;\n    });\n\n    if (type) _this.of(type);\n  });\n}\n\n(0, _inherits.default)(ArraySchema, _mixed.default, {\n  _typeCheck: function _typeCheck(v) {\n    return Array.isArray(v);\n  },\n  _cast: function _cast(_value, _opts) {\n    var _this2 = this;\n\n    var value = _mixed.default.prototype._cast.call(this, _value, _opts); //should ignore nulls here\n\n\n    if (!this._typeCheck(value) || !this.innerType) return value;\n    var isChanged = false;\n    var castArray = value.map(function (v, idx) {\n      var castElement = _this2.innerType.cast(v, (0, _extends2.default)({}, _opts, {\n        path: (0, _makePath.default)(_templateObject(), _opts.path, idx)\n      }));\n\n      if (castElement !== v) {\n        isChanged = true;\n      }\n\n      return castElement;\n    });\n    return isChanged ? castArray : value;\n  },\n  _validate: function _validate(_value, options) {\n    var _this3 = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var errors = [];\n    var sync = options.sync;\n    var path = options.path;\n    var innerType = this.innerType;\n\n    var endEarly = this._option('abortEarly', options);\n\n    var recursive = this._option('recursive', options);\n\n    var originalValue = options.originalValue != null ? options.originalValue : _value;\n    return _mixed.default.prototype._validate.call(this, _value, options).catch((0, _runValidations.propagateErrors)(endEarly, errors)).then(function (value) {\n      if (!recursive || !innerType || !_this3._typeCheck(value)) {\n        if (errors.length) throw errors[0];\n        return value;\n      }\n\n      originalValue = originalValue || value; // #950 Ensure that sparse array empty slots are validated\n\n      var validations = new Array(value.length);\n\n      for (var idx = 0; idx < value.length; idx++) {\n        var item = value[idx];\n\n        var _path = (0, _makePath.default)(_templateObject2(), options.path, idx); // object._validate note for isStrict explanation\n\n\n        var innerOptions = (0, _extends2.default)({}, options, {\n          path: _path,\n          strict: true,\n          parent: value,\n          index: idx,\n          originalValue: originalValue[idx]\n        });\n        validations[idx] = innerType.validate ? innerType.validate(item, innerOptions) : true;\n      }\n\n      return (0, _runValidations.default)({\n        sync: sync,\n        path: path,\n        value: value,\n        errors: errors,\n        endEarly: endEarly,\n        validations: validations\n      });\n    });\n  },\n  _isPresent: function _isPresent(value) {\n    return _mixed.default.prototype._isPresent.call(this, value) && value.length > 0;\n  },\n  of: function of(schema) {\n    var next = this.clone();\n    if (schema !== false && !(0, _isSchema.default)(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema, or `false` to negate a current sub-schema. ' + 'not: ' + (0, _printValue.default)(schema));\n    next._subType = schema;\n    next.innerType = schema;\n    return next;\n  },\n  min: function min(_min, message) {\n    message = message || _locale.array.min;\n    return this.test({\n      message: message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min: _min\n      },\n      test: function test(value) {\n        return (0, _isAbsent.default)(value) || value.length >= this.resolve(_min);\n      }\n    });\n  },\n  max: function max(_max, message) {\n    message = message || _locale.array.max;\n    return this.test({\n      message: message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max: _max\n      },\n      test: function test(value) {\n        return (0, _isAbsent.default)(value) || value.length <= this.resolve(_max);\n      }\n    });\n  },\n  ensure: function ensure() {\n    var _this4 = this;\n\n    return this.default(function () {\n      return [];\n    }).transform(function (val, original) {\n      // We don't want to return `null` for nullable schema\n      if (_this4._typeCheck(val)) return val;\n      return original == null ? [] : [].concat(original);\n    });\n  },\n  compact: function compact(rejector) {\n    var reject = !rejector ? function (v) {\n      return !!v;\n    } : function (v, i, a) {\n      return !rejector(v, i, a);\n    };\n    return this.transform(function (values) {\n      return values != null ? values.filter(reject) : values;\n    });\n  },\n  describe: function describe() {\n    var base = _mixed.default.prototype.describe.call(this);\n\n    if (this.innerType) base.innerType = this.innerType.describe();\n    return base;\n  }\n});\nmodule.exports = exports.default;",
    "packages/strapi-admin/validation/permission.js": "'use strict';\n\nconst _ = require('lodash');\nconst { yup, formatYupErrors } = require('strapi-utils');\nconst { AUTHOR_CODE, PUBLISH_ACTION } = require('../services/constants');\nconst {\n  BOUND_ACTIONS_FOR_FIELDS,\n  BOUND_ACTIONS,\n  getBoundActionsBySubject,\n} = require('../domain/role');\nconst validators = require('./common-validators');\n\nconst handleReject = error => Promise.reject(formatYupErrors(error));\n\n// validatedUpdatePermissionsInput\n\nconst actionFieldsAreEqual = (a, b) => {\n  const aFields = a.fields || [];\n  const bFields = b.fields || [];\n\n  return _.isEqual(aFields.sort(), bFields.sort());\n};\n\nconst haveSameFieldsAsOtherActions = (a, i, allActions) =>\n  allActions.slice(i + 1).every(b => actionFieldsAreEqual(a, b));\n\nconst checkPermissionsAreBound = role =>\n  function(permissions) {\n    const permsBySubject = _.groupBy(\n      permissions.filter(perm => BOUND_ACTIONS.includes(perm.action)),\n      'subject'\n    );\n\n    for (const [subject, perms] of Object.entries(permsBySubject)) {\n      const boundActions = getBoundActionsBySubject(role, subject);\n      const missingActions =\n        _.xor(\n          perms.map(p => p.action),\n          boundActions\n        ).length !== 0;\n      if (missingActions) return false;\n\n      const permsBoundByFields = perms.filter(p => BOUND_ACTIONS_FOR_FIELDS.includes(p.action));\n      const everyActionsHaveSameFields = _.every(permsBoundByFields, haveSameFieldsAsOtherActions);\n      if (!everyActionsHaveSameFields) return false;\n    }\n\n    return true;\n  };\n\nconst noPublishPermissionForAuthorRole = role =>\n  function(permissions) {\n    const isAuthor = role.code === AUTHOR_CODE;\n    const hasPublishPermission = permissions.some(perm => perm.action === PUBLISH_ACTION);\n\n    return !(isAuthor && hasPublishPermission);\n  };\n\nconst getUpdatePermissionsSchemas = role => [\n  validators.updatePermissions,\n  yup.object().shape({ permissions: actionsExistSchema.clone() }),\n  yup.object().shape({\n    permissions: yup\n      .array()\n      .test(\n        'author-no-publish',\n        'The author role cannot have the publish permission.',\n        noPublishPermissionForAuthorRole(role)\n      ),\n  }),\n  yup.object().shape({\n    permissions: yup\n      .array()\n      .test(\n        'are-bond',\n        'Permissions have to be defined all together for a subject field or not at all',\n        checkPermissionsAreBound(role)\n      ),\n  }),\n];\n\nconst checkPermissionsSchema = yup.object().shape({\n  permissions: yup.array().of(\n    yup\n      .object()\n      .shape({\n        action: yup.string().required(),\n        subject: yup.string(),\n        field: yup.string(),\n      })\n      .noUnknown()\n  ),\n});\n\nconst validateCheckPermissionsInput = data => {\n  return checkPermissionsSchema\n    .validate(data, { strict: true, abortEarly: false })\n    .catch(handleReject);\n};\n\nconst validatedUpdatePermissionsInput = async (permissions, role) => {\n  try {\n    const schemas = getUpdatePermissionsSchemas(role);\n    for (const schema of schemas) {\n      await schema.validate(permissions, { strict: true, abortEarly: false });\n    }\n  } catch (e) {\n    return handleReject(e);\n  }\n};\n\n// validatePermissionsExist\n\nconst checkPermissionsExist = function(permissions) {\n  const existingActions = strapi.admin.services.permission.actionProvider.getAll();\n  const failIndex = permissions.findIndex(\n    permission =>\n      !existingActions.some(\n        action =>\n          action.actionId === permission.action &&\n          (action.section !== 'contentTypes' || action.subjects.includes(permission.subject))\n      )\n  );\n\n  return failIndex === -1\n    ? true\n    : this.createError({\n        path: 'permissions',\n        message: `[${failIndex}] is not an existing permission action`,\n      });\n};\n\nconst actionsExistSchema = yup\n  .array()\n  .of(\n    yup.object().shape({\n      conditions: yup.array().of(yup.string()),\n    })\n  )\n  .test('actions-exist', '', checkPermissionsExist);\n\nconst validatePermissionsExist = data => {\n  return actionsExistSchema.validate(data, { strict: true, abortEarly: false }).catch(handleReject);\n};\n\n// exports\n\nmodule.exports = {\n  validatedUpdatePermissionsInput,\n  validatePermissionsExist,\n  validateCheckPermissionsInput,\n};\n",
    "node_modules/jsdom/lib/jsdom/browser/resources/resource-queue.js": "\"use strict\";\n\n/**\n * Queue for all the resources to be download except async scripts.\n * Async scripts have their own queue AsyncResourceQueue.\n */\nmodule.exports = class ResourceQueue {\n  constructor({ paused, asyncQueue } = {}) {\n    this.paused = Boolean(paused);\n    this._asyncQueue = asyncQueue;\n  }\n\n  getLastScript() {\n    let head = this.tail;\n\n    while (head) {\n      if (head.isScript) {\n        return head;\n      }\n      head = head.prev;\n    }\n\n    return null;\n  }\n\n  _moreScripts() {\n    let found = false;\n\n    let head = this.tail;\n    while (head && !found) {\n      found = head.isScript;\n      head = head.prev;\n    }\n\n    return found;\n  }\n\n  _notify() {\n    if (this._listener) {\n      this._listener();\n    }\n  }\n\n  setListener(listener) {\n    this._listener = listener;\n  }\n\n  push(request, onLoad, onError, keepLast, element) {\n    const isScript = element ? element.localName === \"script\" : false;\n\n    if (!request) {\n      if (isScript && !this._moreScripts()) {\n        return onLoad();\n      }\n\n      request = new Promise(resolve => resolve());\n    }\n    const q = this;\n    const item = {\n      isScript,\n      err: null,\n      element,\n      fired: false,\n      data: null,\n      keepLast,\n      prev: q.tail,\n      check() {\n        if (!q.paused && !this.prev && this.fired) {\n          let promise;\n\n          if (this.err && onError) {\n            promise = onError(this.err);\n          }\n\n          if (!this.err && onLoad) {\n            promise = onLoad(this.data);\n          }\n\n          Promise.resolve(promise)\n            .then(() => {\n              if (this.next) {\n                this.next.prev = null;\n                this.next.check();\n              } else { // q.tail===this\n                q.tail = null;\n                q._notify();\n              }\n\n              this.finished = true;\n\n              if (q._asyncQueue) {\n                q._asyncQueue.notifyItem(this);\n              }\n            });\n        }\n      }\n    };\n    if (q.tail) {\n      if (q.tail.keepLast) {\n        // if the tail is the load event in document and we receive a new element to load\n        // we should add this new request before the load event.\n        if (q.tail.prev) {\n          q.tail.prev.next = item;\n        }\n        item.prev = q.tail.prev;\n        q.tail.prev = item;\n        item.next = q.tail;\n      } else {\n        q.tail.next = item;\n        q.tail = item;\n      }\n    } else {\n      q.tail = item;\n    }\n    return request\n      .then(data => {\n        item.fired = 1;\n        item.data = data;\n        item.check();\n      })\n      .catch(err => {\n        item.fired = true;\n        item.err = err;\n        item.check();\n      });\n  }\n\n  resume() {\n    if (!this.paused) {\n      return;\n    }\n    this.paused = false;\n\n    let head = this.tail;\n    while (head && head.prev) {\n      head = head.prev;\n    }\n    if (head) {\n      head.check();\n    }\n  }\n};\n",
    "node_modules/jsdom/lib/jsdom/living/helpers/mutation-observers.js": "\"use strict\";\n\nconst { domSymbolTree } = require(\"./internal-constants\");\nconst reportException = require(\"./runtime-script-errors\");\n\nconst Event = require(\"../generated/Event\");\nconst idlUtils = require(\"../generated/utils\");\nconst MutationRecord = require(\"../generated/MutationRecord\");\n\nconst MUTATION_TYPE = {\n  ATTRIBUTES: \"attributes\",\n  CHARACTER_DATA: \"characterData\",\n  CHILD_LIST: \"childList\"\n};\n\n// Note:\n// Since jsdom doesn't currently implement the concept of \"unit of related similar-origin browsing contexts\"\n// (https://html.spec.whatwg.org/multipage/browsers.html#unit-of-related-similar-origin-browsing-contexts)\n// we will approximate that the following properties are global for now.\n\n// https://dom.spec.whatwg.org/#mutation-observer-compound-microtask-queued-flag\nlet mutationObserverMicrotaskQueueFlag = false;\n\n// Non-spec compliant: List of all the mutation observers with mutation records enqueued. It's a replacement for\n// mutation observer list (https://dom.spec.whatwg.org/#mutation-observer-list) but without leaking since it's empty\n// before notifying the mutation observers.\nconst activeMutationObservers = new Set();\n\n// https://dom.spec.whatwg.org/#signal-slot-list\nconst signalSlotList = [];\n\n// https://dom.spec.whatwg.org/#queue-a-mutation-record\nfunction queueMutationRecord(\n  type,\n  target,\n  name,\n  namespace,\n  oldValue,\n  addedNodes,\n  removedNodes,\n  previousSibling,\n  nextSibling\n) {\n  const interestedObservers = new Map();\n\n  const nodes = domSymbolTree.ancestorsToArray(target);\n\n  for (const node of nodes) {\n    for (const registered of node._registeredObserverList) {\n      const { options, observer: mo } = registered;\n\n      if (\n        !(node !== target && options.subtree === false) &&\n        !(type === MUTATION_TYPE.ATTRIBUTES && options.attributes !== true) &&\n        !(type === MUTATION_TYPE.ATTRIBUTES && options.attributeFilter &&\n          !options.attributeFilter.some(value => value === name || value === namespace)) &&\n        !(type === MUTATION_TYPE.CHARACTER_DATA && options.characterData !== true) &&\n        !(type === MUTATION_TYPE.CHILD_LIST && options.childList === false)\n      ) {\n        if (!interestedObservers.has(mo)) {\n          interestedObservers.set(mo, null);\n        }\n\n        if (\n          (type === MUTATION_TYPE.ATTRIBUTES && options.attributeOldValue === true) ||\n          (type === MUTATION_TYPE.CHARACTER_DATA && options.characterDataOldValue === true)\n        ) {\n          interestedObservers.set(mo, oldValue);\n        }\n      }\n    }\n  }\n\n  for (const [observer, mappedOldValue] of interestedObservers.entries()) {\n    const record = MutationRecord.createImpl(target._globalObject, [], {\n      type,\n      target,\n      attributeName: name,\n      attributeNamespace: namespace,\n      oldValue: mappedOldValue,\n      addedNodes,\n      removedNodes,\n      previousSibling,\n      nextSibling\n    });\n\n    observer._recordQueue.push(record);\n    activeMutationObservers.add(observer);\n  }\n\n  queueMutationObserverMicrotask();\n}\n\n// https://dom.spec.whatwg.org/#queue-a-tree-mutation-record\nfunction queueTreeMutationRecord(target, addedNodes, removedNodes, previousSibling, nextSibling) {\n  queueMutationRecord(\n    MUTATION_TYPE.CHILD_LIST,\n    target,\n    null,\n    null,\n    null,\n    addedNodes,\n    removedNodes,\n    previousSibling,\n    nextSibling\n  );\n}\n\n// https://dom.spec.whatwg.org/#queue-an-attribute-mutation-record\nfunction queueAttributeMutationRecord(target, name, namespace, oldValue) {\n  queueMutationRecord(\n    MUTATION_TYPE.ATTRIBUTES,\n    target,\n    name,\n    namespace,\n    oldValue,\n    [],\n    [],\n    null,\n    null\n  );\n}\n\n// https://dom.spec.whatwg.org/#queue-a-mutation-observer-compound-microtask\nfunction queueMutationObserverMicrotask() {\n  if (mutationObserverMicrotaskQueueFlag) {\n    return;\n  }\n\n  mutationObserverMicrotaskQueueFlag = true;\n\n  Promise.resolve().then(() => {\n    notifyMutationObservers();\n  });\n}\n\n// https://dom.spec.whatwg.org/#notify-mutation-observers\nfunction notifyMutationObservers() {\n  mutationObserverMicrotaskQueueFlag = false;\n\n  const notifyList = [...activeMutationObservers].sort((a, b) => a._id - b._id);\n  activeMutationObservers.clear();\n\n  const signalList = [...signalSlotList];\n  signalSlotList.splice(0, signalSlotList.length);\n\n  for (const mo of notifyList) {\n    const records = [...mo._recordQueue];\n    mo._recordQueue = [];\n\n    for (const node of mo._nodeList) {\n      node._registeredObserverList = node._registeredObserverList.filter(registeredObserver => {\n        return registeredObserver.source !== mo;\n      });\n\n      if (records.length) {\n        try {\n          mo._callback(\n            records.map(idlUtils.wrapperForImpl),\n            idlUtils.wrapperForImpl(mo)\n          );\n        } catch (e) {\n          const { target } = records[0];\n          const window = target._ownerDocument._defaultView;\n\n          reportException(window, e);\n        }\n      }\n    }\n  }\n\n  for (const slot of signalList) {\n    const slotChangeEvent = Event.createImpl(\n      slot._globalObject,\n      [\n        \"slotchange\",\n        { bubbles: true }\n      ],\n      { isTrusted: true }\n    );\n\n    slot._dispatch(slotChangeEvent);\n  }\n}\n\nmodule.exports = {\n  MUTATION_TYPE,\n\n  queueMutationRecord,\n  queueTreeMutationRecord,\n  queueAttributeMutationRecord,\n\n  queueMutationObserverMicrotask,\n\n  signalSlotList\n};\n",
    "packages/strapi-admin/services/__tests__/role.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst roleService = require('../role');\nconst { SUPER_ADMIN_CODE } = require('../constants');\n\ndescribe('Role', () => {\n  describe('create', () => {\n    test('Creates a role', async () => {\n      const dbCreate = jest.fn(role => Promise.resolve(role));\n      const dbCount = jest.fn(() => Promise.resolve(0));\n\n      global.strapi = {\n        query: () => ({ create: dbCreate, count: dbCount }),\n      };\n\n      const input = {\n        name: 'super_admin',\n        description: \"Have all permissions. Can't be delete\",\n        code: 'super-admin',\n      };\n\n      const createdRole = await roleService.create(input);\n\n      expect(dbCreate).toHaveBeenCalledWith(input);\n      expect(createdRole).toStrictEqual(input);\n    });\n  });\n  describe('findOne', () => {\n    test('Finds a role', async () => {\n      const role = {\n        id: 1,\n        name: 'super_admin',\n        description: \"Have all permissions. Can't be delete\",\n      };\n      const dbFindOne = jest.fn(({ id }) => Promise.resolve(_.find([role], { id })));\n\n      global.strapi = {\n        query: () => ({ findOne: dbFindOne }),\n      };\n\n      const foundRole = await roleService.findOne({ id: role.id });\n\n      expect(dbFindOne).toHaveBeenCalledWith({ id: role.id }, []);\n      expect(foundRole).toStrictEqual(role);\n    });\n    test('Finds a role with usersCount', async () => {\n      const role = {\n        id: 1,\n        name: 'super_admin',\n        description: \"Have all permissions. Can't be delete\",\n        usersCount: 0,\n      };\n      const dbFindOne = jest.fn(({ id }) =>\n        Promise.resolve(_.find([_.omit(role, ['usersCount'])], { id }))\n      );\n      const dbCount = jest.fn(() => Promise.resolve(0));\n      global.strapi = {\n        query: () => ({ findOne: dbFindOne, count: dbCount }),\n      };\n\n      const foundRole = await roleService.findOneWithUsersCount({ id: role.id });\n\n      expect(dbFindOne).toHaveBeenCalledWith({ id: role.id }, []);\n      expect(dbCount).toHaveBeenCalledWith({ roles: [role.id] });\n      expect(foundRole).toStrictEqual(role);\n    });\n  });\n  describe('find', () => {\n    test('Finds roles', async () => {\n      const roles = [\n        {\n          id: 1,\n          name: 'super_admin',\n          description: \"Have all permissions. Can't be delete\",\n        },\n      ];\n      const dbFind = jest.fn(() => Promise.resolve(roles));\n\n      global.strapi = {\n        query: () => ({ find: dbFind }),\n      };\n\n      const foundRoles = await roleService.find();\n\n      expect(dbFind).toHaveBeenCalledWith({}, []);\n      expect(foundRoles).toStrictEqual(roles);\n    });\n  });\n  describe('findAll', () => {\n    test('Finds all roles', async () => {\n      const roles = [\n        {\n          id: 1,\n          name: 'super_admin',\n          description: \"Have all permissions. Can't be delete\",\n          usersCount: 0,\n        },\n      ];\n      const dbFind = jest.fn(() =>\n        Promise.resolve(roles.map(role => _.omit(role, ['usersCount'])))\n      );\n      const dbCount = jest.fn(() => Promise.resolve(0));\n\n      global.strapi = {\n        query: () => ({ find: dbFind, count: dbCount }),\n      };\n\n      const foundRoles = await roleService.findAllWithUsersCount();\n\n      expect(dbFind).toHaveBeenCalledWith({ _limit: -1 }, []);\n      expect(foundRoles).toStrictEqual(roles);\n    });\n  });\n  describe('update', () => {\n    test('Updates a role', async () => {\n      const role = {\n        id: 1,\n        name: 'super_admin',\n        description: 'AAA',\n      };\n      const expectedUpdatedRole = {\n        id: 1,\n        name: 'super_admin_updated',\n        description: 'AAA_updated',\n      };\n      const dbUpdate = jest.fn(() => Promise.resolve(expectedUpdatedRole));\n      const dbCount = jest.fn(() => Promise.resolve(0));\n\n      global.strapi = {\n        query: () => ({ update: dbUpdate, count: dbCount }),\n      };\n\n      const updatedRole = await roleService.update(\n        {\n          id: role.id,\n        },\n        {\n          name: expectedUpdatedRole.name,\n          description: expectedUpdatedRole.description,\n        }\n      );\n\n      expect(dbUpdate).toHaveBeenCalledWith(\n        {\n          id: role.id,\n        },\n        {\n          name: expectedUpdatedRole.name,\n          description: expectedUpdatedRole.description,\n        }\n      );\n      expect(updatedRole).toStrictEqual(expectedUpdatedRole);\n    });\n    test('Cannot update code of super admin role', async () => {\n      const dbUpdate = jest.fn();\n      const dbFind = jest.fn(() => [{ id: '1' }]);\n      const dbFindOne = jest.fn(() => ({ id: '1', code: SUPER_ADMIN_CODE }));\n      const badRequest = jest.fn(() => {});\n\n      global.strapi = {\n        query: () => ({ find: dbFind, findOne: dbFindOne, update: dbUpdate }),\n        admin: { config: { superAdminCode: SUPER_ADMIN_CODE } },\n        errors: { badRequest },\n      };\n\n      await roleService.update({ id: 1 }, { code: 'new_code' });\n\n      expect(dbUpdate).toHaveBeenCalledWith({ id: 1 }, {});\n    });\n  });\n  describe('count', () => {\n    test('getUsersCount', async () => {\n      const roleId = 1;\n      const dbCount = jest.fn(() => Promise.resolve(0));\n      global.strapi = {\n        query: () => ({ count: dbCount }),\n      };\n\n      const usersCount = await roleService.getUsersCount(roleId);\n\n      expect(dbCount).toHaveBeenCalledWith({ roles: [roleId] });\n      expect(usersCount).toEqual(0);\n    });\n  });\n  describe('delete', () => {\n    test('Delete a role', async () => {\n      const role = {\n        id: 3,\n        name: 'admin',\n        description: 'Description',\n        users: [],\n      };\n      const dbCount = jest.fn(() => Promise.resolve(0));\n      const dbFindOne = jest.fn(() => ({ id: 1, code: SUPER_ADMIN_CODE }));\n      const dbDelete = jest.fn(() => Promise.resolve(role));\n      const dbDeleteByRolesIds = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query: () => ({ delete: dbDelete, count: dbCount, findOne: dbFindOne }),\n        admin: {\n          services: {\n            permission: { deleteByRolesIds: dbDeleteByRolesIds },\n          },\n          config: { superAdminCode: SUPER_ADMIN_CODE },\n        },\n      };\n\n      const deletedRoles = await roleService.deleteByIds([role.id]);\n\n      expect(dbCount).toHaveBeenCalledWith({ roles: [role.id] });\n      expect(dbDelete).toHaveBeenCalledWith({ id_in: [role.id] });\n      expect(deletedRoles).toStrictEqual([role]);\n    });\n    test('Delete two roles', async () => {\n      const roles = [\n        {\n          id: 1,\n          name: 'admin 1',\n          description: 'Description',\n          users: [],\n        },\n        {\n          id: 2,\n          name: 'admin 2',\n          description: 'Description',\n          users: [],\n        },\n      ];\n      const dbCount = jest.fn(() => Promise.resolve(0));\n      const dbFindOne = jest.fn(() => ({ id: 3, code: SUPER_ADMIN_CODE }));\n      const rolesIds = roles.map(r => r.id);\n      const dbDelete = jest.fn(() => Promise.resolve(roles));\n      const dbGetUsersCount = jest.fn(() => Promise.resolve(0));\n      const dbDeleteByRolesIds = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query: () => ({ delete: dbDelete, count: dbCount, findOne: dbFindOne }),\n        admin: {\n          services: {\n            permission: { deleteByRolesIds: dbDeleteByRolesIds },\n            role: { getUsersCount: dbGetUsersCount },\n          },\n          config: { superAdminCode: SUPER_ADMIN_CODE },\n        },\n      };\n\n      const deletedRoles = await roleService.deleteByIds(rolesIds);\n\n      expect(dbCount).toHaveBeenNthCalledWith(1, { roles: [rolesIds[0]] });\n      expect(dbCount).toHaveBeenNthCalledWith(2, { roles: [rolesIds[1]] });\n      expect(dbCount).toHaveBeenCalledTimes(2);\n      expect(dbDelete).toHaveBeenCalledWith({ id_in: rolesIds });\n      expect(deletedRoles).toStrictEqual(roles);\n    });\n    test('Cannot delete super admin role', async () => {\n      const dbFind = jest.fn(() => [{ id: '1' }]);\n      const dbFindOne = jest.fn(() => ({ id: '1', code: SUPER_ADMIN_CODE }));\n      const badRequest = jest.fn(() => {});\n\n      global.strapi = {\n        query: () => ({ find: dbFind, findOne: dbFindOne }),\n        admin: { config: { superAdminCode: SUPER_ADMIN_CODE } },\n        errors: { badRequest },\n      };\n\n      try {\n        await roleService.deleteByIds([1]);\n      } catch (e) {\n        // nothing\n      }\n\n      expect(badRequest).toHaveBeenCalledWith('ValidationError', {\n        ids: ['You cannot delete the super admin role'],\n      });\n    });\n  });\n  describe('Count roles', () => {\n    test('Count roles without params', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      global.strapi = {\n        query: () => ({ count }),\n      };\n\n      const amount = await roleService.count();\n\n      expect(amount).toBe(2);\n      expect(count).toHaveBeenCalledWith({});\n    });\n\n    test('Count roles with params', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      global.strapi = {\n        query: () => ({ count }),\n      };\n\n      const params = { foo: 'bar' };\n      const amount = await roleService.count(params);\n\n      expect(amount).toBe(2);\n      expect(count).toHaveBeenCalledWith(params);\n    });\n  });\n  describe('createRolesIfNoneExist', () => {\n    test(\"Don't create roles if one already exist\", async () => {\n      const count = jest.fn(() => Promise.resolve(1));\n      const create = jest.fn();\n      global.strapi = {\n        query: () => ({ count, create }),\n      };\n      await roleService.createRolesIfNoneExist();\n\n      expect(create).toHaveBeenCalledTimes(0);\n    });\n    test('Create 3 roles if none exist', async () => {\n      const actions = [\n        {\n          actionId: 'action-1',\n          subjects: ['country'],\n          section: 'contentTypes',\n        },\n      ];\n      const permissions = [\n        {\n          action: 'action-1',\n          subject: 'country',\n          fields: ['name'],\n          conditions: [],\n        },\n      ];\n\n      const defaultPermissions = [\n        {\n          action: 'plugins::upload.read',\n          conditions: ['admin::is-creator'],\n          fields: null,\n          subject: null,\n        },\n        {\n          action: 'plugins::upload.assets.create',\n          conditions: [],\n          fields: null,\n          subject: null,\n        },\n        {\n          action: 'plugins::upload.assets.update',\n          conditions: ['admin::is-creator'],\n          fields: null,\n          subject: null,\n        },\n        {\n          action: 'plugins::upload.assets.download',\n          conditions: [],\n          fields: null,\n          subject: null,\n        },\n        {\n          action: 'plugins::upload.assets.copy-link',\n          conditions: [],\n          fields: null,\n          subject: null,\n        },\n      ];\n\n      const count = jest.fn(() => Promise.resolve(0));\n      let id = 1;\n      const create = jest.fn(role => ({ ...role, id: id++ }));\n      const getAll = jest.fn(() => actions);\n      const createMany = jest.fn();\n      const assignARoleToAll = jest.fn();\n      const getPermissionsWithNestedFields = jest.fn(() => [...permissions]); // cloned, otherwise it is modified inside createRolesIfNoneExist()\n\n      global.strapi = {\n        query: () => ({ count, create }),\n        admin: {\n          services: {\n            permission: { actionProvider: { getAll }, createMany },\n            'content-type': { getPermissionsWithNestedFields },\n            user: { assignARoleToAll },\n          },\n        },\n      };\n      await roleService.createRolesIfNoneExist();\n\n      expect(create).toHaveBeenCalledTimes(3);\n      expect(create).toHaveBeenNthCalledWith(1, {\n        name: 'Super Admin',\n        code: 'strapi-super-admin',\n        description: 'Super Admins can access and manage all features and settings.',\n      });\n      expect(assignARoleToAll).toHaveBeenCalledWith(1);\n      expect(create).toHaveBeenNthCalledWith(2, {\n        name: 'Editor',\n        code: 'strapi-editor',\n        description: 'Editors can manage and publish contents including those of other users.',\n      });\n      expect(create).toHaveBeenNthCalledWith(3, {\n        name: 'Author',\n        code: 'strapi-author',\n        description: 'Authors can manage the content they have created.',\n      });\n      expect(getPermissionsWithNestedFields).toHaveBeenCalledWith(actions, {\n        restrictedSubjects: ['plugins::users-permissions.user'],\n      });\n      expect(createMany).toHaveBeenCalledTimes(2);\n      expect(createMany).toHaveBeenNthCalledWith(\n        1,\n        [\n          ...permissions,\n          ...defaultPermissions.map(d => ({\n            ...d,\n            conditions: [],\n          })),\n        ].map(p => ({ ...p, role: 2 }))\n      );\n\n      expect(createMany).toHaveBeenNthCalledWith(\n        2,\n        [\n          { ...permissions[0], conditions: ['admin::is-creator'] },\n          ...defaultPermissions,\n        ].map(p => ({ ...p, role: 3 }))\n      );\n    });\n  });\n  describe('displayWarningIfNoSuperAdmin', () => {\n    test('superAdmin role exists & a user is superAdmin', async () => {\n      const findOne = jest.fn(() => ({ id: 1 }));\n      const count = jest.fn(() => Promise.resolve(1));\n      const exists = jest.fn(() => Promise.resolve(true));\n      const warn = jest.fn();\n\n      global.strapi = {\n        query: () => ({ findOne, count }),\n        admin: { services: { user: { exists } } },\n        log: { warn },\n      };\n\n      await roleService.displayWarningIfNoSuperAdmin();\n\n      expect(warn).toHaveBeenCalledTimes(0);\n    });\n    test(\"superAdmin role doesn't exist\", async () => {\n      const findOne = jest.fn(() => undefined);\n      const count = jest.fn(() => Promise.resolve(0));\n      const exists = jest.fn(() => Promise.resolve(false));\n      const warn = jest.fn();\n\n      global.strapi = {\n        query: () => ({ findOne, count }),\n        admin: { services: { user: { exists } } },\n        log: { warn },\n      };\n\n      await roleService.displayWarningIfNoSuperAdmin();\n\n      expect(warn).toHaveBeenCalledWith(\"Your application doesn't have a super admin role.\");\n    });\n    test('superAdmin role exist & no user is superAdmin', async () => {\n      const findOne = jest.fn(() => ({ id: 1 }));\n      const count = jest.fn(() => Promise.resolve(0));\n      const exists = jest.fn(() => Promise.resolve(true));\n      const warn = jest.fn();\n\n      global.strapi = {\n        query: () => ({ findOne, count }),\n        admin: { services: { user: { exists } } },\n        log: { warn },\n      };\n\n      await roleService.displayWarningIfNoSuperAdmin();\n\n      expect(warn).toHaveBeenCalledWith(\"Your application doesn't have a super admin user.\");\n    });\n  });\n\n  describe('resetSuperAdminPermissions', () => {\n    test('No superAdmin role exist', async () => {\n      const getSuperAdmin = jest.fn(() => Promise.resolve(undefined));\n      const createMany = jest.fn();\n\n      global.strapi = {\n        query: () => ({ createMany }),\n        admin: { services: { role: { getSuperAdmin } } },\n      };\n\n      await roleService.resetSuperAdminPermissions();\n\n      expect(createMany).toHaveBeenCalledTimes(0);\n    });\n\n    test('Reset super admin permissions', async () => {\n      const roleId = 1;\n      const actions = [\n        {\n          actionId: 'action-1',\n          subjects: ['country'],\n          section: 'contentTypes',\n        },\n        {\n          actionId: 'action-test2',\n          subjects: ['test-subject1', 'test-subject2'],\n          section: 'settings',\n        },\n        {\n          actionId: 'action-test3',\n          subjects: null,\n          section: 'plugin',\n        },\n      ];\n      const permissions = [\n        {\n          action: 'action-1',\n          subject: 'country',\n          fields: ['name'],\n          conditions: [],\n        },\n        {\n          action: 'action-test2',\n          subject: 'test-subject1',\n          fields: null,\n          conditions: [],\n        },\n        {\n          action: 'action-test2',\n          subject: 'test-subject2',\n          fields: null,\n          conditions: [],\n        },\n        {\n          action: 'action-test3',\n          subject: null,\n          fields: null,\n          conditions: [],\n        },\n      ];\n      const getAll = jest.fn(() => actions);\n      const getAllConditions = jest.fn(() => []);\n      const find = jest.fn(() => [{ action: 'action-2', id: 2 }]);\n      const getPermissionsWithNestedFields = jest.fn(() => [\n        {\n          ...permissions[0],\n        },\n      ]); // cloned, otherwise it is modified inside resetSuperAdminPermissions()\n      const deleteByIds = jest.fn();\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: roleId }));\n      const createMany = jest.fn(() => []);\n      const removeUnkownConditionIds = jest.fn(conds => conds);\n\n      global.strapi = {\n        admin: {\n          services: {\n            permission: {\n              createMany,\n              find,\n              actionProvider: { getAll },\n              conditionProvider: { getAll: getAllConditions },\n              deleteByIds,\n            },\n            condition: { removeUnkownConditionIds },\n            'content-type': { getPermissionsWithNestedFields },\n            role: { getSuperAdmin },\n          },\n        },\n      };\n\n      await roleService.resetSuperAdminPermissions();\n\n      expect(deleteByIds).toHaveBeenCalledWith([2]);\n      expect(createMany).toHaveBeenCalledWith(\n        expect.arrayContaining(\n          permissions.map(perm => ({\n            ...perm,\n            role: roleId,\n          }))\n        )\n      );\n    });\n  });\n\n  describe('Assign permissions', () => {\n    test('Delete previous permissions', async () => {\n      const createMany = jest.fn(() => Promise.resolve([]));\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: 0 }));\n      const sendDidUpdateRolePermissions = jest.fn();\n      const find = jest.fn(() => Promise.resolve([{ id: 3 }]));\n      const deleteByIds = jest.fn();\n      const getAll = jest.fn(() => []);\n\n      global.strapi = {\n        admin: {\n          services: {\n            metrics: { sendDidUpdateRolePermissions },\n            permission: { find, createMany, actionProvider: { getAll }, deleteByIds },\n            role: { getSuperAdmin },\n          },\n        },\n      };\n\n      await roleService.assignPermissions(1, []);\n\n      expect(deleteByIds).toHaveBeenCalledWith([3]);\n    });\n\n    test('Create new permissions', async () => {\n      const permissions = Array(5)\n        .fill(0)\n        .map((v, i) => ({ action: `action-${i}` }));\n\n      const createMany = jest.fn(() => Promise.resolve([]));\n      const getSuperAdmin = jest.fn(() => Promise.resolve({ id: 0 }));\n      const sendDidUpdateRolePermissions = jest.fn();\n      const find = jest.fn(() => Promise.resolve([]));\n      const getAll = jest.fn(() => permissions.map(perm => ({ actionId: perm.action })));\n      const removeUnkownConditionIds = jest.fn(conds => _.intersection(conds, ['cond']));\n\n      global.strapi = {\n        admin: {\n          services: {\n            metrics: { sendDidUpdateRolePermissions },\n            role: { getSuperAdmin },\n            permission: {\n              find,\n              createMany,\n              actionProvider: { getAll },\n              conditionProvider: {\n                getAll: jest.fn(() => [{ id: 'admin::is-creator' }]),\n              },\n            },\n            condition: {\n              removeUnkownConditionIds,\n            },\n          },\n        },\n      };\n\n      const permissionsToAssign = [...permissions];\n      permissionsToAssign[4] = {\n        ...permissions[4],\n        conditions: ['cond', 'unknown-cond'],\n      };\n\n      await roleService.assignPermissions(1, permissionsToAssign);\n\n      expect(createMany).toHaveBeenCalledTimes(1);\n      expect(createMany).toHaveBeenCalledWith([\n        { action: 'action-0', conditions: [], fields: null, role: 1, subject: null },\n        { action: 'action-1', conditions: [], fields: null, role: 1, subject: null },\n        { action: 'action-2', conditions: [], fields: null, role: 1, subject: null },\n        { action: 'action-3', conditions: [], fields: null, role: 1, subject: null },\n        { action: 'action-4', conditions: ['cond'], fields: null, role: 1, subject: null },\n      ]);\n    });\n  });\n\n  describe('addPermissions', () => {\n    test('Add role to permissions and call permissions service creation method', async () => {\n      const createMany = jest.fn(() => []);\n      const roleId = 1;\n      const permissions = [\n        {\n          action: 'someAction',\n          conditions: [],\n          fields: null,\n          subject: null,\n        },\n      ];\n\n      global.strapi = {\n        admin: {\n          services: {\n            permission: {\n              createMany,\n            },\n          },\n        },\n      };\n\n      await roleService.addPermissions(roleId, permissions);\n      expect(createMany).toHaveBeenCalledWith(\n        expect.arrayContaining(\n          permissions.map(permission => ({\n            ...permission,\n            role: roleId,\n          }))\n        )\n      );\n    });\n  });\n\n  test('sanitizeRole removes users and permissions', () => {\n    const role = {\n      id: 1,\n      name: 'Some Role',\n      users: [{ id: 1 }],\n      permissions: [{ id: 1 }],\n    };\n\n    expect(roleService.sanitizeRole(role)).toEqual({\n      id: 1,\n      name: 'Some Role',\n    });\n  });\n});\n",
    "packages/strapi-admin/services/role.js": "'use strict';\n\nconst _ = require('lodash');\nconst { set } = require('lodash/fp');\nconst { generateTimestampCode, stringIncludes } = require('strapi-utils');\nconst { createPermission } = require('../domain/permission');\nconst { validatePermissionsExist } = require('../validation/permission');\nconst { SUPER_ADMIN_CODE } = require('./constants');\n\nconst ACTIONS = {\n  publish: 'plugins::content-manager.explorer.publish',\n};\n\nconst sanitizeRole = role => {\n  return _.omit(role, ['users', 'permissions']);\n};\n\nconst fieldsToCompare = ['action', 'subject', 'fields', 'conditions'];\n\nconst getPermissionWithSortedFields = perm => {\n  const sortedPerm = _.cloneDeep(perm);\n  if (Array.isArray(sortedPerm.fields)) {\n    sortedPerm.fields.sort();\n  }\n  return sortedPerm;\n};\n\nconst arePermissionsEqual = (perm1, perm2) =>\n  _.isEqual(\n    _.pick(getPermissionWithSortedFields(perm1), fieldsToCompare),\n    _.pick(getPermissionWithSortedFields(perm2), fieldsToCompare)\n  );\n\n/**\n * Create and save a role in database\n * @param attributes A partial role object\n * @returns {Promise<role>}\n */\nconst create = async attributes => {\n  const alreadyExists = await exists({ name: attributes.name });\n\n  if (alreadyExists) {\n    throw strapi.errors.badRequest('ValidationError', {\n      name: [`The name must be unique and a role with name \\`${attributes.name}\\` already exists.`],\n    });\n  }\n\n  const autoGeneratedCode = `${_.kebabCase(attributes.name)}-${generateTimestampCode()}`;\n\n  const rolesWithCode = {\n    ...attributes,\n    code: attributes.code || autoGeneratedCode,\n  };\n\n  return strapi.query('role', 'admin').create(rolesWithCode);\n};\n\n/**\n * Find a role in database\n * @param params query params to find the role\n * @param populate\n * @returns {Promise<role>}\n */\nconst findOne = (params = {}, populate = []) => {\n  return strapi.query('role', 'admin').findOne(params, populate);\n};\n\n/**\n * Find a role in database with usersCounts\n * @param params query params to find the role\n * @param populate\n * @returns {Promise<role>}\n */\nconst findOneWithUsersCount = async (params = {}, populate = []) => {\n  const role = await strapi.query('role', 'admin').findOne(params, populate);\n\n  if (role) {\n    role.usersCount = await getUsersCount(role.id);\n  }\n\n  return role;\n};\n\n/**\n * Find roles in database\n * @param params query params to find the roles\n * @param populate\n * @returns {Promise<array>}\n */\nconst find = (params = {}, populate = []) => {\n  return strapi.query('role', 'admin').find(params, populate);\n};\n\n/**\n * Find all roles in database\n * @returns {Promise<array>}\n */\nconst findAllWithUsersCount = async (populate = []) => {\n  const roles = await strapi.query('role', 'admin').find({ _limit: -1 }, populate);\n  for (let role of roles) {\n    role.usersCount = await getUsersCount(role.id);\n  }\n\n  return roles;\n};\n\n/**\n * Update a role in database\n * @param params query params to find the role to update\n * @param attributes A partial role object\n * @returns {Promise<role>}\n */\nconst update = async (params, attributes) => {\n  const sanitizedAttributes = _.omit(attributes, ['code']);\n\n  if (_.has(params, 'id') && _.has(sanitizedAttributes, 'name')) {\n    const alreadyExists = await exists({\n      name: sanitizedAttributes.name,\n      id_ne: params.id,\n    });\n    if (alreadyExists) {\n      throw strapi.errors.badRequest('ValidationError', {\n        name: [\n          `The name must be unique and a role with name \\`${sanitizedAttributes.name}\\` already exists.`,\n        ],\n      });\n    }\n  }\n\n  return strapi.query('role', 'admin').update(params, sanitizedAttributes);\n};\n\n/**\n * Check if a role exists in database\n * @param params query params to find the role\n * @returns {Promise<boolean>}\n */\nconst exists = async params => {\n  const foundCount = await strapi.query('role', 'admin').count(params);\n\n  return foundCount > 0;\n};\n\n/**\n * Count the number of roles based on search params\n * @param params params used for the query\n * @returns {Promise<number>}\n */\nconst count = async (params = {}) => {\n  return strapi.query('role', 'admin').count(params);\n};\n\n/**\n * Delete roles in database if they have no user assigned\n * @param ids query params to find the roles\n * @returns {Promise<array>}\n */\nconst deleteByIds = async (ids = []) => {\n  const superAdminRole = await getSuperAdmin();\n  if (superAdminRole && stringIncludes(ids, superAdminRole.id)) {\n    throw strapi.errors.badRequest('ValidationError', {\n      ids: ['You cannot delete the super admin role'],\n    });\n  }\n\n  for (let roleId of ids) {\n    const usersCount = await getUsersCount(roleId);\n    if (usersCount !== 0) {\n      throw strapi.errors.badRequest('ValidationError', {\n        ids: ['Some roles are still assigned to some users.'],\n      });\n    }\n  }\n\n  await strapi.admin.services.permission.deleteByRolesIds(ids);\n\n  let deletedRoles = await strapi.query('role', 'admin').delete({ id_in: ids });\n\n  if (!Array.isArray(deletedRoles)) {\n    deletedRoles = [deletedRoles];\n  }\n\n  return deletedRoles;\n};\n\n/** Count the number of users for some roles\n * @returns {Promise<number>}\n * @param roleId\n */\nconst getUsersCount = async roleId => {\n  return strapi.query('user', 'admin').count({ roles: [roleId] });\n};\n\n/** Returns admin role\n * @returns {Promise<role>}\n */\nconst getSuperAdmin = () => findOne({ code: SUPER_ADMIN_CODE });\n\n/** Returns admin role with userCount\n * @returns {Promise<role>}\n */\nconst getSuperAdminWithUsersCount = () => findOneWithUsersCount({ code: SUPER_ADMIN_CODE });\n\n/** Create superAdmin, Author and Editor role is no role already exist\n * @returns {Promise<>}\n */\nconst createRolesIfNoneExist = async () => {\n  const someRolesExist = await exists();\n  if (someRolesExist) {\n    return;\n  }\n\n  const allActions = strapi.admin.services.permission.actionProvider.getAll();\n  const contentTypesActions = allActions.filter(a => a.section === 'contentTypes');\n\n  // create 3 roles\n  const superAdminRole = await create({\n    name: 'Super Admin',\n    code: 'strapi-super-admin',\n    description: 'Super Admins can access and manage all features and settings.',\n  });\n\n  await strapi.admin.services.user.assignARoleToAll(superAdminRole.id);\n\n  const editorRole = await create({\n    name: 'Editor',\n    code: 'strapi-editor',\n    description: 'Editors can manage and publish contents including those of other users.',\n  });\n\n  const authorRole = await create({\n    name: 'Author',\n    code: 'strapi-author',\n    description: 'Authors can manage the content they have created.',\n  });\n\n  // create content-type permissions for each role\n  const editorPermissions = strapi.admin.services['content-type'].getPermissionsWithNestedFields(\n    contentTypesActions,\n    {\n      restrictedSubjects: ['plugins::users-permissions.user'],\n    }\n  );\n\n  const authorPermissions = editorPermissions\n    .filter(({ action }) => action !== ACTIONS.publish)\n    .map(set('conditions', ['admin::is-creator']));\n\n  editorPermissions.push(...getDefaultPluginPermissions());\n  authorPermissions.push(...getDefaultPluginPermissions({ isAuthor: true }));\n\n  // assign permissions to roles\n  await addPermissions(editorRole.id, editorPermissions);\n  await addPermissions(authorRole.id, authorPermissions);\n};\n\nconst getDefaultPluginPermissions = ({ isAuthor = false } = {}) => {\n  const conditions = isAuthor ? ['admin::is-creator'] : null;\n\n  // add plugin permissions for each role\n  return [\n    { action: 'plugins::upload.read', conditions },\n    { action: 'plugins::upload.assets.create' },\n    { action: 'plugins::upload.assets.update', conditions },\n    { action: 'plugins::upload.assets.download' },\n    { action: 'plugins::upload.assets.copy-link' },\n  ].map(createPermission);\n};\n\n/** Display a warning if the role superAdmin doesn't exist\n *  or if the role is not assigned to at least one user\n * @returns {Promise<>}\n */\nconst displayWarningIfNoSuperAdmin = async () => {\n  const superAdminRole = await getSuperAdminWithUsersCount();\n  const someUsersExists = await strapi.admin.services.user.exists();\n  if (!superAdminRole) {\n    strapi.log.warn(\"Your application doesn't have a super admin role.\");\n  } else if (someUsersExists && superAdminRole.usersCount === 0) {\n    strapi.log.warn(\"Your application doesn't have a super admin user.\");\n  }\n};\n\n/**\n * Assign permissions to a role\n * @param {string|int} roleId - role ID\n * @param {Array<Permission{action,subject,fields,conditions}>} permissions - permissions to assign to the role\n */\nconst assignPermissions = async (roleId, permissions = []) => {\n  try {\n    await validatePermissionsExist(permissions);\n  } catch (err) {\n    throw strapi.errors.badRequest('ValidationError', err);\n  }\n\n  const superAdmin = await strapi.admin.services.role.getSuperAdmin();\n  const isSuperAdmin = superAdmin && superAdmin.id === roleId;\n\n  const permissionsWithRole = permissions.map(permission =>\n    createPermission({\n      ...permission,\n      conditions: strapi.admin.services.condition.removeUnkownConditionIds(permission.conditions),\n      role: roleId,\n    })\n  );\n\n  const existingPermissions = await strapi.admin.services.permission.find({\n    role: roleId,\n    _limit: -1,\n  });\n  const permissionsToAdd = _.differenceWith(\n    permissionsWithRole,\n    existingPermissions,\n    arePermissionsEqual\n  );\n  const permissionsToDelete = _.differenceWith(\n    existingPermissions,\n    permissionsWithRole,\n    arePermissionsEqual\n  );\n  const permissionsToReturn = _.differenceBy(existingPermissions, permissionsToDelete, 'id');\n\n  if (permissionsToDelete.length > 0) {\n    await strapi.admin.services.permission.deleteByIds(permissionsToDelete.map(p => p.id));\n  }\n\n  if (permissionsToAdd.length > 0) {\n    const createdPermissions = await addPermissions(roleId, permissionsToAdd);\n    permissionsToReturn.push(...createdPermissions.map(p => ({ ...p, role: p.role.id })));\n  }\n\n  if (!isSuperAdmin && (permissionsToAdd.length || permissionsToDelete.length)) {\n    await strapi.admin.services.metrics.sendDidUpdateRolePermissions();\n  }\n\n  return permissionsToReturn;\n};\n\nconst addPermissions = async (roleId, permissions) => {\n  const permissionsWithRole = permissions.map(set('role', roleId));\n\n  return strapi.admin.services.permission.createMany(permissionsWithRole);\n};\n\n/**\n * Reset super admin permissions (giving it all permissions)\n * @returns {Promise<>}\n */\nconst resetSuperAdminPermissions = async () => {\n  const superAdminRole = await strapi.admin.services.role.getSuperAdmin();\n  if (!superAdminRole) {\n    return;\n  }\n\n  const allActions = strapi.admin.services.permission.actionProvider.getAll();\n  const contentTypesActions = allActions.filter(a => a.section === 'contentTypes');\n\n  const permissions = strapi.admin.services['content-type'].getPermissionsWithNestedFields(\n    contentTypesActions\n  );\n\n  const otherActions = allActions.filter(a => a.section !== 'contentTypes');\n  otherActions.forEach(action => {\n    if (action.subjects) {\n      const newPerms = action.subjects.map(subject =>\n        createPermission({ action: action.actionId, subject })\n      );\n      permissions.push(...newPerms);\n    } else {\n      permissions.push(createPermission({ action: action.actionId }));\n    }\n  });\n\n  await assignPermissions(superAdminRole.id, permissions);\n};\n\nmodule.exports = {\n  sanitizeRole,\n  create,\n  findOne,\n  findOneWithUsersCount,\n  find,\n  findAllWithUsersCount,\n  update,\n  exists,\n  count,\n  deleteByIds,\n  getUsersCount,\n  getSuperAdmin,\n  getSuperAdminWithUsersCount,\n  createRolesIfNoneExist,\n  displayWarningIfNoSuperAdmin,\n  addPermissions,\n  assignPermissions,\n  resetSuperAdminPermissions,\n};\n",
    "node_modules/jest-jasmine2/build/index.js": "'use strict';\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _sourceMap = require('@jest/source-map');\n\nvar _each = _interopRequireDefault(require('./each'));\n\nvar _errorOnPrivate = require('./errorOnPrivate');\n\nvar _jasmineAsyncInstall = _interopRequireDefault(\n  require('./jasmineAsyncInstall')\n);\n\nvar _reporter = _interopRequireDefault(require('./reporter'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst JASMINE = require.resolve('./jasmine/jasmineLight');\n\nconst jestEachBuildDir = path.dirname(require.resolve('jest-each'));\n\nasync function jasmine2(globalConfig, config, environment, runtime, testPath) {\n  var _runtime$unstable_sho2;\n\n  const reporter = new _reporter.default(globalConfig, config, testPath);\n  const jasmineFactory = runtime.requireInternalModule(JASMINE);\n  const jasmine = jasmineFactory.create({\n    process,\n    testPath,\n    testTimeout: globalConfig.testTimeout\n  });\n  const env = jasmine.getEnv();\n\n  const jasmineInterface = jasmineFactory._interface(jasmine, env);\n\n  Object.assign(environment.global, jasmineInterface);\n  env.addReporter(jasmineInterface.jsApiReporter); // TODO: Remove config option if V8 exposes some way of getting location of caller\n  // in a future version\n\n  if (config.testLocationInResults === true) {\n    function wrapIt(original) {\n      const wrapped = (testName, fn, timeout) => {\n        var _stack$getFileName;\n\n        const sourcemaps = runtime.getSourceMaps();\n        let stack = (0, _sourceMap.getCallsite)(1, sourcemaps);\n        const it = original(testName, fn, timeout);\n\n        if (\n          (_stack$getFileName = stack.getFileName()) === null ||\n          _stack$getFileName === void 0\n            ? void 0\n            : _stack$getFileName.startsWith(jestEachBuildDir)\n        ) {\n          stack = (0, _sourceMap.getCallsite)(4, sourcemaps);\n        } // @ts-expect-error\n\n        it.result.__callsite = stack;\n        return it;\n      };\n\n      return wrapped;\n    }\n\n    environment.global.it = wrapIt(environment.global.it);\n    environment.global.xit = wrapIt(environment.global.xit);\n    environment.global.fit = wrapIt(environment.global.fit);\n  }\n\n  (0, _jasmineAsyncInstall.default)(globalConfig, environment.global);\n  (0, _each.default)(environment);\n  environment.global.test = environment.global.it;\n  environment.global.it.only = environment.global.fit;\n  environment.global.it.todo = env.todo;\n  environment.global.it.skip = environment.global.xit;\n  environment.global.xtest = environment.global.xit;\n  environment.global.describe.skip = environment.global.xdescribe;\n  environment.global.describe.only = environment.global.fdescribe;\n\n  if (config.timers === 'fake' || config.timers === 'legacy') {\n    environment.fakeTimers.useFakeTimers();\n  } else if (config.timers === 'modern') {\n    environment.fakeTimersModern.useFakeTimers();\n  }\n\n  env.beforeEach(() => {\n    if (config.resetModules) {\n      runtime.resetModules();\n    }\n\n    if (config.clearMocks) {\n      runtime.clearAllMocks();\n    }\n\n    if (config.resetMocks) {\n      runtime.resetAllMocks();\n\n      if (config.timers === 'fake' || config.timers === 'legacy') {\n        environment.fakeTimers.useFakeTimers();\n      }\n    }\n\n    if (config.restoreMocks) {\n      runtime.restoreAllMocks();\n    }\n  });\n  env.addReporter(reporter);\n  runtime\n    .requireInternalModule(path.resolve(__dirname, './jestExpect.js'))\n    .default({\n      expand: globalConfig.expand\n    });\n\n  if (globalConfig.errorOnDeprecated) {\n    (0, _errorOnPrivate.installErrorOnPrivate)(environment.global);\n  } else {\n    Object.defineProperty(jasmine, 'DEFAULT_TIMEOUT_INTERVAL', {\n      configurable: true,\n      enumerable: true,\n\n      get() {\n        return this._DEFAULT_TIMEOUT_INTERVAL;\n      },\n\n      set(value) {\n        this._DEFAULT_TIMEOUT_INTERVAL = value;\n      }\n    });\n  }\n\n  const snapshotState = runtime\n    .requireInternalModule(path.resolve(__dirname, './setup_jest_globals.js'))\n    .default({\n      config,\n      globalConfig,\n      localRequire: runtime.requireModule.bind(runtime),\n      testPath\n    });\n\n  for (const path of config.setupFilesAfterEnv) {\n    var _runtime$unstable_sho;\n\n    // TODO: remove ? in Jest 26\n    const esm =\n      (_runtime$unstable_sho = runtime.unstable_shouldLoadAsEsm) === null ||\n      _runtime$unstable_sho === void 0\n        ? void 0\n        : _runtime$unstable_sho.call(runtime, path);\n\n    if (esm) {\n      await runtime.unstable_importModule(path);\n    } else {\n      runtime.requireModule(path);\n    }\n  }\n\n  if (globalConfig.enabledTestsMap) {\n    env.specFilter = spec => {\n      const suiteMap =\n        globalConfig.enabledTestsMap &&\n        globalConfig.enabledTestsMap[spec.result.testPath];\n      return (suiteMap && suiteMap[spec.result.fullName]) || false;\n    };\n  } else if (globalConfig.testNamePattern) {\n    const testNameRegex = new RegExp(globalConfig.testNamePattern, 'i');\n\n    env.specFilter = spec => testNameRegex.test(spec.getFullName());\n  } // TODO: remove ? in Jest 26\n\n  const esm =\n    (_runtime$unstable_sho2 = runtime.unstable_shouldLoadAsEsm) === null ||\n    _runtime$unstable_sho2 === void 0\n      ? void 0\n      : _runtime$unstable_sho2.call(runtime, testPath);\n\n  if (esm) {\n    await runtime.unstable_importModule(testPath);\n  } else {\n    runtime.requireModule(testPath);\n  }\n\n  await env.execute();\n  const results = await reporter.getResults();\n  return addSnapshotData(results, snapshotState);\n}\n\nconst addSnapshotData = (results, snapshotState) => {\n  results.testResults.forEach(({fullName, status}) => {\n    if (status === 'pending' || status === 'failed') {\n      // if test is skipped or failed, we don't want to mark\n      // its snapshots as obsolete.\n      snapshotState.markSnapshotsAsCheckedForTest(fullName);\n    }\n  });\n  const uncheckedCount = snapshotState.getUncheckedCount();\n  const uncheckedKeys = snapshotState.getUncheckedKeys();\n\n  if (uncheckedCount) {\n    snapshotState.removeUncheckedKeys();\n  }\n\n  const status = snapshotState.save();\n  results.snapshot.fileDeleted = status.deleted;\n  results.snapshot.added = snapshotState.added;\n  results.snapshot.matched = snapshotState.matched;\n  results.snapshot.unmatched = snapshotState.unmatched;\n  results.snapshot.updated = snapshotState.updated;\n  results.snapshot.unchecked = !status.deleted ? uncheckedCount : 0; // Copy the array to prevent memory leaks\n\n  results.snapshot.uncheckedKeys = Array.from(uncheckedKeys);\n  return results;\n};\n\nmodule.exports = jasmine2;\n",
    "packages/strapi/bin/strapi.js": "#!/usr/bin/env node\n'use strict';\n\nconst _ = require('lodash');\nconst resolveCwd = require('resolve-cwd');\nconst { yellow } = require('chalk');\nconst { Command } = require('commander');\n\nconst program = new Command();\n\nconst packageJSON = require('../package.json');\n\nconst checkCwdIsStrapiApp = name => {\n  let logErrorAndExit = () => {\n    console.log(\n      `You need to run ${yellow(\n        `strapi ${name}`\n      )} in a Strapi project. Make sure you are in the right directory`\n    );\n    process.exit(1);\n  };\n\n  try {\n    const pkgJSON = require(process.cwd() + '/package.json');\n    if (!_.has(pkgJSON, 'dependencies.strapi')) {\n      logErrorAndExit(name);\n    }\n  } catch (err) {\n    logErrorAndExit(name);\n  }\n};\n\nconst getLocalScript = name => (...args) => {\n  checkCwdIsStrapiApp(name);\n\n  const cmdPath = resolveCwd.silent(`strapi/lib/commands/${name}`);\n  if (!cmdPath) {\n    console.log(\n      `Error loading the local ${yellow(\n        name\n      )} command. Strapi might not be installed in your \"node_modules\". You may need to run \"npm install\"`\n    );\n    process.exit(1);\n  }\n\n  const script = require(cmdPath);\n\n  Promise.resolve()\n    .then(() => {\n      return script(...args);\n    })\n    .catch(error => {\n      console.error(`Error while running command ${name}: ${error.message || error}`);\n      process.exit(1);\n    });\n};\n\n// Initial program setup\nprogram\n  .storeOptionsAsProperties(false)\n  .passCommandToAction(false)\n  .allowUnknownOption(true);\n\nprogram.helpOption('-h, --help', 'Display help for command');\nprogram.addHelpCommand('help [command]', 'Display help for command');\n\n// `$ strapi version` (--version synonym)\nprogram.version(packageJSON.version, '-v, --version', 'Output the version number');\nprogram\n  .command('version')\n  .description('Output your version of Strapi')\n  .action(() => {\n    process.stdout.write(packageJSON.version + '\\n');\n    process.exit(0);\n  });\n\n// `$ strapi console`\nprogram\n  .command('console')\n  .description('Open the Strapi framework console')\n  .action(getLocalScript('console'));\n\n// `$ strapi new`\nprogram\n  .command('new <directory>')\n  .option('--no-run', 'Do not start the application after it is created')\n  .option('--use-npm', 'Force usage of npm instead of yarn to create the project')\n  .option('--debug', 'Display database connection error')\n  .option('--quickstart', 'Quickstart app creation')\n  .option('--dbclient <dbclient>', 'Database client')\n  .option('--dbhost <dbhost>', 'Database host')\n  .option('--dbsrv <dbsrv>', 'Database srv')\n  .option('--dbport <dbport>', 'Database port')\n  .option('--dbname <dbname>', 'Database name')\n  .option('--dbusername <dbusername>', 'Database username')\n  .option('--dbpassword <dbpassword>', 'Database password')\n  .option('--dbssl <dbssl>', 'Database SSL')\n  .option('--dbauth <dbauth>', 'Authentication Database')\n  .option('--dbfile <dbfile>', 'Database file path for sqlite')\n  .option('--dbforce', 'Overwrite database content if any')\n  .description('Create a new application')\n  .action(require('../lib/commands/new'));\n\n// `$ strapi start`\nprogram\n  .command('start')\n  .description('Start your Strapi application')\n  .action(getLocalScript('start'));\n\n// `$ strapi develop`\nprogram\n  .command('develop')\n  .alias('dev')\n  .option('--no-build', 'Disable build')\n  .option('--watch-admin', 'Enable watch', false)\n  .option('--browser <name>', 'Open the browser', true)\n  .description('Start your Strapi application in development mode')\n  .action(getLocalScript('develop'));\n\n// `$ strapi generate:api`\nprogram\n  .command('generate:api <id> [attributes...]')\n  .option('-a, --api <api>', 'API name to generate the files in')\n  .option('-p, --plugin <api>', 'Name of the local plugin')\n  .option('-e, --extend <api>', 'Name of the plugin to extend')\n  .option('-c, --connection <connection>', 'The name of the connection to use')\n  .option('--draft-and-publish', 'Enable draft/publish', false)\n  .description('Generate a basic API')\n  .action((id, attributes, cliArguments) => {\n    cliArguments.attributes = attributes;\n    getLocalScript('generate')(id, cliArguments);\n  });\n\n// `$ strapi generate:controller`\nprogram\n  .command('generate:controller <id>')\n  .option('-a, --api <api>', 'API name to generate the files in')\n  .option('-p, --plugin <api>', 'Name of the local plugin')\n  .option('-e, --extend <api>', 'Name of the plugin to extend')\n  .description('Generate a controller for an API')\n  .action(getLocalScript('generate'));\n\n// `$ strapi generate:model`\nprogram\n  .command('generate:model <id> [attributes...]')\n  .option('-a, --api <api>', 'API name to generate a sub API')\n  .option('-p, --plugin <api>', 'plugin name')\n  .option('-c, --connection <connection>', 'The name of the connection to use')\n  .option('--draft-and-publish', 'Enable draft/publish', false)\n  .description('Generate a model for an API')\n  .action((id, attributes, cliArguments) => {\n    cliArguments.attributes = attributes;\n    getLocalScript('generate')(id, cliArguments);\n  });\n\n// `$ strapi generate:policy`\nprogram\n  .command('generate:policy <id>')\n  .option('-a, --api <api>', 'API name')\n  .option('-p, --plugin <api>', 'plugin name')\n  .description('Generate a policy for an API')\n  .action(getLocalScript('generate'));\n\n// `$ strapi generate:service`\nprogram\n  .command('generate:service <id>')\n  .option('-a, --api <api>', 'API name')\n  .option('-p, --plugin <api>', 'plugin name')\n  .option('-t, --tpl <template>', 'template name')\n  .description('Generate a service for an API')\n  .action(getLocalScript('generate'));\n\n// `$ strapi generate:plugin`\nprogram\n  .command('generate:plugin <id>')\n  .option('-n, --name <name>', 'Plugin name')\n  .description('Generate a basic plugin')\n  .action(getLocalScript('generate'));\n\nprogram\n  .command('build')\n  .option('--clean', 'Remove the build and .cache folders', false)\n  .option('--no-optimization', 'Build the Administration without assets optimization')\n  .description('Builds the strapi admin app')\n  .action(getLocalScript('build'));\n\n// `$ strapi install`\nprogram\n  .command('install [plugins...]')\n  .description('Install a Strapi plugin')\n  .action(getLocalScript('install'));\n\n// `$ strapi uninstall`\nprogram\n  .command('uninstall [plugins...]')\n  .description('Uninstall a Strapi plugin')\n  .option('-d, --delete-files', 'Delete files', false)\n  .action(getLocalScript('uninstall'));\n\n//   `$ strapi watch-admin`\nprogram\n  .command('watch-admin')\n  .option('--browser <name>', 'Open the browser', true)\n  .description('Starts the admin dev server')\n  .action(getLocalScript('watchAdmin'));\n\nprogram\n  .command('configuration:dump')\n  .alias('config:dump')\n  .description('Dump configurations of your application')\n  .option('-f, --file <file>', 'Output file, default output is stdout')\n  .option('-p, --pretty', 'Format the output JSON with indentation and line breaks', false)\n  .action(getLocalScript('configurationDump'));\n\nprogram\n  .command('configuration:restore')\n  .alias('config:restore')\n  .description('Restore configurations of your application')\n  .option('-f, --file <file>', 'Input file, default input is stdin')\n  .option('-s, --strategy <strategy>', 'Strategy name, one of: \"replace\", \"merge\", \"keep\"')\n  .action(getLocalScript('configurationRestore'));\n\n// Admin\nprogram\n  .command('admin:reset-user-password')\n  .alias('admin:reset-password')\n  .description(\"Reset an admin user's password\")\n  .option('-e, --email <email>', 'The user email')\n  .option('-p, --password <password>', 'New password for the user')\n  .action(getLocalScript('admin-reset'));\n\nprogram.parseAsync(process.argv);\n",
    "packages/strapi/lib/hooks/index.js": "'use strict';\n\nconst { uniq, difference, get, isUndefined, merge } = require('lodash');\n\nmodule.exports = async function() {\n  /** Utils */\n\n  const hookConfig = this.config.hook;\n\n  // check if a hook exists\n  const hookExists = key => {\n    return !isUndefined(this.hook[key]);\n  };\n\n  // check if a hook is enabled\n  const hookEnabled = key => get(hookConfig, ['settings', key, 'enabled'], false) === true;\n\n  // list of enabled hooks\n  const enableddHook = Object.keys(this.hook).filter(hookEnabled);\n\n  // Method to initialize hooks and emit an event.\n  const initialize = hookKey => {\n    if (this.hook[hookKey].loaded === true) return;\n\n    const module = this.hook[hookKey].load;\n    const hookTimeout = get(hookConfig, ['settings', hookKey, 'timeout'], hookConfig.timeout);\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(\n        () => reject(`(hook: ${hookKey}) is taking too long to load.`),\n        hookTimeout || 1000\n      );\n\n      this.hook[hookKey] = merge(this.hook[hookKey], module);\n\n      Promise.resolve()\n        .then(() => module.initialize())\n        .then(() => {\n          clearTimeout(timeout);\n          this.hook[hookKey].loaded = true;\n          resolve();\n        })\n        .catch(err => {\n          clearTimeout(timeout);\n\n          if (err) {\n            return reject(err);\n          }\n        });\n    });\n  };\n\n  /**\n   * Run init functions\n   */\n\n  // Run beforeInitialize of every hook\n  await Promise.all(\n    enableddHook.map(key => {\n      const { beforeInitialize } = this.hook[key].load;\n      if (typeof beforeInitialize === 'function') {\n        return beforeInitialize();\n      }\n    })\n  );\n\n  // run the initialization of an array of hooks sequentially\n  const initdHookSeq = async hookArr => {\n    for (let key of uniq(hookArr)) {\n      await initialize(key);\n    }\n  };\n\n  const hooksBefore = get(hookConfig, 'load.before', [])\n    .filter(hookExists)\n    .filter(hookEnabled);\n\n  const hooksAfter = get(hookConfig, 'load.after', [])\n    .filter(hookExists)\n    .filter(hookEnabled);\n\n  const hooksOrder = get(hookConfig, 'load.order', [])\n    .filter(hookExists)\n    .filter(hookEnabled);\n\n  const unspecifieddHook = difference(enableddHook, hooksBefore, hooksOrder, hooksAfter);\n\n  // before\n  await initdHookSeq(hooksBefore);\n\n  // ordered // rest of hooks\n  await initdHookSeq(hooksOrder);\n  await initdHookSeq(unspecifieddHook);\n\n  // after\n  await initdHookSeq(hooksAfter);\n};\n",
    "packages/strapi/lib/middlewares/index.js": "'use strict';\n\nconst { uniq, difference, get, isUndefined, merge } = require('lodash');\n\nconst requiredMiddlewares = [\n  'responses',\n  'router',\n  'logger',\n  'boom',\n  'cors',\n  'cron',\n  'xframe',\n  'xss',\n  'public',\n  'favicon',\n];\n\nmodule.exports = async function() {\n  /** Utils */\n  const middlewareConfig = this.config.middleware;\n\n  // check if a middleware exists\n  const middlewareExists = key => {\n    return !isUndefined(this.middleware[key]);\n  };\n\n  // check if a middleware is enabled\n  const middlewareEnabled = key => {\n    return (\n      requiredMiddlewares.includes(key) ||\n      get(middlewareConfig, ['settings', key, 'enabled'], false) === true\n    );\n  };\n\n  // list of enabled middlewares\n  const enabledMiddlewares = Object.keys(this.middleware).filter(middlewareEnabled);\n\n  // Method to initialize middlewares and emit an event.\n  const initialize = middlewareKey => {\n    if (this.middleware[middlewareKey].loaded === true) return;\n\n    const module = this.middleware[middlewareKey].load;\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(\n        () => reject(`(middleware: ${middlewareKey}) is taking too long to load.`),\n        middlewareConfig.timeout || 1000\n      );\n\n      this.middleware[middlewareKey] = merge(this.middleware[middlewareKey], module);\n\n      Promise.resolve()\n        .then(() => module.initialize())\n        .then(() => {\n          clearTimeout(timeout);\n          this.middleware[middlewareKey].loaded = true;\n          resolve();\n        })\n        .catch(err => {\n          clearTimeout(timeout);\n\n          if (err) {\n            return reject(err);\n          }\n        });\n    });\n  };\n\n  /**\n   * Run init functions\n   */\n\n  // Run beforeInitialize of every middleware\n  await Promise.all(\n    enabledMiddlewares.map(key => {\n      const { beforeInitialize } = this.middleware[key].load;\n      if (typeof beforeInitialize === 'function') {\n        return beforeInitialize();\n      }\n    })\n  );\n\n  // run the initialization of an array of middlewares sequentially\n  const initMiddlewaresSeq = async middlewareArr => {\n    for (let key of uniq(middlewareArr)) {\n      await initialize(key);\n    }\n  };\n\n  const middlewaresBefore = get(middlewareConfig, 'load.before', [])\n    .filter(middlewareExists)\n    .filter(middlewareEnabled);\n\n  const middlewaresAfter = get(middlewareConfig, 'load.after', [])\n    .filter(middlewareExists)\n    .filter(middlewareEnabled);\n\n  const middlewaresOrder = get(middlewareConfig, 'load.order', [])\n    .filter(middlewareExists)\n    .filter(middlewareEnabled);\n\n  const unspecifiedMiddlewares = difference(\n    enabledMiddlewares,\n    middlewaresBefore,\n    middlewaresOrder,\n    middlewaresAfter\n  );\n\n  // before\n  await initMiddlewaresSeq(middlewaresBefore);\n\n  // ordered // rest of middlewares\n  await Promise.all([\n    initMiddlewaresSeq(middlewaresOrder),\n    Promise.all(unspecifiedMiddlewares.map(initialize)),\n  ]);\n\n  // after\n  await initMiddlewaresSeq(middlewaresAfter);\n};\n",
    "packages/strapi-admin/ee/admin/containers/Roles/CreatePage/index.js": "import React, { useState, useRef } from 'react';\nimport { Header } from '@buffetjs/custom';\nimport { Padded } from '@buffetjs/core';\nimport moment from 'moment';\nimport { Formik } from 'formik';\nimport { get, isEmpty } from 'lodash';\nimport { useIntl } from 'react-intl';\nimport {\n  BaselineAlignment,\n  CheckPagePermissions,\n  request,\n  useGlobalContext,\n} from 'strapi-helper-plugin';\nimport { useHistory, useRouteMatch } from 'react-router-dom';\nimport adminPermissions from '../../../../../admin/src/permissions';\nimport { useFetchPermissionsLayout, useFetchRole } from '../../../../../admin/src/hooks';\nimport PageTitle from '../../../../../admin/src/components/SettingsPageTitle';\nimport ContainerFluid from '../../../../../admin/src/components/ContainerFluid';\nimport FormCard from '../../../../../admin/src/components/FormBloc';\nimport { ButtonWithNumber, Permissions } from '../../../../../admin/src/components/Roles';\nimport SizedInput from '../../../../../admin/src/components/SizedInput';\nimport { formatPermissionsToApi } from '../../../../../admin/src/utils';\n\nimport schema from './utils/schema';\n\nconst CreatePage = () => {\n  const { formatMessage } = useIntl();\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const { replace } = useHistory();\n  const permissionsRef = useRef();\n  const { emitEvent, settingsBaseURL } = useGlobalContext();\n  const params = useRouteMatch(`${settingsBaseURL}/roles/duplicate/:id`);\n  const id = get(params, 'params.id', null);\n  const { isLoading: isLayoutLoading, data: permissionsLayout } = useFetchPermissionsLayout();\n  const { role, permissions: rolePermissions, isLoading: isRoleLoading } = useFetchRole(id);\n\n  const headerActions = (handleSubmit, handleReset) => [\n    {\n      label: formatMessage({\n        id: 'app.components.Button.reset',\n        defaultMessage: 'Reset',\n      }),\n      onClick: () => {\n        handleReset();\n        permissionsRef.current.resetForm();\n      },\n      color: 'cancel',\n      type: 'button',\n    },\n    {\n      label: formatMessage({\n        id: 'app.components.Button.save',\n        defaultMessage: 'Save',\n      }),\n      onClick: handleSubmit,\n      color: 'success',\n      type: 'submit',\n      isLoading: isSubmiting,\n    },\n  ];\n\n  const handleCreateRoleSubmit = data => {\n    strapi.lockAppWithOverlay();\n    setIsSubmiting(true);\n\n    if (id) {\n      emitEvent('willDuplicateRole');\n    } else {\n      emitEvent('willCreateNewRole');\n    }\n\n    Promise.resolve(\n      request('/admin/roles', {\n        method: 'POST',\n        body: data,\n      })\n    )\n      .then(async res => {\n        const permissionsToSend = permissionsRef.current.getPermissions();\n\n        if (id) {\n          emitEvent('didDuplicateRole');\n        } else {\n          emitEvent('didCreateNewRole');\n        }\n\n        if (res.data.id && !isEmpty(permissionsToSend)) {\n          await request(`/admin/roles/${res.data.id}/permissions`, {\n            method: 'PUT',\n            body: { permissions: formatPermissionsToApi(permissionsToSend) },\n          });\n        }\n\n        return res;\n      })\n      .then(res => {\n        setIsSubmiting(false);\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: 'Settings.roles.created' },\n        });\n        replace(`${settingsBaseURL}/roles/${res.data.id}`);\n      })\n      .catch(err => {\n        console.error(err);\n        setIsSubmiting(false);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      })\n      .finally(() => {\n        strapi.unlockApp();\n      });\n  };\n\n  const actions = [\n    <ButtonWithNumber number={0} onClick={() => console.log('Open user modal')} key=\"user-button\">\n      {formatMessage({\n        id: 'Settings.roles.form.button.users-with-role',\n        defaultMessage: 'Users with this role',\n      })}\n    </ButtonWithNumber>,\n  ];\n\n  const defaultDescription = `${formatMessage({\n    id: 'Settings.roles.form.created',\n  })} ${moment().format('LL')}`;\n\n  return (\n    <>\n      <PageTitle name=\"Roles\" />\n      <Formik\n        initialValues={{ name: '', description: defaultDescription }}\n        onSubmit={handleCreateRoleSubmit}\n        validationSchema={schema}\n        validateOnChange={false}\n      >\n        {({ handleSubmit, values, errors, handleReset, handleChange, handleBlur }) => (\n          <form onSubmit={handleSubmit}>\n            <ContainerFluid padding=\"0\">\n              <Header\n                title={{\n                  label: formatMessage({\n                    id: 'Settings.roles.create.title',\n                    defaultMessage: 'Create a role',\n                  }),\n                }}\n                content={formatMessage({\n                  id: 'Settings.roles.create.description',\n                  defaultMessage: 'Define the rights given to the role',\n                })}\n                actions={headerActions(handleSubmit, handleReset)}\n                isLoading={isLayoutLoading}\n              />\n              <BaselineAlignment top size=\"3px\" />\n              <FormCard\n                actions={actions}\n                title={formatMessage({\n                  id: 'Settings.roles.form.title',\n                  defaultMessage: 'Details',\n                })}\n                subtitle={formatMessage({\n                  id: 'Settings.roles.form.description',\n                  defaultMessage: 'Name and description of the role',\n                })}\n              >\n                <SizedInput\n                  label=\"Settings.roles.form.input.name\"\n                  defaultMessage=\"Name\"\n                  name=\"name\"\n                  type=\"text\"\n                  error={errors.name ? { id: errors.name } : null}\n                  onBlur={handleBlur}\n                  value={values.name}\n                  onChange={handleChange}\n                />\n\n                <SizedInput\n                  label=\"Settings.roles.form.input.description\"\n                  defaultMessage=\"Description\"\n                  name=\"description\"\n                  type=\"textarea\"\n                  onBlur={handleBlur}\n                  value={values.description}\n                  onChange={handleChange}\n                  // Override the default height of the textarea\n                  style={{ height: 115 }}\n                />\n              </FormCard>\n              {!isLayoutLoading && !isRoleLoading && (\n                <Padded top bottom size=\"md\">\n                  <Permissions\n                    permissionsLayout={permissionsLayout}\n                    ref={permissionsRef}\n                    rolePermissions={rolePermissions}\n                    role={role}\n                  />\n                </Padded>\n              )}\n            </ContainerFluid>\n          </form>\n        )}\n      </Formik>\n    </>\n  );\n};\n\nexport default () => (\n  <CheckPagePermissions permissions={adminPermissions.settings.roles.create}>\n    <CreatePage />\n  </CheckPagePermissions>\n);\n\nexport { CreatePage };\n",
    "packages/strapi-admin/services/permission/engine.js": "'use strict';\n\nconst _ = require('lodash');\nconst { map, filter, each } = require('lodash/fp');\nconst { AbilityBuilder, Ability } = require('@casl/ability');\nconst sift = require('sift');\n\nconst allowedOperations = [\n  '$or',\n  '$eq',\n  '$ne',\n  '$in',\n  '$nin',\n  '$lt',\n  '$lte',\n  '$gt',\n  '$gte',\n  '$exists',\n  '$elemMatch',\n];\nconst operations = _.pick(sift, allowedOperations);\n\nconst conditionsMatcher = conditions => {\n  return sift.createQueryTester(conditions, { operations });\n};\n\nmodule.exports = conditionProvider => ({\n  /**\n   * Generate an ability based on the given user (using associated roles & permissions)\n   * @param user\n   * @param options\n   * @returns {Promise<Ability>}\n   */\n  async generateUserAbility(user, options) {\n    const permissions = await strapi.admin.services.permission.findUserPermissions(user);\n    const abilityCreator = this.generateAbilityCreatorFor(user);\n\n    return abilityCreator(permissions, options);\n  },\n\n  /**\n   * Create an ability factory for a specific user\n   * @param user\n   * @returns {function(*, *): Promise<Ability>}\n   */\n  generateAbilityCreatorFor(user) {\n    return async (permissions, options) => {\n      const { can, build } = new AbilityBuilder(Ability);\n      const registerFn = this.createRegisterFunction(can);\n\n      for (const permission of permissions) {\n        await this.evaluatePermission({ permission, user, options, registerFn });\n      }\n\n      return build({ conditionsMatcher });\n    };\n  },\n\n  /**\n   * Register new rules using `registerFn` based on valid permission's conditions\n   * @param permission\n   * @param user\n   * @param options\n   * @param registerFn\n   * @returns {Promise<void>}\n   */\n  async evaluatePermission({ permission, user, options, registerFn }) {\n    const { action, fields, conditions } = permission;\n    const subject = permission.subject || 'all';\n\n    // Permissions with empty fields array should be removed\n    if (Array.isArray(fields) && fields.length === 0) {\n      return;\n    }\n\n    // Directly registers the permission if there is no condition to check/evaluate\n    if (_.isUndefined(conditions) || _.isEmpty(conditions)) {\n      return registerFn({ action, subject, fields, condition: true });\n    }\n\n    // Replace each condition name by its associated value\n    const resolveConditions = map(conditionProvider.getById);\n\n    // Only keep the handler of each condition\n    const pickHandlers = map(_.property('handler'));\n\n    // Filter conditions, only keeps objects and functions\n    const filterValidConditions = filter(_.isObject);\n\n    // Evaluate the conditions if they're a function, returns the object otherwise\n    const evaluateConditions = conditions =>\n      Promise.all(conditions.map(cond => (_.isFunction(cond) ? cond(user, options) : cond)));\n\n    // Only keeps 'true' booleans or objects as condition's result\n    const filterValidResults = filter(result => result === true || _.isObject(result));\n\n    // Transform each result into registerFn options\n    const transformToRegisterOptions = map(result => ({\n      action,\n      subject,\n      fields,\n      condition: result,\n    }));\n\n    // Register each result using the registerFn\n    const registerResults = each(registerFn);\n\n    await Promise.resolve(conditions)\n      .then(resolveConditions)\n      .then(pickHandlers)\n      .then(filterValidConditions)\n      .then(evaluateConditions)\n      .then(filterValidResults)\n      .then(transformToRegisterOptions)\n      .then(registerResults);\n  },\n\n  /**\n   * Encapsulate a register function with custom params to fit `evaluatePermission`'s syntax\n   * @param can\n   * @returns {function({action?: *, subject?: *, fields?: *, condition?: *}): *}\n   */\n  createRegisterFunction(can) {\n    return ({ action, subject, fields, condition }) => {\n      return can(action, subject, fields, _.isObject(condition) ? condition : undefined);\n    };\n  },\n\n  /**\n   * Check many permissions based on an ability\n   */\n  checkMany: _.curry((ability, permissions) => {\n    return permissions.map(({ action, subject, field }) => ability.can(action, subject, field));\n  }),\n});\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/CreatePage/index.js": "import React, { useState, useRef } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { Header } from '@buffetjs/custom';\nimport { Padded } from '@buffetjs/core';\nimport { Formik } from 'formik';\nimport { useIntl } from 'react-intl';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\nimport BaselineAlignement from '../../../components/BaselineAlignement';\nimport ContainerFluid from '../../../components/ContainerFluid';\nimport FormCard from '../../../components/FormBloc';\nimport SizedInput from '../../../components/SizedInput';\nimport getTrad from '../../../utils/getTrad';\nimport pluginId from '../../../pluginId';\nimport UsersPermissions from '../../../components/UsersPermissions';\nimport { usePlugins } from '../../../hooks';\nimport schema from './utils/schema';\n\nconst CreatePage = () => {\n  const { formatMessage } = useIntl();\n  const { emitEvent } = useGlobalContext();\n  const { goBack } = useHistory();\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const { permissions, routes, policies, isLoading } = usePlugins();\n  const permissionsRef = useRef();\n\n  const headerActions = (handleSubmit, handleReset) => {\n    if (isLoading) {\n      return [];\n    }\n\n    return [\n      {\n        label: formatMessage({\n          id: getTrad('app.components.Button.reset'),\n          defaultMessage: 'Reset',\n        }),\n        onClick: () => {\n          handleReset();\n          permissionsRef.current.resetForm();\n        },\n        color: 'cancel',\n        type: 'button',\n      },\n      {\n        label: formatMessage({\n          id: getTrad('app.components.Button.save'),\n          defaultMessage: 'Save',\n        }),\n        onClick: handleSubmit,\n        color: 'success',\n        type: 'submit',\n        isLoading: isSubmiting,\n      },\n    ];\n  };\n\n  const handleCreateRoleSubmit = data => {\n    strapi.lockAppWithOverlay();\n    setIsSubmiting(true);\n\n    const permissions = permissionsRef.current.getPermissions();\n\n    Promise.resolve(\n      request(`/${pluginId}/roles`, {\n        method: 'POST',\n        body: { ...data, ...permissions, users: [] },\n      })\n    )\n      .then(() => {\n        emitEvent('didCreateRole');\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: 'Settings.roles.created' },\n        });\n        // Forcing redirecting since we don't have the id in the response\n        // TODO\n        goBack();\n      })\n      .catch(err => {\n        console.error(err);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      })\n      .finally(() => {\n        setIsSubmiting(false);\n        strapi.unlockApp();\n      });\n  };\n\n  return (\n    <Formik\n      initialValues={{ name: '', description: '' }}\n      onSubmit={handleCreateRoleSubmit}\n      validationSchema={schema}\n    >\n      {({ handleSubmit, values, errors, handleReset, handleChange, handleBlur, touched }) => {\n        return (\n          <form onSubmit={handleSubmit}>\n            <ContainerFluid padding=\"0\">\n              <Header\n                title={{\n                  label: formatMessage({\n                    id: getTrad('Settings.roles.create.title'),\n                    defaultMessage: 'Create a role',\n                  }),\n                }}\n                content={formatMessage({\n                  id: getTrad('Settings.roles.create.description'),\n                  defaultMessage: 'Define the rights given to the role',\n                })}\n                actions={headerActions(handleSubmit, handleReset)}\n                isLoading={isLoading}\n              />\n              <BaselineAlignement top size=\"3px\" />\n              <FormCard\n                isLoading={isLoading}\n                title={formatMessage({\n                  id: getTrad('EditPage.form.roles'),\n                  defaultMessage: 'Role details',\n                })}\n              >\n                <SizedInput\n                  label=\"Settings.roles.form.input.name\"\n                  defaultMessage=\"Name\"\n                  name=\"name\"\n                  type=\"text\"\n                  error={errors.name && touched.name ? { id: errors.name } : null}\n                  onBlur={handleBlur}\n                  value={values.name}\n                  onChange={handleChange}\n                />\n                <SizedInput\n                  label=\"Settings.roles.form.input.description\"\n                  defaultMessage=\"Description\"\n                  name=\"description\"\n                  type=\"textarea\"\n                  error={\n                    errors.description && touched.description ? { id: errors.description } : null\n                  }\n                  onBlur={handleBlur}\n                  value={values.description}\n                  onChange={handleChange}\n                  // Override the default height of the textarea\n                  style={{ height: 115 }}\n                />\n              </FormCard>\n            </ContainerFluid>\n            <div style={{ paddingTop: '1.8rem' }} />\n            {!isLoading && (\n              <UsersPermissions\n                ref={permissionsRef}\n                permissions={permissions}\n                routes={routes}\n                policies={policies}\n              />\n            )}\n            <Padded top size=\"md\" />\n          </form>\n        );\n      }}\n    </Formik>\n  );\n};\n\nexport default CreatePage;\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/EditPage/index.js": "import React, { useState, useRef } from 'react';\nimport { Header } from '@buffetjs/custom';\nimport { Padded } from '@buffetjs/core';\nimport { Formik } from 'formik';\nimport { useIntl } from 'react-intl';\nimport { useRouteMatch } from 'react-router-dom';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\n\nimport BaselineAlignement from '../../../components/BaselineAlignement';\nimport ContainerFluid from '../../../components/ContainerFluid';\nimport FormCard from '../../../components/FormBloc';\nimport SizedInput from '../../../components/SizedInput';\nimport getTrad from '../../../utils/getTrad';\nimport pluginId from '../../../pluginId';\nimport UsersPermissions from '../../../components/UsersPermissions';\nimport { usePlugins, useFetchRole } from '../../../hooks';\n\nimport schema from './utils/schema';\n\nconst EditPage = () => {\n  const { formatMessage } = useIntl();\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const { settingsBaseURL } = useGlobalContext();\n  const {\n    params: { id },\n  } = useRouteMatch(`${settingsBaseURL}/${pluginId}/roles/:id`);\n  const { routes, policies, isLoading } = usePlugins();\n  const { role, isLoading: isRoleLoading, onSubmitSucceeded } = useFetchRole(id);\n  const permissionsRef = useRef();\n\n  const headerActions = (handleSubmit, handleReset) => {\n    if (isLoading) {\n      return [];\n    }\n\n    return [\n      {\n        label: formatMessage({\n          id: getTrad('app.components.Button.reset'),\n          defaultMessage: 'Reset',\n        }),\n        onClick: () => {\n          handleReset();\n          permissionsRef.current.resetForm();\n        },\n        color: 'cancel',\n        type: 'button',\n      },\n      {\n        label: formatMessage({\n          id: getTrad('app.components.Button.save'),\n          defaultMessage: 'Save',\n        }),\n        onClick: handleSubmit,\n        color: 'success',\n        type: 'submit',\n        isLoading: isSubmiting,\n      },\n    ];\n  };\n\n  const handleCreateRoleSubmit = data => {\n    strapi.lockAppWithOverlay();\n    setIsSubmiting(true);\n\n    const permissions = permissionsRef.current.getPermissions();\n\n    Promise.resolve(\n      request(`/${pluginId}/roles/${id}`, {\n        method: 'PUT',\n        body: { ...data, ...permissions, users: [] },\n      })\n    )\n      .then(() => {\n        onSubmitSucceeded({ name: data.name, description: data.description });\n        permissionsRef.current.setFormAfterSubmit();\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('Settings.roles.edited') },\n        });\n      })\n      .catch(err => {\n        console.error(err);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      })\n      .finally(() => {\n        setIsSubmiting(false);\n        strapi.unlockApp();\n      });\n  };\n\n  return (\n    <Formik\n      enableReinitialize\n      initialValues={{ name: role.name, description: role.description }}\n      onSubmit={handleCreateRoleSubmit}\n      validationSchema={schema}\n    >\n      {({ handleSubmit, values, errors, handleReset, handleChange, handleBlur }) => (\n        <form onSubmit={handleSubmit}>\n          <ContainerFluid padding=\"0\">\n            <Header\n              title={{\n                label: role.name,\n              }}\n              content={role.description}\n              actions={headerActions(handleSubmit, handleReset)}\n              isLoading={isRoleLoading}\n            />\n            <BaselineAlignement top size=\"3px\" />\n            <FormCard\n              title={formatMessage({\n                id: getTrad('EditPage.form.roles'),\n                defaultMessage: 'Role details',\n              })}\n              isLoading={isLoading}\n            >\n              <SizedInput\n                label=\"Settings.roles.form.input.name\"\n                defaultMessage=\"Name\"\n                name=\"name\"\n                type=\"text\"\n                error={errors.name ? { id: errors.name } : null}\n                onBlur={handleBlur}\n                value={values.name}\n                onChange={handleChange}\n              />\n              <SizedInput\n                label=\"Settings.roles.form.input.description\"\n                defaultMessage=\"Description\"\n                name=\"description\"\n                type=\"textarea\"\n                error={errors.description ? { id: errors.description } : null}\n                onBlur={handleBlur}\n                value={values.description}\n                onChange={handleChange}\n                // Override the default height of the textarea\n                style={{ height: 115 }}\n              />\n            </FormCard>\n          </ContainerFluid>\n          <div style={{ paddingTop: '1.8rem' }} />\n          {!isLoading && !isRoleLoading && (\n            <UsersPermissions\n              ref={permissionsRef}\n              permissions={role.permissions}\n              routes={routes}\n              policies={policies}\n            />\n          )}\n          <Padded top size=\"md\" />\n        </form>\n      )}\n    </Formik>\n  );\n};\n\nexport default EditPage;\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/Roles/ListPage/index.js": "import React, { useCallback, useMemo, useState } from 'react';\nimport { List, Header } from '@buffetjs/custom';\nimport { useIntl } from 'react-intl';\nimport { useHistory } from 'react-router-dom';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { useUserPermissions, PopUpWarning, request, useGlobalContext } from 'strapi-helper-plugin';\n\nimport permissions from '../../../permissions';\nimport { EmptyRole, RoleListWrapper, RoleRow } from '../../../components/Roles';\nimport { useRolesList } from '../../../hooks';\nimport BaselineAlignment from './BaselineAlignment';\nimport pluginId from '../../../pluginId';\nimport { getTrad } from '../../../utils';\n\nconst RoleListPage = () => {\n  const { formatMessage } = useIntl();\n  const { emitEvent } = useGlobalContext();\n  const { push } = useHistory();\n\n  const [modalToDelete, setModalDelete] = useState();\n  const [shouldRefetchData, setShouldRefetchData] = useState(false);\n  const [showModalConfirmButtonLoading, setModalButtonLoading] = useState(false);\n\n  const updatePermissions = useMemo(() => {\n    return {\n      update: permissions.updateRole,\n      create: permissions.createRole,\n      delete: permissions.deleteRole,\n      read: permissions.readRoles,\n    };\n  }, []);\n  const {\n    isLoading: isLoadingForPermissions,\n    allowedActions: { canCreate, canUpdate, canDelete, canRead },\n  } = useUserPermissions(updatePermissions);\n  const shouldFetchData = !isLoadingForPermissions && canRead;\n\n  const { roles, getData, isLoading } = useRolesList(shouldFetchData);\n\n  const handleGoTo = id => {\n    if (canUpdate) {\n      push(`/settings/${pluginId}/roles/${id}`);\n    }\n  };\n\n  const handleDelete = () => {\n    strapi.lockAppWithOverlay();\n\n    setModalButtonLoading(true);\n\n    Promise.resolve(\n      request(`/${pluginId}/roles/${modalToDelete}`, {\n        method: 'DELETE',\n      })\n    )\n      .then(() => {\n        setShouldRefetchData(true);\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('Settings.roles.deleted') },\n        });\n      })\n      .catch(err => {\n        console.error(err);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      })\n      .finally(() => {\n        setModalDelete(null);\n        strapi.unlockApp();\n      });\n  };\n\n  const handleClosedModalDelete = () => {\n    if (shouldRefetchData) {\n      getData();\n    }\n    setModalButtonLoading(false);\n    setShouldRefetchData(false);\n  };\n\n  const handleNewRoleClick = () => {\n    emitEvent('willCreateRole');\n    push(`/settings/${pluginId}/roles/new`);\n  };\n\n  /* eslint-disable indent */\n  const headerActions = canCreate\n    ? [\n        {\n          label: formatMessage({\n            id: 'List.button.roles',\n            defaultMessage: 'Add new role',\n          }),\n          onClick: handleNewRoleClick,\n          color: 'primary',\n          type: 'button',\n          icon: true,\n        },\n      ]\n    : [];\n  /* eslint-enable indent */\n\n  const checkCanDeleteRole = useCallback(\n    role => {\n      return canDelete && !['public', 'authenticated'].includes(role.type);\n    },\n    [canDelete]\n  );\n\n  const getLinks = role => {\n    const links = [];\n\n    if (canUpdate) {\n      links.push({\n        icon: <FontAwesomeIcon icon=\"pencil-alt\" />,\n        onClick: () => handleGoTo(role.id),\n      });\n    }\n    if (checkCanDeleteRole(role)) {\n      links.push({\n        icon: <FontAwesomeIcon icon=\"trash-alt\" />,\n        onClick: e => {\n          e.preventDefault();\n          setModalDelete(role.id);\n          e.stopPropagation();\n        },\n      });\n    }\n\n    return links;\n  };\n\n  return (\n    <>\n      <Header\n        icon\n        title={{\n          label: formatMessage({\n            id: 'Settings.roles.title',\n            defaultMessage: 'Roles & Permissions',\n          }),\n        }}\n        content={formatMessage({\n          id: 'Settings.roles.list.description',\n          defaultMessage: 'Define the roles and permissions for your users.',\n        })}\n        actions={headerActions}\n        // Show a loader in the header while requesting data\n        isLoading={isLoading || isLoadingForPermissions}\n      />\n      <BaselineAlignment />\n      {canRead && (\n        <RoleListWrapper>\n          <List\n            title={formatMessage(\n              {\n                id: `Settings.roles.list.title${roles.length > 1 ? '.plural' : '.singular'}`,\n              },\n              { number: roles.length }\n            )}\n            items={roles}\n            isLoading={isLoading || isLoadingForPermissions}\n            customRowComponent={role => (\n              <RoleRow onClick={() => handleGoTo(role.id)} links={getLinks(role)} role={role} />\n            )}\n          />\n          {!roles && !isLoading && !isLoadingForPermissions && <EmptyRole />}\n          <PopUpWarning\n            isOpen={Boolean(modalToDelete)}\n            onConfirm={handleDelete}\n            onClosed={handleClosedModalDelete}\n            toggleModal={() => setModalDelete(null)}\n            isConfirmButtonLoading={showModalConfirmButtonLoading}\n          />\n        </RoleListWrapper>\n      )}\n    </>\n  );\n};\n\nexport default RoleListPage;\n",
    "packages/strapi/lib/commands/configurationRestore.js": "'use strict';\n\nconst fs = require('fs');\nconst _ = require('lodash');\nconst strapi = require('../index');\n\n/**\n * Will restore configurations. It reads from a file or stdin\n * @param {string} file filepath to use as input\n * @param {string} strategy import strategy. one of (replace, merge, keep, default: replace)\n */\nmodule.exports = async function({ file: filePath, strategy = 'replace' }) {\n  const input = filePath ? fs.readFileSync(filePath) : await readStdin(process.stdin);\n\n  const app = await strapi().load();\n\n  let dataToImport;\n  try {\n    dataToImport = JSON.parse(input);\n  } catch (error) {\n    throw new Error(`Invalid input data: ${error.message}. Expected a valid JSON array.`);\n  }\n\n  if (!Array.isArray(dataToImport)) {\n    throw new Error(`Invalid input data. Expected a valid JSON array.`);\n  }\n\n  const importer = createImporter(app.db, strategy);\n\n  for (const config of dataToImport) {\n    await importer.import(config);\n  }\n\n  console.log(\n    `Successfully imported configuration with ${strategy} strategy. Statistics: ${importer.printStatistics()}.`\n  );\n\n  process.exit(0);\n};\n\nconst readStdin = () => {\n  const { stdin } = process;\n  let result = '';\n\n  if (stdin.isTTY) return Promise.resolve(result);\n\n  return new Promise((resolve, reject) => {\n    stdin.setEncoding('utf8');\n    stdin.on('readable', () => {\n      let chunk;\n      while ((chunk = stdin.read())) {\n        result += chunk;\n      }\n    });\n\n    stdin.on('end', () => {\n      resolve(result);\n    });\n\n    stdin.on('error', reject);\n  });\n};\n\nconst createImporter = (db, strategy) => {\n  switch (strategy) {\n    case 'replace':\n      return createReplaceImporter(db);\n    case 'merge':\n      return createMergeImporter(db);\n    case 'keep':\n      return createKeepImporter(db);\n    default:\n      throw new Error(`No importer available for strategy \"${strategy}\"`);\n  }\n};\n\n/**\n * Replace importer. Will replace the keys that already exist and create the new ones\n * @param {Object} db - DatabaseManager instance\n */\nconst createReplaceImporter = db => {\n  const stats = {\n    created: 0,\n    replaced: 0,\n  };\n\n  return {\n    printStatistics() {\n      return `${stats.created} created, ${stats.replaced} replaced`;\n    },\n\n    async import(conf) {\n      const matching = await db.query('core_store').count({ key: conf.key });\n      if (matching > 0) {\n        stats.replaced += 1;\n        await db.query('core_store').update({ key: conf.key }, conf);\n      } else {\n        stats.created += 1;\n        await db.query('core_store').create(conf);\n      }\n    },\n  };\n};\n\n/**\n * Merge importer. Will merge the keys that already exist with their new value and create the new ones\n * @param {Object} db - DatabaseManager instance\n */\nconst createMergeImporter = db => {\n  const stats = {\n    created: 0,\n    merged: 0,\n  };\n\n  return {\n    printStatistics() {\n      return `${stats.created} created, ${stats.merged} merged`;\n    },\n\n    async import(conf) {\n      const existingConf = await db.query('core_store').find({ key: conf.key });\n      if (existingConf) {\n        stats.merged += 1;\n        await db.query('core_store').update({ key: conf.key }, _.merge(existingConf, conf));\n      } else {\n        stats.created += 1;\n        await db.query('core_store').create(conf);\n      }\n    },\n  };\n};\n\n/**\n * Merge importer. Will keep the keys that already exist without changing them and create the new ones\n * @param {Object} db - DatabaseManager instance\n */\nconst createKeepImporter = db => {\n  const stats = {\n    created: 0,\n    untouched: 0,\n  };\n\n  return {\n    printStatistics() {\n      return `${stats.created} created, ${stats.untouched} untouched`;\n    },\n\n    async import(conf) {\n      const matching = await db.query('core_store').count({ key: conf.key });\n      if (matching > 0) {\n        stats.untouched += 1;\n        // if configuration already exists do not overwrite it\n        return;\n      }\n\n      stats.created += 1;\n      await db.query('core_store').create(conf);\n    },\n  };\n};\n",
    "packages/strapi/lib/load/glob.js": "'use strict';\n\nconst glob = require('glob');\n\n/**\n * Promise based glob\n */\nmodule.exports = (...args) => {\n  return new Promise((resolve, reject) => {\n    glob(...args, (err, files) => {\n      if (err) return reject(err);\n      resolve(files);\n    });\n  });\n};\n",
    "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/tests/useFetchPluginsFromMarketPlace.test.js": "import { renderHook } from '@testing-library/react-hooks';\nimport axios from 'axios';\n// eslint-disable-next-line import/no-unresolved\nimport MockAdapter from 'axios-mock-adapter';\n\nimport useFetch from '../index';\n\ndescribe('ADMIN | hooks | useFetchPluginsFromMarketPlace', () => {\n  it('should perform a GET request', async () => {\n    const mock = new MockAdapter(axios);\n    const mockData = [{ ok: true }];\n    mock.onGet().replyOnce(200, mockData);\n\n    const { result, waitForNextUpdate } = renderHook(() => useFetch());\n\n    expect(result.current.isLoading).toBeTruthy();\n\n    await waitForNextUpdate();\n\n    expect(result.current.isLoading).toBeFalsy();\n    expect(result.current.error).toBeFalsy();\n    expect(result.current.data).toEqual(mockData);\n  });\n\n  it('should handle the errors correctly', async () => {\n    const mock = new MockAdapter(axios);\n\n    mock.onGet().replyOnce(() => {\n      return new Promise((_, reject) => {\n        reject(new Error(''));\n      });\n    });\n\n    const { result, waitForNextUpdate } = renderHook(() => useFetch());\n\n    expect(result.current.isLoading).toBeTruthy();\n\n    await waitForNextUpdate();\n\n    expect(result.current.isLoading).toBeFalsy();\n    expect(result.current.error).toBeTruthy();\n    expect(result.current.data).toBeNull();\n  });\n});\n",
    "packages/strapi-admin/index.js": "'use strict';\n/* eslint-disable no-useless-escape */\nconst path = require('path');\nconst _ = require('lodash');\nconst fs = require('fs-extra');\nconst webpack = require('webpack');\nconst WebpackDevServer = require('webpack-dev-server');\nconst chalk = require('chalk');\nconst chokidar = require('chokidar');\n// eslint-disable-next-line node/no-extraneous-require\nconst hasEE = require('strapi/lib/utils/ee');\nconst getWebpackConfig = require('./webpack.config.js');\n\nconst getPkgPath = name => path.dirname(require.resolve(`${name}/package.json`));\n\nfunction getCustomWebpackConfig(dir, config) {\n  const adminConfigPath = path.join(dir, 'admin', 'admin.config.js');\n\n  let webpackConfig = getWebpackConfig({ useEE: hasEE({ dir }), ...config });\n\n  if (fs.existsSync(adminConfigPath)) {\n    const adminConfig = require(path.resolve(adminConfigPath));\n\n    if (_.isFunction(adminConfig.webpack)) {\n      webpackConfig = adminConfig.webpack(webpackConfig, webpack);\n\n      if (!webpackConfig) {\n        console.error(\n          `${chalk.red('Error:')} Nothing was returned from your custom webpack configuration`\n        );\n        process.exit(1);\n      }\n    }\n  }\n\n  return webpackConfig;\n}\n\nasync function build({ dir, env, options, optimize }) {\n  // Create the cache dir containing the front-end files.\n  await createCacheDir(dir);\n\n  const cacheDir = path.resolve(dir, '.cache');\n  const entry = path.resolve(cacheDir, 'admin', 'src', 'app.js');\n  const dest = path.resolve(dir, 'build');\n  const config = getCustomWebpackConfig(dir, { entry, dest, env, options, optimize });\n\n  const compiler = webpack(config);\n\n  return new Promise((resolve, reject) => {\n    compiler.run((err, stats) => {\n      let messages;\n      if (err) {\n        if (!err.message) {\n          return reject(err);\n        }\n        messages = {\n          errors: [err.message],\n          warnings: [],\n        };\n      } else {\n        messages = stats.toJson({ all: false, warnings: true, errors: true });\n      }\n\n      if (messages.errors.length) {\n        // Only keep the first error. Others are often indicative\n        // of the same problem, but confuse the reader with noise.\n        if (messages.errors.length > 1) {\n          messages.errors.length = 1;\n        }\n        return reject(new Error(messages.errors.join('\\n\\n')));\n      }\n\n      return resolve({\n        stats,\n        warnings: messages.warnings,\n      });\n    });\n  });\n}\n\nasync function createPluginsJs(plugins, localPlugins, dest) {\n  const content = `\nconst injectReducer = require('./utils/injectReducer').default;\nconst injectSaga = require('./utils/injectSaga').default;\nconst useInjectReducer = require('./utils/injectReducer').useInjectReducer;\nconst useInjectSaga = require('./utils/injectSaga').useInjectSaga;\nconst { languages } = require('./i18n');\n\nwindow.strapi = Object.assign(window.strapi || {}, {\n  node: MODE || 'host',\n  backendURL: BACKEND_URL === '/' ? window.location.origin : BACKEND_URL,\n  languages,\n  currentLanguage:\n  window.localStorage.getItem('strapi-admin-language') ||\n  window.navigator.language ||\n  window.navigator.userLanguage ||\n  'en',\n  injectReducer,\n  injectSaga,\n  useInjectReducer,\n  useInjectSaga,\n});\n\nmodule.exports = {\n  ${plugins\n    .map(name => {\n      const shortName = name.replace(/^strapi-plugin-/i, '');\n      const req = `require('../../plugins/${name}/admin/src').default`;\n      return `'${shortName}': ${req},`;\n    })\n    .join('\\n')}\n  ${localPlugins\n    .map(name => {\n      const shortName = name.replace(/^strapi-plugin-/i, '');\n      const req = `require('../../../plugins/${name}/admin/src').default`;\n      return `'${shortName}': ${req}`;\n    })\n    .join(',\\n')}\n}\n  `;\n\n  return fs.writeFile(path.resolve(dest, 'admin', 'src', 'plugins.js'), content);\n}\n\nasync function clean({ dir }) {\n  const buildDir = path.join(dir, 'build');\n  const cacheDir = path.join(dir, '.cache');\n\n  fs.removeSync(buildDir);\n  fs.removeSync(cacheDir);\n}\n\nasync function copyPlugin(name, dest) {\n  const pkgFilePath = getPkgPath(name);\n\n  const resolveDepPath = (...args) => path.resolve(pkgFilePath, ...args);\n  const resolveDest = (...args) => path.resolve(dest, 'plugins', name, ...args);\n\n  const copy = (...args) => {\n    return fs.copy(resolveDepPath(...args), resolveDest(...args));\n  };\n\n  // Copy the entire admin folder\n  await copy('admin');\n\n  // Copy the layout.js if it exists\n  if (await fs.exists(path.resolve(pkgFilePath, 'config', 'layout.js'))) {\n    await fs.ensureDir(resolveDest('config'));\n    await copy('config', 'layout.js');\n  }\n\n  await copy('package.json');\n}\n\nasync function copyAdmin(dest) {\n  const adminPath = getPkgPath('strapi-admin');\n\n  // TODO copy ee folders for plugins\n  await fs.copy(path.resolve(adminPath, 'ee', 'admin'), path.resolve(dest, 'ee', 'admin'));\n\n  await fs.ensureDir(path.resolve(dest, 'config'));\n  await fs.copy(path.resolve(adminPath, 'admin'), path.resolve(dest, 'admin'));\n  await fs.copy(\n    path.resolve(adminPath, 'config', 'layout.js'),\n    path.resolve(dest, 'config', 'layout.js')\n  );\n\n  // Copy package.json\n  await fs.copy(path.resolve(adminPath, 'package.json'), path.resolve(dest, 'package.json'));\n}\n\nasync function copyCustomAdmin(src, dest) {\n  await fs.copy(src, path.resolve(dest, 'admin'));\n}\n\nasync function createCacheDir(dir) {\n  const cacheDir = path.resolve(dir, '.cache');\n\n  const pkgJSON = require(path.join(dir, 'package.json'));\n\n  const pluginsToCopy = Object.keys(pkgJSON.dependencies).filter(\n    dep =>\n      dep.startsWith('strapi-plugin') &&\n      fs.existsSync(path.resolve(getPkgPath(dep), 'admin', 'src', 'index.js'))\n  );\n\n  let localPluginsToCopy = [];\n  if (fs.existsSync(path.join(dir, 'plugins'))) {\n    localPluginsToCopy = fs\n      .readdirSync(path.join(dir, 'plugins'))\n      .filter(plugin =>\n        fs.existsSync(path.resolve(dir, 'plugins', plugin, 'admin', 'src', 'index.js'))\n      );\n  }\n\n  // TODO: add logic to avoid copying files if not necessary\n\n  // create .cache dir\n  await fs.emptyDir(cacheDir);\n\n  // copy admin core code\n  await copyAdmin(cacheDir);\n\n  // copy plugins code\n  await Promise.all(pluginsToCopy.map(name => copyPlugin(name, cacheDir)));\n\n  // override admin code with user customizations\n  if (fs.pathExistsSync(path.join(dir, 'admin'))) {\n    await copyCustomAdmin(path.join(dir, 'admin'), cacheDir);\n  }\n\n  // create plugins.js with plugins requires\n  await createPluginsJs(pluginsToCopy, localPluginsToCopy, cacheDir);\n\n  // override plugins' admin code with user customizations\n  const pluginsToOverride = pluginsToCopy.reduce((acc, current) => {\n    const pluginName = current.replace(/^strapi-plugin-/i, '');\n\n    if (fs.pathExistsSync(path.join(dir, 'extensions', pluginName, 'admin'))) {\n      acc.push(pluginName);\n    }\n\n    return acc;\n  }, []);\n\n  await Promise.all(\n    pluginsToOverride.map(plugin =>\n      copyCustomAdmin(\n        path.join(dir, 'extensions', plugin, 'admin'),\n        path.join(cacheDir, 'plugins', `strapi-plugin-${plugin}`)\n      )\n    )\n  );\n}\n\nasync function watchAdmin({ dir, host, port, browser, options }) {\n  // Create the cache dir containing the front-end files.\n  await createCacheDir(dir);\n\n  const entry = path.join(dir, '.cache', 'admin', 'src', 'app.js');\n  const dest = path.join(dir, 'build');\n  const env = 'development';\n\n  const args = {\n    entry,\n    dest,\n    env,\n    port,\n    options,\n  };\n\n  const opts = {\n    clientLogLevel: 'silent',\n    quiet: true,\n    open: browser === 'true' ? true : browser,\n    publicPath: options.publicPath,\n    historyApiFallback: {\n      index: options.publicPath,\n      disableDotRule: true,\n    },\n  };\n\n  const webpackConfig = getCustomWebpackConfig(dir, args);\n  const server = new WebpackDevServer(webpack(webpackConfig), opts);\n\n  server.listen(port, host, function(err) {\n    if (err) {\n      console.log(err);\n    }\n\n    console.log(chalk.green('Starting the development server...'));\n    console.log();\n    console.log(chalk.green(`Admin development at http://${host}:${port}${opts.publicPath}`));\n  });\n\n  watchFiles(dir, options.watchIgnoreFiles);\n}\n\nasync function watchFiles(dir, ignoreFiles = []) {\n  const cacheDir = path.join(dir, '.cache');\n  const pkgJSON = require(path.join(dir, 'package.json'));\n  const admin = path.join(dir, 'admin');\n  const extensionsPath = path.join(dir, 'extensions');\n\n  const appPlugins = Object.keys(pkgJSON.dependencies).filter(\n    dep =>\n      dep.startsWith('strapi-plugin') &&\n      fs.existsSync(path.resolve(getPkgPath(dep), 'admin', 'src', 'index.js'))\n  );\n  const pluginsToWatch = appPlugins.map(plugin =>\n    path.join(extensionsPath, plugin.replace(/^strapi-plugin-/i, ''), 'admin')\n  );\n  const filesToWatch = [admin, ...pluginsToWatch];\n\n  const watcher = chokidar.watch(filesToWatch, {\n    ignoreInitial: true,\n    ignorePermissionErrors: true,\n    ignored: [...ignoreFiles],\n  });\n\n  watcher.on('all', async (event, filePath) => {\n    const isExtension = filePath.includes(extensionsPath);\n    const pluginName = isExtension ? filePath.replace(extensionsPath, '').split(path.sep)[1] : '';\n\n    const packageName = isExtension ? `strapi-plugin-${pluginName}` : 'strapi-admin';\n\n    const targetPath = isExtension\n      ? path.normalize(filePath.split(extensionsPath)[1].replace(pluginName, ''))\n      : path.normalize(filePath.split(admin)[1]);\n\n    const destFolder = isExtension\n      ? path.join(cacheDir, 'plugins', packageName)\n      : path.join(cacheDir, 'admin');\n\n    if (event === 'unlink' || event === 'unlinkDir') {\n      const originalFilePathInNodeModules = path.join(\n        getPkgPath(packageName),\n        isExtension ? '' : 'admin',\n        targetPath\n      );\n\n      // Remove the file or folder\n      // We need to copy the original files when deleting an override one\n      try {\n        fs.removeSync(path.join(destFolder, targetPath));\n      } catch (err) {\n        console.log('An error occured while deleting the file', err);\n      }\n\n      // Check if the file or folder exists in node_modules\n      // If so copy the old one\n      if (fs.pathExistsSync(path.resolve(originalFilePathInNodeModules))) {\n        try {\n          await fs.copy(\n            path.resolve(originalFilePathInNodeModules),\n            path.join(destFolder, targetPath)\n          );\n\n          // The plugins.js file needs to be recreated\n          // when we delete either the admin folder\n          // the admin/src folder\n          // or the plugins.js file\n          // since the path are different when developing inside the monorepository or inside an app\n          const shouldCopyPluginsJSFile =\n            filePath.split('/admin/src').filter(p => !!p).length === 1;\n\n          if (\n            (event === 'unlinkDir' && !isExtension && shouldCopyPluginsJSFile) ||\n            (!isExtension && filePath.includes('plugins.js'))\n          ) {\n            await createPluginsJs(appPlugins, path.join(cacheDir));\n          }\n        } catch (err) {\n          // Do nothing\n        }\n      }\n    } else {\n      // In any other case just copy the file into the .cache folder\n      try {\n        await fs.copy(filePath, path.join(destFolder, targetPath));\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  });\n}\n\nmodule.exports = {\n  clean,\n  build,\n  watchAdmin,\n};\n",
    "packages/strapi-admin/services/__tests__/permissions.engine.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst { subject } = require('@casl/ability');\nconst createConditionProvider = require('../permission/condition-provider');\nconst createPermissionsEngine = require('../permission/engine');\n\ndescribe('Permissions Engine', () => {\n  let conditionProvider;\n  let engine;\n\n  const localTestData = {\n    users: {\n      bob: {\n        firstname: 'Bob',\n        title: 'guest',\n        roles: [{ id: 1 }, { id: 2 }],\n      },\n      alice: {\n        firstname: 'Alice',\n        title: 'admin',\n        roles: [{ id: 1 }],\n      },\n      kai: {\n        firstname: 'Kai',\n        title: 'admin',\n        roles: [{ id: 3 }],\n      },\n      foo: {\n        firstname: 'Foo',\n        title: 'Bar',\n        roles: [{ id: 4 }],\n      },\n    },\n    roles: {\n      1: {\n        permissions: [\n          {\n            action: 'read',\n            subject: 'article',\n            fields: ['**'],\n            conditions: ['plugins::test.isBob'],\n          },\n          {\n            action: 'read',\n            subject: 'user',\n            fields: ['title'],\n            conditions: ['plugins::test.isAdmin'],\n          },\n        ],\n      },\n      2: {\n        permissions: [\n          {\n            action: 'post',\n            subject: 'article',\n            fields: ['*'],\n            conditions: ['plugins::test.isBob'],\n          },\n        ],\n      },\n      3: {\n        permissions: [\n          {\n            action: 'read',\n            subject: 'user',\n            fields: ['title'],\n            conditions: ['plugins::test.isContainedIn'],\n          },\n        ],\n      },\n      4: {\n        permissions: [\n          {\n            action: 'read',\n            subject: 'user',\n            fields: [],\n          },\n        ],\n      },\n    },\n    conditions: [\n      {\n        plugin: 'test',\n        name: 'isBob',\n        category: 'default',\n        handler: async user => new Promise(resolve => resolve(user.firstname === 'Bob')),\n      },\n      {\n        plugin: 'test',\n        name: 'isAdmin',\n        category: 'default',\n        handler: user => user.title === 'admin',\n      },\n      {\n        plugin: 'test',\n        name: 'isCreatedBy',\n        category: 'default',\n        handler: user => ({ created_by: user.firstname }),\n      },\n      {\n        plugin: 'test',\n        name: 'isContainedIn',\n        category: 'default',\n        handler: { firstname: { $in: ['Alice', 'Foo'] } },\n      },\n    ],\n  };\n\n  const getUser = name => localTestData.users[name];\n\n  beforeEach(() => {\n    global.strapi = {\n      isLoaded: false,\n      admin: {\n        services: {\n          permission: {\n            findUserPermissions: jest.fn(({ roles }) =>\n              _.reduce(\n                localTestData.roles,\n                (acc, { permissions: value }, key) => {\n                  return roles.map(_.property('id')).includes(_.toNumber(key))\n                    ? [...acc, ...value]\n                    : acc;\n                },\n                []\n              )\n            ),\n          },\n        },\n      },\n    };\n\n    conditionProvider = createConditionProvider();\n    conditionProvider.registerMany(localTestData.conditions);\n\n    engine = createPermissionsEngine(conditionProvider);\n\n    jest.spyOn(engine, 'evaluatePermission');\n    jest.spyOn(engine, 'createRegisterFunction');\n    jest.spyOn(engine, 'generateAbilityCreatorFor');\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('GenerateUserAbility', () => {\n    test('Successfully creates an ability for Bob', async () => {\n      const user = getUser('bob');\n\n      const ability = await engine.generateUserAbility(user);\n\n      const expected = [\n        {\n          action: 'read',\n          fields: ['**'],\n          subject: 'article',\n        },\n        {\n          action: 'post',\n          fields: ['*'],\n          subject: 'article',\n        },\n      ];\n\n      expect(engine.generateAbilityCreatorFor).toHaveBeenCalledWith(user);\n      expect(_.orderBy(ability.rules, ['subject'], ['asc'])).toMatchObject(expected);\n\n      expect(ability.can('post', 'article')).toBeTruthy();\n      expect(ability.can('post', 'article', 'user')).toBeTruthy();\n      expect(ability.can('post', 'article', 'user.nested')).toBeFalsy();\n\n      expect(ability.can('read', 'article')).toBeTruthy();\n      expect(ability.can('read', 'article', 'title')).toBeTruthy();\n      expect(ability.can('read', 'article', 'title.nested')).toBeTruthy();\n\n      expect(ability.can('read', 'user')).toBeFalsy();\n      expect(ability.can('read', 'user', 'firstname')).toBeFalsy();\n      expect(ability.can('read', 'user', 'title')).toBeFalsy();\n      expect(ability.can('read', 'user', 'title.nested')).toBeFalsy();\n    });\n\n    test('Successfully creates an ability for Alice', async () => {\n      const user = getUser('alice');\n\n      const ability = await engine.generateUserAbility(user);\n\n      const expected = [\n        {\n          action: 'read',\n          fields: ['title'],\n          subject: 'user',\n        },\n      ];\n\n      expect(engine.generateAbilityCreatorFor).toHaveBeenCalledWith(user);\n      expect(_.orderBy(ability.rules, ['action'], ['asc'])).toMatchObject(expected);\n\n      expect(ability.can('post', 'article')).toBeFalsy();\n      expect(ability.can('post', 'article', 'user')).toBeFalsy();\n      expect(ability.can('post', 'article', 'user.nested')).toBeFalsy();\n\n      expect(ability.can('read', 'article')).toBeFalsy();\n      expect(ability.can('read', 'article', 'title')).toBeFalsy();\n      expect(ability.can('read', 'article', 'title.nested')).toBeFalsy();\n\n      expect(ability.can('read', 'user')).toBeTruthy();\n      expect(ability.can('read', 'user', 'firstname')).toBeFalsy();\n      expect(ability.can('read', 'user', 'title')).toBeTruthy();\n      expect(ability.can('read', 'user', 'title.nested')).toBeFalsy();\n    });\n\n    test('Ignore permission on empty fields array', async () => {\n      const user = getUser('foo');\n\n      const ability = await engine.generateUserAbility(user);\n\n      expect(engine.generateAbilityCreatorFor).toHaveBeenCalledWith(user);\n      expect(ability.rules).toHaveLength(0);\n      expect(ability.can('read', 'user')).toBeFalsy();\n    });\n\n    describe('Use objects as subject', () => {\n      let ability;\n\n      beforeAll(async () => {\n        const user = getUser('kai');\n        ability = await engine.generateUserAbility(user);\n      });\n\n      test('Fails to validate the object condition', () => {\n        const args = ['read', subject('user', { firstname: 'Bar' }), 'title'];\n\n        expect(ability.can(...args)).toBeFalsy();\n      });\n\n      test('Fails to read a restricted field', () => {\n        const args = ['read', subject('user', { firstname: 'Foo' }), 'bar'];\n\n        expect(ability.can(...args)).toBeFalsy();\n      });\n\n      test('Successfully validate the permission', () => {\n        const args = ['read', subject('user', { firstname: 'Foo' }), 'title'];\n\n        expect(ability.can(...args)).toBeTruthy();\n      });\n    });\n  });\n\n  describe('Generate Ability Creator For', () => {\n    test('Successfully generates an ability creator for Alice', async () => {\n      const user = getUser('alice');\n\n      const abilityCreator = engine.generateAbilityCreatorFor(user);\n      const ability = await abilityCreator([]);\n\n      expect(abilityCreator).not.toBeUndefined();\n      expect(typeof abilityCreator).toBe('function');\n      expect(ability.rules).toStrictEqual([]);\n    });\n  });\n\n  describe('Evaluate Permission', () => {\n    test('It should register the permission (no conditions / true result)', async () => {\n      const permission = { action: 'read', subject: 'article', fields: ['title'] };\n      const user = getUser('alice');\n      const registerFn = jest.fn();\n\n      await engine.evaluatePermission({ permission, user, registerFn });\n\n      expect(registerFn).toHaveBeenCalledWith({ ...permission, condition: true });\n    });\n\n    test('It should register the permission (conditions / true result)', async () => {\n      const permission = {\n        action: 'read',\n        subject: 'article',\n        fields: ['title'],\n        conditions: ['plugins::test.isAdmin'],\n      };\n      const user = getUser('alice');\n      const registerFn = jest.fn();\n\n      await engine.evaluatePermission({ permission, user, registerFn });\n\n      const expected = {\n        ..._.omit(permission, 'conditions'),\n        condition: true,\n      };\n\n      expect(registerFn).toHaveBeenCalledWith(expected);\n    });\n\n    test('It should not register the permission (conditions / false result)', async () => {\n      const permission = {\n        action: 'read',\n        subject: 'article',\n        fields: ['title'],\n        conditions: ['plugins::test.isBob'],\n      };\n      const user = getUser('alice');\n      const registerFn = jest.fn();\n\n      await engine.evaluatePermission({ permission, user, registerFn });\n\n      expect(registerFn).not.toHaveBeenCalled();\n    });\n\n    test('It should register the permission (conditions / object result)', async () => {\n      const permission = {\n        action: 'read',\n        subject: 'article',\n        fields: ['title'],\n        conditions: ['plugins::test.isCreatedBy'],\n      };\n      const user = getUser('alice');\n      const registerFn = jest.fn();\n\n      await engine.evaluatePermission({ permission, user, registerFn });\n\n      const expected = {\n        ..._.omit(permission, 'conditions'),\n        condition: { created_by: user.firstname },\n      };\n\n      expect(registerFn).toHaveBeenCalledWith(expected);\n    });\n  });\n\n  describe('Create Register Function', () => {\n    let can;\n    let registerFn;\n\n    beforeEach(() => {\n      can = jest.fn();\n      registerFn = engine.createRegisterFunction(can);\n    });\n\n    test('It should calls the can function without any condition', () => {\n      registerFn({ action: 'read', subject: 'article', fields: '*', condition: true });\n\n      expect(can).toHaveBeenCalledTimes(1);\n      expect(can).toHaveBeenCalledWith('read', 'article', '*', undefined);\n    });\n\n    test('It should calls the can function with a condition', () => {\n      registerFn({ action: 'read', subject: 'article', fields: '*', condition: { created_by: 1 } });\n\n      expect(can).toHaveBeenCalledTimes(1);\n      expect(can).toHaveBeenCalledWith('read', 'article', '*', { created_by: 1 });\n    });\n  });\n\n  describe('Check Many', () => {\n    let ability;\n    const permissions = [\n      { action: 'read', subject: 'user', field: 'title' },\n      { action: 'post', subject: 'article' },\n    ];\n\n    beforeEach(() => {\n      ability = { can: jest.fn(() => true) };\n    });\n\n    afterEach(() => {\n      jest.clearAllMocks();\n    });\n\n    test('Using curried version of checkMany', () => {\n      const checkMany = engine.checkMany(ability);\n\n      const res = checkMany(permissions);\n\n      expect(res).toHaveLength(permissions.length);\n      expect(ability.can).toHaveBeenCalledTimes(2);\n    });\n\n    test('Using raw version of checkMany', () => {\n      const res = engine.checkMany(ability, permissions);\n\n      expect(res).toHaveLength(permissions.length);\n      expect(ability.can).toHaveBeenCalledTimes(2);\n    });\n  });\n});\n",
    "packages/strapi-admin/services/__tests__/token.test.js": "'use strict';\n\nconst { createJwtToken, getTokenOptions, decodeJwtToken, createToken } = require('../token');\n\nconst delay = time => new Promise(resolve => setTimeout(resolve, time));\n\ndescribe('Token', () => {\n  describe('token options', () => {\n    test('Has defaults', () => {\n      const getFn = jest.fn(() => ({}));\n      global.strapi = {\n        config: {\n          get: getFn,\n        },\n      };\n\n      const res = getTokenOptions();\n\n      expect(getFn).toHaveBeenCalledWith('server.admin.auth', {});\n      expect(res).toEqual({ options: { expiresIn: '30d' } });\n    });\n\n    test('Merges defaults with configuration', () => {\n      const config = {\n        options: {},\n        secret: '123',\n      };\n\n      const getFn = jest.fn(() => config);\n      global.strapi = {\n        config: {\n          get: getFn,\n        },\n      };\n\n      const res = getTokenOptions();\n\n      expect(getFn).toHaveBeenCalledWith('server.admin.auth', {});\n      expect(res).toEqual({\n        options: {\n          expiresIn: '30d',\n        },\n        secret: config.secret,\n      });\n    });\n\n    test('Overwrite defaults with configuration options', () => {\n      const config = {\n        options: {\n          expiresIn: '1d',\n        },\n        secret: '123',\n      };\n\n      const getFn = jest.fn(() => config);\n      global.strapi = {\n        config: {\n          get: getFn,\n        },\n      };\n\n      const res = getTokenOptions();\n\n      expect(getFn).toHaveBeenCalledWith('server.admin.auth', {});\n      expect(res).toEqual({\n        options: {\n          expiresIn: '1d',\n        },\n        secret: config.secret,\n      });\n    });\n  });\n\n  describe('createJwtToken', () => {\n    test('Returns a jwt token', () => {\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              secret: 'test-123',\n            };\n          },\n        },\n      };\n\n      const token = createJwtToken({ id: 1 });\n\n      expect(token).toBeDefined();\n      expect(typeof token === 'string').toBe(true);\n    });\n\n    test('Token payload does not leak user infos', () => {\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              secret: 'test-123',\n            };\n          },\n        },\n      };\n\n      const token = createJwtToken({\n        id: 1,\n        password: 'pcw123',\n        firstname: 'Test',\n        email: 'test@strapi.io',\n      });\n\n      const { payload } = decodeJwtToken(token);\n\n      expect(payload).toEqual({\n        id: 1,\n        iat: expect.any(Number),\n        exp: expect.any(Number),\n      });\n    });\n  });\n\n  describe('decodeJwtToken', () => {\n    test('Fails if the token is invalid', () => {\n      const { payload, isValid } = decodeJwtToken('invalid-token');\n      expect(payload).toBe(null);\n      expect(isValid).toBe(false);\n    });\n\n    test('Fails if the token was not generated with the same secret', () => {\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              secret: 'test-123',\n            };\n          },\n        },\n      };\n\n      const user = { id: 1 };\n      const token = createJwtToken(user);\n\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              secret: 'not-the-same-secret',\n            };\n          },\n        },\n      };\n\n      const { payload, isValid } = decodeJwtToken(token);\n      expect(payload).toBe(null);\n      expect(isValid).toBe(false);\n    });\n\n    test('Fails if the token has expired', async () => {\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              options: {\n                expiresIn: '1ms',\n              },\n              secret: 'test-123',\n            };\n          },\n        },\n      };\n\n      const user = { id: 1 };\n      const token = createJwtToken(user);\n\n      await delay(10);\n\n      const { payload, isValid } = decodeJwtToken(token);\n      expect(payload).toBe(null);\n      expect(isValid).toBe(false);\n    });\n\n    test('Returns payload if token is valid', async () => {\n      global.strapi = {\n        config: {\n          get() {\n            return {\n              options: { expiresIn: '30d' },\n              secret: 'test-123',\n            };\n          },\n        },\n      };\n\n      const user = { id: 1 };\n      const token = createJwtToken(user);\n\n      const { payload, isValid } = decodeJwtToken(token);\n      expect(payload).toEqual({\n        id: 1,\n        iat: expect.any(Number),\n        exp: expect.any(Number),\n      });\n      expect(isValid).toBe(true);\n    });\n  });\n\n  describe('createToken', () => {\n    test('Create a random token of length 128', () => {\n      const token = createToken();\n\n      expect(token).toBeDefined();\n      expect(typeof token === 'string').toBe(true);\n      expect(token.length).toBe(40);\n    });\n  });\n});\n",
    "packages/strapi-helper-plugin/lib/src/utils/request.js": "import 'whatwg-fetch';\nimport _ from 'lodash';\nimport auth from './auth';\n\n/**\n * Parses the JSON returned by a network request\n *\n * @param  {object} response A response from a network request\n *\n * @return {object}          The parsed JSON from the request\n */\nfunction parseJSON(response) {\n  return response.json ? response.json() : response;\n}\n\n/**\n * Checks if a network request came back fine, and throws an error if not\n *\n * @param  {object} response   A response from a network request\n *\n * @return {object|undefined} Returns either the response, or throws an error\n */\nfunction checkStatus(response, checkToken = true) {\n  if ((response.status >= 200 && response.status < 300) || response.status === 0) {\n    return response;\n  }\n\n  // TODO handle 403...\n\n  if (response.status === 401 && auth.getToken() && checkToken) {\n    // Temporary fix until we create a new request helper\n    auth.clearAppStorage();\n    window.location.reload();\n  }\n\n  return parseJSON(response)\n    .then(responseFormatted => {\n      const error = new Error(response.statusText);\n      error.response = response;\n      error.response.payload = responseFormatted;\n      throw error;\n    })\n    .catch(() => {\n      const error = new Error(response.statusText);\n      error.response = response;\n\n      throw error;\n    });\n}\n\n/**\n * Format query params\n *\n * @param params\n * @returns {string}\n */\nfunction formatQueryParams(params) {\n  return Object.keys(params)\n    .map(k => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`)\n    .join('&');\n}\n\n/**\n * Server restart watcher\n * @param response\n * @returns {object} the response data\n */\nfunction serverRestartWatcher(response) {\n  return new Promise(resolve => {\n    fetch(`${strapi.backendURL}/_health`, {\n      method: 'HEAD',\n      mode: 'no-cors',\n      headers: {\n        'Content-Type': 'application/json',\n        'Keep-Alive': false,\n      },\n    })\n      .then(res => {\n        if (res.status >= 400) {\n          throw new Error('not available');\n        }\n\n        resolve(response);\n      })\n      .catch(() => {\n        setTimeout(() => {\n          return serverRestartWatcher(response).then(resolve);\n        }, 100);\n      });\n  });\n}\n\n/**\n * Requests a URL, returning a promise\n *\n * @param  {string} url       The URL we want to request\n * @param  {object} [options] The options we want to pass to \"fetch\"\n *\n * @return {object}           The response data\n */\nexport default function request(...args) {\n  let [url, options = {}, shouldWatchServerRestart, stringify = true, ...rest] = args;\n  let noAuth;\n\n  try {\n    [{ noAuth }] = rest;\n  } catch (err) {\n    noAuth = false;\n  }\n\n  // Set headers\n  if (!options.headers) {\n    options.headers = Object.assign(\n      {\n        'Content-Type': 'application/json',\n      },\n      options.headers\n    );\n  }\n\n  const token = auth.getToken();\n\n  if (token && !noAuth) {\n    options.headers = Object.assign(\n      {\n        Authorization: `Bearer ${token}`,\n      },\n      options.headers\n    );\n  }\n\n  // Add parameters to url\n  url = _.startsWith(url, '/') ? `${strapi.backendURL}${url}` : url;\n\n  if (options && options.params) {\n    const params = formatQueryParams(options.params);\n    url = `${url}?${params}`;\n  }\n\n  // Stringify body object\n  if (options && options.body && stringify) {\n    options.body = JSON.stringify(options.body);\n  }\n\n  return fetch(url, options)\n    .then(checkStatus)\n    .then(parseJSON)\n    .then(response => {\n      if (shouldWatchServerRestart) {\n        return serverRestartWatcher(response);\n      }\n\n      return response;\n    });\n}\n",
    "packages/strapi-plugin-content-type-builder/admin/src/containers/ListView/index.js": "import React, { useEffect, useMemo, useState } from 'react';\nimport { Prompt, useHistory, useLocation } from 'react-router-dom';\nimport PropTypes from 'prop-types';\nimport { get, has, isEqual } from 'lodash';\nimport { BackHeader, ListWrapper, useGlobalContext } from 'strapi-helper-plugin';\nimport { Header } from '@buffetjs/custom';\nimport ListViewContext from '../../contexts/ListViewContext';\nimport convertAttrObjToArray from '../../utils/convertAttrObjToArray';\nimport getAttributeDisplayedType from '../../utils/getAttributeDisplayedType';\nimport pluginId from '../../pluginId';\nimport getComponents from '../../utils/getComponents';\nimport getTrad from '../../utils/getTrad';\nimport makeSearch from '../../utils/makeSearch';\nimport ListRow from '../../components/ListRow';\nimport List from '../../components/List';\nimport ListButton from '../../components/ListButton';\nimport useDataManager from '../../hooks/useDataManager';\nimport ListHeader from '../../components/ListHeader';\nimport LeftMenu from '../LeftMenu';\nimport Wrapper from './Wrapper';\n\n/* eslint-disable indent */\n\nconst ListView = () => {\n  const {\n    initialData,\n    modifiedData,\n    isInDevelopmentMode,\n    isInContentTypeView,\n    submitData,\n    toggleModalCancel,\n  } = useDataManager();\n\n  const { emitEvent, formatMessage, plugins } = useGlobalContext();\n  const { push, goBack } = useHistory();\n  const { search } = useLocation();\n  const [enablePrompt, togglePrompt] = useState(true);\n\n  useEffect(() => {\n    if (search === '') {\n      togglePrompt(true);\n    }\n  }, [search]);\n\n  // Disabling the prompt on the first render if one of the modal is open\n  useEffect(() => {\n    if (search !== '') {\n      togglePrompt(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const firstMainDataPath = isInContentTypeView ? 'contentType' : 'component';\n  const mainDataTypeAttributesPath = [firstMainDataPath, 'schema', 'attributes'];\n  const targetUid = get(modifiedData, [firstMainDataPath, 'uid']);\n  const isTemporary = get(modifiedData, [firstMainDataPath, 'isTemporary'], false);\n  const contentTypeKind = get(modifiedData, [firstMainDataPath, 'schema', 'kind'], null);\n\n  const attributes = get(modifiedData, mainDataTypeAttributesPath, {});\n  const attributesLength = Object.keys(attributes).length;\n  const currentDataName = get(initialData, [firstMainDataPath, 'schema', 'name'], '');\n  const isFromPlugin = has(initialData, [firstMainDataPath, 'plugin']);\n  const hasModelBeenModified = !isEqual(modifiedData, initialData);\n  const forTarget = isInContentTypeView ? 'contentType' : 'component';\n\n  const handleClickAddField = async (\n    forTarget,\n    targetUid,\n    firstHeaderObj,\n    secondHeaderObj,\n    thirdHeaderObj,\n    fourthHeaderObj\n  ) => {\n    // disable the prompt\n    await wait();\n\n    const searchObj = {\n      modalType: 'chooseAttribute',\n      forTarget,\n      targetUid,\n      ...firstHeaderObj,\n      ...secondHeaderObj,\n      ...thirdHeaderObj,\n      ...fourthHeaderObj,\n    };\n\n    push({ search: makeSearch(searchObj) });\n  };\n\n  const handleClickAddComponentToDZ = async dzName => {\n    const firstHeaderObject = {\n      header_label_1: currentDataName,\n      header_icon_name_1: 'dynamiczone',\n      header_icon_isCustom_1: false,\n    };\n    const secondHeaderObj = {\n      header_label_2: dzName,\n    };\n    const search = {\n      modalType: 'addComponentToDynamicZone',\n      forTarget: 'contentType',\n      targetUid,\n      dynamicZoneTarget: dzName,\n      settingType: 'base',\n      step: '1',\n      actionType: 'edit',\n      ...firstHeaderObject,\n      ...secondHeaderObj,\n    };\n\n    await wait();\n\n    push({ search: makeSearch(search, true) });\n  };\n\n  const handleClickEditField = async (\n    forTarget,\n    targetUid,\n    attributeName,\n    type,\n    firstHeaderObj,\n    secondHeaderObj,\n    thirdHeaderObj,\n    fourthHeaderObj,\n    fifthHeaderObj\n  ) => {\n    const attributeType = getAttributeDisplayedType(type);\n\n    await wait();\n\n    const search = {\n      modalType: 'attribute',\n      actionType: 'edit',\n      settingType: 'base',\n      forTarget,\n      targetUid,\n      attributeName,\n      attributeType,\n      step: type === 'component' ? '2' : null,\n      ...firstHeaderObj,\n      ...secondHeaderObj,\n      ...thirdHeaderObj,\n      ...fourthHeaderObj,\n      ...fifthHeaderObj,\n    };\n\n    await wait();\n\n    push({ search: makeSearch(search, true) });\n  };\n\n  const getDescription = () => {\n    const description = get(modifiedData, [firstMainDataPath, 'schema', 'description'], null);\n\n    return (\n      description ||\n      formatMessage({\n        id: `${pluginId}.modelPage.contentHeader.emptyDescription.description`,\n      })\n    );\n  };\n\n  const wait = async () => {\n    togglePrompt(false);\n\n    return new Promise(resolve => setTimeout(resolve, 100));\n  };\n  const label = get(modifiedData, [firstMainDataPath, 'schema', 'name'], '');\n  const kind = get(modifiedData, [firstMainDataPath, 'schema', 'kind'], '');\n\n  const headerProps = {\n    actions: isInDevelopmentMode\n      ? [\n          {\n            color: 'cancel',\n            onClick: () => {\n              toggleModalCancel();\n            },\n            label: formatMessage({\n              id: `${pluginId}.form.button.cancel`,\n            }),\n            type: 'button',\n            disabled: isEqual(modifiedData, initialData),\n          },\n          {\n            className: 'button-submit',\n            color: 'success',\n            onClick: () => submitData(),\n            label: formatMessage({\n              id: `${pluginId}.form.button.save`,\n            }),\n            type: 'submit',\n            disabled: isEqual(modifiedData, initialData),\n          },\n        ]\n      : [],\n    title: {\n      label,\n      cta:\n        isInDevelopmentMode && !isFromPlugin\n          ? {\n              icon: 'pencil-alt',\n              onClick: async () => {\n                await wait();\n\n                const contentType = kind || firstMainDataPath;\n\n                if (contentType === 'collectionType') {\n                  emitEvent('willEditNameOfContentType');\n                }\n                if (contentType === 'singleType') {\n                  emitEvent('willEditNameOfSingleType');\n                }\n\n                push({\n                  search: makeSearch({\n                    modalType: firstMainDataPath,\n                    actionType: 'edit',\n                    settingType: 'base',\n                    forTarget: firstMainDataPath,\n                    targetUid,\n                    header_label_1: label,\n                    header_icon_isCustom_1: false,\n                    header_icon_name_1:\n                      contentType === 'singleType' ? contentType : firstMainDataPath,\n                    headerId: getTrad('modalForm.header-edit'),\n                  }),\n                });\n              },\n            }\n          : null,\n    },\n    content: getDescription(),\n  };\n\n  const listTitle = [\n    formatMessage(\n      {\n        id: `${pluginId}.table.attributes.title.${attributesLength > 1 ? 'plural' : 'singular'}`,\n      },\n      { number: attributesLength }\n    ),\n  ];\n\n  const addButtonProps = {\n    icon: true,\n    color: 'primary',\n    label: formatMessage({ id: `${pluginId}.button.attributes.add.another` }),\n    onClick: () => {\n      const headerDisplayObject = {\n        header_label_1: currentDataName,\n        header_icon_name_1: forTarget === 'contentType' ? contentTypeKind : forTarget,\n        header_icon_isCustom_1: false,\n      };\n      handleClickAddField(forTarget, targetUid, headerDisplayObject);\n    },\n  };\n\n  const listInjectedComponents = useMemo(() => {\n    return getComponents('listView', 'list.link', plugins, {\n      targetUid,\n      isTemporary,\n      isInContentTypeView,\n      contentTypeKind,\n    });\n  }, [plugins, isTemporary, targetUid, isInContentTypeView, contentTypeKind]);\n\n  const listActions = isInDevelopmentMode\n    ? [...listInjectedComponents, <ListButton {...addButtonProps} key=\"add-button\" />]\n    : listInjectedComponents;\n\n  const CustomRow = props => {\n    const { name } = props;\n\n    return <ListRow {...props} attributeName={name} name={name} onClick={handleClickEditField} />;\n  };\n\n  CustomRow.defaultProps = {\n    name: null,\n  };\n\n  CustomRow.propTypes = {\n    name: PropTypes.string,\n  };\n\n  return (\n    <ListViewContext.Provider value={{ openModalAddField: handleClickAddField }}>\n      <Wrapper>\n        <BackHeader onClick={goBack} />\n        <Prompt\n          message={formatMessage({ id: getTrad('prompt.unsaved') })}\n          when={hasModelBeenModified && enablePrompt}\n        />\n        <div className=\"container-fluid\">\n          <div className=\"row\">\n            <LeftMenu wait={wait} />\n            <div className=\"col-md-9 content\" style={{ paddingLeft: '30px', paddingRight: '30px' }}>\n              <Header {...headerProps} />\n\n              <ListWrapper style={{ marginBottom: 80 }}>\n                <ListHeader actions={listActions} title={listTitle} />\n                <List\n                  items={convertAttrObjToArray(attributes)}\n                  customRowComponent={props => <CustomRow {...props} />}\n                  addComponentToDZ={handleClickAddComponentToDZ}\n                  targetUid={targetUid}\n                  dataType={forTarget}\n                  dataTypeName={currentDataName}\n                  mainTypeName={currentDataName}\n                  editTarget={forTarget}\n                  isMain\n                />\n              </ListWrapper>\n            </div>\n          </div>\n        </div>\n      </Wrapper>\n    </ListViewContext.Provider>\n  );\n};\n\nexport default ListView;\n",
    "packages/strapi-plugin-content-type-builder/services/ContentTypes.js": "'use strict';\n\nconst _ = require('lodash');\nconst pluralize = require('pluralize');\nconst generator = require('strapi-generate');\n\nconst { nameToSlug, contentTypes: contentTypesUtils } = require('strapi-utils');\nconst { formatAttributes, replaceTemporaryUIDs } = require('../utils/attributes');\nconst createBuilder = require('./schema-builder');\nconst apiHandler = require('./api-handler');\nconst { coreUids, pluginsUids } = require('./constants');\n\nconst isContentTypeEditable = (contentType = {}) => {\n  const { uid } = contentType;\n  return !uid.startsWith(coreUids.PREFIX) && uid !== pluginsUids.UPLOAD_FILE;\n};\n\nconst getRestrictRelationsTo = (contentType = {}) => {\n  const { uid } = contentType;\n  if (uid === coreUids.STRAPI_USER) {\n    return ['oneWay', 'manyWay'];\n  }\n\n  if (uid.startsWith(coreUids.PREFIX) || uid === pluginsUids.UPLOAD_FILE) {\n    return [];\n  }\n\n  return null;\n};\n\nconst getformattedName = (contentType = {}) => {\n  const { uid, info } = contentType;\n  const name = _.get(info, 'name') || _.upperFirst(pluralize(uid));\n\n  return name;\n};\n\n/**\n * Format a contentType info to be used by the front-end\n * @param {Object} contentType\n */\nconst formatContentType = contentType => {\n  const { uid, kind, modelName, plugin, connection, collectionName, info, options } = contentType;\n\n  return {\n    uid,\n    plugin,\n    apiID: modelName,\n    schema: {\n      name: getformattedName(contentType),\n      description: _.get(info, 'description', ''),\n      draftAndPublish: contentTypesUtils.hasDraftAndPublish({ options }),\n      connection,\n      kind: kind || 'collectionType',\n      collectionName,\n      attributes: formatAttributes(contentType),\n      editable: isContentTypeEditable(contentType),\n      restrictRelationsTo: getRestrictRelationsTo(contentType),\n    },\n  };\n};\n\nconst createContentTypes = async contentTypes => {\n  const builder = createBuilder();\n  const createdContentTypes = [];\n\n  for (const contentType of contentTypes) {\n    createdContentTypes.push(await createContentType(contentType, { defaultBuilder: builder }));\n  }\n\n  await builder.writeFiles();\n\n  return createdContentTypes;\n};\n\n/**\n * Creates a content type and handle the nested components sent with it\n * @param {Object} params params object\n * @param {Object} params.contentType Main component to create\n * @param {Array<Object>} params.components List of nested components to created or edit\n * @param {Object} options\n * @param {Builder} options.defaultBuilder\n */\nconst createContentType = async ({ contentType, components = [] }, options = {}) => {\n  const builder = options.defaultBuilder || createBuilder();\n  const uidMap = builder.createNewComponentUIDMap(components);\n\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const newContentType = builder.createContentType(replaceTmpUIDs(contentType));\n\n  // allow components to target the new contentType\n  const targetContentType = infos => {\n    Object.keys(infos.attributes).forEach(key => {\n      const { target } = infos.attributes[key];\n      if (target === '__contentType__') {\n        infos.attributes[key].target = newContentType.uid;\n      }\n    });\n\n    return infos;\n  };\n\n  components.forEach(component => {\n    const options = replaceTmpUIDs(targetContentType(component));\n\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(options);\n    }\n\n    return builder.editComponent(options);\n  });\n\n  // generate api skeleton\n  await generateAPI({\n    name: contentType.name,\n    kind: contentType.kind,\n  });\n\n  if (!options.defaultBuilder) {\n    await builder.writeFiles();\n  }\n\n  return newContentType;\n};\n\n/**\n * Generate an API squeleton\n * @param {string} name\n */\nconst generateAPI = ({ name, kind = 'collectionType' }) => {\n  return new Promise((resolve, reject) => {\n    const scope = {\n      generatorType: 'api',\n      id: nameToSlug(name),\n      name: nameToSlug(name),\n      rootPath: strapi.dir,\n      args: {\n        attributes: {},\n        kind,\n      },\n    };\n\n    generator(scope, {\n      success: () => resolve(),\n      error: err => reject(err),\n    });\n  });\n};\n\n/**\n * Edits a contentType and handle the nested contentTypes sent with it\n * @param {String} uid Content-type's uid\n * @param {Object} params params object\n * @param {Object} params.contentType Main contentType to create\n * @param {Array<Object>} params.components List of nested components to created or edit\n */\nconst editContentType = async (uid, { contentType, components = [] }) => {\n  const builder = createBuilder();\n\n  const previousKind = builder.contentTypes.get(uid).schema.kind;\n  const newKind = contentType.kind || previousKind;\n\n  if (newKind !== previousKind && newKind === 'singleType') {\n    const entryCount = await strapi.query(uid).count();\n    if (entryCount > 1) {\n      throw strapi.errors.badRequest(\n        'You cannot convert a collectionType to a singleType when having multiple entries in DB'\n      );\n    }\n  }\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const updatedContentType = builder.editContentType({\n    uid,\n    ...replaceTmpUIDs(contentType),\n  });\n\n  components.forEach(component => {\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  if (newKind !== previousKind) {\n    await apiHandler.backup(uid);\n\n    try {\n      await apiHandler.clear(uid);\n\n      // generate new api skeleton\n      await generateAPI({\n        name: updatedContentType.schema.info.name,\n        kind: updatedContentType.schema.kind,\n      });\n\n      await builder.writeFiles();\n    } catch (error) {\n      strapi.log.error(error);\n      await apiHandler.rollback(uid);\n    }\n\n    return updatedContentType;\n  }\n\n  await builder.writeFiles();\n  return updatedContentType;\n};\n\nconst deleteContentTypes = async uids => {\n  const builder = createBuilder();\n\n  for (const uid of uids) {\n    await deleteContentType(uid, builder);\n  }\n\n  await builder.writeFiles();\n  for (const uid of uids) {\n    try {\n      await apiHandler.clear(uid);\n    } catch (error) {\n      strapi.log.error(error);\n      await apiHandler.rollback(uid);\n    }\n  }\n};\n\n/**\n * Deletes a content type and the api files related to it\n * @param {string} uid content type uid\n * @param defaultBuilder\n */\nconst deleteContentType = async (uid, defaultBuilder = undefined) => {\n  const builder = defaultBuilder || createBuilder();\n  // make a backup\n  await apiHandler.backup(uid);\n\n  const contentType = builder.deleteContentType(uid);\n\n  if (!defaultBuilder) {\n    try {\n      await builder.writeFiles();\n      await apiHandler.clear(uid);\n    } catch (error) {\n      await apiHandler.rollback(uid);\n    }\n  }\n\n  return contentType;\n};\n\nmodule.exports = {\n  createContentType,\n  editContentType,\n  deleteContentType,\n  formatContentType,\n  createContentTypes,\n  deleteContentTypes,\n};\n",
    "packages/strapi-plugin-upload/admin/src/components/EditForm/index.js": "/* eslint-disable jsx-a11y/anchor-is-valid */\n/* eslint-disable react/jsx-fragments */\nimport React, {\n  Fragment,\n  forwardRef,\n  useState,\n  useEffect,\n  useRef,\n  useImperativeHandle,\n} from 'react';\nimport { CopyToClipboard } from 'react-copy-to-clipboard';\nimport axios from 'axios';\nimport { get } from 'lodash';\nimport PropTypes from 'prop-types';\nimport { Row } from 'reactstrap';\nimport { Inputs } from '@buffetjs/custom';\nimport { useGlobalContext, prefixFileUrlWithBackendUrl } from 'strapi-helper-plugin';\nimport Cropper from 'cropperjs';\nimport 'cropperjs/dist/cropper.css';\nimport { createFileToDownloadName } from '../../utils';\nimport CardControl from '../CardControl';\nimport CardControlsWrapper from '../CardControlsWrapper';\nimport CardPreview from '../CardPreview';\nimport InfiniteLoadingIndicator from '../InfiniteLoadingIndicator';\nimport ModalSection from '../ModalSection';\nimport VideoPlayer from '../VideoPlayer';\nimport CropWrapper from './CropWrapper';\nimport FileDetailsBox from './FileDetailsBox';\nimport FileWrapper from './FileWrapper';\nimport FormWrapper from './FormWrapper';\nimport SizeBox from './SizeBox';\nimport Wrapper from './Wrapper';\nimport ErrorMessage from './ErrorMessage';\nimport form from './utils/form';\nimport isImageType from './utils/isImageType';\nimport isVideoType from './utils/isVideoType';\n\nconst EditForm = forwardRef(\n  (\n    {\n      canCopyLink,\n      canDownload,\n      components,\n      fileToEdit,\n      isEditingUploadedFile,\n      isFormDisabled,\n      onAbortUpload,\n      onChange,\n      onClickDeleteFileToUpload,\n      onSubmitEdit,\n      setCropResult,\n      toggleDisableForm,\n    },\n    ref\n  ) => {\n    const { formatMessage } = useGlobalContext();\n    const [isCropping, setIsCropping] = useState(false);\n    const [infos, setInfos] = useState({ width: null, height: null });\n    const [src, setSrc] = useState(null);\n    const cacheRef = useRef(performance.now());\n\n    const fileURL = get(fileToEdit, ['file', 'url'], null);\n    const prefixedFileURL = fileURL\n      ? prefixFileUrlWithBackendUrl(`${fileURL}?${cacheRef.current}`)\n      : null;\n    const downloadFileName = createFileToDownloadName(fileToEdit);\n    const mimeType =\n      get(fileToEdit, ['file', 'type'], null) || get(fileToEdit, ['file', 'mime'], '');\n    const isImg = isImageType(mimeType);\n    const isVideo = isVideoType(mimeType);\n    const canCrop = isImg && !mimeType.includes('svg') && !mimeType.includes('gif');\n    const aRef = useRef();\n    const imgRef = useRef();\n    const inputRef = useRef();\n    const cropper = useRef();\n\n    useImperativeHandle(ref, () => ({\n      click: () => {\n        inputRef.current.click();\n        setIsCropping(false);\n      },\n    }));\n\n    useEffect(() => {\n      if (isImg || isVideo) {\n        if (prefixedFileURL) {\n          setSrc(prefixedFileURL);\n        } else {\n          setSrc(URL.createObjectURL(fileToEdit.file));\n        }\n      }\n    }, [isImg, isVideo, fileToEdit, prefixedFileURL]);\n\n    useEffect(() => {\n      if (isCropping) {\n        cropper.current = new Cropper(imgRef.current, {\n          modal: true,\n          initialAspectRatio: 16 / 9,\n          movable: true,\n          zoomable: false,\n          cropBoxResizable: true,\n          background: false,\n          crop: handleResize,\n        });\n      } else if (cropper.current) {\n        cropper.current.destroy();\n\n        setInfos({ width: null, height: null });\n        toggleDisableForm(false);\n      }\n\n      return () => {\n        if (cropper.current) {\n          cropper.current.destroy();\n        }\n      };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [cropper, isCropping]);\n\n    const handleResize = ({ detail: { height, width } }) => {\n      const roundedDataHeight = Math.round(height);\n      const roundedDataWidth = Math.round(width);\n\n      setInfos({ width: roundedDataWidth, height: roundedDataHeight });\n    };\n\n    const handleToggleCropMode = () => {\n      setIsCropping(prev => {\n        if (!prev && isEditingUploadedFile) {\n          toggleDisableForm(true);\n        }\n\n        return !prev;\n      });\n    };\n\n    const handleChange = ({ target: { files } }) => {\n      if (files[0]) {\n        onChange({ target: { name: 'file', value: files[0] } });\n      }\n    };\n\n    const handleClick = async () => {\n      const cropResult = await getCroppedResult();\n\n      setCropResult(cropResult);\n\n      setIsCropping(false);\n    };\n\n    const getCroppedResult = () => {\n      return new Promise((resolve, reject) => {\n        try {\n          const canvas = cropper.current.getCroppedCanvas();\n\n          canvas.toBlob(\n            async blob => {\n              const {\n                file: { lastModifiedDate, lastModified, name },\n              } = fileToEdit;\n\n              resolve(\n                new File([blob], name, {\n                  type: mimeType,\n                  lastModified,\n                  lastModifiedDate,\n                })\n              );\n            },\n            mimeType,\n            1\n          );\n        } catch (err) {\n          reject();\n        }\n      });\n    };\n\n    const handleClickEditCroppedFile = async (e, shouldDuplicate = false) => {\n      try {\n        const file = await getCroppedResult();\n\n        onSubmitEdit(e, shouldDuplicate, file, true);\n      } catch (err) {\n        // Silent\n      } finally {\n        setIsCropping(false);\n      }\n    };\n\n    const handleClickDelete = () => {\n      onClickDeleteFileToUpload(fileToEdit.originalIndex);\n    };\n\n    const handleCopy = () => {\n      strapi.notification.toggle({\n        type: 'info',\n        message: { id: 'notification.link-copied' },\n      });\n    };\n\n    const handleClickDownload = () => {\n      axios\n        .get(prefixedFileURL, {\n          responseType: 'blob',\n        })\n        .then(({ data }) => {\n          const blobUrl = URL.createObjectURL(data);\n\n          aRef.current.download = downloadFileName;\n          aRef.current.href = blobUrl;\n\n          aRef.current.click();\n        })\n        .catch(err => {\n          console.error(err);\n        });\n    };\n\n    const handleSubmit = e => {\n      e.preventDefault();\n\n      onSubmitEdit(e);\n    };\n\n    const CheckButton = components.CheckControl;\n\n    return (\n      <form onSubmit={handleSubmit}>\n        <ModalSection>\n          <Wrapper>\n            <div className=\"row\">\n              <div className=\"col-6\">\n                <FileWrapper hasError={fileToEdit.hasError}>\n                  {fileToEdit.isUploading ? (\n                    <InfiniteLoadingIndicator onClick={onAbortUpload} />\n                  ) : (\n                    <Fragment>\n                      <CardControlsWrapper className=\"card-control-wrapper-displayed\">\n                        {!isCropping ? (\n                          <>\n                            <CardControl\n                              color=\"#9EA7B8\"\n                              type=\"trash-alt\"\n                              onClick={handleClickDelete}\n                              title=\"delete\"\n                            />\n                            {fileURL && (\n                              <>\n                                {canDownload && (\n                                  <CardControl\n                                    color=\"#9EA7B8\"\n                                    onClick={handleClickDownload}\n                                    type=\"download\"\n                                    title=\"download\"\n                                  />\n                                )}\n                                <a\n                                  title={fileToEdit.fileInfo.name}\n                                  style={{ display: 'none' }}\n                                  ref={aRef}\n                                >\n                                  hidden\n                                </a>\n                                {canCopyLink && (\n                                  <CopyToClipboard\n                                    onCopy={handleCopy}\n                                    text={prefixFileUrlWithBackendUrl(fileURL)}\n                                  >\n                                    <CardControl color=\"#9EA7B8\" type=\"link\" title=\"copy-link\" />\n                                  </CopyToClipboard>\n                                )}\n                              </>\n                            )}\n                            {canCrop && (\n                              <CardControl\n                                color=\"#9EA7B8\"\n                                onClick={handleToggleCropMode}\n                                type=\"crop\"\n                                title=\"crop\"\n                              />\n                            )}\n                          </>\n                        ) : (\n                          <>\n                            <CardControl\n                              color=\"#F64D0A\"\n                              onClick={handleToggleCropMode}\n                              type=\"times\"\n                              title=\"cancel\"\n                              iconStyle={{ height: '1.6rem', width: '1.6rem' }}\n                            />\n                            <CheckButton\n                              color=\"#6DBB1A\"\n                              onClick={handleClick}\n                              onSubmitEdit={handleClickEditCroppedFile}\n                              type=\"check\"\n                              title=\"save\"\n                            />\n                          </>\n                        )}\n                      </CardControlsWrapper>\n                      {isImg ? (\n                        <CropWrapper>\n                          <img\n                            src={src}\n                            alt={get(fileToEdit, ['file', 'name'], '')}\n                            ref={isCropping ? imgRef : null}\n                          />\n                        </CropWrapper>\n                      ) : (\n                        <>\n                          {isVideo ? (\n                            <VideoPlayer src={src} />\n                          ) : (\n                            <CardPreview type={mimeType} url={src} />\n                          )}\n                        </>\n                      )}\n\n                      {isCropping && infos.width !== null && (\n                        <SizeBox>\n                          &nbsp;\n                          {infos.width} x {infos.height}\n                          &nbsp;\n                        </SizeBox>\n                      )}\n                    </Fragment>\n                  )}\n                </FileWrapper>\n                {fileToEdit.hasError && (\n                  <ErrorMessage title={fileToEdit.errorMessage}>\n                    {fileToEdit.errorMessage}\n                  </ErrorMessage>\n                )}\n              </div>\n              <div className=\"col-6\">\n                <FileDetailsBox file={fileToEdit.file} />\n                <FormWrapper>\n                  {form.map(({ key, inputs }) => {\n                    return (\n                      <Row key={key}>\n                        {inputs.map(input => {\n                          return (\n                            <div className=\"col-12\" key={input.name}>\n                              <Inputs\n                                {...input}\n                                disabled={isFormDisabled}\n                                description={\n                                  input.description ? formatMessage(input.description) : null\n                                }\n                                label={formatMessage(input.label)}\n                                onChange={onChange}\n                                type=\"text\"\n                                value={get(fileToEdit, input.name, '')}\n                              />\n                            </div>\n                          );\n                        })}\n                      </Row>\n                    );\n                  })}\n                </FormWrapper>\n              </div>\n            </div>\n          </Wrapper>\n          <input\n            ref={inputRef}\n            type=\"file\"\n            multiple={false}\n            onChange={handleChange}\n            style={{ display: 'none' }}\n            accept={mimeType\n              .split('/')\n              .map((v, i) => {\n                if (i === 1) {\n                  return '*';\n                }\n\n                return v;\n              })\n              .join('/')}\n          />\n          <button type=\"submit\" style={{ display: 'none' }}>\n            hidden button to make to get the native form event\n          </button>\n        </ModalSection>\n      </form>\n    );\n  }\n);\n\nEditForm.defaultProps = {\n  canCopyLink: true,\n  canDownload: true,\n  components: {\n    CheckControl: CardControl,\n  },\n  fileToEdit: null,\n  isEditingUploadedFile: false,\n  isFormDisabled: false,\n  onAbortUpload: () => {},\n  onChange: () => {},\n  onClickDeleteFileToUpload: () => {},\n  onSubmitEdit: e => e.preventDefault(),\n  setCropResult: () => {},\n  toggleDisableForm: () => {},\n};\n\nEditForm.propTypes = {\n  canCopyLink: PropTypes.bool,\n  canDownload: PropTypes.bool,\n  onAbortUpload: PropTypes.func,\n  components: PropTypes.object,\n  fileToEdit: PropTypes.object,\n  isEditingUploadedFile: PropTypes.bool,\n  isFormDisabled: PropTypes.bool,\n  onChange: PropTypes.func,\n  onClickDeleteFileToUpload: PropTypes.func,\n  onSubmitEdit: PropTypes.func,\n  setCropResult: PropTypes.func,\n  toggleDisableForm: PropTypes.func,\n};\n\nexport default EditForm;\n",
    "packages/strapi-plugin-upload/utils/file.js": "'use strict';\n/**\n * Utils file containing file treatment utils\n */\n\nconst bytesToKbytes = bytes => Math.round((bytes / 1000) * 100) / 100;\n\nconst streamToBuffer = stream =>\n  new Promise((resolve, reject) => {\n    const chunks = [];\n    stream.on('data', chunk => {\n      chunks.push(chunk);\n    });\n    stream.on('end', () => {\n      resolve(Buffer.concat(chunks));\n    });\n    stream.on('error', reject);\n  });\n\nmodule.exports = {\n  streamToBuffer,\n  bytesToKbytes,\n};\n",
    "packages/strapi-plugin-users-permissions/services/Jwt.js": "'use strict';\n\n/**\n * Jwt.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\nconst _ = require('lodash');\nconst jwt = require('jsonwebtoken');\n\nmodule.exports = {\n  getToken(ctx) {\n    const params = _.assign({}, ctx.request.body, ctx.request.query);\n\n    let token = '';\n\n    if (ctx.request && ctx.request.header && ctx.request.header.authorization) {\n      const parts = ctx.request.header.authorization.split(' ');\n\n      if (parts.length === 2) {\n        const scheme = parts[0];\n        const credentials = parts[1];\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        }\n      } else {\n        throw new Error(\n          'Invalid authorization header format. Format is Authorization: Bearer [token]'\n        );\n      }\n    } else if (params.token) {\n      token = params.token;\n    } else {\n      throw new Error('No authorization header was found');\n    }\n\n    return this.verify(token);\n  },\n\n  issue(payload, jwtOptions = {}) {\n    _.defaults(jwtOptions, strapi.plugins['users-permissions'].config.jwt);\n    return jwt.sign(\n      _.clone(payload.toJSON ? payload.toJSON() : payload),\n      _.get(strapi.plugins, ['users-permissions', 'config', 'jwtSecret']),\n      jwtOptions\n    );\n  },\n\n  verify(token) {\n    return new Promise(function(resolve, reject) {\n      jwt.verify(\n        token,\n        _.get(strapi.plugins, ['users-permissions', 'config', 'jwtSecret']),\n        {},\n        function(err, tokenPayload = {}) {\n          if (err) {\n            return reject(new Error('Invalid token.'));\n          }\n          resolve(tokenPayload);\n        }\n      );\n    });\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/services/Providers.js": "'use strict';\n\n/**\n * Module dependencies.\n */\n\n// Public node modules.\nconst _ = require('lodash');\nconst request = require('request');\n\n// Purest strategies.\nconst purest = require('purest')({ request });\nconst purestConfig = require('@purest/providers');\nconst { getAbsoluteServerUrl } = require('strapi-utils');\nconst jwt = require('jsonwebtoken');\n\n/**\n * Connect thanks to a third-party provider.\n *\n *\n * @param {String}    provider\n * @param {String}    access_token\n *\n * @return  {*}\n */\n\nconst connect = (provider, query) => {\n  const access_token = query.access_token || query.code || query.oauth_token;\n\n  return new Promise((resolve, reject) => {\n    if (!access_token) {\n      return reject([null, { message: 'No access_token.' }]);\n    }\n\n    // Get the profile.\n    getProfile(provider, query, async (err, profile) => {\n      if (err) {\n        return reject([null, err]);\n      }\n\n      // We need at least the mail.\n      if (!profile.email) {\n        return reject([null, { message: 'Email was not available.' }]);\n      }\n\n      try {\n        const users = await strapi.query('user', 'users-permissions').find({\n          email: profile.email,\n        });\n\n        const advanced = await strapi\n          .store({\n            environment: '',\n            type: 'plugin',\n            name: 'users-permissions',\n            key: 'advanced',\n          })\n          .get();\n\n        const user = _.find(users, { provider });\n\n        if (_.isEmpty(user) && !advanced.allow_register) {\n          return resolve([\n            null,\n            [{ messages: [{ id: 'Auth.advanced.allow_register' }] }],\n            'Register action is actualy not available.',\n          ]);\n        }\n\n        if (!_.isEmpty(user)) {\n          return resolve([user, null]);\n        }\n\n        if (\n          !_.isEmpty(_.find(users, user => user.provider !== provider)) &&\n          advanced.unique_email\n        ) {\n          return resolve([\n            null,\n            [{ messages: [{ id: 'Auth.form.error.email.taken' }] }],\n            'Email is already taken.',\n          ]);\n        }\n\n        // Retrieve default role.\n        const defaultRole = await strapi\n          .query('role', 'users-permissions')\n          .findOne({ type: advanced.default_role }, []);\n\n        // Create the new user.\n        const params = _.assign(profile, {\n          provider: provider,\n          role: defaultRole.id,\n          confirmed: true,\n        });\n\n        const createdUser = await strapi.query('user', 'users-permissions').create(params);\n\n        return resolve([createdUser, null]);\n      } catch (err) {\n        reject([null, err]);\n      }\n    });\n  });\n};\n\n/**\n * Helper to get profiles\n *\n * @param {String}   provider\n * @param {Function} callback\n */\n\nconst getProfile = async (provider, query, callback) => {\n  const access_token = query.access_token || query.code || query.oauth_token;\n\n  const grant = await strapi\n    .store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n      key: 'grant',\n    })\n    .get();\n\n  switch (provider) {\n    case 'discord': {\n      const discord = purest({\n        provider: 'discord',\n        config: {\n          discord: {\n            'https://discordapp.com/api/': {\n              __domain: {\n                auth: {\n                  auth: { bearer: '[0]' },\n                },\n              },\n              '{endpoint}': {\n                __path: {\n                  alias: '__default',\n                },\n              },\n            },\n          },\n        },\n      });\n      discord\n        .query()\n        .get('users/@me')\n        .auth(access_token)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            // Combine username and discriminator because discord username is not unique\n            var username = `${body.username}#${body.discriminator}`;\n            callback(null, {\n              username: username,\n              email: body.email,\n            });\n          }\n        });\n      break;\n    }\n    case 'cognito': {\n      // get the id_token\n      const idToken = query.id_token;\n      // decode the jwt token\n      const tokenPayload = jwt.decode(idToken);\n      if (!tokenPayload) {\n        callback(new Error('unable to decode jwt token'));\n      } else {\n        callback(null, {\n          username: tokenPayload['cognito:username'],\n          email: tokenPayload.email,\n        });\n      }\n      break;\n    }\n    case 'facebook': {\n      const facebook = purest({\n        provider: 'facebook',\n        config: purestConfig,\n      });\n\n      facebook\n        .query()\n        .get('me?fields=name,email')\n        .auth(access_token)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.name,\n              email: body.email,\n            });\n          }\n        });\n      break;\n    }\n    case 'google': {\n      const google = purest({ provider: 'google', config: purestConfig });\n\n      google\n        .query('oauth')\n        .get('tokeninfo')\n        .qs({ access_token })\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.email.split('@')[0],\n              email: body.email,\n            });\n          }\n        });\n      break;\n    }\n    case 'github': {\n      const github = purest({\n        provider: 'github',\n        config: purestConfig,\n        defaults: {\n          headers: {\n            'user-agent': 'strapi',\n          },\n        },\n      });\n\n      github\n        .query()\n        .get('user')\n        .auth(access_token)\n        .request((err, res, userbody) => {\n          if (err) {\n            return callback(err);\n          }\n\n          // This is the public email on the github profile\n          if (userbody.email) {\n            return callback(null, {\n              username: userbody.login,\n              email: userbody.email,\n            });\n          }\n\n          // Get the email with Github's user/emails API\n          github\n            .query()\n            .get('user/emails')\n            .auth(access_token)\n            .request((err, res, emailsbody) => {\n              if (err) {\n                return callback(err);\n              }\n\n              return callback(null, {\n                username: userbody.login,\n                email: Array.isArray(emailsbody)\n                  ? emailsbody.find(email => email.primary === true).email\n                  : null,\n              });\n            });\n        });\n      break;\n    }\n    case 'microsoft': {\n      const microsoft = purest({\n        provider: 'microsoft',\n        config: purestConfig,\n      });\n\n      microsoft\n        .query()\n        .get('me')\n        .auth(access_token)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.userPrincipalName,\n              email: body.userPrincipalName,\n            });\n          }\n        });\n      break;\n    }\n    case 'twitter': {\n      const twitter = purest({\n        provider: 'twitter',\n        config: purestConfig,\n        key: grant.twitter.key,\n        secret: grant.twitter.secret,\n      });\n\n      twitter\n        .query()\n        .get('account/verify_credentials')\n        .auth(access_token, query.access_secret)\n        .qs({ screen_name: query['raw[screen_name]'], include_email: 'true' })\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.screen_name,\n              email: body.email,\n            });\n          }\n        });\n      break;\n    }\n    case 'instagram': {\n      const instagram = purest({\n        provider: 'instagram',\n        key: grant.instagram.key,\n        secret: grant.instagram.secret,\n        config: purestConfig,\n      });\n\n      instagram\n        .query()\n        .get('me')\n        .qs({ access_token, fields: 'id,username' })\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.username,\n              email: `${body.username}@strapi.io`, // dummy email as Instagram does not provide user email\n            });\n          }\n        });\n      break;\n    }\n    case 'vk': {\n      const vk = purest({\n        provider: 'vk',\n        config: purestConfig,\n      });\n\n      vk.query()\n        .get('users.get')\n        .qs({ access_token, id: query.raw.user_id, v: '5.122' })\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: `${body.response[0].last_name} ${body.response[0].first_name}`,\n              email: query.raw.email,\n            });\n          }\n        });\n      break;\n    }\n    case 'twitch': {\n      const twitch = purest({\n        provider: 'twitch',\n        config: {\n          twitch: {\n            'https://api.twitch.tv': {\n              __domain: {\n                auth: {\n                  headers: {\n                    Authorization: 'Bearer [0]',\n                    'Client-ID': '[1]',\n                  },\n                },\n              },\n              'helix/{endpoint}': {\n                __path: {\n                  alias: '__default',\n                },\n              },\n              'oauth2/{endpoint}': {\n                __path: {\n                  alias: 'oauth',\n                },\n              },\n            },\n          },\n        },\n      });\n\n      twitch\n        .get('users')\n        .auth(access_token, grant.twitch.key)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.data[0].login,\n              email: body.data[0].email,\n            });\n          }\n        });\n      break;\n    }\n    case 'linkedin': {\n      const linkedIn = purest({\n        provider: 'linkedin',\n        config: {\n          linkedin: {\n            'https://api.linkedin.com': {\n              __domain: {\n                auth: [{ auth: { bearer: '[0]' } }],\n              },\n              '[version]/{endpoint}': {\n                __path: {\n                  alias: '__default',\n                  version: 'v2',\n                },\n              },\n            },\n          },\n        },\n      });\n      try {\n        const getDetailsRequest = () => {\n          return new Promise((resolve, reject) => {\n            linkedIn\n              .query()\n              .get('me')\n              .auth(access_token)\n              .request((err, res, body) => {\n                if (err) {\n                  return reject(err);\n                }\n                resolve(body);\n              });\n          });\n        };\n\n        const getEmailRequest = () => {\n          return new Promise((resolve, reject) => {\n            linkedIn\n              .query()\n              .get('emailAddress?q=members&projection=(elements*(handle~))')\n              .auth(access_token)\n              .request((err, res, body) => {\n                if (err) {\n                  return reject(err);\n                }\n                resolve(body);\n              });\n          });\n        };\n\n        const { localizedFirstName } = await getDetailsRequest();\n        const { elements } = await getEmailRequest();\n        const email = elements[0]['handle~'];\n\n        callback(null, {\n          username: localizedFirstName,\n          email: email.emailAddress,\n        });\n      } catch (err) {\n        callback(err);\n      }\n      break;\n    }\n    case 'reddit': {\n      const reddit = purest({\n        provider: 'reddit',\n        config: purestConfig,\n        defaults: {\n          headers: {\n            'user-agent': 'strapi',\n          },\n        },\n      });\n\n      reddit\n        .query('auth')\n        .get('me')\n        .auth(access_token)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            callback(null, {\n              username: body.name,\n              email: `${body.name}@strapi.io`, // dummy email as Reddit does not provide user email\n            });\n          }\n        });\n      break;\n    }\n    case 'auth0': {\n      const purestAuth0Conf = {};\n      purestAuth0Conf[`https://${grant.auth0.subdomain}.auth0.com`] = {\n        __domain: {\n          auth: {\n            auth: { bearer: '[0]' },\n          },\n        },\n        '{endpoint}': {\n          __path: {\n            alias: '__default',\n          },\n        },\n      };\n      const auth0 = purest({\n        provider: 'auth0',\n        config: {\n          auth0: purestAuth0Conf,\n        },\n      });\n\n      auth0\n        .get('userinfo')\n        .auth(access_token)\n        .request((err, res, body) => {\n          if (err) {\n            callback(err);\n          } else {\n            const username =\n              body.username || body.nickname || body.name || body.email.split('@')[0];\n            const email = body.email || `${username.replace(/\\s+/g, '.')}@strapi.io`;\n\n            callback(null, {\n              username,\n              email,\n            });\n          }\n        });\n      break;\n    }\n    default:\n      callback(new Error('Unknown provider.'));\n      break;\n  }\n};\n\nconst buildRedirectUri = (provider = '') =>\n  `${getAbsoluteServerUrl(strapi.config)}/connect/${provider}/callback`;\n\nmodule.exports = {\n  connect,\n  buildRedirectUri,\n};\n",
    "packages/strapi-plugin-users-permissions/services/User.js": "'use strict';\n\n/**\n * User.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\nconst crypto = require('crypto');\nconst bcrypt = require('bcryptjs');\n\nconst { sanitizeEntity, getAbsoluteServerUrl } = require('strapi-utils');\n\nmodule.exports = {\n  /**\n   * Promise to count users\n   *\n   * @return {Promise}\n   */\n\n  count(params) {\n    return strapi.query('user', 'users-permissions').count(params);\n  },\n\n  /**\n   * Promise to search count users\n   *\n   * @return {Promise}\n   */\n\n  countSearch(params) {\n    return strapi.query('user', 'users-permissions').countSearch(params);\n  },\n\n  /**\n   * Promise to add a/an user.\n   * @return {Promise}\n   */\n  async add(values) {\n    if (values.password) {\n      values.password = await strapi.plugins['users-permissions'].services.user.hashPassword(\n        values\n      );\n    }\n\n    return strapi.query('user', 'users-permissions').create(values);\n  },\n\n  /**\n   * Promise to edit a/an user.\n   * @return {Promise}\n   */\n  async edit(params, values) {\n    if (values.password) {\n      values.password = await strapi.plugins['users-permissions'].services.user.hashPassword(\n        values\n      );\n    }\n\n    return strapi.query('user', 'users-permissions').update(params, values);\n  },\n\n  /**\n   * Promise to fetch a/an user.\n   * @return {Promise}\n   */\n  fetch(params, populate) {\n    return strapi.query('user', 'users-permissions').findOne(params, populate);\n  },\n\n  /**\n   * Promise to fetch authenticated user.\n   * @return {Promise}\n   */\n  fetchAuthenticatedUser(id) {\n    return strapi.query('user', 'users-permissions').findOne({ id }, ['role']);\n  },\n\n  /**\n   * Promise to fetch all users.\n   * @return {Promise}\n   */\n  fetchAll(params, populate) {\n    return strapi.query('user', 'users-permissions').find(params, populate);\n  },\n\n  hashPassword(user = {}) {\n    return new Promise((resolve, reject) => {\n      if (!user.password || this.isHashed(user.password)) {\n        resolve(null);\n      } else {\n        bcrypt.hash(`${user.password}`, 10, (err, hash) => {\n          if (err) {\n            return reject(err);\n          }\n          resolve(hash);\n        });\n      }\n    });\n  },\n\n  isHashed(password) {\n    if (typeof password !== 'string' || !password) {\n      return false;\n    }\n\n    return password.split('$').length === 4;\n  },\n\n  /**\n   * Promise to remove a/an user.\n   * @return {Promise}\n   */\n  async remove(params) {\n    return strapi.query('user', 'users-permissions').delete(params);\n  },\n\n  async removeAll(params) {\n    return strapi.query('user', 'users-permissions').delete(params);\n  },\n\n  validatePassword(password, hash) {\n    return bcrypt.compare(password, hash);\n  },\n\n  async sendConfirmationEmail(user) {\n    const userPermissionService = strapi.plugins['users-permissions'].services.userspermissions;\n    const pluginStore = await strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n    });\n\n    const settings = await pluginStore\n      .get({ key: 'email' })\n      .then(storeEmail => storeEmail['email_confirmation'].options);\n\n    const userInfo = sanitizeEntity(user, {\n      model: strapi.query('user', 'users-permissions').model,\n    });\n\n    const confirmationToken = crypto.randomBytes(20).toString('hex');\n\n    await this.edit({ id: user.id }, { confirmationToken });\n\n    settings.message = await userPermissionService.template(settings.message, {\n      URL: `${getAbsoluteServerUrl(strapi.config)}/auth/email-confirmation`,\n      USER: userInfo,\n      CODE: confirmationToken,\n    });\n\n    settings.object = await userPermissionService.template(settings.object, { USER: userInfo });\n\n    // Send an email to the user.\n    await strapi.plugins['email'].services.email.send({\n      to: user.email,\n      from:\n        settings.from.email && settings.from.name\n          ? `${settings.from.name} <${settings.from.email}>`\n          : undefined,\n      replyTo: settings.response_email,\n      subject: settings.object,\n      text: settings.message,\n      html: settings.message,\n    });\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/services/UsersPermissions.js": "'use strict';\n\nconst _ = require('lodash');\nconst request = require('request');\n\n/**\n * UsersPermissions.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\nconst DEFAULT_PERMISSIONS = [\n  { action: 'admincallback', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  { action: 'adminregister', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  { action: 'callback', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  { action: 'connect', controller: 'auth', type: 'users-permissions', roleType: null },\n  { action: 'forgotpassword', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  { action: 'register', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  {\n    action: 'emailconfirmation',\n    controller: 'auth',\n    type: 'users-permissions',\n    roleType: 'public',\n  },\n  { action: 'resetpassword', controller: 'auth', type: 'users-permissions', roleType: 'public' },\n  { action: 'init', controller: 'userspermissions', type: null, roleType: null },\n  { action: 'me', controller: 'user', type: 'users-permissions', roleType: null },\n  { action: 'autoreload', controller: null, type: null, roleType: null },\n];\n\nconst isPermissionEnabled = (permission, role) =>\n  DEFAULT_PERMISSIONS.some(\n    defaultPerm =>\n      (defaultPerm.action === null || permission.action === defaultPerm.action) &&\n      (defaultPerm.controller === null || permission.controller === defaultPerm.controller) &&\n      (defaultPerm.type === null || permission.type === defaultPerm.type) &&\n      (defaultPerm.roleType === null || role.type === defaultPerm.roleType)\n  );\n\nmodule.exports = {\n  async createRole(params) {\n    if (!params.type) {\n      params.type = _.snakeCase(_.deburr(_.toLower(params.name)));\n    }\n\n    const role = await strapi\n      .query('role', 'users-permissions')\n      .create(_.omit(params, ['users', 'permissions']));\n\n    const arrayOfPromises = Object.keys(params.permissions || {}).reduce((acc, type) => {\n      Object.keys(params.permissions[type].controllers).forEach(controller => {\n        Object.keys(params.permissions[type].controllers[controller]).forEach(action => {\n          acc.push(\n            strapi.query('permission', 'users-permissions').create({\n              role: role.id,\n              type,\n              controller,\n              action: action.toLowerCase(),\n              ...params.permissions[type].controllers[controller][action],\n            })\n          );\n        });\n      });\n\n      return acc;\n    }, []);\n\n    // Use Content Manager business logic to handle relation.\n    if (params.users && params.users.length > 0)\n      arrayOfPromises.push(\n        strapi.query('role', 'users-permissions').update(\n          {\n            id: role.id,\n          },\n          { users: params.users }\n        )\n      );\n\n    return await Promise.all(arrayOfPromises);\n  },\n\n  async deleteRole(roleID, publicRoleID) {\n    const role = await strapi\n      .query('role', 'users-permissions')\n      .findOne({ id: roleID }, ['users', 'permissions']);\n\n    if (!role) {\n      throw new Error('Cannot found this role');\n    }\n\n    // Move users to guest role.\n    const arrayOfPromises = role.users.reduce((acc, user) => {\n      acc.push(\n        strapi.query('user', 'users-permissions').update(\n          {\n            id: user.id,\n          },\n          {\n            role: publicRoleID,\n          }\n        )\n      );\n\n      return acc;\n    }, []);\n\n    // Remove permissions related to this role.\n    role.permissions.forEach(permission => {\n      arrayOfPromises.push(\n        strapi.query('permission', 'users-permissions').delete({\n          id: permission.id,\n        })\n      );\n    });\n\n    // Delete the role.\n    arrayOfPromises.push(strapi.query('role', 'users-permissions').delete({ id: roleID }));\n\n    return await Promise.all(arrayOfPromises);\n  },\n\n  getPlugins(lang = 'en') {\n    return new Promise(resolve => {\n      request(\n        {\n          uri: `https://marketplace.strapi.io/plugins?lang=${lang}`,\n          json: true,\n          timeout: 3000,\n          headers: {\n            'cache-control': 'max-age=3600',\n          },\n        },\n        (err, response, body) => {\n          if (err || response.statusCode !== 200) {\n            return resolve([]);\n          }\n\n          resolve(body);\n        }\n      );\n    });\n  },\n\n  getActions() {\n    const generateActions = data =>\n      Object.keys(data).reduce((acc, key) => {\n        if (_.isFunction(data[key])) {\n          acc[key] = { enabled: false, policy: '' };\n        }\n\n        return acc;\n      }, {});\n\n    const appControllers = Object.keys(strapi.api || {})\n      .filter(key => !!strapi.api[key].controllers)\n      .reduce(\n        (acc, key) => {\n          Object.keys(strapi.api[key].controllers).forEach(controller => {\n            acc.controllers[controller] = generateActions(strapi.api[key].controllers[controller]);\n          });\n\n          return acc;\n        },\n        { controllers: {} }\n      );\n\n    const pluginsPermissions = Object.keys(strapi.plugins).reduce((acc, key) => {\n      const initialState = {\n        controllers: {},\n      };\n\n      acc[key] = Object.keys(strapi.plugins[key].controllers).reduce((obj, k) => {\n        obj.controllers[k] = generateActions(strapi.plugins[key].controllers[k]);\n\n        return obj;\n      }, initialState);\n\n      return acc;\n    }, {});\n\n    const permissions = {\n      application: {\n        controllers: appControllers.controllers,\n      },\n    };\n\n    return _.merge(permissions, pluginsPermissions);\n  },\n\n  async getRole(roleID, plugins) {\n    const role = await strapi\n      .query('role', 'users-permissions')\n      .findOne({ id: roleID }, ['permissions']);\n\n    if (!role) {\n      throw new Error('Cannot find this role');\n    }\n\n    // Group by `type`.\n    const permissions = role.permissions.reduce((acc, permission) => {\n      _.set(acc, `${permission.type}.controllers.${permission.controller}.${permission.action}`, {\n        enabled: _.toNumber(permission.enabled) == true,\n        policy: permission.policy,\n      });\n\n      if (permission.type !== 'application' && !acc[permission.type].information) {\n        acc[permission.type].information =\n          plugins.find(plugin => plugin.id === permission.type) || {};\n      }\n\n      return acc;\n    }, {});\n\n    return {\n      ...role,\n      permissions,\n    };\n  },\n\n  async getRoles() {\n    const roles = await strapi.query('role', 'users-permissions').find({ _sort: 'name' }, []);\n\n    for (let i = 0; i < roles.length; ++i) {\n      roles[i].nb_users = await strapi\n        .query('user', 'users-permissions')\n        .count({ role: roles[i].id });\n    }\n\n    return roles;\n  },\n\n  async getRoutes() {\n    const routes = Object.keys(strapi.api || {}).reduce((acc, current) => {\n      return acc.concat(_.get(strapi.api[current].config, 'routes', []));\n    }, []);\n    const clonedPlugins = _.cloneDeep(strapi.plugins);\n    const pluginsRoutes = Object.keys(clonedPlugins || {}).reduce((acc, current) => {\n      const routes = _.get(clonedPlugins, [current, 'config', 'routes'], []).reduce((acc, curr) => {\n        const prefix = curr.config.prefix;\n        const path = prefix !== undefined ? `${prefix}${curr.path}` : `/${current}${curr.path}`;\n        _.set(curr, 'path', path);\n\n        return acc.concat(curr);\n      }, []);\n\n      acc[current] = routes;\n\n      return acc;\n    }, {});\n\n    return _.merge({ application: routes }, pluginsRoutes);\n  },\n\n  async updatePermissions() {\n    const { primaryKey } = strapi.query('permission', 'users-permissions');\n    const roles = await strapi.query('role', 'users-permissions').find({}, []);\n    const rolesMap = roles.reduce((map, role) => ({ ...map, [role[primaryKey]]: role }), {});\n\n    const dbPermissions = await strapi\n      .query('permission', 'users-permissions')\n      .find({ _limit: -1 });\n    let permissionsFoundInDB = dbPermissions.map(\n      p => `${p.type}.${p.controller}.${p.action}.${p.role[primaryKey]}`\n    );\n    permissionsFoundInDB = _.uniq(permissionsFoundInDB);\n\n    // Aggregate first level actions.\n    const appActions = Object.keys(strapi.api || {}).reduce((acc, api) => {\n      Object.keys(_.get(strapi.api[api], 'controllers', {})).forEach(controller => {\n        const actions = Object.keys(strapi.api[api].controllers[controller])\n          .filter(action => _.isFunction(strapi.api[api].controllers[controller][action]))\n          .map(action => `application.${controller}.${action.toLowerCase()}`);\n\n        acc = acc.concat(actions);\n      });\n\n      return acc;\n    }, []);\n\n    // Aggregate plugins' actions.\n    const pluginsActions = Object.keys(strapi.plugins).reduce((acc, plugin) => {\n      Object.keys(strapi.plugins[plugin].controllers).forEach(controller => {\n        const actions = Object.keys(strapi.plugins[plugin].controllers[controller])\n          .filter(action => _.isFunction(strapi.plugins[plugin].controllers[controller][action]))\n          .map(action => `${plugin}.${controller}.${action.toLowerCase()}`);\n\n        acc = acc.concat(actions);\n      });\n\n      return acc;\n    }, []);\n\n    const actionsFoundInFiles = appActions.concat(pluginsActions);\n\n    // create permissions for each role\n    let permissionsFoundInFiles = actionsFoundInFiles.reduce(\n      (acc, action) => [...acc, ...roles.map(role => `${action}.${role[primaryKey]}`)],\n      []\n    );\n    permissionsFoundInFiles = _.uniq(permissionsFoundInFiles);\n\n    // Compare to know if actions have been added or removed from controllers.\n    if (!_.isEqual(permissionsFoundInDB.sort(), permissionsFoundInFiles.sort())) {\n      const splitted = str => {\n        const [type, controller, action, roleId] = str.split('.');\n\n        return { type, controller, action, roleId };\n      };\n\n      // We have to know the difference to add or remove the permissions entries in the database.\n      const toRemove = _.difference(permissionsFoundInDB, permissionsFoundInFiles).map(splitted);\n      const toAdd = _.difference(permissionsFoundInFiles, permissionsFoundInDB).map(splitted);\n\n      const query = strapi.query('permission', 'users-permissions');\n\n      // Execute request to update entries in database for each role.\n      await Promise.all(\n        toAdd.map(permission =>\n          query.create({\n            type: permission.type,\n            controller: permission.controller,\n            action: permission.action,\n            enabled: isPermissionEnabled(permission, rolesMap[permission.roleId]),\n            policy: '',\n            role: permission.roleId,\n          })\n        )\n      );\n\n      await Promise.all(\n        toRemove.map(permission => {\n          const { type, controller, action, roleId: role } = permission;\n          return query.delete({ type, controller, action, role });\n        })\n      );\n    }\n  },\n\n  async initialize() {\n    const roleCount = await strapi.query('role', 'users-permissions').count();\n\n    if (roleCount === 0) {\n      await strapi.query('role', 'users-permissions').create({\n        name: 'Authenticated',\n        description: 'Default role given to authenticated user.',\n        type: 'authenticated',\n      });\n\n      await strapi.query('role', 'users-permissions').create({\n        name: 'Public',\n        description: 'Default role given to unauthenticated user.',\n        type: 'public',\n      });\n    }\n\n    return this.updatePermissions();\n  },\n\n  async updateRole(roleID, body) {\n    const [role, authenticated] = await Promise.all([\n      this.getRole(roleID, []),\n      strapi.query('role', 'users-permissions').findOne({ type: 'authenticated' }, []),\n    ]);\n\n    await strapi\n      .query('role', 'users-permissions')\n      .update({ id: roleID }, _.pick(body, ['name', 'description']));\n\n    await Promise.all(\n      Object.keys(body.permissions || {}).reduce((acc, type) => {\n        Object.keys(body.permissions[type].controllers).forEach(controller => {\n          Object.keys(body.permissions[type].controllers[controller]).forEach(action => {\n            const bodyAction = body.permissions[type].controllers[controller][action];\n            const currentAction = _.get(\n              role.permissions,\n              `${type}.controllers.${controller}.${action}`,\n              {}\n            );\n\n            if (!_.isEqual(bodyAction, currentAction)) {\n              acc.push(\n                strapi.query('permission', 'users-permissions').update(\n                  {\n                    role: roleID,\n                    type,\n                    controller,\n                    action: action.toLowerCase(),\n                  },\n                  bodyAction\n                )\n              );\n            }\n          });\n        });\n\n        return acc;\n      }, [])\n    );\n\n    // Add user to this role.\n    const newUsers = _.differenceBy(body.users, role.users, 'id');\n    await Promise.all(newUsers.map(user => this.updateUserRole(user, roleID)));\n\n    const oldUsers = _.differenceBy(role.users, body.users, 'id');\n    await Promise.all(oldUsers.map(user => this.updateUserRole(user, authenticated.id)));\n  },\n\n  async updateUserRole(user, role) {\n    return strapi.query('user', 'users-permissions').update({ id: user.id }, { role });\n  },\n\n  template(layout, data) {\n    const compiledObject = _.template(layout);\n    return compiledObject(data);\n  },\n};\n",
    "packages/strapi-provider-email-amazon-ses/lib/index.js": "'use strict';\n\nconst nodeSES = require('node-ses');\nconst { removeUndefined } = require('strapi-utils');\n\nmodule.exports = {\n  init: (providerOptions = {}, settings = {}) => {\n    var client = nodeSES.createClient({ ...providerOptions });\n\n    return {\n      send: options => {\n        return new Promise((resolve, reject) => {\n          const { from, to, cc, bcc, replyTo, subject, text, html, ...rest } = options;\n\n          let msg = {\n            from: from || settings.defaultFrom,\n            to,\n            cc,\n            bcc,\n            replyTo: replyTo || settings.defaultReplyTo,\n            subject,\n            altText: text,\n            message: html,\n            ...rest,\n          };\n          client.sendEmail(removeUndefined(msg), function(err) {\n            if (err) {\n              if (err.Message) {\n                reject(`${err.Message} ${err.Detail ? err.Detail : ''}`);\n              }\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-email-mailgun/lib/index.js": "'use strict';\n\nconst mailgunFactory = require('mailgun-js');\nconst { removeUndefined } = require('strapi-utils');\n\nmodule.exports = {\n  init: (providerOptions = {}, settings = {}) => {\n    const mailgun = mailgunFactory({\n      mute: false,\n      ...providerOptions,\n    });\n\n    return {\n      send: options => {\n        return new Promise((resolve, reject) => {\n          const { from, to, cc, bcc, replyTo, subject, text, html, ...rest } = options;\n\n          let msg = {\n            from: from || settings.defaultFrom,\n            to,\n            cc,\n            bcc,\n            'h:Reply-To': replyTo || settings.defaultReplyTo,\n            subject,\n            text,\n            html,\n            ...rest,\n          };\n\n          mailgun.messages().send(removeUndefined(msg), function(err) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-email-sendgrid/lib/index.js": "'use strict';\n\nconst sendgrid = require('@sendgrid/mail');\nconst { removeUndefined } = require('strapi-utils');\n\nmodule.exports = {\n  init: (providerOptions = {}, settings = {}) => {\n    sendgrid.setApiKey(providerOptions.apiKey);\n\n    return {\n      send: options => {\n        return new Promise((resolve, reject) => {\n          const { from, to, cc, bcc, replyTo, subject, text, html, ...rest } = options;\n\n          let msg = {\n            from: from || settings.defaultFrom,\n            to,\n            cc,\n            bcc,\n            replyTo: replyTo || settings.defaultReplyTo,\n            subject,\n            text,\n            html,\n            ...rest,\n          };\n\n          sendgrid.send(removeUndefined(msg), function(err) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-email-sendmail/lib/index.js": "'use strict';\n\nconst sendmailFactory = require('sendmail');\nconst { removeUndefined } = require('strapi-utils');\n\nmodule.exports = {\n  init: (providerOptions = {}, settings = {}) => {\n    const sendmail = sendmailFactory({\n      silent: true,\n      ...providerOptions,\n    });\n    return {\n      send: options => {\n        return new Promise((resolve, reject) => {\n          const { from, to, cc, bcc, replyTo, subject, text, html, ...rest } = options;\n\n          let msg = {\n            from: from || settings.defaultFrom,\n            to,\n            cc,\n            bcc,\n            replyTo: replyTo || settings.defaultReplyTo,\n            subject,\n            text,\n            html,\n            ...rest,\n          };\n\n          sendmail(removeUndefined(msg), err => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-upload-aws-s3/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n/* eslint-disable no-unused-vars */\n// Public node modules.\nconst _ = require('lodash');\nconst AWS = require('aws-sdk');\n\nmodule.exports = {\n  init(config) {\n    const S3 = new AWS.S3({\n      apiVersion: '2006-03-01',\n      ...config,\n    });\n\n    return {\n      upload(file, customParams = {}) {\n        return new Promise((resolve, reject) => {\n          // upload file on S3 bucket\n          const path = file.path ? `${file.path}/` : '';\n          S3.upload(\n            {\n              Key: `${path}${file.hash}${file.ext}`,\n              Body: Buffer.from(file.buffer, 'binary'),\n              ACL: 'public-read',\n              ContentType: file.mime,\n              ...customParams,\n            },\n            (err, data) => {\n              if (err) {\n                return reject(err);\n              }\n\n              // set the bucket file url\n              file.url = data.Location;\n\n              resolve();\n            }\n          );\n        });\n      },\n      delete(file, customParams = {}) {\n        return new Promise((resolve, reject) => {\n          // delete file on S3 bucket\n          const path = file.path ? `${file.path}/` : '';\n          S3.deleteObject(\n            {\n              Key: `${path}${file.hash}${file.ext}`,\n              ...customParams,\n            },\n            (err, data) => {\n              if (err) {\n                return reject(err);\n              }\n\n              resolve();\n            }\n          );\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-upload-cloudinary/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst cloudinary = require('cloudinary').v2;\nconst intoStream = require('into-stream');\nconst { errors } = require('strapi-plugin-upload');\n\nmodule.exports = {\n  init(config) {\n    cloudinary.config(config);\n\n    return {\n      upload(file, customConfig = {}) {\n        return new Promise((resolve, reject) => {\n          const config = {\n            resource_type: 'auto',\n            public_id: file.hash,\n          };\n\n          if (file.ext) {\n            config.filename = `${file.hash}${file.ext}`;\n          }\n\n          const upload_stream = cloudinary.uploader.upload_stream(\n            { ...config, ...customConfig },\n            (err, image) => {\n              if (err) {\n                if (err.message.includes('File size too large')) {\n                  return reject(errors.entityTooLarge());\n                }\n                return reject(errors.unknownError(`Error uploading to cloudinary: ${err.message}`));\n              }\n\n              if (image.resource_type === 'video') {\n                file.previewUrl = cloudinary.url(`${image.public_id}.gif`, {\n                  video_sampling: 6,\n                  delay: 200,\n                  width: 250,\n                  crop: 'scale',\n                  resource_type: 'video',\n                });\n              }\n\n              file.url = image.secure_url;\n              file.provider_metadata = {\n                public_id: image.public_id,\n                resource_type: image.resource_type,\n              };\n              resolve();\n            }\n          );\n\n          intoStream(file.buffer).pipe(upload_stream);\n        });\n      },\n      async delete(file, customConfig = {}) {\n        try {\n          const { resource_type, public_id } = file.provider_metadata;\n          const response = await cloudinary.uploader.destroy(public_id, {\n            invalidate: true,\n            resource_type: resource_type || 'image',\n            ...customConfig,\n          });\n\n          if (response.result !== 'ok' && response.result !== 'not found') {\n            throw errors.unknownError(`Error deleting on cloudinary: ${response.result}`);\n          }\n        } catch (error) {\n          throw errors.unknownError(`Error deleting on cloudinary: ${error.message}`);\n        }\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-upload-local/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst fs = require('fs');\nconst path = require('path');\nconst { errors } = require('strapi-plugin-upload');\n\nmodule.exports = {\n  init({ sizeLimit = 1000000 } = {}) {\n    const verifySize = file => {\n      if (file.size > sizeLimit) {\n        throw errors.entityTooLarge();\n      }\n    };\n    const configPublicPath = strapi.config.get(\n      'middleware.settings.public.path',\n      strapi.config.paths.static\n    );\n\n    const uploadDir = path.resolve(strapi.dir, configPublicPath);\n\n    return {\n      upload(file) {\n        verifySize(file);\n\n        return new Promise((resolve, reject) => {\n          // write file in public/assets folder\n          fs.writeFile(\n            path.join(uploadDir, `/uploads/${file.hash}${file.ext}`),\n            file.buffer,\n            err => {\n              if (err) {\n                return reject(err);\n              }\n\n              file.url = `/uploads/${file.hash}${file.ext}`;\n\n              resolve();\n            }\n          );\n        });\n      },\n      delete(file) {\n        return new Promise((resolve, reject) => {\n          const filePath = path.join(uploadDir, `/uploads/${file.hash}${file.ext}`);\n\n          if (!fs.existsSync(filePath)) {\n            return resolve(\"File doesn't exist\");\n          }\n\n          // remove file from public/assets folder\n          fs.unlink(filePath, err => {\n            if (err) {\n              return reject(err);\n            }\n\n            resolve();\n          });\n        });\n      },\n    };\n  },\n};\n",
    "packages/strapi-provider-upload-rackspace/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst pkgcloud = require('pkgcloud');\nconst streamifier = require('streamifier');\n\nmodule.exports = {\n  init(config) {\n    const options = { container: config.container };\n    const client = pkgcloud.storage.createClient({\n      provider: 'rackspace',\n      ...config,\n    });\n\n    const remoteURL = () =>\n      new Promise((resolve, reject) => {\n        return client.getContainer(config.container, (err, res) => {\n          if (err && !res) return reject(err);\n          return resolve(res);\n        });\n      });\n\n    return {\n      upload(file) {\n        const readStream = streamifier.createReadStream(file.buffer);\n        const writeStream = client.upload({\n          ...options,\n          remote: file.hash,\n          contentType: file.mime,\n        });\n\n        return new Promise((resolve, reject) => {\n          readStream.pipe(writeStream);\n          writeStream.on('error', error => error && reject(error));\n          writeStream.on('success', result => {\n            remoteURL()\n              .then(data => {\n                resolve(\n                  Object.assign(file, {\n                    mime: result.contentType,\n                    url: `${data.cdnSslUri}/${result.name}`,\n                  })\n                );\n              })\n              .catch(err => console.error(err) && reject(err));\n          });\n        });\n      },\n      delete(file) {\n        return new Promise((resolve, reject) => {\n          client.removeFile(config.container, file.hash, error => {\n            if (error) return reject(error);\n            return resolve();\n          });\n        });\n      },\n    };\n  },\n};\n",
    "test/helpers/test-app-generator.js": "'use strict';\n\nconst path = require('path');\nconst rimraf = require('rimraf');\nconst generateNew = require('../../packages/strapi-generate-new/lib/generate-new');\n\n/**\n * Delete the testApp folder\n * @param {string} appName - name of the app / folder where the app is located\n */\nconst cleanTestApp = appName => {\n  return new Promise((resolve, reject) => {\n    rimraf(path.resolve(appName), err => {\n      if (err) reject(err);\n      resolve();\n    });\n  });\n};\n\n/**\n * Runs strapi generate new\n * @param {Object} options - Options\n * @param {string} options.appName - Name of the app that will be created (also the name of the folder)\n * @param {database} options.database - Arguments to create the testApp with the provided database params\n */\nconst generateTestApp = async ({ appName, database }) => {\n  const scope = {\n    database: {\n      settings: database,\n      options: {},\n    },\n    rootPath: path.resolve(appName),\n    name: appName,\n    // disable quickstart run app after creation\n    runQuickstartApp: false,\n    // use package version as strapiVersion (all packages have the same version);\n    strapiVersion: require('../../packages/strapi/package.json').version,\n    debug: false,\n    quick: false,\n    uuid: undefined,\n    deviceId: null,\n    // use yarn if available and --use-npm isn't true\n    useYarn: true,\n    installDependencies: false,\n    strapiDependencies: [\n      'strapi',\n      'strapi-admin',\n      'strapi-utils',\n      'strapi-plugin-content-type-builder',\n      'strapi-plugin-content-manager',\n      'strapi-plugin-users-permissions',\n      'strapi-plugin-email',\n      'strapi-plugin-upload',\n      'strapi-plugin-graphql',\n      'strapi-plugin-documentation',\n    ],\n    additionalsDependencies: {},\n  };\n\n  await generateNew(scope);\n};\n\nmodule.exports = {\n  cleanTestApp,\n  generateTestApp,\n};\n",
    "examples/getstarted/api/homepage/config/policies/test.js": "module.exports = async (ctx, next) => {\n  console.log('in test policy');\n\n  await next();\n};\n",
    "packages/strapi/lib/Strapi.js": "'use strict';\n\nconst http = require('http');\nconst path = require('path');\nconst fse = require('fs-extra');\nconst Koa = require('koa');\nconst Router = require('koa-router');\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst CLITable = require('cli-table3');\nconst { logger, models, getAbsoluteAdminUrl, getAbsoluteServerUrl } = require('strapi-utils');\nconst { createDatabaseManager } = require('strapi-database');\nconst loadConfiguration = require('./core/app-configuration');\n\nconst utils = require('./utils');\nconst loadModules = require('./core/load-modules');\nconst bootstrap = require('./core/bootstrap');\nconst initializeMiddlewares = require('./middlewares');\nconst initializeHooks = require('./hooks');\nconst createStrapiFs = require('./core/fs');\nconst createEventHub = require('./services/event-hub');\nconst createWebhookRunner = require('./services/webhook-runner');\nconst { webhookModel, createWebhookStore } = require('./services/webhook-store');\nconst { createCoreStore, coreStoreModel } = require('./services/core-store');\nconst createEntityService = require('./services/entity-service');\nconst entityValidator = require('./services/entity-validator');\nconst createTelemetry = require('./services/metrics');\nconst createUpdateNotifier = require('./utils/update-notifier');\nconst ee = require('./utils/ee');\n\n/**\n * Construct an Strapi instance.\n *\n * @constructor\n */\nclass Strapi {\n  constructor(opts = {}) {\n    this.reload = this.reload();\n\n    // Expose `koa`.\n    this.app = new Koa();\n    this.router = new Router();\n\n    this.initServer();\n\n    // Logger.\n    this.log = logger;\n\n    // Utils.\n    this.utils = {\n      models,\n    };\n\n    this.dir = opts.dir || process.cwd();\n\n    this.admin = {};\n    this.plugins = {};\n    this.config = loadConfiguration(this.dir, opts);\n    this.app.proxy = this.config.get('server.proxy');\n\n    this.isLoaded = false;\n\n    // internal services.\n    this.fs = createStrapiFs(this);\n    this.eventHub = createEventHub();\n\n    this.requireProjectBootstrap();\n\n    createUpdateNotifier(this).notify();\n  }\n\n  get EE() {\n    return ee({ dir: this.dir, logger });\n  }\n\n  handleRequest(req, res) {\n    if (!this.requestHandler) {\n      this.requestHandler = this.app.callback();\n    }\n\n    return this.requestHandler(req, res);\n  }\n\n  requireProjectBootstrap() {\n    const bootstrapPath = path.resolve(this.dir, 'config/functions/bootstrap.js');\n\n    if (fse.existsSync(bootstrapPath)) {\n      require(bootstrapPath);\n    }\n  }\n\n  logStats() {\n    const columns = Math.min(process.stderr.columns, 80) - 2;\n    console.log();\n    console.log(chalk.black.bgWhite(_.padEnd(' Project information', columns)));\n    console.log();\n\n    const infoTable = new CLITable({\n      colWidths: [20, 50],\n      chars: { mid: '', 'left-mid': '', 'mid-mid': '', 'right-mid': '' },\n    });\n\n    const isEE = strapi.EE === true && ee.isEE === true;\n\n    infoTable.push(\n      [chalk.blue('Time'), `${new Date()}`],\n      [chalk.blue('Launched in'), Date.now() - this.config.launchedAt + ' ms'],\n      [chalk.blue('Environment'), this.config.environment],\n      [chalk.blue('Process PID'), process.pid],\n      [chalk.blue('Version'), `${this.config.info.strapi} (node ${process.version})`],\n      [chalk.blue('Edition'), isEE ? 'Enterprise' : 'Community']\n    );\n\n    console.log(infoTable.toString());\n    console.log();\n    console.log(chalk.black.bgWhite(_.padEnd(' Actions available', columns)));\n    console.log();\n  }\n\n  logFirstStartupMessage() {\n    this.logStats();\n\n    console.log(chalk.bold('One more thing...'));\n    console.log(\n      chalk.grey('Create your first administrator 💻 by going to the administration panel at:')\n    );\n    console.log();\n\n    const addressTable = new CLITable();\n\n    const adminUrl = getAbsoluteAdminUrl(strapi.config);\n    addressTable.push([chalk.bold(adminUrl)]);\n\n    console.log(`${addressTable.toString()}`);\n    console.log();\n  }\n\n  logStartupMessage() {\n    this.logStats();\n\n    console.log(chalk.bold('Welcome back!'));\n\n    if (this.config.serveAdminPanel === true) {\n      console.log(chalk.grey('To manage your project 🚀, go to the administration panel at:'));\n      const adminUrl = getAbsoluteAdminUrl(strapi.config);\n      console.log(chalk.bold(adminUrl));\n      console.log();\n    }\n\n    console.log(chalk.grey('To access the server ⚡️, go to:'));\n    const serverUrl = getAbsoluteServerUrl(strapi.config);\n    console.log(chalk.bold(serverUrl));\n    console.log();\n  }\n\n  initServer() {\n    this.server = http.createServer(this.handleRequest.bind(this));\n    // handle port in use cleanly\n    this.server.on('error', err => {\n      if (err.code === 'EADDRINUSE') {\n        return this.stopWithError(`The port ${err.port} is already used by another application.`);\n      }\n\n      this.log.error(err);\n    });\n\n    // Close current connections to fully destroy the server\n    const connections = {};\n\n    this.server.on('connection', conn => {\n      const key = conn.remoteAddress + ':' + conn.remotePort;\n      connections[key] = conn;\n\n      conn.on('close', function() {\n        delete connections[key];\n      });\n    });\n\n    this.server.destroy = cb => {\n      this.server.close(cb);\n\n      for (let key in connections) {\n        connections[key].destroy();\n      }\n    };\n  }\n\n  async start(cb) {\n    try {\n      if (!this.isLoaded) {\n        await this.load();\n      }\n\n      this.app.use(this.router.routes()).use(this.router.allowedMethods());\n\n      // Launch server.\n      this.listen(cb);\n    } catch (err) {\n      this.stopWithError(err);\n    }\n  }\n\n  async destroy() {\n    if (_.has(this, 'server.destroy')) {\n      this.server.destroy();\n    }\n\n    await Promise.all(\n      Object.values(this.plugins).map(plugin => {\n        if (_.has(plugin, 'destroy') && typeof plugin.destroy === 'function') {\n          return plugin.destroy();\n        }\n      })\n    );\n\n    if (_.has(this, 'admin')) {\n      await this.admin.destroy();\n    }\n\n    this.eventHub.removeAllListeners();\n\n    if (_.has(this, 'db')) {\n      await this.db.destroy();\n    }\n\n    delete global.strapi;\n  }\n\n  /**\n   * Add behaviors to the server\n   */\n  async listen(cb) {\n    const onListen = async err => {\n      if (err) return this.stopWithError(err);\n\n      // Is the project initialised?\n      const isInitialised = await utils.isInitialised(this);\n\n      // Should the startup message be displayed?\n      const hideStartupMessage = process.env.STRAPI_HIDE_STARTUP_MESSAGE\n        ? process.env.STRAPI_HIDE_STARTUP_MESSAGE === 'true'\n        : false;\n\n      if (hideStartupMessage === false) {\n        if (!isInitialised) {\n          this.logFirstStartupMessage();\n        } else {\n          this.logStartupMessage();\n        }\n      }\n\n      // Emit started event.\n      const databaseClients = _.map(this.config.get('connections'), _.property('settings.client'));\n      await this.telemetry.send('didStartServer', { database: databaseClients });\n\n      if (cb && typeof cb === 'function') {\n        cb();\n      }\n\n      if (\n        (this.config.environment === 'development' &&\n          this.config.get('server.admin.autoOpen', true) !== false) ||\n        !isInitialised\n      ) {\n        await utils.openBrowser.call(this);\n      }\n    };\n\n    const listenSocket = this.config.get('server.socket');\n    const listenErrHandler = err => onListen(err).catch(err => this.stopWithError(err));\n\n    if (listenSocket) {\n      this.server.listen(listenSocket, listenErrHandler);\n    } else {\n      this.server.listen(\n        this.config.get('server.port'),\n        this.config.get('server.host'),\n        listenErrHandler\n      );\n    }\n  }\n\n  stopWithError(err, customMessage) {\n    this.log.debug(`⛔️ Server wasn't able to start properly.`);\n    if (customMessage) {\n      this.log.error(customMessage);\n    }\n    this.log.error(err);\n    return this.stop();\n  }\n\n  stop(exitCode = 1) {\n    // Destroy server and available connections.\n    if (_.has(this, 'server.destroy')) {\n      this.server.destroy();\n    }\n\n    if (this.config.autoReload) {\n      process.send('stop');\n    }\n\n    // Kill process.\n    process.exit(exitCode);\n  }\n\n  async load() {\n    this.app.use(async (ctx, next) => {\n      if (ctx.request.url === '/_health' && ['HEAD', 'GET'].includes(ctx.request.method)) {\n        ctx.set('strapi', 'You are so French!');\n        ctx.status = 204;\n      } else {\n        await next();\n      }\n    });\n\n    const modules = await loadModules(this);\n\n    this.api = modules.api;\n    this.admin = modules.admin;\n    this.components = modules.components;\n    this.plugins = modules.plugins;\n    this.middleware = modules.middlewares;\n    this.hook = modules.hook;\n\n    await bootstrap(this);\n\n    // init webhook runner\n    this.webhookRunner = createWebhookRunner({\n      eventHub: this.eventHub,\n      logger: this.log,\n      configuration: this.config.get('server.webhooks', {}),\n    });\n\n    // Init core store\n    this.models['core_store'] = coreStoreModel(this.config);\n    this.models['strapi_webhooks'] = webhookModel(this.config);\n\n    this.db = createDatabaseManager(this);\n    await this.db.initialize();\n\n    this.store = createCoreStore({\n      environment: this.config.environment,\n      db: this.db,\n    });\n\n    this.webhookStore = createWebhookStore({ db: this.db });\n\n    await this.startWebhooks();\n\n    this.entityValidator = entityValidator;\n\n    this.entityService = createEntityService({\n      db: this.db,\n      eventHub: this.eventHub,\n      entityValidator: this.entityValidator,\n    });\n\n    this.telemetry = createTelemetry(this);\n\n    // Initialize hooks and middlewares.\n    await initializeMiddlewares.call(this);\n    await initializeHooks.call(this);\n\n    await this.runBootstrapFunctions();\n    await this.freeze();\n\n    this.isLoaded = true;\n\n    return this;\n  }\n\n  async startWebhooks() {\n    const webhooks = await this.webhookStore.findWebhooks();\n    webhooks.forEach(webhook => this.webhookRunner.add(webhook));\n  }\n\n  reload() {\n    const state = {\n      shouldReload: 0,\n    };\n\n    const reload = function() {\n      if (state.shouldReload > 0) {\n        // Reset the reloading state\n        state.shouldReload -= 1;\n        reload.isReloading = false;\n        return;\n      }\n\n      if (this.config.autoReload) {\n        this.server.close();\n        process.send('reload');\n      }\n    };\n\n    Object.defineProperty(reload, 'isWatching', {\n      configurable: true,\n      enumerable: true,\n      set: value => {\n        // Special state when the reloader is disabled temporarly (see GraphQL plugin example).\n        if (state.isWatching === false && value === true) {\n          state.shouldReload += 1;\n        }\n        state.isWatching = value;\n      },\n      get: () => {\n        return state.isWatching;\n      },\n    });\n\n    reload.isReloading = false;\n    reload.isWatching = true;\n\n    return reload;\n  }\n\n  async runBootstrapFunctions() {\n    const execBootstrap = async fn => {\n      if (!fn) return;\n\n      return fn();\n    };\n\n    // plugins bootstrap\n    const pluginBoostraps = Object.keys(this.plugins).map(plugin => {\n      return execBootstrap(_.get(this.plugins[plugin], 'config.functions.bootstrap')).catch(err => {\n        strapi.log.error(`Bootstrap function in plugin \"${plugin}\" failed`);\n        strapi.log.error(err);\n        strapi.stop();\n      });\n    });\n    await Promise.all(pluginBoostraps);\n\n    // user bootstrap\n    await execBootstrap(_.get(this.config, ['functions', 'bootstrap']));\n\n    // admin bootstrap : should always run after the others\n    const adminBootstrap = _.get(this.admin.config, 'functions.bootstrap');\n    return execBootstrap(adminBootstrap).catch(err => {\n      strapi.log.error(`Bootstrap function in admin failed`);\n      strapi.log.error(err);\n      strapi.stop();\n    });\n  }\n\n  async freeze() {\n    Object.freeze(this.config);\n    Object.freeze(this.dir);\n    Object.freeze(this.admin);\n    Object.freeze(this.plugins);\n    Object.freeze(this.api);\n  }\n\n  getModel(modelKey, plugin) {\n    return this.db.getModel(modelKey, plugin);\n  }\n\n  /**\n   * Binds queries with a specific model\n   * @param {string} entity - entity name\n   * @param {string} plugin - plugin name or null\n   */\n  query(entity, plugin) {\n    return this.db.query(entity, plugin);\n  }\n}\n\nmodule.exports = options => {\n  const strapi = new Strapi(options);\n  global.strapi = strapi;\n  return strapi;\n};\n",
    "packages/strapi/lib/commands/__tests__/admin-reset.test.js": "'use strict';\n\nconst load = jest.fn(() => mock);\nconst resetPasswordByEmail = jest.fn();\nconst admin = {\n  services: {\n    user: {\n      resetPasswordByEmail,\n    },\n  },\n};\n\nconst mock = {\n  load,\n  admin,\n};\n\njest.mock('../../index', () => {\n  return jest.fn(() => mock);\n});\n\nconst inquirer = require('inquirer');\nconst resetAdminPasswordCommand = require('../admin-reset');\n\ndescribe('admin:reset-password command', () => {\n  beforeEach(() => {\n    load.mockClear();\n    resetPasswordByEmail.mockClear();\n  });\n\n  test('resetAdminPasswordCommand accepts direct input', async () => {\n    const email = 'email@email.fr';\n    const password = 'testPasword1234';\n\n    const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {});\n    const consoleLog = jest.spyOn(console, 'log').mockImplementation(() => {});\n\n    await resetAdminPasswordCommand({ email, password });\n\n    expect(mockExit).toHaveBeenCalledWith(0);\n    expect(consoleLog).toHaveBeenCalled();\n    expect(load).toHaveBeenCalled();\n    expect(resetPasswordByEmail).toHaveBeenCalledWith(email, password);\n\n    mockExit.mockRestore();\n    consoleLog.mockRestore();\n  });\n\n  describe('Handles prompt input', () => {\n    test('Only prompt on TTY', async () => {\n      const tmpTTY = process.stdin.isTTY;\n      process.stdin.isTTY = false;\n\n      // throw so the code will stop executing\n      const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {\n        throw new Error('exit');\n      });\n\n      const consoleError = jest.spyOn(console, 'error').mockImplementation(() => {});\n\n      await resetAdminPasswordCommand().catch(err => {\n        expect(err).toEqual(new Error('exit'));\n      });\n\n      expect(consoleError).toBeCalledWith('Missing required options `email` or `password`');\n      expect(mockExit).toHaveBeenCalledWith(1);\n      expect(load).not.toHaveBeenCalled();\n      expect(resetPasswordByEmail).not.toHaveBeenCalled();\n\n      process.stdin.isTTY = tmpTTY;\n      mockExit.mockRestore();\n      consoleError.mockRestore();\n    });\n\n    test('Stops if not confirmed', async () => {\n      process.stdin.isTTY = true;\n      const email = 'email@email.fr';\n      const password = 'testPasword1234';\n\n      const mockInquiry = jest\n        .spyOn(inquirer, 'prompt')\n        .mockImplementationOnce(async () => ({ email, password, confirm: false }));\n\n      // throw so the code will stop executing\n      const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {\n        throw new Error('exit');\n      });\n\n      await resetAdminPasswordCommand().catch(err => {\n        expect(err).toEqual(new Error('exit'));\n      });\n\n      expect(mockInquiry).toHaveBeenLastCalledWith([\n        expect.objectContaining({\n          message: expect.any(String),\n          name: 'email',\n          type: 'input',\n        }),\n        expect.objectContaining({\n          message: expect.any(String),\n          name: 'password',\n          type: 'password',\n        }),\n        expect.objectContaining({\n          message: expect.any(String),\n          name: 'confirm',\n          type: 'confirm',\n        }),\n      ]);\n      expect(mockExit).toHaveBeenCalledWith(0);\n      expect(load).not.toHaveBeenCalled();\n      expect(resetPasswordByEmail).not.toHaveBeenCalled();\n\n      mockExit.mockRestore();\n      mockInquiry.mockRestore();\n    });\n\n    test('Calls the reset method with user input', async () => {\n      const email = 'email@email.fr';\n      const password = 'testPasword1234';\n\n      const mockInquiry = jest\n        .spyOn(inquirer, 'prompt')\n        .mockImplementationOnce(async () => ({ email, password, confirm: true }));\n\n      const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => {});\n      const consoleLog = jest.spyOn(console, 'log').mockImplementation(() => {});\n\n      await resetAdminPasswordCommand();\n\n      expect(mockExit).toHaveBeenCalledWith(0);\n      expect(consoleLog).toHaveBeenCalled();\n      expect(load).toHaveBeenCalled();\n      expect(resetPasswordByEmail).toHaveBeenCalledWith(email, password);\n\n      mockInquiry.mockRestore();\n      mockExit.mockRestore();\n      consoleLog.mockRestore();\n    });\n  });\n});\n",
    "packages/strapi/lib/commands/admin-reset.js": "'use strict';\n\nconst _ = require('lodash');\nconst inquirer = require('inquirer');\nconst strapi = require('../index');\n\nconst promptQuestions = [\n  { type: 'input', name: 'email', message: 'User email?' },\n  { type: 'password', name: 'password', message: 'New password?' },\n  {\n    type: 'confirm',\n    name: 'confirm',\n    message: \"Do you really want to reset this user's password?\",\n  },\n];\n\n/**\n * Reset user's password\n * @param {Object} cmdOptions - command options\n * @param {string} cmdOptions.email - user's email\n * @param {string} cmdOptions.password - user's new password\n */\nmodule.exports = async function(cmdOptions = {}) {\n  const { email, password } = cmdOptions;\n\n  if (_.isEmpty(email) && _.isEmpty(password) && process.stdin.isTTY) {\n    const inquiry = await inquirer.prompt(promptQuestions);\n\n    if (!inquiry.confirm) {\n      process.exit(0);\n    }\n\n    return changePassword(inquiry);\n  }\n\n  if (_.isEmpty(email) || _.isEmpty(password)) {\n    console.error('Missing required options `email` or `password`');\n    process.exit(1);\n  }\n\n  return changePassword({ email, password });\n};\n\nasync function changePassword({ email, password }) {\n  const app = await strapi().load();\n\n  await app.admin.services.user.resetPasswordByEmail(email, password);\n\n  console.log(`Successfully reset user's password`);\n  process.exit(0);\n}\n",
    "packages/strapi/lib/commands/configurationDump.js": "'use strict';\n\nconst fs = require('fs');\nconst strapi = require('../index');\n\nconst CHUNK_SIZE = 100;\n\n/**\n * Will dump configurations to a file or stdout\n * @param {string} file filepath to use as output\n */\nmodule.exports = async function({ file: filePath, pretty }) {\n  const output = filePath ? fs.createWriteStream(filePath) : process.stdout;\n\n  const app = await strapi().load();\n\n  const count = await app.query('core_store').count();\n\n  const exportData = [];\n\n  const pageCount = Math.ceil(count / CHUNK_SIZE);\n\n  for (let page = 0; page < pageCount; page++) {\n    const results = await app\n      .query('core_store')\n      .find({ _limit: CHUNK_SIZE, _start: page * CHUNK_SIZE, _sort: 'key' });\n\n    results\n      .filter(result => result.key.startsWith('plugin_'))\n      .forEach(result => {\n        exportData.push({\n          key: result.key,\n          value: result.value,\n          type: result.type,\n          environment: result.environment,\n          tag: result.tag,\n        });\n      });\n  }\n\n  output.write(JSON.stringify(exportData, null, pretty ? 2 : null));\n  output.write('\\n');\n  output.end();\n\n  // log success only when writting to file\n  if (filePath) {\n    console.log(`Successfully exported ${exportData.length} configuration entries`);\n  }\n  process.exit(0);\n};\n",
    "packages/strapi/lib/commands/install.js": "'use strict';\n\nconst { join } = require('path');\nconst { existsSync } = require('fs-extra');\nconst ora = require('ora');\nconst execa = require('execa');\nconst findPackagePath = require('../load/package-path');\n\nmodule.exports = async plugins => {\n  const loader = ora();\n  const dir = process.cwd();\n\n  const version = require(join(dir, 'package.json')).dependencies.strapi;\n\n  const pluginArgs = plugins.map(name => `strapi-plugin-${name}@${version}`);\n\n  try {\n    loader.start(`Installing dependencies`);\n\n    const useYarn = existsSync(join(dir, 'yarn.lock'));\n    if (useYarn) {\n      await execa('yarn', ['add', ...pluginArgs]);\n    } else {\n      await execa('npm', ['install', '--save', ...pluginArgs]);\n    }\n\n    loader.succeed();\n\n    // check if rebuild is necessary\n    let shouldRebuild = false;\n    for (let name of plugins) {\n      let pkgPath = findPackagePath(`strapi-plugin-${name}`);\n      if (existsSync(join(pkgPath, 'admin', 'src', 'index.js'))) {\n        shouldRebuild = true;\n      }\n    }\n\n    if (shouldRebuild) {\n      loader.start(`Rebuilding admin UI`);\n      await execa('npm', ['run', 'build']);\n      loader.succeed();\n    }\n  } catch (err) {\n    loader.clear();\n    console.error(err.message);\n    process.exit(1);\n  }\n};\n",
    "packages/strapi/lib/commands/uninstall.js": "'use strict';\n\nconst { join } = require('path');\nconst { existsSync, removeSync } = require('fs-extra');\nconst ora = require('ora');\nconst execa = require('execa');\nconst inquirer = require('inquirer');\nconst findPackagePath = require('../load/package-path');\n\nmodule.exports = async (plugins, { deleteFiles }) => {\n  const answers = await inquirer.prompt([\n    {\n      type: 'confirm',\n      name: 'deleteFiles',\n      message: `Do you want to delete the plugin generated files in the extensions folder ?`,\n      default: true,\n      when: !deleteFiles,\n    },\n  ]);\n\n  const loader = ora();\n  const dir = process.cwd();\n\n  const pluginArgs = plugins.map(name => `strapi-plugin-${name}`);\n\n  try {\n    // verify should rebuild before removing the pacakge\n    let shouldRebuild = false;\n    for (let name of plugins) {\n      let pkgPath = findPackagePath(`strapi-plugin-${name}`);\n      if (existsSync(join(pkgPath, 'admin', 'src', 'index.js'))) {\n        shouldRebuild = true;\n      }\n    }\n\n    loader.start(`Uninstalling dependencies`);\n\n    const useYarn = existsSync(join(dir, 'yarn.lock'));\n    if (useYarn) {\n      await execa('yarn', ['remove', ...pluginArgs]);\n    } else {\n      await execa('npm', ['remove', ...pluginArgs]);\n    }\n\n    loader.succeed();\n\n    if (deleteFiles === true || answers.deleteFiles === true) {\n      loader.start('Deleting old files');\n      for (let name of plugins) {\n        const pluginDir = join(dir, 'extensions', name);\n        if (existsSync(pluginDir)) {\n          removeSync(pluginDir);\n        }\n      }\n      loader.succeed();\n    }\n\n    if (shouldRebuild) {\n      loader.start(`Rebuilding admin UI`);\n      await execa('npm', ['run', 'build']);\n      loader.succeed();\n    }\n  } catch (err) {\n    loader.clear();\n    console.error(err.message);\n    process.exit(1);\n  }\n};\n",
    "packages/strapi/lib/core/__tests__/fs.test.js": "'use strict';\n\njest.mock('fs-extra', () => ({\n  ensureFile: jest.fn(() => Promise.resolve()),\n  writeFile: jest.fn(() => Promise.resolve()),\n}));\n\nconst path = require('path');\nconst fse = require('fs-extra');\nconst fs = require('../fs');\n\ndescribe('Strapi fs utils', () => {\n  const strapi = {\n    dir: '/tmp',\n  };\n\n  test('Provides new functions', () => {\n    const strapiFS = fs(strapi);\n\n    expect(strapiFS.writeAppFile).toBeInstanceOf(Function);\n    expect(strapiFS.writePluginFile).toBeInstanceOf(Function);\n  });\n\n  describe('Write App File', () => {\n    test('Makes sure the path exists and writes', async () => {\n      const strapiFS = fs(strapi);\n\n      const content = '';\n\n      await strapiFS.writeAppFile('test', content);\n\n      expect(fse.ensureFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'));\n      expect(fse.writeFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'), content);\n    });\n\n    test('Normalize the path to avoid relative access to folders in parent directories', async () => {\n      const strapiFS = fs(strapi);\n\n      const content = '';\n\n      await strapiFS.writeAppFile('../../test', content);\n\n      expect(fse.ensureFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'));\n      expect(fse.writeFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'), content);\n    });\n\n    test('Works with array path', async () => {\n      const strapiFS = fs(strapi);\n\n      const content = '';\n\n      await strapiFS.writeAppFile(['test', 'sub', 'path'], content);\n\n      expect(fse.ensureFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test', 'sub', 'path'));\n      expect(fse.writeFile).toHaveBeenCalledWith(\n        path.join('/', 'tmp', 'test', 'sub', 'path'),\n        content\n      );\n    });\n  });\n\n  describe('Write Plugin File', () => {\n    test('Scopes the writes in the extensions folder', async () => {\n      const strapiFS = fs(strapi);\n\n      const content = '';\n\n      strapiFS.writeAppFile = jest.fn(() => Promise.resolve());\n\n      await strapiFS.writePluginFile('users-permissions', ['test', 'sub', 'path'], content);\n\n      expect(strapiFS.writeAppFile).toHaveBeenCalledWith(\n        'extensions/users-permissions/test/sub/path',\n        content\n      );\n    });\n  });\n});\n",
    "packages/strapi/lib/core/load-admin.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst findPackagePath = require('../load/package-path');\nconst loadFiles = require('../load/load-files');\nconst loadConfig = require('../load/load-config-files');\n\nconst mergeRoutes = (a, b, key) =>\n  _.isArray(a) && _.isArray(b) && key === 'routes' ? a.concat(b) : undefined;\n\nmodule.exports = async strapi => {\n  const adminPath = findPackagePath('strapi-admin');\n  const [files, config] = await Promise.all([\n    loadFiles(adminPath, '!(config|node_modules|tests|ee|scripts)/*.*(js|json)'),\n    loadConfig(adminPath),\n  ]);\n\n  // set admin config in strapi.config.server.admin\n  const userAdminConfig = strapi.config.get('server.admin');\n  strapi.config.set('server.admin', _.merge(config.config, userAdminConfig));\n\n  // load ee files if they exist\n  let eeFiles = {};\n  let eeConfig = {};\n\n  if (process.env.STRAPI_DISABLE_EE !== 'true' && strapi.EE) {\n    const eeAdminPath = `${adminPath}/ee`;\n    [eeFiles, eeConfig] = await Promise.all([\n      loadFiles(eeAdminPath, '!(config|test)/*.*(js|json)'),\n      loadConfig(eeAdminPath),\n    ]);\n  }\n\n  return _.mergeWith({}, files, eeFiles, config, eeConfig, mergeRoutes);\n};\n",
    "packages/strapi/lib/core/load-components.js": "'use strict';\n\nconst { join } = require('path');\nconst _ = require('lodash');\nconst { exists } = require('fs-extra');\nconst loadFiles = require('../load/load-files');\n\nmodule.exports = async strapi => {\n  const componentsDir = join(strapi.dir, 'components');\n\n  if (!(await exists(componentsDir))) {\n    return {};\n  }\n\n  const map = await loadFiles(componentsDir, '*/*.*(js|json)');\n\n  return Object.keys(map).reduce((acc, category) => {\n    Object.keys(map[category]).forEach(key => {\n      const schema = map[category][key];\n\n      const filePath = join(componentsDir, category, schema.__filename__);\n\n      if (!schema.collectionName) {\n        return strapi.stopWithError(\n          `Component ${key} is missing a \"collectionName\" property.\\nVerify file ${filePath}.`\n        );\n      }\n\n      const uid = `${category}.${key}`;\n\n      acc[uid] = Object.assign(schema, {\n        __schema__: _.cloneDeep(schema),\n        uid,\n        category,\n        modelType: 'component',\n        modelName: key,\n        globalId: schema.globalId || _.upperFirst(_.camelCase(`component_${uid}`)),\n      });\n    });\n\n    return acc;\n  }, {});\n};\n",
    "packages/strapi/lib/core/load-hooks.js": "'use strict';\n\n// Dependencies.\nconst path = require('path');\nconst fs = require('fs-extra');\nconst _ = require('lodash');\nconst glob = require('../load/glob');\nconst findPackagePath = require('../load/package-path');\n\n/**\n * Load hooks\n */\nmodule.exports = async function({ installedHooks, installedPlugins, appPath }) {\n  let hooks = {};\n\n  await Promise.all([\n    loadHookDependencies(installedHooks, hooks),\n    // local middleware\n    loadLocalHooks(appPath, hooks),\n    // plugins middlewares\n    loadPluginsHooks(installedPlugins, hooks),\n    // local plugin middlewares\n    loadLocalPluginsHooks(appPath, hooks),\n  ]);\n\n  return hooks;\n};\n\nconst loadHooksInDir = async (dir, hooks) => {\n  const files = await glob('*/*(index|defaults).*(js|json)', {\n    cwd: dir,\n  });\n\n  files.forEach(f => {\n    const name = f.split('/')[0];\n    mountHooks(name, [path.resolve(dir, f)], hooks);\n  });\n};\n\nconst loadLocalHooks = (appPath, hooks) => loadHooksInDir(path.resolve(appPath, 'hooks'), hooks);\n\nconst loadPluginsHooks = async (plugins, hooks) => {\n  for (let pluginName of plugins) {\n    const dir = path.resolve(findPackagePath(`strapi-plugin-${pluginName}`), 'hooks');\n    await loadHooksInDir(dir, hooks);\n  }\n};\n\nconst loadLocalPluginsHooks = async (appPath, hooks) => {\n  const pluginsDir = path.resolve(appPath, 'plugins');\n  if (!fs.existsSync(pluginsDir)) return;\n\n  const pluginsNames = await fs.readdir(pluginsDir);\n\n  for (let pluginName of pluginsNames) {\n    // ignore files\n    const stat = await fs.stat(path.resolve(pluginsDir, pluginName));\n    if (!stat.isDirectory()) continue;\n\n    const dir = path.resolve(pluginsDir, pluginName, 'hooks');\n    await loadHooksInDir(dir, hooks);\n  }\n};\n\nconst loadHookDependencies = async (installedHooks, hooks) => {\n  for (let hook of installedHooks) {\n    const hookDir = path.dirname(require.resolve(`strapi-hook-${hook}`));\n\n    const files = await glob('*(index|defaults).*(js|json)', {\n      cwd: hookDir,\n      absolute: true,\n    });\n\n    mountHooks(hook, files, hooks);\n  }\n};\n\nconst mountHooks = (name, files, hooks) => {\n  files.forEach(file => {\n    hooks[name] = hooks[name] || { loaded: false };\n\n    let dependencies = [];\n    try {\n      dependencies = _.get(require(`strapi-hook-${name}/package.json`), 'strapi.dependencies', []);\n    } catch (err) {\n      // Silent\n    }\n\n    if (_.endsWith(file, 'index.js') && !hooks[name].load) {\n      Object.defineProperty(hooks[name], 'load', {\n        configurable: false,\n        enumerable: true,\n        get: () => require(file)(strapi),\n      });\n      hooks[name].dependencies = dependencies;\n      return;\n    }\n\n    if (_.endsWith(file, 'defaults.json')) {\n      hooks[name].defaults = require(file);\n      return;\n    }\n  });\n};\n",
    "packages/strapi/lib/core/load-middlewares.js": "'use strict';\n\n// Dependencies.\nconst path = require('path');\nconst fs = require('fs-extra');\nconst _ = require('lodash');\nconst glob = require('../load/glob');\nconst findPackagePath = require('../load/package-path');\n\n/**\n * Load middlewares\n */\nmodule.exports = async function(strapi) {\n  const { installedMiddlewares, installedPlugins, appPath } = strapi.config;\n\n  let middlewares = {};\n\n  const loaders = createLoaders(strapi);\n\n  await loaders.loadMiddlewareDependencies(installedMiddlewares, middlewares);\n  // internal middlewares\n  await loaders.loadInternalMiddlewares(middlewares);\n  // local middleware\n  await loaders.loadLocalMiddlewares(appPath, middlewares);\n  // plugins middlewares\n  await loaders.loadPluginsMiddlewares(installedPlugins, middlewares);\n  // local plugin middlewares\n  await loaders.loadLocalPluginsMiddlewares(appPath, middlewares);\n  // load admin middlwares\n  await loaders.loadAdminMiddlewares(middlewares);\n\n  return middlewares;\n};\n\n/**\n * Build loader functions\n * @param {*} strapi - strapi instance\n */\nconst createLoaders = strapi => {\n  const loadMiddlewaresInDir = async (dir, middlewares) => {\n    const files = await glob('*/*(index|defaults).*(js|json)', {\n      cwd: dir,\n    });\n\n    files.forEach(f => {\n      const name = f.split('/')[0];\n      mountMiddleware(name, [path.resolve(dir, f)], middlewares);\n    });\n  };\n\n  const loadInternalMiddlewares = middlewares =>\n    loadMiddlewaresInDir(path.resolve(__dirname, '..', 'middlewares'), middlewares);\n\n  const loadLocalMiddlewares = (appPath, middlewares) =>\n    loadMiddlewaresInDir(path.resolve(appPath, 'middlewares'), middlewares);\n\n  const loadPluginsMiddlewares = async (plugins, middlewares) => {\n    for (let pluginName of plugins) {\n      const dir = path.resolve(findPackagePath(`strapi-plugin-${pluginName}`), 'middlewares');\n      await loadMiddlewaresInDir(dir, middlewares);\n    }\n  };\n\n  const loadLocalPluginsMiddlewares = async (appPath, middlewares) => {\n    const pluginsDir = path.resolve(appPath, 'plugins');\n    if (!fs.existsSync(pluginsDir)) return;\n\n    const pluginsNames = await fs.readdir(pluginsDir);\n\n    for (let pluginFolder of pluginsNames) {\n      // ignore files\n      const stat = await fs.stat(path.resolve(pluginsDir, pluginFolder));\n      if (!stat.isDirectory()) continue;\n\n      const dir = path.resolve(pluginsDir, pluginFolder, 'middlewares');\n      await loadMiddlewaresInDir(dir, middlewares);\n    }\n  };\n\n  const loadAdminMiddlewares = async middlewares => {\n    const dir = path.resolve(findPackagePath(`strapi-admin`), 'middlewares');\n    await loadMiddlewaresInDir(dir, middlewares);\n  };\n\n  const loadMiddlewareDependencies = async (packages, middlewares) => {\n    for (let packageName of packages) {\n      const baseDir = path.dirname(require.resolve(`strapi-middleware-${packageName}`));\n      const files = await glob('*(index|defaults).*(js|json)', {\n        cwd: baseDir,\n        absolute: true,\n      });\n\n      mountMiddleware(packageName, files, middlewares);\n    }\n  };\n\n  const mountMiddleware = (name, files, middlewares) => {\n    files.forEach(file => {\n      middlewares[name] = middlewares[name] || { loaded: false };\n\n      if (_.endsWith(file, 'index.js') && !middlewares[name].load) {\n        return Object.defineProperty(middlewares[name], 'load', {\n          configurable: false,\n          enumerable: true,\n          get: () => require(file)(strapi),\n        });\n      }\n\n      if (_.endsWith(file, 'defaults.json')) {\n        middlewares[name].defaults = require(file);\n        return;\n      }\n    });\n  };\n\n  return {\n    loadInternalMiddlewares,\n    loadLocalMiddlewares,\n    loadPluginsMiddlewares,\n    loadLocalPluginsMiddlewares,\n    loadMiddlewareDependencies,\n    loadAdminMiddlewares,\n  };\n};\n",
    "packages/strapi/lib/core/load-modules.js": "/**\n * Load Modules is the root module loader.\n * This is where all the strapi enviornment is laoded\n * - APIs\n * - Plugins\n * - Hooks\n * - Middlewres\n * - Components\n * - ContentTypes\n */\n'use strict';\n\nconst _ = require('lodash');\n\nconst loadApis = require('./load-apis');\nconst loadAdmin = require('./load-admin');\nconst loadPlugins = require('./load-plugins');\nconst loadMiddlewares = require('./load-middlewares');\nconst loadExtensions = require('./load-extensions');\nconst loadHooks = require('./load-hooks');\nconst loadComponents = require('./load-components');\n\nmodule.exports = async strapi => {\n  const [api, admin, plugins, middlewares, hook, extensions, components] = await Promise.all([\n    loadApis(strapi),\n    loadAdmin(strapi),\n    loadPlugins(strapi),\n    loadMiddlewares(strapi),\n    loadHooks(strapi.config),\n    loadExtensions(strapi.config),\n    loadComponents(strapi),\n  ]);\n\n  // TODO: move this into the appropriate loaders\n\n  /**\n   * Handle plugin extensions\n   */\n  // merge extensions config folders\n  _.mergeWith(plugins, extensions.merges, (objValue, srcValue, key) => {\n    // concat routes\n    if (_.isArray(srcValue) && _.isArray(objValue) && key === 'routes') {\n      return srcValue.concat(objValue);\n    }\n  });\n\n  // overwrite plugins with extensions overwrites\n  extensions.overwrites.forEach(({ path, mod }) => {\n    _.assign(_.get(plugins, path), mod);\n  });\n\n  return {\n    api,\n    admin,\n    plugins,\n    middlewares,\n    hook,\n    extensions,\n    components,\n  };\n};\n",
    "packages/strapi/lib/core/load-plugins.js": "'use strict';\n\nconst { join } = require('path');\nconst { existsSync } = require('fs-extra');\nconst _ = require('lodash');\nconst findPackagePath = require('../load/package-path');\nconst loadFiles = require('../load/load-files');\nconst loadConfig = require('../load/load-config-files');\n\nmodule.exports = async ({ dir, config }) => {\n  const localPlugins = await loadLocalPlugins({ dir, config });\n  const plugins = await loadPlugins({\n    installedPlugins: config.installedPlugins,\n    config,\n  });\n\n  const pluginsIntersection = _.intersection(Object.keys(localPlugins), Object.keys(plugins));\n\n  if (pluginsIntersection.length > 0) {\n    throw new Error(\n      `You have some local plugins with the same name as npm installed plugins:\\n${pluginsIntersection\n        .map(p => `- ${p}`)\n        .join('\\n')}`\n    );\n  }\n\n  // check for conflicts\n  return _.merge(plugins, localPlugins);\n};\n\nconst loadLocalPlugins = async ({ dir, config }) => {\n  const pluginsDir = join(dir, 'plugins');\n\n  if (!existsSync(pluginsDir)) return {};\n\n  const [files, configs] = await Promise.all([\n    loadFiles(pluginsDir, '{*/!(config)/*.*(js|json),*/package.json}'),\n    loadConfig(pluginsDir, '*/config/**/*.+(js|json)'),\n  ]);\n  const userConfigs = Object.keys(files).reduce((acc, plugin) => {\n    acc[plugin] = { config: config.get(['plugins', plugin], {}) };\n    return acc;\n  }, {});\n  return _.merge(files, configs, userConfigs);\n};\n\nconst loadPlugins = async ({ installedPlugins, config }) => {\n  let plugins = {};\n\n  for (let plugin of installedPlugins) {\n    const pluginPath = findPackagePath(`strapi-plugin-${plugin}`);\n\n    const files = await loadFiles(\n      pluginPath,\n      '{!(config|node_modules|tests)/*.*(js|json),package.json}'\n    );\n\n    const { config: pluginConfig } = await loadConfig(pluginPath);\n\n    const userConfig = config.get(['plugins', plugin], {});\n\n    const mergedConfig = _.merge(pluginConfig, userConfig);\n\n    _.set(plugins, plugin, _.assign({}, files, { config: mergedConfig }));\n  }\n\n  return plugins;\n};\n",
    "packages/strapi/lib/core-api/__tests__/service.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst createService = require('../service');\n\nconst maxLimit = 50;\nconst defaultLimit = 20;\n\n// init global strapi\nglobal.strapi = {\n  config: {\n    get(path, defaultValue) {\n      return _.get(this, path, defaultValue);\n    },\n    api: {\n      rest: {\n        defaultLimit,\n        maxLimit,\n      },\n    },\n  },\n};\n\ndescribe('Default Service', () => {\n  describe('Collection Type', () => {\n    test('Creates default actions', () => {\n      const strapi = {};\n      const model = {\n        modelName: 'testModel',\n        kind: 'collectionType',\n      };\n\n      const service = createService({ strapi, model });\n\n      expect(service).toEqual({\n        find: expect.any(Function),\n        findOne: expect.any(Function),\n        count: expect.any(Function),\n        search: expect.any(Function),\n        countSearch: expect.any(Function),\n        create: expect.any(Function),\n        update: expect.any(Function),\n        delete: expect.any(Function),\n      });\n    });\n  });\n\n  describe('Single Type', () => {\n    test('Creates default actions', () => {\n      const strapi = {};\n      const model = {\n        modelName: 'testModel',\n        kind: 'singleType',\n      };\n\n      const service = createService({ strapi, model });\n\n      expect(service).toEqual({\n        find: expect.any(Function),\n        createOrUpdate: expect.any(Function),\n        delete: expect.any(Function),\n      });\n    });\n\n    describe('Passes the logic down to the entityService', () => {\n      test('Creates data when no entity is found', async () => {\n        const strapi = {\n          entityService: {\n            find: jest.fn(() => Promise.resolve(null)),\n            create: jest.fn(() => Promise.resolve({ id: 1 })),\n          },\n        };\n\n        const model = {\n          modelName: 'testModel',\n          kind: 'singleType',\n        };\n\n        const service = createService({ strapi, model });\n\n        const input = {};\n        await service.createOrUpdate(input);\n\n        expect(strapi.entityService.find).toHaveBeenCalledWith(\n          { populate: undefined, params: { _publicationState: 'live', _limit: defaultLimit } },\n          {\n            model: 'testModel',\n          }\n        );\n\n        expect(strapi.entityService.create).toHaveBeenCalledWith(\n          { data: input },\n          {\n            model: 'testModel',\n          }\n        );\n      });\n\n      test('Updates data when entity is found', async () => {\n        const strapi = {\n          entityService: {\n            find: jest.fn(() => Promise.resolve({ id: 1 })),\n            update: jest.fn(() => Promise.resolve({ id: 1 })),\n          },\n        };\n\n        const model = {\n          modelName: 'testModel',\n          kind: 'singleType',\n        };\n\n        const service = createService({ strapi, model });\n\n        const input = {};\n        await service.createOrUpdate(input);\n\n        expect(strapi.entityService.find).toHaveBeenCalledWith(\n          { populate: undefined, params: { _publicationState: 'live', _limit: defaultLimit } },\n          {\n            model: 'testModel',\n          }\n        );\n\n        expect(strapi.entityService.update).toHaveBeenCalledWith(\n          {\n            params: { id: 1 },\n            data: input,\n          },\n          {\n            model: 'testModel',\n          }\n        );\n      });\n\n      test('Delete data when entity is found', async () => {\n        const strapi = {\n          entityService: {\n            find: jest.fn(() => Promise.resolve({ id: 1 })),\n            delete: jest.fn(() => Promise.resolve({ id: 1 })),\n          },\n        };\n\n        const model = {\n          modelName: 'testModel',\n          kind: 'singleType',\n        };\n\n        const service = createService({ strapi, model });\n\n        await service.delete();\n\n        expect(strapi.entityService.find).toHaveBeenCalledWith(\n          { populate: undefined, params: { _publicationState: 'live', _limit: defaultLimit } },\n          {\n            model: 'testModel',\n          }\n        );\n\n        expect(strapi.entityService.delete).toHaveBeenCalledWith(\n          {\n            params: { id: 1 },\n          },\n          {\n            model: 'testModel',\n          }\n        );\n      });\n    });\n  });\n});\n\ndescribe('getFetchParams', () => {\n  test.each([\n    [`0 if _limit is '0'`, { _limit: '0', maxLimit }, 0],\n    ['0 if _limit is 0', { _limit: 0, maxLimit }, 0],\n    [`0 if _limit is ''`, { _limit: '', maxLimit }, 0],\n    [`1 if _limit is '1'`, { _limit: '1', maxLimit }, 1],\n    [\n      `${maxLimit} if _limit(500) exceeds max allowed limit (${maxLimit})`,\n      { _limit: '500', maxLimit },\n      maxLimit,\n    ],\n    [\n      `${maxLimit} if _limit is set to -1 and max allowed limit is set (${maxLimit})`,\n      { _limit: '-1', maxLimit },\n      maxLimit,\n    ],\n    [`${defaultLimit} (default) if no _limit is provided`, { maxLimit }, defaultLimit],\n    [\n      `${defaultLimit} (default) if _limit is undefined`,\n      { _limit: undefined, maxLimit },\n      defaultLimit,\n    ],\n    ['1000 if _limit=1000 and no max allowed limit is set', { _limit: 1000 }, 1000],\n  ])('Sets _limit parameter to %s', (description, input, expected) => {\n    strapi.config.api.rest.maxLimit = input.maxLimit;\n    expect(createService.getFetchParams({ _limit: input._limit })).toMatchObject({\n      _limit: expected,\n    });\n  });\n});\n",
    "packages/strapi/lib/core-api/controller.js": "'use strict';\n\nconst _ = require('lodash');\nconst { parseMultipartData, sanitizeEntity } = require('strapi-utils');\n\nconst createSanitizeFn = model => data => {\n  return sanitizeEntity(data, { model: strapi.getModel(model.uid) });\n};\n\n/**\n * default bookshelf controller\n *\n */\nmodule.exports = ({ service, model }) => {\n  if (model.kind === 'singleType') {\n    return createSingleTypeController({ model, service });\n  }\n\n  return createCollectionTypeController({ model, service });\n};\n\n/**\n * Returns a single type controller to handle default core-api actions\n */\nconst createSingleTypeController = ({ model, service }) => {\n  const sanitize = createSanitizeFn(model);\n\n  return {\n    /**\n     * Retrieve single type content\n     *\n     * @return {Object|Array}\n     */\n    async find(ctx) {\n      const { query } = ctx;\n      const entity = await service.find(query);\n      return sanitize(entity);\n    },\n\n    /**\n     * create or update single type content.\n     *\n     * @return {Object}\n     */\n    async update(ctx) {\n      let entity;\n      if (ctx.is('multipart')) {\n        const { data, files } = parseMultipartData(ctx);\n        entity = await service.createOrUpdate(data, { files });\n      } else {\n        entity = await service.createOrUpdate(ctx.request.body);\n      }\n\n      return sanitize(entity);\n    },\n\n    async delete() {\n      const entity = await service.delete();\n      return sanitize(entity);\n    },\n  };\n};\n\n/**\n *\n * Returns a collection type controller to handle default core-api actions\n */\nconst createCollectionTypeController = ({ model, service }) => {\n  const sanitize = createSanitizeFn(model);\n\n  return {\n    /**\n     * Retrieve records.\n     *\n     * @return {Object|Array}\n     */\n    async find(ctx) {\n      let entities;\n      if (_.has(ctx.query, '_q')) {\n        entities = await service.search(ctx.query);\n      } else {\n        entities = await service.find(ctx.query);\n      }\n\n      return sanitize(entities);\n    },\n\n    /**\n     * Retrieve a record.\n     *\n     * @return {Object}\n     */\n    async findOne(ctx) {\n      const { query, params } = ctx;\n      const entity = await service.findOne({ ...query, id: params.id });\n\n      return sanitize(entity);\n    },\n\n    /**\n     * Count records.\n     *\n     * @return {Number}\n     */\n    count(ctx) {\n      if (_.has(ctx.query, '_q')) {\n        return service.countSearch(ctx.query);\n      }\n      return service.count(ctx.query);\n    },\n\n    /**\n     * Create a record.\n     *\n     * @return {Object}\n     */\n    async create(ctx) {\n      let entity;\n      if (ctx.is('multipart')) {\n        const { data, files } = parseMultipartData(ctx);\n        entity = await service.create(data, { files });\n      } else {\n        entity = await service.create(ctx.request.body);\n      }\n\n      return sanitize(entity);\n    },\n\n    /**\n     * Update a record.\n     *\n     * @return {Object}\n     */\n    async update(ctx) {\n      let entity;\n      if (ctx.is('multipart')) {\n        const { data, files } = parseMultipartData(ctx);\n        entity = await service.update({ id: ctx.params.id }, data, { files });\n      } else {\n        entity = await service.update({ id: ctx.params.id }, ctx.request.body);\n      }\n\n      return sanitize(entity);\n    },\n\n    /**\n     * Destroy a record.\n     *\n     * @return {Object}\n     */\n    async delete(ctx) {\n      const entity = await service.delete({ id: ctx.params.id });\n      return sanitize(entity);\n    },\n  };\n};\n",
    "packages/strapi/lib/core-api/service.js": "'use strict';\n\nconst _ = require('lodash');\nconst utils = require('strapi-utils');\nconst {\n  contentTypes: {\n    hasDraftAndPublish,\n    constants: { PUBLISHED_AT_ATTRIBUTE, DP_PUB_STATE_LIVE },\n  },\n} = require('strapi-utils');\n\n/**\n * Default limit values from config\n * @return {{maxLimit: number, defaultLimit: number}}\n */\nconst getLimitConfigDefaults = () => ({\n  defaultLimit: _.toNumber(strapi.config.get('api.rest.defaultLimit', 100)),\n  maxLimit: _.toNumber(strapi.config.get('api.rest.maxLimit')) || null,\n});\n\nconst getLimitParam = params => {\n  const { defaultLimit, maxLimit } = getLimitConfigDefaults();\n  if (params._limit === undefined) {\n    return defaultLimit;\n  }\n\n  const limit = _.toNumber(params._limit);\n  // if there is max limit set and params._limit exceeds this number, return configured max limit\n  if (maxLimit && (limit === -1 || limit > maxLimit)) {\n    return maxLimit;\n  }\n\n  return limit;\n};\n\nconst getFetchParams = (params = {}) => {\n  const defaultParams = {};\n\n  Object.assign(defaultParams, {\n    _publicationState: DP_PUB_STATE_LIVE,\n  });\n\n  return {\n    ...defaultParams,\n    ...params,\n    _limit: getLimitParam(params),\n  };\n};\n\n/**\n * default service\n *\n */\nconst createCoreService = ({ model, strapi }) => {\n  const serviceFactory =\n    model.kind === 'singleType' ? createSingleTypeService : createCollectionTypeService;\n\n  return serviceFactory({ model, strapi });\n};\n\n/**\n * Mixins\n */\nconst createUtils = ({ model }) => {\n  const { getNonWritableAttributes } = utils.contentTypes;\n\n  return {\n    sanitizeInput: data => _.omit(data, getNonWritableAttributes(model)),\n  };\n};\n\n/**\n * Returns a single type service to handle default core-api actions\n */\nconst createSingleTypeService = ({ model, strapi }) => {\n  const { modelName } = model;\n  const { sanitizeInput } = createUtils({ model });\n\n  return {\n    /**\n     * Returns single type content\n     *\n     * @return {Promise}\n     */\n    find(params, populate) {\n      return strapi.entityService.find(\n        { params: getFetchParams(params), populate },\n        { model: modelName }\n      );\n    },\n\n    /**\n     * Creates or update the single- type content\n     *\n     * @return {Promise}\n     */\n    async createOrUpdate(data, { files } = {}) {\n      const entity = await this.find();\n      const sanitizedData = sanitizeInput(data);\n\n      if (!entity) {\n        return strapi.entityService.create({ data: sanitizedData, files }, { model: modelName });\n      } else {\n        return strapi.entityService.update(\n          {\n            params: {\n              id: entity.id,\n            },\n            data: sanitizedData,\n            files,\n          },\n          { model: modelName }\n        );\n      }\n    },\n\n    /**\n     * Deletes the single type content\n     *\n     * @return {Promise}\n     */\n    async delete() {\n      const entity = await this.find();\n\n      if (!entity) return;\n\n      return strapi.entityService.delete({ params: { id: entity.id } }, { model: modelName });\n    },\n  };\n};\n\n/**\n *\n * Returns a collection type service to handle default core-api actions\n */\nconst createCollectionTypeService = ({ model, strapi }) => {\n  const { modelName } = model;\n  const { sanitizeInput } = createUtils({ model });\n\n  return {\n    /**\n     * Promise to fetch all records\n     *\n     * @return {Promise}\n     */\n    find(params, populate) {\n      return strapi.entityService.find(\n        { params: getFetchParams(params), populate },\n        { model: modelName }\n      );\n    },\n\n    /**\n     * Promise to fetch record\n     *\n     * @return {Promise}\n     */\n\n    findOne(params, populate) {\n      return strapi.entityService.findOne(\n        { params: getFetchParams(params), populate },\n        { model: modelName }\n      );\n    },\n\n    /**\n     * Promise to count record\n     *\n     * @return {Promise}\n     */\n\n    count(params) {\n      return strapi.entityService.count({ params: getFetchParams(params) }, { model: modelName });\n    },\n\n    /**\n     * Promise to add record\n     *\n     * @return {Promise}\n     */\n\n    create(data, { files } = {}) {\n      const sanitizedData = sanitizeInput(data);\n      if (hasDraftAndPublish(model)) {\n        sanitizedData[PUBLISHED_AT_ATTRIBUTE] = _.get(\n          sanitizedData,\n          PUBLISHED_AT_ATTRIBUTE,\n          new Date()\n        );\n      }\n      return strapi.entityService.create({ data: sanitizedData, files }, { model: modelName });\n    },\n\n    /**\n     * Promise to edit record\n     *\n     * @return {Promise}\n     */\n\n    update(params, data, { files } = {}) {\n      const sanitizedData = sanitizeInput(data);\n      return strapi.entityService.update(\n        { params, data: sanitizedData, files },\n        { model: modelName }\n      );\n    },\n\n    /**\n     * Promise to delete a record\n     *\n     * @return {Promise}\n     */\n\n    delete(params) {\n      return strapi.entityService.delete({ params }, { model: modelName });\n    },\n\n    /**\n     * Promise to search records\n     *\n     * @return {Promise}\n     */\n\n    search(params) {\n      return strapi.entityService.search({ params }, { model: modelName });\n    },\n\n    /**\n     * Promise to count searched records\n     *\n     * @return {Promise}\n     */\n    countSearch(params) {\n      return strapi.entityService.countSearch(\n        { params: getFetchParams(params) },\n        { model: modelName }\n      );\n    },\n  };\n};\n\nmodule.exports = createCoreService;\n\nmodule.exports.getFetchParams = getFetchParams;\n",
    "packages/strapi/lib/load/load-files.js": "'use strict';\n\nconst path = require('path');\nconst _ = require('lodash');\nconst fse = require('fs-extra');\nconst glob = require('./glob');\nconst filePathToPath = require('./filepath-to-prop-path');\n\n/**\n * Returns an Object build from a list of files matching a glob pattern in a directory\n * It builds a tree structure resembling the folder structure in dir\n * @param {string} dir - Directory to load\n * @param {string} pattern - Glob pattern to search for\n * @param {Object} options - Options\n * @param {Function} options.requireFn - Function that will require the matches files\n * @param {Function} options.shouldUseFileNameAsKey - Weather to use the filename as a key in the Object path or not\n * @param {Object} options.globArgs - extra glob function arguments\n */\nconst loadFiles = async (\n  dir,\n  pattern,\n  { requireFn = require, shouldUseFileNameAsKey = () => true, globArgs = {} } = {}\n) => {\n  const root = {};\n  const files = await glob(pattern, { cwd: dir, ...globArgs });\n\n  for (let file of files) {\n    const absolutePath = path.resolve(dir, file);\n\n    // load module\n    delete require.cache[absolutePath];\n    let mod;\n\n    if (path.extname(absolutePath) === '.json') {\n      mod = await fse.readJson(absolutePath);\n    } else {\n      mod = requireFn(absolutePath);\n    }\n\n    Object.defineProperty(mod, '__filename__', {\n      enumerable: true,\n      configurable: false,\n      writable: false,\n      value: path.basename(file),\n    });\n\n    const propPath = filePathToPath(file, shouldUseFileNameAsKey(file));\n\n    if (propPath.length === 0) _.merge(root, mod);\n    _.merge(root, _.setWith({}, propPath, mod, Object));\n  }\n\n  return root;\n};\n\nmodule.exports = loadFiles;\n",
    "packages/strapi/lib/middlewares/boom/index.js": "'use strict';\n\n/**\n * Boom hook\n */\n\n// Public node modules.\nconst _ = require('lodash');\nconst Boom = require('boom');\nconst delegate = require('delegates');\n\nconst boomMethods = [\n  'badRequest',\n  'unauthorized',\n  'paymentRequired',\n  'forbidden',\n  'notFound',\n  'methodNotAllowed',\n  'notAcceptable',\n  'proxyAuthRequired',\n  'clientTimeout',\n  'conflict',\n  'resourceGone',\n  'lengthRequired',\n  'preconditionFailed',\n  'entityTooLarge',\n  'uriTooLong',\n  'unsupportedMediaType',\n  'rangeNotSatisfiable',\n  'expectationFailed',\n  'teapot',\n  'badData',\n  'locked',\n  'failedDependency',\n  'preconditionRequired',\n  'tooManyRequests',\n  'illegal',\n  'badImplementation',\n  'notImplemented',\n  'badGateway',\n  'serverUnavailable',\n  'gatewayTimeout',\n];\n\nconst formatBoomPayload = boomError => {\n  if (!Boom.isBoom(boomError)) {\n    boomError = Boom.boomify(boomError, {\n      statusCode: boomError.status || 500,\n    });\n  }\n\n  const { output } = boomError;\n\n  if (output.statusCode < 500 && !_.isNil(boomError.data)) {\n    output.payload.data = boomError.data;\n  }\n\n  return { status: output.statusCode, body: output.payload };\n};\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      this.delegator = delegate(strapi.app.context, 'response');\n      this.createResponses();\n\n      strapi.errors = Boom;\n      strapi.app.use(async (ctx, next) => {\n        try {\n          // App logic.\n          await next();\n        } catch (error) {\n          // emit error if configured\n          if (strapi.config.get('server.emitErrors', false)) {\n            strapi.app.emit('error', error, ctx);\n          }\n\n          // Log error.\n\n          const { status, body } = formatBoomPayload(error);\n\n          if (status >= 500) {\n            strapi.log.error(error);\n          }\n\n          ctx.body = body;\n          ctx.status = status;\n        }\n      });\n\n      strapi.app.use(async (ctx, next) => {\n        await next();\n        // Empty body is considered as `notFound` response.\n        if (_.isNil(ctx.body) && _.isNil(ctx.status)) {\n          ctx.notFound();\n        }\n      });\n    },\n\n    // Custom function to avoid ctx.body repeat\n    createResponses() {\n      boomMethods.forEach(method => {\n        strapi.app.response[method] = function(msg, ...rest) {\n          const boomError = Boom[method](msg, ...rest) || {};\n\n          const { status, body } = formatBoomPayload(boomError);\n\n          // keep retro-compatibility for old error formats\n          body.message = msg || body.data || body.message;\n\n          this.body = body;\n          this.status = status;\n        };\n\n        this.delegator.method(method);\n      });\n\n      strapi.app.response.send = function(data, status = 200) {\n        this.status = status;\n        this.body = data;\n      };\n\n      strapi.app.response.created = function(data) {\n        this.status = 201;\n        this.body = data;\n      };\n\n      strapi.app.response.deleted = function(data) {\n        if (_.isNil(data)) {\n          this.status = 204;\n        } else {\n          this.status = 200;\n          this.body = data;\n        }\n      };\n\n      this.delegator\n        .method('send')\n        .method('created')\n        .method('deleted');\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/cors/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\nconst cors = require('@koa/cors');\n\nconst defaults = {\n  origin: '*',\n  maxAge: 31536000,\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS'],\n  headers: ['Content-Type', 'Authorization', 'Origin', 'Accept'],\n  keepHeadersOnError: false,\n};\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n    initialize() {\n      const {\n        origin,\n        expose,\n        maxAge,\n        credentials,\n        methods,\n        headers,\n        keepHeadersOnError,\n      } = Object.assign({}, defaults, strapi.config.get('middleware.settings.cors'));\n\n      strapi.app.use(\n        cors({\n          origin: async function(ctx) {\n            let originList;\n\n            if (typeof origin === 'function') {\n              originList = await origin(ctx);\n            } else {\n              originList = origin;\n            }\n\n            const whitelist = Array.isArray(originList) ? originList : originList.split(/\\s*,\\s*/);\n\n            const requestOrigin = ctx.accept.headers.origin;\n            if (whitelist.includes('*')) {\n              return '*';\n            }\n\n            if (!whitelist.includes(requestOrigin)) {\n              return ctx.throw(`${requestOrigin} is not a valid origin`);\n            }\n            return requestOrigin;\n          },\n          exposeHeaders: expose,\n          maxAge,\n          credentials,\n          allowMethods: methods,\n          allowHeaders: headers,\n          keepHeadersOnError,\n        })\n      );\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/csp/index.js": "'use strict';\n\nconst convert = require('koa-convert');\nconst { csp } = require('koa-lusca');\n/**\n * CSP hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        if (ctx.request.admin) return await next();\n\n        return await convert(csp(strapi.config.middleware.settings.csp))(\n          ctx,\n          next\n        );\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/hsts/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\nconst convert = require('koa-convert');\nconst { hsts } = require('koa-lusca');\n\n/**\n * HSTS hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        if (ctx.request.admin) return next();\n\n        return await convert(hsts(strapi.config.middleware.settings.hsts))(\n          ctx,\n          next\n        );\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/logger/index.js": "'use strict';\nconst chalk = require('chalk');\nconst _ = require('lodash');\n\nconst codeToColor = code => {\n  return code >= 500\n    ? chalk.red(code)\n    : code >= 400\n    ? chalk.yellow(code)\n    : code >= 300\n    ? chalk.cyan(code)\n    : code >= 200\n    ? chalk.green(code)\n    : code;\n};\n\n/**\n * Logger hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n    initialize() {\n      const { level, exposeInContext, requests } = strapi.config.middleware.settings.logger;\n\n      const logLevels = Object.keys(strapi.log.levels.values);\n\n      if (!_.includes(logLevels, level)) {\n        throw new Error(\n          \"Invalid log level set in middleware configuration. Accepted values are: '\" +\n            logLevels.join(\"', '\") +\n            \"'.\"\n        );\n      }\n\n      strapi.log.level = level;\n\n      if (exposeInContext) {\n        strapi.app.context.log = strapi.log;\n      }\n\n      const isLogLevelEnvVariableSet = _.isString(process.env.STRAPI_LOG_LEVEL);\n\n      if (isLogLevelEnvVariableSet && strapi.log.levelVal <= 20) {\n        strapi.log.debug(\n          `STRAPI_LOG_LEVEL environment variable is overridden by logger middleware. It only applies outside Strapi's middleware context.`\n        );\n      }\n\n      if (requests && strapi.log.levelVal <= 20) {\n        strapi.app.use(async (ctx, next) => {\n          const start = Date.now();\n          await next();\n          const delta = Math.ceil(Date.now() - start);\n          strapi.log.debug(`${ctx.method} ${ctx.url} (${delta} ms) ${codeToColor(ctx.status)}`);\n        });\n      }\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/p3p/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\nconst convert = require('koa-convert');\nconst { p3p } = require('koa-lusca');\n/**\n * P3P hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        if (ctx.request.admin) return next();\n\n        return await convert(p3p(strapi.config.middleware.settings.p3p))(\n          ctx,\n          next\n        );\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/parser/index.js": "'use strict';\n\nconst body = require('koa-body');\nconst qs = require('qs');\nconst { omit } = require('lodash');\n\n/**\n * Body parser hook\n */\nconst addQsParser = (app, settings) => {\n  Object.defineProperty(app.request, 'query', {\n    configurable: false,\n    enumerable: true,\n    /*\n     * Get parsed query-string.\n     */\n    get() {\n      const qstr = this.querystring;\n      const cache = (this._querycache = this._querycache || {});\n      return cache[qstr] || (cache[qstr] = qs.parse(qstr, settings));\n    },\n\n    /*\n     * Set query-string as an object.\n     */\n    set(obj) {\n      this.querystring = qs.stringify(obj);\n    },\n  });\n\n  return app;\n};\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        // disable for graphql\n        // TODO: find a better way later\n        if (ctx.url === '/graphql') {\n          return next();\n        }\n\n        try {\n          const res = await body({\n            patchKoa: true,\n            ...omit(strapi.config.middleware.settings.parser, 'queryStringParser'),\n          })(ctx, next);\n          return res;\n        } catch (e) {\n          if (e.message.includes('maxFileSize exceeded')) {\n            throw strapi.errors.entityTooLarge('FileTooBig', {\n              errors: [\n                {\n                  id: 'Upload.status.sizeLimit',\n                  message: `file is bigger than the limit size!`,\n                },\n              ],\n            });\n          }\n          throw e;\n        }\n      });\n\n      addQsParser(strapi.app, strapi.config.get('middleware.settings.parser.queryStringParser'));\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/poweredBy/index.js": "'use strict';\n\nmodule.exports = strapi => {\n  return {\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        await next();\n\n        ctx.set(\n          'X-Powered-By',\n          strapi.config.get('middleware.settings.poweredBy.value', 'Strapi <strapi.io>')\n        );\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/public/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Node.js core.\nconst fs = require('fs');\nconst path = require('path');\nconst stream = require('stream');\nconst _ = require('lodash');\nconst koaStatic = require('koa-static');\nconst utils = require('../../utils');\nconst serveStatic = require('./serve-static');\n\n/**\n * Public assets hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    async initialize() {\n      const { defaultIndex, maxAge, path: publicPath } = strapi.config.middleware.settings.public;\n      const staticDir = path.resolve(strapi.dir, publicPath || strapi.config.paths.static);\n\n      if (defaultIndex === true) {\n        const index = fs.readFileSync(path.join(__dirname, 'index.html'), 'utf8');\n\n        const serveIndexPage = async (ctx, next) => {\n          // defer rendering of strapi index page\n          await next();\n          if (ctx.body != null || ctx.status !== 404) return;\n\n          ctx.url = 'index.html';\n          const isInitialised = await utils.isInitialised(strapi);\n          const data = {\n            serverTime: new Date().toUTCString(),\n            isInitialised,\n            ..._.pick(strapi, [\n              'config.info.version',\n              'config.info.name',\n              'config.admin.url',\n              'config.server.url',\n              'config.environment',\n              'config.serveAdminPanel',\n            ]),\n          };\n          const content = _.template(index)(data);\n          const body = stream.Readable({\n            read() {\n              this.push(Buffer.from(content));\n              this.push(null);\n            },\n          });\n          // Serve static.\n          ctx.type = 'html';\n          ctx.body = body;\n        };\n\n        strapi.router.get('/', serveIndexPage);\n        strapi.router.get('/index.html', serveIndexPage);\n        strapi.router.get(\n          '/assets/images/(.*)',\n          serveStatic(path.resolve(__dirname, 'assets/images'), { maxage: maxAge, defer: true })\n        );\n      }\n\n      // serve files in public folder unless a sub router renders something else\n      strapi.router.get(\n        '/(.*)',\n        koaStatic(staticDir, {\n          maxage: maxAge,\n          defer: true,\n        })\n      );\n\n      if (!strapi.config.serveAdminPanel) return;\n\n      const buildDir = path.resolve(strapi.dir, 'build');\n      const serveAdmin = ctx => {\n        ctx.type = 'html';\n        ctx.body = fs.createReadStream(path.join(buildDir + '/index.html'));\n      };\n\n      strapi.router.get(\n        `${strapi.config.admin.path}/*`,\n        serveStatic(buildDir, { maxage: maxAge, defer: false, index: 'index.html' })\n      );\n\n      strapi.router.get(`${strapi.config.admin.path}`, serveAdmin);\n      strapi.router.get(`${strapi.config.admin.path}/*`, serveAdmin);\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/public/serve-static.js": "'use strict';\n\nconst path = require('path');\nconst koaStatic = require('koa-static');\n\n// serveStatic is not supposed to be used to serve a folder that have sub-folders\nconst serveStatic = (filesDir, koaStaticOptions = {}) => {\n  const serve = koaStatic(filesDir, koaStaticOptions);\n\n  return async (ctx, next) => {\n    const prev = ctx.path;\n    const newPath = path.basename(ctx.path);\n    ctx.path = newPath;\n    await serve(ctx, async () => {\n      ctx.path = prev;\n      await next();\n      ctx.path = newPath;\n    });\n    ctx.path = prev;\n  };\n};\n\nmodule.exports = serveStatic;\n",
    "packages/strapi/lib/middlewares/responseTime/index.js": "'use strict';\n\n/**\n * X-Response-Time hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        const start = Date.now();\n\n        await next();\n\n        const delta = Math.ceil(Date.now() - start);\n\n        ctx.set('X-Response-Time', delta + 'ms'); // eslint-disable-line prefer-template\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/responses/index.js": "'use strict';\n\nconst _ = require('lodash');\n\nmodule.exports = strapi => {\n  return {\n    initialize() {\n      strapi.app.use(async (ctx, next) => {\n        await next();\n\n        const responseFn = strapi.config.get(['functions', 'responses', ctx.status]);\n        if (_.isFunction(responseFn)) {\n          await responseFn(ctx);\n        }\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/router/utils/routerChecker.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst _ = require('lodash');\n\n// Strapi utilities.\nconst { finder, policy: policyUtils } = require('strapi-utils');\n\nconst getMethod = route => _.trim(_.toLower(route.method));\nconst getEndpoint = route => _.trim(route.path);\n\nmodule.exports = strapi =>\n  function routerChecker(value, plugin) {\n    const method = getMethod(value);\n    const endpoint = getEndpoint(value);\n\n    // Define controller and action names.\n    const [controllerName, actionName] = _.trim(value.handler).split('.');\n    const controllerKey = _.toLower(controllerName);\n\n    let controller;\n\n    if (plugin) {\n      controller =\n        plugin === 'admin'\n          ? strapi.admin.controllers[controllerKey]\n          : strapi.plugins[plugin].controllers[controllerKey];\n    } else {\n      controller = strapi.controllers[controllerKey];\n    }\n\n    if (!_.isFunction(controller[actionName])) {\n      strapi.stopWithError(\n        `Error creating endpoint ${method} ${endpoint}: handler not found \"${controllerKey}.${actionName}\"`\n      );\n    }\n\n    const action = controller[actionName].bind(controller);\n\n    // Retrieve the API's name where the controller is located\n    // to access to the right validators\n    const currentApiName = finder(strapi.plugins[plugin] || strapi.api || strapi.admin, controller);\n\n    // Add the `globalPolicy`.\n    const globalPolicy = policyUtils.globalPolicy({\n      controller: controllerKey,\n      action: actionName,\n      method,\n      endpoint,\n      plugin,\n    });\n\n    // Init policies array.\n    const policies = [globalPolicy];\n\n    let policyOption = _.get(value, 'config.policies');\n\n    // Allow string instead of array of policies.\n    if (_.isString(policyOption) && !_.isEmpty(policyOption)) {\n      policyOption = [policyOption];\n    }\n\n    if (_.isArray(policyOption)) {\n      policyOption.forEach(policyName => {\n        try {\n          policies.push(policyUtils.get(policyName, plugin, currentApiName));\n        } catch (error) {\n          strapi.stopWithError(`Error creating endpoint ${method} ${endpoint}: ${error.message}`);\n        }\n      });\n    }\n\n    policies.push(async (ctx, next) => {\n      // Set body.\n      const values = await next();\n\n      if (_.isNil(ctx.body) && !_.isNil(values)) {\n        ctx.body = values;\n      }\n    });\n\n    return {\n      method,\n      endpoint,\n      policies,\n      action,\n    };\n  };\n",
    "packages/strapi/lib/middlewares/xframe/index.js": "'use strict';\n\nconst convert = require('koa-convert');\nconst { xframe } = require('koa-lusca');\n\n/**\n * CRON hook\n */\n\nmodule.exports = strapi => {\n  return {\n    /**\n     * Initialize the hook\n     */\n\n    initialize() {\n      const defaults = require('./defaults.json');\n\n      strapi.app.use(async (ctx, next) => {\n        if (ctx.request.admin) {\n          return await convert(xframe(defaults.xframe))(ctx, next);\n        }\n\n        const { enabled, value } = strapi.config.get('middleware.settings.xframe', {});\n        if (enabled) {\n          return await convert(xframe(value))(ctx, next);\n        }\n\n        await next();\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/middlewares/xss/index.js": "'use strict';\n\nconst convert = require('koa-convert');\nconst { xssProtection } = require('koa-lusca');\n\nmodule.exports = strapi => {\n  return {\n    initialize() {\n      const defaults = require('./defaults.json');\n\n      strapi.app.use(async (ctx, next) => {\n        if (ctx.request.admin) {\n          return await convert(\n            xssProtection({\n              enabled: true,\n              mode: defaults.xss.mode,\n            })\n          )(ctx, next);\n        }\n\n        const xssConfig = strapi.config.get('middleware.settings.xss');\n        if (xssConfig.enabled) {\n          return await convert(xssProtection(xssConfig))(ctx, next);\n        }\n\n        await next();\n      });\n    },\n  };\n};\n",
    "packages/strapi/lib/services/__tests__/entity-service.test.js": "'use strict';\n\nconst { EventEmitter } = require('events');\nconst createEntityService = require('../entity-service');\nconst entityValidator = require('../entity-validator');\n\ndescribe('Entity service', () => {\n  global.strapi = {\n    getModel: jest.fn(() => ({})),\n    config: {\n      get() {\n        return [];\n      },\n    },\n  };\n\n  describe('Find', () => {\n    test('Returns first element for single types', async () => {\n      const data = {\n        id: 1,\n        title: 'Test',\n      };\n\n      const fakeQuery = {\n        find: jest.fn(() => Promise.resolve([data])),\n      };\n\n      const fakeDB = {\n        getModel: jest.fn(() => {\n          return { kind: 'singleType', privateAttributes: [] };\n        }),\n        query: jest.fn(() => fakeQuery),\n      };\n\n      const instance = createEntityService({\n        db: fakeDB,\n        eventHub: new EventEmitter(),\n      });\n\n      const result = await instance.find({}, { model: 'test-model' });\n\n      expect(fakeDB.getModel).toHaveBeenCalledTimes(1);\n      expect(fakeDB.getModel).toHaveBeenCalledWith('test-model');\n\n      expect(fakeDB.query).toHaveBeenCalledWith('test-model');\n      expect(fakeQuery.find).toHaveBeenCalledWith({ _limit: 1 }, undefined);\n      expect(result).toEqual(data);\n    });\n  });\n\n  describe('Create', () => {\n    test('Throws when trying to create a new single type entry if there is already one', async () => {\n      const fakeQuery = {\n        count: jest.fn(() => Promise.resolve(1)),\n      };\n\n      const fakeDB = {\n        getModel: jest.fn(() => {\n          return { kind: 'singleType', privateAttributes: [] };\n        }),\n        query: jest.fn(() => fakeQuery),\n      };\n\n      const instance = createEntityService({\n        db: fakeDB,\n        eventHub: new EventEmitter(),\n      });\n\n      await expect(instance.create({ data: {} }, { model: 'test-model' })).rejects.toThrow(\n        'Single type entry can only be created once'\n      );\n\n      expect(fakeDB.getModel).toHaveBeenCalledTimes(1);\n      expect(fakeDB.getModel).toHaveBeenCalledWith('test-model');\n\n      expect(fakeDB.query).toHaveBeenCalledWith('test-model');\n      expect(fakeQuery.count).toHaveBeenCalled();\n    });\n\n    describe('assign default values', () => {\n      let instance;\n\n      beforeAll(() => {\n        const fakeQuery = {\n          count: jest.fn(() => 0),\n          create: jest.fn(data => data),\n        };\n\n        const fakeModel = {\n          kind: 'contentType',\n          modelName: 'test-model',\n          privateAttributes: [],\n          options: {},\n          attributes: {\n            attrStringDefaultRequired: { type: 'string', default: 'default value', required: true },\n            attrStringDefault: { type: 'string', default: 'default value' },\n            attrBoolDefaultRequired: { type: 'boolean', default: true, required: true },\n            attrBoolDefault: { type: 'boolean', default: true },\n            attrIntDefaultRequired: { type: 'integer', default: 1, required: true },\n            attrIntDefault: { type: 'integer', default: 1 },\n            attrEnumDefaultRequired: {\n              type: 'enumeration',\n              enum: ['a', 'b', 'c'],\n              default: 'a',\n              required: true,\n            },\n            attrEnumDefault: {\n              type: 'enumeration',\n              enum: ['a', 'b', 'c'],\n              default: 'b',\n            },\n          },\n        };\n\n        const fakeDB = {\n          getModel: jest.fn(() => fakeModel),\n          query: jest.fn(() => fakeQuery),\n        };\n\n        instance = createEntityService({\n          db: fakeDB,\n          eventHub: new EventEmitter(),\n          entityValidator,\n        });\n      });\n\n      test('should create record with all default attributes', async () => {\n        const data = {};\n\n        await expect(instance.create({ data }, { model: 'test-model' })).resolves.toMatchObject({\n          attrStringDefaultRequired: 'default value',\n          attrStringDefault: 'default value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 1,\n          attrIntDefault: 1,\n          attrEnumDefaultRequired: 'a',\n          attrEnumDefault: 'b',\n        });\n      });\n\n      test('should create record with default and required attributes', async () => {\n        const data = {\n          attrStringDefault: 'my value',\n          attrBoolDefault: false,\n          attrIntDefault: 2,\n          attrEnumDefault: 'c',\n        };\n\n        await expect(instance.create({ data }, { model: 'test-model' })).resolves.toMatchObject({\n          attrStringDefault: 'my value',\n          attrBoolDefault: false,\n          attrIntDefault: 2,\n          attrEnumDefault: 'c',\n          attrStringDefaultRequired: 'default value',\n          attrBoolDefaultRequired: true,\n          attrIntDefaultRequired: 1,\n          attrEnumDefaultRequired: 'a',\n        });\n      });\n\n      test('should create record with provided data', async () => {\n        const data = {\n          attrStringDefaultRequired: 'my value',\n          attrStringDefault: 'my value',\n          attrBoolDefaultRequired: true,\n          attrBoolDefault: true,\n          attrIntDefaultRequired: 10,\n          attrIntDefault: 10,\n          attrEnumDefaultRequired: 'c',\n          attrEnumDefault: 'a',\n        };\n\n        await expect(instance.create({ data }, { model: 'test-model' })).resolves.toMatchObject(\n          data\n        );\n      });\n    });\n  });\n});\n",
    "packages/strapi/lib/services/__tests__/entity-validator.test.js": "'use strict';\n\nconst entityValidator = require('../entity-validator');\n\ndescribe('Entity validator', () => {\n  describe('Published input', () => {\n    describe('General Errors', () => {\n      it('Throws a badRequest error on invalid input', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        };\n\n        const input = { title: 1234 };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, input).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith(\n            'ValidationError',\n            expect.any(Object)\n          );\n        });\n      });\n\n      it('Returns data on valid input', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        };\n\n        const input = { title: 'test Title' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input);\n        expect(data).toEqual(input);\n      });\n\n      it('Returns casted data when possible', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n            number: {\n              type: 'integer',\n            },\n          },\n        };\n\n        const input = { title: 'Test', number: '123' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input);\n        expect(data).toEqual({\n          title: 'Test',\n          number: 123,\n        });\n      });\n\n      test('Throws on required not respected', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n            },\n          },\n        };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, {}).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith('ValidationError', {\n            errors: { title: [expect.stringMatching('must be defined')] },\n          });\n        });\n\n        await entityValidator.validateEntityCreation(model, { title: null }).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith('ValidationError', {\n            errors: { title: [expect.stringMatching('must be defined')] },\n          });\n        });\n      });\n\n      it('Supports custom field types', async () => {\n        const model = {\n          attributes: {\n            uuid: {\n              type: 'uuid',\n            },\n          },\n        };\n\n        const input = { uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input);\n        expect(data).toEqual({\n          uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7',\n        });\n      });\n    });\n\n    describe('String validator', () => {\n      test('Throws on min length not respected', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              minLength: 10,\n            },\n          },\n        };\n\n        const input = { title: 'tooSmall' };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, input).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith('ValidationError', {\n            errors: { title: [expect.stringMatching('at least 10 characters')] },\n          });\n        });\n      });\n\n      test('Throws on max length not respected', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              maxLength: 2,\n            },\n          },\n        };\n\n        const input = { title: 'tooLong' };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, input).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith('ValidationError', {\n            errors: { title: [expect.stringMatching('at most 2 characters')] },\n          });\n        });\n      });\n\n      test('Allows empty strings even when required', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n            },\n          },\n        };\n\n        const input = { title: '' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input);\n        expect(data).toEqual(input);\n      });\n\n      test('Assign default values', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n              default: 'New',\n            },\n            type: {\n              type: 'string',\n              default: 'test',\n            },\n            testDate: {\n              type: 'date',\n              required: true,\n              default: '2020-04-01T04:00:00.000Z',\n            },\n            testJSON: {\n              type: 'date',\n              required: true,\n              default: {\n                foo: 1,\n                bar: 2,\n              },\n            },\n          },\n        };\n\n        await expect(entityValidator.validateEntityCreation(model, {})).resolves.toMatchObject({\n          title: 'New',\n          type: 'test',\n          testDate: '2020-04-01T04:00:00.000Z',\n          testJSON: {\n            foo: 1,\n            bar: 2,\n          },\n        });\n      });\n\n      test(\"Don't assign default value if empty string\", async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n              default: 'default',\n            },\n            content: {\n              type: 'string',\n              default: 'default',\n            },\n          },\n        };\n\n        await expect(\n          entityValidator.validateEntityCreation(model, {\n            title: '',\n            content: '',\n          })\n        ).resolves.toMatchObject({\n          title: '',\n          content: '',\n        });\n      });\n    });\n  });\n\n  describe('Draft input', () => {\n    describe('General Errors', () => {\n      it('Throws a badRequest error on invalid input', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        };\n\n        const input = { title: 1234 };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, input, { isDraft: true }).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith(\n            'ValidationError',\n            expect.any(Object)\n          );\n        });\n      });\n\n      it('Returns data on valid input', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        };\n\n        const input = { title: 'test Title' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });\n        expect(data).toEqual(input);\n      });\n\n      it('Returns casted data when possible', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n            number: {\n              type: 'integer',\n            },\n          },\n        };\n\n        const input = { title: 'Test', number: '123' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });\n        expect(data).toEqual({\n          title: 'Test',\n          number: 123,\n        });\n      });\n\n      test('Does not throws on required not respected', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n            },\n          },\n        };\n\n        expect.hasAssertions();\n\n        let data = await entityValidator.validateEntityCreation(model, {}, { isDraft: true });\n        expect(data).toEqual({});\n\n        data = await entityValidator.validateEntityCreation(\n          model,\n          { title: null },\n          { isDraft: true }\n        );\n        expect(data).toEqual({ title: null });\n      });\n\n      it('Supports custom field types', async () => {\n        const model = {\n          attributes: {\n            uuid: {\n              type: 'uuid',\n            },\n          },\n        };\n\n        const input = { uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });\n        expect(data).toEqual({\n          uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7',\n        });\n      });\n    });\n\n    describe('String validator', () => {\n      test('Does not throws on min length not respected', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              minLength: 10,\n            },\n          },\n        };\n\n        const input = { title: 'tooSmall' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });\n        expect(data).toEqual(input);\n      });\n\n      test('Throws on max length not respected', async () => {\n        global.strapi = {\n          errors: {\n            badRequest: jest.fn(),\n          },\n        };\n\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              maxLength: 2,\n            },\n          },\n        };\n\n        const input = { title: 'tooLong' };\n\n        expect.hasAssertions();\n\n        await entityValidator.validateEntityCreation(model, input, { isDraft: true }).catch(() => {\n          expect(strapi.errors.badRequest).toHaveBeenCalledWith('ValidationError', {\n            errors: { title: [expect.stringMatching('at most 2 characters')] },\n          });\n        });\n      });\n\n      test('Allows empty strings even when required', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        };\n\n        const input = { title: '' };\n\n        expect.hasAssertions();\n\n        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });\n        expect(data).toEqual(input);\n      });\n\n      test('Assign default values', async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n              default: 'New',\n            },\n            type: {\n              type: 'string',\n              default: 'test',\n            },\n            testDate: {\n              type: 'date',\n              required: true,\n              default: '2020-04-01T04:00:00.000Z',\n            },\n            testJSON: {\n              type: 'date',\n              required: true,\n              default: {\n                foo: 1,\n                bar: 2,\n              },\n            },\n          },\n        };\n\n        await expect(\n          entityValidator.validateEntityCreation(model, {}, { isDraft: true })\n        ).resolves.toMatchObject({\n          title: 'New',\n          type: 'test',\n          testDate: '2020-04-01T04:00:00.000Z',\n          testJSON: {\n            foo: 1,\n            bar: 2,\n          },\n        });\n      });\n\n      test(\"Don't assign default value if empty string\", async () => {\n        const model = {\n          attributes: {\n            title: {\n              type: 'string',\n              required: true,\n              default: 'default',\n            },\n            content: {\n              type: 'string',\n              default: 'default',\n            },\n          },\n        };\n\n        await expect(\n          entityValidator.validateEntityCreation(\n            model,\n            {\n              title: '',\n              content: '',\n            },\n            { isDraft: true }\n          )\n        ).resolves.toMatchObject({\n          title: '',\n          content: '',\n        });\n      });\n    });\n  });\n});\n",
    "packages/strapi/lib/services/core-store.js": "'use strict';\n\nconst coreStoreModel = config => ({\n  connection: config.get('database.defaultConnection'),\n  uid: 'strapi::core-store',\n  internal: true,\n  info: {\n    name: 'core_store',\n    description: '',\n  },\n  attributes: {\n    key: {\n      type: 'string',\n    },\n    value: {\n      type: 'text',\n    },\n    type: {\n      type: 'string',\n    },\n    environment: {\n      type: 'string',\n    },\n    tag: {\n      type: 'string',\n    },\n  },\n  globalId: 'StrapiConfigs',\n  collectionName: 'core_store',\n});\n\nconst createCoreStore = ({ environment: defaultEnv, db }) => {\n  return (source = {}) => {\n    async function get(params = {}) {\n      const { key, environment = defaultEnv, type = 'core', name = '', tag = '' } = Object.assign(\n        {},\n        source,\n        params\n      );\n\n      const prefix = `${type}${name ? `_${name}` : ''}`;\n\n      const where = {\n        key: `${prefix}_${key}`,\n        environment,\n        tag,\n      };\n\n      const data = await db.query('core_store').findOne(where);\n\n      if (!data) {\n        return null;\n      }\n\n      if (\n        data.type === 'object' ||\n        data.type === 'array' ||\n        data.type === 'boolean' ||\n        data.type === 'string'\n      ) {\n        try {\n          return JSON.parse(data.value);\n        } catch (err) {\n          return new Date(data.value);\n        }\n      } else if (data.type === 'number') {\n        return parseFloat(data.value);\n      } else {\n        return null;\n      }\n    }\n\n    async function set(params = {}) {\n      const { key, value, environment = defaultEnv, type, name, tag = '' } = Object.assign(\n        {},\n        source,\n        params\n      );\n\n      const prefix = `${type}${name ? `_${name}` : ''}`;\n\n      const where = {\n        key: `${prefix}_${key}`,\n        environment,\n        tag,\n      };\n\n      const data = await db.query('core_store').findOne(where);\n\n      if (data) {\n        Object.assign(data, {\n          value: JSON.stringify(value) || value.toString(),\n          type: (typeof value).toString(),\n        });\n\n        await db.query('core_store').update({ id: data.id }, data);\n      } else {\n        const data = Object.assign({}, where, {\n          value: JSON.stringify(value) || value.toString(),\n          type: (typeof value).toString(),\n          tag,\n        });\n\n        await db.query('core_store').create(data);\n      }\n    }\n\n    return {\n      get,\n      set,\n    };\n  };\n};\n\nmodule.exports = {\n  coreStoreModel,\n  createCoreStore,\n};\n",
    "packages/strapi/lib/services/entity-service.js": "'use strict';\n\nconst _ = require('lodash');\nconst {\n  sanitizeEntity,\n  webhook: webhookUtils,\n  contentTypes: contentTypesUtils,\n} = require('strapi-utils');\nconst uploadFiles = require('./utils/upload-files');\n\n// TODO: those should be strapi events used by the webhooks not the other way arround\nconst { ENTRY_CREATE, ENTRY_UPDATE, ENTRY_DELETE } = webhookUtils.webhookEvents;\n\nmodule.exports = ({ db, eventHub, entityValidator }) => ({\n  /**\n   * expose some utils so the end users can use them\n   */\n  uploadFiles,\n  /**\n   * Promise to fetch all records\n   *\n   * @return {Promise}\n   */\n  async find({ params, populate }, { model }) {\n    const { kind } = db.getModel(model);\n\n    // return first element and ignore filters\n    if (kind === 'singleType') {\n      const results = await db.query(model).find({ ...params, _limit: 1 }, populate);\n      return _.first(results) || null;\n    }\n\n    return db.query(model).find(params, populate);\n  },\n\n  findPage({ params, populate }, { model }) {\n    return db.query(model).findPage(params, populate);\n  },\n\n  findWithRelationCounts({ params, populate }, { model }) {\n    return db.query(model).findWithRelationCounts(params, populate);\n  },\n\n  /**\n   * Promise to fetch record\n   *\n   * @return {Promise}\n   */\n\n  findOne({ params, populate }, { model }) {\n    return db.query(model).findOne(params, populate);\n  },\n\n  /**\n   * Promise to count record\n   *\n   * @return {Promise}\n   */\n\n  count({ params }, { model }) {\n    return db.query(model).count(params);\n  },\n\n  /**\n   * Promise to add record\n   *\n   * @return {Promise}\n   */\n\n  async create({ data, files }, { model }) {\n    const modelDef = db.getModel(model);\n\n    if (modelDef.kind === 'singleType') {\n      // check if there is already one entry and throw\n      const count = await db.query(model).count();\n      if (count >= 1) {\n        throw new Error('Single type entry can only be created once');\n      }\n    }\n\n    const isDraft = contentTypesUtils.isDraft(data, modelDef);\n\n    const validData = await entityValidator.validateEntityCreation(modelDef, data, { isDraft });\n\n    let entry = await db.query(model).create(validData);\n\n    if (files && Object.keys(files).length > 0) {\n      await this.uploadFiles(entry, files, { model });\n      entry = await this.findOne({ params: { id: entry.id } }, { model });\n    }\n\n    eventHub.emit(ENTRY_CREATE, {\n      model: modelDef.modelName,\n      entry: sanitizeEntity(entry, { model: modelDef }),\n    });\n\n    return entry;\n  },\n\n  /**\n   * Promise to edit record\n   *\n   * @return {Promise}\n   */\n\n  async update({ params, data, files }, { model }) {\n    const modelDef = db.getModel(model);\n    const existingEntry = await db.query(model).findOne(params);\n\n    const isDraft = contentTypesUtils.isDraft(existingEntry, modelDef);\n\n    const validData = await entityValidator.validateEntityUpdate(modelDef, data, {\n      isDraft,\n    });\n\n    let entry = await db.query(model).update(params, validData);\n\n    if (files && Object.keys(files).length > 0) {\n      await this.uploadFiles(entry, files, { model });\n      entry = await this.findOne({ params: { id: entry.id } }, { model });\n    }\n\n    eventHub.emit(ENTRY_UPDATE, {\n      model: modelDef.modelName,\n      entry: sanitizeEntity(entry, { model: modelDef }),\n    });\n\n    return entry;\n  },\n\n  /**\n   * Promise to delete a record\n   *\n   * @return {Promise}\n   */\n\n  async delete({ params }, { model }) {\n    const entry = await db.query(model).delete(params);\n\n    const modelDef = db.getModel(model);\n    eventHub.emit(ENTRY_DELETE, {\n      model: modelDef.modelName,\n      entry: sanitizeEntity(entry, { model: modelDef }),\n    });\n\n    return entry;\n  },\n\n  /**\n   * Promise to search records\n   *\n   * @return {Promise}\n   */\n\n  search({ params, populate }, { model }) {\n    return db.query(model).search(params, populate);\n  },\n\n  searchWithRelationCounts({ params, populate }, { model }) {\n    return db.query(model).searchWithRelationCounts(params, populate);\n  },\n\n  searchPage({ params, populate }, { model }) {\n    return db.query(model).searchPage(params, populate);\n  },\n\n  /**\n   * Promise to count searched records\n   *\n   * @return {Promise}\n   */\n  countSearch({ params }, { model }) {\n    return db.query(model).countSearch(params);\n  },\n});\n",
    "packages/strapi/lib/services/entity-validator/index.js": "/**\n * Entity validator\n * Module that will validate input data for entity creation or edition\n */\n'use strict';\n\nconst { has, assoc, prop } = require('lodash/fp');\nconst strapiUtils = require('strapi-utils');\nconst validators = require('./validators');\n\nconst { yup, formatYupErrors } = strapiUtils;\nconst { isMediaAttribute, isScalarAttribute, getWritableAttributes } = strapiUtils.contentTypes;\n\nconst addMinMax = (attr, validator, data) => {\n  if (Number.isInteger(attr.min) && (attr.required || (Array.isArray(data) && data.length > 0))) {\n    validator = validator.min(attr.min);\n  }\n  if (Number.isInteger(attr.max)) {\n    validator = validator.max(attr.max);\n  }\n  return validator;\n};\n\nconst addRequiredValidation = createOrUpdate => (required, validator) => {\n  if (required) {\n    if (createOrUpdate === 'creation') {\n      validator = validator.notNil();\n    } else if (createOrUpdate === 'update') {\n      validator = validator.notNull();\n    }\n  } else {\n    validator = validator.nullable();\n  }\n  return validator;\n};\n\nconst addDefault = createOrUpdate => (attr, validator) => {\n  if (createOrUpdate === 'creation') {\n    if (\n      ((attr.type === 'component' && attr.repeatable) || attr.type === 'dynamiczone') &&\n      !attr.required\n    ) {\n      validator = validator.default([]);\n    } else {\n      validator = validator.default(attr.default);\n    }\n  } else {\n    validator = validator.default(undefined);\n  }\n\n  return validator;\n};\n\nconst preventCast = validator => validator.transform((val, originalVal) => originalVal);\n\nconst createComponentValidator = createOrUpdate => (attr, data, { isDraft }) => {\n  let validator;\n\n  const [model] = strapi.db.getModelsByAttribute(attr);\n  if (!model) {\n    throw new Error('Validation failed: Model not found');\n  }\n\n  if (prop('repeatable', attr) === true) {\n    validator = yup\n      .array()\n      .of(\n        yup.lazy(item => createModelValidator(createOrUpdate)(model, item, { isDraft }).notNull())\n      );\n    validator = addRequiredValidation(createOrUpdate)(true, validator);\n    validator = addMinMax(attr, validator, data);\n  } else {\n    validator = createModelValidator(createOrUpdate)(model, data, { isDraft });\n    validator = addRequiredValidation(createOrUpdate)(!isDraft && attr.required, validator);\n  }\n\n  return validator;\n};\n\nconst createDzValidator = createOrUpdate => (attr, data, { isDraft }) => {\n  let validator;\n\n  validator = yup.array().of(\n    yup.lazy(item => {\n      const model = strapi.getModel(prop('__component', item));\n      const schema = yup\n        .object()\n        .shape({\n          __component: yup\n            .string()\n            .required()\n            .oneOf(Object.keys(strapi.components)),\n        })\n        .notNull();\n\n      return model\n        ? schema.concat(createModelValidator(createOrUpdate)(model, item, { isDraft }))\n        : schema;\n    })\n  );\n  validator = addRequiredValidation(createOrUpdate)(true, validator);\n  validator = addMinMax(attr, validator, data);\n\n  return validator;\n};\n\nconst createRelationValidator = createOrUpdate => (attr, data, { isDraft }) => {\n  let validator;\n\n  if (Array.isArray(data)) {\n    validator = yup.array().of(yup.mixed());\n  } else {\n    validator = yup.mixed();\n  }\n  validator = addRequiredValidation(createOrUpdate)(!isDraft && attr.required, validator);\n\n  return validator;\n};\n\nconst createScalarAttributeValidator = createOrUpdate => (attr, { isDraft }) => {\n  let validator;\n\n  if (has(attr.type, validators)) {\n    validator = validators[attr.type](attr, { isDraft });\n  } else {\n    // No validators specified - fall back to mixed\n    validator = yup.mixed();\n  }\n\n  validator = addRequiredValidation(createOrUpdate)(!isDraft && attr.required, validator);\n\n  return validator;\n};\n\nconst createAttributeValidator = createOrUpdate => (attr, data, { isDraft }) => {\n  let validator;\n  if (isMediaAttribute(attr)) {\n    validator = yup.mixed();\n  } else if (isScalarAttribute(attr)) {\n    validator = createScalarAttributeValidator(createOrUpdate)(attr, { isDraft });\n  } else {\n    if (attr.type === 'component') {\n      validator = createComponentValidator(createOrUpdate)(attr, data, { isDraft });\n    } else if (attr.type === 'dynamiczone') {\n      validator = createDzValidator(createOrUpdate)(attr, data, { isDraft });\n    } else {\n      validator = createRelationValidator(createOrUpdate)(attr, data, { isDraft });\n    }\n\n    validator = preventCast(validator);\n  }\n\n  validator = addDefault(createOrUpdate)(attr, validator);\n\n  return validator;\n};\n\nconst createModelValidator = createOrUpdate => (model, data, { isDraft }) => {\n  const writableAttributes = model ? getWritableAttributes(model) : [];\n\n  const schema = writableAttributes.reduce((validators, attributeName) => {\n    const validator = createAttributeValidator(createOrUpdate)(\n      model.attributes[attributeName],\n      prop(attributeName, data),\n      { isDraft }\n    );\n\n    return assoc(attributeName, validator)(validators);\n  }, {});\n\n  return yup.object().shape(schema);\n};\n\nconst createValidateEntity = createOrUpdate => async (model, data, { isDraft = false } = {}) => {\n  try {\n    const validator = createModelValidator(createOrUpdate)(model, data, { isDraft }).required();\n    return await validator.validate(data, { abortEarly: false });\n  } catch (e) {\n    throw strapi.errors.badRequest('ValidationError', { errors: formatYupErrors(e) });\n  }\n};\n\nmodule.exports = {\n  validateEntityCreation: createValidateEntity('creation'),\n  validateEntityUpdate: createValidateEntity('update'),\n};\n",
    "packages/strapi/lib/services/metrics/middleware.js": "'use strict';\n\nconst createMiddleware = ({ sendEvent }) => {\n  const _state = {\n    currentDay: null,\n    counter: 0,\n  };\n\n  return async (ctx, next) => {\n    const { url, method } = ctx.request;\n\n    if (!url.includes('.') && ['GET', 'PUT', 'POST', 'DELETE'].includes(method)) {\n      const dayOfMonth = new Date().getDate();\n\n      if (dayOfMonth !== _state.currentDay) {\n        _state.currentDay = dayOfMonth;\n        _state.counter = 0;\n      }\n\n      // Send max. 1000 events per day.\n      if (_state.counter < 1000) {\n        sendEvent('didReceiveRequest', { url: ctx.request.url });\n\n        // Increase counter.\n        _state.counter++;\n      }\n    }\n\n    await next();\n  };\n};\n\nmodule.exports = createMiddleware;\n",
    "packages/strapi/lib/services/metrics/sender.js": "'use strict';\n\nconst os = require('os');\nconst _ = require('lodash');\nconst isDocker = require('is-docker');\nconst { machineIdSync } = require('node-machine-id');\nconst fetch = require('node-fetch');\nconst ciEnv = require('ci-info');\nconst ee = require('../../utils/ee');\n\nconst defaultQueryOpts = {\n  timeout: 1000,\n  headers: { 'Content-Type': 'application/json' },\n};\n\nconst ANALYTICS_URI = 'https://analytics.strapi.io';\n\n/**\n * Create a send function for event with all the necessary metadatas\n * @param {Object} strapi strapi app\n * @returns {Function} (event, payload) -> Promise{boolean}\n */\nmodule.exports = strapi => {\n  const { uuid, template } = strapi.config;\n  const deviceId = machineIdSync();\n  const isEE = strapi.EE === true && ee.isEE === true;\n\n  const anonymous_metadata = {\n    environment: strapi.config.environment,\n    os: os.type(),\n    osPlatform: os.platform(),\n    osRelease: os.release(),\n    nodeVersion: process.version,\n    docker: process.env.DOCKER || isDocker(),\n    isCI: ciEnv.isCI,\n    version: strapi.config.info.strapi,\n    strapiVersion: strapi.config.info.strapi,\n    projectType: isEE ? 'Enterprise' : 'Community',\n    template,\n  };\n\n  return async (event, payload = {}, opts = {}) => {\n    const reqParams = {\n      method: 'POST',\n      body: JSON.stringify({\n        event,\n        uuid,\n        deviceId,\n        properties: {\n          ...payload,\n          ...anonymous_metadata,\n        },\n      }),\n      ..._.merge({}, defaultQueryOpts, opts),\n    };\n\n    try {\n      const res = await fetch(`${ANALYTICS_URI}/track`, reqParams);\n      return res.ok;\n    } catch (err) {\n      return false;\n    }\n  };\n};\n",
    "packages/strapi/lib/services/utils/upload-files.js": "'use strict';\n\nconst _ = require('lodash');\n\nmodule.exports = async (entry, files, { model, source }) => {\n  const entity = strapi.getModel(model, source);\n\n  if (!_.has(strapi.plugins, 'upload')) return entry;\n\n  const uploadService = strapi.plugins.upload.services.upload;\n\n  const findModelFromUploadPath = path => {\n    if (path.length === 0) return { model, source };\n\n    let currentPath = [];\n    let tmpModel = entity;\n    let modelName = model;\n    let sourceName;\n\n    for (let i = 0; i < path.length; i++) {\n      if (!tmpModel) return {};\n      const part = path[i];\n      const attr = tmpModel.attributes[part];\n\n      currentPath.push(part);\n\n      // ignore array indexes => handled in the dynamic zone section\n      if (_.isFinite(_.toNumber(path[i]))) {\n        continue;\n      }\n\n      if (!attr) return {};\n\n      if (attr.type === 'component') {\n        modelName = attr.component;\n        tmpModel = strapi.components[attr.component];\n      } else if (attr.type === 'dynamiczone') {\n        const entryIdx = path[i + 1]; // get component index\n        const value = _.get(entry, [...currentPath, entryIdx]);\n\n        if (!value) return {};\n\n        modelName = value.__component; // get component type\n        tmpModel = strapi.components[modelName];\n      } else if (_.has(attr, 'model') || _.has(attr, 'collection')) {\n        sourceName = attr.plugin;\n        modelName = attr.model || attr.collection;\n        tmpModel = strapi.getModel(attr.model || attr.collection, source);\n      } else {\n        return {};\n      }\n    }\n\n    return { model: modelName, source: sourceName };\n  };\n\n  const doUpload = async (key, files) => {\n    const parts = key.split('.');\n    const [path, field] = [_.initial(parts), _.last(parts)];\n\n    const { model, source } = findModelFromUploadPath(path);\n\n    if (model) {\n      const id = _.get(entry, path.concat('id'));\n      return uploadService.uploadToEntity({ id, model, field }, files, source);\n    }\n  };\n\n  await Promise.all(Object.keys(files).map(key => doUpload(key, files[key])));\n};\n",
    "packages/strapi/lib/services/webhook-runner.js": "/**\n * The event hub is Strapi's event control center.\n */\n'use strict';\n\nconst debug = require('debug')('strapi');\nconst _ = require('lodash');\nconst fetch = require('node-fetch');\n\nconst WorkerQueue = require('./worker-queue');\n\nconst defaultConfiguration = {\n  defaultHeaders: {},\n};\n\nclass WebhookRunner {\n  constructor({ eventHub, logger, configuration = {} }) {\n    debug('Initialized webhook runer');\n    this.eventHub = eventHub;\n    this.logger = logger;\n    this.webhooksMap = new Map();\n    this.listeners = new Map();\n\n    if (typeof configuration !== 'object') {\n      throw new Error(\n        'Invalid configuration provided to the webhookRunner.\\nCheck your server.json -> webhooks configuration'\n      );\n    }\n\n    this.config = _.merge(defaultConfiguration, configuration);\n\n    this.queue = new WorkerQueue({ logger, concurency: 5 });\n    this.queue.subscribe(this.executeListener.bind(this));\n  }\n\n  deleteListener(event) {\n    debug(`Deleting listener for event '${event}'`);\n    if (this.listeners.has(event)) {\n      const fn = this.listeners.get(event);\n\n      this.eventHub.off(event, fn);\n      this.listeners.delete(event);\n    }\n  }\n\n  createListener(event) {\n    debug(`Creating listener for event '${event}'`);\n    if (this.listeners.has(event)) {\n      this.logger.error(\n        `The webhook runner is already listening for the event '${event}'. Did you mean to call .register() ?`\n      );\n    }\n\n    const listen = info => {\n      this.queue.enqueue({ event, info });\n    };\n\n    this.listeners.set(event, listen);\n    this.eventHub.on(event, listen);\n  }\n\n  async executeListener({ event, info }) {\n    debug(`Executing webhook for event '${event}'`);\n    const webhooks = this.webhooksMap.get(event) || [];\n    const activeWebhooks = webhooks.filter(\n      webhook => webhook.isEnabled === true\n    );\n\n    for (const webhook of activeWebhooks) {\n      await this.run(webhook, event, info).catch(error => {\n        this.logger.error('Error running webhook');\n        this.logger.error(error);\n      });\n    }\n  }\n\n  run(webhook, event, info = {}) {\n    const { url, headers } = webhook;\n\n    return fetch(url, {\n      method: 'post',\n      body: JSON.stringify({\n        event,\n        created_at: new Date(),\n        ...info,\n      }),\n      headers: {\n        ...this.config.defaultHeaders,\n        ...headers,\n        'X-Strapi-Event': event,\n        'Content-Type': 'application/json',\n      },\n      timeout: 10000,\n    })\n      .then(async res => {\n        if (res.ok) {\n          return {\n            statusCode: res.status,\n          };\n        }\n\n        return {\n          statusCode: res.status,\n          message: await res.text(),\n        };\n      })\n      .catch(err => {\n        return {\n          statusCode: 500,\n          message: err.message,\n        };\n      });\n  }\n\n  add(webhook) {\n    debug(`Registering webhook '${webhook.id}'`);\n    const { events } = webhook;\n\n    events.forEach(event => {\n      if (this.webhooksMap.has(event)) {\n        this.webhooksMap.get(event).push(webhook);\n      } else {\n        this.webhooksMap.set(event, [webhook]);\n        this.createListener(event);\n      }\n    });\n  }\n\n  update(webhook) {\n    debug(`Refreshing webhook '${webhook.id}'`);\n    this.remove(webhook);\n    this.add(webhook);\n  }\n\n  remove(webhook) {\n    debug(`Unregistering webhook '${webhook.id}'`);\n\n    this.webhooksMap.forEach((webhooks, event) => {\n      const filteredWebhooks = webhooks.filter(\n        value => value.id !== webhook.id\n      );\n\n      // Cleanup hanging listeners\n      if (filteredWebhooks.length === 0) {\n        this.webhooksMap.delete(event);\n        this.deleteListener(event);\n      } else {\n        this.webhooksMap.set(event, filteredWebhooks);\n      }\n    });\n  }\n}\n\n/**\n * Expose a factory function instead of the class\n */\nmodule.exports = function createWebhookRunner(opts) {\n  return new WebhookRunner(opts);\n};\n",
    "packages/strapi/lib/services/webhook-store.js": "/**\n * Webhook store is the implementation of webhook storage over the core_store\n */\n'use strict';\n\nconst webhookModel = config => ({\n  connection: config.get('database.defaultConnection'),\n  uid: 'strapi::webhooks',\n  internal: true,\n  globalId: 'StrapiWebhooks',\n  collectionName: 'strapi_webhooks',\n  info: {\n    name: 'Strapi webhooks',\n    description: '',\n  },\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    url: {\n      type: 'text',\n    },\n    headers: {\n      type: 'json',\n    },\n    events: {\n      type: 'json',\n    },\n    enabled: {\n      type: 'boolean',\n    },\n  },\n});\n\nconst toDBObject = data => {\n  return {\n    name: data.name,\n    url: data.url,\n    headers: data.headers,\n    events: data.events,\n    enabled: data.isEnabled,\n  };\n};\n\nconst fromDBObject = row => {\n  return {\n    id: row.id,\n    name: row.name,\n    url: row.url,\n    headers: row.headers,\n    events: row.events,\n    isEnabled: row.enabled,\n  };\n};\n\nconst createWebhookStore = ({ db }) => {\n  const webhookQueries = db.query('strapi_webhooks');\n\n  return {\n    async findWebhooks() {\n      const results = await webhookQueries.find();\n\n      return results.map(fromDBObject);\n    },\n\n    async findWebhook(id) {\n      const result = await webhookQueries.findOne({ id });\n      return result ? fromDBObject(result) : null;\n    },\n\n    createWebhook(data) {\n      return webhookQueries.create(toDBObject({ ...data, isEnabled: true })).then(fromDBObject);\n    },\n\n    async updateWebhook(id, data) {\n      const webhook = await webhookQueries.update({ id }, toDBObject(data));\n      return webhook ? fromDBObject(webhook) : null;\n    },\n\n    async deleteWebhook(id) {\n      const webhook = await webhookQueries.delete({ id });\n      return webhook ? fromDBObject(webhook) : null;\n    },\n  };\n};\n\nmodule.exports = {\n  webhookModel,\n  createWebhookStore,\n};\n",
    "packages/strapi/lib/services/worker-queue.js": "/**\n * Simple worker queue in memory\n */\n'use strict';\n\nconst debug = require('debug')('strapi');\n\nmodule.exports = class WorkerQueue {\n  constructor({ logger, concurrency = 5 } = {}) {\n    debug('Initialize worker queue');\n\n    this.logger = logger;\n    this.worker = noop;\n\n    this.concurrency = concurrency;\n    this.running = 0;\n    this.queue = [];\n  }\n\n  subscribe(worker) {\n    debug('Subscribe to worker queue');\n    this.worker = worker;\n  }\n\n  enqueue(payload) {\n    debug('Enqueue event in worker queue');\n    if (this.running < this.concurrency) {\n      this.running++;\n      this.execute(payload);\n    } else {\n      this.queue.unshift(payload);\n    }\n  }\n\n  pop() {\n    debug('Pop worker queue and execute');\n    const payload = this.queue.pop();\n\n    if (payload) {\n      this.execute(payload);\n    } else {\n      this.running--;\n    }\n  }\n\n  async execute(payload) {\n    debug('Execute worker');\n    try {\n      await this.worker(payload);\n    } catch (error) {\n      this.logger.error(error);\n    } finally {\n      this.pop();\n    }\n  }\n};\n\nfunction noop() {}\n",
    "packages/strapi/lib/utils/index.js": "'use strict';\n\n// Dependencies.\nconst { isEmpty } = require('lodash');\nconst openBrowser = require('./openBrowser');\n\nmodule.exports = {\n  /*\n   * Return false where there is no administrator, otherwise return true.\n   */\n  async isInitialised(strapi) {\n    try {\n      if (isEmpty(strapi.admin)) {\n        return true;\n      }\n\n      const numberOfAdministrators = await strapi.query('user', 'admin').find({ _limit: 1 });\n\n      return numberOfAdministrators.length > 0;\n    } catch (err) {\n      strapi.stopWithError(err);\n    }\n  },\n  openBrowser,\n};\n",
    "packages/strapi/lib/utils/openBrowser.js": "/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar execSync = require('child_process').execSync;\nvar chalk = require('chalk');\nvar spawn = require('cross-spawn');\nvar opn = require('opn');\nconst fetch = require('node-fetch');\nconst { getAbsoluteAdminUrl } = require('strapi-utils');\n\n// https://github.com/sindresorhus/opn#app\nvar OSX_CHROME = 'google chrome';\n\nconst Actions = Object.freeze({\n  NONE: 0,\n  BROWSER: 1,\n  SCRIPT: 2,\n});\n\nfunction getBrowserEnv() {\n  // Attempt to honor this environment variable.\n  // It is specific to the operating system.\n  // See https://github.com/sindresorhus/opn#app for documentation.\n  const value = process.env.BROWSER;\n  let action;\n  if (!value) {\n    // Default.\n    action = Actions.BROWSER;\n  } else if (value.toLowerCase().endsWith('.js')) {\n    action = Actions.SCRIPT;\n  } else if (value.toLowerCase() === 'none') {\n    action = Actions.NONE;\n  } else {\n    action = Actions.BROWSER;\n  }\n  return { action, value };\n}\n\nfunction executeNodeScript(scriptPath, url) {\n  const extraArgs = process.argv.slice(2);\n  const child = spawn('node', [scriptPath, ...extraArgs, url], {\n    stdio: 'inherit',\n  });\n  child.on('close', code => {\n    if (code !== 0) {\n      console.log();\n      console.log(chalk.red('The script specified as BROWSER environment variable failed.'));\n      console.log(`${chalk.cyan(scriptPath)} exited with code ${code}.`);\n      console.log();\n      return;\n    }\n  });\n  return true;\n}\n\nfunction startBrowserProcess(browser, url) {\n  // If we're on OS X, the user hasn't specifically\n  // requested a different browser, we can try opening\n  // Chrome with AppleScript. This lets us reuse an\n  // existing tab when possible instead of creating a new one.\n  const shouldTryOpenChromeWithAppleScript =\n    process.platform === 'darwin' && (typeof browser !== 'string' || browser === OSX_CHROME);\n\n  if (shouldTryOpenChromeWithAppleScript) {\n    try {\n      // Try our best to reuse existing tab\n      // on OS X Google Chrome with AppleScript\n      execSync('ps cax | grep \"Google Chrome\"');\n      execSync(`osascript resources/openChrome.applescript \"${encodeURI(url)}\"`, {\n        cwd: __dirname,\n        stdio: 'ignore',\n      });\n      return true;\n    } catch (err) {\n      strapi.log.error('Failed to open Google Chrome with AppleScript');\n    }\n  }\n\n  // Another special case: on OS X, check if BROWSER has been set to \"open\".\n  // In this case, instead of passing `open` to `opn` (which won't work),\n  // just ignore it (thus ensuring the intended behavior, i.e. opening the system browser):\n  // https://github.com/facebook/create-react-app/pull/1690#issuecomment-283518768\n  if (process.platform === 'darwin' && browser === 'open') {\n    browser = undefined;\n  }\n\n  // Fallback to opn\n  // (It will always open new tab)\n  try {\n    var options = { app: browser };\n    opn(url, options).catch(() => {}); // Prevent `unhandledRejection` error.\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nasync function pingDashboard(url, multipleTime = false) {\n  try {\n    await fetch(url, { method: 'HEAD', timeout: 300, body: null });\n    // Inform the user that we're going to open the administration panel.\n    this.log.info('⏳ Opening the admin panel...');\n  } catch (e) {\n    if (e.code !== 'ECONNREFUSED' && e.type !== 'request-timeout') {\n      return console.error(e);\n    }\n\n    // Only display once.\n    if (!multipleTime) {\n      this.log.warn(`⚠️  The admin panel is unavailable... Impossible to open it in the browser.`);\n    }\n  }\n}\n\n/**\n * Reads the BROWSER evironment variable and decides what to do with it. Returns\n * true if it opened a browser or ran a node.js script, otherwise false.\n */\nasync function openBrowser() {\n  const url = getAbsoluteAdminUrl(strapi.config);\n\n  // Ping the dashboard to ensure it's available.\n  await pingDashboard.call(this, url);\n\n  const { action, value } = getBrowserEnv();\n  switch (action) {\n    case Actions.NONE:\n      // Special case: BROWSER=\"none\" will prevent opening completely.\n      return false;\n    case Actions.SCRIPT:\n      return executeNodeScript(value, url);\n    case Actions.BROWSER:\n      return startBrowserProcess(value, url);\n    default:\n      throw new Error('Not implemented.');\n  }\n}\n\nmodule.exports = openBrowser;\n",
    "packages/strapi/lib/utils/update-notifier/index.js": "'use strict';\n\nconst path = require('path');\nconst packageJson = require('package-json');\nconst Configstore = require('configstore');\nconst semver = require('semver');\nconst boxen = require('boxen');\nconst chalk = require('chalk');\nconst { env } = require('strapi-utils');\n\nconst pkg = require('../../../package');\n\nconst CHECK_INTERVAL = 1000 * 60 * 60 * 24 * 1; // 1 day\nconst NOTIF_INTERVAL = 1000 * 60 * 60 * 24 * 7; // 1 week\nconst boxenOptions = {\n  padding: 1,\n  margin: 1,\n  align: 'center',\n  borderColor: 'yellow',\n  borderStyle: 'round',\n};\n\nconst geUpdatetMessage = (newVersion, currentVersion) => {\n  const currentVersionLog = chalk.dim(currentVersion);\n  const newVersionLog = chalk.green(newVersion);\n  const releaseLink = chalk.bold('https://github.com/strapi/strapi/releases');\n\n  return `\nA new version of Strapi is available ${currentVersionLog} → ${newVersionLog}\nCheck out the new the releases at: ${releaseLink}\n`.trim();\n};\n\nconst createUpdateNotifier = strapi => {\n  let config = null;\n\n  try {\n    config = new Configstore(\n      pkg.name,\n      {},\n      { configPath: path.join(strapi.dir, '.strapi-updater.json') }\n    );\n  } catch {\n    // we don't have write access to the file system\n    // we silence the error\n  }\n\n  const checkUpdate = async checkInterval => {\n    const now = Date.now();\n    const lastUpdateCheck = config.get('lastUpdateCheck') || 0;\n    if (lastUpdateCheck + checkInterval > now) {\n      return;\n    }\n\n    try {\n      const res = await packageJson(pkg.name);\n      if (res.version) {\n        config.set('latest', res.version);\n        config.set('lastUpdateCheck', now);\n      }\n    } catch {\n      // silence error if offline\n    }\n  };\n\n  const display = notifInterval => {\n    const now = Date.now();\n    const latestVersion = config.get('latest');\n    const lastNotification = config.get('lastNotification') || 0;\n    if (\n      !process.stdout.isTTY ||\n      lastNotification + notifInterval > now ||\n      !semver.valid(latestVersion) ||\n      !semver.valid(pkg.version) ||\n      semver.lte(latestVersion, pkg.version)\n    ) {\n      return;\n    }\n\n    const message = boxen(geUpdatetMessage(latestVersion, pkg.version), boxenOptions);\n    config.set('lastNotification', now);\n    console.log(message);\n  };\n\n  return {\n    notify({ checkInterval = CHECK_INTERVAL, notifInterval = NOTIF_INTERVAL } = {}) {\n      if (env.bool('STRAPI_DISABLE_UPDATE_NOTIFICATION', false) || !config) {\n        return;\n      }\n      display(notifInterval);\n      checkUpdate(checkInterval); // doesn't need to await\n    },\n  };\n};\n\nmodule.exports = createUpdateNotifier;\n",
    "packages/strapi/tests/api/basic-compo-repeatable.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompo: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithCompo = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      component: 'default.compo',\n      type: 'component',\n      required: true,\n      repeatable: true,\n    },\n  },\n  connection: 'default',\n  name: 'product-with-compo',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + compo', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompo)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: [\n        {\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-compos',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-compos',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body[0]).toMatchObject(data.productsWithCompo[0]);\n    res.body.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: [\n        {\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompo[0]);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo', '0'])).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].name', '0'])).toBe(\n        'compo[0].name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic-compo.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompo: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithCompo = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      component: 'default.compo',\n      type: 'component',\n      required: true,\n    },\n  },\n  connection: 'default',\n  name: 'product-with-compo',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + compo', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompo)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: {\n        name: 'compo name',\n        description: 'short',\n      },\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-compos',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-compos',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body[0]).toMatchObject(data.productsWithCompo[0]);\n    res.body.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: {\n        name: 'compo name updated',\n        description: 'update',\n      },\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompo[0]);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.compo.0')).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: '',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          description: 'short',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.name', '0'])).toBe(\n        'compo.name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic-dp-compo-repeatable.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompoAndDP: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithCompoAndDP = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      type: 'component',\n      component: 'default.compo',\n      required: true,\n      repeatable: true,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product-with-compo-and-dp',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + compo + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompoAndDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: [\n        {\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-compo-and-dps',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-compo-and-dps',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body[0]).toMatchObject(data.productsWithCompoAndDP[0]);\n    res.body.forEach(p => {\n      expect(p.published_at).toBeISODate();\n    });\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: [\n        {\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompoAndDP[0]);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo', '0'])).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].name', '0'])).toBe(\n        'compo[0].name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic-dp-compo.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompoAndDP: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithCompoAndDP = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      type: 'component',\n      component: 'default.compo',\n      required: true,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product-with-compo-and-dp',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + compo + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompoAndDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: {\n        name: 'compo name',\n        description: 'short',\n      },\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-compo-and-dps',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-compo-and-dps',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body[0]).toMatchObject(data.productsWithCompoAndDP[0]);\n    res.body.forEach(p => {\n      expect(p.published_at).toBeISODate();\n    });\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: {\n        name: 'compo name updated',\n        description: 'update',\n      },\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompoAndDP[0]);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.productsWithCompoAndDP.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.compo.0')).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: '',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          description: 'short',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.name', '0'])).toBe(\n        'compo.name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic-dp.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  products: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithDP = {\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 30,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product-with-dp',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create a product', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-dps',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeISODate();\n    data.products.push(res.body);\n  });\n\n  test('Create a product + can overwrite published_at', async () => {\n    const product = {\n      name: 'Product 2',\n      description: 'Product description',\n      published_at: '2020-08-20T10:27:55.000Z',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-dps',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.omit(product, 'published_at'));\n    expect(res.body.published_at).toBeISODate();\n    expect(res.body.published_at).toBe(product.published_at);\n    data.products.push(res.body);\n  });\n\n  test('Read products', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-dps',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(2);\n    expect(res.body).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          name: 'Product 1',\n          description: 'Product description',\n        }),\n      ])\n    );\n    res.body.forEach(p => {\n      expect(p.published_at).toBeISODate();\n    });\n  });\n\n  test('Update product', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-dps/${data.products[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.omit(product, 'published_at'));\n    expect(res.body.id).toEqual(data.products[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.products[0] = res.body;\n  });\n\n  test('Update product + can overwrite published_at', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      published_at: '2020-08-27T09:50:50.000Z',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-dps/${data.products[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.pick(data.products[0], ['name', 'description']));\n    expect(res.body.published_at).toBeISODate();\n    expect(res.body.published_at).toBe(product.published_at);\n    data.products[0] = res.body;\n  });\n\n  test('Delete product', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-dps/${data.products[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.products[0]);\n    expect(res.body.id).toEqual(data.products[0].id);\n    expect(res.body.published_at).toBeISODate();\n    data.products.shift();\n  });\n\n  describe('validators', () => {\n    test('Cannot create a product - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: '',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.description.0')).toBe(\n        'description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create a product - required', async () => {\n      const product = {\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.name.0')).toBe('name must be defined.');\n    });\n\n    test('Cannot create a product - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: \"I'm a product description that is very long. At least thirty characters.\",\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dps',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'description', '0'])).toBe(\n        'description must be at most 30 characters'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic-dz.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nconst data = {\n  productWithDz: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithDz = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    dz: {\n      components: ['default.compo'],\n      type: 'dynamiczone',\n      required: true,\n    },\n  },\n  connection: 'default',\n  name: 'product-with-dz',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + dz', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithDz)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-dzs',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productWithDz.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/product-with-dzs',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body[0]).toMatchObject(data.productWithDz[0]);\n    res.body.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/product-with-dzs/${data.productWithDz[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productWithDz[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productWithDz[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/product-with-dzs/${data.productWithDz[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productWithDz[0]);\n    expect(res.body.id).toEqual(data.productWithDz[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productWithDz.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz', '0'])).toBe('dz must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].description', '0'])).toBe(\n        'dz[0].description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].description', '0'])).toBe(\n        'dz[0].description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].name', '0'])).toBe(\n        'dz[0].name must be defined.'\n      );\n    });\n\n    test('Cannot create product with compo - missing __component', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            name: 'Product 1',\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].__component', '0'])).toBe(\n        'dz[0].__component is a required field'\n      );\n    });\n  });\n});\n",
    "packages/strapi/tests/api/basic.test.e2e.js": "'use strict';\n\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  product: [],\n};\n\nconst product = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n  },\n  connection: 'default',\n  name: 'product',\n  description: '',\n  collectionName: '',\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\ndescribe('Core API - Basic', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(product)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/products',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.product.push(res.body);\n  });\n\n  test('Read product', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/products',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body)).toBe(true);\n    expect(res.body).toHaveLength(1);\n    expect(res.body).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          name: 'Product 1',\n          description: 'Product description',\n        }),\n      ])\n    );\n    res.body.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/products/${data.product[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.product[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.product[0] = res.body;\n  });\n\n  test('Delete product', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/products/${data.product[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.product[0]);\n    expect(res.body.id).toEqual(data.product[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.product.shift();\n  });\n});\n",
    "packages/strapi/tests/deepFiltering.test.e2e.js": "'use strict';\n\n// Test an API with all the possible filed types and simple filterings (no deep filtering, no relations)\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nconst data = {\n  card: [],\n  collector: [],\n};\nlet rq;\nlet strapi;\n\nconst card = {\n  name: 'card',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst collector = {\n  name: 'collector',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    age: {\n      type: 'integer',\n    },\n    cards: {\n      nature: 'manyWay',\n      target: 'application::card.card',\n      unique: false,\n    },\n    collector_friends: {\n      nature: 'manyWay',\n      target: '__self__',\n      unique: false,\n    },\n  },\n};\n\nconst fixtures = {\n  card: [\n    {\n      name: 'Hugo LLORIS',\n    },\n    {\n      name: 'Samuel UMTITI',\n    },\n    {\n      name: 'Lucas HERNANDEZ',\n    },\n  ],\n  collector: ({ card }) => [\n    {\n      name: 'Bernard',\n      age: 25,\n      cards: [card[0].id, card[1].id],\n    },\n    self => ({\n      name: 'Isabelle',\n      age: 55,\n      cards: [card[0].id],\n      collector_friends: [self[0].id],\n    }),\n    self => ({\n      name: 'Kenza',\n      age: 25,\n      cards: [],\n      collector_friends: [self[0].id],\n    }),\n  ],\n};\n\ndescribe('Deep Filtering API', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentTypes([card, collector])\n      .addFixtures(card.name, fixtures.card)\n      .addFixtures(collector.name, fixtures.collector)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    Object.assign(data, builder.sanitizedFixtures(strapi));\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Without search', () => {\n    describe('Filter on a manyWay relation', () => {\n      test('Should return 2 results', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'cards.name': data.card[0].name,\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(2);\n        expect(res.body[0]).toMatchObject(data.collector[0]);\n        expect(res.body[1]).toMatchObject(data.collector[1]);\n      });\n\n      test('Should return 1 result', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'cards.name': data.card[1].name,\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(1);\n        expect(res.body[0]).toMatchObject(data.collector[0]);\n      });\n    });\n\n    describe('Filter on a self manyWay relation', () => {\n      test('Should return 2 results', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'collector_friends.name': data.collector[0].name,\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(2);\n        expect(res.body).toMatchObject(data.collector.slice(1, 3));\n      });\n    });\n  });\n\n  describe('With search', () => {\n    describe('Filter on a manyWay relation', () => {\n      test('cards.name + empty search', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'cards.name': data.card[0].name,\n            _q: '',\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(2);\n        expect(res.body).toMatchObject(data.collector.slice(0, 2));\n      });\n\n      test('cards.name + _q=25', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'cards.name': data.card[0].name,\n            _q: 25,\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(1);\n        expect(res.body).toMatchObject([data.collector[0]]);\n      });\n    });\n\n    describe('Filter on a self manyWay relation', () => {\n      test('collector_friends.name + empty search', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'collector_friends.name': data.collector[0].name,\n            _q: '',\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(2);\n        expect(res.body).toMatchObject(data.collector.slice(1, 3));\n      });\n      test('collector_friends.name + search isa', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            'collector_friends.name': data.collector[0].name,\n            _q: 'isa',\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(1);\n        expect(res.body).toMatchObject([data.collector[1]]);\n      });\n    });\n  });\n});\n",
    "packages/strapi/tests/endpoint.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst modelsUtils = require('../../../test/helpers/models');\n\nconst form = require('../../../test/helpers/generators');\n\nconst cleanDate = entry => {\n  delete entry.updatedAt;\n  delete entry.createdAt;\n  delete entry.created_at;\n  delete entry.updated_at;\n};\n\nconst builder = createTestBuilder();\nlet data;\nlet rq;\nlet strapi;\n\ndescribe('Create Strapi API End to End', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentTypes([form.article, form.tag, form.category, form.reference, form.product], {\n        batch: true,\n      })\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Test manyToMany relation (article - tag) with Content Manager', () => {\n    beforeAll(async () => {\n      data = {\n        articles: [],\n        tags: [],\n      };\n    });\n\n    test('Create tag1', async () => {\n      const { body } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag1',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag1');\n    });\n\n    test('Create tag2', async () => {\n      const { body } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag2',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag2');\n    });\n\n    test('Create tag3', async () => {\n      const { body } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag3',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag3');\n    });\n\n    test('Create article1 without relation', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'My super content 1',\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(0);\n    });\n\n    test('Create article2 with tag1', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n        tags: [data.tags[0]],\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(1);\n      expect(body.tags[0].id).toBe(data.tags[0].id);\n    });\n\n    test('Update article1 add tag2', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        tags: [data.tags[1]],\n      });\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(1);\n      expect(body.tags[0].id).toBe(data.tags[1].id);\n    });\n\n    test('Update article1 add tag1 and tag3', async () => {\n      const entry = Object.assign({}, data.articles[0]);\n      entry.tags.push(data.tags[0]);\n      entry.tags.push(data.tags[2]);\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(3);\n    });\n\n    test('Update article1 remove one tag', async () => {\n      const entry = Object.assign({}, data.articles[0]);\n      entry.tags = entry.tags.slice(1);\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(2);\n    });\n\n    test('Update article1 remove all tag', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        tags: [],\n      });\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(0);\n    });\n  });\n\n  describe('Test oneToMany - manyToOne relation (article - category) with Content Manager', () => {\n    beforeAll(() => {\n      data = {\n        articles: [],\n        categories: [],\n      };\n    });\n\n    afterAll(async () => {\n      await modelsUtils.cleanupModels(['article', 'category'], { strapi });\n    });\n\n    test('Create cat1', async () => {\n      const { body } = await rq({\n        url: '/categories',\n        method: 'POST',\n        body: {\n          name: 'cat1',\n        },\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('cat1');\n    });\n\n    test('Create cat2', async () => {\n      const { body } = await rq({\n        url: '/categories',\n        method: 'POST',\n        body: {\n          name: 'cat2',\n        },\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('cat2');\n    });\n\n    test('Create article1 with cat1', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'Content 1',\n        category: data.categories[0],\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n    });\n\n    test('Update article1 with cat2', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        category: data.categories[1],\n      });\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n    });\n\n    test('Create article2', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n    });\n\n    test('Update article2 with cat2', async () => {\n      const entry = Object.assign({}, data.articles[1], {\n        category: data.categories[1],\n      });\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[1] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n    });\n\n    test('Update cat1 with article1', async () => {\n      const entry = Object.assign({}, data.categories[0]);\n      entry.articles.push(data.articles[0]);\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/categories/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.categories[0] = body;\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.articles.length).toBe(1);\n      expect(body.name).toBe(entry.name);\n    });\n\n    test('Create cat3 with article1', async () => {\n      const entry = {\n        name: 'cat3',\n        articles: [data.articles[0]],\n      };\n\n      const { body } = await rq({\n        url: '/categories',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.articles.length).toBe(1);\n      expect(body.name).toBe(entry.name);\n    });\n\n    test('Get article1 with cat3', async () => {\n      const { body } = await rq({\n        url: `/articles/${data.articles[0].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.category.id).toBe(data.categories[2].id);\n    });\n\n    test('Get article2 with cat2', async () => {\n      const { body } = await rq({\n        url: `/articles/${data.articles[1].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.category.id).toBe(data.categories[1].id);\n    });\n\n    test('Get cat1 without relations', async () => {\n      const { body } = await rq({\n        url: `/categories/${data.categories[0].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(0);\n    });\n\n    test('Get cat2 with article2', async () => {\n      const { body } = await rq({\n        url: `/categories/${data.categories[1].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(1);\n      expect(body.articles[0].id).toBe(data.articles[1].id);\n    });\n\n    test('Get cat3 with article1', async () => {\n      const { body } = await rq({\n        url: `/categories/${data.categories[2].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(1);\n      expect(body.articles[0].id).toBe(data.articles[0].id);\n    });\n  });\n\n  describe('Test oneToOne relation (article - reference) with Content Manager', () => {\n    beforeAll(() => {\n      data = {\n        articles: [],\n        references: [],\n      };\n    });\n\n    afterAll(async () => {\n      await modelsUtils.cleanupModels(['article', 'reference'], { strapi });\n    });\n\n    test('Create ref1', async () => {\n      const { body } = await rq({\n        url: '/references',\n        method: 'POST',\n        body: {\n          name: 'ref1',\n        },\n      });\n\n      data.references.push(body);\n\n      expect(body.id);\n      expect(body.name).toBe('ref1');\n    });\n\n    test('Create article1', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'Content 1',\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n    });\n\n    test('Update article1 with ref1', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        reference: data.references[0].id,\n      });\n\n      cleanDate(entry);\n\n      const { body } = await rq({\n        url: `/articles/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.reference.id).toBe(entry.reference);\n    });\n\n    test('Create article2 with ref1', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n        reference: data.references[0].id,\n      };\n\n      const { body } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.reference.id).toBe(entry.reference);\n    });\n  });\n\n  describe('Test oneWay relation (reference - tag) with Content Manager', () => {\n    beforeAll(() => {\n      data = {\n        tags: [],\n        references: [],\n      };\n    });\n\n    afterAll(async () => {\n      await modelsUtils.cleanupModels(['reference', 'tag'], { strapi });\n    });\n\n    test('Attach Tag to a Reference', async () => {\n      await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      }).then(({ body: tagToCreate }) => {\n        data.tags.push(tagToCreate);\n\n        return rq({\n          url: '/references',\n          method: 'POST',\n          body: {\n            name: 'cat111',\n            tag: tagToCreate,\n          },\n        }).then(({ body }) => {\n          data.references.push(body);\n          expect(body.tag.id).toBe(tagToCreate.id);\n        });\n      });\n    });\n\n    test('Detach Tag to a Reference', async () => {\n      const { body: tagToCreate } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      });\n\n      data.tags.push(tagToCreate);\n\n      const { body: referenceToCreate } = await rq({\n        url: '/references',\n        method: 'POST',\n        body: {\n          name: 'cat111',\n          tag: tagToCreate,\n        },\n      });\n\n      data.references.push(referenceToCreate);\n\n      expect(referenceToCreate.tag.id).toBe(tagToCreate.id);\n\n      const { body: referenceToUpdate } = await rq({\n        url: `/references/${referenceToCreate.id}`,\n        method: 'PUT',\n        body: {\n          tag: null,\n        },\n      });\n\n      expect(referenceToUpdate.tag).toBe(null);\n    });\n\n    test('Delete Tag so the relation in the Reference side should be removed', async () => {\n      const { body: tagToCreate } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      });\n\n      data.tags.push(tagToCreate);\n\n      const { body: referenceToCreate } = await rq({\n        url: '/references',\n        method: 'POST',\n        body: {\n          name: 'cat111',\n          tag: tagToCreate,\n        },\n      });\n\n      data.references.push(referenceToCreate);\n\n      await rq({\n        url: `/tags/${tagToCreate.id}`,\n        method: 'DELETE',\n      });\n\n      const { body: referenceToGet } = await rq({\n        url: `/references/${referenceToCreate.id}`,\n        method: 'GET',\n      });\n\n      if (!referenceToGet.tag || Object.keys(referenceToGet.tag).length == 0) return;\n      expect(referenceToGet.tag).toBe(null);\n    });\n  });\n});\n",
    "packages/strapi/tests/filtering.test.e2e.js": "'use strict';\n\n// Test an API with all the possible filed types and simple filtering (no deep filtering, no relations)\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nconst data = { product: [] };\n\n// complete list of existing fields and tests\nconst product = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    price: {\n      type: 'float',\n    },\n    decimal_field: {\n      type: 'decimal',\n    },\n    rank: {\n      type: 'integer',\n    },\n    big_rank: {\n      type: 'biginteger',\n    },\n  },\n  connection: 'default',\n  name: 'product',\n  description: '',\n  collectionName: '',\n};\n\nconst productFixtures = [\n  {\n    name: 'Product 1',\n    description: 'Product description',\n    price: 10.99,\n    decimal_field: 42.43,\n    rank: 42,\n    big_rank: '345678912983',\n  },\n  {\n    name: 'Product 2',\n    description: 'Product description 2',\n    price: 28.31,\n    decimal_field: 91.22,\n    rank: 82,\n    big_rank: '926371623421',\n  },\n  {\n    name: 'Product 3',\n    description: 'Product description 3',\n    price: 28.31,\n    decimal_field: 12.22,\n    rank: 91,\n    big_rank: '926372323421',\n  },\n  {\n    name: 'Product 4',\n    description: 'Product description 4',\n    price: null,\n    decimal_field: 12.22,\n    rank: 99,\n    big_rank: '999999999999',\n  },\n  {\n    name: 'Продукт 5, Product 5',\n    description: 'Опис на продукт 5',\n    price: null,\n    decimal_field: 142.43,\n    rank: 142,\n    big_rank: 345678912983,\n  },\n];\n\ndescribe('Filtering API', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(product)\n      .addFixtures(product.name, productFixtures)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    Object.assign(data, builder.sanitizedFixtures(strapi));\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Basic filters', () => {\n    describe('Filter equals', () => {\n      test('Should be the default filter', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name: 'Product 1',\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(1);\n        expect(res.body[0]).toMatchObject(data.product[0]);\n      });\n\n      test('Should be usable with equal suffix', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_eq: 'Product 1',\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(1);\n        expect(res.body[0]).toMatchObject(data.product[0]);\n      });\n\n      test('Should return an empty array when no match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_eq: 'Product non existant',\n          },\n        });\n\n        expect(res.body).toEqual([]);\n      });\n    });\n\n    describe('Filter not equals', () => {\n      test('Should return an array with matching entities', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ne: 'Non existent product ',\n          },\n        });\n\n        expect(res.body).toEqual(\n          expect.arrayContaining(data.product.map(o => expect.objectContaining(o)))\n        );\n      });\n\n      test('Should return an empty array when no match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ne: 'Product 1',\n          },\n        });\n\n        expect(res.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });\n    });\n\n    describe('Filter null', () => {\n      test('Should return only matching items', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_null: true,\n          },\n        });\n\n        const matching = data.product.filter(x => x.price === null);\n        res.body.sort((a, b) => (a.id > b.id ? 1 : -1));\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(matching.length);\n        expect(res.body).toMatchObject(matching);\n        expect(res.body).toEqual(expect.arrayContaining(matching));\n      });\n\n      test('Should return three matches', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_null: false,\n          },\n        });\n\n        expect(Array.isArray(res.body)).toBe(true);\n        expect(res.body.length).toBe(3);\n      });\n    });\n\n    describe('Filter contains insensitive', () => {\n      test('Should match with insensitive case', async () => {\n        const res1 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_contains: 'product',\n          },\n        });\n\n        expect(res1.body).toEqual(\n          expect.arrayContaining(data.product.map(o => expect.objectContaining(o)))\n        );\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_contains: 'PrOdUct',\n          },\n        });\n\n        expect(res1.body).toEqual(res2.body);\n      });\n\n      test('Should return an empty array on no insensitive case match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_contains: 'production',\n          },\n        });\n\n        expect(res.body).toEqual([]);\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_contains: 'ProdUctIon',\n          },\n        });\n\n        expect(res2.body).toEqual(res.body);\n      });\n    });\n\n    describe('Filter not contains insensitive', () => {\n      test('Should return an array of entities on match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontains: 'production',\n          },\n        });\n\n        expect(res.body).toEqual(\n          expect.arrayContaining(data.product.map(o => expect.objectContaining(o)))\n        );\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontains: 'ProdUctIon',\n          },\n        });\n\n        expect(res2.body).toEqual(res.body);\n      });\n\n      test('Should return an empty array when no match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontains: 'product',\n          },\n        });\n\n        expect(res.body).toEqual([]);\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontains: 'ProDuCt',\n          },\n        });\n\n        expect(res2.body).toEqual(res.body);\n      });\n    });\n\n    // FIXME: Not working on sqlite due to https://www.sqlite.org/draft/pragma.html#pragma_case_sensitive_like\n    describe('Filter contains sensitive', () => {\n      test.skip('Should return empty if the case does not match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_containss: 'product',\n          },\n        });\n\n        expect(res.body).toEqual([]);\n      });\n\n      test('Should return the entities if the case matches', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_containss: 'Product',\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n\n    // FIXME: Not working on sqlite due to https://www.sqlite.org/draft/pragma.html#pragma_case_sensitive_like\n    describe('Filter not contains sensitive', () => {\n      test.skip('Should return the entities if the case does not match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontainss: 'product',\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should return an empty array if the case matches', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            name_ncontainss: 'Product',\n          },\n        });\n\n        expect(res.body).toEqual([]);\n      });\n    });\n\n    describe('Filter in', () => {\n      test('Should return the Product with a single value', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_in: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should return the Product with an array of values', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_in: [42, 12],\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should return a, empty array if no values are matching', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_in: [43, 12],\n          },\n        });\n\n        expect(res.body).toEqual([]);\n      });\n    });\n\n    describe('Filter not in', () => {\n      test('Should return an array without the values matching when a single value is provided', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_nin: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });\n\n      test('Should return an array without the values matching when an array of values is provided', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_nin: [42, 12],\n          },\n        });\n\n        expect(res.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });\n\n      test('Should return an array with values that do not match the filter', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_nin: [43, 12],\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n\n    describe('Filter greater than', () => {\n      test('Should match values only greater than', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gt: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gt: 40,\n          },\n        });\n\n        expect(res2.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gt: 40,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_gt: 9.3,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            decimal_field_gt: 1.23,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            big_rank_gt: 34567891298,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n\n    describe('Filter greater than or equal', () => {\n      test('Should work correclty on equal values', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gte: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gte: 43,\n          },\n        });\n\n        expect(res2.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_gte: 40,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_gte: 10.99,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            decimal_field_gte: 42.43,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            big_rank_gte: '345678912983',\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n\n    describe('Filter less than', () => {\n      test('Should match values only less than', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lt: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lt: 43,\n          },\n        });\n\n        expect(res2.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lt: 45,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_lt: 21.3,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            decimal_field_lt: 46.23,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            big_rank_lt: 3456789129812,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n\n    describe('Filter less than or equal', () => {\n      test('Should work correclty on equal values', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lte: 52,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lte: 21,\n          },\n        });\n\n        expect(res2.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            rank_lte: 42,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            price_lte: 10.99,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            decimal_field_lte: 42.43,\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n\n      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            big_rank_lte: '345678912983',\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n      });\n    });\n  });\n\n  describe('Or filtering', () => {\n    describe('_or filter', () => {\n      test('Supports simple or', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            _where: {\n              _or: [\n                {\n                  rank: 42,\n                },\n                {\n                  rank: 82,\n                },\n              ],\n            },\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0], data.product[1]]));\n      });\n\n      test('Supports simple or on different fields', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            _where: {\n              _or: [\n                {\n                  rank: 42,\n                },\n                {\n                  price_gt: 28,\n                },\n              ],\n            },\n          },\n        });\n\n        expect(res.body).toEqual(\n          expect.arrayContaining([data.product[0], data.product[1], data.product[2]])\n        );\n      });\n\n      test('Supports or with nested and', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            _where: {\n              _or: [\n                {\n                  rank: 42,\n                },\n                [\n                  {\n                    price_gt: 28,\n                  },\n                  {\n                    rank: 91,\n                  },\n                ],\n              ],\n            },\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0], data.product[2]]));\n      });\n\n      test('Supports or with nested or', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            _where: {\n              _or: [\n                {\n                  rank: 42,\n                },\n                [\n                  {\n                    price_gt: 28,\n                  },\n                  {\n                    _or: [\n                      {\n                        rank: 91,\n                      },\n                    ],\n                  },\n                ],\n              ],\n            },\n          },\n        });\n\n        expect(res.body).toEqual(expect.arrayContaining([data.product[0], data.product[2]]));\n      });\n    });\n\n    test('Filter equals', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank: [42, 43],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter not equals', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_ne: [41, 43],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter contains insensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_contains: ['Product', '1'],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter not contains insensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_ncontains: ['Product', 'Non existent'],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter contains sensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_containss: ['Product', 'Non existent'],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter not contains sensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_ncontainss: ['product', 'Non existent'],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter greater than', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_gt: [12, 56],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter greater than or equal', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_gte: [42, 56],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter less than', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_lt: [56, 12],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Filter less than or equal', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_lte: [12, 42],\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n  });\n\n  describe('Complexe filtering', () => {\n    test('Greater than and less than at the same time', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_lte: 42,\n          rank_gte: 42,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_lt: 43,\n          rank_gt: 41,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          rank_lt: 43,\n          rank_gt: 431,\n        },\n      });\n\n      expect(res.body).toEqual([]);\n    });\n\n    test('Contains and Not contains on same column', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_contains: 'Product',\n          name_ncontains: '1',\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining(data.product.slice(1)));\n\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_contains: 'Product 1',\n          name_ncontains: ['2', '3'],\n        },\n      });\n\n      expect(res.body).toEqual(expect.not.arrayContaining([data.product[1], data.product[2]]));\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_contains: '2',\n          name_ncontains: 'Product',\n        },\n      });\n\n      expect(res.body).toEqual([]);\n    });\n\n    test('Combined filters', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          name_contains: 'Product',\n          rank_lt: 45,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n  });\n\n  describe('Sorting', () => {\n    test('Default sorting is asc', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _sort: 'rank',\n        },\n      });\n\n      expect(res.body).toEqual(\n        expect.arrayContaining(data.product.slice(0).sort((a, b) => a.rank - b.rank))\n      );\n    });\n\n    test('Simple sorting', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _sort: 'rank:asc',\n        },\n      });\n\n      expect(res.body).toEqual(\n        expect.arrayContaining(data.product.slice(0).sort((a, b) => a.rank - b.rank))\n      );\n\n      const res2 = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _sort: 'rank:desc',\n        },\n      });\n\n      expect(res2.body).toEqual(\n        expect.arrayContaining(data.product.slice(0).sort((a, b) => b.rank - a.rank))\n      );\n    });\n\n    test('Multi column sorting', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _sort: 'price:asc,rank:desc',\n        },\n      });\n\n      [data.product[3], data.product[0], data.product[2], data.product[1]].forEach(expectedPost => {\n        expect(res.body).toEqual(expect.arrayContaining([expectedPost]));\n      });\n    });\n  });\n\n  describe('Limit and offset', () => {\n    test('Limit', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _limit: 1,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Limit with sorting', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _limit: 1,\n          _sort: 'rank:desc',\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[data.product.length - 1]]));\n    });\n\n    test('Offset', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _start: 1,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining(data.product.slice(1)));\n    });\n\n    test('Offset with limit', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _limit: 1,\n          _start: 1,\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining(data.product.slice(1, 2)));\n    });\n  });\n\n  describe('Text query', () => {\n    test('Cyrillic query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _q: 'Опис',\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[4]]));\n    });\n\n    test('Multi word query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _q: 'Product description',\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[0]]));\n    });\n\n    test('Multi word cyrillic query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _q: 'Опис на продукт',\n        },\n      });\n\n      expect(res.body).toEqual(expect.arrayContaining([data.product[4]]));\n    });\n  });\n});\n",
    "packages/strapi/tests/publication-state.test.e2e.js": "'use strict';\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst fixtures = {\n  product: [\n    {\n      name: 'Bamboo Desk',\n      categories: ['Home'],\n      comp: { countries: ['France'] },\n      published_at: null,\n    },\n    {\n      name: 'Computer',\n      categories: ['Home', 'Tech'],\n      comp: { countries: ['France', 'Italy', 'Spain'] },\n      published_at: new Date(),\n    },\n    {\n      name: 'Burger Drone',\n      categories: ['Tech', 'Food'],\n      comp: { countries: ['Italy', 'Spain'] },\n      published_at: new Date(),\n    },\n  ],\n  category: [\n    { name: 'Home', published_at: null },\n    { name: 'Food', published_at: new Date() },\n    { name: 'Tech', published_at: new Date() },\n  ],\n  country: [\n    { name: 'France', published_at: new Date() },\n    { name: 'Italy', published_at: null },\n    { name: 'Spain', published_at: new Date() },\n  ],\n};\n\nconst data = { product: [], category: [], country: [] };\n\nconst pluralizedModels = {\n  product: 'products',\n  country: 'countries',\n  category: 'categories',\n};\n\nconst contentTypes = {\n  product: {\n    attributes: {\n      name: {\n        type: 'string',\n      },\n      categories: {\n        nature: 'manyWay',\n        target: 'application::category.category',\n        unique: false,\n      },\n      comp: {\n        component: 'default.comp',\n        type: 'component',\n        required: true,\n      },\n    },\n    draftAndPublish: true,\n    connection: 'default',\n    name: 'product',\n    description: '',\n    collectionName: '',\n  },\n  country: {\n    attributes: {\n      name: {\n        type: 'string',\n      },\n    },\n    draftAndPublish: true,\n    connection: 'default',\n    name: 'country',\n    description: '',\n    collectionName: '',\n  },\n  category: {\n    attributes: {\n      name: {\n        type: 'string',\n      },\n    },\n    draftAndPublish: true,\n    connection: 'default',\n    name: 'category',\n    description: '',\n    collectionName: '',\n  },\n};\n\nconst components = {\n  comp: {\n    name: 'comp',\n    attributes: {\n      countries: {\n        nature: 'manyWay',\n        target: 'application::country.country',\n      },\n    },\n  },\n};\n\nconst filterBy = (name, { mode = 'live' } = {}) => {\n  return fixtures[name].filter(item => {\n    if (['live', 'default'].includes(mode)) {\n      return item.published_at instanceof Date;\n    }\n    return true;\n  });\n};\n\nconst lengthFor = (name, { mode = 'live' } = {}) => {\n  return filterBy(name, { mode }).length;\n};\n\nconst getQueryFromMode = mode => {\n  if (['live', 'preview'].includes(mode)) {\n    return `?_publicationState=${mode}`;\n  }\n\n  return '';\n};\n\ndescribe('Publication State', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(contentTypes.country)\n      .addComponent(components.comp)\n      .addContentTypes([contentTypes.category, contentTypes.product])\n      .addFixtures(contentTypes.country.name, fixtures.country)\n      .addFixtures(contentTypes.category.name, fixtures.category)\n      .addFixtures(contentTypes.product.name, f =>\n        fixtures.product.map(product => ({\n          name: product.name,\n          categories: product.categories.map(name => f.category.find(cat => cat.name === name).id),\n          comp: {\n            countries: product.comp.countries.map(\n              name => f.country.find(country => country.name === name).id\n            ),\n          },\n          published_at: product.published_at,\n        }))\n      )\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    Object.assign(data, builder.sanitizedFixtures(strapi));\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe.each(['default', 'live', 'preview'])('Mode: \"%s\"', mode => {\n    describe.each(['country', 'category', 'product'])('For %s', modelName => {\n      const baseUrl = `/${pluralizedModels[modelName]}`;\n      const query = getQueryFromMode(mode);\n\n      test('Can get entries', async () => {\n        const res = await rq({ method: 'GET', url: `${baseUrl}${query}` });\n\n        expect(res.body).toHaveLength(lengthFor(modelName, { mode }));\n      });\n\n      test('Can count entries', async () => {\n        const res = await rq({ method: 'GET', url: `${baseUrl}/count${query}` });\n\n        expect(res.body).toBe(lengthFor(modelName, { mode }));\n      });\n    });\n  });\n\n  describe('Advanced checks', () => {\n    describe('Nested level of relations (live mode)', () => {\n      let products;\n      const pluralizedModelName = pluralizedModels[contentTypes.product.name];\n\n      beforeEach(async () => {\n        const res = await rq({\n          method: 'GET',\n          url: `/${pluralizedModelName}?_publicationState=live`,\n        });\n        products = res.body;\n      });\n\n      const getApiRef = id => data.product.find(product => product.id === id);\n\n      test('Payload integrity', () => {\n        expect(products).toHaveLength(lengthFor(contentTypes.product.name));\n      });\n\n      test('Root level', () => {\n        products.forEach(product => {\n          expect(product.published_at).toBeISODate();\n        });\n      });\n\n      test('First level (categories)', () => {\n        products.forEach(({ id, categories }) => {\n          const length = getApiRef(id).categories.filter(c => c.published_at !== null).length;\n          expect(categories).toHaveLength(length);\n\n          categories.forEach(category => {\n            expect(category.published_at).toBeISODate();\n          });\n        });\n      });\n\n      test('Second level through component (countries)', () => {\n        products.forEach(({ id, comp: { countries } }) => {\n          const length = getApiRef(id).comp.countries.filter(c => c.published_at !== null).length;\n          expect(countries).toHaveLength(length);\n\n          countries.forEach(country => {\n            expect(country.published_at).toBeISODate();\n          });\n        });\n      });\n    });\n  });\n});\n",
    "packages/strapi/tests/search.test.e2e.js": "'use strict';\n\n// Test an API with all the possible filed types and simple filtering (no deep filtering, no relations)\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet rq;\nlet strapi;\nlet data = {\n  bed: [],\n};\n\nconst bedModel = {\n  name: 'bed',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    weight: {\n      type: 'decimal',\n    },\n    shortDescription: {\n      type: 'text',\n    },\n    description: {\n      type: 'richtext',\n    },\n    sku: {\n      type: 'uid',\n    },\n    savEmail: {\n      type: 'email',\n    },\n    type: {\n      enum: ['spring', 'foam', 'feather'],\n      type: 'enumeration',\n    },\n    serialNumber: {\n      type: 'biginteger',\n    },\n    peopleNumber: {\n      type: 'integer',\n    },\n    fabricThickness: {\n      type: 'float',\n    },\n  },\n};\n\nconst bedFixtures = [\n  {\n    // will have id=1\n    name: 'Sleepy Bed',\n    weight: 12.4,\n    shortDescription: 'Is a good bed to sleep in.',\n    description: '**Is a very good bed to sleep in.** We promise.',\n    sku: 'sleepybed_0152',\n    savEmail: 'sav@bed.fr',\n    type: 'foam',\n    serialNumber: 999999999999999,\n    peopleNumber: 6,\n    fabricThickness: 1.14157,\n  },\n  {\n    // will have id=2\n    name: 'Tired Bed',\n    weight: 11.1,\n    shortDescription: 'You will never wake up again.',\n    description: '**You will never wake up again.** Never.',\n    sku: 'tiredbed_0001',\n    savEmail: 'sav@sleep.fr',\n    type: 'feather',\n    serialNumber: 1111111111111111,\n    peopleNumber: 1,\n    fabricThickness: 1.0001,\n  },\n  {\n    // will have id=3\n    // other beds don't contain any 3 in order to find only Zombie Bed when searching 3\n    name: 'Zombie Bed',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: null,\n    fabricThickness: null,\n  },\n  {\n    // will have id=4\n    name: 'a*b_c%d\\\\e+f',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: null,\n    fabricThickness: null,\n  },\n  {\n    // will have id=5\n    name: 'Tired Bed',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: 7,\n    fabricThickness: null,\n  },\n];\n\ndescribe('Search query', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(bedModel)\n      .addFixtures(bedModel.name, bedFixtures)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    data.bed = builder.sanitizedFixturesFor(bedModel.name, strapi);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Without filters', () => {\n    test('search for \"id\"', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: data.bed[2].id,\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body[0]).toMatchObject(data.bed[2]);\n    });\n\n    test.each(Object.keys(bedFixtures[0]))('search that target column %p', async columnName => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: bedFixtures[0][columnName],\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body[0]).toMatchObject(data.bed[0]);\n    });\n\n    test('search with an empty query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: '',\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(5);\n      expect(res.body).toEqual(expect.arrayContaining(data.bed));\n    });\n\n    test('search with special characters', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: data.bed[3].name,\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body[0]).toMatchObject(data.bed[3]);\n    });\n  });\n\n  describe('With filters', () => {\n    test('search with an empty query & peopleNumber > 0', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: '',\n          peopleNumber_gt: 0,\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(3);\n      expect(res.body).toMatchObject([data.bed[0], data.bed[1], data.bed[4]]);\n    });\n    test('search with an empty query & peopleNumber > 1', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: '',\n          peopleNumber_gt: 1,\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(2);\n      expect(res.body).toMatchObject([data.bed[0], data.bed[4]]);\n    });\n    test('search with an empty query & peopleNumber in [1, 6]', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds?peopleNumber=1&peopleNumber=6&_q=',\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(2);\n      expect(res.body).toMatchObject(data.bed.slice(0, 2));\n    });\n    test('search for \"Sleepy Bed\" & peopleNumber < 7', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: 'Sleepy Bed',\n          peopleNumber_lt: 7,\n        },\n      });\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body).toMatchObject([data.bed[0]]);\n    });\n  });\n});\n",
    "packages/strapi/tests/single-type.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet uid = 'single-type';\nlet data = {};\n\nconst model = {\n  kind: 'singleType',\n  name: 'single-type',\n  attributes: {\n    title: {\n      type: 'string',\n    },\n  },\n};\n\ndescribe('Content Manager single types', () => {\n  beforeAll(async () => {\n    await builder.addContentType(model).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('find single type content returns 404 when not created', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(404);\n  });\n\n  test('Create content', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'PUT',\n      body: {\n        title: 'Title',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: expect.anything(),\n      title: 'Title',\n    });\n\n    data.id = res.body.id;\n  });\n\n  test('Update keeps the same data id', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'PUT',\n      body: {\n        title: 'Title',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: data.id,\n      title: 'Title',\n    });\n  });\n\n  test('find single type content returns an object ', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: expect.anything(),\n      title: 'Title',\n    });\n  });\n\n  test('Delete single type content returns an object and makes data unavailable', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'DELETE',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: expect.anything(),\n      title: 'Title',\n    });\n\n    const getRes = await rq({\n      url: `/${uid}`,\n      method: 'GET',\n    });\n\n    expect(getRes.statusCode).toBe(404);\n  });\n});\n",
    "packages/strapi-admin/admin/src/components/Users/ModalCreateBody/index.js": "import React, { forwardRef, useReducer, useImperativeHandle, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { BaselineAlignment, ModalSection, request } from 'strapi-helper-plugin';\nimport { FormattedMessage } from 'react-intl';\nimport { get } from 'lodash';\nimport { Padded, Text } from '@buffetjs/core';\nimport { Col, Row } from 'reactstrap';\nimport checkFormValidity from '../../../utils/checkFormValidity';\nimport SelectRoles from '../SelectRoles';\nimport form from './utils/form';\nimport schema from './utils/schema';\nimport { initialState, reducer } from './reducer';\nimport init from './init';\nimport Input from '../../SizedInput';\nimport Wrapper from './Wrapper';\nimport MagicLink from '../MagicLink';\n\n// This component accepts a ref so we can have access to the submit handler.\nconst ModalCreateBody = forwardRef(\n  ({ isDisabled, onSubmit, registrationToken, setIsSubmiting, showMagicLink }, ref) => {\n    const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n    const { formErrors, modifiedData } = reducerState;\n    const buttonSubmitRef = useRef(null);\n\n    useImperativeHandle(ref, () => ({\n      submit: () => {\n        buttonSubmitRef.current.click();\n      },\n    }));\n\n    const handleChange = ({ target: { name, value } }) => {\n      dispatch({\n        type: 'ON_CHANGE',\n        keys: name,\n        value,\n      });\n    };\n\n    const handleSubmit = async e => {\n      e.persist();\n      e.preventDefault();\n      const errors = await checkFormValidity(modifiedData, schema);\n\n      if (!errors) {\n        try {\n          // Prevent user interactions until the request is completed\n          strapi.lockAppWithOverlay();\n\n          setIsSubmiting(true);\n\n          const requestURL = '/admin/users';\n          const cleanedRoles = modifiedData.roles.map(role => role.id);\n\n          const { data } = await request(requestURL, {\n            method: 'POST',\n            body: { ...modifiedData, roles: cleanedRoles },\n          });\n\n          onSubmit(e, data);\n        } catch (err) {\n          const message = get(err, ['response', 'payload', 'message'], 'An error occured');\n\n          strapi.notification.toggle({ type: 'warning', message });\n        } finally {\n          strapi.unlockApp();\n          setIsSubmiting(false);\n        }\n      }\n\n      dispatch({\n        type: 'SET_ERRORS',\n        errors: errors || {},\n      });\n    };\n\n    return (\n      <form onSubmit={handleSubmit}>\n        {showMagicLink && (\n          <>\n            <BaselineAlignment top size=\"18px\" />\n            <ModalSection>\n              <MagicLink registrationToken={registrationToken} />\n            </ModalSection>\n          </>\n        )}\n        <ModalSection>\n          <Padded top size=\"18px\">\n            <Text fontSize=\"xs\" color=\"grey\" fontWeight=\"bold\" textTransform=\"uppercase\">\n              <FormattedMessage id=\"app.components.Users.ModalCreateBody.block-title.details\">\n                {txt => txt}\n              </FormattedMessage>\n            </Text>\n          </Padded>\n        </ModalSection>\n        <ModalSection>\n          <Wrapper>\n            <Padded top size=\"20px\">\n              <Row>\n                {Object.keys(form).map((inputName, i) => (\n                  <Input\n                    key={inputName}\n                    {...form[inputName]}\n                    autoFocus={i === 0}\n                    disabled={isDisabled}\n                    error={formErrors[inputName]}\n                    name={inputName}\n                    onChange={handleChange}\n                    value={modifiedData[inputName]}\n                  />\n                ))}\n              </Row>\n            </Padded>\n          </Wrapper>\n        </ModalSection>\n        <ModalSection>\n          <Padded top size=\"3px\">\n            <Text fontSize=\"xs\" color=\"grey\" fontWeight=\"bold\" textTransform=\"uppercase\">\n              <FormattedMessage id=\"app.components.Users.ModalCreateBody.block-title.roles\">\n                {txt => txt}\n              </FormattedMessage>\n            </Text>\n          </Padded>\n        </ModalSection>\n        <ModalSection>\n          <Wrapper>\n            <Padded top size=\"12px\">\n              <Row>\n                <Col xs=\"6\">\n                  <SelectRoles\n                    isDisabled={isDisabled}\n                    name=\"roles\"\n                    onChange={handleChange}\n                    value={modifiedData.roles}\n                    error={formErrors.roles}\n                  />\n                </Col>\n              </Row>\n            </Padded>\n          </Wrapper>\n        </ModalSection>\n        <button type=\"submit\" style={{ display: 'none' }} ref={buttonSubmitRef}>\n          hidden button to use the native form event\n        </button>\n      </form>\n    );\n  }\n);\n\nModalCreateBody.defaultProps = {\n  isDisabled: false,\n  onSubmit: e => e.preventDefault(),\n  registrationToken: '',\n  setIsSubmiting: () => {},\n  showMagicLink: false,\n};\n\nModalCreateBody.propTypes = {\n  isDisabled: PropTypes.bool,\n  onSubmit: PropTypes.func,\n  registrationToken: PropTypes.string,\n  setIsSubmiting: PropTypes.func,\n  showMagicLink: PropTypes.bool,\n};\n\nexport default ModalCreateBody;\n",
    "packages/strapi-admin/admin/src/containers/Admin/index.js": "/**\n *\n * Admin\n *\n */\n\nimport React, { createRef } from 'react';\nimport PropTypes from 'prop-types';\nimport axios from 'axios';\nimport { connect } from 'react-redux';\nimport { createStructuredSelector } from 'reselect';\nimport { bindActionCreators, compose } from 'redux';\nimport { Switch, Route } from 'react-router-dom';\nimport { injectIntl } from 'react-intl';\nimport { isEmpty } from 'lodash';\n// Components from strapi-helper-plugin\nimport {\n  difference,\n  GlobalContextProvider,\n  LoadingIndicatorPage,\n  OverlayBlocker,\n  UserProvider,\n  CheckPagePermissions,\n  request,\n} from 'strapi-helper-plugin';\nimport { SETTINGS_BASE_URL, SHOW_TUTORIALS, STRAPI_UPDATE_NOTIF } from '../../config';\nimport { checkLatestStrapiVersion } from '../../utils';\n\nimport adminPermissions from '../../permissions';\nimport Header from '../../components/Header/index';\nimport NavTopRightWrapper from '../../components/NavTopRightWrapper';\nimport LeftMenu from '../LeftMenu';\nimport InstalledPluginsPage from '../InstalledPluginsPage';\nimport LocaleToggle from '../LocaleToggle';\nimport HomePage from '../HomePage';\nimport MarketplacePage from '../MarketplacePage';\nimport NotFoundPage from '../NotFoundPage';\nimport OnboardingVideos from '../Onboarding';\nimport SettingsPage from '../SettingsPage';\nimport PluginDispatcher from '../PluginDispatcher';\nimport ProfilePage from '../ProfilePage';\nimport Logout from './Logout';\nimport {\n  disableGlobalOverlayBlocker,\n  enableGlobalOverlayBlocker,\n  getInfosDataSucceeded,\n  updatePlugin,\n} from '../App/actions';\nimport makeSelecApp from '../App/selectors';\nimport {\n  getStrapiLatestReleaseSucceeded,\n  getUserPermissions,\n  getUserPermissionsError,\n  getUserPermissionsSucceeded,\n  setAppError,\n} from './actions';\nimport makeSelectAdmin from './selectors';\nimport Wrapper from './Wrapper';\nimport Content from './Content';\n\nexport class Admin extends React.Component {\n  // eslint-disable-line react/prefer-stateless-function\n\n  // Ref to access the menu API\n  menuRef = createRef();\n\n  helpers = {\n    updatePlugin: this.props.updatePlugin,\n  };\n\n  componentDidMount() {\n    this.emitEvent('didAccessAuthenticatedAdministration');\n    this.initApp();\n  }\n\n  shouldComponentUpdate(prevProps) {\n    return !isEmpty(difference(prevProps, this.props));\n  }\n\n  /* istanbul ignore next */\n  componentDidCatch(error, info) {\n    /* eslint-disable */\n    console.log('An error has occured');\n    console.log('--------------------');\n    console.log(error);\n    console.log('Here is some infos');\n    console.log(info);\n    /* eslint-enable */\n\n    // Display the error log component which is not designed yet\n    this.props.setAppError();\n  }\n\n  emitEvent = async (event, properties) => {\n    const {\n      global: { uuid },\n    } = this.props;\n\n    if (uuid) {\n      try {\n        await axios.post('https://analytics.strapi.io/track', {\n          event,\n          // PROJECT_TYPE is an env variable defined in the webpack config\n          // eslint-disable-next-line no-undef\n          properties: { ...properties, projectType: PROJECT_TYPE },\n          uuid,\n        });\n      } catch (err) {\n        // Silent\n      }\n    }\n  };\n\n  fetchAppInfo = async () => {\n    try {\n      const { data } = await request('/admin/information', { method: 'GET' });\n\n      this.props.getInfosDataSucceeded(data);\n    } catch (err) {\n      console.error(err);\n      strapi.notification.error('notification.error');\n    }\n  };\n\n  fetchStrapiLatestRelease = async () => {\n    const {\n      global: { strapiVersion },\n      getStrapiLatestReleaseSucceeded,\n    } = this.props;\n\n    if (!STRAPI_UPDATE_NOTIF) {\n      return;\n    }\n\n    try {\n      const {\n        data: { tag_name },\n      } = await axios.get('https://api.github.com/repos/strapi/strapi/releases/latest');\n      const shouldUpdateStrapi = checkLatestStrapiVersion(strapiVersion, tag_name);\n\n      getStrapiLatestReleaseSucceeded(tag_name, shouldUpdateStrapi);\n\n      const showUpdateNotif = !JSON.parse(localStorage.getItem('STRAPI_UPDATE_NOTIF'));\n\n      if (!showUpdateNotif) {\n        return;\n      }\n\n      if (shouldUpdateStrapi) {\n        strapi.notification.toggle({\n          type: 'info',\n          message: { id: 'notification.version.update.message' },\n          link: {\n            url: `https://github.com/strapi/strapi/releases/tag/${tag_name}`,\n            label: {\n              id: 'notification.version.update.link',\n            },\n          },\n          blockTransition: true,\n          onClose: () => localStorage.setItem('STRAPI_UPDATE_NOTIF', true),\n        });\n      }\n    } catch (err) {\n      // Silent\n    }\n  };\n\n  fetchUserPermissions = async (resetState = false) => {\n    const { getUserPermissions, getUserPermissionsError, getUserPermissionsSucceeded } = this.props;\n\n    if (resetState) {\n      // Show a loader\n      getUserPermissions();\n    }\n\n    try {\n      const { data } = await request('/admin/users/me/permissions', { method: 'GET' });\n\n      getUserPermissionsSucceeded(data);\n    } catch (err) {\n      console.error(err);\n      getUserPermissionsError(err);\n    }\n  };\n\n  hasApluginNotReady = props => {\n    const {\n      global: { plugins },\n    } = props;\n\n    return !Object.keys(plugins).every(plugin => plugins[plugin].isReady === true);\n  };\n\n  initApp = async () => {\n    await this.fetchAppInfo();\n    await this.fetchStrapiLatestRelease();\n    await this.fetchUserPermissions(true);\n  };\n\n  /**\n   * Display the app loader until the app is ready\n   * @returns {Boolean}\n   */\n  showLoader = () => {\n    return this.hasApluginNotReady(this.props);\n  };\n\n  renderInitializers = () => {\n    const {\n      global: { plugins },\n    } = this.props;\n\n    return Object.keys(plugins).reduce((acc, current) => {\n      const InitializerComponent = plugins[current].initializer;\n\n      if (InitializerComponent) {\n        const key = plugins[current].id;\n\n        acc.push(<InitializerComponent key={key} {...this.props} {...this.helpers} />);\n      }\n\n      return acc;\n    }, []);\n  };\n\n  renderPluginDispatcher = props => {\n    // NOTE: Send the needed props instead of everything...\n\n    return <PluginDispatcher {...this.props} {...props} {...this.helpers} />;\n  };\n\n  renderRoute = (props, Component) => <Component {...this.props} {...props} />;\n\n  render() {\n    const {\n      admin: { isLoading, shouldUpdateStrapi, userPermissions },\n      global: {\n        autoReload,\n        blockApp,\n        currentEnvironment,\n        overlayBlockerData,\n        plugins,\n        showGlobalAppBlocker,\n        strapiVersion,\n      },\n      disableGlobalOverlayBlocker,\n      enableGlobalOverlayBlocker,\n      intl: { formatMessage, locale },\n      updatePlugin,\n    } = this.props;\n\n    // We need the admin data in order to make the initializers work\n    if (this.showLoader()) {\n      return (\n        <>\n          {this.renderInitializers()}\n          <LoadingIndicatorPage />\n        </>\n      );\n    }\n\n    // Show a loader while permissions are being fetched\n    if (isLoading) {\n      return <LoadingIndicatorPage />;\n    }\n\n    return (\n      <GlobalContextProvider\n        autoReload={autoReload}\n        emitEvent={this.emitEvent}\n        currentEnvironment={currentEnvironment}\n        currentLocale={locale}\n        disableGlobalOverlayBlocker={disableGlobalOverlayBlocker}\n        enableGlobalOverlayBlocker={enableGlobalOverlayBlocker}\n        fetchUserPermissions={this.fetchUserPermissions}\n        formatMessage={formatMessage}\n        shouldUpdateStrapi={shouldUpdateStrapi}\n        menu={this.menuRef.current}\n        plugins={plugins}\n        settingsBaseURL={SETTINGS_BASE_URL || '/settings'}\n        strapiVersion={strapiVersion}\n        updatePlugin={updatePlugin}\n      >\n        <UserProvider value={userPermissions}>\n          <Wrapper>\n            <LeftMenu\n              shouldUpdateStrapi={shouldUpdateStrapi}\n              version={strapiVersion}\n              plugins={plugins}\n              ref={this.menuRef}\n            />\n            <NavTopRightWrapper>\n              {/* Injection zone not ready yet */}\n              <Logout />\n              <LocaleToggle isLogged />\n            </NavTopRightWrapper>\n            <div className=\"adminPageRightWrapper\">\n              <Header />\n              <Content>\n                <Switch>\n                  <Route path=\"/\" render={props => this.renderRoute(props, HomePage)} exact />\n                  <Route path=\"/me\" component={ProfilePage} />\n                  <Route path=\"/plugins/:pluginId\" render={this.renderPluginDispatcher} />\n                  <Route path=\"/list-plugins\" exact>\n                    <CheckPagePermissions permissions={adminPermissions.marketplace.main}>\n                      <InstalledPluginsPage />\n                    </CheckPagePermissions>\n                  </Route>\n                  <Route path=\"/marketplace\">\n                    <CheckPagePermissions permissions={adminPermissions.marketplace.main}>\n                      <MarketplacePage />\n                    </CheckPagePermissions>\n                  </Route>\n                  <Route\n                    path={`${SETTINGS_BASE_URL || '/settings'}/:settingId`}\n                    component={SettingsPage}\n                  />\n                  <Route path={SETTINGS_BASE_URL || '/settings'} component={SettingsPage} exact />\n                  <Route key=\"7\" path=\"\" component={NotFoundPage} />\n                  <Route key=\"8\" path=\"/404\" component={NotFoundPage} />\n                </Switch>\n              </Content>\n            </div>\n            <OverlayBlocker\n              key=\"overlayBlocker\"\n              isOpen={blockApp && showGlobalAppBlocker}\n              {...overlayBlockerData}\n            />\n            {SHOW_TUTORIALS && <OnboardingVideos />}\n          </Wrapper>\n        </UserProvider>\n      </GlobalContextProvider>\n    );\n  }\n}\n\nAdmin.defaultProps = {\n  intl: {\n    formatMessage: () => {},\n    locale: 'en',\n  },\n};\n\nAdmin.propTypes = {\n  admin: PropTypes.shape({\n    appError: PropTypes.bool,\n    isLoading: PropTypes.bool,\n    shouldUpdateStrapi: PropTypes.bool.isRequired,\n    userPermissions: PropTypes.array,\n  }).isRequired,\n  disableGlobalOverlayBlocker: PropTypes.func.isRequired,\n  enableGlobalOverlayBlocker: PropTypes.func.isRequired,\n  getInfosDataSucceeded: PropTypes.func.isRequired,\n  getStrapiLatestReleaseSucceeded: PropTypes.func.isRequired,\n  getUserPermissions: PropTypes.func.isRequired,\n  getUserPermissionsError: PropTypes.func.isRequired,\n  getUserPermissionsSucceeded: PropTypes.func.isRequired,\n  global: PropTypes.shape({\n    autoReload: PropTypes.bool,\n    blockApp: PropTypes.bool,\n    currentEnvironment: PropTypes.string,\n    overlayBlockerData: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n    plugins: PropTypes.object,\n    showGlobalAppBlocker: PropTypes.bool,\n    strapiVersion: PropTypes.string,\n    uuid: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n  }).isRequired,\n  intl: PropTypes.shape({\n    formatMessage: PropTypes.func,\n    locale: PropTypes.string,\n  }),\n  location: PropTypes.object.isRequired,\n  setAppError: PropTypes.func.isRequired,\n  updatePlugin: PropTypes.func.isRequired,\n};\n\nconst mapStateToProps = createStructuredSelector({\n  admin: makeSelectAdmin(),\n  global: makeSelecApp(),\n});\n\nexport function mapDispatchToProps(dispatch) {\n  return bindActionCreators(\n    {\n      disableGlobalOverlayBlocker,\n      enableGlobalOverlayBlocker,\n      getInfosDataSucceeded,\n      getStrapiLatestReleaseSucceeded,\n      getUserPermissions,\n      getUserPermissionsError,\n      getUserPermissionsSucceeded,\n      setAppError,\n      updatePlugin,\n    },\n    dispatch\n  );\n}\n\nconst withConnect = connect(mapStateToProps, mapDispatchToProps);\n\nexport default compose(injectIntl, withConnect)(Admin);\n",
    "packages/strapi-admin/admin/src/containers/App/index.js": "/**\n *\n * App.js\n *\n * This component is the skeleton around the actual pages, and should only\n * contain code that should be seen on all pages. (e.g. navigation bar)\n *\n * NOTE: while this component should technically be a stateless functional\n * component (SFC), hot reloading does not currently support SFCs. If hot\n * reloading is not a neccessity for you then you can refactor it and remove\n * the linting exception.\n */\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { Switch, Route } from 'react-router-dom';\nimport { connect } from 'react-redux';\nimport { bindActionCreators, compose } from 'redux';\nimport { LoadingIndicatorPage, auth, request } from 'strapi-helper-plugin';\nimport GlobalStyle from '../../components/GlobalStyle';\nimport Admin from '../Admin';\nimport AuthPage from '../AuthPage';\nimport NotFoundPage from '../NotFoundPage';\n// eslint-disable-next-line import/no-cycle\nimport NotificationProvider from '../NotificationProvider';\nimport PrivateRoute from '../PrivateRoute';\nimport Theme from '../Theme';\nimport { Content, Wrapper } from './components';\nimport { getDataSucceeded } from './actions';\nimport NewNotification from '../NewNotification';\n\nfunction App(props) {\n  const getDataRef = useRef();\n  const [{ isLoading, hasAdmin }, setState] = useState({ isLoading: true, hasAdmin: false });\n  getDataRef.current = props.getDataSucceeded;\n\n  useEffect(() => {\n    const currentToken = auth.getToken();\n\n    const renewToken = async () => {\n      try {\n        const {\n          data: { token },\n        } = await request('/admin/renew-token', {\n          method: 'POST',\n          body: { token: currentToken },\n        });\n        auth.updateToken(token);\n      } catch (err) {\n        // Refresh app\n        auth.clearAppStorage();\n        window.location.reload();\n      }\n    };\n\n    if (currentToken) {\n      renewToken();\n    }\n  }, []);\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        const { data } = await request('/admin/init', { method: 'GET' });\n\n        const { uuid } = data;\n\n        if (uuid) {\n          try {\n            fetch('https://analytics.strapi.io/track', {\n              method: 'POST',\n              body: JSON.stringify({\n                event: 'didInitializeAdministration',\n                uuid,\n              }),\n              headers: {\n                'Content-Type': 'application/json',\n              },\n            });\n          } catch (e) {\n            // Silent.\n          }\n        }\n\n        getDataRef.current(data);\n        setState({ isLoading: false, hasAdmin: data.hasAdmin });\n      } catch (err) {\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'app.containers.App.notification.error.init' },\n        });\n      }\n    };\n\n    getData();\n  }, []);\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <Theme>\n      <Wrapper>\n        <GlobalStyle />\n        <NotificationProvider />\n        <NewNotification />\n        <Content>\n          <Switch>\n            <Route\n              path=\"/auth/:authType\"\n              render={routerProps => <AuthPage {...routerProps} hasAdmin={hasAdmin} />}\n              exact\n            />\n            <PrivateRoute path=\"/\" component={Admin} />\n            <Route path=\"\" component={NotFoundPage} />\n          </Switch>\n        </Content>\n      </Wrapper>\n    </Theme>\n  );\n}\n\nApp.propTypes = {\n  getDataSucceeded: PropTypes.func.isRequired,\n};\n\nexport function mapDispatchToProps(dispatch) {\n  return bindActionCreators({ getDataSucceeded }, dispatch);\n}\n\nconst withConnect = connect(null, mapDispatchToProps);\n\nexport default compose(withConnect)(App);\nexport { App };\n",
    "packages/strapi-admin/admin/src/containers/AuthPage/index.js": "import React, { useEffect, useReducer } from 'react';\nimport axios from 'axios';\nimport { camelCase, get, omit, upperFirst } from 'lodash';\nimport { Redirect, useRouteMatch, useHistory } from 'react-router-dom';\nimport { BaselineAlignment, auth, useQuery } from 'strapi-helper-plugin';\nimport { Padded } from '@buffetjs/core';\nimport PropTypes from 'prop-types';\nimport NavTopRightWrapper from '../../components/NavTopRightWrapper';\nimport PageTitle from '../../components/PageTitle';\nimport LocaleToggle from '../LocaleToggle';\nimport checkFormValidity from '../../utils/checkFormValidity';\nimport formatAPIErrors from '../../utils/formatAPIErrors';\nimport { forms } from './utils';\nimport init from './init';\nimport { initialState, reducer } from './reducer';\n\nconst AuthPage = ({ hasAdmin }) => {\n  const { push } = useHistory();\n  const {\n    params: { authType },\n  } = useRouteMatch('/auth/:authType');\n  const query = useQuery();\n  const registrationToken = query.get('registrationToken');\n  const { Component, endPoint, fieldsToDisable, fieldsToOmit, inputsPrefix, schema, ...rest } = get(\n    forms,\n    authType,\n    {}\n  );\n  const [{ formErrors, modifiedData, requestError }, dispatch] = useReducer(\n    reducer,\n    initialState,\n    init\n  );\n  const CancelToken = axios.CancelToken;\n  const source = CancelToken.source();\n\n  useEffect(() => {\n    // Cancel request on unmount\n    return () => {\n      source.cancel('Component unmounted');\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Reset the state on navigation change\n  useEffect(() => {\n    dispatch({\n      type: 'RESET_PROPS',\n    });\n  }, [authType]);\n\n  useEffect(() => {\n    if (authType === 'register') {\n      const getData = async () => {\n        try {\n          const {\n            data: { data },\n          } = await axios.get(\n            `${strapi.backendURL}/admin/registration-info?registrationToken=${registrationToken}`\n          );\n\n          if (data) {\n            dispatch({\n              type: 'SET_DATA',\n              data: { registrationToken, userInfo: data },\n            });\n          }\n        } catch (err) {\n          const errorMessage = get(err, ['response', 'data', 'message'], 'An error occured');\n\n          strapi.notification.toggle({\n            type: 'warning',\n            message: errorMessage,\n          });\n\n          // Redirect to the oops page in case of an invalid token\n          // @alexandrebodin @JAB I am not sure it is the wanted behavior\n          push(`/auth/oops?info=${encodeURIComponent(errorMessage)}`);\n        }\n      };\n\n      getData();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [authType]);\n\n  const handleChange = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name,\n      value,\n    });\n  };\n\n  const handleSubmit = async e => {\n    e.preventDefault();\n\n    dispatch({\n      type: 'SET_ERRORS',\n      errors: {},\n    });\n\n    const errors = await checkFormValidity(modifiedData, schema);\n\n    dispatch({\n      type: 'SET_ERRORS',\n      errors: errors || {},\n    });\n\n    if (!errors) {\n      const body = omit(modifiedData, fieldsToOmit);\n      const requestURL = `/admin/${endPoint}`;\n\n      if (authType === 'login') {\n        await loginRequest(body, requestURL);\n      }\n\n      if (authType === 'register' || authType === 'register-admin') {\n        await registerRequest(body, requestURL);\n      }\n\n      if (authType === 'forgot-password') {\n        await forgotPasswordRequest(body, requestURL);\n      }\n\n      if (authType === 'reset-password') {\n        await resetPasswordRequest(body, requestURL);\n      }\n    }\n  };\n\n  const forgotPasswordRequest = async (body, requestURL) => {\n    try {\n      await axios({\n        method: 'POST',\n        url: `${strapi.backendURL}${requestURL}`,\n        data: body,\n        cancelToken: source.token,\n      });\n\n      push('/auth/forgot-password-success');\n    } catch (err) {\n      console.error(err);\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  const loginRequest = async (body, requestURL) => {\n    try {\n      const {\n        data: {\n          data: { token, user },\n        },\n      } = await axios({\n        method: 'POST',\n        url: `${strapi.backendURL}${requestURL}`,\n        data: body,\n        cancelToken: source.token,\n      });\n\n      auth.setToken(token, modifiedData.rememberMe);\n      auth.setUserInfo(user, modifiedData.rememberMe);\n\n      push('/');\n    } catch (err) {\n      if (err.response) {\n        const errorMessage = get(err, ['response', 'data', 'message'], 'Something went wrong');\n        const errorStatus = get(err, ['response', 'data', 'statusCode'], 400);\n\n        if (camelCase(errorMessage).toLowerCase() === 'usernotactive') {\n          push('/auth/oops');\n\n          dispatch({\n            type: 'RESET_PROPS',\n          });\n\n          return;\n        }\n\n        dispatch({\n          type: 'SET_REQUEST_ERROR',\n          errorMessage,\n          errorStatus,\n        });\n      }\n    }\n  };\n\n  const registerRequest = async (body, requestURL) => {\n    try {\n      const {\n        data: {\n          data: { token, user },\n        },\n      } = await axios({\n        method: 'POST',\n        url: `${strapi.backendURL}${requestURL}`,\n        data: body,\n        cancelToken: source.token,\n      });\n\n      auth.setToken(token, false);\n      auth.setUserInfo(user, false);\n\n      if (\n        (authType === 'register' && modifiedData.userInfo.news === true) ||\n        (authType === 'register-admin' && modifiedData.news === true)\n      ) {\n        axios({\n          method: 'POST',\n          url: 'https://analytics.strapi.io/register',\n          data: {\n            email: user.email,\n            username: user.firstname,\n          },\n        });\n      }\n      // Redirect to the homePage\n      push('/');\n    } catch (err) {\n      if (err.response) {\n        const { data } = err.response;\n        const apiErrors = formatAPIErrors(data);\n\n        dispatch({\n          type: 'SET_ERRORS',\n          errors: apiErrors,\n        });\n      }\n    }\n  };\n\n  const resetPasswordRequest = async (body, requestURL) => {\n    try {\n      const {\n        data: {\n          data: { token, user },\n        },\n      } = await axios({\n        method: 'POST',\n        url: `${strapi.backendURL}${requestURL}`,\n        data: { ...body, resetPasswordToken: query.get('code') },\n        cancelToken: source.token,\n      });\n\n      auth.setToken(token, false);\n      auth.setUserInfo(user, false);\n\n      // Redirect to the homePage\n      push('/');\n    } catch (err) {\n      if (err.response) {\n        const errorMessage = get(err, ['response', 'data', 'message'], 'Something went wrong');\n        const errorStatus = get(err, ['response', 'data', 'statusCode'], 400);\n\n        dispatch({\n          type: 'SET_REQUEST_ERROR',\n          errorMessage,\n          errorStatus,\n        });\n      }\n    }\n  };\n\n  // Redirect the user to the login page if the endpoint does not exist\n  if (!forms[authType]) {\n    return <Redirect to=\"/\" />;\n  }\n\n  // Redirect the user to the login page if there is already an admin user\n  if (hasAdmin && authType === 'register-admin') {\n    return <Redirect to=\"/\" />;\n  }\n\n  // Redirect the user to the register-admin if it is the first user\n  if (!hasAdmin && authType !== 'register-admin') {\n    return <Redirect to=\"/auth/register-admin\" />;\n  }\n\n  // Redirect the user to the homepage if he is logged in\n  if (auth.getToken()) {\n    return <Redirect to=\"/\" />;\n  }\n\n  return (\n    <>\n      <Padded bottom size=\"md\">\n        <PageTitle title={upperFirst(authType)} />\n        <NavTopRightWrapper>\n          <LocaleToggle isLogged className=\"localeDropdownMenuNotLogged\" />\n        </NavTopRightWrapper>\n        <BaselineAlignment top size=\"78px\">\n          <Component\n            {...rest}\n            fieldsToDisable={fieldsToDisable}\n            formErrors={formErrors}\n            inputsPrefix={inputsPrefix}\n            modifiedData={modifiedData}\n            onChange={handleChange}\n            onSubmit={handleSubmit}\n            requestError={requestError}\n          />\n        </BaselineAlignment>\n      </Padded>\n    </>\n  );\n};\n\nAuthPage.defaultProps = {\n  hasAdmin: false,\n};\n\nAuthPage.propTypes = {\n  hasAdmin: PropTypes.bool,\n};\n\nexport default AuthPage;\n",
    "packages/strapi-admin/admin/src/containers/HomePage/hooks.js": "import { useEffect, useState, useRef } from 'react';\nimport axios from 'axios';\n\nconst useFetch = () => {\n  const isMounted = useRef(true);\n  const [state, setState] = useState({\n    error: false,\n    isLoading: true,\n    posts: [{ link: '1' }, { link: '2' }],\n  });\n\n  useEffect(() => {\n    const CancelToken = axios.CancelToken;\n    const source = CancelToken.source();\n\n    const fetchData = async () => {\n      try {\n        const { data } = await axios.get(\n          'https://strapi.io/api/blog-posts?_limit=2&_sort=publishedAt:desc',\n          {\n            cancelToken: source.token,\n          }\n        );\n\n        const posts = data.reduce((acc, curr) => {\n          acc.push({\n            title: curr.seo.metaTitle,\n            link: curr.slug,\n            content: curr.seo.metaDescription,\n          });\n\n          return acc;\n        }, []);\n\n        setState({ isLoading: false, posts, error: false });\n      } catch (err) {\n        if (isMounted.current) {\n          setState({ isLoading: false, error: true, posts: [] });\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      isMounted.current = false;\n      source.cancel('abort');\n    };\n  }, []);\n\n  return state;\n};\n\nexport default useFetch;\n",
    "packages/strapi-admin/admin/src/containers/InstalledPluginsPage/index.js": "import React from 'react';\nimport { useGlobalContext, request } from 'strapi-helper-plugin';\nimport { Header, List } from '@buffetjs/custom';\nimport PageTitle from '../../components/PageTitle';\nimport ContainerFluid from '../../components/ContainerFluid';\nimport ListWrapper from './ListWrapper';\nimport Row from './Row';\nimport generateRows from './utils/generateRows';\n\nconst InstalledPluginsPage = () => {\n  const { formatMessage, plugins } = useGlobalContext();\n  const onConfirm = async id => {\n    try {\n      const requestUrl = `/admin/plugins/uninstall/${id}`;\n      // Force the Overlayblocker to be displayed\n      const overlayblockerParams = {\n        enabled: true,\n        title: 'app.components.ListPluginsPage.deletePlugin.title',\n        description: 'app.components.ListPluginsPage.deletePlugin.description',\n      };\n      // Lock the app\n      strapi.lockApp(overlayblockerParams);\n      const response = await request(requestUrl, { method: 'DELETE' }, overlayblockerParams);\n\n      if (response.ok) {\n        // Reload the app\n        window.location.reload();\n      }\n    } catch (err) {\n      strapi.unlockApp();\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'app.components.listPluginsPage.deletePlugin.error' },\n      });\n    }\n  };\n\n  const rows = generateRows(plugins, onConfirm);\n\n  return (\n    <div>\n      <PageTitle\n        title={formatMessage({\n          id: 'app.components.ListPluginsPage.helmet.title',\n        })}\n      />\n      <ContainerFluid>\n        <Header\n          title={{\n            label: formatMessage({\n              id: 'app.components.ListPluginsPage.title',\n            }),\n          }}\n          content={formatMessage({\n            id: 'app.components.ListPluginsPage.description',\n          })}\n        />\n        <ListWrapper>\n          <List\n            title={formatMessage(\n              { id: 'app.components.listPlugins.title.plural' },\n              { number: rows.length }\n            )}\n            items={rows}\n            customRowComponent={Row}\n          />\n        </ListWrapper>\n      </ContainerFluid>\n    </div>\n  );\n};\n\nexport default InstalledPluginsPage;\n",
    "packages/strapi-admin/admin/src/containers/LeftMenu/index.js": "/*\n *\n * LeftMenu\n *\n */\n\nimport React, {\n  forwardRef,\n  memo,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useReducer,\n} from 'react';\nimport PropTypes from 'prop-types';\nimport { useLocation } from 'react-router-dom';\n\nimport { UserContext, hasPermissions, request } from 'strapi-helper-plugin';\nimport {\n  LeftMenuLinksSection,\n  LeftMenuFooter,\n  LeftMenuHeader,\n  LinksContainer,\n} from '../../components/LeftMenu';\nimport { useSettingsMenu } from '../../hooks';\nimport { generateModelsLinks, filterLinks } from './utils';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\nimport Loader from './Loader';\nimport Wrapper from './Wrapper';\n\nconst LeftMenu = forwardRef(({ shouldUpdateStrapi, version, plugins }, ref) => {\n  const location = useLocation();\n  const permissions = useContext(UserContext);\n  const { menu: settingsMenu } = useSettingsMenu(true);\n\n  // TODO: this needs to be added to the settings API in the v4\n  const settingsLinkNotificationCount = useMemo(() => {\n    if (shouldUpdateStrapi) {\n      return 1;\n    }\n\n    return 0;\n  }, [shouldUpdateStrapi]);\n  const [\n    {\n      collectionTypesSectionLinks,\n      generalSectionLinks,\n      isLoading,\n      pluginsSectionLinks,\n      singleTypesSectionLinks,\n    },\n    dispatch,\n  ] = useReducer(reducer, initialState, () =>\n    init(initialState, plugins, settingsMenu, settingsLinkNotificationCount)\n  );\n  const generalSectionLinksFiltered = useMemo(() => filterLinks(generalSectionLinks), [\n    generalSectionLinks,\n  ]);\n  const pluginsSectionLinksFiltered = useMemo(() => filterLinks(pluginsSectionLinks), [\n    pluginsSectionLinks,\n  ]);\n\n  const singleTypesSectionLinksFiltered = useMemo(() => filterLinks(singleTypesSectionLinks), [\n    singleTypesSectionLinks,\n  ]);\n  const collectTypesSectionLinksFiltered = useMemo(() => filterLinks(collectionTypesSectionLinks), [\n    collectionTypesSectionLinks,\n  ]);\n\n  // TODO:\n  // This is making a lot of request especially for the Author role as all permissions are being sent to\n  // to the backend.\n  // We should improve this by sending one request in with all permissions in bulk using the\n  // findMatchingPermissions util from the helper plugin and the /users/me/permissions endPoint\n  const checkPermissions = async (index, permissionsToCheck) => {\n    const hasPermission = await hasPermissions(permissions, permissionsToCheck);\n\n    return { index, hasPermission };\n  };\n\n  const generateArrayOfPromises = array =>\n    array.map((_, index) => checkPermissions(index, array[index].permissions));\n\n  const getModels = async () => {\n    const requestURL = '/content-manager/content-types';\n\n    try {\n      const { data } = await request(requestURL, { method: 'GET' });\n\n      const formattedData = generateModelsLinks(data);\n\n      const collectionTypesSectionLinksArrayOfPromises = generateArrayOfPromises(\n        formattedData.collectionTypesSectionLinks\n      );\n      const collectionTypesSectionResults = await Promise.all(\n        collectionTypesSectionLinksArrayOfPromises\n      );\n\n      const singleTypesSectionLinksArrayOfPromises = generateArrayOfPromises(\n        formattedData.singleTypesSectionLinks\n      );\n      const singleTypesSectionResults = await Promise.all(singleTypesSectionLinksArrayOfPromises);\n\n      dispatch({\n        type: 'GET_MODELS_SUCCEEDED',\n        data: formattedData,\n      });\n\n      dispatch({\n        type: 'SET_LINK_PERMISSIONS',\n        data: {\n          collectionTypesSectionLinks: collectionTypesSectionResults,\n          singleTypesSectionLinks: singleTypesSectionResults,\n        },\n      });\n    } catch (err) {\n      console.error(err);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  // Make the getModels method available for all the other plugins\n  // So they can regenerate the menu when they need\n  // It's specially used in the content type builder\n  useImperativeHandle(ref, () => ({\n    getModels,\n  }));\n\n  useEffect(() => {\n    const getLinksPermissions = async () => {\n      const generalSectionLinksArrayOfPromises = generateArrayOfPromises(generalSectionLinks);\n      const pluginsSectionLinksArrayOfPromises = generateArrayOfPromises(pluginsSectionLinks);\n\n      await getModels();\n\n      const generalSectionResults = await Promise.all(generalSectionLinksArrayOfPromises);\n      const pluginsSectionResults = await Promise.all(pluginsSectionLinksArrayOfPromises);\n\n      dispatch({\n        type: 'SET_LINK_PERMISSIONS',\n        data: {\n          generalSectionLinks: generalSectionResults,\n          pluginsSectionLinks: pluginsSectionResults,\n        },\n      });\n\n      dispatch({\n        type: 'TOGGLE_IS_LOADING',\n      });\n    };\n\n    getLinksPermissions();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [permissions]);\n\n  return (\n    <Wrapper>\n      <Loader show={isLoading} />\n      <LeftMenuHeader />\n      <LinksContainer>\n        {collectTypesSectionLinksFiltered.length > 0 && (\n          <LeftMenuLinksSection\n            section=\"collectionType\"\n            name=\"collectionType\"\n            links={collectTypesSectionLinksFiltered}\n            location={location}\n            searchable\n          />\n        )}\n        {singleTypesSectionLinksFiltered.length > 0 && (\n          <LeftMenuLinksSection\n            section=\"singleType\"\n            name=\"singleType\"\n            links={singleTypesSectionLinksFiltered}\n            location={location}\n            searchable\n          />\n        )}\n\n        {pluginsSectionLinksFiltered.length > 0 && (\n          <LeftMenuLinksSection\n            section=\"plugins\"\n            name=\"plugins\"\n            links={pluginsSectionLinksFiltered}\n            location={location}\n            searchable={false}\n            emptyLinksListMessage=\"app.components.LeftMenuLinkContainer.noPluginsInstalled\"\n          />\n        )}\n        {generalSectionLinksFiltered.length > 0 && (\n          <LeftMenuLinksSection\n            section=\"general\"\n            name=\"general\"\n            links={generalSectionLinksFiltered}\n            location={location}\n            searchable={false}\n          />\n        )}\n      </LinksContainer>\n      <LeftMenuFooter key=\"footer\" version={version} />\n    </Wrapper>\n  );\n});\n\nLeftMenu.propTypes = {\n  shouldUpdateStrapi: PropTypes.bool.isRequired,\n  version: PropTypes.string.isRequired,\n  plugins: PropTypes.object.isRequired,\n};\n\nexport default memo(LeftMenu);\n",
    "packages/strapi-admin/admin/src/containers/MarketplacePage/index.js": "import React from 'react';\nimport { LoadingIndicatorPage, useGlobalContext, request } from 'strapi-helper-plugin';\nimport { Header } from '@buffetjs/custom';\nimport { useHistory } from 'react-router-dom';\n\nimport { useFetchPluginsFromMarketPlace } from '../../hooks';\nimport PageTitle from '../../components/PageTitle';\nimport PluginCard from './PluginCard';\nimport Wrapper from './Wrapper';\n\nconst MarketPlacePage = () => {\n  const history = useHistory();\n  const { autoReload, currentEnvironment, formatMessage, plugins } = useGlobalContext();\n  const { error, isLoading, data } = useFetchPluginsFromMarketPlace();\n\n  if (isLoading || error) {\n    return <LoadingIndicatorPage />;\n  }\n\n  const handleDownloadPlugin = async pluginId => {\n    // Force the Overlayblocker to be displayed\n    const overlayblockerParams = {\n      enabled: true,\n      title: 'app.components.InstallPluginPage.Download.title',\n      description: 'app.components.InstallPluginPage.Download.description',\n    };\n    // Lock the app\n    strapi.lockApp(overlayblockerParams);\n\n    try {\n      const opts = {\n        method: 'POST',\n        body: {\n          plugin: pluginId,\n          port: window.location.port,\n        },\n      };\n      const response = await request('/admin/plugins/install', opts, overlayblockerParams);\n\n      if (response.ok) {\n        // Reload the app\n        window.location.reload();\n      }\n    } catch (err) {\n      strapi.unlockApp();\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  return (\n    <div>\n      <PageTitle\n        title={formatMessage({\n          id: 'app.components.InstallPluginPage.helmet',\n        })}\n      />\n      <Wrapper>\n        <Header\n          title={{\n            label: formatMessage({\n              id: 'app.components.InstallPluginPage.title',\n            }),\n          }}\n          content={formatMessage({\n            id: 'app.components.InstallPluginPage.description',\n          })}\n        />\n        <div className=\"row\" style={{ paddingTop: '4.1rem' }}>\n          {data.map(plugin => {\n            return (\n              <PluginCard\n                autoReload={autoReload}\n                currentEnvironment={currentEnvironment}\n                downloadPlugin={handleDownloadPlugin}\n                key={plugin.id}\n                history={history}\n                plugin={plugin}\n                showSupportUsButton={false}\n                isAlreadyInstalled={plugins[plugin.id] !== undefined}\n              />\n            );\n          })}\n        </div>\n      </Wrapper>\n    </div>\n  );\n};\n\nexport default MarketPlacePage;\n",
    "packages/strapi-admin/admin/src/containers/Onboarding/index.js": "import React, { useEffect, useReducer, memo } from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport axios from 'axios';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faQuestion, faTimes } from '@fortawesome/free-solid-svg-icons';\nimport cn from 'classnames';\nimport { useGlobalContext } from 'strapi-helper-plugin';\n\nimport formatVideoArray from './utils/formatAndStoreVideoArray';\n\nimport StaticLinks from './StaticLinks';\nimport Video from './Video';\nimport Wrapper from './Wrapper';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\nconst OnboardingVideos = () => {\n  const { emitEvent } = useGlobalContext();\n  const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n  const { isLoading, isOpen, videos } = reducerState.toJS();\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        const { data } = await axios.get('https://strapi.io/videos', {\n          timeout: 1000,\n        });\n        const { didWatchVideos, videos } = formatVideoArray(data);\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          didWatchVideos,\n          videos,\n        });\n      } catch (err) {\n        console.error(err);\n        dispatch({\n          type: 'HIDE_VIDEO_ONBOARDING',\n        });\n      }\n    };\n\n    getData();\n  }, []);\n\n  // Hide the player in case of request error\n  if (isLoading) {\n    return null;\n  }\n\n  const handleClick = () => {\n    const eventName = isOpen\n      ? 'didOpenGetStartedVideoContainer'\n      : 'didCloseGetStartedVideoContainer';\n\n    dispatch({ type: 'SET_IS_OPEN' });\n    emitEvent(eventName);\n  };\n  const handleClickOpenVideo = videoIndexToOpen => {\n    dispatch({\n      type: 'TOGGLE_VIDEO_MODAL',\n      videoIndexToOpen,\n    });\n  };\n  const handleUpdateVideoStartTime = (videoIndex, elapsedTime) => {\n    dispatch({\n      type: 'UPDATE_VIDEO_STARTED_TIME_AND_PLAYED_INFOS',\n      videoIndex,\n      elapsedTime,\n    });\n  };\n  const setVideoDuration = (videoIndex, duration) => {\n    dispatch({\n      type: 'SET_VIDEO_DURATION',\n      duration,\n      videoIndex,\n    });\n  };\n\n  const hasVideos = videos.length > 0;\n  const className = hasVideos ? 'visible' : 'hidden';\n\n  return (\n    <Wrapper className={className} isOpen={isOpen}>\n      <div className={cn('videosContent', isOpen ? 'shown' : 'hide')}>\n        <div className=\"videosHeader\">\n          <p>\n            <FormattedMessage id=\"app.components.Onboarding.title\" />\n          </p>\n          <p>\n            {Math.floor((videos.filter(v => v.end).length * 100) / videos.length)}\n            <FormattedMessage id=\"app.components.Onboarding.label.completed\" />\n          </p>\n        </div>\n        <ul className=\"onboardingList\">\n          {videos.map((video, index) => (\n            <Video\n              key={video.id || index}\n              id={index}\n              video={video}\n              onClick={() => handleClickOpenVideo(index)}\n              setVideoDuration={(_, duration) => {\n                setVideoDuration(index, duration);\n              }}\n              getVideoCurrentTime={(_, elapsedTime) => {\n                handleUpdateVideoStartTime(index, elapsedTime);\n              }}\n              didPlayVideo={(_, elapsedTime) => {\n                const eventName = `didPlay${index}GetStartedVideo`;\n\n                emitEvent(eventName, { timestamp: elapsedTime });\n              }}\n              didStopVideo={(_, elapsedTime) => {\n                const eventName = `didStop${index}Video`;\n\n                emitEvent(eventName, { timestamp: elapsedTime });\n              }}\n            />\n          ))}\n        </ul>\n        <StaticLinks />\n      </div>\n      <div className=\"openBtn\">\n        <button onClick={handleClick} className={isOpen ? 'active' : ''} type=\"button\">\n          <FontAwesomeIcon icon={faQuestion} />\n          <FontAwesomeIcon icon={faTimes} />\n          <span />\n        </button>\n      </div>\n    </Wrapper>\n  );\n};\n\nexport default memo(OnboardingVideos);\n",
    "packages/strapi-admin/admin/src/containers/Roles/EditPage/index.js": "import React, { useState, useRef } from 'react';\nimport { useRouteMatch } from 'react-router-dom';\nimport { get, has, isEmpty } from 'lodash';\nimport { BaselineAlignment, useGlobalContext, request, difference } from 'strapi-helper-plugin';\nimport { Header } from '@buffetjs/custom';\nimport { Padded } from '@buffetjs/core';\nimport { Formik } from 'formik';\nimport { useIntl } from 'react-intl';\nimport PageTitle from '../../../components/SettingsPageTitle';\nimport ContainerFluid from '../../../components/ContainerFluid';\nimport { Permissions, RoleForm } from '../../../components/Roles';\nimport { useFetchRole, useFetchPermissionsLayout } from '../../../hooks';\nimport { formatPermissionsToApi } from '../../../utils';\nimport schema from './utils/schema';\n\nconst EditPage = () => {\n  const { formatMessage } = useIntl();\n  const { emitEvent, settingsBaseURL } = useGlobalContext();\n  const {\n    params: { id },\n  } = useRouteMatch(`${settingsBaseURL}/roles/:id`);\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const permissionsRef = useRef();\n\n  const { isLoading: isLayoutLoading, data: permissionsLayout } = useFetchPermissionsLayout(id);\n  const {\n    role,\n    permissions: rolePermissions,\n    isLoading: isRoleLoading,\n    onSubmitSucceeded,\n  } = useFetchRole(id);\n\n  /* eslint-disable indent */\n  const headerActions = (handleSubmit, handleReset) =>\n    isLayoutLoading && isRoleLoading\n      ? []\n      : [\n          {\n            label: formatMessage({\n              id: 'app.components.Button.reset',\n              defaultMessage: 'Reset',\n            }),\n            disabled: role.code === 'strapi-super-admin',\n            onClick: () => {\n              handleReset();\n              permissionsRef.current.resetForm();\n            },\n            color: 'cancel',\n            type: 'button',\n          },\n          {\n            label: formatMessage({\n              id: 'app.components.Button.save',\n              defaultMessage: 'Save',\n            }),\n            disabled: role.code === 'strapi-super-admin',\n            onClick: handleSubmit,\n            color: 'success',\n            type: 'submit',\n            isLoading: isSubmiting,\n          },\n        ];\n  /* eslint-enable indent */\n\n  const handleEditRoleSubmit = async data => {\n    try {\n      strapi.lockAppWithOverlay();\n      setIsSubmiting(true);\n\n      const permissionsToSend = permissionsRef.current.getPermissions();\n\n      const checkConditionsDiff = () => {\n        const diff = difference(\n          get(permissionsToSend, 'contentTypesPermissions', {}),\n          get(rolePermissions, 'contentTypesPermissions', {})\n        );\n\n        if (isEmpty(diff)) {\n          return false;\n        }\n\n        return Object.keys(diff).some(key => {\n          return has(diff, [key, 'conditions']);\n        });\n      };\n\n      await request(`/admin/roles/${id}`, {\n        method: 'PUT',\n        body: data,\n      });\n\n      if (role.code !== 'strapi-super-admin' && !isEmpty(permissionsToSend)) {\n        await request(`/admin/roles/${id}/permissions`, {\n          method: 'PUT',\n          body: {\n            permissions: formatPermissionsToApi(permissionsToSend),\n          },\n        });\n\n        if (checkConditionsDiff()) {\n          emitEvent('didUpdateConditions');\n        }\n      }\n\n      permissionsRef.current.setFormAfterSubmit();\n      onSubmitSucceeded({ name: data.name, description: data.description });\n\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: 'notification.success.saved' },\n      });\n    } catch (err) {\n      console.error(err.response);\n      const message = get(err, 'response.payload.message', 'An error occured');\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message,\n      });\n    } finally {\n      setIsSubmiting(false);\n      strapi.unlockApp();\n    }\n  };\n\n  return (\n    <>\n      <PageTitle name=\"Roles\" />\n      <Formik\n        enableReinitialize\n        initialValues={{\n          name: role.name,\n          description: role.description,\n        }}\n        onSubmit={handleEditRoleSubmit}\n        validationSchema={schema}\n        validateOnChange={false}\n      >\n        {({ handleSubmit, values, errors, handleReset, handleChange, handleBlur }) => (\n          <form onSubmit={handleSubmit}>\n            <ContainerFluid padding=\"0\">\n              <Header\n                title={{\n                  label: formatMessage({\n                    id: 'Settings.roles.edit.title',\n                    defaultMessage: 'Edit a role',\n                  }),\n                }}\n                content={formatMessage({\n                  id: 'Settings.roles.create.description',\n                  defaultMessage: 'Define the rights given to the role',\n                })}\n                actions={headerActions(handleSubmit, handleReset)}\n                isLoading={isLayoutLoading || isRoleLoading}\n              />\n              <BaselineAlignment top size=\"3px\" />\n              <RoleForm\n                isLoading={isRoleLoading}\n                disabled={role.code === 'strapi-super-admin'}\n                errors={errors}\n                values={values}\n                onChange={handleChange}\n                onBlur={handleBlur}\n                role={role}\n              />\n              {!isLayoutLoading && !isRoleLoading && (\n                <Padded top bottom size=\"md\">\n                  <Permissions\n                    permissionsLayout={permissionsLayout}\n                    rolePermissions={rolePermissions}\n                    role={role}\n                    ref={permissionsRef}\n                  />\n                </Padded>\n              )}\n            </ContainerFluid>\n          </form>\n        )}\n      </Formik>\n    </>\n  );\n};\n\nexport default EditPage;\n",
    "packages/strapi-admin/admin/src/containers/Users/ListPage/index.js": "import React, { useCallback, useEffect, useMemo, useReducer, useRef, useState } from 'react';\nimport {\n  BaselineAlignment,\n  useQuery,\n  request,\n  useUserPermissions,\n  LoadingIndicatorPage,\n  PopUpWarning,\n} from 'strapi-helper-plugin';\nimport { get } from 'lodash';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { Flex, Padded } from '@buffetjs/core';\nimport PageTitle from '../../../components/SettingsPageTitle';\nimport { useSettingsHeaderSearchContext } from '../../../hooks';\nimport { Footer, List, Filter, FilterPicker, SortPicker } from '../../../components/Users';\nimport adminPermissions from '../../../permissions';\nimport Header from './Header';\nimport ModalForm from './ModalForm';\nimport getFilters from './utils/getFilters';\nimport init from './init';\nimport { initialState, reducer } from './reducer';\n\nconst ListPage = () => {\n  const {\n    isLoading: isLoadingForPermissions,\n    allowedActions: { canCreate, canDelete, canRead, canUpdate },\n  } = useUserPermissions(adminPermissions.settings.users);\n  const [isWarningDeleteAllOpened, setIsWarningDeleteAllOpened] = useState(false);\n  const [isModalOpened, setIsModalOpened] = useState(false);\n  const { toggleHeaderSearch } = useSettingsHeaderSearchContext();\n  const query = useQuery();\n  const { push } = useHistory();\n  const { search } = useLocation();\n  const filters = useMemo(() => {\n    return getFilters(search);\n  }, [search]);\n\n  const [\n    {\n      data,\n      dataToDelete,\n      isLoading,\n      pagination: { total },\n      shouldRefetchData,\n      showModalConfirmButtonLoading,\n    },\n    dispatch,\n  ] = useReducer(reducer, initialState, init);\n  const pageSize = parseInt(query.get('pageSize') || 10, 10);\n  const page = parseInt(query.get('page') || 0, 10);\n  const _sort = decodeURIComponent(query.get('_sort'));\n  const _q = decodeURIComponent(query.get('_q') || '');\n  const getDataRef = useRef();\n  const listRef = useRef();\n\n  getDataRef.current = async () => {\n    if (!canRead) {\n      dispatch({\n        type: 'UNSET_IS_LOADING',\n      });\n\n      return;\n    }\n    // Show the loading state and reset the state\n    dispatch({\n      type: 'GET_DATA',\n    });\n\n    try {\n      const {\n        data: { results, pagination },\n      } = await request(`/admin/users${search}`, { method: 'GET' });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        data: results,\n        pagination,\n      });\n    } catch (err) {\n      console.error(err.response);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  useEffect(() => {\n    if (!isLoadingForPermissions) {\n      getDataRef.current();\n    }\n  }, [search, isLoadingForPermissions]);\n\n  useEffect(() => {\n    if (canRead) {\n      toggleHeaderSearch({ id: 'Settings.permissions.menu.link.users.label' });\n    }\n\n    return () => {\n      if (canRead) {\n        toggleHeaderSearch();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [canRead]);\n\n  const handleChangeDataToDelete = ids => {\n    dispatch({\n      type: 'ON_CHANGE_DATA_TO_DELETE',\n      dataToDelete: ids,\n    });\n  };\n\n  const handleChangeFilter = ({ filter, name, value }) => {\n    const filterName = `${name}${filter}`;\n\n    updateSearchParams(filterName, encodeURIComponent(value), true);\n  };\n\n  const handleChangeFooterParams = ({ target: { name, value } }) => {\n    let paramName = name.split('.')[1].replace('_', '');\n\n    if (paramName === 'limit') {\n      paramName = 'pageSize';\n    }\n\n    updateSearchParams(paramName, value);\n  };\n\n  const handleChangeSort = ({ target: { name, value } }) => {\n    updateSearchParams(name, value);\n  };\n\n  const handleClickDeleteFilter = ({ target: { name } }) => {\n    const currentSearch = new URLSearchParams(search);\n\n    currentSearch.delete(name);\n\n    push({ search: currentSearch.toString() });\n  };\n\n  const handleClickDelete = useCallback(id => {\n    handleToggleModal();\n\n    dispatch({\n      type: 'ON_CHANGE_DATA_TO_DELETE',\n      dataToDelete: [id],\n    });\n  }, []);\n\n  const handleCloseModal = () => {\n    // Refetch data\n    getDataRef.current();\n  };\n\n  const handleClosedModalDelete = () => {\n    if (shouldRefetchData) {\n      getDataRef.current();\n    } else {\n      // Empty the selected ids when the modal closes\n      dispatch({\n        type: 'RESET_DATA_TO_DELETE',\n      });\n\n      // Reset the list's reducer dataToDelete state using a ref so we don't need an effect\n      listRef.current.resetDataToDelete();\n    }\n  };\n\n  const handleConfirmDeleteData = useCallback(async () => {\n    dispatch({\n      type: 'ON_DELETE_USERS',\n    });\n\n    let shouldDispatchSucceededAction = false;\n\n    try {\n      await request('/admin/users/batch-delete', {\n        method: 'POST',\n        body: {\n          ids: dataToDelete,\n        },\n      });\n      shouldDispatchSucceededAction = true;\n    } catch (err) {\n      const errorMessage = get(err, 'response.payload.data', 'An error occured');\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message: errorMessage,\n      });\n    }\n\n    // Only dispatch the action once\n    if (shouldDispatchSucceededAction) {\n      dispatch({\n        type: 'ON_DELETE_USERS_SUCCEEDED',\n      });\n    }\n\n    handleToggleModal();\n  }, [dataToDelete]);\n\n  const handleToggle = () => setIsModalOpened(prev => !prev);\n\n  const handleToggleModal = () => setIsWarningDeleteAllOpened(prev => !prev);\n\n  const updateSearchParams = (name, value, shouldDeleteSearch = false) => {\n    const currentSearch = new URLSearchParams(search);\n    // Update the currentSearch\n    currentSearch.set(name, value);\n\n    if (shouldDeleteSearch) {\n      currentSearch.delete('_q');\n    }\n\n    push({\n      search: currentSearch.toString(),\n    });\n  };\n\n  if (isLoadingForPermissions) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <div>\n      <PageTitle name=\"Users\" />\n      <Header\n        canCreate={canCreate}\n        canDelete={canDelete}\n        canRead={canRead}\n        count={total}\n        dataToDelete={dataToDelete}\n        onClickAddUser={handleToggle}\n        onClickDelete={handleToggleModal}\n        isLoading={isLoading}\n      />\n      {canRead && (\n        <>\n          <BaselineAlignment top size=\"1px\">\n            <Flex flexWrap=\"wrap\">\n              <SortPicker onChange={handleChangeSort} value={_sort} />\n              <Padded right size=\"10px\" />\n              <BaselineAlignment bottom size=\"6px\">\n                <FilterPicker onChange={handleChangeFilter} />\n              </BaselineAlignment>\n              <Padded right size=\"10px\" />\n              {filters.map((filter, i) => (\n                // eslint-disable-next-line react/no-array-index-key\n                <Filter key={i} {...filter} onClick={handleClickDeleteFilter} />\n              ))}\n            </Flex>\n          </BaselineAlignment>\n          <BaselineAlignment top size=\"8px\" />\n          <Padded top size=\"sm\">\n            <List\n              canDelete={canDelete}\n              canUpdate={canUpdate}\n              dataToDelete={dataToDelete}\n              isLoading={isLoading}\n              data={data}\n              onChange={handleChangeDataToDelete}\n              onClickDelete={handleClickDelete}\n              searchParam={_q}\n              filters={filters}\n              ref={listRef}\n            />\n          </Padded>\n          <Footer\n            count={total}\n            onChange={handleChangeFooterParams}\n            params={{ _limit: pageSize, _page: page }}\n          />\n        </>\n      )}\n      <ModalForm isOpen={isModalOpened} onClosed={handleCloseModal} onToggle={handleToggle} />\n      <PopUpWarning\n        isOpen={isWarningDeleteAllOpened}\n        onClosed={handleClosedModalDelete}\n        onConfirm={handleConfirmDeleteData}\n        toggleModal={handleToggleModal}\n        isConfirmButtonLoading={showModalConfirmButtonLoading}\n      />\n    </div>\n  );\n};\n\nexport default ListPage;\n",
    "packages/strapi-admin/admin/src/containers/Webhooks/EditView/index.js": "/**\n *\n * EditView\n *\n */\n\nimport React, { useEffect, useMemo, useReducer, useRef, useState } from 'react';\nimport { useHistory, useRouteMatch } from 'react-router-dom';\nimport { get, isEmpty, isEqual, omit } from 'lodash';\nimport { Header, Inputs as InputsIndex } from '@buffetjs/custom';\nimport { Play } from '@buffetjs/icons';\nimport {\n  request,\n  useGlobalContext,\n  getYupInnerErrors,\n  BackHeader,\n  LoadingIndicatorPage,\n} from 'strapi-helper-plugin';\nimport { useModels } from '../../../hooks';\nimport PageTitle from '../../../components/SettingsPageTitle';\nimport { Inputs, TriggerContainer } from '../../../components/Webhooks';\nimport reducer, { initialState } from './reducer';\nimport { cleanData, form, schema } from './utils';\nimport Wrapper from './Wrapper';\n\nfunction EditView() {\n  const { isLoading: isLoadingForModels, collectionTypes } = useModels();\n\n  const isMounted = useRef();\n  const { formatMessage } = useGlobalContext();\n  const [submittedOnce, setSubmittedOnce] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [reducerState, dispatch] = useReducer(reducer, initialState);\n  const { push, replace } = useHistory();\n  const {\n    params: { id },\n  } = useRouteMatch('/settings/webhooks/:id');\n\n  const abortController = new AbortController();\n  const { signal } = abortController;\n  const isCreating = id === 'create';\n\n  const {\n    formErrors,\n    modifiedData,\n    initialData,\n    isLoading,\n    isTriggering,\n    triggerResponse,\n  } = reducerState.toJS();\n\n  useEffect(() => {\n    isMounted.current = true;\n\n    const fetchData = async () => {\n      try {\n        const { data } = await request(`/admin/webhooks/${id}`, {\n          method: 'GET',\n        });\n\n        if (isMounted.current) {\n          dispatch({\n            type: 'GET_DATA_SUCCEEDED',\n            data,\n          });\n        }\n      } catch (err) {\n        if (isMounted.current) {\n          dispatch({ type: 'UNSET_LOADER' });\n\n          if (err.code !== 20) {\n            strapi.notification.toggle({\n              type: 'warning',\n              message: { id: 'notification.error' },\n            });\n          }\n        }\n      }\n    };\n\n    if (!isCreating) {\n      fetchData();\n    } else {\n      dispatch({ type: 'UNSET_LOADER' });\n    }\n\n    return () => {\n      isMounted.current = false;\n      abortController.abort();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [id, isCreating]);\n\n  const areActionDisabled = isEqual(initialData, modifiedData);\n\n  const isTriggerActionDisabled = isCreating || (!isCreating && !areActionDisabled) || isTriggering;\n\n  const formattedErrors = Object.keys(formErrors)\n    .filter(key => key.includes('headers'))\n    .reduce((obj, key) => {\n      obj[key] = formErrors[key];\n\n      return obj;\n    }, {});\n\n  /* eslint-disable indent */\n  const headerTitle = isCreating\n    ? formatMessage({\n        id: 'Settings.webhooks.create',\n      })\n    : initialData.name;\n\n  const headersActions = [\n    {\n      color: 'primary',\n      disabled: isTriggerActionDisabled,\n      label: formatMessage({\n        id: 'Settings.webhooks.trigger',\n      }),\n      onClick: () => handleTrigger(),\n      title: isTriggerActionDisabled\n        ? formatMessage({\n            id: 'Settings.webhooks.trigger.save',\n          })\n        : null,\n      type: 'button',\n      icon: (\n        <Play width=\"8px\" height=\"10px\" fill={isTriggerActionDisabled ? '#b4b6ba' : '#ffffff'} />\n      ),\n    },\n    {\n      color: 'cancel',\n      disabled: areActionDisabled,\n      label: formatMessage({\n        id: 'app.components.Button.reset',\n      }),\n      onClick: () => handleReset(),\n      style: {\n        paddingLeft: '20px',\n        paddingRight: '20px',\n      },\n      type: 'button',\n    },\n    {\n      color: 'success',\n      disabled: areActionDisabled,\n      label: formatMessage({\n        id: 'app.components.Button.save',\n      }),\n      isLoading: isSubmitting,\n      style: {\n        minWidth: 140,\n      },\n      type: 'submit',\n    },\n  ];\n  /* eslint-enable indent */\n\n  const headerProps = {\n    title: {\n      label: headerTitle,\n    },\n    actions: headersActions,\n  };\n\n  const checkFormErrors = async (submit = false) => {\n    try {\n      await schema.validate(modifiedData, { abortEarly: false });\n\n      if (isMounted.current) {\n        setErrors({});\n\n        if (submit) {\n          submitForm();\n        }\n      }\n    } catch (err) {\n      if (isMounted.current) {\n        setErrors(getYupInnerErrors(err));\n\n        if (submit) {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.form.error.fields' },\n          });\n        }\n      }\n    }\n  };\n\n  const createWebhooks = async () => {\n    try {\n      strapi.lockAppWithOverlay();\n      setIsSubmitting(true);\n      const { data } = await request('/admin/webhooks', {\n        method: 'POST',\n        body: cleanData(modifiedData),\n      });\n      setIsSubmitting(false);\n      dispatch({\n        type: 'SUBMIT_SUCCEEDED',\n      });\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: 'Settings.webhooks.created' },\n      });\n      replace(`/settings/webhooks/${data.id}`);\n    } catch (err) {\n      setIsSubmitting(false);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  const getErrorMessage = error => {\n    if (!error) {\n      return null;\n    }\n\n    return formatMessage({\n      id: error.id,\n    });\n  };\n\n  const goToList = () => push('/settings/webhooks');\n\n  const handleChange = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name.split('.'),\n      value,\n    });\n\n    if (submittedOnce) {\n      if (name === 'events') {\n        resetEventsError();\n      }\n      if (name.includes('headers')) {\n        resetHeadersError(name);\n      }\n    }\n  };\n\n  const handleClick = () => {\n    dispatch({\n      type: 'ADD_NEW_HEADER',\n      keys: ['headers'],\n    });\n  };\n\n  const handleTrigger = async () => {\n    dispatch({\n      type: 'SET_IS_TRIGGERING',\n    });\n\n    try {\n      const { data } = await request(`/admin/webhooks/${id}/trigger`, {\n        method: 'POST',\n        signal,\n      });\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'TRIGGER_SUCCEEDED',\n          response: data,\n        });\n      }\n    } catch (err) {\n      if (isMounted.current) {\n        if (err.code !== 20) {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n        dispatch({\n          type: 'SET_IS_TRIGGERING',\n        });\n      }\n    }\n  };\n\n  const handleRemove = index => {\n    dispatch({\n      type: 'ON_HEADER_REMOVE',\n      index,\n    });\n\n    resetHeadersErrors();\n  };\n\n  const handleReset = () =>\n    dispatch({\n      type: 'RESET_FORM',\n    });\n\n  const handleSubmit = e => {\n    e.preventDefault();\n    setSubmittedOnce(true);\n    checkFormErrors(true);\n  };\n\n  const onCancelTrigger = () => {\n    abortController.abort();\n\n    dispatch({\n      type: 'ON_TRIGGER_CANCELED',\n    });\n  };\n\n  const resetEventsError = () => {\n    const errors = formErrors;\n    delete errors.events;\n    setErrors(errors);\n  };\n\n  const resetHeadersError = keys => {\n    const errors = formErrors;\n\n    setErrors(omit(errors, [keys]));\n  };\n\n  const resetHeadersErrors = () => {\n    const errors = formErrors;\n    const newErrors = Object.keys(errors)\n      .filter(key => !key.includes('headers'))\n      .reduce((obj, key) => {\n        obj[key] = formErrors[key];\n\n        return obj;\n      }, {});\n\n    setErrors(newErrors);\n  };\n\n  const setErrors = errors => {\n    dispatch({\n      type: 'SET_ERRORS',\n      errors,\n    });\n  };\n\n  const submitForm = () => {\n    if (!isCreating) {\n      updateWebhook();\n    } else {\n      createWebhooks();\n    }\n  };\n\n  const updateWebhook = async () => {\n    try {\n      strapi.lockAppWithOverlay();\n      setIsSubmitting(true);\n\n      const body = cleanData(modifiedData);\n      delete body.id;\n\n      await request(`/admin/webhooks/${id}`, {\n        method: 'PUT',\n        body,\n      });\n      setIsSubmitting(false);\n      dispatch({\n        type: 'SUBMIT_SUCCEEDED',\n      });\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: 'notification.form.success.fields' },\n      });\n    } catch (err) {\n      setIsSubmitting(false);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  const shouldShowDPEvents = useMemo(\n    () => collectionTypes.some(ct => ct.options.draftAndPublish === true),\n    [collectionTypes]\n  );\n\n  if (isLoading || isLoadingForModels) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <Wrapper>\n      <PageTitle name=\"Webhooks\" />\n      <BackHeader onClick={goToList} />\n      <form onSubmit={handleSubmit}>\n        <Header {...headerProps} />\n        {(isTriggering || !isEmpty(triggerResponse)) && (\n          <div className=\"trigger-wrapper\">\n            <TriggerContainer\n              isPending={isTriggering}\n              response={triggerResponse}\n              onCancel={onCancelTrigger}\n            />\n          </div>\n        )}\n        <div className=\"form-wrapper\">\n          <div className=\"form-card\">\n            <div className=\"row\">\n              {Object.keys(form).map(key => {\n                return (\n                  <div key={key} className={form[key].styleName}>\n                    <InputsIndex\n                      {...form[key]}\n                      customInputs={{\n                        headers: Inputs,\n                        events: Inputs,\n                      }}\n                      label={formatMessage({\n                        id: form[key].label,\n                      })}\n                      error={getErrorMessage(get(formErrors, key, null))}\n                      name={key}\n                      onChange={handleChange}\n                      shouldShowDPEvents={shouldShowDPEvents}\n                      validations={form[key].validations}\n                      value={modifiedData[key] || form[key].value}\n                      {...(form[key].type === 'headers' && {\n                        onClick: handleClick,\n                        onRemove: handleRemove,\n                        customError: formattedErrors,\n                      })}\n                    />\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n      </form>\n    </Wrapper>\n  );\n}\n\nexport default EditView;\n",
    "packages/strapi-admin/admin/src/containers/Webhooks/ListView/index.js": "/**\n *\n * ListView\n *\n */\n\nimport React, { useEffect, useReducer, useRef, useState } from 'react';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { Header, List } from '@buffetjs/custom';\nimport { Button } from '@buffetjs/core';\nimport { Plus } from '@buffetjs/icons';\nimport { omit } from 'lodash';\nimport { useIntl } from 'react-intl';\nimport {\n  request,\n  ListButton,\n  PopUpWarning,\n  useUserPermissions,\n  LoadingIndicatorPage,\n} from 'strapi-helper-plugin';\nimport adminPermissions from '../../../permissions';\nimport PageTitle from '../../../components/SettingsPageTitle';\nimport { EmptyList, ListRow } from '../../../components/Webhooks';\nimport Wrapper from './Wrapper';\nimport reducer, { initialState } from './reducer';\n\nfunction ListView() {\n  const {\n    isLoading,\n    allowedActions: { canCreate, canRead, canUpdate, canDelete },\n  } = useUserPermissions(adminPermissions.settings.webhooks);\n\n  const isMounted = useRef(true);\n  const { formatMessage } = useIntl();\n  const [showModal, setShowModal] = useState(false);\n  const [reducerState, dispatch] = useReducer(reducer, initialState);\n  const { push } = useHistory();\n  const { pathname } = useLocation();\n\n  const { webhooks, webhooksToDelete, webhookToDelete } = reducerState.toJS();\n\n  useEffect(() => {\n    isMounted.current = true;\n\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    if (canRead) {\n      fetchData();\n    }\n  }, [canRead]);\n\n  const getWebhookIndex = id => webhooks.findIndex(webhook => webhook.id === id);\n\n  // New button\n  const addBtnLabel = formatMessage({\n    id: 'Settings.webhooks.list.button.add',\n  });\n\n  const newButtonProps = {\n    label: addBtnLabel,\n    onClick: () => handleGoTo('create'),\n    color: 'primary',\n    type: 'button',\n    icon: <Plus fill=\"#007eff\" width=\"11px\" height=\"11px\" />,\n    Component: props => {\n      if (canCreate) {\n        return <Button {...props} />;\n      }\n\n      return null;\n    },\n  };\n\n  // Header props\n  const actions = [\n    {\n      ...newButtonProps,\n      icon: true,\n      style: {\n        paddingLeft: 15,\n        paddingRight: 15,\n      },\n    },\n  ];\n\n  const headerProps = {\n    title: {\n      label: formatMessage({ id: 'Settings.webhooks.title' }),\n    },\n    content: formatMessage({ id: 'Settings.webhooks.list.description' }),\n    actions,\n  };\n\n  // List props\n  const rowsCount = webhooks.length;\n  const titleLabel = `${\n    rowsCount > 1\n      ? formatMessage({ id: 'Settings.webhooks.title' })\n      : formatMessage({ id: 'Settings.webhooks.singular' })\n  }`;\n  const title = `${rowsCount} ${titleLabel}`;\n\n  /* eslint-disable indent */\n  const deleteButtonProps = canDelete\n    ? {\n        color: 'delete',\n        disabled: !(webhooksToDelete.length > 0),\n        label: formatMessage({ id: 'app.utils.delete' }),\n        onClick: () => setShowModal(true),\n        type: 'button',\n      }\n    : null;\n  /* eslint-enable indent */\n\n  const listProps = {\n    title,\n    button: deleteButtonProps,\n    items: webhooks,\n  };\n\n  const fetchData = async () => {\n    try {\n      const { data } = await request('/admin/webhooks', {\n        method: 'GET',\n      });\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n        });\n      }\n    } catch (err) {\n      if (isMounted.current) {\n        if (err.code !== 20) {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      }\n    }\n  };\n\n  const handleChange = (value, id) => {\n    dispatch({\n      type: 'SET_WEBHOOKS_TO_DELETE',\n      value,\n      id,\n    });\n  };\n\n  const handleConfirmDelete = () => {\n    if (webhookToDelete) {\n      handleConfirmDeleteOne();\n    } else {\n      handleConfirmDeleteAll();\n    }\n  };\n\n  const handleConfirmDeleteOne = async () => {\n    try {\n      await request(`/admin/webhooks/${webhookToDelete}`, {\n        method: 'DELETE',\n      });\n\n      dispatch({\n        type: 'WEBHOOK_DELETED',\n        index: getWebhookIndex(webhookToDelete),\n      });\n    } catch (err) {\n      if (err.code !== 20) {\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      }\n    }\n    setShowModal(false);\n  };\n\n  const handleConfirmDeleteAll = async () => {\n    const body = {\n      ids: webhooksToDelete,\n    };\n\n    try {\n      await request('/admin/webhooks/batch-delete', {\n        method: 'POST',\n        body,\n      });\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'WEBHOOKS_DELETED',\n        });\n      }\n    } catch (err) {\n      if (isMounted.current) {\n        if (err.code !== 20) {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      }\n    }\n    setShowModal(false);\n  };\n\n  const handleDeleteClick = id => {\n    setShowModal(true);\n\n    dispatch({\n      type: 'SET_WEBHOOK_TO_DELETE',\n      id,\n    });\n  };\n\n  const handleEnabledChange = async (value, id) => {\n    const webhookIndex = getWebhookIndex(id);\n\n    const initialWebhookProps = webhooks[webhookIndex];\n    const keys = [webhookIndex, 'isEnabled'];\n\n    const body = {\n      ...initialWebhookProps,\n      isEnabled: value,\n    };\n\n    delete body.id;\n\n    try {\n      dispatch({\n        type: 'SET_WEBHOOK_ENABLED',\n        keys,\n        value,\n      });\n\n      await request(`/admin/webhooks/${id}`, {\n        method: 'PUT',\n        body,\n      });\n    } catch (err) {\n      if (isMounted.current) {\n        dispatch({\n          type: 'SET_WEBHOOK_ENABLED',\n          keys,\n          value: !value,\n        });\n\n        if (err.code !== 20) {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      }\n    }\n  };\n\n  const handleGoTo = to => {\n    push(`${pathname}/${to}`);\n  };\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <Wrapper>\n      <PageTitle name=\"Webhooks\" />\n      <Header {...headerProps} />\n      {canRead && (\n        <div className=\"list-wrapper\">\n          {rowsCount > 0 ? (\n            <List\n              {...listProps}\n              customRowComponent={props => {\n                return (\n                  <ListRow\n                    {...props}\n                    canUpdate={canUpdate}\n                    canDelete={canDelete}\n                    onCheckChange={handleChange}\n                    onEditClick={handleGoTo}\n                    onDeleteCLick={handleDeleteClick}\n                    onEnabledChange={handleEnabledChange}\n                    itemsToDelete={webhooksToDelete}\n                  />\n                );\n              }}\n            />\n          ) : (\n            <EmptyList />\n          )}\n          <ListButton>{canCreate && <Button {...omit(newButtonProps, 'Component')} />}</ListButton>\n        </div>\n      )}\n      <PopUpWarning\n        isOpen={showModal}\n        toggleModal={() => setShowModal(!showModal)}\n        popUpWarningType=\"danger\"\n        onConfirm={handleConfirmDelete}\n      />\n    </Wrapper>\n  );\n}\n\nexport default ListView;\n",
    "packages/strapi-admin/admin/src/hooks/useFetchPermissionsLayout/index.js": "import { useEffect, useReducer } from 'react';\nimport { request } from 'strapi-helper-plugin';\n\nimport reducer, { initialState } from './reducer';\n\nconst useFetchPermissionsLayout = () => {\n  const [{ data, error, isLoading }, dispatch] = useReducer(reducer, initialState);\n\n  useEffect(() => {\n    const getData = async () => {\n      dispatch({\n        type: 'GET_DATA',\n      });\n\n      const { data } = await request('/admin/permissions', { method: 'GET' });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        data,\n      });\n    };\n\n    getData();\n  }, []);\n\n  return { data, error, isLoading };\n};\n\nexport default useFetchPermissionsLayout;\n",
    "packages/strapi-admin/admin/src/hooks/useFetchPluginsFromMarketPlace/index.js": "import { useEffect, useState } from 'react';\nimport axios from 'axios';\nimport { useGlobalContext } from 'strapi-helper-plugin';\n\nconst useFetchPluginsFromMarketPlace = () => {\n  const { currentLocale } = useGlobalContext();\n  const [state, setState] = useState({\n    error: false,\n    isLoading: true,\n    data: null,\n  });\n\n  useEffect(() => {\n    const CancelToken = axios.CancelToken;\n    const source = CancelToken.source();\n\n    const getData = async () => {\n      try {\n        const { data } = await axios.get('https://marketplace.strapi.io/plugins', {\n          cancelToken: source.token,\n          params: { lang: currentLocale },\n        });\n\n        setState({\n          isLoading: false,\n          data,\n          error: false,\n        });\n      } catch (err) {\n        if (axios.isCancel(err)) {\n          // Silent\n        } else {\n          // handle error\n          setState(prev => ({ ...prev, isLoading: false, error: true }));\n        }\n      }\n    };\n\n    getData();\n\n    return () => {\n      source.cancel();\n    };\n  }, [currentLocale]);\n\n  return state;\n};\n\nexport default useFetchPluginsFromMarketPlace;\n",
    "packages/strapi-admin/admin/src/hooks/useFetchRole/index.js": "import { useCallback, useReducer, useEffect } from 'react';\nimport { request } from 'strapi-helper-plugin';\n\nimport reducer, { initialState } from './reducer';\nimport { formatPermissionsFromApi } from '../../utils';\n\nconst useFetchRole = id => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  useEffect(() => {\n    if (id) {\n      fetchRole(id);\n    } else {\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        role: {},\n        permissions: {},\n      });\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [id]);\n\n  const fetchRole = async roleId => {\n    try {\n      const [{ data: role }, { data: permissions }] = await Promise.all(\n        [`roles/${roleId}`, `roles/${roleId}/permissions`].map(endPoint =>\n          request(`/admin/${endPoint}`, { method: 'GET' })\n        )\n      );\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        role,\n        permissions: formatPermissionsFromApi(permissions),\n      });\n    } catch (err) {\n      console.error(err);\n\n      dispatch({\n        type: 'GET_DATA_ERROR',\n      });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  const handleSubmitSucceeded = useCallback(data => {\n    dispatch({\n      type: 'ON_SUBMIT_SUCCEEDED',\n      ...data,\n    });\n  }, []);\n\n  return { ...state, onSubmitSucceeded: handleSubmitSucceeded };\n};\n\nexport default useFetchRole;\n",
    "packages/strapi-admin/admin/src/hooks/useModels/index.js": "import { useReducer, useEffect } from 'react';\nimport { request } from 'strapi-helper-plugin';\n\nimport reducer, { initialState } from './reducer';\n\nconst useModels = () => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  useEffect(() => {\n    fetchModels();\n  }, []);\n\n  const fetchModels = async () => {\n    dispatch({\n      type: 'GET_MODELS',\n    });\n\n    try {\n      const [{ data: components }, { data: contentTypes }] = await Promise.all(\n        ['components', 'content-types'].map(endPoint =>\n          request(`/content-manager/${endPoint}`, { method: 'GET' })\n        )\n      );\n\n      dispatch({\n        type: 'GET_MODELS_SUCCEDED',\n        contentTypes,\n        components,\n      });\n    } catch (err) {\n      dispatch({\n        type: 'GET_MODELS_ERROR',\n      });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  return {\n    ...state,\n    getData: fetchModels,\n  };\n};\n\nexport default useModels;\n",
    "packages/strapi-admin/admin/src/hooks/useRolesList/index.js": "import { useEffect, useReducer } from 'react';\nimport { request } from 'strapi-helper-plugin';\nimport { get } from 'lodash';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\nconst useRolesList = (shouldFetchData = true) => {\n  const [{ roles, isLoading }, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, shouldFetchData)\n  );\n\n  useEffect(() => {\n    if (shouldFetchData) {\n      fetchRolesList();\n    }\n  }, [shouldFetchData]);\n\n  const fetchRolesList = async () => {\n    try {\n      dispatch({\n        type: 'GET_DATA',\n      });\n\n      const { data } = await request('/admin/roles', { method: 'GET' });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        data,\n      });\n    } catch (err) {\n      const message = get(err, ['response', 'payload', 'message'], 'An error occured');\n\n      dispatch({\n        type: 'GET_DATA_ERROR',\n      });\n\n      if (message !== 'Forbidden') {\n        strapi.notification.toggle({\n          type: 'warning',\n          message,\n        });\n      }\n    }\n  };\n\n  return { roles, isLoading, getData: fetchRolesList };\n};\n\nexport default useRolesList;\n",
    "packages/strapi-admin/admin/src/hooks/useSettingsMenu/index.js": "import { useContext, useEffect, useReducer } from 'react';\nimport { useGlobalContext, hasPermissions, UserContext } from 'strapi-helper-plugin';\n\nimport reducer, { initialState } from './reducer';\nimport init from './init';\n\nconst useSettingsMenu = (noCheck = false) => {\n  const permissions = useContext(UserContext);\n  const { plugins } = useGlobalContext();\n\n  const [{ isLoading, menu }, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, plugins)\n  );\n\n  useEffect(() => {\n    const getData = async () => {\n      const checkPermissions = async (permissionsToCheck, path) => {\n        const hasPermission = await hasPermissions(permissions, permissionsToCheck);\n\n        return { hasPermission, path };\n      };\n\n      const generateArrayOfPromises = array => {\n        return array.reduce((acc, current, sectionIndex) => {\n          const generateArrayOfPromises = array =>\n            array.map((link, index) =>\n              checkPermissions(array[index].permissions, `${sectionIndex}.links.${index}`)\n            );\n\n          return [...acc, ...generateArrayOfPromises(current.links)];\n        }, []);\n      };\n\n      const generalSectionLinksArrayOfPromises = generateArrayOfPromises(menu);\n\n      const data = await Promise.all(generalSectionLinksArrayOfPromises);\n\n      dispatch({\n        type: 'CHECK_PERMISSIONS_SUCCEEDED',\n        data,\n      });\n    };\n\n    // This hook is also used by the main LeftMenu component in order to know which sections it needs to display/hide\n    // Therefore, we don't need to make the checking all the times when the hook is used.\n    if (!noCheck) {\n      getData();\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [permissions, noCheck]);\n\n  return { isLoading, menu };\n};\n\nexport default useSettingsMenu;\n",
    "packages/strapi-admin/admin/src/hooks/useUsersForm/index.js": "import { useEffect, useReducer } from 'react';\nimport { request } from 'strapi-helper-plugin';\nimport { get, has, omit } from 'lodash';\nimport { checkFormValidity, formatAPIErrors } from '../../utils';\nimport { initialState, reducer } from './reducer';\nimport init from './init';\n\nconst useUsersForm = (endPoint, schema, cbSuccess, fieldsToPick) => {\n  const [\n    { formErrors, initialData, isLoading, modifiedData, showHeaderButtonLoader, showHeaderLoader },\n    dispatch,\n  ] = useReducer(reducer, initialState, () => init(initialState, fieldsToPick));\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        const { data } = await request(endPoint, { method: 'GET' });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n          fieldsToPick,\n        });\n      } catch (err) {\n        console.error(err.response);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      }\n    };\n\n    if (endPoint) {\n      getData();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [endPoint]);\n\n  const handleCancel = () => {\n    dispatch({\n      type: 'ON_CANCEL',\n    });\n  };\n\n  const handleChange = ({ target: { name, value, type: inputType } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      inputType,\n      keys: name,\n      value,\n    });\n  };\n\n  const handleSubmit = async e => {\n    e.preventDefault();\n    const errors = await checkFormValidity(modifiedData, schema);\n\n    dispatch({\n      type: 'SET_ERRORS',\n      errors: errors || {},\n    });\n\n    if (!errors) {\n      try {\n        strapi.lockAppWithOverlay();\n\n        dispatch({\n          type: 'ON_SUBMIT',\n        });\n\n        const cleanedData = omit(modifiedData, ['confirmPassword', 'registrationToken']);\n\n        if (cleanedData.roles) {\n          cleanedData.roles = cleanedData.roles.map(role => role.id);\n        }\n\n        const { data } = await request(endPoint, {\n          method: 'PUT',\n          body: cleanedData,\n        });\n\n        cbSuccess(data);\n\n        dispatch({\n          type: 'ON_SUBMIT_SUCCEEDED',\n          data,\n        });\n\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: 'notification.success.saved' },\n        });\n      } catch (err) {\n        const data = get(err, 'response.payload', { data: {} });\n\n        if (has(data, 'data') && typeof data.data === 'string') {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: data.data,\n          });\n        } else {\n          strapi.notification.toggle({\n            type: 'warning',\n            message: data.message,\n          });\n        }\n\n        const apiErrors = formatAPIErrors(data);\n\n        dispatch({\n          type: 'SET_ERRORS',\n          errors: apiErrors,\n        });\n      } finally {\n        strapi.unlockApp();\n      }\n    }\n  };\n\n  return [\n    { formErrors, initialData, isLoading, modifiedData, showHeaderButtonLoader, showHeaderLoader },\n    dispatch,\n    { handleCancel, handleChange, handleSubmit },\n  ];\n};\n\nexport default useUsersForm;\n",
    "packages/strapi-admin/admin/src/utils/checkFormValidity.js": "import { getYupInnerErrors } from 'strapi-helper-plugin';\n\nconst checkFormValidity = async (data, schema) => {\n  let errors = null;\n\n  try {\n    await schema.validate(data, { abortEarly: false });\n  } catch (err) {\n    errors = getYupInnerErrors(err);\n  }\n\n  return errors;\n};\n\nexport default checkFormValidity;\n",
    "packages/strapi-admin/config/functions/bootstrap.js": "'use strict';\n\nconst adminActions = require('../admin-actions');\nconst adminConditions = require('../admin-conditions');\n\nconst registerPermissionActions = () => {\n  const { actionProvider } = strapi.admin.services.permission;\n  actionProvider.register(adminActions.actions);\n};\n\nconst registerAdminConditions = () => {\n  const { conditionProvider } = strapi.admin.services.permission;\n  conditionProvider.registerMany(adminConditions.conditions);\n};\n\nmodule.exports = async () => {\n  registerAdminConditions();\n  registerPermissionActions();\n  await strapi.admin.services.permission.cleanPermissionInDatabase();\n  await strapi.admin.services.permission.ensureBoundPermissionsInDatabase();\n  await strapi.admin.services.user.migrateUsers();\n  await strapi.admin.services.role.createRolesIfNoneExist();\n  await strapi.admin.services.role.resetSuperAdminPermissions();\n  await strapi.admin.services.role.displayWarningIfNoSuperAdmin();\n  await strapi.admin.services.user.displayWarningIfUsersDontHaveRole();\n\n  strapi.admin.destroy = () => {\n    strapi.admin.services.permission.conditionProvider.clear();\n    strapi.admin.services.permission.actionProvider.clear();\n  };\n};\n",
    "packages/strapi-admin/controllers/Webhooks.js": "'use strict';\n\nconst _ = require('lodash');\nconst { yup, formatYupErrors, webhook: webhookUtils } = require('strapi-utils');\n\nconst urlRegex = /^(?:([a-z0-9+.-]+):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9_]-*)*[a-z\\u00a1-\\uffff0-9_]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9_]-*)*[a-z\\u00a1-\\uffff0-9_]+)*\\.?)(?::\\d{2,5})?(?:[/?#]\\S*)?$/;\n\nconst webhookValidator = yup\n  .object({\n    name: yup.string().required(),\n    url: yup\n      .string()\n      .matches(urlRegex, 'url must be a valid URL')\n      .required(),\n    headers: yup.lazy(data => {\n      if (typeof data !== 'object') {\n        return yup.object().required();\n      }\n\n      return yup\n        .object(\n          _.mapValues(data, () => {\n            yup\n              .string()\n              .min(1)\n              .required();\n          })\n        )\n        .required();\n    }),\n    events: yup\n      .array()\n      .of(\n        yup\n          .string()\n          .oneOf(_.values(webhookUtils.webhookEvents))\n          .required()\n      )\n      .min(1)\n      .required(),\n  })\n  .noUnknown();\n\nconst updateWebhookValidator = webhookValidator.shape({\n  isEnabled: yup.boolean(),\n});\n\nmodule.exports = {\n  async listWebhooks(ctx) {\n    const webhooks = await strapi.webhookStore.findWebhooks();\n    ctx.send({ data: webhooks });\n  },\n\n  async getWebhook(ctx) {\n    const { id } = ctx.params;\n    const webhook = await strapi.webhookStore.findWebhook(id);\n\n    if (!webhook) {\n      return ctx.notFound('webhook.notFound');\n    }\n\n    ctx.send({ data: webhook });\n  },\n\n  async createWebhook(ctx) {\n    const { body } = ctx.request;\n\n    try {\n      await webhookValidator.validate(body, {\n        strict: true,\n        abortEarly: false,\n      });\n    } catch (error) {\n      return ctx.badRequest('ValidationError', {\n        errors: formatYupErrors(error),\n      });\n    }\n\n    const webhook = await strapi.webhookStore.createWebhook(body);\n\n    strapi.webhookRunner.add(webhook);\n\n    ctx.created({ data: webhook });\n  },\n\n  async updateWebhook(ctx) {\n    const { id } = ctx.params;\n    const { body } = ctx.request;\n\n    try {\n      await updateWebhookValidator.validate(body, {\n        strict: true,\n        abortEarly: false,\n      });\n    } catch (error) {\n      return ctx.badRequest('ValidationError', {\n        errors: formatYupErrors(error),\n      });\n    }\n\n    const webhook = await strapi.webhookStore.findWebhook(id);\n\n    if (!webhook) {\n      return ctx.notFound('webhook.notFound');\n    }\n\n    const updatedWebhook = await strapi.webhookStore.updateWebhook(id, {\n      ...webhook,\n      ...body,\n    });\n\n    if (!updatedWebhook) {\n      return ctx.notFound('webhook.notFound');\n    }\n\n    strapi.webhookRunner.update(updatedWebhook);\n\n    ctx.send({ data: updatedWebhook });\n  },\n\n  async deleteWebhook(ctx) {\n    const { id } = ctx.params;\n    const webhook = await strapi.webhookStore.findWebhook(id);\n\n    if (!webhook) {\n      return ctx.notFound('webhook.notFound');\n    }\n\n    await strapi.webhookStore.deleteWebhook(id);\n\n    strapi.webhookRunner.remove(webhook);\n\n    ctx.body = { data: webhook };\n  },\n\n  async deleteWebhooks(ctx) {\n    const { ids } = ctx.request.body;\n\n    if (!Array.isArray(ids) || ids.length === 0) {\n      return ctx.badRequest('ids must be an array of id');\n    }\n\n    for (const id of ids) {\n      const webhook = await strapi.webhookStore.findWebhook(id);\n\n      if (!webhook) continue;\n\n      await strapi.webhookStore.deleteWebhook(id);\n      strapi.webhookRunner.remove(webhook);\n    }\n\n    ctx.send({ data: ids });\n  },\n\n  async triggerWebhook(ctx) {\n    const { id } = ctx.params;\n\n    const webhook = await strapi.webhookStore.findWebhook(id);\n\n    const response = await strapi.webhookRunner.run(webhook, 'trigger-test', {});\n\n    ctx.body = { data: response };\n  },\n};\n",
    "packages/strapi-admin/controllers/admin.js": "'use strict';\n\nconst execa = require('execa');\nconst _ = require('lodash');\n\nconst PLUGIN_NAME_REGEX = /^[A-Za-z][A-Za-z0-9-_]+$/;\n\n/**\n * Validates a plugin name format\n */\nconst isValidPluginName = plugin => {\n  return _.isString(plugin) && !_.isEmpty(plugin) && PLUGIN_NAME_REGEX.test(plugin);\n};\n\n/**\n * A set of functions called \"actions\" for `Admin`\n */\n\nmodule.exports = {\n  async init() {\n    const uuid = strapi.config.get('uuid', false);\n    const hasAdmin = await strapi.admin.services.user.exists();\n\n    return { data: { uuid, hasAdmin } };\n  },\n\n  async information() {\n    const currentEnvironment = strapi.app.env;\n    const autoReload = strapi.config.get('autoReload', false);\n    const strapiVersion = strapi.config.get('info.strapi', null);\n    const nodeVersion = process.version;\n    const communityEdition = !strapi.EE;\n\n    return {\n      data: { currentEnvironment, autoReload, strapiVersion, nodeVersion, communityEdition },\n    };\n  },\n\n  async installPlugin(ctx) {\n    try {\n      const { plugin } = ctx.request.body;\n\n      if (!isValidPluginName(plugin)) {\n        return ctx.badRequest('Invalid plugin name');\n      }\n\n      strapi.reload.isWatching = false;\n\n      strapi.log.info(`Installing ${plugin}...`);\n      await execa('npm', ['run', 'strapi', '--', 'install', plugin]);\n\n      ctx.send({ ok: true });\n\n      strapi.reload();\n    } catch (err) {\n      strapi.log.error(err);\n      strapi.reload.isWatching = true;\n      ctx.badRequest(null, [{ messages: [{ id: 'An error occurred' }] }]);\n    }\n  },\n\n  async plugins(ctx) {\n    try {\n      const plugins = Object.keys(strapi.plugins).reduce((acc, key) => {\n        acc[key] = _.get(strapi.plugins, [key, 'package', 'strapi'], {\n          name: key,\n        });\n\n        return acc;\n      }, {});\n\n      ctx.send({ plugins });\n    } catch (err) {\n      strapi.log.error(err);\n      ctx.badRequest(null, [{ messages: [{ id: 'An error occurred' }] }]);\n    }\n  },\n\n  async uninstallPlugin(ctx) {\n    try {\n      const { plugin } = ctx.params;\n\n      if (!isValidPluginName(plugin)) {\n        return ctx.badRequest('Invalid plugin name');\n      }\n\n      strapi.reload.isWatching = false;\n\n      strapi.log.info(`Uninstalling ${plugin}...`);\n      await execa('npm', ['run', 'strapi', '--', 'uninstall', plugin, '-d']);\n\n      ctx.send({ ok: true });\n\n      strapi.reload();\n    } catch (err) {\n      strapi.log.error(err);\n      strapi.reload.isWatching = true;\n      ctx.badRequest(null, [{ messages: [{ id: 'An error occurred' }] }]);\n    }\n  },\n};\n",
    "packages/strapi-admin/controllers/authenticated-user.js": "'use strict';\n\nconst { validateProfileUpdateInput } = require('../validation/user');\n\nmodule.exports = {\n  async getMe(ctx) {\n    const userInfo = strapi.admin.services.user.sanitizeUser(ctx.state.user);\n\n    ctx.body = {\n      data: userInfo,\n    };\n  },\n\n  async updateMe(ctx) {\n    const input = ctx.request.body;\n\n    try {\n      await validateProfileUpdateInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const updatedUser = await strapi.admin.services.user.updateById(ctx.state.user.id, input);\n\n    ctx.body = {\n      data: strapi.admin.services.user.sanitizeUser(updatedUser),\n    };\n  },\n\n  async getOwnPermissions(ctx) {\n    const { findUserPermissions, sanitizePermission } = strapi.admin.services.permission;\n\n    const userPermissions = await findUserPermissions(ctx.state.user);\n\n    ctx.body = {\n      data: userPermissions.map(sanitizePermission),\n    };\n  },\n};\n",
    "packages/strapi-admin/controllers/authentication.js": "'use strict';\n\nconst passport = require('koa-passport');\nconst compose = require('koa-compose');\n\nconst {\n  validateRegistrationInput,\n  validateAdminRegistrationInput,\n  validateRegistrationInfoQuery,\n  validateForgotPasswordInput,\n  validateResetPasswordInput,\n} = require('../validation/authentication');\n\nmodule.exports = {\n  login: compose([\n    (ctx, next) => {\n      return passport.authenticate('local', { session: false }, (err, user, info) => {\n        if (err) {\n          return ctx.badImplementation();\n        }\n\n        if (!user) {\n          return ctx.badRequest(info.message);\n        }\n\n        ctx.state.user = user;\n        return next();\n      })(ctx, next);\n    },\n    ctx => {\n      const { user } = ctx.state;\n\n      ctx.body = {\n        data: {\n          token: strapi.admin.services.token.createJwtToken(user),\n          user: strapi.admin.services.user.sanitizeUser(ctx.state.user), // TODO: fetch more detailed info\n        },\n      };\n    },\n  ]),\n\n  renewToken(ctx) {\n    const { token } = ctx.request.body;\n\n    if (token === undefined) {\n      return ctx.badRequest('Missing token');\n    }\n\n    const { isValid, payload } = strapi.admin.services.token.decodeJwtToken(token);\n\n    if (!isValid) {\n      return ctx.badRequest('Invalid token');\n    }\n\n    ctx.body = {\n      data: {\n        token: strapi.admin.services.token.createJwtToken({ id: payload.id }),\n      },\n    };\n  },\n\n  async registrationInfo(ctx) {\n    try {\n      await validateRegistrationInfoQuery(ctx.request.query);\n    } catch (err) {\n      return ctx.badRequest('QueryError', err);\n    }\n\n    const { registrationToken } = ctx.request.query;\n\n    const registrationInfo = await strapi.admin.services.user.findRegistrationInfo(\n      registrationToken\n    );\n\n    if (!registrationInfo) {\n      return ctx.badRequest('Invalid registrationToken');\n    }\n\n    ctx.body = { data: registrationInfo };\n  },\n\n  async register(ctx) {\n    const input = ctx.request.body;\n\n    try {\n      await validateRegistrationInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const user = await strapi.admin.services.user.register(input);\n\n    ctx.body = {\n      data: {\n        token: strapi.admin.services.token.createJwtToken(user),\n        user: strapi.admin.services.user.sanitizeUser(user),\n      },\n    };\n  },\n\n  async registerAdmin(ctx) {\n    const input = ctx.request.body;\n\n    try {\n      await validateAdminRegistrationInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const hasAdmin = await strapi.admin.services.user.exists();\n\n    if (hasAdmin) {\n      return ctx.badRequest('You cannot register a new super admin');\n    }\n\n    const superAdminRole = await strapi.admin.services.role.getSuperAdmin();\n\n    if (!superAdminRole) {\n      throw new Error(\n        \"Cannot register the first admin because the super admin role doesn't exist.\"\n      );\n    }\n\n    const user = await strapi.admin.services.user.create({\n      ...input,\n      registrationToken: null,\n      isActive: true,\n      roles: superAdminRole ? [superAdminRole.id] : [],\n    });\n\n    await strapi.telemetry.send('didCreateFirstAdmin');\n\n    ctx.body = {\n      data: {\n        token: strapi.admin.services.token.createJwtToken(user),\n        user: strapi.admin.services.user.sanitizeUser(user),\n      },\n    };\n  },\n\n  async forgotPassword(ctx) {\n    const input = ctx.request.body;\n\n    try {\n      await validateForgotPasswordInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    strapi.admin.services.auth.forgotPassword(input);\n\n    ctx.status = 204;\n  },\n\n  async resetPassword(ctx) {\n    const input = ctx.request.body;\n\n    try {\n      await validateResetPasswordInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const user = await strapi.admin.services.auth.resetPassword(input);\n\n    ctx.body = {\n      data: {\n        token: strapi.admin.services.token.createJwtToken(user),\n        user: strapi.admin.services.user.sanitizeUser(user),\n      },\n    };\n  },\n};\n",
    "packages/strapi-admin/controllers/permission.js": "'use strict';\n\nconst { validateCheckPermissionsInput } = require('../validation/permission');\nconst { formatActionsBySections, formatConditions } = require('./formatters');\n\nmodule.exports = {\n  /**\n   * Check each permissions from `request.body.permissions` and returns an array of booleans\n   * @param {KoaContext} ctx - koa context\n   */\n  async check(ctx) {\n    const { body: input } = ctx.request;\n\n    try {\n      await validateCheckPermissionsInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const checkPermissions = strapi.admin.services.permission.engine.checkMany(\n      ctx.state.userAbility\n    );\n\n    ctx.body = {\n      data: checkPermissions(input.permissions),\n    };\n  },\n\n  /**\n   * Returns every permissions, in nested format\n   * @param {KoaContext} ctx - koa context\n   */\n  async getAll(ctx) {\n    const allActions = strapi.admin.services.permission.actionProvider.getAll();\n    const conditions = strapi.admin.services.permission.conditionProvider.getAll();\n\n    ctx.body = {\n      data: {\n        conditions: formatConditions(conditions),\n        sections: formatActionsBySections(allActions),\n      },\n    };\n  },\n};\n",
    "packages/strapi-admin/controllers/user.js": "'use strict';\n\nconst _ = require('lodash');\nconst {\n  validateUserCreationInput,\n  validateUserUpdateInput,\n  validateUsersDeleteInput,\n} = require('../validation/user');\n\nmodule.exports = {\n  async create(ctx) {\n    const { body } = ctx.request;\n\n    try {\n      await validateUserCreationInput(body);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const attributes = _.pick(body, ['firstname', 'lastname', 'email', 'roles']);\n\n    const userAlreadyExists = await strapi.admin.services.user.exists({\n      email: attributes.email,\n    });\n\n    if (userAlreadyExists) {\n      return ctx.badRequest('Email already taken');\n    }\n\n    const createdUser = await strapi.admin.services.user.create(attributes);\n\n    const userInfo = strapi.admin.services.user.sanitizeUser(createdUser);\n\n    // Send 201 created\n    ctx.created({ data: userInfo });\n  },\n\n  async find(ctx) {\n    const method = _.has(ctx.query, '_q') ? 'searchPage' : 'findPage';\n\n    const { results, pagination } = await strapi.admin.services.user[method](ctx.query);\n\n    ctx.body = {\n      data: {\n        results: results.map(strapi.admin.services.user.sanitizeUser),\n        pagination,\n      },\n    };\n  },\n\n  async findOne(ctx) {\n    const { id } = ctx.params;\n\n    const user = await strapi.admin.services.user.findOne({ id });\n\n    if (!user) {\n      return ctx.notFound('User does not exist');\n    }\n\n    ctx.body = {\n      data: strapi.admin.services.user.sanitizeUser(user),\n    };\n  },\n\n  async update(ctx) {\n    const { id } = ctx.params;\n    const { body: input } = ctx.request;\n\n    try {\n      await validateUserUpdateInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    if (_.has(input, 'email')) {\n      const uniqueEmailCheck = await strapi.admin.services.user.exists({\n        id_ne: id,\n        email: input.email,\n      });\n\n      if (uniqueEmailCheck) {\n        return ctx.badRequest('A user with this email address already exists');\n      }\n    }\n\n    const updatedUser = await strapi.admin.services.user.updateById(id, input);\n\n    if (!updatedUser) {\n      return ctx.notFound('User does not exist');\n    }\n\n    ctx.body = {\n      data: strapi.admin.services.user.sanitizeUser(updatedUser),\n    };\n  },\n\n  async deleteOne(ctx) {\n    const { id } = ctx.params;\n\n    const deletedUser = await strapi.admin.services.user.deleteById(id);\n\n    if (!deletedUser) {\n      return ctx.notFound('User not found');\n    }\n\n    return ctx.deleted({\n      data: strapi.admin.services.user.sanitizeUser(deletedUser),\n    });\n  },\n\n  /**\n   * Delete several users\n   * @param {KoaContext} ctx - koa context\n   */\n  async deleteMany(ctx) {\n    const { body } = ctx.request;\n    try {\n      await validateUsersDeleteInput(body);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const users = await strapi.admin.services.user.deleteByIds(body.ids);\n    const sanitizedUsers = users.map(strapi.admin.services.user.sanitizeUser);\n\n    return ctx.deleted({\n      data: sanitizedUsers,\n    });\n  },\n};\n",
    "packages/strapi-admin/ee/admin/containers/Roles/ListPage/index.js": "import React, { useEffect, useReducer, useRef, useState } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { Button } from '@buffetjs/core';\nimport { List, Header } from '@buffetjs/custom';\nimport { Plus } from '@buffetjs/icons';\nimport matchSorter from 'match-sorter';\nimport {\n  useGlobalContext,\n  useQuery,\n  ListButton,\n  PopUpWarning,\n  request,\n  useUserPermissions,\n  LoadingIndicatorPage,\n} from 'strapi-helper-plugin';\nimport { useIntl } from 'react-intl';\nimport adminPermissions from '../../../../../admin/src/permissions';\nimport PageTitle from '../../../../../admin/src/components/SettingsPageTitle';\nimport useSettingsHeaderSearchContext from '../../../../../admin/src/hooks/useSettingsHeaderSearchContext';\nimport { EmptyRole, RoleListWrapper } from '../../../../../admin/src/components/Roles';\nimport { useRolesList } from '../../../../../admin/src/hooks';\nimport RoleRow from './RoleRow';\nimport BaselineAlignment from './BaselineAlignment';\nimport reducer, { initialState } from './reducer';\n\nconst RoleListPage = () => {\n  const { settingsBaseURL } = useGlobalContext();\n  const [isWarningDeleteAllOpened, setIsWarningDeleteAllOpenend] = useState(false);\n  const { formatMessage } = useIntl();\n  const { push } = useHistory();\n  const [{ selectedRoles, showModalConfirmButtonLoading, shouldRefetchData }, dispath] = useReducer(\n    reducer,\n    initialState\n  );\n  const {\n    isLoading: isLoadingForPermissions,\n    allowedActions: { canCreate, canDelete, canRead, canUpdate },\n  } = useUserPermissions(adminPermissions.settings.roles);\n  const { getData, roles, isLoading } = useRolesList(false);\n  const getDataRef = useRef(getData);\n  const { toggleHeaderSearch } = useSettingsHeaderSearchContext();\n  const query = useQuery();\n  const _q = decodeURIComponent(query.get('_q') || '');\n  const results = matchSorter(roles, _q, { keys: ['name', 'description'] });\n\n  useEffect(() => {\n    // Show the search bar only if the user is allowed to read\n    if (canRead) {\n      toggleHeaderSearch({ id: 'Settings.permissions.menu.link.roles.label' });\n    }\n\n    return () => {\n      if (canRead) {\n        toggleHeaderSearch();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [canRead]);\n\n  useEffect(() => {\n    if (!isLoadingForPermissions && canRead) {\n      getDataRef.current();\n    }\n  }, [isLoadingForPermissions, canRead]);\n\n  const handleClosedModal = () => {\n    if (shouldRefetchData) {\n      getData();\n    }\n\n    // Empty the selected ids when the modal closes\n    dispath({\n      type: 'RESET_DATA_TO_DELETE',\n    });\n  };\n\n  const handleConfirmDeleteData = async () => {\n    try {\n      dispath({\n        type: 'ON_REMOVE_ROLES',\n      });\n      const filteredRoles = selectedRoles.filter(currentId => {\n        const currentRole = roles.find(role => role.id === currentId);\n\n        return currentRole.usersCount === 0;\n      });\n\n      if (selectedRoles.length !== filteredRoles.length) {\n        strapi.notification.toggle({\n          type: 'info',\n          message: { id: 'Roles.ListPage.notification.delete-all-not-allowed' },\n        });\n      }\n\n      if (filteredRoles.length) {\n        await request('/admin/roles/batch-delete', {\n          method: 'POST',\n          body: {\n            ids: filteredRoles,\n          },\n        });\n\n        // Empty the selectedRolesId and set the shouldRefetchData to true so the\n        // list is updated when closing the modal\n        dispath({\n          type: 'ON_REMOVE_ROLES_SUCCEEDED',\n        });\n      }\n    } catch (err) {\n      console.error(err);\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      handleToggleModal();\n    }\n  };\n\n  const handleDuplicateRole = id => {\n    push(`${settingsBaseURL}/roles/duplicate/${id}`);\n  };\n\n  const handleNewRoleClick = () => push(`${settingsBaseURL}/roles/new`);\n\n  const handleRemoveRole = roleId => {\n    dispath({\n      type: 'SET_ROLE_TO_DELETE',\n      id: roleId,\n    });\n\n    handleToggleModal();\n  };\n\n  const handleRoleToggle = roleId => {\n    dispath({\n      type: 'ON_SELECTION',\n      id: roleId,\n    });\n  };\n\n  const handleToggleModal = () => setIsWarningDeleteAllOpenend(prev => !prev);\n\n  /* eslint-disable indent */\n  const headerActions = canCreate\n    ? [\n        {\n          label: formatMessage({\n            id: 'Settings.roles.list.button.add',\n            defaultMessage: 'Add new role',\n          }),\n          onClick: handleNewRoleClick,\n          color: 'primary',\n          type: 'button',\n          icon: true,\n        },\n      ]\n    : [];\n  /* eslint-enable indent */\n\n  const resultsCount = results.length;\n\n  if (isLoadingForPermissions) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <>\n      <PageTitle name=\"Roles\" />\n      <Header\n        title={{\n          label: formatMessage({\n            id: 'Settings.roles.title',\n            defaultMessage: 'roles',\n          }),\n        }}\n        content={formatMessage({\n          id: 'Settings.roles.list.description',\n          defaultMessage: 'List of roles',\n        })}\n        actions={headerActions}\n        isLoading={isLoading}\n      />\n      <BaselineAlignment />\n      {canRead && (\n        <RoleListWrapper>\n          <List\n            title={formatMessage(\n              {\n                id: `Settings.roles.list.title${resultsCount > 1 ? '.plural' : '.singular'}`,\n                defaultMessage: `{number} ${resultsCount > 1 ? 'roles' : 'role'}`,\n              },\n              { number: resultsCount }\n            )}\n            isLoading={isLoading}\n            /* eslint-disable indent */\n            button={\n              canDelete\n                ? {\n                    color: 'delete',\n                    disabled: selectedRoles.length === 0,\n                    label: formatMessage({ id: 'app.utils.delete', defaultMessage: 'Delete' }),\n                    onClick: handleToggleModal,\n                    type: 'button',\n                  }\n                : null\n            }\n            /* eslint-enable indent */\n            items={results}\n            customRowComponent={role => (\n              <RoleRow\n                canCreate={canCreate}\n                canDelete={canDelete}\n                canUpdate={canUpdate}\n                selectedRoles={selectedRoles}\n                onRoleDuplicate={handleDuplicateRole}\n                onRoleRemove={handleRemoveRole}\n                onRoleToggle={handleRoleToggle}\n                role={role}\n              />\n            )}\n          />\n          {!resultsCount && !isLoading && <EmptyRole />}\n          {canCreate && (\n            <ListButton>\n              <Button\n                onClick={handleNewRoleClick}\n                icon={<Plus fill=\"#007eff\" width=\"11px\" height=\"11px\" />}\n                label={formatMessage({\n                  id: 'Settings.roles.list.button.add',\n                  defaultMessage: 'Add new role',\n                })}\n              />\n            </ListButton>\n          )}\n        </RoleListWrapper>\n      )}\n      <PopUpWarning\n        isOpen={isWarningDeleteAllOpened}\n        onClosed={handleClosedModal}\n        onConfirm={handleConfirmDeleteData}\n        toggleModal={handleToggleModal}\n        isConfirmButtonLoading={showModalConfirmButtonLoading}\n      />\n    </>\n  );\n};\n\nexport default RoleListPage;\n",
    "packages/strapi-admin/ee/controllers/role.js": "'use strict';\n\nconst { yup, formatYupErrors } = require('strapi-utils');\nconst {\n  validateRoleCreateInput,\n  validateRoleDeleteInput,\n  validateRolesDeleteInput,\n} = require('../validation/role');\nconst { validatedUpdatePermissionsInput } = require('../validation/permission');\nconst { SUPER_ADMIN_CODE } = require('../../services/constants');\n\nmodule.exports = {\n  /**\n   * Create a new role\n   * @param {KoaContext} ctx - koa context\n   */\n  async create(ctx) {\n    try {\n      await validateRoleCreateInput(ctx.request.body);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    let role = await strapi.admin.services.role.create(ctx.request.body);\n\n    const sanitizedRole = strapi.admin.services.role.sanitizeRole(role);\n    ctx.created({ data: sanitizedRole });\n  },\n\n  /**\n   * Delete a role\n   * @param {KoaContext} ctx - koa context\n   */\n  async deleteOne(ctx) {\n    const { id } = ctx.params;\n\n    try {\n      await validateRoleDeleteInput(id);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const roles = await strapi.admin.services.role.deleteByIds([id]);\n\n    const sanitizedRole = roles.map(strapi.admin.services.role.sanitizeRole)[0] || null;\n\n    return ctx.deleted({\n      data: sanitizedRole,\n    });\n  },\n\n  /**\n   * delete several roles\n   * @param {KoaContext} ctx - koa context\n   */\n  async deleteMany(ctx) {\n    const { body } = ctx.request;\n    try {\n      await validateRolesDeleteInput(body);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    const roles = await strapi.admin.services.role.deleteByIds(body.ids);\n    const sanitizedRoles = roles.map(strapi.admin.services.role.sanitizeRole);\n\n    return ctx.deleted({\n      data: sanitizedRoles,\n    });\n  },\n\n  /**\n   * Updates the permissions assigned to a role\n   * @param {KoaContext} ctx - koa context\n   */\n  async updatePermissions(ctx) {\n    const { id } = ctx.params;\n    const input = ctx.request.body;\n\n    const role = await strapi.admin.services.role.findOne({ id });\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    try {\n      if (role.code === SUPER_ADMIN_CODE) {\n        const err = new yup.ValidationError(\"Super admin permissions can't be edited.\");\n        throw formatYupErrors(err);\n      }\n      await validatedUpdatePermissionsInput(input);\n    } catch (err) {\n      return ctx.badRequest('ValidationError', err);\n    }\n\n    if (!role) {\n      return ctx.notFound('role.notFound');\n    }\n\n    const permissions = await strapi.admin.services.role.assignPermissions(\n      role.id,\n      input.permissions\n    );\n\n    ctx.body = {\n      data: permissions,\n    };\n  },\n};\n",
    "packages/strapi-admin/ee/validation/role.js": "'use strict';\n\nconst { yup, formatYupErrors, stringIncludes, stringEquals } = require('strapi-utils');\n\nconst handleReject = error => Promise.reject(formatYupErrors(error));\n\nconst roleCreateSchema = yup\n  .object()\n  .shape({\n    name: yup\n      .string()\n      .min(1)\n      .required(),\n    description: yup.string().nullable(),\n  })\n  .noUnknown();\n\nconst rolesDeleteSchema = yup\n  .object()\n  .shape({\n    ids: yup\n      .array()\n      .of(yup.strapiID())\n      .min(1)\n      .required()\n      .test('no-admin-many-delete', 'You cannot delete the super admin role', async ids => {\n        const superAdminRole = await strapi.admin.services.role.getSuperAdmin();\n        return !superAdminRole || !stringIncludes(ids, superAdminRole.id);\n      }),\n  })\n  .noUnknown();\n\nconst roleDeleteSchema = yup\n  .strapiID()\n  .required()\n  .test('no-admin-single-delete', 'You cannot delete the super admin role', async function(id) {\n    const superAdminRole = await strapi.admin.services.role.getSuperAdmin();\n    return !superAdminRole || !stringEquals(id, superAdminRole.id)\n      ? true\n      : this.createError({ path: 'id', message: `You cannot delete the super admin role` });\n  });\n\nconst validateRoleCreateInput = async data => {\n  return roleCreateSchema.validate(data, { strict: true, abortEarly: false }).catch(handleReject);\n};\n\nconst validateRolesDeleteInput = async data => {\n  return rolesDeleteSchema.validate(data, { strict: true, abortEarly: false }).catch(handleReject);\n};\n\nconst validateRoleDeleteInput = async data => {\n  return roleDeleteSchema.validate(data, { strict: true, abortEarly: false }).catch(handleReject);\n};\n\nmodule.exports = {\n  validateRoleCreateInput,\n  validateRolesDeleteInput,\n  validateRoleDeleteInput,\n};\n",
    "packages/strapi-admin/middlewares/auth/index.js": "'use strict';\n\nconst passport = require('koa-passport');\nconst { Strategy: LocalStrategy } = require('passport-local');\n\nconst createLocalStrategy = strapi => {\n  return new LocalStrategy(\n    {\n      usernameField: 'email',\n      passwordField: 'password',\n      session: false,\n    },\n    function(email, password, done) {\n      return strapi.admin.services.auth\n        .checkCredentials({ email, password })\n        .then(([error, user, message]) => done(error, user, message))\n        .catch(error => done(error));\n    }\n  );\n};\n\nmodule.exports = strapi => ({\n  initialize() {\n    passport.use(createLocalStrategy(strapi));\n\n    strapi.app.use(passport.initialize());\n\n    strapi.app.use(async (ctx, next) => {\n      if (\n        ctx.request.header.authorization &&\n        ctx.request.header.authorization.split(' ')[0] === 'Bearer'\n      ) {\n        const token = ctx.request.header.authorization.split(' ')[1];\n\n        const { payload, isValid } = strapi.admin.services.token.decodeJwtToken(token);\n\n        if (isValid) {\n          // request is made by an admin\n          const admin = await strapi.query('user', 'admin').findOne({ id: payload.id }, ['roles']);\n\n          if (!admin || !(admin.isActive === true)) {\n            return ctx.forbidden('Invalid credentials');\n          }\n\n          ctx.state.admin = admin;\n          ctx.state.user = admin;\n          ctx.state.userAbility = await strapi.admin.services.permission.engine.generateUserAbility(\n            admin\n          );\n          ctx.state.isAuthenticatedAdmin = true;\n          return next();\n        }\n      }\n\n      return next();\n    });\n  },\n});\n",
    "packages/strapi-admin/services/__tests__/action-provider.test.js": "'use strict';\nconst _ = require('lodash');\nconst domain = require('../../domain/action');\nconst actionProviderService = require('../permission/action-provider');\n\ndescribe('Action Provider Service', () => {\n  beforeEach(() => {\n    global.strapi = {\n      plugins: { aPlugin: {} },\n    };\n  });\n\n  describe('settings', () => {\n    const readAction = {\n      uid: 'marketplace.read',\n      displayName: 'Can read',\n      pluginName: 'admin',\n      section: 'settings',\n      category: 'plugins and marketplace',\n      subCategory: 'marketplace',\n    };\n\n    const createAction = {\n      uid: 'marketplace.create',\n      displayName: 'Can create',\n      pluginName: 'admin',\n      section: 'settings',\n      category: 'plugins and marketplace',\n    };\n\n    test('Can register a settings action', async () => {\n      await actionProviderService.register([readAction]);\n      const createdAction = actionProviderService.get(readAction.uid, readAction.pluginName);\n\n      expect(createdAction).toMatchObject({\n        ..._.omit(readAction, ['uid']),\n        actionId: 'admin::marketplace.read',\n      });\n    });\n\n    test('Can register a settings action without subCategory', async () => {\n      await actionProviderService.register([createAction]);\n      const createdAction = actionProviderService.get(createAction.uid, createAction.pluginName);\n\n      expect(createdAction).toMatchObject({\n        ..._.omit(createAction, ['uid']),\n        actionId: 'admin::marketplace.create',\n        subCategory: 'general',\n      });\n    });\n\n    test('Can get all registered entries (array)', () => {\n      expect(actionProviderService.getAll()).toHaveLength(2);\n    });\n\n    test('Can get all registered entries (map)', () => {\n      expect(actionProviderService.getAllByMap().size).toBe(2);\n    });\n\n    test('Can get an action by its actionId', () => {\n      const actionId = 'admin::marketplace.create';\n      const expected = domain.createAction(createAction);\n      expect(actionProviderService.getByActionId(actionId)).toStrictEqual(expected);\n    });\n\n    test('Can register a settings action with a pluginName other than \"admin\"', async () => {\n      const action = {\n        uid: 'marketplace.update',\n        displayName: 'Can update',\n        pluginName: 'aPlugin',\n        section: 'settings',\n        category: 'plugins and marketplace',\n      };\n\n      await actionProviderService.register([action]);\n      const createdAction = actionProviderService.get(action.uid, action.pluginName);\n\n      expect(createdAction).toMatchObject({\n        ..._.omit(action, ['uid']),\n        actionId: 'plugins::aPlugin.marketplace.update',\n      });\n    });\n\n    test('Cannot register a settings action with a non standard name', async () => {\n      const action = {\n        uid: 'Marketplace Read',\n        displayName: 'Access the marketplace',\n        pluginName: 'aPlugin',\n        section: 'settings',\n        category: 'plugins and marketplace',\n      };\n\n      expect(() => actionProviderService.register([action])).toThrow(\n        '[0].uid: The id can only contain lowercase letters, dots and hyphens.'\n      );\n    });\n\n    test('Cannot register actions with same actionId', async () => {\n      global.strapi.stopWithError = jest.fn(() => {});\n\n      const action1 = {\n        uid: 'marketplace.delete',\n        displayName: 'Can delete',\n        pluginName: 'aPlugin',\n        section: 'settings',\n        category: 'plugins and marketplace',\n      };\n\n      const action2 = {\n        uid: action1.uid,\n        displayName: 'delete',\n        pluginName: 'aPlugin',\n        section: 'plugins',\n      };\n\n      expect(() => actionProviderService.register([action1, action2])).toThrow(\n        'Duplicated action id: plugins::aPlugin.marketplace.delete. You may want to change the actions name.'\n      );\n    });\n\n    test(\"Cannot register a settings action with a pluginName that doesn't exist\", async () => {\n      const action = {\n        uid: 'marketplace.read',\n        displayName: 'Access the marketplace',\n        pluginName: 'plugin-name-that-doesnt-exist',\n        section: 'settings',\n        category: 'plugins and marketplace',\n      };\n\n      expect(() => actionProviderService.register([action])).toThrow(\n        '[0].pluginName is not an existing plugin'\n      );\n    });\n\n    test('Cannot register a settings action without category', async () => {\n      const action = {\n        uid: 'marketplace.read',\n        displayName: 'Access the marketplace',\n        pluginName: 'admin',\n        section: 'settings',\n      };\n\n      expect(() => actionProviderService.register([action])).toThrow(\n        '[0].category is a required field'\n      );\n    });\n\n    test('Cannot register an action outside of the bootstrap function', async () => {\n      global.strapi = {\n        isLoaded: true,\n      };\n\n      expect(() => actionProviderService.register([])).toThrow(\n        `You can't register new actions outside of the bootstrap function.`\n      );\n    });\n  });\n});\n",
    "packages/strapi-admin/services/__tests__/auth.test.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst {\n  validatePassword,\n  hashPassword,\n  checkCredentials,\n  forgotPassword,\n  resetPassword,\n} = require('../auth');\n\ndescribe('Auth', () => {\n  describe('checkCredentials', () => {\n    test('Fails on not found user, without leaking not found info', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n\n      const input = { email: 'test@strapi.io', password: 'pcw123' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'Invalid credentials' }]);\n    });\n\n    test('Fails when password is invalid, without leaking specific info', async () => {\n      const user = {\n        id: 1,\n        firstname: '',\n        lastname: '',\n        email: 'test@strapi.io',\n        password: await hashPassword('test-password'),\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n\n      const input = { email: 'test@strapi.io', password: 'wrong-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'Invalid credentials' }]);\n    });\n\n    test.each([false, null, 1, 0])('Fails when user is not active (%s)', async isActive => {\n      const user = {\n        id: 1,\n        firstname: '',\n        lastname: '',\n        email: 'test@strapi.io',\n        isActive,\n        password: await hashPassword('test-password'),\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, false, { message: 'User not active' }]);\n    });\n\n    test('Returns user when all checks pass', async () => {\n      const user = {\n        id: 1,\n        firstname: '',\n        lastname: '',\n        email: 'test@strapi.io',\n        isActive: true,\n        password: await hashPassword('test-password'),\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n\n      const input = { email: 'test@strapi.io', password: 'test-password' };\n      const res = await checkCredentials(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email });\n      expect(res).toEqual([null, user]);\n    });\n  });\n\n  describe('validatePassword', () => {\n    test('Compares password with hash', async () => {\n      const password = 'pcw123';\n      const hash = await hashPassword(password);\n\n      const isValid = await validatePassword(password, hash);\n      expect(isValid).toBe(true);\n    });\n  });\n\n  describe('forgotPassword', () => {\n    test('Only run the process for active users', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n\n      const input = { email: 'test@strapi.io' };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalledWith({ email: input.email, isActive: true });\n    });\n\n    test('Will return silently in case the user is not found', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n      const send = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n        plugins: {\n          email: {\n            services: {\n              email: { send },\n            },\n          },\n        },\n      };\n\n      const input = { email: 'test@strapi.io' };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(send).not.toHaveBeenCalled();\n    });\n\n    test('Will assign a new reset token', async () => {\n      const user = {\n        id: 1,\n        email: 'test@strapi.io',\n      };\n      const resetPasswordToken = '123';\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const send = jest.fn(() => Promise.resolve());\n      const updateById = jest.fn(() => Promise.resolve());\n      const createToken = jest.fn(() => resetPasswordToken);\n\n      const config = {\n        server: {\n          host: '0.0.0.0',\n        },\n        admin: { url: '/admin' },\n      };\n\n      global.strapi = {\n        config: {\n          ...config,\n          get(path, def) {\n            return _.get(path, def);\n          },\n        },\n        query() {\n          return { findOne };\n        },\n        admin: { services: { user: { updateById }, token: { createToken } } },\n        plugins: { email: { services: { email: { send, sendTemplatedEmail: send } } } },\n      };\n\n      const input = { email: user.email };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled();\n      expect(updateById).toHaveBeenCalledWith(user.id, { resetPasswordToken });\n    });\n\n    test('Will call the send service', async () => {\n      const user = {\n        id: 1,\n        email: 'test@strapi.io',\n      };\n      const resetPasswordToken = '123';\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const send = jest.fn(() => Promise.resolve());\n      const sendTemplatedEmail = jest.fn(() => Promise.resolve());\n      const updateById = jest.fn(() => Promise.resolve());\n      const createToken = jest.fn(() => resetPasswordToken);\n\n      const config = {\n        server: {\n          host: '0.0.0.0',\n          admin: { url: '/admin', forgotPassword: { emailTemplate: {} } },\n        },\n      };\n\n      global.strapi = {\n        config: {\n          ...config,\n          get(path, def) {\n            return _.get(path, def);\n          },\n        },\n        query() {\n          return { findOne };\n        },\n        admin: {\n          services: {\n            user: { updateById },\n            token: { createToken },\n          },\n        },\n        plugins: { email: { services: { email: { send, sendTemplatedEmail } } } },\n      };\n\n      const input = { email: user.email };\n      await forgotPassword(input);\n\n      expect(findOne).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled();\n      expect(sendTemplatedEmail).toHaveBeenCalled();\n    });\n  });\n\n  describe('resetPassword', () => {\n    test('Check user is active', async () => {\n      const resetPasswordToken = '123';\n      const findOne = jest.fn(() => Promise.resolve());\n      const badRequest = jest.fn(() => {});\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n        errors: { badRequest },\n      };\n\n      expect.assertions(2);\n      return resetPassword({ resetPasswordToken, password: 'Test1234' }).catch(() => {\n        expect(findOne).toHaveBeenCalledWith({ resetPasswordToken, isActive: true });\n        expect(badRequest).toHaveBeenCalled();\n      });\n    });\n\n    test('Fails if user is not found', async () => {\n      const resetPasswordToken = '123';\n      const findOne = jest.fn(() => Promise.resolve());\n      const badRequest = jest.fn(() => {});\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n        errors: { badRequest },\n      };\n\n      expect.assertions(1);\n      return resetPassword({ resetPasswordToken, password: 'Test1234' }).catch(() => {\n        expect(badRequest).toHaveBeenCalled();\n      });\n    });\n\n    test('Changes password and clear reset token', async () => {\n      const resetPasswordToken = '123';\n      const user = { id: 1 };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const updateById = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n        admin: { services: { user: { updateById } } },\n      };\n\n      const input = { resetPasswordToken, password: 'Test1234' };\n      await resetPassword(input);\n\n      expect(updateById).toHaveBeenCalledWith(user.id, {\n        password: input.password,\n        resetPasswordToken: null,\n      });\n    });\n  });\n});\n",
    "packages/strapi-admin/services/__tests__/permission.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst permissionService = require('../permission');\n\ndescribe('Permission Service', () => {\n  describe('Find permissions', () => {\n    test('Find calls the right db query', async () => {\n      const find = jest.fn(() => Promise.resolve([]));\n      global.strapi = {\n        query() {\n          return { find };\n        },\n      };\n\n      await permissionService.find({ role: 1 });\n\n      expect(find).toHaveBeenCalledWith({ role: 1 }, []);\n    });\n  });\n\n  describe('Find User Permissions', () => {\n    test('Find calls the right db query', async () => {\n      const find = jest.fn(({ role_in }) => role_in);\n\n      global.strapi = {\n        query() {\n          return { find };\n        },\n      };\n\n      const rolesId = [1, 2];\n\n      const res = await permissionService.findUserPermissions({\n        roles: rolesId.map(id => ({ id })),\n      });\n\n      expect(find).toHaveBeenCalledWith({ role_in: rolesId, _limit: -1 });\n      expect(res).toStrictEqual(rolesId);\n    });\n\n    test('Returns default result when no roles provided', async () => {\n      const res = await permissionService.findUserPermissions({});\n\n      expect(res).toStrictEqual([]);\n    });\n  });\n\n  describe('Sanitize Permission', () => {\n    test('Removes unwanted properties', () => {\n      const removeUnkownConditionIds = jest.fn(() => ['cond']);\n      global.strapi = {\n        admin: { services: { condition: { removeUnkownConditionIds } } },\n      };\n      const permission = {\n        action: 'read',\n        subject: 'article',\n        fields: ['*'],\n        conditions: ['cond', 'unknown-cond'],\n        foo: 'bar',\n      };\n\n      const sanitizedPermission = permissionService.sanitizePermission(permission);\n\n      expect(sanitizedPermission.foo).toBeUndefined();\n      expect(sanitizedPermission).toMatchObject({\n        ..._.omit(permission, 'foo'),\n        conditions: ['cond'],\n      });\n    });\n  });\n\n  describe('cleanPermissionInDatabase', () => {\n    test('Remove permission that dont exist + clean fields', async () => {\n      const permsInDb = [\n        {\n          id: 1,\n          action: 'action-1',\n          fields: ['name'],\n        },\n        {\n          id: 2,\n          action: 'action-2',\n          fields: ['name'],\n        },\n        {\n          id: 3,\n          action: 'action-3',\n          subject: 'country',\n          fields: ['name'],\n        },\n        {\n          id: 4,\n          action: 'action-3',\n          subject: 'planet',\n          fields: ['name'],\n        },\n        {\n          id: 5,\n          action: 'action-1',\n          subject: 'planet',\n          fields: ['name', 'description'],\n        },\n        {\n          id: 6,\n          action: 'action-1',\n          subject: 'country',\n          fields: null,\n        },\n      ];\n\n      const permsWithCleanFields = [\n        permsInDb[0],\n        permsInDb[2],\n        { ...permsInDb[4], fields: ['name', 'galaxy'] },\n        { ...permsInDb[5], fields: ['name'] },\n      ];\n\n      const findPage = jest.fn(() =>\n        Promise.resolve({\n          results: permsInDb,\n          pagination: { total: 4 },\n        })\n      );\n      const cleanPermissionFields = jest.fn(() => permsWithCleanFields);\n      const dbDelete = jest.fn(() => Promise.resolve());\n      const update = jest.fn(() => Promise.resolve());\n      const registeredPerms = new Map();\n      registeredPerms.set('action-1', {});\n      registeredPerms.set('action-3', { subjects: ['country'] });\n      const getAllByMap = jest.fn(() => registeredPerms);\n      const prevGetAllByMap = permissionService.actionProvider.getAllByMap;\n      permissionService.actionProvider.getAllByMap = getAllByMap;\n\n      global.strapi = {\n        query: () => ({ findPage, delete: dbDelete, update }),\n        admin: { services: { 'content-type': { cleanPermissionFields } } },\n      };\n\n      await permissionService.cleanPermissionInDatabase();\n\n      expect(findPage).toHaveBeenCalledWith({ page: 1, pageSize: 200 }, []);\n      expect(update).toHaveBeenNthCalledWith(1, { id: permsInDb[4].id }, permsWithCleanFields[2]);\n      expect(update).toHaveBeenNthCalledWith(2, { id: permsInDb[5].id }, permsWithCleanFields[3]);\n      expect(getAllByMap).toHaveBeenCalledWith();\n      expect(dbDelete).toHaveBeenCalledWith({ id_in: [2, 4] });\n\n      // restauring actionProvider\n      permissionService.actionProvider.getAllByMap = prevGetAllByMap;\n    });\n  });\n});\n",
    "packages/strapi-admin/services/__tests__/user.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst userService = require('../user');\nconst { SUPER_ADMIN_CODE } = require('../constants');\n\ndescribe('User', () => {\n  describe('sanitizeUser', () => {\n    test('Removes password and resetPasswordToken', () => {\n      const res = userService.sanitizeUser({\n        id: 1,\n        firstname: 'Test',\n        otherField: 'Hello',\n        password: '$5IAZUDB871',\n        resetPasswordToken: '3456-5678-6789-789',\n        roles: [],\n      });\n\n      expect(res).toEqual({\n        id: 1,\n        firstname: 'Test',\n        otherField: 'Hello',\n        roles: [],\n      });\n    });\n  });\n\n  describe('create', () => {\n    const count = jest.fn(() => Promise.resolve(1));\n    const sendDidInviteUser = jest.fn();\n\n    test('Creates a user by merging given and default attributes', async () => {\n      const create = jest.fn(user => Promise.resolve(user));\n      const createToken = jest.fn(() => 'token');\n      const hashPassword = jest.fn(() => Promise.resolve('123456789'));\n\n      global.strapi = {\n        admin: {\n          services: {\n            token: { createToken },\n            auth: { hashPassword },\n            role: { count },\n            metrics: { sendDidInviteUser },\n          },\n        },\n        query() {\n          return { create, count };\n        },\n      };\n\n      const input = { firstname: 'Kai', lastname: 'Doe', email: 'kaidoe@email.com' };\n      const expected = { ...input, isActive: false, roles: [], registrationToken: 'token' };\n\n      const result = await userService.create(input);\n\n      expect(create).toHaveBeenCalled();\n      expect(createToken).toHaveBeenCalled();\n      expect(result).toMatchObject(expected);\n    });\n\n    test('Creates a user and hash password if provided', async () => {\n      const create = jest.fn(user => Promise.resolve(user));\n      const createToken = jest.fn(() => 'token');\n      const hashPassword = jest.fn(() => Promise.resolve('123456789'));\n\n      global.strapi = {\n        admin: {\n          services: {\n            token: { createToken },\n            auth: { hashPassword },\n            role: { count },\n            metrics: { sendDidInviteUser },\n          },\n        },\n        query() {\n          return { create, count };\n        },\n      };\n\n      const input = {\n        firstname: 'Kai',\n        lastname: 'Doe',\n        email: 'kaidoe@email.com',\n        password: 'Pcw123',\n      };\n      const expected = {\n        ...input,\n        password: expect.any(String),\n        isActive: false,\n        roles: [],\n        registrationToken: 'token',\n      };\n\n      const result = await userService.create(input);\n\n      expect(create).toHaveBeenCalled();\n      expect(hashPassword).toHaveBeenCalledWith(input.password);\n      expect(createToken).toHaveBeenCalled();\n      expect(result).toMatchObject(expected);\n      expect(result.password !== input.password).toBe(true);\n    });\n\n    test('Creates a user by using given attributes', async () => {\n      const create = jest.fn(user => Promise.resolve(user));\n      const createToken = jest.fn(() => 'token');\n      const hashPassword = jest.fn(() => Promise.resolve('123456789'));\n\n      global.strapi = {\n        admin: {\n          services: {\n            token: { createToken },\n            auth: { hashPassword },\n            role: { count },\n            metrics: { sendDidInviteUser },\n          },\n        },\n        query() {\n          return { create, count };\n        },\n      };\n\n      const input = {\n        firstname: 'Kai',\n        lastname: 'Doe',\n        email: 'kaidoe@email.com',\n        roles: [2],\n        isActive: true,\n        registrationToken: 'another-token',\n      };\n      const expected = _.clone(input);\n      const result = await userService.create(input);\n\n      expect(result).toMatchObject(expected);\n    });\n  });\n\n  describe('Count users', () => {\n    test('Count users without params', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      global.strapi = {\n        query: () => ({ count }),\n      };\n\n      const amount = await userService.count();\n\n      expect(amount).toBe(2);\n      expect(count).toHaveBeenCalledWith({});\n    });\n\n    test('Count users with params', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      global.strapi = {\n        query: () => ({ count }),\n      };\n\n      const params = { foo: 'bar' };\n      const amount = await userService.count(params);\n\n      expect(amount).toBe(2);\n      expect(count).toHaveBeenCalledWith(params);\n    });\n  });\n\n  describe('update', () => {\n    test('Hash password', async () => {\n      const hash = 'aoizdnoaizndoainzodiaz';\n\n      const id = 1;\n      const input = { email: 'test@strapi.io', password: '123' };\n\n      const findOne = jest.fn((_, user) => Promise.resolve(user));\n      const update = jest.fn((_, user) => Promise.resolve(user));\n      const hashPassword = jest.fn(() => Promise.resolve(hash));\n\n      global.strapi = {\n        query() {\n          return { update, findOne };\n        },\n        admin: {\n          services: {\n            auth: { hashPassword },\n          },\n        },\n      };\n\n      const result = await userService.updateById(id, input);\n\n      expect(hashPassword).toHaveBeenCalledWith(input.password);\n      expect(update).toHaveBeenCalledWith({ id }, { email: input.email, password: hash });\n      expect(result).toEqual({\n        email: 'test@strapi.io',\n        password: 'aoizdnoaizndoainzodiaz',\n      });\n    });\n\n    test('Forwards call to the query layer', async () => {\n      const user = {\n        email: 'test@strapi.io',\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const update = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return { update, findOne };\n        },\n      };\n      const id = 1;\n      const input = { email: 'test@strapi.io' };\n      const result = await userService.updateById(id, input);\n\n      expect(update).toHaveBeenCalledWith({ id }, input);\n      expect(result).toBe(user);\n    });\n  });\n\n  describe('updateById', () => {\n    test('Cannot delete last super admin', async () => {\n      const findOne = jest.fn(() =>\n        Promise.resolve({ id: 11, roles: [{ code: SUPER_ADMIN_CODE }] })\n      );\n      const getSuperAdminWithUsersCount = jest.fn(() => Promise.resolve({ id: 1, usersCount: 1 }));\n      const badRequest = jest.fn();\n      global.strapi = {\n        query: () => ({ findOne }),\n        admin: { services: { role: { getSuperAdminWithUsersCount } } },\n        errors: { badRequest },\n      };\n      try {\n        await userService.deleteById(2);\n      } catch (e) {\n        //nothing\n      }\n\n      expect(badRequest).toHaveBeenCalledWith(\n        'ValidationError',\n        'You must have at least one user with super admin role.'\n      );\n    });\n    test('Can delete a super admin if he/she is not the last one', async () => {\n      const user = { id: 2, roles: [{ code: SUPER_ADMIN_CODE }] };\n      const findOne = jest.fn(() => Promise.resolve(user));\n      const getSuperAdminWithUsersCount = jest.fn(() => Promise.resolve({ id: 1, usersCount: 2 }));\n      const deleteFn = jest.fn(() => user);\n      global.strapi = {\n        query: () => ({ findOne, delete: deleteFn }),\n        admin: { services: { role: { getSuperAdminWithUsersCount } } },\n      };\n\n      const res = await userService.deleteById(user.id);\n      expect(deleteFn).toHaveBeenCalledWith({ id: user.id });\n      expect(res).toEqual(user);\n    });\n  });\n\n  describe('deleteByIds', () => {\n    test('Cannot delete last super admin', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      const getSuperAdminWithUsersCount = jest.fn(() => Promise.resolve({ id: 1, usersCount: 2 }));\n      const badRequest = jest.fn();\n      global.strapi = {\n        query: () => ({ count }),\n        admin: { services: { role: { getSuperAdminWithUsersCount } } },\n        errors: { badRequest },\n      };\n\n      try {\n        await userService.deleteByIds([2, 3]);\n      } catch (e) {\n        // nothing\n      }\n\n      expect(badRequest).toHaveBeenCalledWith(\n        'ValidationError',\n        'You must have at least one user with super admin role.'\n      );\n    });\n\n    test('Can delete a super admin if he/she is not the last one', async () => {\n      const users = [\n        { id: 2, roles: [{ code: SUPER_ADMIN_CODE }] },\n        { id: 3, roles: [{ code: SUPER_ADMIN_CODE }] },\n      ];\n      const count = jest.fn(() => Promise.resolve(users.length));\n      const getSuperAdminWithUsersCount = jest.fn(() => Promise.resolve({ id: 1, usersCount: 3 }));\n      const deleteFn = jest.fn(() => users);\n      global.strapi = {\n        query: () => ({ count, delete: deleteFn }),\n        admin: { services: { role: { getSuperAdminWithUsersCount } } },\n      };\n\n      const res = await userService.deleteByIds([2, 3]);\n      expect(deleteFn).toHaveBeenCalledWith({ id_in: [2, 3] });\n      expect(res).toEqual(users);\n    });\n  });\n\n  describe('exists', () => {\n    test('Return true if the user already exists', async () => {\n      const count = jest.fn(() => Promise.resolve(1));\n\n      global.strapi = {\n        query: () => {\n          return { count };\n        },\n      };\n\n      const result = await userService.exists();\n\n      expect(result).toBeTruthy();\n    });\n\n    test('Return false if the user does not exists', async () => {\n      const count = jest.fn(() => Promise.resolve(0));\n\n      global.strapi = {\n        query: () => {\n          return { count };\n        },\n      };\n\n      const result = await userService.exists();\n\n      expect(result).toBeFalsy();\n    });\n  });\n\n  describe('Fetch users (paginated)', () => {\n    const defaults = { page: 1, pageSize: 100 };\n\n    beforeEach(() => {\n      const fetchPage = jest.fn(({ page = defaults.page, pageSize = defaults.pageSize } = {}) => {\n        return {\n          results: Array.from({ length: pageSize }).map((_, i) => i + (page - 1) * pageSize),\n          pagination: { page, pageSize, total: page * pageSize, pageCount: page },\n        };\n      });\n\n      global.strapi = {\n        query() {\n          return { findPage: fetchPage, searchPage: fetchPage };\n        },\n      };\n    });\n\n    test('Fetch users with custom pagination', async () => {\n      const pagination = { page: 2, pageSize: 15 };\n      const foundPage = await userService.findPage(pagination);\n      const searchedPage = await userService.searchPage(pagination);\n\n      expect(foundPage.results.length).toBe(15);\n      expect(foundPage.results[0]).toBe(15);\n      expect((foundPage.pagination.total = 30));\n\n      expect(searchedPage.results.length).toBe(15);\n      expect(searchedPage.results[0]).toBe(15);\n      expect((searchedPage.pagination.total = 30));\n    });\n\n    test('Fetch users with default pagination', async () => {\n      const foundPage = await userService.findPage();\n      const searchedPage = await userService.searchPage();\n\n      expect(foundPage.results.length).toBe(100);\n      expect(foundPage.results[0]).toBe(0);\n      expect((foundPage.pagination.total = 100));\n\n      expect(searchedPage.results.length).toBe(100);\n      expect(searchedPage.results[0]).toBe(0);\n      expect((searchedPage.pagination.total = 100));\n    });\n\n    test('Fetch users with partial pagination', async () => {\n      const pagination = { page: 2 };\n      const foundPage = await userService.findPage(pagination);\n      const searchedPage = await userService.searchPage(pagination);\n\n      expect(foundPage.results.length).toBe(100);\n      expect(foundPage.results[0]).toBe(100);\n      expect((foundPage.pagination.total = 200));\n\n      expect(searchedPage.results.length).toBe(100);\n      expect(searchedPage.results[0]).toBe(100);\n      expect((searchedPage.pagination.total = 200));\n    });\n  });\n\n  describe('Fetch user', () => {\n    const user = { firstname: 'Kai', lastname: 'Doe', email: 'kaidoe@email.com' };\n\n    beforeEach(() => {\n      const findOne = jest.fn(({ id }) =>\n        Promise.resolve(\n          {\n            1: user,\n          }[id] || null\n        )\n      );\n\n      global.strapi = {\n        query() {\n          return { findOne };\n        },\n      };\n    });\n\n    test('Finds and returns a user by its ID', async () => {\n      const input = { id: 1 };\n      const res = await userService.findOne(input);\n\n      expect(res).not.toBeNull();\n      expect(res).toMatchObject(user);\n    });\n\n    test('Fails to find a user with provided params', async () => {\n      const input = { id: 27 };\n      const res = await userService.findOne(input);\n\n      expect(res).toBeNull();\n    });\n  });\n\n  describe('findRegistrationInfo', () => {\n    test('Returns undefined if not found', async () => {\n      const findOne = jest.fn(() => Promise.resolve());\n\n      global.strapi = {\n        query: () => {\n          return { findOne };\n        },\n      };\n\n      const res = await userService.findRegistrationInfo('ABCD');\n      expect(res).toBeUndefined();\n      expect(findOne).toHaveBeenCalledWith({ registrationToken: 'ABCD' });\n    });\n\n    test('Returns correct user registration info', async () => {\n      const user = {\n        email: 'test@strapi.io',\n        firstname: 'Test',\n        lastname: 'Strapi',\n        otherField: 'ignored',\n      };\n\n      const findOne = jest.fn(() => Promise.resolve(user));\n\n      global.strapi = {\n        query: () => {\n          return { findOne };\n        },\n      };\n\n      const res = await userService.findRegistrationInfo('ABCD');\n\n      expect(res).toEqual({\n        email: user.email,\n        firstname: user.firstname,\n        lastname: user.lastname,\n      });\n    });\n  });\n\n  describe('register', () => {\n    test('Fails if no matching user is found', async () => {\n      const findOne = jest.fn(() => Promise.resolve(undefined));\n\n      global.strapi = {\n        query() {\n          return {\n            findOne,\n          };\n        },\n        errors: {\n          badRequest(msg) {\n            throw new Error(msg);\n          },\n        },\n      };\n\n      const input = {\n        registrationToken: '123',\n        userInfo: {\n          firstname: 'test',\n          lastname: 'Strapi',\n          password: 'Test1234',\n        },\n      };\n\n      expect(userService.register(input)).rejects.toThrowError('Invalid registration info');\n    });\n\n    test('Calls udpate service', async () => {\n      const findOne = jest.fn(() => Promise.resolve({ id: 1 }));\n      const updateById = jest.fn(user => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return {\n            findOne,\n          };\n        },\n        admin: {\n          services: {\n            user: { updateById },\n          },\n        },\n      };\n\n      const input = {\n        registrationToken: '123',\n        userInfo: {\n          firstname: 'test',\n          lastname: 'Strapi',\n          password: 'Test1234',\n        },\n      };\n\n      await userService.register(input);\n\n      expect(updateById).toHaveBeenCalledWith(\n        1,\n        expect.objectContaining({ firstname: 'test', lastname: 'Strapi', password: 'Test1234' })\n      );\n    });\n\n    test('Set user to active', async () => {\n      const findOne = jest.fn(() => Promise.resolve({ id: 1 }));\n      const updateById = jest.fn(user => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return {\n            findOne,\n          };\n        },\n        admin: {\n          services: {\n            user: { updateById },\n          },\n        },\n      };\n\n      const input = {\n        registrationToken: '123',\n        userInfo: {\n          firstname: 'test',\n          lastname: 'Strapi',\n          password: 'Test1234',\n        },\n      };\n\n      await userService.register(input);\n\n      expect(updateById).toHaveBeenCalledWith(1, expect.objectContaining({ isActive: true }));\n    });\n\n    test('Reset registrationToken', async () => {\n      const findOne = jest.fn(() => Promise.resolve({ id: 1 }));\n      const updateById = jest.fn(user => Promise.resolve(user));\n\n      global.strapi = {\n        query() {\n          return {\n            findOne,\n          };\n        },\n        admin: {\n          services: {\n            user: { updateById },\n          },\n        },\n      };\n\n      const input = {\n        registrationToken: '123',\n        userInfo: {\n          firstname: 'test',\n          lastname: 'Strapi',\n          password: 'Test1234',\n        },\n      };\n\n      await userService.register(input);\n\n      expect(updateById).toHaveBeenCalledWith(\n        1,\n        expect.objectContaining({ registrationToken: null })\n      );\n    });\n  });\n\n  describe('Assign a role to all', () => {\n    test('mongoose', async () => {\n      const updateMany = jest.fn();\n\n      global.strapi = {\n        query: () => ({\n          model: {\n            orm: 'mongoose',\n            updateMany,\n          },\n        }),\n      };\n\n      await userService.assignARoleToAll(3);\n\n      expect(updateMany).toHaveBeenCalledWith({}, { roles: [3] });\n    });\n\n    test('bookshelf', async () => {\n      const knexFunctions = {};\n      const select = jest.fn(() => knexFunctions);\n      const from = jest.fn(() => knexFunctions);\n      const leftJoin = jest.fn(() => knexFunctions);\n      const where = jest.fn(() => knexFunctions);\n      const pluck = jest.fn(() => [1, 2]);\n      Object.assign(knexFunctions, { select, from, leftJoin, where, pluck });\n      const into = jest.fn();\n      const insert = jest.fn(() => ({ into }));\n\n      global.strapi = {\n        connections: {\n          default: {\n            select,\n            insert,\n          },\n        },\n        query: () => ({\n          model: {\n            orm: 'bookshelf',\n            connection: 'default',\n            associations: [{ alias: 'roles', tableCollectionName: 'strapi_users_roles' }],\n            collectionName: 'strapi_administrators',\n          },\n        }),\n      };\n\n      await userService.assignARoleToAll(3);\n\n      expect(select).toHaveBeenCalledWith('strapi_administrators.id');\n      expect(from).toHaveBeenCalledWith('strapi_administrators');\n      expect(leftJoin).toHaveBeenCalledWith(\n        'strapi_users_roles',\n        'strapi_administrators.id',\n        'strapi_users_roles.user_id'\n      );\n      expect(where).toHaveBeenCalledWith('strapi_users_roles.role_id', null);\n      expect(pluck).toHaveBeenCalledWith('strapi_administrators.id');\n      expect(insert).toHaveBeenCalledWith([\n        { role_id: 3, user_id: 1 },\n        { role_id: 3, user_id: 2 },\n      ]);\n      expect(into).toHaveBeenCalledWith('strapi_users_roles');\n    });\n  });\n\n  describe('displayWarningIfUsersDontHaveRole', () => {\n    test('All users have at least one role', async () => {\n      const count = jest.fn(() => Promise.resolve(0));\n      const warn = jest.fn();\n\n      global.strapi = {\n        query: () => ({ model: { orm: 'bookshelf' }, count }),\n        log: { warn },\n      };\n\n      await userService.displayWarningIfUsersDontHaveRole();\n\n      expect(warn).toHaveBeenCalledTimes(0);\n    });\n    test('2 users have 0 roles', async () => {\n      const count = jest.fn(() => Promise.resolve(2));\n      const warn = jest.fn();\n\n      global.strapi = {\n        query: () => ({ model: { orm: 'bookshelf' }, count }),\n        log: { warn },\n      };\n\n      await userService.displayWarningIfUsersDontHaveRole();\n\n      expect(warn).toHaveBeenCalledWith(\"Some users (2) don't have any role.\");\n    });\n  });\n\n  describe('migrateUsers', () => {\n    test(\"Don't do anything if the migration has already been done\", async () => {\n      const updateMany = jest.fn();\n      const exists = jest.fn(() => Promise.resolve(true));\n\n      global.strapi = {\n        query: () => ({ model: { orm: 'mongoose' } }),\n        admin: { services: { role: { exists } } },\n      };\n\n      await userService.migrateUsers();\n\n      expect(updateMany).toHaveBeenCalledTimes(0);\n    });\n    test('Migrate for mongoose', async () => {\n      const updateMany = jest.fn();\n      const exists = jest.fn(() => Promise.resolve(false));\n\n      global.strapi = {\n        query: () => ({ model: { orm: 'mongoose', updateMany } }),\n        admin: { services: { role: { exists } } },\n      };\n\n      await userService.migrateUsers();\n\n      expect(updateMany).toHaveBeenCalledTimes(2);\n      expect(updateMany).toHaveBeenNthCalledWith(\n        1,\n        { blocked: { $in: [false, null] } },\n        { isActive: true }\n      );\n      expect(updateMany).toHaveBeenNthCalledWith(2, { blocked: true }, { isActive: false });\n    });\n    test('Migrate for bookshelf', async () => {\n      const query = jest.fn(() => ({ save }));\n      const save = jest.fn(() => Promise.resolve());\n      const exists = jest.fn(() => Promise.resolve(false));\n\n      global.strapi = {\n        query: () => ({ model: { orm: 'bookshelf', query } }),\n        admin: { services: { role: { exists } } },\n      };\n\n      await userService.migrateUsers();\n\n      expect(query).toHaveBeenCalledTimes(2);\n      expect(save).toHaveBeenCalledTimes(2);\n      expect(save).toHaveBeenNthCalledWith(\n        1,\n        { isActive: true },\n        { method: 'update', patch: true, require: false }\n      );\n      expect(save).toHaveBeenNthCalledWith(\n        2,\n        { isActive: false },\n        { method: 'update', patch: true, require: false }\n      );\n    });\n  });\n\n  describe('resetPasswordByEmail', () => {\n    test('Throws on missing user', async () => {\n      const email = 'email@email.fr';\n      const password = 'invalidpass';\n\n      const findOne = jest.fn(() => {\n        return null;\n      });\n\n      global.strapi = {\n        query() {\n          return {\n            findOne,\n          };\n        },\n      };\n\n      await expect(userService.resetPasswordByEmail(email, password)).rejects.toEqual(\n        new Error(`User not found for email: ${email}`)\n      );\n\n      expect(findOne).toHaveBeenCalledWith({ email }, undefined);\n    });\n\n    test.each(['abc', 'Abcd', 'Abcdefgh', 'Abcd123'])(\n      'Throws on invalid password',\n      async password => {\n        const email = 'email@email.fr';\n\n        const findOne = jest.fn(() => ({ id: 1 }));\n\n        global.strapi = {\n          query() {\n            return {\n              findOne,\n            };\n          },\n        };\n\n        await expect(userService.resetPasswordByEmail(email, password)).rejects.toEqual(\n          new Error(\n            'Invalid password. Expected a minimum of 8 characters with at least one number and one uppercase letter'\n          )\n        );\n\n        expect(findOne).toHaveBeenCalledWith({ email }, undefined);\n      }\n    );\n  });\n\n  test('Call the update function with the expected params', async () => {\n    const email = 'email@email.fr';\n    const password = 'Testing1234';\n    const hash = 'hash';\n    const userId = 1;\n\n    const findOne = jest.fn(() => ({ id: userId }));\n    const update = jest.fn();\n    const hashPassword = jest.fn(() => hash);\n\n    global.strapi = {\n      query() {\n        return {\n          findOne,\n          update,\n        };\n      },\n      admin: {\n        services: {\n          auth: {\n            hashPassword,\n          },\n        },\n      },\n    };\n\n    await userService.resetPasswordByEmail(email, password);\n    expect(findOne).toHaveBeenCalledWith({ email }, undefined);\n    expect(update).toHaveBeenCalledWith({ id: userId }, { password: hash });\n    expect(hashPassword).toHaveBeenCalledWith(password);\n  });\n});\n",
    "packages/strapi-admin/services/auth.js": "'use strict';\n\nconst bcrypt = require('bcryptjs');\nconst _ = require('lodash');\nconst { getAbsoluteAdminUrl } = require('strapi-utils');\n\n/**\n * hashes a password\n * @param {string} password - password to hash\n * @returns {string} hashed password\n */\nconst hashPassword = password => bcrypt.hash(password, 10);\n\n/**\n * Validate a password\n * @param {string} password\n * @param {string} hash\n * @returns {boolean} is the password valid\n */\nconst validatePassword = (password, hash) => bcrypt.compare(password, hash);\n\n/**\n * Check login credentials\n * @param {Object} options\n * @param {string} options.email\n * @param {string} options.password\n */\nconst checkCredentials = async ({ email, password }) => {\n  const user = await strapi.query('user', 'admin').findOne({ email });\n\n  if (!user || !user.password) {\n    return [null, false, { message: 'Invalid credentials' }];\n  }\n\n  const isValid = await validatePassword(password, user.password);\n\n  if (!isValid) {\n    return [null, false, { message: 'Invalid credentials' }];\n  }\n\n  if (!(user.isActive === true)) {\n    return [null, false, { message: 'User not active' }];\n  }\n\n  return [null, user];\n};\n\n/**\n * Send an email to the user if it exists or do nothing\n * @param {Object} param params\n * @param {string} param.email user email for which to reset the password\n */\nconst forgotPassword = async ({ email } = {}) => {\n  const user = await strapi.query('user', 'admin').findOne({ email, isActive: true });\n\n  if (!user) {\n    return;\n  }\n\n  const resetPasswordToken = strapi.admin.services.token.createToken();\n  await strapi.admin.services.user.updateById(user.id, { resetPasswordToken });\n\n  // Send an email to the admin.\n  const url = `${getAbsoluteAdminUrl(\n    strapi.config\n  )}/auth/reset-password?code=${resetPasswordToken}`;\n  return strapi.plugins.email.services.email\n    .sendTemplatedEmail(\n      {\n        to: user.email,\n        from: strapi.config.get('server.admin.forgotPassword.from'),\n        replyTo: strapi.config.get('server.admin.forgotPassword.replyTo'),\n      },\n      strapi.config.get('server.admin.forgotPassword.emailTemplate'),\n      {\n        url,\n        user: _.pick(user, ['email', 'firstname', 'lastname', 'username']),\n      }\n    )\n    .catch(err => {\n      // log error server side but do not disclose it to the user to avoid leaking informations\n      strapi.log.error(err);\n    });\n};\n\n/**\n * Reset a user password\n * @param {Object} param params\n * @param {string} param.resetPasswordToken token generated to request a password reset\n * @param {string} param.password new user password\n */\nconst resetPassword = async ({ resetPasswordToken, password } = {}) => {\n  const matchingUser = await strapi\n    .query('user', 'admin')\n    .findOne({ resetPasswordToken, isActive: true });\n\n  if (!matchingUser) {\n    throw strapi.errors.badRequest();\n  }\n\n  return strapi.admin.services.user.updateById(matchingUser.id, {\n    password,\n    resetPasswordToken: null,\n  });\n};\n\nmodule.exports = {\n  checkCredentials,\n  validatePassword,\n  hashPassword,\n  forgotPassword,\n  resetPassword,\n};\n",
    "packages/strapi-admin/services/metrics.js": "'use strict';\n\nconst sendDidInviteUser = async () => {\n  const numberOfUsers = await strapi.admin.services.user.count();\n  const numberOfRoles = await strapi.admin.services.role.count();\n  return strapi.telemetry.send('didInviteUser', { numberOfRoles, numberOfUsers });\n};\n\nconst sendDidUpdateRolePermissions = async () => {\n  return strapi.telemetry.send('didUpdateRolePermissions');\n};\n\nmodule.exports = {\n  sendDidInviteUser,\n  sendDidUpdateRolePermissions,\n};\n",
    "packages/strapi-admin/services/permission.js": "'use strict';\n\nconst _ = require('lodash');\nconst { flatMap, filter } = require('lodash/fp');\nconst pmap = require('p-map');\nconst { getBoundActionsBySubject, BOUND_ACTIONS_FOR_FIELDS } = require('../domain/role');\nconst { createPermission } = require('../domain/permission');\nconst createPermissionsManager = require('./permission/permissions-manager');\nconst createConditionProvider = require('./permission/condition-provider');\nconst createPermissionEngine = require('./permission/engine');\nconst actionProvider = require('./permission/action-provider');\nconst { EDITOR_CODE } = require('./constants');\n\nconst conditionProvider = createConditionProvider();\nconst engine = createPermissionEngine(conditionProvider);\n\n/**\n * Removes unwanted fields from a permission\n * @param perm\n * @returns {*}\n */\nconst sanitizePermission = perm => ({\n  ..._.pick(perm, ['id', 'action', 'subject', 'fields']),\n  conditions: strapi.admin.services.condition.removeUnkownConditionIds(perm.conditions),\n});\n\n/**\n * Delete permissions of roles in database\n * @param rolesIds ids of roles\n * @returns {Promise<array>}\n */\nconst deleteByRolesIds = rolesIds => {\n  return strapi.query('permission', 'admin').delete({ role_in: rolesIds });\n};\n\n/**\n * Delete permissions\n * @param ids ids of permissions\n * @returns {Promise<array>}\n */\nconst deleteByIds = ids => {\n  return strapi.query('permission', 'admin').delete({ id_in: ids });\n};\n\n/**\n * Create many permissions\n * @param permissions\n * @returns {Promise<*[]|*>}\n */\nconst createMany = async permissions => {\n  return strapi.query('permission', 'admin').createMany(permissions);\n};\n\n/**\n * Update a permission\n * @returns {Promise<*[]|*>}\n * @param params\n * @param attributes\n */\nconst update = async (params, attributes) => {\n  return strapi.query('permission', 'admin').update(params, attributes);\n};\n\n/**\n * Find assigned permissions in the database\n * @param params query params to find the permissions\n * @returns {Promise<array<Object>>}\n */\nconst find = (params = {}) => {\n  return strapi.query('permission', 'admin').find(params, []);\n};\n\n/**\n * Find all permissions for a user\n * @param roles\n * @returns {Promise<*[]|*>}\n */\nconst findUserPermissions = async ({ roles }) => {\n  if (!_.isArray(roles)) {\n    return [];\n  }\n\n  return strapi\n    .query('permission', 'admin')\n    .find({ role_in: roles.map(_.property('id')), _limit: -1 });\n};\n\n/**\n * Removes permissions in database that don't exist anymore\n * @returns {Promise<>}\n */\nconst cleanPermissionInDatabase = async () => {\n  const pageSize = 200;\n  let page = 0;\n  let total = 1;\n\n  while (page * pageSize < total) {\n    // First, delete permission that don't exist anymore\n    page += 1;\n    const res = await strapi.query('permission', 'admin').findPage({ page, pageSize }, []);\n    total = res.pagination.total;\n\n    const dbPermissions = res.results;\n    const allActionsMap = actionProvider.getAllByMap();\n    const permissionsToRemoveIds = dbPermissions.reduce((idsToDelete, perm) => {\n      if (\n        !allActionsMap.has(perm.action) ||\n        (Array.isArray(allActionsMap.get(perm.action).subjects) &&\n          !allActionsMap.get(perm.action).subjects.includes(perm.subject))\n      ) {\n        idsToDelete.push(perm.id);\n      }\n      return idsToDelete;\n    }, []);\n\n    const deletePromise = deleteByIds(permissionsToRemoveIds);\n\n    // Second, clean fields of permissions (add required ones, remove the non-existing anymore ones)\n    const permissionsInDb = dbPermissions.filter(perm => !permissionsToRemoveIds.includes(perm.id));\n    const permissionsWithCleanFields = strapi.admin.services['content-type'].cleanPermissionFields(\n      permissionsInDb\n    );\n\n    // Update only the ones that need to be updated\n    const permissionsNeedingToBeUpdated = _.differenceWith(\n      permissionsWithCleanFields,\n      permissionsInDb,\n      (a, b) => a.id === b.id && _.xor(a.fields, b.fields).length === 0\n    );\n    const promiseProvider = perm => update({ id: perm.id }, perm);\n\n    //Update the database\n    await Promise.all([\n      deletePromise,\n      pmap(permissionsNeedingToBeUpdated, promiseProvider, {\n        concurrency: 100,\n        stopOnError: true,\n      }),\n    ]);\n  }\n};\n\nconst ensureBoundPermissionsInDatabase = async () => {\n  if (strapi.EE) {\n    return;\n  }\n\n  const contentTypes = Object.values(strapi.contentTypes);\n  const editorRole = await strapi.query('role', 'admin').findOne({ code: EDITOR_CODE }, []);\n\n  if (_.isNil(editorRole)) {\n    return;\n  }\n\n  for (const contentType of contentTypes) {\n    const boundActions = getBoundActionsBySubject(editorRole, contentType.uid);\n    const permissions = await strapi.query('permission', 'admin').find(\n      {\n        subject: contentType.uid,\n        action_in: boundActions,\n        role: editorRole.id,\n      },\n      []\n    );\n\n    if (permissions.length === 0) {\n      return;\n    }\n\n    const fields = _.flow(flatMap('fields'), filter(_.negate(_.isNil)), _.uniq)(permissions);\n\n    // Handle the scenario where permissions are missing\n\n    const missingActions = _.difference(boundActions, _.map(permissions, 'action'));\n\n    if (missingActions.length > 0) {\n      const permissions = missingActions.map(action =>\n        createPermission({\n          action,\n          subject: contentType.uid,\n          role: editorRole.id,\n          fields: BOUND_ACTIONS_FOR_FIELDS.includes(action) ? fields : null,\n        })\n      );\n\n      await createMany(permissions);\n    }\n  }\n};\n\nmodule.exports = {\n  createMany,\n  find,\n  deleteByRolesIds,\n  deleteByIds,\n  sanitizePermission,\n  findUserPermissions,\n  actionProvider,\n  createPermissionsManager,\n  engine,\n  conditionProvider,\n  cleanPermissionInDatabase,\n  ensureBoundPermissionsInDatabase,\n};\n",
    "packages/strapi-admin/services/user.js": "'use strict';\n\nconst _ = require('lodash');\nconst { stringIncludes } = require('strapi-utils');\nconst { createUser, hasSuperAdminRole } = require('../domain/user');\nconst { password: passwordValidator } = require('../validation/common-validators');\nconst { SUPER_ADMIN_CODE } = require('./constants');\n\nconst sanitizeUserRoles = role => _.pick(role, ['id', 'name', 'description', 'code']);\n\n/**\n * Remove private user fields\n * @param {Object} user - user to sanitize\n */\nconst sanitizeUser = user => {\n  return {\n    ..._.omit(user, ['password', 'resetPasswordToken', 'roles']),\n    roles: user.roles && user.roles.map(sanitizeUserRoles),\n  };\n};\n\n/**\n * Create and save a user in database\n * @param attributes A partial user object\n * @returns {Promise<user>}\n */\nconst create = async attributes => {\n  const userInfo = {\n    registrationToken: strapi.admin.services.token.createToken(),\n    ...attributes,\n  };\n\n  if (_.has(attributes, 'password')) {\n    userInfo.password = await strapi.admin.services.auth.hashPassword(attributes.password);\n  }\n\n  const user = createUser(userInfo);\n  const createdUser = await strapi.query('user', 'admin').create(user);\n\n  await strapi.admin.services.metrics.sendDidInviteUser();\n\n  return createdUser;\n};\n\n/**\n * Update a user in database\n * @param id query params to find the user to update\n * @param attributes A partial user object\n * @returns {Promise<user>}\n */\nconst updateById = async (id, attributes) => {\n  // Check at least one super admin remains\n  if (_.has(attributes, 'roles')) {\n    const lastAdminUser = await isLastSuperAdminUser(id);\n    const superAdminRole = await strapi.admin.services.role.getSuperAdminWithUsersCount();\n    const willRemoveSuperAdminRole = !stringIncludes(attributes.roles, superAdminRole.id);\n\n    if (lastAdminUser && willRemoveSuperAdminRole) {\n      throw strapi.errors.badRequest(\n        'ValidationError',\n        'You must have at least one user with super admin role.'\n      );\n    }\n  }\n\n  // cannot disable last super admin\n  if (attributes.isActive === false) {\n    const lastAdminUser = await isLastSuperAdminUser(id);\n    if (lastAdminUser) {\n      throw strapi.errors.badRequest(\n        'ValidationError',\n        'You must have at least one active user with super admin role.'\n      );\n    }\n  }\n\n  // hash password if a new one is sent\n  if (_.has(attributes, 'password')) {\n    const hashedPassword = await strapi.admin.services.auth.hashPassword(attributes.password);\n\n    return strapi.query('user', 'admin').update(\n      { id },\n      {\n        ...attributes,\n        password: hashedPassword,\n      }\n    );\n  }\n\n  return strapi.query('user', 'admin').update({ id }, attributes);\n};\n\n/**\n * Reset a user password by email. (Used in admin:reset CLI)\n * @param {string} email - user email\n * @param {string} password - new password\n */\nconst resetPasswordByEmail = async (email, password) => {\n  const user = await findOne({ email });\n\n  if (!user) {\n    throw new Error(`User not found for email: ${email}`);\n  }\n\n  try {\n    await passwordValidator.validate(password);\n  } catch (error) {\n    throw new Error(\n      'Invalid password. Expected a minimum of 8 characters with at least one number and one uppercase letter'\n    );\n  }\n\n  await updateById(user.id, { password });\n};\n\n/**\n * Check if a user is the last super admin\n * @param {int|string} userId user's id to look for\n */\nconst isLastSuperAdminUser = async userId => {\n  const user = await findOne({ id: userId }, ['roles']);\n  const superAdminRole = await strapi.admin.services.role.getSuperAdminWithUsersCount();\n\n  return superAdminRole.usersCount === 1 && hasSuperAdminRole(user);\n};\n\n/**\n * Check if a user with specific attributes exists in the database\n * @param attributes A partial user object\n * @returns {Promise<boolean>}\n */\nconst exists = async (attributes = {}) => {\n  return (await strapi.query('user', 'admin').count(attributes)) > 0;\n};\n\n/**\n * Returns a user registration info\n * @param {string} registrationToken - a user registration token\n * @returns {Promise<registrationInfo>} - Returns user email, firstname and lastname\n */\nconst findRegistrationInfo = async registrationToken => {\n  const user = await strapi.query('user', 'admin').findOne({ registrationToken });\n\n  if (!user) {\n    return undefined;\n  }\n\n  return _.pick(user, ['email', 'firstname', 'lastname']);\n};\n\n/**\n * Registers a user based on a registrationToken and some informations to update\n * @param {Object} params\n * @param {Object} params.registrationToken registration token\n * @param {Object} params.userInfo user info\n */\nconst register = async ({ registrationToken, userInfo }) => {\n  const matchingUser = await strapi.query('user', 'admin').findOne({ registrationToken });\n\n  if (!matchingUser) {\n    throw strapi.errors.badRequest('Invalid registration info');\n  }\n\n  return strapi.admin.services.user.updateById(matchingUser.id, {\n    password: userInfo.password,\n    firstname: userInfo.firstname,\n    lastname: userInfo.lastname,\n    registrationToken: null,\n    isActive: true,\n  });\n};\n\n/**\n * Find one user\n */\nconst findOne = async (params, populate) => {\n  return strapi.query('user', 'admin').findOne(params, populate);\n};\n\n/** Find many users (paginated)\n * @param query\n * @returns {Promise<user>}\n */\nconst findPage = async query => {\n  return strapi.query('user', 'admin').findPage(query);\n};\n\n/** Search for many users (paginated)\n * @param query\n * @returns {Promise<user>}\n */\nconst searchPage = async query => {\n  return strapi.query('user', 'admin').searchPage(query);\n};\n\n/** Delete a user\n * @param id id of the user to delete\n * @returns {Promise<user>}\n */\nconst deleteById = async id => {\n  // Check at least one super admin remains\n  const userToDelete = await strapi.query('user', 'admin').findOne({ id }, ['roles']);\n  if (userToDelete) {\n    if (userToDelete.roles.some(r => r.code === SUPER_ADMIN_CODE)) {\n      const superAdminRole = await strapi.admin.services.role.getSuperAdminWithUsersCount();\n      if (superAdminRole.usersCount === 1) {\n        throw strapi.errors.badRequest(\n          'ValidationError',\n          'You must have at least one user with super admin role.'\n        );\n      }\n    }\n  } else {\n    return null;\n  }\n\n  return strapi.query('user', 'admin').delete({ id });\n};\n\n/** Delete a user\n * @param ids ids of the users to delete\n * @returns {Promise<user>}\n */\nconst deleteByIds = async ids => {\n  // Check at least one super admin remains\n  const superAdminRole = await strapi.admin.services.role.getSuperAdminWithUsersCount();\n  const nbOfSuperAdminToDelete = await strapi\n    .query('user', 'admin')\n    .count({ id_in: ids, roles: [superAdminRole.id] });\n  if (superAdminRole.usersCount === nbOfSuperAdminToDelete) {\n    throw strapi.errors.badRequest(\n      'ValidationError',\n      'You must have at least one user with super admin role.'\n    );\n  }\n\n  return strapi.query('user', 'admin').delete({ id_in: ids });\n};\n\n/** Count the users that don't have any associated roles\n * @returns {Promise<number>}\n */\nconst countUsersWithoutRole = async () => {\n  const userModel = strapi.query('user', 'admin').model;\n  let count;\n\n  if (userModel.orm === 'bookshelf') {\n    count = await strapi.query('user', 'admin').count({ roles_null: true });\n  } else if (userModel.orm === 'mongoose') {\n    count = await strapi.query('user', 'admin').model.countDocuments({\n      $or: [{ roles: { $exists: false } }, { roles: { $size: 0 } }],\n    });\n  } else {\n    const allRoles = await strapi.query('role', 'admin').find({ _limit: -1 });\n    count = await strapi.query('user', 'admin').count({\n      roles_nin: allRoles.map(r => r.id),\n    });\n  }\n\n  return count;\n};\n\n/**\n * Count the number of users based on search params\n * @param params params used for the query\n * @returns {Promise<number>}\n */\nconst count = async (params = {}) => {\n  return strapi.query('user', 'admin').count(params);\n};\n\n/** Assign some roles to several users\n * @returns {undefined}\n */\nconst assignARoleToAll = async roleId => {\n  const userModel = strapi.query('user', 'admin').model;\n\n  if (userModel.orm === 'bookshelf') {\n    const assocTable = userModel.associations.find(a => a.alias === 'roles').tableCollectionName;\n    const userTable = userModel.collectionName;\n    const knex = strapi.connections[userModel.connection];\n    const usersIds = await knex\n      .select(`${userTable}.id`)\n      .from(userTable)\n      .leftJoin(assocTable, `${userTable}.id`, `${assocTable}.user_id`)\n      .where(`${assocTable}.role_id`, null)\n      .pluck(`${userTable}.id`);\n\n    if (usersIds.length > 0) {\n      const newRelations = usersIds.map(userId => ({ user_id: userId, role_id: roleId }));\n      await knex.insert(newRelations).into(assocTable);\n    }\n  } else if (userModel.orm === 'mongoose') {\n    await strapi.query('user', 'admin').model.updateMany({}, { roles: [roleId] });\n  }\n};\n\n/** Display a warning if some users don't have at least one role\n * @returns {Promise<>}\n */\nconst displayWarningIfUsersDontHaveRole = async () => {\n  const count = await countUsersWithoutRole();\n\n  if (count > 0) {\n    strapi.log.warn(`Some users (${count}) don't have any role.`);\n  }\n};\n\nconst migrateUsers = async () => {\n  const someRolesExist = await strapi.admin.services.role.exists();\n  if (someRolesExist) {\n    return;\n  }\n\n  const userModel = strapi.query('user', 'admin').model;\n\n  if (userModel.orm === 'bookshelf') {\n    await userModel\n      .query(qb => qb.where('blocked', false).orWhere('blocked', null))\n      .save({ isActive: true }, { method: 'update', patch: true, require: false });\n    await userModel\n      .query(qb => qb.where('blocked', true))\n      .save({ isActive: false }, { method: 'update', patch: true, require: false });\n  } else if (userModel.orm === 'mongoose') {\n    await userModel.updateMany({ blocked: { $in: [false, null] } }, { isActive: true });\n    await userModel.updateMany({ blocked: true }, { isActive: false });\n  }\n};\n\nmodule.exports = {\n  create,\n  updateById,\n  exists,\n  findRegistrationInfo,\n  register,\n  sanitizeUser,\n  findOne,\n  findPage,\n  searchPage,\n  deleteById,\n  deleteByIds,\n  countUsersWithoutRole,\n  count,\n  assignARoleToAll,\n  displayWarningIfUsersDontHaveRole,\n  migrateUsers,\n  resetPasswordByEmail,\n};\n",
    "packages/strapi-admin/tests/admin-auth.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createStrapiInstance, superAdmin } = require('../../../test/helpers/strapi');\nconst { createUtils } = require('../../../test/helpers/utils');\n\nconst edition = process.env.STRAPI_DISABLE_EE === 'true' ? 'CE' : 'EE';\n\nlet internals = {\n  role: null,\n};\n\ndescribe('Admin Auth End to End', () => {\n  let rq;\n  let strapi;\n  let utils;\n\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    utils = createUtils(strapi);\n\n    if (edition === 'EE') {\n      internals.role = await utils.createRole({\n        name: 'auth_test_role',\n        description: 'Only used for auth crud test (e2e)',\n      });\n    } else {\n      internals.role = await utils.getSuperAdminRole();\n    }\n  }, 60000);\n\n  afterAll(async () => {\n    if (edition === 'EE') {\n      await utils.deleteRolesById([internals.role.id]);\n    }\n\n    await strapi.destroy();\n  }, 60000);\n\n  describe('Login', () => {\n    test('Can connect successfully', async () => {\n      const res = await rq({\n        url: '/admin/login',\n        method: 'POST',\n        body: superAdmin.loginInfo,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toMatchObject({\n        token: expect.any(String),\n        user: {\n          firstname: expect.stringOrNull(),\n          lastname: expect.stringOrNull(),\n          username: expect.stringOrNull(),\n          email: expect.any(String),\n          isActive: expect.any(Boolean),\n        },\n      });\n    });\n\n    test('Fails on invalid password', async () => {\n      const res = await rq({\n        url: '/admin/login',\n        method: 'POST',\n        body: {\n          ...superAdmin.loginInfo,\n          password: 'wrongPassword',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Invalid credentials',\n      });\n    });\n\n    test('Fails on invalid email', async () => {\n      const res = await rq({\n        url: '/admin/login',\n        method: 'POST',\n        body: {\n          email: 'non-existent-user@strapi.io',\n          password: 'pcw123',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Invalid credentials',\n      });\n    });\n\n    test('Fails on missing credentials', async () => {\n      const res = await rq({\n        url: '/admin/login',\n        method: 'POST',\n        body: {\n          email: 'non-existent-user@strapi.io',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Missing credentials',\n      });\n    });\n  });\n\n  describe('Renew token', () => {\n    test('Renew token', async () => {\n      const authRes = await rq({\n        url: '/admin/login',\n        method: 'POST',\n        body: superAdmin.loginInfo,\n      });\n\n      expect(authRes.statusCode).toBe(200);\n      const { token } = authRes.body.data;\n\n      const res = await rq({\n        url: '/admin/renew-token',\n        method: 'POST',\n        body: {\n          token,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toEqual({\n        token: expect.any(String),\n      });\n    });\n\n    test('Fails on invalid token', async () => {\n      const res = await rq({\n        url: '/admin/renew-token',\n        method: 'POST',\n        body: {\n          token: 'invalid-token',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Invalid token',\n      });\n    });\n\n    test('Fails on missing token', async () => {\n      const res = await rq({\n        url: '/admin/renew-token',\n        method: 'POST',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Missing token',\n      });\n    });\n  });\n\n  describe('GET /registration-info', () => {\n    const registrationToken = 'foobar';\n    let user;\n\n    beforeAll(async () => {\n      const userInfo = {\n        email: 'test@strapi.io',\n        firstname: 'test',\n        lastname: 'strapi',\n        roles: [internals.role.id],\n        registrationToken,\n        isActive: false,\n      };\n\n      user = await utils.createUser(userInfo);\n    });\n\n    afterAll(async () => {\n      await utils.deleteUserById(user.id);\n    });\n\n    test('Returns registration info', async () => {\n      const res = await rq({\n        url: `/admin/registration-info?registrationToken=${registrationToken}`,\n        method: 'GET',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          email: user.email,\n          firstname: user.firstname,\n          lastname: user.lastname,\n        },\n      });\n    });\n\n    test('Fails on missing registration token', async () => {\n      const res = await rq({\n        url: '/admin/registration-info',\n        method: 'GET',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'QueryError',\n        data: {\n          registrationToken: ['registrationToken is a required field'],\n        },\n      });\n    });\n\n    test('Fails on invalid registration token. Without too much info', async () => {\n      const res = await rq({\n        url: '/admin/registration-info?registrationToken=ABCD',\n        method: 'GET',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'Invalid registrationToken',\n      });\n    });\n  });\n\n  describe('GET /register', () => {\n    let user;\n\n    beforeEach(async () => {\n      const userInfo = {\n        email: 'test@strapi.io',\n        firstname: 'test',\n        lastname: 'strapi',\n        registrationToken: 'foobar',\n      };\n\n      user = await utils.createUser(userInfo);\n    });\n\n    afterEach(async () => {\n      await utils.deleteUserById(user.id);\n    });\n\n    test('Fails on missing payload', async () => {\n      const res = await rq({\n        url: '/admin/register',\n        method: 'POST',\n        body: {\n          userInfo: {},\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          registrationToken: ['registrationToken is a required field'],\n\n          'userInfo.firstname': ['userInfo.firstname is a required field'],\n          'userInfo.lastname': ['userInfo.lastname is a required field'],\n          'userInfo.password': ['userInfo.password is a required field'],\n        },\n      });\n    });\n\n    test('Fails on invalid password', async () => {\n      const res = await rq({\n        url: '/admin/register',\n        method: 'POST',\n        body: {\n          registrationToken: user.registrationToken,\n          userInfo: {\n            firstname: 'test',\n            lastname: 'Strapi',\n            password: '123',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          'userInfo.password': ['userInfo.password must contain at least one uppercase character'],\n        },\n      });\n    });\n\n    test('Registers user correctly', async () => {\n      const userRegistrationInfo = {\n        firstname: 'test',\n        lastname: 'Strapi',\n        password: '1Test2azda3',\n      };\n\n      const res = await rq({\n        url: '/admin/register',\n        method: 'POST',\n        body: {\n          registrationToken: user.registrationToken,\n          userInfo: userRegistrationInfo,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toMatchObject({\n        token: expect.any(String),\n        user: {\n          email: user.email,\n          firstname: 'test',\n          lastname: 'Strapi',\n        },\n      });\n\n      expect(res.body.data.user.password === userRegistrationInfo.password).toBe(false);\n    });\n  });\n\n  describe('GET /register-admin', () => {\n    test('Fails on missing payload', async () => {\n      const res = await rq({\n        url: '/admin/register-admin',\n        method: 'POST',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          email: ['email is a required field'],\n          firstname: ['firstname is a required field'],\n          lastname: ['lastname is a required field'],\n          password: ['password is a required field'],\n        },\n      });\n    });\n\n    test('Fails on invalid password', async () => {\n      const res = await rq({\n        url: '/admin/register-admin',\n        method: 'POST',\n        body: {\n          email: 'test@strapi.io',\n          firstname: 'test',\n          lastname: 'Strapi',\n          password: '123',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          password: ['password must contain at least one uppercase character'],\n        },\n      });\n    });\n\n    test('Fails if already a user', async () => {\n      const userInfo = {\n        email: 'test-admin@strapi.io',\n        firstname: 'test',\n        lastname: 'Strapi',\n        password: '1Test2azda3',\n      };\n\n      const res = await rq({\n        url: '/admin/register-admin',\n        method: 'POST',\n        body: userInfo,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'You cannot register a new super admin',\n      });\n    });\n  });\n\n  describe('POST /forgot-password', () => {\n    test('Always returns en empty response', async () => {\n      const res = await rq({\n        url: '/admin/forgot-password',\n        method: 'POST',\n        body: {\n          email: 'admin@strapi.io',\n        },\n      });\n\n      expect(res.statusCode).toBe(204);\n      expect(res.body).toStrictEqual({});\n\n      const nonExistentRes = await rq({\n        url: '/admin/forgot-password',\n        method: 'POST',\n        body: {\n          email: 'email-do-not-exist@strapi.io',\n        },\n      });\n\n      expect(nonExistentRes.statusCode).toBe(204);\n      expect(nonExistentRes.body).toStrictEqual({});\n    });\n  });\n});\n",
    "packages/strapi-admin/tests/admin-authenticated-user.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest, createRequest } = require('../../../test/helpers/request');\n\ndescribe('Authenticated User', () => {\n  let rq;\n  let strapi;\n\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('GET /users/me', () => {\n    test('Returns sanitized user info', async () => {\n      const res = await rq({\n        url: '/admin/users/me',\n        method: 'GET',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toMatchObject({\n        id: expect.anything(),\n        firstname: expect.stringOrNull(),\n        lastname: expect.stringOrNull(),\n        username: expect.stringOrNull(),\n        email: expect.any(String),\n        isActive: expect.any(Boolean),\n      });\n    });\n\n    test('Returns forbidden on unauthenticated query', async () => {\n      const req = createRequest({ strapi });\n      const res = await req({\n        url: '/admin/users/me',\n        method: 'GET',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(403);\n    });\n  });\n\n  describe('PUT /users/me', () => {\n    test('Returns forbidden on unauthenticated query', async () => {\n      const req = createRequest({ strapi });\n      const res = await req({\n        url: '/admin/users/me',\n        method: 'PUT',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(403);\n    });\n\n    test('Fails when trying to edit roles', async () => {\n      const res = await rq({\n        url: '/admin/users/me',\n        method: 'PUT',\n        body: {\n          roles: [1],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n      });\n    });\n\n    test('Fails when trying to edit isActive', async () => {\n      const res = await rq({\n        url: '/admin/users/me',\n        method: 'PUT',\n        body: {\n          isActive: 12,\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n      });\n    });\n\n    test('Fails when trying to set invalid inputs', async () => {\n      const res = await rq({\n        url: '/admin/users/me',\n        method: 'PUT',\n        body: {\n          isActive: 12,\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n      });\n    });\n\n    test('Allows edition of names', async () => {\n      const input = {\n        firstname: 'newFirstName',\n        lastname: 'newLastaName',\n      };\n\n      const res = await rq({\n        url: '/admin/users/me',\n        method: 'PUT',\n        body: input,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toMatchObject({\n        id: expect.anything(),\n        email: expect.any(String),\n        firstname: input.firstname,\n        lastname: input.lastname,\n        username: expect.stringOrNull(),\n        isActive: expect.any(Boolean),\n        roles: expect.arrayContaining([]),\n      });\n    });\n  });\n});\n",
    "packages/strapi-admin/tests/admin-permission.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\n\ndescribe('Role CRUD End to End', () => {\n  let rq;\n  let strapi;\n\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  test('Can get the existing permissions', async () => {\n    let res = await rq({\n      url: '/admin/permissions',\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n\n    // Data is sorted to avoid error with snapshot when the data is not in the same order\n    const sortedData = _.cloneDeep(res.body.data);\n    Object.keys(sortedData.sections).forEach(sectionName => {\n      sortedData.sections[sectionName] = _.sortBy(sortedData.sections[sectionName], ['action']);\n    });\n    sortedData.conditions = sortedData.conditions.sort();\n    expect(sortedData).toMatchSnapshot();\n  });\n});\n",
    "packages/strapi-admin/tests/admin-permissions-conditions.test.e2e.js": "'use strict';\n\nconst { prop } = require('lodash/fp');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createRequest, createAuthRequest } = require('../../../test/helpers/request');\nconst { createUtils } = require('../../../test/helpers/utils');\n\nconst edition = process.env.STRAPI_DISABLE_EE === 'true' ? 'CE' : 'EE';\n\nif (edition === 'EE') {\n  describe('Admin Permissions - Conditions', () => {\n    let strapi;\n    let utils;\n    const builder = createTestBuilder();\n    let requests = {\n      public: null,\n      admin: null,\n    };\n\n    const localTestData = {\n      models: {\n        article: {\n          name: 'article',\n          attributes: {\n            title: {\n              type: 'string',\n            },\n            price: {\n              type: 'integer',\n            },\n          },\n        },\n      },\n      entry: {\n        name: 'Test Article',\n        price: 999,\n      },\n      role: {\n        name: 'foobar',\n        description: 'A dummy test role',\n      },\n      permissions: [\n        {\n          action: 'plugins::content-manager.explorer.create',\n          subject: 'application::article.article',\n          fields: null,\n          conditions: [],\n        },\n        {\n          action: 'plugins::content-manager.explorer.read',\n          subject: 'application::article.article',\n          fields: null,\n          conditions: ['admin::has-same-role-as-creator'],\n        },\n        {\n          action: 'plugins::content-manager.explorer.delete',\n          subject: 'application::article.article',\n          fields: null,\n          conditions: ['admin::is-creator'],\n        },\n      ],\n      userPassword: 'fooBar42',\n      users: [\n        { firstname: 'Alice', lastname: 'Foo', email: 'alice.foo@test.com' },\n        { firstname: 'Bob', lastname: 'Bar', email: 'bob.bar@test.com' },\n      ],\n    };\n\n    const createFixtures = async () => {\n      // Login with admin and init admin tools\n      requests.admin = await createAuthRequest({ strapi });\n      requests.public = createRequest({ strapi });\n\n      // Create the foobar role\n      const role = await utils.createRole(localTestData.role);\n\n      // Assign permissions to the foobar role\n      const permissions = await utils.assignPermissionsToRole(role.id, localTestData.permissions);\n      Object.assign(role, { permissions });\n\n      // Create users with the new role & create associated auth requests\n      const users = [];\n\n      for (let i = 0; i < localTestData.users.length; ++i) {\n        const userFixture = localTestData.users[i];\n        const userAttributes = {\n          ...userFixture,\n          password: localTestData.userPassword,\n          roles: [role.id],\n        };\n\n        const createdUser = await utils.createUser(userAttributes);\n\n        requests[createdUser.id] = await createAuthRequest({ strapi, userInfo: createdUser });\n\n        users.push(createdUser);\n      }\n\n      // Update the local data store\n      Object.assign(localTestData, { role, permissions, users });\n    };\n\n    const getUserRequest = idx => requests[localTestData.users[idx].id];\n    const getModelName = () => localTestData.models.article.name;\n\n    const deleteFixtures = async () => {\n      // Delete users\n      const usersId = localTestData.users.map(prop('id'));\n      await utils.deleteUsersById(usersId);\n\n      // Delete the foobar role\n      await utils.deleteRolesById([localTestData.role.id]);\n    };\n\n    beforeAll(async () => {\n      await builder.addContentType(localTestData.models.article).build();\n\n      strapi = await createStrapiInstance();\n      utils = createUtils(strapi);\n\n      await createFixtures();\n    }, 60000);\n\n    afterAll(async () => {\n      await deleteFixtures();\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    test('User A can create an entry', async () => {\n      const rq = getUserRequest(0);\n      const modelName = getModelName();\n      const res = await rq({\n        method: 'POST',\n        url: `/content-manager/collection-types/application::${modelName}.${modelName}`,\n        body: localTestData.entry,\n      });\n\n      expect(res.statusCode).toBe(200);\n      localTestData.entry = res.body;\n    });\n\n    test('User A can read its entry', async () => {\n      const { id } = localTestData.entry;\n      const modelName = getModelName();\n      const rq = getUserRequest(0);\n      const res = await rq({\n        method: 'GET',\n        url: `/content-manager/collection-types/application::${modelName}.${modelName}/${id}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(localTestData.entry);\n    });\n\n    test('User B can read the entry created by user A', async () => {\n      const { id } = localTestData.entry;\n      const modelName = getModelName();\n      const rq = getUserRequest(1);\n      const res = await rq({\n        method: 'GET',\n        url: `/content-manager/collection-types/application::${modelName}.${modelName}/${id}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(localTestData.entry);\n    });\n\n    test('User B cannot delete the entry created by user A', async () => {\n      const { id } = localTestData.entry;\n      const modelName = getModelName();\n      const rq = getUserRequest(1);\n      const res = await rq({\n        method: 'DELETE',\n        url: `/content-manager/collection-types/application::${modelName}.${modelName}/${id}`,\n      });\n\n      expect(res.statusCode).toBe(403);\n    });\n\n    test('User A can delete its entry', async () => {\n      const { id } = localTestData.entry;\n      const modelName = getModelName();\n      const rq = getUserRequest(0);\n      const res = await rq({\n        method: 'DELETE',\n        url: `/content-manager/collection-types/application::${modelName}.${modelName}/${id}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(localTestData.entry);\n    });\n  });\n} else {\n  describe('Admin Permissions - Conditions ', () => {\n    test.skip('Only in EE', () => {});\n  });\n}\n",
    "packages/strapi-admin/tests/admin-role.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst edition = process.env.STRAPI_DISABLE_EE === 'true' ? 'CE' : 'EE';\nconst sortPermissionArray = arr => _.sortBy(arr, ['action', 'subject']);\n\nconst data = {\n  rolesWithUsers: [],\n  rolesWithoutUsers: [],\n  users: [],\n  deleteRolesIds: [],\n  superAdminRole: undefined,\n  authorRole: undefined,\n  editorRole: undefined,\n};\n\nconst omitTimestamps = obj => _.omit(obj, ['updatedAt', 'createdAt', 'updated_at', 'created_at']);\n\ndescribe('Role CRUD End to End', () => {\n  let rq;\n  let strapi;\n\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('Default roles', () => {\n    test('Default roles are created', async () => {\n      const defaultsRoles = [\n        {\n          name: 'Super Admin',\n          code: 'strapi-super-admin',\n          description: 'Super Admins can access and manage all features and settings.',\n          usersCount: 1,\n        },\n        {\n          name: 'Editor',\n          code: 'strapi-editor',\n          description: 'Editors can manage and publish contents including those of other users.',\n          usersCount: 0,\n        },\n        {\n          name: 'Author',\n          code: 'strapi-author',\n          description: 'Authors can manage the content they have created.',\n          usersCount: 0,\n        },\n      ];\n\n      const res = await rq({\n        url: '/admin/roles',\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toHaveLength(3);\n      expect(res.body.data).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining(defaultsRoles[0]),\n          expect.objectContaining(defaultsRoles[1]),\n          expect.objectContaining(defaultsRoles[2]),\n        ])\n      );\n      data.superAdminRole = res.body.data.find(r => r.code === 'strapi-super-admin');\n      data.authorRole = res.body.data.find(r => r.code === 'strapi-author');\n      data.editorRole = res.body.data.find(r => r.code === 'strapi-editor');\n    });\n\n    test('Author have admin::is-creator condition for every permission', async () => {\n      const res = await rq({\n        url: `/admin/roles/${data.authorRole.id}/permissions`,\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data)).toBe(true);\n      expect(res.body.data).toHaveLength(5);\n      res.body.data\n        .filter(p => !p.action.includes('plugins::upload'))\n        .forEach(permission => {\n          expect(permission.conditions).toEqual(['admin::is-creator']);\n        });\n    });\n\n    test(\"Editor's permissions don't have any conditions\", async () => {\n      const res = await rq({\n        url: `/admin/roles/${data.editorRole.id}/permissions`,\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data)).toBe(true);\n      expect(res.body.data).toHaveLength(5);\n      res.body.data\n        .filter(p => !p.action.includes('plugins::upload'))\n        .forEach(permission => {\n          expect(permission.conditions).toEqual([]);\n        });\n    });\n\n    if (edition === 'EE') {\n      const newPermissions = [\n        {\n          action: 'plugins::users-permissions.roles.update',\n        },\n        {\n          action: 'plugins::content-manager.explorer.create',\n          subject: 'plugins::users-permissions.user',\n          fields: ['username'],\n          conditions: ['admin::is-creator'],\n        },\n      ];\n\n      test('Conditions of editors and author can be modified', async () => {\n        let res = await rq({\n          url: `/admin/roles/${data.editorRole.id}/permissions`,\n          method: 'PUT',\n          body: { permissions: newPermissions },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toHaveLength(2);\n        expect(res.body).toEqual({\n          data: expect.arrayContaining([\n            expect.objectContaining({\n              action: 'plugins::users-permissions.roles.update',\n              conditions: [],\n            }),\n            expect.objectContaining({\n              action: 'plugins::content-manager.explorer.create',\n              subject: 'plugins::users-permissions.user',\n              fields: ['username'],\n              conditions: ['admin::is-creator'],\n            }),\n          ]),\n        });\n\n        res = await rq({\n          url: `/admin/roles/${data.authorRole.id}/permissions`,\n          method: 'PUT',\n          body: { permissions: newPermissions },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toHaveLength(2);\n        expect(res.body).toEqual({\n          data: expect.arrayContaining([\n            expect.objectContaining({\n              action: 'plugins::users-permissions.roles.update',\n              conditions: [],\n            }),\n            expect.objectContaining({\n              action: 'plugins::content-manager.explorer.create',\n              subject: 'plugins::users-permissions.user',\n              fields: ['username'],\n              conditions: ['admin::is-creator'],\n            }),\n          ]),\n        });\n      });\n    } else if (edition === 'CE') {\n      const newPermissions = [\n        {\n          action: 'plugins::users-permissions.roles.update',\n        },\n        {\n          action: 'plugins::users-permissions.roles.read',\n          conditions: ['admin::is-creator'],\n        },\n        {\n          action: 'plugins::content-manager.explorer.create',\n          subject: 'plugins::users-permissions.user',\n          fields: ['username'],\n          conditions: ['admin::is-creator'],\n        },\n        {\n          action: 'plugins::content-manager.explorer.update',\n          subject: 'plugins::users-permissions.user',\n          fields: ['username'],\n          conditions: ['admin::is-creator'],\n        },\n        {\n          action: 'plugins::content-manager.explorer.delete',\n          subject: 'plugins::users-permissions.user',\n          fields: null,\n          conditions: ['admin::is-creator'],\n        },\n        {\n          action: 'plugins::content-manager.explorer.read',\n          subject: 'plugins::users-permissions.user',\n          fields: ['username'],\n          conditions: ['admin::is-creator'],\n        },\n      ];\n\n      test(\"Conditions of editors and author can't be modified\", async () => {\n        let res = await rq({\n          url: `/admin/roles/${data.editorRole.id}/permissions`,\n          method: 'PUT',\n          body: { permissions: newPermissions },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toHaveLength(6);\n        expect(res.body).toEqual({\n          data: expect.arrayContaining(\n            newPermissions\n              .slice(3, 6)\n              .map(p => ({ ...p, conditions: [] }))\n              .map(expect.objectContaining)\n          ),\n        });\n\n        res = await rq({\n          url: `/admin/roles/${data.authorRole.id}/permissions`,\n          method: 'PUT',\n          body: { permissions: newPermissions },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toHaveLength(6);\n        expect(res.body).toEqual({\n          data: expect.arrayContaining(\n            newPermissions\n              .slice(3, 6)\n              .map(p => ({ ...p, conditions: ['admin::is-creator'] }))\n              .map(expect.objectContaining)\n          ),\n        });\n      });\n    }\n  });\n\n  if (edition === 'EE') {\n    describe('Create some roles', () => {\n      const rolesToCreate = [\n        [{ name: 'new role 0', description: 'description' }],\n        [{ name: 'new role 1', description: 'description' }],\n        [{ name: 'new role 2', description: 'description' }],\n        [{ name: 'new role 3', description: 'description' }],\n        [{ name: 'new role 4', description: 'description' }],\n        [{ name: 'new role 5', description: 'description' }],\n      ];\n      test.each(rolesToCreate)('can create %p', async role => {\n        let res = await rq({\n          url: '/admin/roles',\n          method: 'POST',\n          body: role,\n        });\n\n        expect(res.statusCode).toBe(201);\n        expect(res.body.data).toMatchObject({\n          id: expect.anything(),\n          name: role.name,\n          description: role.description,\n        });\n        data.rolesWithoutUsers.push(res.body.data);\n      });\n      test('Cannot create a role already existing', async () => {\n        const role = _.pick(data.rolesWithoutUsers[0], ['name', 'description']);\n        const res = await rq({\n          url: '/admin/roles',\n          method: 'POST',\n          body: role,\n        });\n\n        expect(res.statusCode).toBe(400);\n        expect(res.body.data).toMatchObject({\n          name: [`The name must be unique and a role with name \\`${role.name}\\` already exists.`],\n        });\n      });\n      test('Can create a user with a role', async () => {\n        const user = {\n          email: 'new-user@strapi.io',\n          firstname: 'New',\n          lastname: 'User',\n          roles: [data.rolesWithoutUsers[5].id],\n        };\n\n        const res = await rq({\n          url: '/admin/users',\n          method: 'POST',\n          body: user,\n        });\n\n        expect(res.statusCode).toBe(201);\n\n        data.users.push(res.body.data);\n        data.rolesWithUsers.push(data.rolesWithoutUsers[5]);\n        data.rolesWithoutUsers.splice(5, 1);\n      });\n    });\n\n    describe('Find a role', () => {\n      test('Can find a role successfully', async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n          method: 'GET',\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toMatchObject({\n          id: data.rolesWithoutUsers[0].id,\n          name: data.rolesWithoutUsers[0].name,\n          description: data.rolesWithoutUsers[0].description,\n          usersCount: 0,\n          code: expect.anything(),\n        });\n        expect(res.body.data.code.startsWith('new-role-0')).toBe(true);\n      });\n    });\n\n    describe('Find all roles', () => {\n      test('Can find all roles successfully', async () => {\n        const expectedRolesWithoutUser = data.rolesWithoutUsers.map(r => ({ ...r, usersCount: 0 }));\n        const expectedRolesWithUser = data.rolesWithUsers.map(r => ({ ...r, usersCount: 1 }));\n        const expectedRoles = expectedRolesWithoutUser.concat(expectedRolesWithUser);\n\n        const res = await rq({\n          url: '/admin/roles',\n          method: 'GET',\n        });\n\n        expect(res.statusCode).toBe(200);\n        expectedRoles.forEach(role => {\n          expect(res.body.data).toEqual(\n            expect.arrayContaining([\n              expect.objectContaining({\n                id: role.id,\n                name: role.name,\n                description: role.description,\n                usersCount: role.usersCount,\n                code: expect.anything(),\n              }),\n            ])\n          );\n        });\n      });\n    });\n\n    describe('Update a role', () => {\n      test('Can update name and description of a role successfully', async () => {\n        const updates = {\n          name: 'new name - Cannot update the name of a role',\n          description: 'new description - Can update a role successfully',\n        };\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n          method: 'PUT',\n          body: updates,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(omitTimestamps(res.body.data)).toMatchObject({\n          ...omitTimestamps(data.rolesWithoutUsers[0]),\n          ...updates,\n        });\n        data.rolesWithoutUsers[0] = res.body.data;\n      });\n\n      test('Can update description of a role successfully', async () => {\n        const updates = {\n          name: 'new name - Cannot update the name of a role',\n          description: 'new description - Can update description of a role successfully',\n        };\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n          method: 'PUT',\n          body: updates,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(omitTimestamps(res.body.data)).toMatchObject({\n          ...omitTimestamps(data.rolesWithoutUsers[0]),\n          ...updates,\n        });\n        data.rolesWithoutUsers[0] = res.body.data;\n      });\n\n      test('Cannot update the name of a role if already exists', async () => {\n        const updates = {\n          name: data.rolesWithoutUsers[0].name,\n          description: 'new description - Cannot update the name of a role if already exists',\n        };\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[1].id}`,\n          method: 'PUT',\n          body: updates,\n        });\n\n        expect(res.statusCode).toBe(400);\n        expect(res.body.data).toMatchObject({\n          name: [\n            `The name must be unique and a role with name \\`${data.rolesWithoutUsers[0].name}\\` already exists.`,\n          ],\n        });\n      });\n\n      test('Cannot update super admin role', async () => {\n        const updates = {\n          name: 'new name - Cannot update the name of a role',\n          description: 'new description - Can update a role successfully',\n        };\n        const res = await rq({\n          url: `/admin/roles/${data.superAdminRole.id}`,\n          method: 'PUT',\n          body: updates,\n        });\n\n        expect(res.statusCode).toBe(400);\n      });\n    });\n\n    describe('Delete roles', () => {\n      describe('batch-delete', () => {\n        test(\"Don't delete the roles if some still have assigned users\", async () => {\n          const roles = [data.rolesWithUsers[0], data.rolesWithUsers[0]];\n          const rolesIds = roles.map(r => r.id);\n          let res = await rq({\n            url: '/admin/roles/batch-delete',\n            method: 'POST',\n            body: { ids: rolesIds },\n          });\n\n          expect(res.statusCode).toBe(400);\n          expect(res.body.data).toMatchObject({\n            ids: ['Some roles are still assigned to some users.'],\n          });\n\n          for (let role of roles) {\n            res = await rq({\n              url: `/admin/roles/${role.id}`,\n              method: 'GET',\n            });\n            expect(res.statusCode).toBe(200);\n            expect(res.body.data).toMatchObject(role);\n          }\n        });\n\n        test('Can delete a role', async () => {\n          let res = await rq({\n            url: '/admin/roles/batch-delete',\n            method: 'POST',\n            body: { ids: [data.rolesWithoutUsers[0].id] },\n          });\n          expect(res.statusCode).toBe(200);\n          expect(res.body.data).toMatchObject([data.rolesWithoutUsers[0]]);\n\n          res = await rq({\n            url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n            method: 'GET',\n          });\n          expect(res.statusCode).toBe(404);\n\n          data.deleteRolesIds.push(data.rolesWithoutUsers[0].id);\n          data.rolesWithoutUsers.shift();\n        });\n\n        test('Can delete two roles', async () => {\n          const roles = data.rolesWithoutUsers.slice(0, 2);\n          const rolesIds = roles.map(r => r.id);\n\n          let res = await rq({\n            url: '/admin/roles/batch-delete',\n            method: 'POST',\n            body: { ids: rolesIds },\n          });\n          expect(res.statusCode).toBe(200);\n          expect(res.body.data).toMatchObject(roles);\n\n          for (let roleId of rolesIds) {\n            res = await rq({\n              url: `/admin/roles/${roleId}`,\n              method: 'GET',\n            });\n            expect(res.statusCode).toBe(404);\n            data.deleteRolesIds.push(data.rolesWithoutUsers[0].id);\n            data.rolesWithoutUsers.shift();\n          }\n        });\n      });\n\n      describe('simple delete', () => {\n        test('Can delete a role', async () => {\n          let res = await rq({\n            url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n            method: 'DELETE',\n          });\n          expect(res.statusCode).toBe(200);\n          expect(res.body.data).toMatchObject(data.rolesWithoutUsers[0]);\n\n          res = await rq({\n            url: `/admin/roles/${data.rolesWithoutUsers[0].id}`,\n            method: 'GET',\n          });\n          expect(res.statusCode).toBe(404);\n\n          data.deleteRolesIds.push(data.rolesWithoutUsers[0].id);\n          data.rolesWithoutUsers.shift();\n        });\n\n        test(\"Don't delete a role if it still has assigned users\", async () => {\n          let res = await rq({\n            url: `/admin/roles/${data.rolesWithUsers[0].id}`,\n            method: 'DELETE',\n          });\n\n          expect(res.statusCode).toBe(400);\n          expect(res.body.data).toMatchObject({\n            ids: ['Some roles are still assigned to some users.'],\n          });\n\n          res = await rq({\n            url: `/admin/roles/${data.rolesWithUsers[0].id}`,\n            method: 'GET',\n          });\n          expect(res.statusCode).toBe(200);\n          expect(res.body.data).toMatchObject(data.rolesWithUsers[0]);\n        });\n\n        test(\"Can't delete super admin role\", async () => {\n          let res = await rq({\n            url: `/admin/roles/${data.superAdminRole.id}`,\n            method: 'DELETE',\n          });\n\n          expect(res.statusCode).toBe(400);\n          expect(res.body.data).toMatchObject({\n            id: ['You cannot delete the super admin role'],\n          });\n\n          res = await rq({\n            url: `/admin/roles/${data.rolesWithUsers[0].id}`,\n            method: 'GET',\n          });\n          expect(res.statusCode).toBe(200);\n          expect(res.body.data).toMatchObject(data.rolesWithUsers[0]);\n        });\n      });\n    });\n\n    describe(\"Roles don't exist\", () => {\n      test(\"Cannot update a role if it doesn't exist\", async () => {\n        const updates = {\n          name: \"new name - Cannot update a role if it doesn't exist\",\n          description: \"new description - Cannot update a role if it doesn't exist\",\n        };\n        const res = await rq({\n          url: `/admin/roles/${data.deleteRolesIds[0]}`,\n          method: 'PUT',\n          body: updates,\n        });\n\n        expect(res.statusCode).toBe(404);\n        expect(res.body).toMatchObject({\n          statusCode: 404,\n          error: 'Not Found',\n          message: 'role.notFound',\n        });\n      });\n\n      test(\"Simple delete - No error if deleting a role that doesn't exist\", async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.deleteRolesIds[0]}`,\n          method: 'DELETE',\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toEqual(null);\n      });\n      test(\"Batch Delete - No error if deleting a role that doesn't exist\", async () => {\n        const res = await rq({\n          url: '/admin/roles/batch-delete',\n          method: 'POST',\n          body: { ids: [data.deleteRolesIds[0]] },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data).toEqual([]);\n      });\n    });\n\n    describe('get & update Permissions', () => {\n      test('get permissions on empty role', async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}/permissions`,\n          method: 'GET',\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toEqual({\n          data: [],\n        });\n      });\n\n      test('assign permissions on role', async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}/permissions`,\n          method: 'PUT',\n          body: {\n            permissions: [\n              {\n                action: 'plugins::users-permissions.roles.update',\n              },\n              {\n                action: 'plugins::content-manager.explorer.create',\n                subject: 'plugins::users-permissions.user',\n                fields: ['username'],\n                conditions: ['admin::is-creator'],\n              },\n            ],\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data.length > 0).toBe(true);\n        res.body.data.forEach(permission => {\n          expect(permission).toMatchObject({\n            id: expect.anything(),\n            action: expect.any(String),\n            subject: expect.stringOrNull(),\n          });\n\n          if (permission.conditions.length > 0) {\n            expect(permission.conditions).toEqual(expect.arrayContaining([expect.any(String)]));\n          }\n          if (permission.fields && permission.fields.length > 0) {\n            expect(permission.fields).toEqual(expect.arrayContaining([expect.any(String)]));\n          }\n        });\n      });\n\n      test('assign permissions on role with an unknown condition', async () => {\n        const permissions = [\n          {\n            action: 'plugins::users-permissions.roles.update',\n          },\n          {\n            action: 'plugins::content-manager.explorer.create',\n            subject: 'plugins::users-permissions.user',\n            fields: ['username'],\n            conditions: ['admin::is-creator'],\n          },\n        ];\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}/permissions`,\n          method: 'PUT',\n          body: {\n            permissions: [\n              permissions[0],\n              {\n                ...permissions[1],\n                conditions: [...permissions[1].conditions, 'unknown-condition'],\n              },\n            ],\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data.length > 0).toBe(true);\n        expect(sortPermissionArray(res.body.data)).toMatchObject(\n          sortPermissionArray(\n            permissions.map(perm => ({ subject: null, fields: null, conditions: [], ...perm }))\n          )\n        );\n      });\n\n      test(\"can't assign non-existing permissions on role\", async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}/permissions`,\n          method: 'PUT',\n          body: {\n            permissions: [\n              {\n                action: 'non.existing.action',\n              },\n            ],\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n        expect(res.body).toMatchObject({\n          statusCode: 400,\n          error: 'Bad Request',\n          message: 'ValidationError',\n          data: { permissions: ['[0] is not an existing permission action'] },\n        });\n      });\n\n      test('get permissions role', async () => {\n        const res = await rq({\n          url: `/admin/roles/${data.rolesWithoutUsers[0].id}/permissions`,\n          method: 'GET',\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body.data.length > 0).toBe(true);\n        res.body.data.forEach(permission => {\n          expect(permission).toMatchObject({\n            id: expect.anything(),\n            action: expect.any(String),\n            subject: expect.stringOrNull(),\n          });\n\n          if (permission.conditions.length > 0) {\n            expect(permission.conditions).toEqual(expect.arrayContaining([expect.any(String)]));\n          }\n          if (permission.fields && permission.fields.length > 0) {\n            expect(permission.fields).toEqual(expect.arrayContaining([expect.any(String)]));\n          }\n        });\n      });\n    });\n  }\n\n  if (edition === 'CE') {\n    describe('Cannot create a new role', () => {\n      test('Cannot create a role successfully', async () => {\n        const role = {\n          name: 'new role',\n          description: 'Description of new role',\n        };\n\n        const res = await rq({\n          url: '/admin/roles',\n          method: 'POST',\n          body: role,\n        });\n\n        expect(res.statusCode).toBe(405);\n      });\n    });\n  }\n});\n",
    "packages/strapi-admin/tests/admin-user.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createUtils } = require('../../../test/helpers/utils');\n\nconst edition = process.env.STRAPI_DISABLE_EE === 'true' ? 'CE' : 'EE';\n\nconst omitTimestamps = obj => _.omit(obj, ['updatedAt', 'createdAt', 'updated_at', 'created_at']);\n\n/**\n * == Test Suite Overview ==\n *\n * N°   Description\n * -------------------------------------------\n * 1.  Creates a user (wrong body)\n * 2.  Creates a user (successfully)\n * 3.  Creates users with superAdmin role (success)\n * 4.  Updates a user (wrong body)\n * 5.  Updates a user (successfully)\n * 6.  Finds a user (successfully)\n * 7.  Finds a list of users (contains user)\n * 8.  Deletes a user (successfully)\n * 9.  Deletes a user (not found)\n * 10. Deletes 2 super admin users (successfully)\n * 11. Deletes a super admin user (successfully)\n * 12. Deletes last super admin user (bad request)\n * 13. Deletes last super admin user in batch (bad request)\n * 14. Updates a user (not found)\n * 15. Finds a user (not found)\n * 16. Finds a list of users (missing user)\n */\n\ndescribe('Admin User CRUD (e2e)', () => {\n  let rq;\n  let utils;\n  let strapi;\n\n  // Local test data used across the test suite\n  let testData = {\n    firstSuperAdminUser: undefined,\n    otherSuperAdminUsers: [],\n    user: undefined,\n    role: undefined,\n    superAdminRole: undefined,\n  };\n\n  const createUserRole = async () =>\n    utils.createRole({\n      name: 'user_test_role',\n      description: 'Only used for user crud test (e2e)',\n    });\n\n  // Initialization Actions\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    utils = createUtils(strapi);\n\n    if (edition === 'EE') {\n      testData.role = await createUserRole();\n    } else {\n      testData.role = await utils.getSuperAdminRole();\n    }\n\n    testData.firstSuperAdminUser = rq.getLoggedUser();\n    testData.superAdminRole = await utils.getSuperAdminRole();\n  }, 60000);\n\n  // Cleanup actions\n  afterAll(async () => {\n    if (edition === 'EE') {\n      await utils.deleteRolesById([testData.role.id]);\n    }\n    await strapi.destroy();\n  }, 60000);\n\n  test('1. Creates a user (wrong body)', async () => {\n    const body = {\n      firstname: 'user_tests-firstname',\n      lastname: 'user_tests-lastname',\n      roles: [testData.role.id],\n    };\n\n    const res = await rq({\n      url: '/admin/users',\n      method: 'POST',\n      body,\n    });\n\n    expect(res.statusCode).toBe(400);\n    expect(res.body).toMatchObject({\n      statusCode: 400,\n      error: 'Bad Request',\n      message: 'ValidationError',\n      data: {\n        email: ['email is a required field'],\n      },\n    });\n  });\n\n  test('2. Creates a user (successfully)', async () => {\n    const body = {\n      email: 'user-tests@strapi-e2e.com',\n      firstname: 'user_tests-firstname',\n      lastname: 'user_tests-lastname',\n      roles: [testData.role.id],\n    };\n\n    const res = await rq({\n      url: '/admin/users',\n      method: 'POST',\n      body,\n    });\n\n    expect(res.statusCode).toBe(201);\n    expect(res.body.data).not.toBeNull();\n\n    // Using the created user as an example for the rest of the tests\n    testData.user = res.body.data;\n  });\n\n  test('3. Creates users with superAdmin role (success)', async () => {\n    const getBody = index => {\n      return {\n        email: `user-tests${index}@strapi-e2e.com`,\n        firstname: 'user_tests-firstname',\n        lastname: 'user_tests-lastname',\n        roles: [testData.superAdminRole.id],\n      };\n    };\n\n    for (let i = 0; i < 3; i++) {\n      const res = await rq({\n        url: '/admin/users',\n        method: 'POST',\n        body: getBody(i),\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body.data).not.toBeNull();\n\n      testData.otherSuperAdminUsers.push(res.body.data);\n    }\n  });\n\n  test('4. Updates a user (wrong body)', async () => {\n    const body = {\n      email: 42,\n    };\n\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'PUT',\n      body,\n    });\n\n    expect(res.statusCode).toBe(400);\n    expect(res.body).toMatchObject({\n      statusCode: 400,\n      error: 'Bad Request',\n      message: 'ValidationError',\n      data: {\n        email: ['email must be a `string` type, but the final value was: `42`.'],\n      },\n    });\n  });\n\n  test('5. Updates a user (successfully)', async () => {\n    const body = {\n      firstname: 'foobar',\n    };\n\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'PUT',\n      body,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).not.toBeNull();\n    expect(omitTimestamps(res.body.data)).toMatchObject({\n      ...omitTimestamps(testData.user),\n      ...body,\n    });\n\n    // Update the local copy of the user\n    testData.user = res.body.data;\n  });\n\n  test('6. Finds a user (successfully)', async () => {\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject(testData.user);\n  });\n\n  describe('7. Finds a list of users (contains user)', () => {\n    const expectedBodyFormat = () => ({\n      data: {\n        pagination: {\n          page: 1,\n          pageSize: expect.any(Number),\n          pageCount: expect.any(Number),\n          total: expect.any(Number),\n        },\n        results: expect.any(Array),\n      },\n    });\n\n    test('7.1. Using findPage', async () => {\n      const res = await rq({\n        url: `/admin/users?email=${testData.user.email}`,\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(expectedBodyFormat());\n      expect(res.body.data.results).toContainEqual(testData.user);\n    });\n\n    test('7.2. Using searchPage', async () => {\n      const res = await rq({\n        url: `/admin/users?_q=${testData.user.email}`,\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(expectedBodyFormat());\n      expect(res.body.data.results).toContainEqual(testData.user);\n    });\n  });\n\n  test('8. Deletes a user (successfully)', async () => {\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'DELETE',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject(testData.user);\n  });\n\n  test('9. Deletes a user (not found)', async () => {\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'DELETE',\n    });\n\n    expect(res.statusCode).toBe(404);\n  });\n\n  test('10. Deletes 2 super admin users (successfully)', async () => {\n    const users = testData.otherSuperAdminUsers.splice(0, 2);\n    const res = await rq({\n      url: `/admin/users/batch-delete`,\n      method: 'POST',\n      body: {\n        ids: users.map(u => u.id),\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject(users);\n  });\n\n  test('11. Deletes a super admin user (successfully)', async () => {\n    const user = testData.otherSuperAdminUsers.pop();\n    const res = await rq({\n      url: `/admin/users/${user.id}`,\n      method: 'DELETE',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject(user);\n  });\n\n  test('12. Deletes last super admin user (bad request)', async () => {\n    const res = await rq({\n      url: `/admin/users/${testData.firstSuperAdminUser.id}`,\n      method: 'DELETE',\n    });\n\n    expect(res.statusCode).toBe(400);\n    expect(res.body).toMatchObject({\n      statusCode: 400,\n      error: 'Bad Request',\n      message: 'ValidationError',\n      data: 'You must have at least one user with super admin role.',\n    });\n  });\n\n  test('13. Deletes last super admin user in batch (bad request)', async () => {\n    const res = await rq({\n      url: `/admin/users/batch-delete`,\n      method: 'POST',\n      body: {\n        ids: [testData.firstSuperAdminUser.id],\n      },\n    });\n\n    expect(res.statusCode).toBe(400);\n    expect(res.body).toMatchObject({\n      statusCode: 400,\n      error: 'Bad Request',\n      message: 'ValidationError',\n      data: 'You must have at least one user with super admin role.',\n    });\n  });\n\n  test('14. Updates a user (not found)', async () => {\n    const body = {\n      lastname: 'doe',\n    };\n\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'PUT',\n      body,\n    });\n\n    expect(res.statusCode).toBe(404);\n    expect(res.body).toMatchObject({\n      error: 'Not Found',\n      message: 'entry.notFound',\n      statusCode: 404,\n    });\n  });\n\n  test('15. Finds a user (not found)', async () => {\n    const res = await rq({\n      url: `/admin/users/${testData.user.id}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(404);\n    expect(res.body).toMatchObject({\n      error: 'Not Found',\n      message: 'User does not exist',\n      statusCode: 404,\n    });\n  });\n\n  test('16. Finds a list of users (missing user)', async () => {\n    const res = await rq({\n      url: `/admin/users?email=${testData.user.email}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject({\n      pagination: {\n        page: 1,\n        pageSize: expect.any(Number),\n        pageCount: expect.any(Number),\n        total: expect.any(Number),\n      },\n      results: expect.any(Array),\n    });\n    expect(res.body.data.results).toHaveLength(0);\n  });\n});\n",
    "packages/strapi-connector-bookshelf/lib/build-database-schema.js": "'use strict';\n\nconst _ = require('lodash');\nconst { singular } = require('pluralize');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\n\nconst { storeDefinition, getColumnsWhereDefinitionChanged } = require('./utils/store-definition');\nconst { getManyRelations } = require('./utils/associations');\nconst createMigrationRunner = require('./migrations/create-migration-runner');\nconst draftPublishMigration = require('./migrations/draft-publish-migration');\n\nconst migrateSchemas = async ({ ORM, loadedModel, definition, connection, model }, context) => {\n  // Add created_at and updated_at field if timestamp option is true\n  if (loadedModel.hasTimestamps) {\n    definition.attributes[loadedModel.hasTimestamps[0]] = { type: 'currentTimestamp' };\n    definition.attributes[loadedModel.hasTimestamps[1]] = { type: 'currentTimestamp' };\n  }\n\n  // Equilize tables\n  if (connection.options && connection.options.autoMigration !== false) {\n    await createOrUpdateTable(\n      {\n        table: loadedModel.tableName,\n        attributes: definition.attributes,\n        definition,\n        ORM,\n        model,\n      },\n      context\n    );\n  }\n\n  // Equilize polymorphic relations\n  const morphRelations = definition.associations.filter(association => {\n    return association.nature.toLowerCase().includes('morphto');\n  });\n\n  for (const morphRelation of morphRelations) {\n    const attributes = {\n      [`${loadedModel.tableName}_id`]: { type: definition.primaryKeyType },\n      [`${morphRelation.alias}_id`]: { type: definition.primaryKeyType },\n      [`${morphRelation.alias}_type`]: { type: 'text' },\n      [definition.attributes[morphRelation.alias].filter]: { type: 'text' },\n      order: { type: 'integer' },\n    };\n\n    if (connection.options && connection.options.autoMigration !== false) {\n      await createOrUpdateTable(\n        {\n          table: `${loadedModel.tableName}_morph`,\n          attributes,\n          definition,\n          ORM,\n          model,\n        },\n        context\n      );\n    }\n  }\n\n  // Equilize many to many relations\n  const manyRelations = getManyRelations(definition);\n\n  for (const manyRelation of manyRelations) {\n    const { plugin, collection, via, dominant, alias } = manyRelation;\n\n    if (dominant) {\n      const targetCollection = strapi.db.getModel(collection, plugin);\n\n      const targetAttr = via\n        ? targetCollection.attributes[via]\n        : {\n            attribute: singular(definition.collectionName),\n            column: definition.primaryKey,\n          };\n\n      const defAttr = definition.attributes[alias];\n\n      const targetCol = `${targetAttr.attribute}_${targetAttr.column}`;\n      let rootCol = `${defAttr.attribute}_${defAttr.column}`;\n\n      // manyWay with same CT\n      if (rootCol === targetCol) {\n        rootCol = `related_${rootCol}`;\n      }\n\n      const attributes = {\n        [targetCol]: { type: targetCollection.primaryKeyType },\n        [rootCol]: { type: definition.primaryKeyType },\n      };\n\n      const table = manyRelation.tableCollectionName;\n      if (connection.options && connection.options.autoMigration !== false) {\n        await createOrUpdateTable({ table, attributes, definition, ORM, model }, context);\n      }\n    }\n  }\n\n  // Remove from attributes (auto handled by bookshlef and not displayed on ctb)\n  if (loadedModel.hasTimestamps) {\n    delete definition.attributes[loadedModel.hasTimestamps[0]];\n    delete definition.attributes[loadedModel.hasTimestamps[1]];\n  }\n};\n\nconst getColumnInfo = async (columnName, tableName, ORM) => {\n  const exists = await ORM.knex.schema.hasColumn(tableName, columnName);\n\n  return {\n    columnName,\n    exists,\n  };\n};\n\nconst isColumn = ({ definition, attribute, name }) => {\n  if (!_.has(attribute, 'type')) {\n    const relation = definition.associations.find(association => {\n      return association.alias === name;\n    });\n\n    if (!relation) return false;\n\n    if (['oneToOne', 'manyToOne', 'oneWay'].includes(relation.nature)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (['component', 'dynamiczone'].includes(attribute.type)) {\n    return false;\n  }\n\n  return true;\n};\n\nconst uniqueColName = (table, key) => `${table}_${key}_unique`;\n\nconst buildColType = ({ name, attribute, table, tableExists = false, definition, ORM }) => {\n  if (!attribute.type) {\n    const relation = definition.associations.find(association => association.alias === name);\n\n    if (['oneToOne', 'manyToOne', 'oneWay'].includes(relation.nature)) {\n      return buildColType({\n        name,\n        attribute: { type: definition.primaryKeyType },\n        table,\n        tableExists,\n        definition,\n        ORM,\n      });\n    }\n\n    return null;\n  }\n\n  // allow custom data type for a column\n  if (_.has(attribute, 'columnType')) {\n    return table.specificType(name, attribute.columnType);\n  }\n\n  switch (attribute.type) {\n    case 'uuid':\n      return table.uuid(name);\n    case 'uid': {\n      table.unique(name);\n      return table.string(name);\n    }\n    case 'richtext':\n    case 'text':\n      return table.text(name, 'longtext');\n    case 'json':\n      return definition.client === 'pg' ? table.jsonb(name) : table.text(name, 'longtext');\n    case 'enumeration':\n    case 'string':\n    case 'password':\n    case 'email':\n      return table.string(name);\n    case 'integer':\n      return table.integer(name);\n    case 'biginteger':\n      return table.bigInteger(name);\n    case 'float':\n      return table.double(name);\n    case 'decimal':\n      return table.decimal(name, 10, 2);\n    case 'date':\n      return table.date(name);\n    case 'time':\n      return table.time(name, 3);\n    case 'datetime':\n      return table.datetime(name);\n    case 'timestamp':\n      return table.timestamp(name);\n    case 'currentTimestamp': {\n      const col = table.timestamp(name);\n\n      if (definition.client !== 'sqlite3' && tableExists) {\n        return col;\n      }\n\n      return col.defaultTo(ORM.knex.fn.now());\n    }\n    case 'boolean':\n      return table.boolean(name);\n    default:\n      return null;\n  }\n};\n\n// Equilize database tables\nconst createOrUpdateTable = async ({ table, attributes, definition, ORM, model }, context) => {\n  const tableExists = await ORM.knex.schema.hasTable(table);\n\n  const createIdType = table => {\n    if (definition.primaryKeyType === 'uuid' && definition.client === 'pg') {\n      return table\n        .specificType('id', 'uuid DEFAULT uuid_generate_v4()')\n        .notNullable()\n        .primary();\n    }\n\n    return table.increments('id');\n  };\n\n  const createColumns = (tbl, columns, opts = {}) => {\n    const { tableExists, alter = false } = opts;\n\n    Object.keys(columns).forEach(key => {\n      const attribute = columns[key];\n\n      const col = buildColType({\n        name: key,\n        attribute,\n        table: tbl,\n        tableExists,\n        definition,\n        ORM,\n      });\n      if (!col) return;\n\n      if (attribute.required === true) {\n        if (\n          (definition.client !== 'sqlite3' || !tableExists) &&\n          !contentTypesUtils.hasDraftAndPublish(model) && // no require constraint to allow drafts\n          definition.modelType !== 'component' // no require constraint to allow components in drafts\n        ) {\n          col.notNullable();\n        }\n      } else {\n        col.nullable();\n      }\n\n      if (attribute.unique === true) {\n        if (definition.client !== 'sqlite3' || !tableExists) {\n          tbl.unique(key, uniqueColName(table, key));\n        }\n      }\n\n      if (alter) {\n        col.alter();\n      }\n    });\n  };\n\n  const alterColumns = (tbl, columns, opts = {}) => {\n    return createColumns(tbl, columns, { ...opts, alter: true });\n  };\n\n  const createTable = (table, { trx = ORM.knex, ...opts } = {}) => {\n    return trx.schema.createTable(table, tbl => {\n      createIdType(tbl);\n      createColumns(tbl, attributes, { ...opts, tableExists: false });\n    });\n  };\n\n  if (!tableExists) {\n    await createTable(table);\n    return;\n  }\n\n  const attributesNames = Object.keys(attributes);\n\n  // Fetch existing column\n  const columnsInfo = await Promise.all(\n    attributesNames.map(attributeName => getColumnInfo(attributeName, table, ORM))\n  );\n  const nameOfColumnsToAdd = columnsInfo.filter(info => !info.exists).map(info => info.columnName);\n\n  const columnsToAdd = _.pick(attributes, nameOfColumnsToAdd);\n\n  // Generate and execute query to add missing column\n  if (Object.keys(columnsToAdd).length > 0) {\n    await ORM.knex.schema.table(table, tbl => {\n      createColumns(tbl, columnsToAdd, { tableExists });\n    });\n  }\n\n  const attrsNameWithoutTimestamps = attributesNames.filter(\n    columnName => !(definition.options.timestamps || []).includes(columnName)\n  );\n\n  const columnsToAlter = await getColumnsWhereDefinitionChanged(\n    attrsNameWithoutTimestamps,\n    definition,\n    ORM\n  );\n\n  const shouldRebuild =\n    columnsToAlter.length > 0 || (definition.client === 'sqlite3' && context.recreateSqliteTable);\n\n  if (shouldRebuild) {\n    switch (definition.client) {\n      case 'sqlite3': {\n        const tmpTable = `tmp_${table}`;\n\n        const rebuildTable = async trx => {\n          await trx.schema.renameTable(table, tmpTable);\n\n          // drop possible conflicting indexes\n          await Promise.all(\n            attributesNames.map(key =>\n              trx.raw('DROP INDEX IF EXISTS ??', uniqueColName(table, key))\n            )\n          );\n\n          // create the table\n          await createTable(table, { trx });\n\n          const attrs = attributesNames.filter(attributeName =>\n            isColumn({\n              definition,\n              attribute: attributes[attributeName],\n              name: attributeName,\n            })\n          );\n\n          const allAttrs = ['id', ...attrs];\n\n          await trx.insert(qb => qb.select(allAttrs).from(tmpTable)).into(table);\n          await trx.schema.dropTableIfExists(tmpTable);\n        };\n\n        try {\n          await ORM.knex.transaction(trx => rebuildTable(trx));\n        } catch (err) {\n          if (err.message.includes('UNIQUE constraint failed')) {\n            strapi.log.error(\n              `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\\n\\t- ${err.stack}`\n            );\n          } else {\n            strapi.log.error(`Migration failed`);\n            strapi.log.error(err);\n          }\n\n          return false;\n        }\n        break;\n      }\n      default: {\n        const alterTable = async trx => {\n          await Promise.all(\n            columnsToAlter.map(col => {\n              return ORM.knex.schema\n                .alterTable(table, tbl => {\n                  tbl.dropUnique(col, uniqueColName(table, col));\n                })\n                .catch(() => {});\n            })\n          );\n          await trx.schema.alterTable(table, tbl => {\n            alterColumns(tbl, _.pick(attributes, columnsToAlter), {\n              tableExists,\n            });\n          });\n        };\n\n        try {\n          await ORM.knex.transaction(trx => alterTable(trx));\n        } catch (err) {\n          if (err.code === '23505' && definition.client === 'pg') {\n            strapi.log.error(\n              `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\\n\\t- ${err.message}\\n\\t- ${err.detail}`\n            );\n          } else if (definition.client === 'mysql' && err.errno === 1062) {\n            strapi.log.error(\n              `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\\n\\t- ${err.sqlMessage}`\n            );\n          } else {\n            strapi.log.error(`Migration failed`);\n            strapi.log.error(err);\n          }\n\n          return false;\n        }\n      }\n    }\n  }\n};\n\nconst migrationRunner = createMigrationRunner(migrateSchemas, {\n  hooks: [draftPublishMigration],\n});\n\nmodule.exports = async ({ ORM, loadedModel, definition, connection, model }) => {\n  // run migrations\n  await migrationRunner.run({ ORM, loadedModel, definition, connection, model });\n\n  // store new definitions\n  await storeDefinition(definition, ORM);\n};\n",
    "packages/strapi-connector-bookshelf/lib/generate-component-relations.js": "'use strict';\n\nconst pluralize = require('pluralize');\n\nconst { getComponentAttributes } = require('./utils/attributes');\n\nconst createComponentModels = async ({ model, definition, ORM, GLOBALS }) => {\n  const { collectionName, primaryKey } = definition;\n\n  const componentAttributes = getComponentAttributes(definition);\n\n  if (componentAttributes.length > 0) {\n    // create component model\n    const joinTable = `${collectionName}_components`;\n    const joinColumn = `${pluralize.singular(collectionName)}_${primaryKey}`;\n\n    const relatedComponents = componentAttributes\n      .map(key => {\n        const attr = definition.attributes[key];\n        const { type } = attr;\n\n        switch (type) {\n          case 'component': {\n            const { component } = attr;\n            return strapi.components[component];\n          }\n          case 'dynamiczone': {\n            const { components } = attr;\n            return components.map(component => strapi.components[component]);\n          }\n          default: {\n            throw new Error(`Invalid type for attribute ${key}: ${type}`);\n          }\n        }\n      })\n      .reduce((acc, arr) => acc.concat(arr), []);\n\n    const joinModel = ORM.Model.extend({\n      requireFetch: false,\n      tableName: joinTable,\n      component() {\n        return this.morphTo(\n          'component',\n          ...relatedComponents.map(component => GLOBALS[component.globalId])\n        );\n      },\n    });\n\n    joinModel.foreignKey = joinColumn;\n    definition.componentsJoinModel = joinModel;\n\n    componentAttributes.forEach(name => {\n      model[name] = function relation() {\n        return this.hasMany(joinModel, joinColumn).query(qb => {\n          qb.where('field', name)\n            .whereIn(\n              'component_type',\n              relatedComponents.map(component => component.collectionName)\n            )\n            .orderBy('order');\n        });\n      };\n    });\n  }\n};\n\nconst createComponentJoinTables = async ({ definition, ORM }) => {\n  const { collectionName, primaryKey } = definition;\n\n  const componentAttributes = getComponentAttributes(definition);\n\n  if (componentAttributes.length > 0) {\n    const joinTable = `${collectionName}_components`;\n    const joinColumn = `${pluralize.singular(collectionName)}_${primaryKey}`;\n\n    if (await ORM.knex.schema.hasTable(joinTable)) return;\n\n    await ORM.knex.schema.createTable(joinTable, table => {\n      table.increments();\n      table.string('field').notNullable();\n      table\n        .integer('order')\n        .unsigned()\n        .notNullable();\n      table.string('component_type').notNullable();\n      table.integer('component_id').notNullable();\n      table\n        .integer(joinColumn)\n        .unsigned()\n        .notNullable();\n\n      table\n        .foreign(joinColumn, `${joinColumn}_fk`)\n        .references(primaryKey)\n        .inTable(collectionName)\n        .onDelete('CASCADE');\n    });\n  }\n};\n\nmodule.exports = {\n  createComponentModels,\n  createComponentJoinTables,\n};\n",
    "packages/strapi-connector-bookshelf/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Core\nconst path = require('path');\nconst fs = require('fs');\n// Public node modules.\nconst _ = require('lodash');\nconst bookshelf = require('bookshelf');\n\n// Local helpers.\nconst relations = require('./relations');\nconst buildQuery = require('./buildQuery');\nconst mountModels = require('./mount-models');\nconst getQueryParams = require('./get-query-params');\nconst queries = require('./queries');\nconst initKnex = require('./knex');\n\n/**\n * Bookshelf hook\n */\n\n/**\n * Default options\n */\n\nconst defaults = {\n  defaultConnection: 'default',\n  host: 'localhost',\n};\n\nconst isBookshelfConnection = ({ connector }) => connector === 'bookshelf';\n\nmodule.exports = function(strapi) {\n  const { connections } = strapi.config;\n  const bookshelfConnections = Object.keys(connections).filter(key =>\n    isBookshelfConnection(connections[key])\n  );\n\n  function initialize() {\n    initKnex(strapi);\n\n    const GLOBALS = {};\n\n    const connectionsPromises = bookshelfConnections.map(connectionName => {\n      const connection = connections[connectionName];\n\n      _.defaults(connection.settings, strapi.config.hook.settings.bookshelf);\n\n      // Create Bookshelf instance for this connection.\n      const ORM = new bookshelf(strapi.connections[connectionName]);\n\n      const initFunctionPath = path.resolve(\n        strapi.config.appPath,\n        'config',\n        'functions',\n        'bookshelf.js'\n      );\n\n      if (fs.existsSync(initFunctionPath)) {\n        require(initFunctionPath)(ORM, connection);\n      }\n\n      const ctx = {\n        GLOBALS,\n        connection,\n        ORM,\n      };\n\n      return mountConnection(connectionName, ctx);\n    });\n\n    return Promise.all(connectionsPromises);\n  }\n\n  async function mountConnection(connectionName, ctx) {\n    if (strapi.models['core_store'].connection === connectionName) {\n      await mountCoreStore(ctx);\n    }\n\n    const finalizeMountings = await Promise.all([\n      mountComponents(connectionName, ctx),\n      mountApis(connectionName, ctx),\n      mountAdmin(connectionName, ctx),\n      mountPlugins(connectionName, ctx),\n    ]);\n\n    for (const finalizeMounting of _.flattenDeep(finalizeMountings)) {\n      await finalizeMounting();\n    }\n  }\n\n  function mountCoreStore(ctx) {\n    return mountModels(\n      {\n        models: {\n          core_store: strapi.models['core_store'],\n        },\n        target: strapi.models,\n      },\n      ctx,\n      { selfFinalize: true }\n    );\n  }\n\n  function mountComponents(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(strapi.components, ({ connection }) => connection === connectionName),\n      target: strapi.components,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountApis(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(\n        strapi.models,\n        ({ connection }, name) => connection === connectionName && name !== 'core_store'\n      ),\n      target: strapi.models,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountAdmin(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(strapi.admin.models, ({ connection }) => connection === connectionName),\n      target: strapi.admin.models,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountPlugins(connectionName, ctx) {\n    return Promise.all(\n      Object.keys(strapi.plugins).map(name => {\n        const plugin = strapi.plugins[name];\n        return mountModels(\n          {\n            models: _.pickBy(plugin.models, ({ connection }) => connection === connectionName),\n            target: plugin.models,\n          },\n          ctx\n        );\n      })\n    );\n  }\n\n  async function destroy() {\n    await Promise.all(bookshelfConnections.map(connName => strapi.connections[connName].destroy()));\n  }\n\n  return {\n    defaults,\n    initialize,\n    getQueryParams,\n    buildQuery,\n    queries,\n    destroy,\n    ...relations,\n    get defaultTimestamps() {\n      return ['created_at', 'updated_at'];\n    },\n  };\n};\n",
    "packages/strapi-connector-bookshelf/lib/migrations/create-migration-runner.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst createMigrationRunner = (migrationFunction, { hooks = [] } = {}, context = {}) => {\n  const beforeHook = async (options, context) => {\n    for (const migration of hooks) {\n      if (_.isFunction(migration.before)) {\n        await migration.before(options, context);\n      }\n    }\n  };\n\n  const afterHook = async (options, context) => {\n    for (const migration of hooks.slice(0).reverse()) {\n      if (_.isFunction(migration.after)) {\n        await migration.after(options, context);\n      }\n    }\n  };\n\n  const run = async options => {\n    await beforeHook(options, context);\n    await migrationFunction(options, context);\n    await afterHook(options, context);\n  };\n\n  return {\n    run,\n  };\n};\n\nmodule.exports = createMigrationRunner;\n",
    "packages/strapi-connector-bookshelf/lib/migrations/draft-publish-migration.js": "'use strict';\n\nconst _ = require('lodash');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\n\nconst { PUBLISHED_AT_ATTRIBUTE } = contentTypesUtils.constants;\nconst { getDefinitionFromStore } = require('../utils/store-definition');\n\nconst getDraftAndPublishMigrationWay = async ({ definition, ORM }) => {\n  const previousDefRow = await getDefinitionFromStore(definition, ORM);\n  const previousDef = JSON.parse(_.get(previousDefRow, 'value', null));\n  const previousDraftAndPublish = contentTypesUtils.hasDraftAndPublish(previousDef);\n  const actualDraftAndPublish = contentTypesUtils.hasDraftAndPublish(definition);\n\n  if (previousDraftAndPublish === actualDraftAndPublish) {\n    return 'none';\n  }\n  if (!previousDraftAndPublish && actualDraftAndPublish) {\n    return 'enable';\n  }\n  if (previousDraftAndPublish && !actualDraftAndPublish) {\n    return 'disable';\n  }\n};\n\nconst before = async ({ definition, ORM }, context) => {\n  const way = await getDraftAndPublishMigrationWay({ definition, ORM });\n\n  if (way === 'disable') {\n    const publishedAtColumnExists = await ORM.knex.schema.hasColumn(\n      definition.collectionName,\n      PUBLISHED_AT_ATTRIBUTE\n    );\n\n    if (publishedAtColumnExists) {\n      await ORM.knex(definition.collectionName)\n        .delete()\n        .where(PUBLISHED_AT_ATTRIBUTE, null);\n\n      if (definition.client === 'sqlite3') {\n        // Bug when droping column with sqlite3 https://github.com/knex/knex/issues/631\n        // Need to recreate the table\n        context.recreateSqliteTable = true;\n      } else {\n        await ORM.knex.schema.table(definition.collectionName, table => {\n          table.dropColumn(PUBLISHED_AT_ATTRIBUTE);\n        });\n      }\n    }\n  }\n};\n\nconst after = async ({ definition, ORM }) => {\n  const way = await getDraftAndPublishMigrationWay({ definition, ORM });\n\n  if (way === 'enable') {\n    const now = new Date();\n    let publishedAtValue = now;\n    if (_.get(definition, 'options.timestamps', false)) {\n      const createdAtColumn = _.get(definition, 'options.timestamps.0', 'created_at');\n      publishedAtValue = ORM.knex.ref(createdAtColumn);\n    }\n    await ORM.knex(definition.collectionName)\n      .update({ [PUBLISHED_AT_ATTRIBUTE]: publishedAtValue })\n      .where(PUBLISHED_AT_ATTRIBUTE, null);\n\n    await ORM.knex(definition.collectionName) // in case some created_at were null\n      .update({ [PUBLISHED_AT_ATTRIBUTE]: now })\n      .where(PUBLISHED_AT_ATTRIBUTE, null);\n  }\n};\n\nmodule.exports = {\n  before,\n  after,\n};\n",
    "packages/strapi-connector-bookshelf/lib/mount-models.js": "'use strict';\nconst _ = require('lodash');\nconst { singular } = require('pluralize');\n\nconst { models: utilsModels, contentTypes: contentTypesUtils } = require('strapi-utils');\nconst relations = require('./relations');\nconst buildDatabaseSchema = require('./build-database-schema');\nconst {\n  createComponentJoinTables,\n  createComponentModels,\n} = require('./generate-component-relations');\nconst { createParser } = require('./parser');\nconst { createFormatter } = require('./formatter');\nconst populateFetch = require('./populate');\n\nconst {\n  PUBLISHED_AT_ATTRIBUTE,\n  CREATED_BY_ATTRIBUTE,\n  UPDATED_BY_ATTRIBUTE,\n} = contentTypesUtils.constants;\n\nconst PIVOT_PREFIX = '_pivot_';\n\nconst getDatabaseName = connection => {\n  const dbName = _.get(connection.settings, 'database');\n  const dbSchema = _.get(connection.settings, 'schema', 'public');\n  switch (_.get(connection.settings, 'client')) {\n    case 'sqlite3':\n      return 'main';\n    case 'pg':\n      return `${dbName}.${dbSchema}`;\n    case 'mysql':\n      return dbName;\n    default:\n      return dbName;\n  }\n};\n\nconst isARelatedField = (morphAttrInfo, attr) => {\n  const samePlugin =\n    morphAttrInfo.plugin === attr.plugin || (_.isNil(morphAttrInfo.plugin) && _.isNil(attr.plugin));\n  const sameModel = [attr.model, attr.collection].includes(morphAttrInfo.model);\n  const isMorph = attr.via === morphAttrInfo.name;\n\n  return isMorph && sameModel && samePlugin;\n};\n\nconst getRelatedFieldsOfMorphModel = morphAttrInfo => morphModel => {\n  const relatedFields = _.reduce(\n    morphModel.attributes,\n    (fields, attr, attrName) => {\n      return isARelatedField(morphAttrInfo, attr) ? fields.concat(attrName) : fields;\n    },\n    []\n  );\n\n  return { collectionName: morphModel.collectionName, relatedFields };\n};\n\nmodule.exports = async ({ models, target }, ctx, { selfFinalize = false } = {}) => {\n  const { GLOBALS, connection, ORM } = ctx;\n\n  // Parse every authenticated model.\n  const updateModel = async model => {\n    const definition = models[model];\n\n    if (!definition.uid.startsWith('strapi::') && definition.modelType !== 'component') {\n      if (contentTypesUtils.hasDraftAndPublish(definition)) {\n        definition.attributes[PUBLISHED_AT_ATTRIBUTE] = {\n          type: 'datetime',\n          configurable: false,\n        };\n      }\n\n      const isPrivate = !_.get(definition, 'options.populateCreatorFields', false);\n\n      definition.attributes[CREATED_BY_ATTRIBUTE] = {\n        model: 'user',\n        plugin: 'admin',\n        configurable: false,\n        writable: false,\n        private: isPrivate,\n      };\n\n      definition.attributes[UPDATED_BY_ATTRIBUTE] = {\n        model: 'user',\n        plugin: 'admin',\n        configurable: false,\n        writable: false,\n        private: isPrivate,\n      };\n    }\n\n    definition.globalName = _.upperFirst(_.camelCase(definition.globalId));\n    definition.associations = [];\n\n    // Define local GLOBALS to expose every models in this file.\n    GLOBALS[definition.globalId] = {};\n\n    // Add some information about ORM & client connection & tableName\n    definition.orm = 'bookshelf';\n    definition.databaseName = getDatabaseName(connection);\n    definition.client = _.get(connection.settings, 'client');\n    definition.primaryKey = 'id';\n    definition.primaryKeyType = 'integer';\n\n    target[model].allAttributes = { ...definition.attributes };\n\n    const createdAtCol = _.get(definition, 'options.timestamps.0', 'created_at');\n    const updatedAtCol = _.get(definition, 'options.timestamps.1', 'updated_at');\n    if (_.get(definition, 'options.timestamps', false)) {\n      _.set(definition, 'options.timestamps', [createdAtCol, updatedAtCol]);\n      target[model].allAttributes[createdAtCol] = { type: 'timestamp' };\n      target[model].allAttributes[updatedAtCol] = { type: 'timestamp' };\n    } else {\n      _.set(definition, 'options.timestamps', false);\n    }\n\n    // Register the final model for Bookshelf.\n    const loadedModel = _.assign(\n      {\n        requireFetch: false,\n        tableName: definition.collectionName,\n        hasTimestamps: definition.options.timestamps,\n        associations: [],\n        defaults: Object.keys(definition.attributes).reduce((acc, current) => {\n          if (definition.attributes[current].type && definition.attributes[current].default) {\n            acc[current] = definition.attributes[current].default;\n          }\n\n          return acc;\n        }, {}),\n      },\n      definition.options\n    );\n\n    const componentAttributes = Object.keys(definition.attributes).filter(key =>\n      ['component', 'dynamiczone'].includes(definition.attributes[key].type)\n    );\n\n    if (_.isString(_.get(connection, 'options.pivot_prefix'))) {\n      loadedModel.toJSON = function(options = {}) {\n        const { shallow = false, omitPivot = false } = options;\n        const attributes = this.serialize(options);\n\n        if (!shallow) {\n          const pivot = this.pivot && !omitPivot && this.pivot.attributes;\n\n          // Remove pivot attributes with prefix.\n          _.keys(pivot).forEach(key => delete attributes[`${PIVOT_PREFIX}${key}`]);\n\n          // Add pivot attributes without prefix.\n          const pivotAttributes = _.mapKeys(\n            pivot,\n            (value, key) => `${connection.options.pivot_prefix}${key}`\n          );\n\n          return Object.assign({}, attributes, pivotAttributes);\n        }\n\n        return attributes;\n      };\n    }\n\n    await createComponentModels({\n      model: loadedModel,\n      definition,\n      ORM,\n      GLOBALS,\n    });\n\n    // Add every relationships to the loaded model for Bookshelf.\n    // Basic attributes don't need this-- only relations.\n    Object.keys(definition.attributes).forEach(name => {\n      const details = definition.attributes[name];\n      if (details.type !== undefined) {\n        return;\n      }\n\n      const { nature, verbose } =\n        utilsModels.getNature({\n          attribute: details,\n          attributeName: name,\n          modelName: model.toLowerCase(),\n        }) || {};\n\n      // Build associations key\n      utilsModels.defineAssociations(model.toLowerCase(), definition, details, name);\n\n      let globalId;\n      const globalName = details.model || details.collection || '';\n\n      // Exclude polymorphic association.\n      if (globalName !== '*') {\n        globalId = strapi.db.getModel(globalName.toLowerCase(), details.plugin).globalId;\n      }\n\n      switch (verbose) {\n        case 'hasOne': {\n          const target = details.plugin\n            ? strapi.plugins[details.plugin].models[details.model]\n            : strapi.models[details.model];\n\n          const FK = _.findKey(target.attributes, details => {\n            if (\n              _.has(details, 'model') &&\n              details.model === model &&\n              _.has(details, 'via') &&\n              details.via === name\n            ) {\n              return details;\n            }\n          });\n\n          const columnName = _.get(target.attributes, [FK, 'columnName'], FK);\n\n          loadedModel[name] = function() {\n            return this.hasOne(GLOBALS[globalId], columnName);\n          };\n          break;\n        }\n        case 'hasMany': {\n          const columnName = details.plugin\n            ? _.get(\n                strapi.plugins,\n                [\n                  details.plugin,\n                  'models',\n                  details.collection,\n                  'attributes',\n                  details.via,\n                  'columnName',\n                ],\n                details.via\n              )\n            : _.get(\n                strapi.models,\n                [model.collection, 'attributes', details.via, 'columnName'],\n                details.via\n              );\n\n          // Set this info to be able to see if this field is a real database's field.\n          details.isVirtual = true;\n\n          loadedModel[name] = function() {\n            return this.hasMany(GLOBALS[globalId], columnName);\n          };\n          break;\n        }\n        case 'belongsTo': {\n          loadedModel[name] = function() {\n            return this.belongsTo(GLOBALS[globalId], _.get(details, 'columnName', name));\n          };\n          break;\n        }\n        case 'belongsToMany': {\n          const targetModel = strapi.db.getModel(details.collection, details.plugin);\n\n          // Force singular foreign key\n          details.attribute = singular(details.collection);\n          details.column = 'id';\n\n          // Set this info to be able to see if this field is a real database's field.\n          details.isVirtual = true;\n\n          if (nature === 'manyWay') {\n            const joinTableName =\n              details.collectionName || `${definition.collectionName}__${_.snakeCase(name)}`;\n\n            const foreignKey = `${singular(definition.collectionName)}_${definition.primaryKey}`;\n\n            let otherKey = `${details.attribute}_${details.column}`;\n\n            if (otherKey === foreignKey) {\n              otherKey = `related_${otherKey}`;\n              details.attribute = `related_${details.attribute}`;\n            }\n\n            loadedModel[name] = function() {\n              const targetBookshelfModel = GLOBALS[globalId];\n              let collection = this.belongsToMany(\n                targetBookshelfModel,\n                joinTableName,\n                foreignKey,\n                otherKey\n              );\n\n              if (Array.isArray(details.withPivot)) {\n                return collection.withPivot(details.withPivot);\n              }\n\n              return collection;\n            };\n          } else {\n            const joinTableName = utilsModels.getCollectionName(\n              targetModel.attributes[details.via],\n              details\n            );\n\n            const relationship = targetModel.attributes[details.via];\n\n            // Define PK column\n            relationship.attribute = singular(relationship.collection);\n            relationship.column = definition.primaryKey;\n\n            // Sometimes the many-to-many relationships\n            // is on the same keys on the same models (ex: `friends` key in model `User`)\n            if (\n              `${details.attribute}_${details.column}` ===\n              `${relationship.attribute}_${relationship.column}`\n            ) {\n              relationship.attribute = singular(details.via);\n            }\n\n            loadedModel[name] = function() {\n              const targetBookshelfModel = GLOBALS[globalId];\n\n              const foreignKey = `${relationship.attribute}_${relationship.column}`;\n              const otherKey = `${details.attribute}_${details.column}`;\n\n              let collection = this.belongsToMany(\n                targetBookshelfModel,\n                joinTableName,\n                foreignKey,\n                otherKey\n              );\n\n              if (Array.isArray(details.withPivot)) {\n                return collection.withPivot(details.withPivot);\n              }\n\n              return collection;\n            };\n          }\n\n          break;\n        }\n        case 'morphOne': {\n          const model = details.plugin\n            ? strapi.plugins[details.plugin].models[details.model]\n            : strapi.models[details.model];\n\n          const globalId = `${model.collectionName}_morph`;\n          const filter = _.get(model, ['attributes', details.via, 'filter'], 'field');\n\n          loadedModel[name] = function() {\n            return this.morphOne(\n              GLOBALS[globalId],\n              details.via,\n              `${definition.collectionName}`\n            ).query(qb => {\n              qb.where(filter, name);\n            });\n          };\n          break;\n        }\n        case 'morphMany': {\n          const collection = details.plugin\n            ? strapi.plugins[details.plugin].models[details.collection]\n            : strapi.models[details.collection];\n\n          const globalId = `${collection.collectionName}_morph`;\n          const filter = _.get(model, ['attributes', details.via, 'filter'], 'field');\n\n          loadedModel[name] = function() {\n            return this.morphMany(\n              GLOBALS[globalId],\n              details.via,\n              `${definition.collectionName}`\n            ).query(qb => {\n              qb.where(filter, name).orderBy('order');\n            });\n          };\n          break;\n        }\n        case 'belongsToMorph':\n        case 'belongsToManyMorph': {\n          const association = _.find(definition.associations, { alias: name });\n          const morphAttrInfo = {\n            plugin: definition.plugin,\n            model: definition.modelName,\n            name,\n          };\n          const morphModelsAndFields = association.related.map(\n            getRelatedFieldsOfMorphModel(morphAttrInfo)\n          );\n\n          // Define new model.\n          const options = {\n            requireFetch: false,\n            tableName: `${definition.collectionName}_morph`,\n            [definition.collectionName]: function() {\n              return this.belongsTo(\n                GLOBALS[definition.globalId],\n                `${definition.collectionName}_id`\n              );\n            },\n            related: function() {\n              return this.morphTo(\n                name,\n                ...association.related.map(morphModel => [\n                  GLOBALS[morphModel.globalId],\n                  morphModel.collectionName,\n                ])\n              );\n            },\n          };\n\n          GLOBALS[options.tableName] = ORM.Model.extend(options);\n\n          // Set polymorphic table name to the main model.\n          target[model].morph = GLOBALS[options.tableName];\n\n          // Hack Bookshelf to create a many-to-many polymorphic association.\n          // Upload has many Upload_morph that morph to different model.\n          const populateFn = qb => {\n            qb.where(qb => {\n              for (const modelAndFields of morphModelsAndFields) {\n                qb.orWhere(qb => {\n                  qb.where({ related_type: modelAndFields.collectionName }).whereIn(\n                    'field',\n                    modelAndFields.relatedFields\n                  );\n                });\n              }\n            });\n          };\n\n          loadedModel[name] = function() {\n            if (verbose === 'belongsToMorph') {\n              return this.hasOne(\n                GLOBALS[options.tableName],\n                `${definition.collectionName}_id`\n              ).query(populateFn);\n            }\n\n            return this.hasMany(\n              GLOBALS[options.tableName],\n              `${definition.collectionName}_id`\n            ).query(populateFn);\n          };\n          break;\n        }\n        default: {\n          break;\n        }\n      }\n    });\n\n    // Call this callback function after we are done parsing\n    // all attributes for relationships-- see below.\n\n    const parseValue = createParser();\n    try {\n      // External function to map key that has been updated with `columnName`\n      const mapper = (params = {}) => {\n        Object.keys(params).map(key => {\n          const attr = definition.attributes[key] || {};\n\n          params[key] = parseValue(attr.type, params[key]);\n        });\n\n        return _.mapKeys(params, (value, key) => {\n          const attr = definition.attributes[key] || {};\n\n          return _.isPlainObject(attr) && _.isString(attr['columnName']) ? attr['columnName'] : key;\n        });\n      };\n\n      // Extract association except polymorphic.\n      const associations = definition.associations.filter(\n        association => association.nature.toLowerCase().indexOf('morph') === -1\n      );\n      // Extract polymorphic association.\n      const polymorphicAssociations = definition.associations.filter(\n        association => association.nature.toLowerCase().indexOf('morph') !== -1\n      );\n\n      // Update serialize to reformat data for polymorphic associations.\n      loadedModel.serialize = function(options) {\n        const attrs = _.clone(this.attributes);\n\n        if (options && options.shallow) {\n          return attrs;\n        }\n\n        const relations = this.relations;\n\n        componentAttributes.forEach(key => {\n          if (!_.has(relations, key)) return;\n\n          const attr = definition.attributes[key];\n          const { type } = attr;\n\n          switch (type) {\n            case 'component': {\n              const { repeatable } = attr;\n\n              const components = relations[key].toJSON().map(el => el.component);\n\n              attrs[key] = repeatable === true ? components : _.first(components) || null;\n\n              break;\n            }\n            case 'dynamiczone': {\n              attrs[key] = relations[key].toJSON().map(el => {\n                const componentKey = Object.keys(strapi.components).find(\n                  key => strapi.components[key].collectionName === el.component_type\n                );\n\n                return {\n                  __component: strapi.components[componentKey].uid,\n                  ...el.component,\n                };\n              });\n\n              break;\n            }\n            default: {\n              throw new Error(`Invalid type for attribute ${key}: ${type}`);\n            }\n          }\n        });\n\n        polymorphicAssociations.map(association => {\n          // Retrieve relation Bookshelf object.\n          const relation = relations[association.alias];\n\n          if (relation) {\n            // Extract raw JSON data.\n            attrs[association.alias] = relation.toJSON ? relation.toJSON(options) : relation;\n\n            // Retrieve opposite model.\n            const model = strapi.db.getModel(\n              association.collection || association.model,\n              association.plugin\n            );\n\n            // Reformat data by bypassing the many-to-many relationship.\n            switch (association.nature) {\n              case 'oneToManyMorph':\n                attrs[association.alias] = attrs[association.alias][model.collectionName] || null;\n                break;\n              case 'manyToManyMorph':\n                attrs[association.alias] = attrs[association.alias].map(\n                  rel => rel[model.collectionName]\n                );\n                break;\n              case 'oneMorphToOne': {\n                const obj = attrs[association.alias];\n\n                if (obj === undefined || obj === null) {\n                  break;\n                }\n\n                const contentType = strapi.db.getModelByCollectionName(\n                  obj[`${association.alias}_type`]\n                );\n\n                attrs[association.alias] = {\n                  __contentType: contentType ? contentType.globalId : null,\n                  ...obj.related,\n                };\n\n                break;\n              }\n              case 'manyMorphToOne':\n              case 'manyMorphToMany':\n                attrs[association.alias] = attrs[association.alias].map(obj => {\n                  const contentType = strapi.db.getModelByCollectionName(\n                    obj[`${association.alias}_type`]\n                  );\n\n                  return {\n                    __contentType: contentType ? contentType.globalId : null,\n                    ...obj.related,\n                  };\n                });\n                break;\n              default:\n            }\n          }\n        });\n\n        associations.map(association => {\n          const relation = relations[association.alias];\n\n          if (relation) {\n            // Extract raw JSON data.\n            attrs[association.alias] = relation.toJSON ? relation.toJSON(options) : relation;\n          }\n        });\n\n        return attrs;\n      };\n\n      // Initialize lifecycle callbacks.\n      loadedModel.initialize = function() {\n        // Load bookshelf plugin arguments from model options\n        this.constructor.__super__.initialize.apply(this, arguments);\n\n        this.on('fetching fetching:collection', (instance, attrs, options) => {\n          populateFetch(definition, options);\n        });\n\n        this.on('saving', (instance, attrs) => {\n          instance.attributes = _.assign(instance.attributes, mapper(attrs));\n        });\n\n        const formatValue = createFormatter(definition.client);\n        function formatEntry(entry) {\n          Object.keys(entry.attributes).forEach(key => {\n            if (key.startsWith('_strapi_tmp_')) {\n              delete entry.attributes[key];\n              return;\n            }\n            const attr = definition.attributes[key] || {};\n            entry.attributes[key] = formatValue(attr, entry.attributes[key]);\n          });\n        }\n\n        this.on('saved fetched fetched:collection', instance => {\n          if (Array.isArray(instance.models)) {\n            instance.models.forEach(entry => formatEntry(entry));\n          } else {\n            formatEntry(instance);\n          }\n        });\n      };\n\n      loadedModel.hidden = _.keys(\n        _.keyBy(\n          _.filter(definition.attributes, (value, key) => {\n            if (\n              _.has(value, 'columnName') &&\n              !_.isEmpty(value.columnName) &&\n              value.columnName !== key\n            ) {\n              return true;\n            }\n          }),\n          'columnName'\n        )\n      );\n      GLOBALS[definition.globalId] = ORM.Model.extend(loadedModel);\n\n      // Expose ORM functions through the `strapi.models[xxx]`\n      // or `strapi.plugins[xxx].models[yyy]` object.\n      target[model] = _.assign(GLOBALS[definition.globalId], target[model]);\n\n      // Push attributes to be aware of model schema.\n      target[model]._attributes = definition.attributes;\n      target[model].updateRelations = relations.update;\n      target[model].deleteRelations = relations.deleteRelations;\n      target[model].privateAttributes = contentTypesUtils.getPrivateAttributes(target[model]);\n\n      return async () => {\n        try {\n          await buildDatabaseSchema({\n            ORM,\n            definition,\n            loadedModel,\n            connection,\n            model: target[model],\n          });\n\n          await createComponentJoinTables({ definition, ORM });\n        } catch (err) {\n          if (['ER_TOO_LONG_IDENT'].includes(err.code)) {\n            strapi.stopWithError(\n              err,\n              `A table name is too long. If it is the name of a join table automatically generated by Strapi, you can customise it by adding \\`collectionName: \"customName\"\\` in the corresponding model's attribute.\n    When this happens on a manyToMany relation, make sure to set this parameter on the dominant side of the relation (e.g: where \\`dominant: true\\` is set)`\n            );\n          }\n\n          strapi.stopWithError(err);\n        }\n      };\n    } catch (err) {\n      if (err instanceof TypeError || err instanceof ReferenceError) {\n        strapi.stopWithError(err, `Impossible to register the '${model}' model.`);\n      }\n\n      strapi.stopWithError(err);\n    }\n  };\n\n  const finalizeUpdates = [];\n  for (const model of _.keys(models)) {\n    const finalizeUpdate = await updateModel(model);\n    finalizeUpdates.push(finalizeUpdate);\n  }\n\n  if (selfFinalize) {\n    for (const finalizeUpdate of finalizeUpdates) {\n      await finalizeUpdate();\n    }\n    return [];\n  }\n\n  return finalizeUpdates;\n};\n",
    "packages/strapi-connector-bookshelf/lib/queries.js": "'use strict';\n/**\n * Implementation of model queries for bookshelf\n */\n\nconst _ = require('lodash');\nconst { omit } = require('lodash/fp');\nconst pmap = require('p-map');\nconst { convertRestQueryParams, buildQuery, escapeQuery } = require('strapi-utils');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\nconst { singular } = require('pluralize');\nconst { handleDatabaseError } = require('./utils/errors');\n\nconst { PUBLISHED_AT_ATTRIBUTE } = contentTypesUtils.constants;\nconst pickCountFilters = omit(['sort', 'limit', 'start']);\n\nmodule.exports = function createQueryBuilder({ model, strapi }) {\n  /* Utils */\n  // association key\n  const assocKeys = model.associations.map(ast => ast.alias);\n  // component keys\n  const componentKeys = Object.keys(model.attributes).filter(key => {\n    return ['dynamiczone', 'component'].includes(model.attributes[key].type);\n  });\n\n  const timestamps = _.get(model, ['options', 'timestamps'], []);\n  const hasDraftAndPublish = contentTypesUtils.hasDraftAndPublish(model);\n\n  // Returns an object with relation keys only to create relations in DB\n  const pickRelations = attributes => {\n    return _.pick(attributes, assocKeys);\n  };\n\n  // keys to exclude to get attribute keys\n  const excludedKeys = assocKeys.concat(componentKeys);\n  // Returns an object without relational keys to persist in DB\n  const selectAttributes = attributes => {\n    return _.pickBy(attributes, (value, key) => {\n      if (Array.isArray(timestamps) && timestamps.includes(key)) {\n        return false;\n      }\n\n      return !excludedKeys.includes(key) && _.has(model.allAttributes, key);\n    });\n  };\n\n  const wrapTransaction = (fn, { transacting } = {}) => {\n    const db = strapi.connections[model.connection];\n\n    if (transacting) return fn(transacting);\n    return db.transaction(trx => fn(trx));\n  };\n\n  const wrapErrors = fn => async (...args) => {\n    try {\n      return await fn(...args);\n    } catch (error) {\n      return handleDatabaseError(error);\n    }\n  };\n\n  /**\n   * Find one entry based on params\n   */\n  async function findOne(params, populate, { transacting } = {}) {\n    const entries = await find({ ...params, _limit: 1 }, populate, { transacting });\n    return entries[0] || null;\n  }\n\n  /**\n   * Find multiple entries based on params\n   */\n  function find(params, populate, { transacting } = {}) {\n    const filters = convertRestQueryParams(params);\n    const query = buildQuery({ model, filters });\n\n    return model\n      .query(query)\n      .fetchAll({\n        withRelated: populate,\n        transacting,\n        publicationState: filters.publicationState,\n      })\n      .then(results => results.toJSON());\n  }\n\n  /**\n   * Count entries based on filters\n   */\n  function count(params = {}) {\n    const filters = pickCountFilters(convertRestQueryParams(params));\n\n    return model\n      .query(buildQuery({ model, filters }))\n      .count()\n      .then(Number);\n  }\n\n  async function create(attributes, { transacting } = {}) {\n    const relations = pickRelations(attributes);\n    const data = { ...selectAttributes(attributes) };\n\n    if (hasDraftAndPublish) {\n      data[PUBLISHED_AT_ATTRIBUTE] = _.has(attributes, PUBLISHED_AT_ATTRIBUTE)\n        ? attributes[PUBLISHED_AT_ATTRIBUTE]\n        : new Date();\n    }\n\n    const runCreate = async trx => {\n      // Create entry with no-relational data.\n      const entry = await model.forge(data).save(null, { transacting: trx });\n      const isDraft = contentTypesUtils.isDraft(entry.toJSON(), model);\n      await createComponents(entry, attributes, { transacting: trx, isDraft });\n\n      return model.updateRelations({ id: entry.id, values: relations }, { transacting: trx });\n    };\n\n    return wrapTransaction(runCreate, { transacting });\n  }\n\n  async function update(params, attributes, { transacting } = {}) {\n    const entry = await model.where(params).fetch({ transacting });\n\n    if (!entry) {\n      const err = new Error('entry.notFound');\n      err.status = 404;\n      throw err;\n    }\n\n    // Extract attributes related to relational data.\n    const relations = pickRelations(attributes);\n    const data = selectAttributes(attributes);\n\n    const runUpdate = async trx => {\n      const updatedEntry =\n        Object.keys(data).length > 0\n          ? await entry.save(data, {\n              transacting: trx,\n              method: 'update',\n              patch: true,\n            })\n          : entry;\n\n      await updateComponents(updatedEntry, attributes, { transacting: trx });\n\n      if (Object.keys(relations).length > 0) {\n        return model.updateRelations({ id: entry.id, values: relations }, { transacting: trx });\n      }\n\n      return findOne(params, null, { transacting: trx });\n    };\n\n    return wrapTransaction(runUpdate, { transacting });\n  }\n\n  async function deleteOne(id, { transacting } = {}) {\n    const entry = await model.where({ [model.primaryKey]: id }).fetch({ transacting });\n\n    if (!entry) {\n      const err = new Error('entry.notFound');\n      err.status = 404;\n      throw err;\n    }\n\n    await model.deleteRelations(id, { transacting });\n\n    const runDelete = async trx => {\n      await deleteComponents(entry, { transacting: trx });\n      await model.where({ id: entry.id }).destroy({ transacting: trx, require: false });\n      return entry.toJSON();\n    };\n\n    return wrapTransaction(runDelete, { transacting });\n  }\n\n  async function deleteMany(params, { transacting } = {}) {\n    if (params[model.primaryKey]) {\n      const entries = await find({ ...params, _limit: 1 }, null, { transacting });\n      if (entries.length > 0) {\n        return deleteOne(entries[0][model.primaryKey], { transacting });\n      }\n      return null;\n    }\n\n    const paramsWithDefaults = _.defaults(params, { _limit: -1 });\n    const entries = await find(paramsWithDefaults, null, { transacting });\n    return pmap(entries, entry => deleteOne(entry.id, { transacting }), {\n      concurrency: 100,\n      stopOnError: true,\n    });\n  }\n\n  function search(params, populate) {\n    const filters = convertRestQueryParams(_.omit(params, '_q'));\n\n    return model\n      .query(qb => qb.where(buildSearchQuery({ model, params })))\n      .query(buildQuery({ model, filters }))\n      .fetchAll({ withRelated: populate })\n      .then(results => results.toJSON());\n  }\n\n  function countSearch(params) {\n    const countParams = omit(['_q'], params);\n    const filters = pickCountFilters(convertRestQueryParams(countParams));\n\n    return model\n      .query(qb => qb.where(buildSearchQuery({ model, params })))\n      .query(buildQuery({ model, filters }))\n      .count()\n      .then(Number);\n  }\n\n  async function createComponents(entry, attributes, { transacting, isDraft }) {\n    if (componentKeys.length === 0) return;\n\n    const joinModel = model.componentsJoinModel;\n    const { foreignKey } = joinModel;\n\n    const createComponentAndLink = async ({ componentModel, value, key, order }) => {\n      return strapi\n        .query(componentModel.uid)\n        .create(value, { transacting })\n        .then(component => {\n          return joinModel.forge().save(\n            {\n              [foreignKey]: entry.id,\n              component_type: componentModel.collectionName,\n              component_id: component.id,\n              field: key,\n              order,\n            },\n            { transacting }\n          );\n        });\n    };\n\n    for (let key of componentKeys) {\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      switch (type) {\n        case 'component': {\n          const { component, required = false, repeatable = false } = attr;\n          const componentModel = strapi.components[component];\n\n          if (!isDraft && required === true && !_.has(attributes, key)) {\n            const err = new Error(`Component ${key} is required`);\n            err.status = 400;\n            throw err;\n          }\n\n          if (!_.has(attributes, key)) continue;\n\n          const componentValue = attributes[key];\n\n          if (repeatable === true) {\n            await Promise.all(\n              componentValue.map((value, idx) =>\n                createComponentAndLink({\n                  componentModel,\n                  value,\n                  key,\n                  order: idx + 1,\n                })\n              )\n            );\n          } else {\n            if (componentValue === null) continue;\n            await createComponentAndLink({\n              componentModel,\n              key,\n              value: componentValue,\n              order: 1,\n            });\n          }\n          break;\n        }\n        case 'dynamiczone': {\n          const { required = false } = attr;\n\n          if (!isDraft && required === true && !_.has(attributes, key)) {\n            const err = new Error(`Dynamiczone ${key} is required`);\n            err.status = 400;\n            throw err;\n          }\n\n          if (!_.has(attributes, key)) continue;\n\n          const dynamiczoneValues = attributes[key];\n\n          await Promise.all(\n            dynamiczoneValues.map((value, idx) => {\n              const component = value.__component;\n              const componentModel = strapi.components[component];\n              return createComponentAndLink({\n                componentModel,\n                value: _.omit(value, ['__component']),\n                key,\n                order: idx + 1,\n              });\n            })\n          );\n          break;\n        }\n      }\n    }\n  }\n\n  async function updateComponents(entry, attributes, { transacting }) {\n    if (componentKeys.length === 0) return;\n\n    const joinModel = model.componentsJoinModel;\n    const { foreignKey } = joinModel;\n\n    const updateOrCreateComponentAndLink = async ({ componentModel, key, value, order }) => {\n      // check if value has an id then update else create\n      if (_.has(value, componentModel.primaryKey)) {\n        return strapi\n          .query(componentModel.uid)\n          .update(\n            {\n              [componentModel.primaryKey]: value[componentModel.primaryKey],\n            },\n            value,\n            { transacting }\n          )\n          .then(component => {\n            return joinModel\n              .where({\n                [foreignKey]: entry.id,\n                component_type: componentModel.collectionName,\n                component_id: component.id,\n                field: key,\n              })\n              .save(\n                {\n                  order,\n                },\n                { transacting, patch: true, require: false }\n              );\n          });\n      }\n      // create\n      return strapi\n        .query(componentModel.uid)\n        .create(value, { transacting })\n        .then(component => {\n          return joinModel.forge().save(\n            {\n              [foreignKey]: entry.id,\n              component_type: componentModel.collectionName,\n              component_id: component.id,\n              field: key,\n              order,\n            },\n            { transacting }\n          );\n        });\n    };\n\n    for (let key of componentKeys) {\n      // if key isn't present then don't change the current component data\n      if (!_.has(attributes, key)) continue;\n\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      switch (type) {\n        case 'component': {\n          const { component, repeatable = false } = attr;\n\n          const componentModel = strapi.components[component];\n\n          const componentValue = attributes[key];\n\n          if (repeatable === true) {\n            await deleteOldComponents(entry, componentValue, {\n              key,\n              joinModel,\n              componentModel,\n              transacting,\n            });\n\n            await Promise.all(\n              componentValue.map((value, idx) => {\n                return updateOrCreateComponentAndLink({\n                  componentModel,\n                  key,\n                  value,\n                  order: idx + 1,\n                });\n              })\n            );\n          } else {\n            await deleteOldComponents(entry, componentValue, {\n              key,\n              joinModel,\n              componentModel,\n              transacting,\n            });\n\n            if (componentValue === null) continue;\n\n            await updateOrCreateComponentAndLink({\n              componentModel,\n              key,\n              value: componentValue,\n              order: 1,\n            });\n          }\n\n          break;\n        }\n        case 'dynamiczone': {\n          const dynamiczoneValues = attributes[key];\n\n          await deleteDynamicZoneOldComponents(entry, dynamiczoneValues, {\n            key,\n            joinModel,\n            transacting,\n          });\n\n          await Promise.all(\n            dynamiczoneValues.map((value, idx) => {\n              const component = value.__component;\n              const componentModel = strapi.components[component];\n              return updateOrCreateComponentAndLink({\n                componentModel,\n                value: _.omit(value, ['__component']),\n                key,\n                order: idx + 1,\n              });\n            })\n          );\n          break;\n        }\n      }\n    }\n    return;\n  }\n\n  async function deleteDynamicZoneOldComponents(entry, values, { key, joinModel, transacting }) {\n    const idsToKeep = values.reduce((acc, value) => {\n      const component = value.__component;\n      const componentModel = strapi.components[component];\n      if (_.has(value, componentModel.primaryKey)) {\n        acc.push({\n          id: value[componentModel.primaryKey].toString(),\n          component: componentModel,\n        });\n      }\n\n      return acc;\n    }, []);\n\n    const allIds = await joinModel\n      .query(qb => {\n        qb.where(joinModel.foreignKey, entry.id).andWhere('field', key);\n      })\n      .fetchAll({ transacting })\n      .map(el => {\n        const componentKey = Object.keys(strapi.components).find(\n          key => strapi.components[key].collectionName === el.get('component_type')\n        );\n\n        return {\n          id: el.get('component_id').toString(),\n          component: strapi.components[componentKey],\n        };\n      });\n\n    // verify the provided ids are related to this entity.\n    idsToKeep.forEach(({ id, component }) => {\n      if (!allIds.find(el => el.id === id && el.component.uid === component.uid)) {\n        const err = new Error(\n          `Some of the provided components in ${key} are not related to the entity`\n        );\n        err.status = 400;\n        throw err;\n      }\n    });\n\n    const idsToDelete = allIds.reduce((acc, { id, component }) => {\n      if (!idsToKeep.find(el => el.id === id && el.component.uid === component.uid)) {\n        acc.push({\n          id,\n          component,\n        });\n      }\n      return acc;\n    }, []);\n\n    if (idsToDelete.length > 0) {\n      await joinModel\n        .query(qb => {\n          qb.where('field', key);\n          qb.where(qb => {\n            idsToDelete.forEach(({ id, component }) => {\n              qb.orWhere(qb => {\n                qb.where('component_id', id).andWhere('component_type', component.collectionName);\n              });\n            });\n          });\n        })\n        .destroy({ transacting });\n\n      for (const idToDelete of idsToDelete) {\n        const { id, component } = idToDelete;\n        const model = strapi.query(component.uid);\n        await model.delete({ [model.primaryKey]: id }, { transacting });\n      }\n    }\n  }\n\n  async function deleteOldComponents(\n    entry,\n    componentValue,\n    { key, joinModel, componentModel, transacting }\n  ) {\n    const componentArr = Array.isArray(componentValue) ? componentValue : [componentValue];\n\n    const idsToKeep = componentArr\n      .filter(el => _.has(el, componentModel.primaryKey))\n      .map(el => el[componentModel.primaryKey].toString());\n\n    const allIds = await joinModel\n      .where({\n        [joinModel.foreignKey]: entry.id,\n        field: key,\n      })\n      .fetchAll({ transacting })\n      .map(el => el.get('component_id').toString());\n\n    // verify the provided ids are related to this entity.\n    idsToKeep.forEach(id => {\n      if (!allIds.includes(id)) {\n        const err = new Error(\n          `Some of the provided components in ${key} are not related to the entity`\n        );\n        err.status = 400;\n        throw err;\n      }\n    });\n\n    const idsToDelete = _.difference(allIds, idsToKeep);\n    if (idsToDelete.length > 0) {\n      await joinModel\n        .query(qb => qb.whereIn('component_id', idsToDelete).andWhere('field', key))\n        .destroy({ transacting, require: false });\n\n      await strapi\n        .query(componentModel.uid)\n        .delete({ [`${componentModel.primaryKey}_in`]: idsToDelete }, { transacting });\n    }\n  }\n\n  async function deleteComponents(entry, { transacting }) {\n    if (componentKeys.length === 0) return;\n\n    const joinModel = model.componentsJoinModel;\n    const { foreignKey } = joinModel;\n\n    for (let key of componentKeys) {\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      switch (type) {\n        case 'component': {\n          const { component } = attr;\n\n          const componentModel = strapi.components[component];\n\n          const ids = await joinModel\n            .where({\n              [foreignKey]: entry.id,\n              field: key,\n            })\n            .fetchAll({ transacting })\n            .map(el => el.get('component_id'));\n\n          await strapi\n            .query(componentModel.uid)\n            .delete({ [`${componentModel.primaryKey}_in`]: ids }, { transacting });\n\n          await joinModel\n            .where({\n              [foreignKey]: entry.id,\n              field: key,\n            })\n            .destroy({ transacting, require: false });\n          break;\n        }\n        case 'dynamiczone': {\n          const { components } = attr;\n\n          const componentJoins = await joinModel\n            .where({\n              [foreignKey]: entry.id,\n              field: key,\n            })\n            .fetchAll({ transacting })\n            .map(el => ({\n              id: el.get('component_id'),\n              componentType: el.get('component_type'),\n            }));\n\n          for (const compo of components) {\n            const { uid, collectionName } = strapi.components[compo];\n            const model = strapi.query(uid);\n\n            const toDelete = componentJoins.filter(el => el.componentType === collectionName);\n\n            if (toDelete.length > 0) {\n              await model.delete(\n                {\n                  [`${model.primaryKey}_in`]: toDelete.map(el => el.id),\n                },\n                { transacting }\n              );\n            }\n          }\n\n          await joinModel\n            .where({\n              [foreignKey]: entry.id,\n              field: key,\n            })\n            .destroy({ transacting, require: false });\n\n          break;\n        }\n      }\n    }\n  }\n\n  async function fetchRelationCounters(attribute, entitiesIds = []) {\n    const assoc = model.associations.find(assoc => assoc.alias === attribute);\n    const assocModel = strapi.db.getModelByAssoc(assoc);\n    const knex = strapi.connections[model.connection];\n    const targetAttribute = assocModel.attributes[assoc.via];\n\n    switch (assoc.nature) {\n      case 'oneToMany': {\n        return knex\n          .select()\n          .column({ id: assoc.via, count: knex.raw('count(*)') })\n          .from(assocModel.collectionName)\n          .whereIn(assoc.via, entitiesIds)\n          .groupBy(assoc.via);\n      }\n      case 'manyWay': {\n        const column = `${singular(model.collectionName)}_${model.primaryKey}`;\n        return knex\n          .select()\n          .column({ id: column, count: knex.raw('count(*)') })\n          .from(assoc.tableCollectionName)\n          .whereIn(column, entitiesIds)\n          .groupBy(column);\n      }\n      case 'manyToMany': {\n        const column = `${targetAttribute.attribute}_${targetAttribute.column}`;\n        return knex\n          .select()\n          .column({ id: column, count: knex.raw('count(*)') })\n          .from(assoc.tableCollectionName)\n          .whereIn(column, entitiesIds)\n          .groupBy(column);\n      }\n      default: {\n        return [];\n      }\n    }\n  }\n\n  return {\n    findOne,\n    find,\n    create: wrapErrors(create),\n    update: wrapErrors(update),\n    delete: deleteMany,\n    count,\n    search,\n    countSearch,\n    fetchRelationCounters,\n  };\n};\n\n/**\n * util to build search query\n * @param {*} model\n * @param {*} params\n */\nconst buildSearchQuery = ({ model, params }) => qb => {\n  const query = params._q;\n\n  const associations = model.associations.map(x => x.alias);\n  const stringTypes = ['string', 'text', 'uid', 'email', 'enumeration', 'richtext'];\n  const numberTypes = ['biginteger', 'integer', 'decimal', 'float'];\n\n  const searchColumns = Object.keys(model._attributes)\n    .filter(attribute => !associations.includes(attribute))\n    .filter(attribute => stringTypes.includes(model._attributes[attribute].type));\n\n  if (!_.isNaN(_.toNumber(query))) {\n    const numberColumns = Object.keys(model._attributes)\n      .filter(attribute => !associations.includes(attribute))\n      .filter(attribute => numberTypes.includes(model._attributes[attribute].type));\n    searchColumns.push(...numberColumns);\n  }\n\n  if ([...numberTypes, ...stringTypes].includes(model.primaryKeyType)) {\n    searchColumns.push(model.primaryKey);\n  }\n\n  // Search in columns with text using index.\n  switch (model.client) {\n    case 'pg':\n      searchColumns.forEach(attr =>\n        qb.orWhereRaw(\n          `\"${model.collectionName}\".\"${attr}\"::text ILIKE ?`,\n          `%${escapeQuery(query, '*%\\\\')}%`\n        )\n      );\n      break;\n    case 'sqlite3':\n      searchColumns.forEach(attr =>\n        qb.orWhereRaw(\n          `\"${model.collectionName}\".\"${attr}\" LIKE ? ESCAPE '\\\\'`,\n          `%${escapeQuery(query, '*%\\\\')}%`\n        )\n      );\n      break;\n    case 'mysql':\n      searchColumns.forEach(attr =>\n        qb.orWhereRaw(\n          `\\`${model.collectionName}\\`.\\`${attr}\\` LIKE ?`,\n          `%${escapeQuery(query, '*%\\\\')}%`\n        )\n      );\n      break;\n  }\n};\n",
    "packages/strapi-connector-bookshelf/lib/relations.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst _ = require('lodash');\n\n// Utils\nconst {\n  models: { getValuePrimaryKey },\n} = require('strapi-utils');\n\nconst transformToArrayID = array => {\n  if (_.isArray(array)) {\n    return array\n      .map(value => _.get(value, 'id') || value)\n      .filter(n => n)\n      .map(val => _.toString(val));\n  }\n\n  return transformToArrayID([array]);\n};\n\nconst removeUndefinedKeys = obj => _.pickBy(obj, _.negate(_.isUndefined));\n\nconst addRelationMorph = async (model, { params, transacting } = {}) => {\n  return await model.morph.forge().save(\n    {\n      [`${model.collectionName}_id`]: params.id,\n      [`${params.alias}_id`]: params.refId,\n      [`${params.alias}_type`]: params.ref,\n      field: params.field,\n      order: params.order,\n    },\n    { transacting }\n  );\n};\n\nconst removeRelationMorph = async (model, { params, transacting } = {}) => {\n  return await model.morph\n    .forge()\n    .where(\n      _.omitBy(\n        {\n          [`${model.collectionName}_id`]: params.id,\n          [`${params.alias}_id`]: params.refId,\n          [`${params.alias}_type`]: params.ref,\n          field: params.field,\n        },\n        _.isUndefined\n      )\n    )\n    .destroy({\n      require: false,\n      transacting,\n    });\n};\n\nmodule.exports = {\n  async findOne(params, populate, { transacting } = {}) {\n    const record = await this.forge({\n      [this.primaryKey]: getValuePrimaryKey(params, this.primaryKey),\n    }).fetch({\n      transacting,\n      withRelated: populate,\n    });\n\n    const data = record ? record.toJSON() : record;\n\n    // Retrieve data manually.\n    if (_.isEmpty(populate)) {\n      const arrayOfPromises = this.associations\n        .filter(association => ['manyMorphToOne', 'manyMorphToMany'].includes(association.nature))\n        .map(() => {\n          return this.morph\n            .forge()\n            .where({\n              [`${this.collectionName}_id`]: getValuePrimaryKey(params, this.primaryKey),\n            })\n            .fetchAll({\n              transacting,\n            });\n        });\n\n      const related = await Promise.all(arrayOfPromises);\n\n      related.forEach((value, index) => {\n        data[this.associations[index].alias] = value ? value.toJSON() : value;\n      });\n    }\n\n    return data;\n  },\n\n  async update(params, { transacting } = {}) {\n    const relationUpdates = [];\n    const primaryKeyValue = getValuePrimaryKey(params, this.primaryKey);\n    const response = await module.exports.findOne.call(this, params, null, {\n      transacting,\n    });\n\n    // Only update fields which are on this document.\n    const values = Object.keys(removeUndefinedKeys(params.values)).reduce((acc, current) => {\n      const property = params.values[current];\n      const association = this.associations.filter(x => x.alias === current)[0];\n      const details = this._attributes[current];\n\n      if (!association && _.get(details, 'isVirtual') !== true) {\n        return _.set(acc, current, property);\n      }\n\n      const assocModel = strapi.db.getModel(details.model || details.collection, details.plugin);\n\n      switch (association.nature) {\n        case 'oneWay': {\n          return _.set(acc, current, _.get(property, assocModel.primaryKey, property));\n        }\n        case 'oneToOne': {\n          if (response[current] === property) return acc;\n\n          if (_.isNull(property)) {\n            const updatePromise = assocModel\n              .where({\n                [assocModel.primaryKey]: getValuePrimaryKey(\n                  response[current],\n                  assocModel.primaryKey\n                ),\n              })\n              .save(\n                { [details.via]: null },\n                {\n                  method: 'update',\n                  patch: true,\n                  require: false,\n                  transacting,\n                }\n              );\n\n            relationUpdates.push(updatePromise);\n            return _.set(acc, current, null);\n          }\n\n          // set old relations to null\n          const updateLink = this.where({ [current]: property })\n            .save(\n              { [current]: null },\n              {\n                method: 'update',\n                patch: true,\n                require: false,\n                transacting,\n              }\n            )\n            .then(() => {\n              return assocModel.where({ [this.primaryKey]: property }).save(\n                { [details.via]: primaryKeyValue },\n                {\n                  method: 'update',\n                  patch: true,\n                  require: false,\n                  transacting,\n                }\n              );\n            });\n\n          // set new relation\n          relationUpdates.push(updateLink);\n          return _.set(acc, current, property);\n        }\n        case 'oneToMany': {\n          // receive array of ids or array of objects with ids\n\n          // set relation to null for all the ids not in the list\n          const currentIds = response[current];\n          const toRemove = _.differenceWith(currentIds, property, (a, b) => {\n            return `${a[assocModel.primaryKey] || a}` === `${b[assocModel.primaryKey] || b}`;\n          });\n\n          const updatePromise = assocModel\n            .where(\n              assocModel.primaryKey,\n              'in',\n              toRemove.map(val => val[assocModel.primaryKey] || val)\n            )\n            .save(\n              { [details.via]: null },\n              {\n                method: 'update',\n                patch: true,\n                require: false,\n                transacting,\n              }\n            )\n            .then(() => {\n              return assocModel\n                .where(\n                  assocModel.primaryKey,\n                  'in',\n                  property.map(val => val[assocModel.primaryKey] || val)\n                )\n                .save(\n                  { [details.via]: primaryKeyValue },\n                  {\n                    method: 'update',\n                    patch: true,\n                    require: false,\n                    transacting,\n                  }\n                );\n            });\n\n          relationUpdates.push(updatePromise);\n          return acc;\n        }\n        case 'manyToOne': {\n          return _.set(acc, current, _.get(property, assocModel.primaryKey, property));\n        }\n        case 'manyWay':\n        case 'manyToMany': {\n          const storedValue = transformToArrayID(response[current]);\n          const currentValue = transformToArrayID(params.values[current]);\n\n          const toAdd = _.difference(currentValue, storedValue);\n          const toRemove = _.difference(storedValue, currentValue);\n\n          const collection = this.forge({\n            [this.primaryKey]: primaryKeyValue,\n          })[association.alias]();\n\n          const updatePromise = collection\n            .detach(toRemove, { transacting })\n            .then(() => collection.attach(toAdd, { transacting }));\n\n          relationUpdates.push(updatePromise);\n          return acc;\n        }\n        // media -> model\n        case 'manyMorphToMany':\n        case 'manyMorphToOne': {\n          // Update the relational array.\n          const refs = params.values[current];\n\n          if (Array.isArray(refs) && refs.length === 0) {\n            // clear related\n            relationUpdates.push(\n              removeRelationMorph(this, { params: { id: primaryKeyValue }, transacting })\n            );\n            break;\n          }\n\n          refs.forEach(obj => {\n            const targetModel = strapi.db.getModel(\n              obj.ref,\n              obj.source !== 'content-manager' ? obj.source : null\n            );\n\n            const reverseAssoc = targetModel.associations.find(assoc => assoc.alias === obj.field);\n\n            // Remove existing relationship because only one file\n            // can be related to this field.\n            if (reverseAssoc && reverseAssoc.nature === 'oneToManyMorph') {\n              relationUpdates.push(\n                removeRelationMorph(this, {\n                  params: {\n                    alias: association.alias,\n                    ref: targetModel.collectionName,\n                    refId: obj.refId,\n                    field: obj.field,\n                  },\n                  transacting,\n                }).then(() =>\n                  addRelationMorph(this, {\n                    params: {\n                      id: response[this.primaryKey],\n                      alias: association.alias,\n                      ref: targetModel.collectionName,\n                      refId: obj.refId,\n                      field: obj.field,\n                      order: 1,\n                    },\n                    transacting,\n                  })\n                )\n              );\n\n              return;\n            }\n\n            const addRelation = async () => {\n              const maxOrder = await this.morph\n                .query(qb => {\n                  qb.max('order as order').where({\n                    [`${association.alias}_id`]: obj.refId,\n                    [`${association.alias}_type`]: targetModel.collectionName,\n                    field: obj.field,\n                  });\n                })\n                .fetch({ transacting });\n\n              const { order = 0 } = maxOrder.toJSON();\n\n              await addRelationMorph(this, {\n                params: {\n                  id: response[this.primaryKey],\n                  alias: association.alias,\n                  ref: targetModel.collectionName,\n                  refId: obj.refId,\n                  field: obj.field,\n                  order: order + 1,\n                },\n                transacting,\n              });\n            };\n\n            relationUpdates.push(addRelation());\n          });\n          break;\n        }\n        // model -> media\n        case 'oneToManyMorph':\n        case 'manyToManyMorph': {\n          const currentValue = transformToArrayID(params.values[current]);\n\n          const model = strapi.db.getModel(details.collection || details.model, details.plugin);\n\n          const promise = removeRelationMorph(model, {\n            params: {\n              alias: association.via,\n              ref: this.collectionName,\n              refId: response.id,\n              field: association.alias,\n            },\n            transacting,\n          }).then(() => {\n            return Promise.all(\n              currentValue.map((id, idx) => {\n                return addRelationMorph(model, {\n                  params: {\n                    id,\n                    alias: association.via,\n                    ref: this.collectionName,\n                    refId: response.id,\n                    field: association.alias,\n                    order: idx + 1,\n                  },\n                  transacting,\n                });\n              })\n            );\n          });\n\n          relationUpdates.push(promise);\n\n          break;\n        }\n        case 'oneMorphToOne':\n        case 'oneMorphToMany': {\n          break;\n        }\n        default:\n      }\n\n      return acc;\n    }, {});\n\n    await Promise.all(relationUpdates);\n\n    delete values[this.primaryKey];\n    if (!_.isEmpty(values)) {\n      await this.forge({\n        [this.primaryKey]: getValuePrimaryKey(params, this.primaryKey),\n      }).save(values, {\n        patch: true,\n        transacting,\n      });\n    }\n\n    const result = await this.forge({\n      [this.primaryKey]: getValuePrimaryKey(params, this.primaryKey),\n    }).fetch({\n      transacting,\n    });\n\n    return result && result.toJSON ? result.toJSON() : result;\n  },\n\n  deleteRelations(id, { transacting }) {\n    const values = {};\n\n    this.associations.map(association => {\n      switch (association.nature) {\n        case 'oneWay':\n        case 'oneToOne':\n        case 'manyToOne':\n        case 'oneToManyMorph':\n          values[association.alias] = null;\n          break;\n        case 'manyWay':\n        case 'oneToMany':\n        case 'manyToMany':\n        case 'manyToManyMorph':\n        case 'manyMorphToMany':\n        case 'manyMorphToOne':\n          values[association.alias] = [];\n          break;\n        default:\n      }\n    });\n\n    return this.updateRelations({ [this.primaryKey]: id, values }, { transacting });\n  },\n};\n",
    "packages/strapi-connector-bookshelf/lib/utils/connectivity.js": "'use strict';\n\n// Public node modules\nconst inquirer = require('inquirer');\n\nconst hasResults = rows => {\n  if (!rows || rows.length === 0) return true;\n  return false;\n};\n\nconst checkDatabaseIsEmpty = {\n  postgres: client =>\n    client\n      .select('tablename')\n      .from('pg_tables')\n      .where('schemaname', 'public')\n      .then(hasResults),\n\n  mysql: (client, { database }) =>\n    client\n      .select()\n      .from('information_schema.tables')\n      .where('table_schema', database)\n      .then(hasResults),\n\n  sqlite: client =>\n    client\n      .select()\n      .from('sqlite_master')\n      .then(hasResults),\n};\n\nmodule.exports = async ({ scope, connection }) => {\n  const knex = require('knex');\n\n  const { settings } = connection;\n  const client = knex({\n    client: settings.client,\n    connection: Object.assign({}, settings, {\n      user: settings.username,\n    }),\n    useNullAsDefault: true,\n  });\n\n  const destroyClientAndThrow = err => {\n    return client.destroy().then(\n      () => {\n        throw err;\n      },\n      () => {\n        throw err;\n      }\n    );\n  };\n\n  await client.raw('select 1+1 as result').catch(destroyClientAndThrow);\n\n  return checkDatabaseIsEmpty[settings.client](client, settings)\n    .then(isEmpty => {\n      if (isEmpty) return;\n      if (scope.dbforce) return;\n\n      console.log();\n      console.error(\n        'It seems that your database is not empty.\\nStrapi automatically creates tables and columns which might corrupt the data already present in your database.'\n      );\n\n      return inquirer\n        .prompt([\n          {\n            type: 'confirm',\n            name: 'confirm',\n            message: `Are you sure you want to continue with the ${settings.database} database:`,\n          },\n        ])\n        .then(({ confirm }) => {\n          // send restart flag to retry\n          if (!confirm) return { shouldRetry: true };\n        });\n    })\n    .then(res => client.destroy().then(() => res))\n    .catch(destroyClientAndThrow);\n};\n",
    "packages/strapi-connector-bookshelf/lib/utils/store-definition.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst formatDefinitionToStore = definition =>\n  JSON.stringify(\n    _.pick(definition, ['uid', 'collectionName', 'kind', 'info', 'options', 'attributes'])\n  );\n\nconst getDefinitionFromStore = async (definition, ORM) => {\n  const coreStoreExists = await ORM.knex.schema.hasTable('core_store');\n\n  if (!coreStoreExists) {\n    return undefined;\n  }\n\n  const def = await strapi.models['core_store']\n    .forge({ key: `model_def_${definition.uid}` })\n    .fetch();\n\n  return def ? def.toJSON() : undefined;\n};\n\nconst storeDefinition = async (definition, ORM) => {\n  const defToStore = formatDefinitionToStore(definition);\n  const existingDef = await getDefinitionFromStore(definition, ORM);\n\n  const defData = {\n    key: `model_def_${definition.uid}`,\n    type: 'object',\n    value: defToStore,\n  };\n\n  if (existingDef) {\n    return strapi.models['core_store'].forge({ id: existingDef.id }).save(defData);\n  }\n\n  return strapi.models['core_store'].forge(defData).save();\n};\n\nconst getColumnsWhereDefinitionChanged = async (columnsName, definition, ORM) => {\n  const previousDefinitionRow = await getDefinitionFromStore(definition, ORM);\n  const previousDefinition = JSON.parse(_.get(previousDefinitionRow, 'value', null));\n\n  return columnsName.filter(columnName => {\n    const previousAttribute = _.get(previousDefinition, ['attributes', columnName], null);\n    const actualAttribute = _.get(definition, ['attributes', columnName], null);\n\n    return !_.isEqual(previousAttribute, actualAttribute);\n  });\n};\n\nmodule.exports = {\n  storeDefinition,\n  getDefinitionFromStore,\n  getColumnsWhereDefinitionChanged,\n};\n",
    "packages/strapi-connector-mongoose/lib/database-migration.js": "'use strict';\n\nconst _ = require('lodash');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\n\nconst { PUBLISHED_AT_ATTRIBUTE } = contentTypesUtils.constants;\nconst { getDefinitionFromStore } = require('./utils/store-definition');\n\nconst getDraftAndPublishMigrationWay = async (definition, ORM) => {\n  const previousDefRow = await getDefinitionFromStore(definition, ORM);\n  const previousDef = JSON.parse(_.get(previousDefRow, 'value', null));\n  const previousDraftAndPublish = contentTypesUtils.hasDraftAndPublish(previousDef);\n  const actualDraftAndPublish = contentTypesUtils.hasDraftAndPublish(definition);\n\n  if (!previousDefRow || previousDraftAndPublish === actualDraftAndPublish) {\n    return 'none';\n  }\n  if (!previousDraftAndPublish && actualDraftAndPublish) {\n    return 'enable';\n  }\n  if (previousDraftAndPublish && !actualDraftAndPublish) {\n    return 'disable';\n  }\n};\n\nconst migrateDraftAndPublish = async ({ definition, model, ORM }) => {\n  let way = await getDraftAndPublishMigrationWay(definition, ORM);\n\n  if (way === 'enable') {\n    const createdAtCol = _.get(definition, 'timestamps.createdAt', 'createdAt');\n    await model\n      .aggregate([\n        {\n          $addFields: {\n            [PUBLISHED_AT_ATTRIBUTE]: { $ifNull: [`$${createdAtCol}`, new Date()] },\n          },\n        },\n        {\n          $out: definition.collectionName,\n        },\n      ])\n      .exec();\n  } else if (way === 'disable') {\n    await model.deleteMany({ [PUBLISHED_AT_ATTRIBUTE]: null });\n    await model.updateMany({}, { $unset: { [PUBLISHED_AT_ATTRIBUTE]: '' } }, { strict: false });\n  }\n};\n\nmodule.exports = {\n  migrateDraftAndPublish,\n};\n",
    "packages/strapi-connector-mongoose/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst path = require('path');\nconst fs = require('fs');\nconst url = require('url');\nconst _ = require('lodash');\nconst mongoose = require('mongoose');\nrequire('mongoose-long')(mongoose);\n\nconst Mongoose = mongoose.Mongoose;\n\nconst relations = require('./relations');\nconst buildQuery = require('./buildQuery');\nconst getQueryParams = require('./get-query-params');\nconst mountModels = require('./mount-models');\nconst queries = require('./queries');\n\n/**\n * Mongoose hook\n */\n\nconst defaults = {\n  defaultConnection: 'default',\n  host: 'localhost',\n  port: 27017,\n  database: 'strapi',\n  authenticationDatabase: '',\n  ssl: false,\n  debug: false,\n};\n\nconst isMongooseConnection = ({ connector }) => connector === 'mongoose';\n\nconst createConnectionURL = opts => {\n  const { protocol, auth, host, port } = opts;\n\n  return {\n    toString() {\n      return `${protocol}://${auth}${host}${port}/`;\n    },\n  };\n};\n\nmodule.exports = function(strapi) {\n  const { connections } = strapi.config;\n  const mongooseConnections = Object.keys(connections).filter(key =>\n    isMongooseConnection(connections[key])\n  );\n\n  function initialize() {\n    const connectionsPromises = mongooseConnections.map(async connectionName => {\n      const connection = connections[connectionName];\n      const instance = new Mongoose();\n\n      _.defaults(connection.settings, strapi.config.hook.settings.mongoose);\n\n      const {\n        uri,\n        host,\n        port,\n        username,\n        password,\n        database,\n        srv,\n        useUnifiedTopology,\n      } = connection.settings;\n\n      // eslint-disable-next-line node/no-deprecated-api\n      const uriOptions = uri ? url.parse(uri, true).query : {};\n      const { authenticationDatabase, ssl, debug } = _.defaults(\n        connection.options,\n        uriOptions,\n        strapi.config.hook.settings.mongoose\n      );\n      const isSrv = srv === true || srv === 'true';\n\n      // Connect to mongo database\n      const connectOptions = {};\n\n      if (!_.isEmpty(username)) {\n        connectOptions.user = username;\n\n        if (!_.isEmpty(password)) {\n          connectOptions.pass = password;\n        }\n      }\n\n      if (!_.isEmpty(authenticationDatabase)) {\n        connectOptions.authSource = authenticationDatabase;\n      }\n\n      connectOptions.ssl = ssl === true || ssl === 'true';\n      connectOptions.useNewUrlParser = true;\n      connectOptions.dbName = database;\n      connectOptions.useCreateIndex = true;\n      connectOptions.useUnifiedTopology = useUnifiedTopology || true;\n\n      try {\n        const connectionURL = createConnectionURL({\n          protocol: `mongodb${isSrv ? '+srv' : ''}`,\n          port: isSrv ? '' : `:${port}`,\n          host,\n          auth: username ? `${username}:${encodeURIComponent(password)}@` : '',\n        });\n\n        const connectionString = uri || connectionURL.toString();\n\n        await instance.connect(connectionString, connectOptions);\n      } catch (error) {\n        const err = new Error(`Error connecting to the Mongo database. ${error.message}`);\n        delete err.stack;\n        throw err;\n      }\n\n      try {\n        const { version } = await instance.connection.db.admin().serverInfo();\n        instance.mongoDBVersion = version;\n      } catch {\n        instance.mongoDBVersion = null;\n      }\n\n      const initFunctionPath = path.resolve(\n        strapi.config.appPath,\n        'config',\n        'functions',\n        'mongoose.js'\n      );\n\n      if (fs.existsSync(initFunctionPath)) {\n        require(initFunctionPath)(instance, connection);\n      }\n\n      instance.set('debug', debug === true || debug === 'true');\n      instance.set('useFindAndModify', false);\n\n      const ctx = {\n        instance,\n        connection,\n      };\n\n      _.set(strapi, `connections.${connectionName}`, instance);\n\n      return Promise.all([\n        mountComponents(connectionName, ctx),\n        mountApis(connectionName, ctx),\n        mountAdmin(connectionName, ctx),\n        mountPlugins(connectionName, ctx),\n      ]);\n    });\n\n    return Promise.all(connectionsPromises);\n  }\n\n  function mountComponents(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(strapi.components, ({ connection }) => connection === connectionName),\n      target: strapi.components,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountApis(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(strapi.models, ({ connection }) => connection === connectionName),\n      target: strapi.models,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountAdmin(connectionName, ctx) {\n    const options = {\n      models: _.pickBy(strapi.admin.models, ({ connection }) => connection === connectionName),\n      target: strapi.admin.models,\n    };\n\n    return mountModels(options, ctx);\n  }\n\n  function mountPlugins(connectionName, ctx) {\n    return Promise.all(\n      Object.keys(strapi.plugins).map(name => {\n        const plugin = strapi.plugins[name];\n        return mountModels(\n          {\n            models: _.pickBy(plugin.models, ({ connection }) => connection === connectionName),\n            target: plugin.models,\n          },\n          ctx\n        );\n      })\n    );\n  }\n\n  async function destroy() {\n    await Promise.all(\n      mongooseConnections.map(connName => {\n        const mongooseConnection = strapi.connections[connName];\n\n        if (\n          mongooseConnection instanceof Mongoose &&\n          mongooseConnection.connection.readyState === 1\n        ) {\n          mongooseConnection.disconnect();\n        }\n      })\n    );\n  }\n\n  return {\n    defaults,\n    initialize,\n    getQueryParams,\n    destroy,\n    buildQuery,\n    queries,\n    ...relations,\n    get defaultTimestamps() {\n      return ['createdAt', 'updatedAt'];\n    },\n  };\n};\n",
    "packages/strapi-connector-mongoose/lib/queries.js": "'use strict';\n/**\n * Implementation of model queries for mongo\n */\n\nconst _ = require('lodash');\nconst { prop, omit } = require('lodash/fp');\nconst { convertRestQueryParams, buildQuery } = require('strapi-utils');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\nconst mongoose = require('mongoose');\n\nconst populateQueries = require('./utils/populate-queries');\n\nconst { PUBLISHED_AT_ATTRIBUTE, DP_PUB_STATES } = contentTypesUtils.constants;\nconst { findComponentByGlobalId } = require('./utils/helpers');\nconst { handleDatabaseError } = require('./utils/errors');\n\nconst hasPK = (obj, model) => _.has(obj, model.primaryKey) || _.has(obj, 'id');\nconst getPK = (obj, model) => (_.has(obj, model.primaryKey) ? obj[model.primaryKey] : obj.id);\nconst pickCountFilters = omit(['sort', 'limit', 'start']);\n\nmodule.exports = ({ model, strapi }) => {\n  const assocKeys = model.associations.map(ast => ast.alias);\n  const componentKeys = Object.keys(model.attributes).filter(key =>\n    ['component', 'dynamiczone'].includes(model.attributes[key].type)\n  );\n  const hasDraftAndPublish = contentTypesUtils.hasDraftAndPublish(model);\n\n  const excludedKeys = assocKeys.concat(componentKeys);\n\n  const defaultPopulate = (options = {}) =>\n    model.associations\n      .filter(ast => ast.autoPopulate !== false)\n      .map(ast => {\n        const assocModel = strapi.db.getModelByAssoc(ast);\n        const populate = {\n          path: ast.alias,\n          options: { publicationState: options.publicationState },\n        };\n\n        if (\n          contentTypesUtils.hasDraftAndPublish(assocModel) &&\n          DP_PUB_STATES.includes(options.publicationState)\n        ) {\n          populate.match = _.merge(\n            populate.match,\n            populateQueries.publicationState[options.publicationState]\n          );\n        }\n\n        return populate;\n      });\n\n  const pickRelations = values => {\n    return _.pick(values, assocKeys);\n  };\n\n  const omitExernalValues = values => {\n    return _.omit(values, excludedKeys);\n  };\n\n  const wrapErrors = fn => async (...args) => {\n    try {\n      return await fn(...args);\n    } catch (error) {\n      return handleDatabaseError(error);\n    }\n  };\n\n  async function createComponents(entry, values, { isDraft, session = null } = {}) {\n    if (componentKeys.length === 0) return;\n\n    for (let key of componentKeys) {\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      if (type === 'component') {\n        const { component, required = false, repeatable = false } = attr;\n\n        const componentModel = strapi.components[component];\n\n        if (!isDraft && required === true && !_.has(values, key)) {\n          const err = new Error(`Component ${key} is required`);\n          err.status = 400;\n          throw err;\n        }\n\n        if (!_.has(values, key)) continue;\n\n        const componentValue = values[key];\n\n        if (repeatable === true) {\n          const components = await Promise.all(\n            componentValue.map(value => {\n              return strapi.query(component).create(value, { session });\n            })\n          );\n\n          const componentsArr = components.map(componentEntry => ({\n            kind: componentModel.globalId,\n            ref: componentEntry.id,\n          }));\n\n          entry[key] = componentsArr;\n          await entry.save({ session });\n        } else {\n          if (componentValue === null) continue;\n\n          const componentEntry = await strapi.query(component).create(componentValue, { session });\n          entry[key] = [\n            {\n              kind: componentModel.globalId,\n              ref: componentEntry.id,\n            },\n          ];\n          await entry.save({ session });\n        }\n      }\n\n      if (type === 'dynamiczone') {\n        const { required = false } = attr;\n\n        if (!isDraft && required === true && !_.has(values, key)) {\n          const err = new Error(`Dynamiczone ${key} is required`);\n          err.status = 400;\n          throw err;\n        }\n\n        if (!_.has(values, key)) continue;\n\n        const dynamiczoneValues = values[key];\n\n        const dynamiczones = await Promise.all(\n          dynamiczoneValues.map(value => {\n            const component = value.__component;\n            return strapi\n              .query(component)\n              .create(value, { session })\n              .then(entity => {\n                return {\n                  __component: value.__component,\n                  entity,\n                };\n              });\n          })\n        );\n\n        const componentsArr = dynamiczones.map(({ __component, entity }) => {\n          const componentModel = strapi.components[__component];\n\n          return {\n            kind: componentModel.globalId,\n            ref: entity.id,\n          };\n        });\n\n        entry[key] = componentsArr;\n        await entry.save({ session });\n      }\n    }\n  }\n\n  async function updateComponents(entry, values, { session = null } = {}) {\n    if (componentKeys.length === 0) return;\n\n    const updateOrCreateComponent = async ({ componentUID, value }) => {\n      // check if value has an id then update else create\n      const query = strapi.query(componentUID);\n      if (hasPK(value, query.model)) {\n        return query.update(\n          {\n            [query.model.primaryKey]: getPK(value, query.model),\n          },\n          value,\n          { session }\n        );\n      }\n      return query.create(value, { session });\n    };\n\n    for (let key of componentKeys) {\n      // if key isn't present then don't change the current component data\n      if (!_.has(values, key)) continue;\n\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      if (type === 'component') {\n        const { component: componentUID, repeatable = false } = attr;\n\n        const componentModel = strapi.components[componentUID];\n        const componentValue = values[key];\n\n        if (repeatable === true) {\n          await deleteOldComponents(entry, componentValue, {\n            key,\n            componentModel,\n            session,\n          });\n\n          const components = await Promise.all(\n            componentValue.map(value => updateOrCreateComponent({ componentUID, value }))\n          );\n          const componentsArr = components.map(component => ({\n            kind: componentModel.globalId,\n            ref: component.id,\n          }));\n\n          entry[key] = componentsArr;\n          await entry.save({ session });\n        } else {\n          await deleteOldComponents(entry, componentValue, {\n            key,\n            componentModel,\n            session,\n          });\n\n          if (componentValue === null) continue;\n\n          const component = await updateOrCreateComponent({\n            componentUID,\n            value: componentValue,\n          });\n\n          entry[key] = [\n            {\n              kind: componentModel.globalId,\n              ref: component.id,\n            },\n          ];\n          await entry.save({ session });\n        }\n      }\n\n      if (type === 'dynamiczone') {\n        const dynamiczoneValues = values[key];\n\n        await deleteDynamicZoneOldComponents(entry, dynamiczoneValues, {\n          key,\n          session,\n        });\n\n        const dynamiczones = await Promise.all(\n          dynamiczoneValues.map(value => {\n            const componentUID = value.__component;\n            return updateOrCreateComponent({ componentUID, value }).then(entity => {\n              return {\n                componentUID,\n                entity,\n              };\n            });\n          })\n        );\n\n        const componentsArr = dynamiczones.map(({ componentUID, entity }) => {\n          const componentModel = strapi.components[componentUID];\n\n          return {\n            kind: componentModel.globalId,\n            ref: entity.id,\n          };\n        });\n\n        entry[key] = componentsArr;\n        await entry.save({ session });\n      }\n    }\n    return;\n  }\n\n  async function deleteDynamicZoneOldComponents(entry, values, { key, session = null }) {\n    const idsToKeep = values.reduce((acc, value) => {\n      const component = value.__component;\n      const componentModel = strapi.components[component];\n      if (hasPK(value, componentModel)) {\n        acc.push({\n          id: getPK(value, componentModel).toString(),\n          componentUID: componentModel.uid,\n        });\n      }\n\n      return acc;\n    }, []);\n\n    const allIds = []\n      .concat(entry[key] || [])\n      .filter(el => el.ref)\n      .map(el => ({\n        id: el.ref._id.toString(),\n        componentUID: findComponentByGlobalId(el.kind).uid,\n      }));\n\n    // verify the provided ids are realted to this entity.\n    idsToKeep.forEach(({ id, componentUID }) => {\n      if (!allIds.find(el => el.id === id && el.componentUID === componentUID)) {\n        const err = new Error(\n          `Some of the provided components in ${key} are not related to the entity`\n        );\n        err.status = 400;\n        throw err;\n      }\n    });\n\n    const idsToDelete = allIds.reduce((acc, { id, componentUID }) => {\n      if (!idsToKeep.find(el => el.id === id && el.componentUID === componentUID)) {\n        acc.push({\n          id,\n          componentUID,\n        });\n      }\n      return acc;\n    }, []);\n\n    if (idsToDelete.length > 0) {\n      const deleteMap = idsToDelete.reduce((map, { id, componentUID }) => {\n        if (!_.has(map, componentUID)) {\n          map[componentUID] = [id];\n          return map;\n        }\n\n        map[componentUID].push(id);\n        return map;\n      }, {});\n\n      await Promise.all(\n        Object.keys(deleteMap).map(componentUID => {\n          return strapi\n            .query(componentUID)\n            .delete({ [`${model.primaryKey}_in`]: deleteMap[componentUID] }, { session });\n        })\n      );\n    }\n  }\n\n  async function deleteOldComponents(\n    entry,\n    componentValue,\n    { key, componentModel, session = null }\n  ) {\n    const componentArr = Array.isArray(componentValue) ? componentValue : [componentValue];\n\n    const idsToKeep = componentArr\n      .filter(val => hasPK(val, componentModel))\n      .map(val => getPK(val, componentModel));\n\n    const allIds = []\n      .concat(entry[key] || [])\n      .filter(el => el.ref)\n      .map(el => el.ref._id);\n\n    // verify the provided ids are related to this entity.\n    idsToKeep.forEach(id => {\n      if (allIds.findIndex(currentId => currentId.toString() === id.toString()) === -1) {\n        const err = new Error(\n          `Some of the provided components in ${key} are not related to the entity`\n        );\n        err.status = 400;\n        throw err;\n      }\n    });\n\n    const idsToDelete = allIds.reduce((acc, id) => {\n      if (idsToKeep.includes(id.toString())) return acc;\n      return acc.concat(id);\n    }, []);\n\n    if (idsToDelete.length > 0) {\n      await strapi\n        .query(componentModel.uid)\n        .delete({ [`${model.primaryKey}_in`]: idsToDelete }, { session });\n    }\n  }\n\n  async function deleteComponents(entry, { session = null } = {}) {\n    if (componentKeys.length === 0) return;\n\n    for (let key of componentKeys) {\n      const attr = model.attributes[key];\n      const { type } = attr;\n\n      if (type === 'component') {\n        const { component } = attr;\n        const componentModel = strapi.components[component];\n\n        if (Array.isArray(entry[key]) && entry[key].length > 0) {\n          const idsToDelete = entry[key].map(el => el.ref);\n          await strapi\n            .query(componentModel.uid)\n            .delete({ [`${model.primaryKey}_in`]: idsToDelete }, { session });\n        }\n      }\n\n      if (type === 'dynamiczone') {\n        if (Array.isArray(entry[key]) && entry[key].length > 0) {\n          const idsToDelete = entry[key].map(el => ({\n            componentUID: findComponentByGlobalId(el.kind).uid,\n            id: el.ref,\n          }));\n\n          const deleteMap = idsToDelete.reduce((map, { id, componentUID }) => {\n            if (!_.has(map, componentUID)) {\n              map[componentUID] = [id];\n              return map;\n            }\n\n            map[componentUID].push(id);\n            return map;\n          }, {});\n\n          await Promise.all(\n            Object.keys(deleteMap).map(componentUID => {\n              return strapi.query(componentUID).delete(\n                {\n                  [`${model.primaryKey}_in`]: deleteMap[componentUID],\n                },\n                { session }\n              );\n            })\n          );\n        }\n      }\n    }\n  }\n\n  function find(params, populate, { session = null } = {}) {\n    const filters = convertRestQueryParams(params);\n    const populateOpt = populate || defaultPopulate({ publicationState: filters.publicationState });\n\n    return buildQuery({\n      model,\n      filters,\n      populate: populateOpt,\n      session,\n    }).then(results => results.map(result => (result ? result.toObject() : null)));\n  }\n\n  async function findOne(params, populate, { session = null } = {}) {\n    const entries = await find({ ...params, _limit: 1 }, populate, { session });\n    return entries[0] || null;\n  }\n\n  function count(params, { session = null } = {}) {\n    const filters = pickCountFilters(convertRestQueryParams(params));\n\n    return buildQuery({ model, filters, session }).count();\n  }\n\n  async function create(values, { session = null } = {}) {\n    // Extract values related to relational data.\n    const relations = pickRelations(values);\n    const data = omitExernalValues(values);\n\n    if (hasDraftAndPublish) {\n      data[PUBLISHED_AT_ATTRIBUTE] = _.has(values, PUBLISHED_AT_ATTRIBUTE)\n        ? values[PUBLISHED_AT_ATTRIBUTE]\n        : new Date();\n    }\n\n    /*\n      Create entry with no-relational data.\n      Note that it is mongoose requirement that you **must** pass an array as\n      the first parameter to `create()` if you want to specify options.\n      https://mongoosejs.com/docs/api.html#model_Model.create\n    */\n    const [entry] = await model.create([data], { session });\n    const isDraft = contentTypesUtils.isDraft(entry, model);\n    await createComponents(entry, values, { session, isDraft });\n\n    // Create relational data and return the entry.\n    return model.updateRelations(\n      {\n        [model.primaryKey]: getPK(entry, model),\n        values: relations,\n      },\n      { session }\n    );\n  }\n\n  async function update(params, values, { session = null } = {}) {\n    const entry = await model.findOne(params).session(session);\n\n    if (!entry) {\n      const err = new Error('entry.notFound');\n      err.status = 404;\n      throw err;\n    }\n\n    // Extract values related to relational data.\n    const relations = pickRelations(values);\n    const data = omitExernalValues(values);\n\n    // update components first in case it fails don't update the entity\n    await updateComponents(entry, values, { session });\n    // Update entry with no-relational data.\n    await entry.updateOne(data, { session });\n\n    // Update relational data and return the entry.\n    return model.updateRelations(Object.assign(params, { values: relations }), { session });\n  }\n\n  async function deleteMany(params, { session = null } = {}) {\n    if (params[model.primaryKey]) {\n      const entries = await find({ ...params, _limit: 1 }, null, { session });\n      if (entries.length > 0) {\n        return deleteOne(entries[0][model.primaryKey], { session });\n      }\n      return null;\n    }\n\n    const entries = await find(params, null, { session });\n    return Promise.all(entries.map(entry => deleteOne(entry[model.primaryKey], { session })));\n  }\n\n  async function deleteOne(id, { session = null } = {}) {\n    const entry = await model\n      .findOneAndRemove({ [model.primaryKey]: id }, { session })\n      .populate(defaultPopulate());\n\n    if (!entry) {\n      const err = new Error('entry.notFound');\n      err.status = 404;\n      throw err;\n    }\n\n    await deleteComponents(entry, { session });\n\n    await model.deleteRelations(entry, { session });\n\n    return entry.toObject ? entry.toObject() : null;\n  }\n\n  function search(params, populate, { session = null } = {}) {\n    const filters = convertRestQueryParams(_.omit(params, '_q'));\n    const populateOpt = populate || defaultPopulate({ publicationState: filters.publicationState });\n\n    return buildQuery({\n      model,\n      filters,\n      searchParam: params._q,\n      populate: populateOpt,\n      session,\n    }).then(results => results.map(result => (result ? result.toObject() : null)));\n  }\n\n  function countSearch(params, { session = null } = {}) {\n    const countParams = omit(['_q'], params);\n    const filters = pickCountFilters(convertRestQueryParams(countParams));\n\n    return buildQuery({\n      model,\n      filters,\n      searchParam: params._q,\n      session,\n    }).count();\n  }\n\n  async function fetchRelationCounters(attribute, entitiesIds = []) {\n    const assoc = model.associations.find(assoc => assoc.alias === attribute);\n\n    switch (prop('nature', assoc)) {\n      case 'oneToMany': {\n        const assocModel = strapi.db.getModelByAssoc(assoc);\n        return assocModel\n          .aggregate()\n          .match({ [assoc.via]: { $in: entitiesIds.map(mongoose.Types.ObjectId) } })\n          .group({\n            _id: `$${assoc.via}`,\n            count: { $sum: 1 },\n          })\n          .project({ _id: 0, id: '$_id', count: 1 });\n      }\n      case 'manyWay': {\n        return model\n          .aggregate()\n          .match({ [model.primaryKey]: { $in: entitiesIds.map(mongoose.Types.ObjectId) } })\n          .project({ _id: 0, id: '$_id', count: { $size: { $ifNull: [`$${assoc.alias}`, []] } } });\n      }\n      case 'manyToMany': {\n        if (assoc.dominant) {\n          return model\n            .aggregate()\n            .match({ [model.primaryKey]: { $in: entitiesIds.map(mongoose.Types.ObjectId) } })\n            .project({\n              _id: 0,\n              id: '$_id',\n              count: { $size: { $ifNull: [`$${assoc.alias}`, []] } },\n            });\n        }\n        const assocModel = strapi.db.getModelByAssoc(assoc);\n        return assocModel\n          .aggregate()\n          .match({ [assoc.via]: { $in: entitiesIds.map(mongoose.Types.ObjectId) } })\n          .unwind(assoc.via)\n          .group({ _id: `$${assoc.via}`, count: { $sum: 1 } })\n          .project({ _id: 0, id: '$_id', count: 1 });\n      }\n      default: {\n        return [];\n      }\n    }\n  }\n\n  return {\n    findOne,\n    find,\n    create: wrapErrors(create),\n    update: wrapErrors(update),\n    delete: deleteMany,\n    count,\n    search,\n    countSearch,\n    fetchRelationCounters,\n  };\n};\n",
    "packages/strapi-connector-mongoose/lib/relations.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst _ = require('lodash');\nconst mongoose = require('mongoose');\n\n// Utils\nconst {\n  models: { getValuePrimaryKey },\n} = require('strapi-utils');\n\nconst transformToArrayID = (array, pk) => {\n  if (_.isArray(array)) {\n    return array\n      .map(value => value && (getValuePrimaryKey(value, pk) || value))\n      .filter(n => n)\n      .map(val => _.toString(val));\n  }\n\n  return transformToArrayID([array]);\n};\n\nconst removeUndefinedKeys = (obj = {}) => _.pickBy(obj, _.negate(_.isUndefined));\n\nconst addRelationMorph = async (model, params, { session = null } = {}) => {\n  const { id, alias, refId, ref, field, filter } = params;\n\n  await model.updateMany(\n    {\n      [model.primaryKey]: id,\n    },\n    {\n      $push: {\n        [alias]: {\n          ref: new mongoose.Types.ObjectId(refId),\n          kind: ref,\n          [filter]: field,\n        },\n      },\n    },\n    { session }\n  );\n};\n\nconst removeRelationMorph = async (model, params, { session = null } = {}) => {\n  const { alias } = params;\n\n  let opts;\n  // if entry id is provided simply query it\n  if (params.id) {\n    opts = {\n      _id: params.id,\n    };\n  } else {\n    opts = {\n      [alias]: {\n        $elemMatch: {\n          ref: params.refId,\n          kind: params.ref,\n          [params.filter]: params.field,\n        },\n      },\n    };\n  }\n\n  await model.updateMany(\n    opts,\n    {\n      $pull: {\n        [alias]: {\n          ref: params.refId,\n          kind: params.ref,\n          [params.filter]: params.field,\n        },\n      },\n    },\n    { session }\n  );\n};\n\nmodule.exports = {\n  async update(params, { session = null } = {}) {\n    const relationUpdates = [];\n    const populate = this.associations.map(x => x.alias);\n    const primaryKeyValue = getValuePrimaryKey(params, this.primaryKey);\n\n    const entry = await this.findOne({ [this.primaryKey]: primaryKeyValue })\n      .session(session)\n      .populate(populate)\n      .lean();\n\n    // Only update fields which are on this document.\n    const values = Object.keys(removeUndefinedKeys(params.values)).reduce((acc, attribute) => {\n      const currentValue = entry[attribute];\n      const newValue = params.values[attribute];\n\n      const association = this.associations.find(x => x.alias === attribute);\n\n      const details = this._attributes[attribute];\n\n      // set simple attributes\n      if (!association && _.get(details, 'isVirtual') !== true) {\n        return _.set(acc, attribute, newValue);\n      }\n\n      const assocModel = strapi.db.getModel(details.model || details.collection, details.plugin);\n\n      switch (association.nature) {\n        case 'oneWay': {\n          return _.set(acc, attribute, _.get(newValue, assocModel.primaryKey, newValue));\n        }\n        case 'oneToOne': {\n          // if value is the same don't do anything\n          if (currentValue === newValue) return acc;\n\n          // if the value is null, set field to null on both sides\n          if (_.isNull(newValue)) {\n            const updatePromise = assocModel.updateOne(\n              {\n                [assocModel.primaryKey]: getValuePrimaryKey(currentValue, assocModel.primaryKey),\n              },\n              { [details.via]: null },\n              { session }\n            );\n\n            relationUpdates.push(updatePromise);\n            return _.set(acc, attribute, null);\n          }\n\n          // set old relations to null\n          const updateLink = this.updateOne(\n            { [attribute]: new mongoose.Types.ObjectId(newValue) },\n            { [attribute]: null },\n            { session }\n          ).then(() => {\n            return assocModel.updateOne(\n              {\n                [this.primaryKey]: new mongoose.Types.ObjectId(newValue),\n              },\n              { [details.via]: primaryKeyValue },\n              { session }\n            );\n          });\n\n          // set new relation\n          relationUpdates.push(updateLink);\n          return _.set(acc, attribute, newValue);\n        }\n        case 'oneToMany': {\n          // set relation to null for all the ids not in the list\n          const attributeIds = currentValue;\n          const toRemove = _.differenceWith(attributeIds, newValue, (a, b) => {\n            return `${a[assocModel.primaryKey] || a}` === `${b[assocModel.primaryKey] || b}`;\n          });\n\n          const updatePromise = assocModel\n            .updateMany(\n              {\n                [assocModel.primaryKey]: {\n                  $in: toRemove.map(\n                    val => new mongoose.Types.ObjectId(val[assocModel.primaryKey] || val)\n                  ),\n                },\n              },\n              { [details.via]: null },\n              { session }\n            )\n            .then(() => {\n              return assocModel.updateMany(\n                {\n                  [assocModel.primaryKey]: {\n                    $in: newValue.map(\n                      val => new mongoose.Types.ObjectId(val[assocModel.primaryKey] || val)\n                    ),\n                  },\n                },\n                { [details.via]: primaryKeyValue },\n                { session }\n              );\n            });\n\n          relationUpdates.push(updatePromise);\n          return acc;\n        }\n        case 'manyToOne': {\n          return _.set(acc, attribute, _.get(newValue, assocModel.primaryKey, newValue));\n        }\n        case 'manyWay':\n        case 'manyToMany': {\n          if (association.dominant) {\n            return _.set(\n              acc,\n              attribute,\n              newValue ? newValue.map(val => val[assocModel.primaryKey] || val) : newValue\n            );\n          }\n\n          const updatePomise = assocModel\n            .updateMany(\n              {\n                [assocModel.primaryKey]: {\n                  $in: currentValue.map(\n                    val => new mongoose.Types.ObjectId(val[assocModel.primaryKey] || val)\n                  ),\n                },\n              },\n              {\n                $pull: {\n                  [association.via]: new mongoose.Types.ObjectId(primaryKeyValue),\n                },\n              },\n              { session }\n            )\n            .then(() => {\n              return assocModel.updateMany(\n                {\n                  [assocModel.primaryKey]: {\n                    $in: newValue\n                      ? newValue.map(\n                          val => new mongoose.Types.ObjectId(val[assocModel.primaryKey] || val)\n                        )\n                      : newValue,\n                  },\n                },\n                {\n                  $addToSet: { [association.via]: [primaryKeyValue] },\n                },\n                { session }\n              );\n            });\n\n          relationUpdates.push(updatePomise);\n          return acc;\n        }\n        // media -> model\n        case 'manyMorphToMany':\n        case 'manyMorphToOne': {\n          newValue.forEach(obj => {\n            const refModel = strapi.db.getModel(obj.ref, obj.source);\n\n            const createRelation = () => {\n              return addRelationMorph(\n                this,\n                {\n                  id: entry[this.primaryKey],\n                  alias: association.alias,\n                  ref: obj.kind || refModel.globalId,\n                  refId: new mongoose.Types.ObjectId(obj.refId),\n                  field: obj.field,\n                  filter: association.filter,\n                },\n                { session }\n              );\n            };\n\n            // Clear relations to refModel\n            const reverseAssoc = refModel.associations.find(assoc => assoc.alias === obj.field);\n            if (reverseAssoc && reverseAssoc.nature === 'oneToManyMorph') {\n              relationUpdates.push(\n                removeRelationMorph(\n                  this,\n                  {\n                    alias: association.alias,\n                    ref: obj.kind || refModel.globalId,\n                    refId: new mongoose.Types.ObjectId(obj.refId),\n                    field: obj.field,\n                    filter: association.filter,\n                  },\n                  { session }\n                )\n                  .then(createRelation)\n                  .then(() => {\n                    // set field inside refModel\n                    return refModel.updateMany(\n                      {\n                        [refModel.primaryKey]: new mongoose.Types.ObjectId(obj.refId),\n                      },\n                      {\n                        [obj.field]: new mongoose.Types.ObjectId(entry[this.primaryKey]),\n                      },\n                      { session }\n                    );\n                  })\n              );\n            } else {\n              relationUpdates.push(\n                createRelation().then(() => {\n                  // push to field inside refModel\n                  return refModel.updateMany(\n                    {\n                      [refModel.primaryKey]: new mongoose.Types.ObjectId(obj.refId),\n                    },\n                    {\n                      $push: { [obj.field]: new mongoose.Types.ObjectId(entry[this.primaryKey]) },\n                    },\n                    { session }\n                  );\n                })\n              );\n            }\n          });\n          break;\n        }\n        // model -> media\n        case 'oneToManyMorph':\n        case 'manyToManyMorph': {\n          // Compare array of ID to find deleted files.\n          const currentIds = transformToArrayID(currentValue, this.primaryKey);\n          const newIds = transformToArrayID(newValue, this.primaryKey);\n\n          const toAdd = _.difference(newIds, currentIds);\n          const toRemove = _.difference(currentIds, newIds);\n\n          const model = strapi.db.getModel(details.model || details.collection, details.plugin);\n\n          if (!Array.isArray(newValue)) {\n            _.set(acc, attribute, newIds[0]);\n          } else {\n            _.set(acc, attribute, newIds);\n          }\n\n          const addPromise = Promise.all(\n            toAdd.map(id => {\n              return addRelationMorph(\n                model,\n                {\n                  id,\n                  alias: association.via,\n                  ref: this.globalId,\n                  refId: entry._id,\n                  field: association.alias,\n                  filter: association.filter,\n                },\n                { session }\n              );\n            })\n          );\n\n          relationUpdates.push(addPromise);\n\n          toRemove.forEach(id => {\n            relationUpdates.push(\n              removeRelationMorph(\n                model,\n                {\n                  id,\n                  alias: association.via,\n                  ref: this.globalId,\n                  refId: entry._id,\n                  field: association.alias,\n                  filter: association.filter,\n                },\n                { session }\n              )\n            );\n          });\n          break;\n        }\n        case 'oneMorphToOne':\n        case 'oneMorphToMany':\n          break;\n        default:\n      }\n\n      return acc;\n    }, {});\n\n    // Update virtuals fields.\n    await Promise.all(relationUpdates).then(() =>\n      this.updateOne({ [this.primaryKey]: primaryKeyValue }, values, {\n        strict: false,\n        session,\n      })\n    );\n\n    const updatedEntity = await this.findOne({\n      [this.primaryKey]: primaryKeyValue,\n    })\n      .session(session)\n      .populate(populate);\n\n    return updatedEntity && updatedEntity.toObject ? updatedEntity.toObject() : updatedEntity;\n  },\n\n  deleteRelations(entry, { session = null } = {}) {\n    const primaryKeyValue = entry[this.primaryKey];\n\n    return Promise.all(\n      this.associations.map(async association => {\n        const { nature, via, dominant } = association;\n\n        // TODO: delete all the ref to the model\n\n        switch (nature) {\n          case 'oneWay':\n          case 'manyWay': {\n            return;\n          }\n          case 'oneToMany':\n          case 'oneToOne': {\n            if (!via) {\n              return;\n            }\n\n            const targetModel = strapi.db.getModel(\n              association.model || association.collection,\n              association.plugin\n            );\n\n            return targetModel.updateMany({ [via]: primaryKeyValue }, { [via]: null }, { session });\n          }\n          case 'manyToMany':\n          case 'manyToOne': {\n            if (!via || dominant) {\n              return;\n            }\n\n            const targetModel = strapi.db.getModel(\n              association.model || association.collection,\n              association.plugin\n            );\n\n            return targetModel.updateMany(\n              { [via]: primaryKeyValue },\n              { $pull: { [via]: primaryKeyValue } },\n              { session }\n            );\n          }\n          case 'oneToManyMorph':\n          case 'manyToManyMorph': {\n            // delete relation inside of the ref model\n\n            const targetModel = strapi.db.getModel(\n              association.model || association.collection,\n              association.plugin\n            );\n\n            // ignore them ghost relations\n            if (!targetModel) return;\n\n            const element = {\n              ref: primaryKeyValue,\n              kind: this.globalId,\n              [association.filter]: association.alias,\n            };\n\n            return targetModel.updateMany(\n              { [via]: { $elemMatch: element } },\n              { $pull: { [via]: element } },\n              { session }\n            );\n          }\n          case 'manyMorphToMany':\n          case 'manyMorphToOne': {\n            // delete relation inside of the ref model\n            // console.log(entry[association.alias]);\n\n            if (Array.isArray(entry[association.alias])) {\n              return Promise.all(\n                entry[association.alias].map(val => {\n                  const targetModel = strapi.db.getModelByGlobalId(val.kind);\n\n                  // ignore them ghost relations\n                  if (!targetModel) return;\n\n                  const field = val[association.filter];\n                  const reverseAssoc = targetModel.associations.find(\n                    assoc => assoc.alias === field\n                  );\n\n                  if (reverseAssoc && reverseAssoc.nature === 'oneToManyMorph') {\n                    return targetModel.updateMany(\n                      {\n                        [targetModel.primaryKey]: val.ref && (val.ref._id || val.ref),\n                      },\n                      {\n                        [field]: null,\n                      },\n                      { session }\n                    );\n                  }\n\n                  return targetModel.updateMany(\n                    {\n                      [targetModel.primaryKey]: val.ref && (val.ref._id || val.ref),\n                    },\n                    {\n                      $pull: { [field]: primaryKeyValue },\n                    },\n                    { session }\n                  );\n                })\n              );\n            }\n\n            return;\n          }\n          case 'oneMorphToOne':\n          case 'oneMorphToMany': {\n            return;\n          }\n        }\n      })\n    );\n  },\n};\n",
    "packages/strapi-connector-mongoose/lib/utils/store-definition.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst formatDefinitionToStore = definition =>\n  JSON.stringify(\n    _.pick(definition, ['uid', 'collectionName', 'kind', 'info', 'options', 'attributes'])\n  );\n\n// Using MongoDB instead of Mongoose since this function\n// may be called before the model 'core_store' is instanciated\nconst getDefinitionFromStore = async (definition, ORM) =>\n  ORM.connection.db.collection('core_store').findOne({ key: `model_def_${definition.uid}` });\n\n// Using MongoDB instead of Mongoose since this function\n// may be called before the model 'core_store' is instanciated\nconst storeDefinition = async (definition, ORM) => {\n  const defToStore = formatDefinitionToStore(definition);\n\n  await ORM.connection.db.collection('core_store').updateOne(\n    {\n      key: `model_def_${definition.uid}`,\n    },\n    {\n      $set: {\n        key: `model_def_${definition.uid}`,\n        type: 'object',\n        value: defToStore,\n        environment: '',\n        tag: '',\n      },\n    },\n    {\n      upsert: true,\n    }\n  );\n};\n\nconst didDefinitionChange = async (definition, ORM) => {\n  const previousDefRow = await getDefinitionFromStore(definition, ORM);\n  const previousDefJSON = _.get(previousDefRow, 'value', null);\n  const actualDefJSON = formatDefinitionToStore(definition);\n\n  return previousDefJSON !== actualDefJSON;\n};\n\nmodule.exports = {\n  didDefinitionChange,\n  storeDefinition,\n  getDefinitionFromStore,\n};\n",
    "packages/strapi-database/lib/connector-registry.js": "'use strict';\n/**\n * Database connector registry\n */\n\nconst _ = require('lodash');\nconst requireConnector = require('./require-connector');\n\nconst createConnectorRegistry = ({ defaultConnection, connections }) => {\n  const _connectors = new Map();\n\n  return {\n    /**\n     * Load connector modules\n     */\n    load() {\n      for (const connection of Object.values(connections)) {\n        const { connector } = connection;\n        if (!_connectors.has(connector)) {\n          _connectors.set(connector, requireConnector(connector)(strapi));\n        }\n      }\n    },\n\n    /**\n     * Initialize connectors\n     */\n    async initialize() {\n      for (const connector of _connectors.values()) {\n        await connector.initialize();\n      }\n    },\n\n    getAll() {\n      return Array.from(_connectors.values());\n    },\n\n    get(key) {\n      return _connectors.get(key);\n    },\n\n    set(key, val) {\n      _connectors.set(key, val);\n      return this;\n    },\n\n    get default() {\n      const defaultConnector = connections[defaultConnection].connector;\n      return _connectors.get(defaultConnector);\n    },\n\n    getByConnection(connection) {\n      if (!_.has(connections, connection)) {\n        throw new Error('Trying to access a connector for an unknown connection');\n      }\n\n      const connectorKey = connections[connection].connector;\n      return _connectors.get(connectorKey);\n    },\n  };\n};\n\nmodule.exports = createConnectorRegistry;\n",
    "packages/strapi-database/lib/database-manager.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createQuery } = require('./queries');\nconst createConnectorRegistry = require('./connector-registry');\nconst constants = require('./constants');\nconst { validateModelSchemas } = require('./validation');\n\nclass DatabaseManager {\n  constructor(strapi) {\n    this.strapi = strapi;\n\n    this.initialized = false;\n\n    this.connectors = createConnectorRegistry({\n      connections: strapi.config.get('database.connections'),\n      defaultConnection: strapi.config.get('database.defaultConnection'),\n    });\n\n    this.queries = new Map();\n    this.models = new Map();\n  }\n\n  async initialize() {\n    if (this.initialized === true) {\n      throw new Error('Database manager already initialized');\n    }\n\n    this.initialized = true;\n\n    this.connectors.load();\n\n    validateModelSchemas({ strapi: this.strapi, manager: this });\n\n    await this.connectors.initialize();\n\n    this.initializeModelsMap();\n\n    return this;\n  }\n\n  async destroy() {\n    await Promise.all(this.connectors.getAll().map(connector => connector.destroy()));\n  }\n\n  initializeModelsMap() {\n    Object.keys(this.strapi.models).forEach(modelKey => {\n      const model = this.strapi.models[modelKey];\n      this.models.set(model.uid, model);\n    });\n\n    Object.keys(this.strapi.admin.models).forEach(modelKey => {\n      const model = this.strapi.admin.models[modelKey];\n      this.models.set(model.uid, model);\n    });\n\n    Object.keys(this.strapi.plugins).forEach(pluginKey => {\n      Object.keys(this.strapi.plugins[pluginKey].models).forEach(modelKey => {\n        const model = this.strapi.plugins[pluginKey].models[modelKey];\n        this.models.set(model.uid, model);\n      });\n    });\n  }\n\n  query(entity, plugin) {\n    if (!entity) {\n      throw new Error(`argument entity is required`);\n    }\n\n    const normalizedName = entity.toLowerCase();\n\n    // get by uid or name / plugin\n    const model = this.models.has(entity)\n      ? this.models.get(entity)\n      : this.getModel(normalizedName, plugin);\n\n    if (!model) {\n      throw new Error(`The model ${entity} can't be found.`);\n    }\n\n    if (this.queries.has(model.uid)) {\n      return this.queries.get(model.uid);\n    }\n\n    const connectorQuery = this.connectors\n      .get(model.orm)\n      .queries({ model, modelKey: model.modelName, strapi });\n\n    const query = createQuery({\n      connectorQuery,\n      model,\n    });\n\n    this.queries.set(model.uid, query);\n    return query;\n  }\n\n  getModel(name, plugin) {\n    const key = _.toLower(name);\n\n    if (this.models.has(key)) return this.models.get(key);\n\n    if (plugin === 'admin') {\n      return _.get(strapi.admin, ['models', key]);\n    }\n\n    if (plugin) {\n      return _.get(strapi.plugins, [plugin, 'models', key]);\n    }\n\n    return _.get(strapi, ['models', key]) || _.get(strapi, ['components', key]);\n  }\n\n  getModelByAssoc(assoc) {\n    return this.getModel(assoc.collection || assoc.model, assoc.plugin);\n  }\n\n  getModelByCollectionName(collectionName) {\n    return Array.from(this.models.values()).find(model => {\n      return model.collectionName === collectionName;\n    });\n  }\n\n  getModelByGlobalId(globalId) {\n    return Array.from(this.models.values()).find(model => {\n      return model.globalId === globalId;\n    });\n  }\n\n  getModelsByAttribute(attr) {\n    if (attr.type === 'component') {\n      return [this.getModel(attr.component)];\n    }\n    if (attr.type === 'dynamiczone') {\n      return attr.components.map(compoName => this.getModel(compoName));\n    }\n    if (attr.model || attr.collection) {\n      return [this.getModelByAssoc(attr)];\n    }\n\n    return [];\n  }\n\n  getModelsByPluginName(pluginName) {\n    if (!pluginName) {\n      return strapi.models;\n    }\n\n    return pluginName === 'admin' ? strapi.admin.models : strapi.plugins[pluginName].models;\n  }\n\n  getReservedNames() {\n    return {\n      models: constants.RESERVED_MODEL_NAMES,\n      attributes: [\n        ...constants.RESERVED_ATTRIBUTE_NAMES,\n        ...(strapi.db.connectors.default.defaultTimestamps || []),\n      ],\n    };\n  }\n}\n\nfunction createDatabaseManager(strapi) {\n  return new DatabaseManager(strapi);\n}\n\nmodule.exports = {\n  createDatabaseManager,\n};\n",
    "packages/strapi-database/lib/queries/__tests__/create-query.test.js": "'use strict';\n\nconst _ = require('lodash');\nconst createQuery = require('../create-query');\n\ndescribe('Database queries', () => {\n  describe('Substitute id with primaryKey in parameters', () => {\n    test.each(['create', 'update', 'delete', 'find', 'findOne', 'search', 'count', 'countSearch'])(\n      'Calling \"%s\" replaces id by the primaryKey in the params of the model before calling the underlying connector',\n      async method => {\n        const model = {\n          primaryKey: 'testId',\n        };\n        const params = {\n          id: 'someValue',\n        };\n\n        const connectorQuery = {\n          [method]: jest.fn(() => Promise.resolve({})),\n        };\n\n        const query = createQuery({ model, connectorQuery });\n\n        await query[method](params);\n\n        expect(connectorQuery[method]).toHaveBeenCalledWith({\n          testId: 'someValue',\n        });\n      }\n    );\n  });\n\n  describe('Lifecycles', () => {\n    test.each(['create', 'update', 'delete', 'find', 'findOne', 'search', 'count', 'countSearch'])(\n      'Calling \"%s\" calls the before adn after lifecycle hooks with the correct arguments',\n      async method => {\n        const arg1 = {};\n        const arg2 = {};\n        const output = {};\n        const beforeLifecycleMethod = jest.fn();\n        const afterLifecycleMethod = jest.fn();\n        const queryMethod = jest.fn(() => Promise.resolve(output));\n\n        const model = {\n          lifecycles: {\n            [`before${_.upperFirst(method)}`]: beforeLifecycleMethod,\n            [`after${_.upperFirst(method)}`]: afterLifecycleMethod,\n          },\n        };\n\n        const connectorQuery = {\n          [method]: queryMethod,\n        };\n\n        const query = createQuery({ model, connectorQuery });\n\n        await query[method](arg1, arg2);\n\n        expect(queryMethod).toHaveBeenCalledWith(arg1, arg2);\n        expect(beforeLifecycleMethod).toHaveBeenCalledWith(arg1, arg2);\n        expect(afterLifecycleMethod).toHaveBeenCalledWith(output, arg1, arg2);\n      }\n    );\n  });\n});\n",
    "packages/strapi-database/lib/queries/__tests__/paginated-queries.test.js": "'use strict';\n\nconst {\n  createFindPageQuery,\n  createSearchPageQuery,\n  createPaginatedQuery,\n  getPaginationInfos,\n} = require('../paginated-queries');\n\ndescribe('Paginated Queries', () => {\n  describe('createPaginatedQuery', () => {\n    test('Successfully create a paginated query based on given fetch and count', async () => {\n      const fetch = jest.fn(() => [1, 2]);\n      const count = jest.fn(() => 2);\n\n      const paginatedQuery = createPaginatedQuery({ fetch, count });\n\n      const data = await paginatedQuery({});\n\n      expect(fetch).toHaveBeenCalled();\n      expect(count).toHaveBeenCalled();\n      expect(data).toMatchObject({\n        results: [1, 2],\n        pagination: {\n          page: 1,\n          pageSize: 100,\n          total: 2,\n          pageCount: 1,\n        },\n      });\n    });\n\n    test('Use custom pagination options to find a specific page', async () => {\n      const fetch = jest.fn(() => [5, 6]);\n      const count = jest.fn(() => 6);\n\n      const paginatedQuery = createPaginatedQuery({ fetch, count });\n\n      const data = await paginatedQuery({ page: 2, pageSize: 4 });\n\n      expect(fetch).toHaveBeenCalled();\n      expect(count).toHaveBeenCalled();\n      expect(data).toMatchObject({\n        results: [5, 6],\n        pagination: {\n          page: 2,\n          pageSize: 4,\n          total: 6,\n          pageCount: 2,\n        },\n      });\n    });\n  });\n\n  describe('createFindPageQuery', () => {\n    test('Successfully create a findPage query based on given find and count', async () => {\n      const find = jest.fn(() => [1, 2]);\n      const count = jest.fn(() => 2);\n\n      const paginatedQuery = createFindPageQuery({ find, count });\n\n      const data = await paginatedQuery({});\n\n      expect(find).toHaveBeenCalled();\n      expect(count).toHaveBeenCalled();\n      expect(data).toMatchObject({\n        results: [1, 2],\n        pagination: {\n          page: 1,\n          pageSize: 100,\n          total: 2,\n          pageCount: 1,\n        },\n      });\n    });\n  });\n\n  describe('createSearchPageQuery', () => {\n    test('Successfully create a searchPage query based on given search and countSearch', async () => {\n      const search = jest.fn(() => [1, 2]);\n      const countSearch = jest.fn(() => 2);\n\n      const paginatedQuery = createSearchPageQuery({ search, countSearch });\n\n      const data = await paginatedQuery({});\n\n      expect(search).toHaveBeenCalled();\n      expect(countSearch).toHaveBeenCalled();\n      expect(data).toMatchObject({\n        results: [1, 2],\n        pagination: {\n          page: 1,\n          pageSize: 100,\n          total: 2,\n          pageCount: 1,\n        },\n      });\n    });\n  });\n\n  describe('getPaginationInfos', () => {\n    test('Incomplete last page', async () => {\n      const queryParams = { page: 2, pageSize: 6 };\n      const count = jest.fn(() => 8);\n\n      const pagination = await getPaginationInfos(queryParams, count);\n\n      expect(count).toHaveBeenCalled();\n      expect(pagination).toEqual({\n        page: 2,\n        pageSize: 6,\n        total: 8,\n        pageCount: 2,\n      });\n    });\n\n    test('Complete last page', async () => {\n      const queryParams = { page: 2, pageSize: 6 };\n      const count = jest.fn(() => 18);\n\n      const pagination = await getPaginationInfos(queryParams, count);\n\n      expect(count).toHaveBeenCalled();\n      expect(pagination).toEqual({\n        page: 2,\n        pageSize: 6,\n        total: 18,\n        pageCount: 3,\n      });\n    });\n  });\n});\n",
    "packages/strapi-database/lib/queries/helpers.js": "'use strict';\n\nconst { replaceIdByPrimaryKey } = require('../utils/primary-key');\nconst { executeBeforeLifecycle, executeAfterLifecycle } = require('../utils/lifecycles');\n\nconst withLifecycles = ({ query, model, fn }) => async (params, ...rest) => {\n  // substitute id for primaryKey value in params\n  const newParams = replaceIdByPrimaryKey(params, model);\n  const queryArguments = [newParams, ...rest];\n\n  // execute before hook\n  await executeBeforeLifecycle(query, model, ...queryArguments);\n\n  // execute query\n  const result = await fn(...queryArguments);\n\n  // execute after hook with result and arguments\n  await executeAfterLifecycle(query, model, result, ...queryArguments);\n\n  // return result\n  return result;\n};\n\n// wraps a connectorQuery call with:\n// - param substitution\n// - lifecycle hooks\nconst createQueryWithLifecycles = ({ query, model, connectorQuery }) => {\n  return withLifecycles({\n    query,\n    model,\n    fn: (...queryParameters) => connectorQuery[query](...queryParameters),\n  });\n};\n\nmodule.exports = { withLifecycles, createQueryWithLifecycles };\n",
    "packages/strapi-database/lib/queries/paginated-queries.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst createPaginatedQuery = ({ fetch, count }) => async (queryParams, ...args) => {\n  const params = _.omit(queryParams, ['page', 'pageSize']);\n  const pagination = await getPaginationInfos(queryParams, count);\n\n  Object.assign(params, paginationToQueryParams(pagination));\n\n  const results = await fetch(params, ...args);\n\n  return { results, pagination };\n};\n\nconst createSearchPageQuery = ({ search, countSearch }) =>\n  createPaginatedQuery({ fetch: search, count: countSearch });\n\nconst createFindPageQuery = ({ find, count }) => createPaginatedQuery({ fetch: find, count });\n\nconst getPaginationInfos = async (queryParams, count) => {\n  const { page, pageSize, ...params } = withDefaultPagination(queryParams);\n\n  const total = await count(params);\n\n  return {\n    page,\n    pageSize,\n    pageCount: Math.ceil(total / pageSize),\n    total,\n  };\n};\n\nconst withDefaultPagination = params => {\n  const { page = 1, pageSize = 100, ...rest } = params;\n\n  return {\n    page: parseInt(page),\n    pageSize: parseInt(pageSize),\n    ...rest,\n  };\n};\n\nconst paginationToQueryParams = ({ page, pageSize }) => ({\n  _start: Math.max(page - 1, 0) * pageSize,\n  _limit: pageSize,\n});\n\nmodule.exports = {\n  getPaginationInfos,\n  withDefaultPagination,\n  createPaginatedQuery,\n  createFindPageQuery,\n  createSearchPageQuery,\n};\n",
    "packages/strapi-database/lib/queries/relations-counts-queries.js": "'use strict';\n\nconst { prop, assoc } = require('lodash/fp');\nconst { MANY_RELATIONS } = require('strapi-utils').relations.constants;\n\nconst createRelationsCountsQuery = ({ model, fn, connectorQuery }) => {\n  // fetch counter map\n  const fetchCounters = async (...args) => {\n    const results = await connectorQuery.fetchRelationCounters(...args);\n    return results.reduce((map, { id, count }) => assoc(id, Number(count), map), {});\n  };\n\n  return async function(params, populate) {\n    const xManyAssocs = [];\n    const xToOnePopulate = [];\n\n    model.associations\n      .filter(assoc => !populate || populate.includes(assoc.alias))\n      .forEach(assoc => {\n        if (MANY_RELATIONS.includes(assoc.nature)) {\n          xManyAssocs.push(assoc);\n        } else {\n          xToOnePopulate.push(assoc.alias);\n        }\n      });\n\n    const { results, pagination } = await fn(params, xToOnePopulate);\n    const resultsIds = results.map(prop('id'));\n\n    const counters = await Promise.all(\n      xManyAssocs.map(async ({ alias }) => ({\n        field: alias,\n        counts: await fetchCounters(alias, resultsIds),\n      }))\n    );\n\n    results.forEach(entity => {\n      counters.forEach(({ field, counts }) => {\n        entity[field] = { count: counts[entity.id] || 0 };\n      });\n    });\n\n    return {\n      results,\n      pagination,\n    };\n  };\n};\n\nmodule.exports = {\n  createRelationsCountsQuery,\n};\n",
    "packages/strapi-database/lib/utils/lifecycles.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst executeLifecycle = async (lifecycle, model, ...args) => {\n  if (_.has(model, `lifecycles.${lifecycle}`)) {\n    await model.lifecycles[lifecycle](...args);\n  }\n};\n\nconst executeBeforeLifecycle = (lifecycle, model, ...args) =>\n  executeLifecycle(`before${_.upperFirst(lifecycle)}`, model, ...args);\n\nconst executeAfterLifecycle = (lifecycle, model, ...args) =>\n  executeLifecycle(`after${_.upperFirst(lifecycle)}`, model, ...args);\n\nmodule.exports = {\n  executeBeforeLifecycle,\n  executeAfterLifecycle,\n};\n",
    "packages/strapi-database/tests/migration-draft-publish.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst modelsUtils = require('../../../test/helpers/models');\n\nlet builder;\nlet strapi;\nlet rq;\nlet data = {\n  dogs: [],\n};\nconst dogModel = {\n  draftAndPublish: false,\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    code: {\n      type: 'string',\n      unique: true,\n    },\n  },\n  connection: 'default',\n  name: 'dog',\n  description: '',\n  collectionName: '',\n};\n\nconst dogs = [\n  {\n    name: 'Nelson',\n    code: '1',\n  },\n  {\n    name: 'Atos',\n    code: '2',\n  },\n];\n\nconst restart = async () => {\n  await strapi.destroy();\n  strapi = await createStrapiInstance();\n  rq = await createAuthRequest({ strapi });\n};\n\nconst sortDogs = dogs => _.sortBy(dogs, 'name');\n\ndescribe('Migration - draft and publish', () => {\n  describe.each([\n    ['without table modifications', {}, {}],\n    ['with table modifications', { town: { type: 'string' } }, { color: { type: 'string' } }],\n  ])('%p', (testName, tableModification1, tableModification2) => {\n    beforeAll(async () => {\n      builder = createTestBuilder();\n\n      await builder\n        .addContentType(dogModel)\n        .addFixtures(dogModel.name, dogs)\n        .build();\n\n      strapi = await createStrapiInstance();\n      rq = await createAuthRequest({ strapi });\n\n      data.dogs = sortDogs(builder.sanitizedFixturesFor(dogModel.name, strapi));\n    }, 60000);\n\n    afterAll(async () => {\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    describe('Enabling D&P on a content-type', () => {\n      test('No published_at before enabling the feature', async () => {\n        let { body } = await rq({\n          url: '/content-manager/collection-types/application::dog.dog',\n          method: 'GET',\n        });\n\n        expect(body.results.length).toBe(2);\n\n        const sortedBody = sortDogs(body.results);\n\n        sortedBody.forEach((dog, index) => {\n          expect(dog).toMatchObject(data.dogs[index]);\n          expect(dog.published_at).toBeUndefined();\n        });\n      });\n\n      test('Published_at is equal to created_at after enabling the feature', async () => {\n        const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n\n        await modelsUtils.modifyContentType(\n          {\n            ...schema,\n            attributes: _.merge(schema.attributes, tableModification1),\n            draftAndPublish: true,\n          },\n          { strapi }\n        );\n\n        await restart();\n\n        let { body } = await rq({\n          method: 'GET',\n          url: '/content-manager/collection-types/application::dog.dog',\n        });\n\n        expect(body.results.length).toBe(2);\n\n        const sortedBody = sortDogs(body.results);\n\n        sortedBody.forEach((dog, index) => {\n          expect(dog).toMatchObject(data.dogs[index]);\n          expect(dog.published_at).toBe(dog.createdAt || dog.created_at);\n          expect(!isNaN(new Date(dog.published_at).valueOf())).toBe(true);\n        });\n\n        data.dogs = sortedBody;\n      }, 60000);\n    });\n\n    describe('Disabling D&P on a content-type', () => {\n      test('No published_at after disabling the feature + draft removed', async () => {\n        const res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/application::dog.dog/${data.dogs[1].id}/actions/unpublish`,\n        });\n\n        data.dogs[1] = res.body;\n\n        const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n\n        await modelsUtils.modifyContentType(\n          {\n            ...schema,\n            draftAndPublish: false,\n            attributes: _.merge(schema.attributes, tableModification2),\n          },\n          { strapi }\n        );\n\n        await restart();\n\n        // drafts should have been deleted with the migration, so we remove them\n        data.dogs = data.dogs.filter(dog => !_.isNil(dog.published_at));\n\n        let { body } = await rq({\n          url: '/content-manager/collection-types/application::dog.dog',\n          method: 'GET',\n        });\n\n        expect(body.results.length).toBe(1);\n        expect(body.results[0]).toMatchObject(_.pick(data.dogs[0], ['name']));\n        expect(body.results[0].published_at).toBeUndefined();\n      }, 60000);\n\n      test('Unique constraint is kept after disabling the feature', async () => {\n        const dogToCreate = { code: 'sameCode' };\n\n        let res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/application::dog.dog/`,\n          body: dogToCreate,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject(dogToCreate);\n\n        data.dogs.push(res.body);\n\n        res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/application::dog.dog/`,\n          body: dogToCreate,\n        });\n\n        expect(res.statusCode).toBe(400);\n      });\n    });\n  });\n});\n",
    "packages/strapi-database/tests/migration-required-attribute.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst modelsUtils = require('../../../test/helpers/models');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  dogs: [],\n};\n\nconst dogModel = {\n  draftAndPublish: false,\n  attributes: {\n    name: {\n      type: 'string',\n      required: false,\n    },\n  },\n  connection: 'default',\n  name: 'dog',\n  description: '',\n  collectionName: '',\n};\n\nconst dogs = [\n  {\n    name: null,\n  },\n  {\n    name: 'Atos',\n  },\n];\n\nconst restart = async () => {\n  await strapi.destroy();\n  strapi = await createStrapiInstance();\n  rq = await createAuthRequest({ strapi });\n};\n\ndescribe('Migration - required attribute', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(dogModel)\n      .addFixtures(dogModel.name, dogs)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    data.dogs = builder.sanitizedFixturesFor(dogModel.name, strapi);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  });\n\n  describe('Required: false -> true', () => {\n    test('Can be null before migration', async () => {\n      let { body } = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::dog.dog',\n      });\n      expect(body.results.length).toBe(2);\n      const dogWithNameNull = body.results.find(dog => dog.name === null);\n      expect(dogWithNameNull).toBeTruthy();\n    });\n\n    test('Cannot create an entry with null after migration', async () => {\n      // remove null values otherwise the migration would fail\n\n      const { body } = await rq({\n        method: 'PUT',\n        url: `/content-manager/collection-types/application::dog.dog/${data.dogs[0].id}`,\n        body: { name: 'Nelson' },\n      });\n      data.dogs[0] = body;\n\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n      schema.attributes.name.required = true;\n\n      await modelsUtils.modifyContentType(schema, { strapi });\n      await restart();\n\n      // Try to create an entry with null\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::dog.dog',\n        body: { name: null },\n      });\n      expect(res.body.message).toBe('ValidationError');\n    }, 60000);\n  });\n\n  describe('Required: true -> false', () => {\n    test('Can create an entry with null after migration', async () => {\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n      schema.attributes.name.required = false;\n\n      await modelsUtils.modifyContentType(schema, { strapi });\n      await restart();\n\n      // Try to create an entry with null\n      const res = await rq({\n        url: `/content-manager/collection-types/application::dog.dog`,\n        method: 'POST',\n        body: { name: null },\n      });\n\n      expect(res.body).toMatchObject({ name: null });\n      data.dogs.push(res.body);\n    }, 60000);\n  });\n});\n",
    "packages/strapi-database/tests/migration-unique-attribute.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst modelsUtils = require('../../../test/helpers/models');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  dogs: [],\n};\n\nconst dogModel = {\n  draftAndPublish: false,\n  attributes: {\n    name: {\n      type: 'string',\n      unique: false,\n    },\n  },\n  connection: 'default',\n  name: 'dog',\n  description: '',\n  collectionName: '',\n};\n\nconst dogs = [\n  {\n    name: 'Atos',\n  },\n  {\n    name: 'Atos',\n  },\n];\n\nconst restart = async () => {\n  await strapi.destroy();\n  strapi = await createStrapiInstance();\n  rq = await createAuthRequest({ strapi });\n};\n\ndescribe('Migration - unique attribute', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(dogModel)\n      .addFixtures(dogModel.name, dogs)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    data.dogs = builder.sanitizedFixturesFor(dogModel.name, strapi);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Unique: false -> true', () => {\n    test('Can have duplicates before migration', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::dog.dog',\n        method: 'GET',\n      });\n      expect(body.results.length).toBe(2);\n      expect(body.results[0].name).toEqual(body.results[1].name);\n    });\n\n    test('Cannot create a duplicated entry after migration', async () => {\n      // remove duplicated values otherwise the migration would fail\n      const { body } = await rq({\n        url: `/content-manager/collection-types/application::dog.dog/${data.dogs[0].id}`,\n        method: 'PUT',\n        body: { name: 'Nelson' },\n      });\n      data.dogs[0] = body;\n\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n      schema.attributes.name.unique = true;\n      await modelsUtils.modifyContentType(schema, { strapi });\n\n      await restart();\n\n      // Try to create a duplicated entry\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::dog.dog',\n        body: { name: data.dogs[0].name },\n      });\n      expect(res.statusCode).toBe(400);\n    }, 60000);\n  });\n\n  describe('Unique: true -> false', () => {\n    test('Can create a duplicated entry after migration', async () => {\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.name, { strapi });\n      schema.attributes.name.unique = false;\n      await modelsUtils.modifyContentType(schema, { strapi });\n\n      await restart();\n\n      // Try to create a duplicated entry\n      const res = await rq({\n        url: `/content-manager/collection-types/application::dog.dog`,\n        method: 'POST',\n        body: { name: data.dogs[0].name },\n      });\n\n      expect(res.body).toMatchObject({ name: data.dogs[0].name });\n      data.dogs.push(res.body);\n    }, 60000);\n  });\n});\n",
    "packages/strapi-generate-new/lib/create-cli-db-project.js": "'use strict';\n\nconst { merge } = require('lodash');\n\nconst { trackUsage } = require('./utils/usage');\nconst defaultConfigs = require('./utils/db-configs');\nconst clientDependencies = require('./utils/db-client-dependencies');\nconst createProject = require('./create-project');\n\nmodule.exports = async scope => {\n  console.log('Creating a project from the database CLI arguments.');\n  await trackUsage({ event: 'didChooseCustomDatabase', scope });\n\n  const client = scope.database.settings.client;\n  const configuration = {\n    client,\n    connection: merge({}, defaultConfigs[client] || {}, scope.database),\n    dependencies: clientDependencies({ scope, client }),\n  };\n  return createProject(scope, configuration);\n};\n",
    "packages/strapi-generate-new/lib/create-customized-project.js": "'use strict';\n\nconst { join } = require('path');\nconst fse = require('fs-extra');\nconst inquirer = require('inquirer');\nconst execa = require('execa');\nconst { merge, pick } = require('lodash');\n\nconst stopProcess = require('./utils/stop-process');\nconst { trackUsage } = require('./utils/usage');\nconst defaultConfigs = require('./utils/db-configs');\nconst clientDependencies = require('./utils/db-client-dependencies');\nconst dbQuestions = require('./utils/db-questions');\nconst createProject = require('./create-project');\n\nmodule.exports = async scope => {\n  await trackUsage({ event: 'didChooseCustomDatabase', scope });\n\n  const configuration = await askDbInfosAndTest(scope).catch(error => {\n    return trackUsage({ event: 'didNotConnectDatabase', scope, error }).then(\n      () => {\n        throw error;\n      }\n    );\n  });\n\n  console.log();\n  console.log('Creating a project with custom database options.');\n  await trackUsage({ event: 'didConnectDatabase', scope });\n  return createProject(scope, configuration);\n};\n\nconst MAX_RETRIES = 5;\nasync function askDbInfosAndTest(scope) {\n  let retries = 0;\n\n  async function loop() {\n    // else ask for the client name\n    const { client, connection } = await askDatabaseInfos(scope);\n\n    const configuration = {\n      client,\n      connection,\n      dependencies: clientDependencies({ scope, client }),\n    };\n\n    return testDatabaseConnection({\n      scope,\n      configuration,\n    })\n      .then(result => {\n        if (\n          result &&\n          result.shouldRetry === true &&\n          retries < MAX_RETRIES - 1\n        ) {\n          console.log('Retrying...');\n          retries++;\n          return loop();\n        }\n      })\n      .then(\n        () => fse.remove(scope.tmpPath),\n        err => {\n          return fse.remove(scope.tmpPath).then(() => {\n            throw err;\n          });\n        }\n      )\n      .then(() => configuration)\n      .catch(err => {\n        if (retries < MAX_RETRIES - 1) {\n          console.log();\n          console.log(`⛔️ Connection test failed: ${err.message}`);\n          console.log();\n\n          if (scope.debug) {\n            console.log('Full error log:');\n            console.log(err);\n          }\n\n          console.log('Retrying...');\n          retries++;\n          return loop();\n        }\n\n        console.log(err);\n        stopProcess(\n          `️⛔️ Could not connect to your database after ${MAX_RETRIES} tries. Try to check your database configuration an retry.`\n        );\n      });\n  }\n\n  return loop();\n}\n\nasync function testDatabaseConnection({ scope, configuration }) {\n  const { client } = configuration;\n\n  if (client === 'sqlite') return;\n\n  await installDatabaseTestingDep({\n    scope,\n    configuration,\n  });\n\n  const connectivityFile = join(\n    scope.tmpPath,\n    'node_modules',\n    `strapi-connector-${configuration.connection.connector}`,\n    'lib',\n    'utils',\n    'connectivity.js'\n  );\n\n  const tester = require(connectivityFile);\n  return tester({ scope, connection: configuration.connection });\n}\n\nconst SETTINGS_FIELDS = [\n  'database',\n  'host',\n  'srv',\n  'port',\n  'username',\n  'password',\n  'filename',\n];\n\nconst OPTIONS_FIELDS = ['authenticationDatabase'];\n\nasync function askDatabaseInfos(scope) {\n  const { client } = await inquirer.prompt([\n    {\n      type: 'list',\n      name: 'client',\n      message: 'Choose your default database client',\n      choices: ['sqlite', 'postgres', 'mysql', 'mongo'],\n      default: 'sqlite',\n    },\n  ]);\n\n  const responses = await inquirer.prompt(\n    dbQuestions[client].map(q => q({ scope, client }))\n  );\n\n  const connection = merge({}, defaultConfigs[client] || {}, {\n    settings: pick(responses, SETTINGS_FIELDS),\n    options: pick(responses, OPTIONS_FIELDS),\n  });\n\n  if (responses.ssl === true) {\n    if (client === 'mongo') {\n      connection.options.ssl = true;\n    } else {\n      connection.settings.ssl = true;\n    }\n  }\n\n  return {\n    client,\n    connection,\n  };\n}\n\nasync function installDatabaseTestingDep({ scope, configuration }) {\n  let packageManager = scope.useYarn ? 'yarnpkg' : 'npm';\n  let cmd = scope.useYarn\n    ? ['--cwd', scope.tmpPath, 'add']\n    : ['install', '--prefix', scope.tmpPath];\n\n  // Manually create the temp directory for yarn\n  if (scope.useYarn) {\n    await fse.ensureDir(scope.tmpPath);\n  }\n\n  const deps = Object.keys(configuration.dependencies).map(dep => {\n    return `${dep}@${configuration.dependencies[dep]}`;\n  });\n\n  await execa(packageManager, cmd.concat(deps));\n}\n",
    "packages/strapi-generate-new/lib/create-project.js": "'use strict';\n\nconst { join } = require('path');\nconst fse = require('fs-extra');\nconst chalk = require('chalk');\nconst execa = require('execa');\nconst ora = require('ora');\nconst _ = require('lodash');\n\nconst stopProcess = require('./utils/stop-process');\nconst { trackUsage, captureStderr } = require('./utils/usage');\nconst mergeTemplate = require('./utils/merge-template.js');\n\nconst packageJSON = require('./resources/json/package.json');\nconst createDatabaseConfig = require('./resources/templates/database.js');\nconst createServerConfig = require('./resources/templates/server.js');\n\nmodule.exports = async function createProject(scope, { client, connection, dependencies }) {\n  console.log('Creating files.');\n\n  const { rootPath } = scope;\n  const resources = join(__dirname, 'resources');\n\n  try {\n    // copy files\n    await fse.copy(join(resources, 'files'), rootPath);\n\n    // copy dot files\n    const dotFiles = await fse.readdir(join(resources, 'dot-files'));\n    await Promise.all(\n      dotFiles.map(name => {\n        return fse.copy(join(resources, 'dot-files', name), join(rootPath, `.${name}`));\n      })\n    );\n\n    await trackUsage({ event: 'didCopyProjectFiles', scope });\n\n    // copy templates\n    await fse.writeJSON(\n      join(rootPath, 'package.json'),\n      packageJSON({\n        strapiDependencies: scope.strapiDependencies,\n        additionalsDependencies: dependencies,\n        strapiVersion: scope.strapiVersion,\n        projectName: _.kebabCase(scope.name),\n        uuid: scope.uuid,\n      }),\n      {\n        spaces: 2,\n      }\n    );\n\n    await trackUsage({ event: 'didWritePackageJSON', scope });\n\n    // ensure node_modules is created\n    await fse.ensureDir(join(rootPath, 'node_modules'));\n\n    // create config/database.js\n    await fse.writeFile(\n      join(rootPath, `config/database.js`),\n      createDatabaseConfig({\n        client,\n        connection,\n      })\n    );\n\n    // create config/server.js\n    await fse.writeFile(join(rootPath, `config/server.js`), createServerConfig());\n    await trackUsage({ event: 'didCopyConfigurationFiles', scope });\n\n    // merge template files if a template is specified\n    const hasTemplate = Boolean(scope.template);\n    if (hasTemplate) {\n      try {\n        await mergeTemplate(scope, rootPath);\n      } catch (error) {\n        throw new Error(`⛔️ Template installation failed: ${error.message}`);\n      }\n    }\n  } catch (err) {\n    await fse.remove(scope.rootPath);\n    throw err;\n  }\n\n  await trackUsage({ event: 'willInstallProjectDependencies', scope });\n\n  const installPrefix = chalk.yellow('Installing dependencies:');\n  const loader = ora(installPrefix).start();\n\n  const logInstall = (chunk = '') => {\n    loader.text = `${installPrefix} ${chunk\n      .toString()\n      .split('\\n')\n      .join(' ')}`;\n  };\n\n  try {\n    if (scope.installDependencies !== false) {\n      const runner = runInstall(scope);\n\n      runner.stdout.on('data', logInstall);\n      runner.stderr.on('data', logInstall);\n\n      await runner;\n    }\n\n    loader.stop();\n    console.log(`Dependencies installed ${chalk.green('successfully')}.`);\n\n    await trackUsage({ event: 'didInstallProjectDependencies', scope });\n  } catch (error) {\n    loader.stop();\n    await trackUsage({\n      event: 'didNotInstallProjectDependencies',\n      scope,\n      error: error.stderr.slice(-1024),\n    });\n\n    console.error(`${chalk.red('Error')} while installing dependencies:`);\n    console.error(error.stderr);\n\n    await captureStderr('didNotInstallProjectDependencies', error);\n\n    console.log(chalk.black.bgWhite(' Keep trying!             '));\n    console.log();\n    console.log(\n      chalk.bold(\n        'Oh, it seems that you encountered errors while installing dependencies in your project.'\n      )\n    );\n    console.log(`Don't give up, your project was created correctly.`);\n    console.log(\n      `Fix the issues mentioned in the installation errors and try to run the following command:`\n    );\n    console.log();\n    console.log(\n      `cd ${chalk.green(rootPath)} && ${chalk.cyan(scope.useYarn ? 'yarn' : 'npm')} install`\n    );\n    console.log();\n\n    stopProcess();\n  }\n\n  await trackUsage({ event: 'didCreateProject', scope });\n\n  console.log();\n  console.log(`Your application was created at ${chalk.green(rootPath)}.\\n`);\n\n  const cmd = chalk.cyan(scope.useYarn ? 'yarn' : 'npm run');\n\n  console.log('Available commands in your project:');\n  console.log();\n  console.log(`  ${cmd} develop`);\n  console.log('  Start Strapi in watch mode.');\n  console.log();\n  console.log(`  ${cmd} start`);\n  console.log('  Start Strapi without watch mode.');\n  console.log();\n  console.log(`  ${cmd} build`);\n  console.log('  Build Strapi admin panel.');\n  console.log();\n  console.log(`  ${cmd} strapi`);\n  console.log(`  Display all available commands.`);\n  console.log();\n  console.log('You can start by doing:');\n  console.log();\n  console.log(`  ${chalk.cyan('cd')} ${rootPath}`);\n  console.log(`  ${cmd} develop`);\n  console.log();\n};\n\nconst installArguments = ['install', '--production', '--no-optional'];\nfunction runInstall({ rootPath, useYarn }) {\n  if (useYarn) {\n    return execa('yarnpkg', installArguments, {\n      cwd: rootPath,\n      stdin: 'ignore',\n    });\n  }\n\n  return execa('npm', installArguments, { cwd: rootPath, stdin: 'ignore' });\n}\n",
    "packages/strapi-generate-new/lib/create-quickstart-project.js": "'use strict';\n\nconst execa = require('execa');\n\nconst { trackUsage, captureStderr } = require('./utils/usage');\nconst defaultConfigs = require('./utils/db-configs.js');\nconst clientDependencies = require('./utils/db-client-dependencies.js');\nconst createProject = require('./create-project');\n\nmodule.exports = async function createQuickStartProject(scope) {\n  console.log('Creating a quickstart project.');\n  await trackUsage({ event: 'didChooseQuickstart', scope });\n\n  // get default sqlite config\n  const client = 'sqlite';\n  const configuration = {\n    client,\n    connection: defaultConfigs[client],\n    dependencies: clientDependencies({ scope, client }),\n  };\n\n  await createProject(scope, configuration);\n\n  if (scope.runQuickstartApp !== true) return;\n\n  try {\n    await trackUsage({ event: 'willBuildAdmin', scope });\n\n    await execa('npm', ['run', 'build', '--', '--no-optimization'], {\n      stdio: 'inherit',\n      cwd: scope.rootPath,\n      env: {\n        FORCE_COLOR: 1,\n      },\n    });\n\n    await trackUsage({ event: 'didBuildAdmin', scope });\n  } catch (error) {\n    await trackUsage({\n      event: 'didNotBuildAdmin',\n      scope,\n      error,\n    });\n\n    await captureStderr('didNotBuildAdmin', error);\n    process.exit(1);\n  }\n\n  console.log(`Running your Strapi application.`);\n\n  try {\n    await trackUsage({ event: 'willStartServer', scope });\n\n    await execa('npm', ['run', 'develop'], {\n      stdio: 'inherit',\n      cwd: scope.rootPath,\n      env: {\n        FORCE_COLOR: 1,\n      },\n    });\n  } catch (error) {\n    await trackUsage({\n      event: 'didNotStartServer',\n      scope,\n      error,\n    });\n\n    await captureStderr('didNotStartServer', error);\n    process.exit(1);\n  }\n};\n",
    "packages/strapi-generate-new/lib/generate-new.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Node.js core.\nconst chalk = require('chalk');\nconst inquirer = require('inquirer');\nconst fse = require('fs-extra');\n\nconst { trackUsage } = require('./utils/usage');\nconst stopProcess = require('./utils/stop-process');\nconst createCLIDatabaseProject = require('./create-cli-db-project');\nconst createCustomizeProject = require('./create-customized-project');\nconst createQuickStartProject = require('./create-quickstart-project');\n\nmodule.exports = async scope => {\n  const hasDatabaseConfig = Boolean(scope.database);\n\n  // check rootPath is empty\n  if (await fse.exists(scope.rootPath)) {\n    const stat = await fse.stat(scope.rootPath);\n\n    if (!stat.isDirectory()) {\n      stopProcess(\n        `⛔️ ${chalk.green(\n          scope.rootPath\n        )} is not a directory. Make sure to create a Strapi application in an empty directory.`\n      );\n    }\n\n    const files = await fse.readdir(scope.rootPath);\n    if (files.length > 1) {\n      stopProcess(\n        `⛔️ You can only create a Strapi app in an empty directory.\\nMake sure ${chalk.green(\n          scope.rootPath\n        )} is empty.`\n      );\n    }\n  }\n\n  await trackUsage({ event: 'willCreateProject', scope });\n\n  // if database config is provided don't test the connection and create the project directly\n  if (hasDatabaseConfig) {\n    return createCLIDatabaseProject(scope);\n  }\n\n  // if cli quickstart create project with default sqlite options\n  if (scope.quick === true) {\n    return createQuickStartProject(scope);\n  }\n\n  const useQuickStart = await askShouldUseQuickstart();\n  // else if question response is quickstart create project\n  if (useQuickStart) {\n    return createQuickStartProject(scope);\n  }\n\n  // create a project with full list of questions\n  return createCustomizeProject(scope);\n};\n\nasync function askShouldUseQuickstart() {\n  const answer = await inquirer.prompt([\n    {\n      type: 'list',\n      name: 'type',\n      message: 'Choose your installation type',\n      choices: [\n        {\n          name: 'Quickstart (recommended)',\n          value: 'quick',\n        },\n        {\n          name: 'Custom (manual settings)',\n          value: 'custom',\n        },\n      ],\n    },\n  ]);\n\n  return answer.type === 'quick';\n}\n",
    "packages/strapi-generate-new/lib/utils/merge-template.js": "'use strict';\n\nconst os = require('os');\nconst path = require('path');\nconst fse = require('fs-extra');\nconst fetch = require('node-fetch');\nconst tar = require('tar');\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst gitInfo = require('hosted-git-info');\n\n// Specify all the files and directories a template can have\nconst allowChildren = '*';\nconst allowedTemplateContents = {\n  'README.md': true,\n  '.env.example': true,\n  api: allowChildren,\n  components: allowChildren,\n  config: {\n    functions: allowChildren,\n  },\n  data: allowChildren,\n  plugins: allowChildren,\n  public: allowChildren,\n  scripts: allowChildren,\n};\n\n/**\n * merge template with new project being created\n * @param {string} scope  project creation params\n * @param {string} rootPath  project path\n */\nmodule.exports = async function mergeTemplate(scope, rootPath) {\n  // Parse template info\n  const repoInfo = getRepoInfo(scope.template);\n  const { user, project } = repoInfo;\n  console.log(`Installing ${chalk.yellow(`${user}/${project}`)} template.`);\n\n  // Download template repository to a temporary directory\n  const templatePath = await fse.mkdtemp(path.join(os.tmpdir(), 'strapi-'));\n\n  try {\n    await downloadGithubRepo(repoInfo, templatePath);\n  } catch (error) {\n    throw Error(`Could not download ${chalk.yellow(`${user}/${project}`)} repository.`);\n  }\n\n  // Make sure the downloaded template matches the required format\n  const { templateConfig } = await checkTemplateRootStructure(templatePath, scope);\n  await checkTemplateContentsStructure(path.resolve(templatePath, 'template'));\n\n  // Merge contents of the template in the project\n  const fullTemplateUrl = `https://github.com/${user}/${project}`;\n  await mergePackageJSON(rootPath, templateConfig, fullTemplateUrl);\n  await mergeFilesAndDirectories(rootPath, templatePath);\n\n  // Delete the downloaded template repo\n  await fse.remove(templatePath);\n};\n\n// Make sure the template has the required top-level structure\nasync function checkTemplateRootStructure(templatePath, scope) {\n  // Make sure the root of the repo has a template.json or a template.js file\n  const templateJsonPath = path.join(templatePath, 'template.json');\n  const templateFunctionPath = path.join(templatePath, 'template.js');\n\n  // Store the template config, whether it comes from a JSON or a function\n  let templateConfig = {};\n\n  const hasJsonConfig = fse.existsSync(templateJsonPath);\n  if (hasJsonConfig) {\n    const jsonStat = await fse.stat(templateJsonPath);\n    if (!jsonStat.isFile()) {\n      throw new Error(`A template's ${chalk.green('template.json')} must be a file`);\n    }\n    templateConfig = require(templateJsonPath);\n  }\n\n  const hasFunctionConfig = fse.existsSync(templateFunctionPath);\n  if (hasFunctionConfig) {\n    const functionStat = await fse.stat(templateFunctionPath);\n    if (!functionStat.isFile()) {\n      throw new Error(`A template's ${chalk.green('template.js')} must be a file`);\n    }\n    // Get the config by passing the scope to the function\n    templateConfig = require(templateFunctionPath)(scope);\n  }\n\n  // Make sure there's exactly one template config file\n  if (!hasJsonConfig && !hasFunctionConfig) {\n    throw new Error(\n      `A template must have either a ${chalk.green('template.json')} or a ${chalk.green(\n        'template.js'\n      )} root file`\n    );\n  } else if (hasJsonConfig && hasFunctionConfig) {\n    throw new Error(\n      `A template cannot have both ${chalk.green('template.json')} and ${chalk.green(\n        'template.js'\n      )} root files`\n    );\n  }\n\n  // Make sure the root of the repo has a template folder\n  const templateDirPath = path.join(templatePath, 'template');\n  try {\n    const stat = await fse.stat(templateDirPath);\n    if (!stat.isDirectory()) {\n      throw Error(`A template must have a root ${chalk.green('template/')} directory`);\n    }\n  } catch (error) {\n    if (error.code === 'ENOENT') {\n      throw Error(`A template must have a root ${chalk.green('template/')} directory`);\n    }\n\n    throw error;\n  }\n\n  return { templateConfig };\n}\n\n// Traverse template tree to make sure each file and folder is allowed\nasync function checkTemplateContentsStructure(templateContentsPath) {\n  // Recursively check if each item in a directory is allowed\n  const checkPathContents = (pathToCheck, parents) => {\n    const contents = fse.readdirSync(pathToCheck);\n    contents.forEach(item => {\n      const nextParents = [...parents, item];\n      const matchingTreeValue = _.get(allowedTemplateContents, nextParents);\n\n      // Treat files and directories separately\n      const itemPath = path.resolve(pathToCheck, item);\n      const isDirectory = fse.statSync(itemPath).isDirectory();\n\n      if (matchingTreeValue === undefined) {\n        // Unknown paths are forbidden\n        throw Error(\n          `Illegal template structure, unknown path ${chalk.green(nextParents.join('/'))}`\n        );\n      }\n\n      if (matchingTreeValue === true) {\n        if (!isDirectory) {\n          // All good, the file is allowed\n          return;\n        }\n        throw Error(\n          `Illegal template structure, expected a file and got a directory at ${chalk.green(\n            nextParents.join('/')\n          )}`\n        );\n      }\n\n      if (isDirectory) {\n        if (matchingTreeValue === allowChildren) {\n          // All children are allowed\n          return;\n        }\n        // Check if the contents of the directory are allowed\n        checkPathContents(itemPath, nextParents);\n      } else {\n        throw Error(\n          `Illegal template structure, unknow file ${chalk.green(nextParents.join('/'))}`\n        );\n      }\n    });\n  };\n\n  checkPathContents(templateContentsPath, []);\n}\n\nfunction getRepoInfo(template) {\n  try {\n    const { user, project, default: urlStrategy } = gitInfo.fromUrl(template);\n    if (urlStrategy === 'https' || urlStrategy === 'http') {\n      // A full GitHub URL was provided, return username and project directly\n      return { user, project };\n    }\n    if (urlStrategy === 'shortcut') {\n      // A shorthand was provided, so prefix the project name with \"strapi-template-\"\n      return {\n        user,\n        project: `strapi-template-${project}`,\n      };\n    }\n  } catch (error) {\n    // If it's not a GitHub URL, then assume it's a shorthand for an official template\n    return {\n      user: 'strapi',\n      project: `strapi-template-${template}`,\n    };\n  }\n}\n\nasync function downloadGithubRepo(repoInfo, templatePath) {\n  // Download from GitHub\n  const { user, project } = repoInfo;\n  const codeload = `https://codeload.github.com/${user}/${project}/tar.gz/master`;\n  const response = await fetch(codeload);\n  if (!response.ok) {\n    throw Error(`Could not download the ${chalk.green(`${user}/${project}`)} repository`);\n  }\n\n  await new Promise(resolve => {\n    response.body.pipe(tar.extract({ strip: 1, cwd: templatePath })).on('close', resolve);\n  });\n}\n\n// Merge the template's template.json into the Strapi project's package.json\nasync function mergePackageJSON(rootPath, templateConfig, templateUrl) {\n  // Import the package.json as an object\n  const packageJSON = require(path.resolve(rootPath, 'package.json'));\n\n  if (!templateConfig.package) {\n    // Nothing to overwrite\n    return;\n  }\n\n  // Make sure the template.json doesn't overwrite the UUID\n  if (templateConfig.package.strapi && templateConfig.package.strapi.uuid) {\n    throw Error('A template cannot overwrite the Strapi UUID');\n  }\n\n  // Use lodash to deeply merge them\n  const mergedConfig = _.merge(packageJSON, templateConfig.package);\n\n  // Add starter info to package.json\n  _.set(mergedConfig, 'strapi.template', templateUrl);\n\n  // Save the merged config as the new package.json\n  const packageJSONPath = path.join(rootPath, 'package.json');\n  await fse.writeJSON(packageJSONPath, mergedConfig, { spaces: 2 });\n}\n\n// Merge all allowed files and directories\nasync function mergeFilesAndDirectories(rootPath, templatePath) {\n  const templateDir = path.join(templatePath, 'template');\n  await fse.copy(templateDir, rootPath, { overwrite: true, recursive: true });\n}\n",
    "packages/strapi-generate-new/lib/utils/usage.js": "'use strict';\n\nconst os = require('os');\nconst fetch = require('node-fetch');\nconst sentry = require('@sentry/node');\n\nasync function captureException(error) {\n  try {\n    sentry.captureException(error);\n    await sentry.flush();\n  } catch (err) {\n    /** ignore errors*/\n    return Promise.resolve();\n  }\n}\n\nasync function captureError(message) {\n  try {\n    sentry.captureMessage(message, 'error');\n    await sentry.flush();\n  } catch (err) {\n    /** ignore errors*/\n    return Promise.resolve();\n  }\n}\n\nfunction captureStderr(name, error) {\n  if (error && error.stderr && error.stderr.trim() !== '') {\n    error.stderr\n      .trim()\n      .split('\\n')\n      .forEach(line => {\n        sentry.addBreadcrumb({\n          category: 'stderr',\n          message: line,\n          level: 'error',\n        });\n      });\n  }\n\n  return captureError(name);\n}\n\nfunction trackEvent(event, body) {\n  try {\n    return fetch('https://analytics.strapi.io/track', {\n      method: 'POST',\n      body: JSON.stringify({\n        event,\n        ...body,\n      }),\n      timeout: 1000,\n      headers: { 'Content-Type': 'application/json' },\n    }).catch(() => {});\n  } catch (err) {\n    /** ignore errors*/\n    return Promise.resolve();\n  }\n}\n\nfunction trackError({ scope, error }) {\n  try {\n    return trackEvent('didNotCreateProject', {\n      uuid: scope.uuid,\n      deviceId: scope.deviceId,\n      properties: {\n        error: typeof error == 'string' ? error : error && error.message,\n        os: os.type(),\n        platform: os.platform(),\n        release: os.release(),\n        version: scope.strapiVersion,\n        nodeVersion: process.version,\n        docker: scope.docker,\n        useYarn: scope.useYarn,\n        template: scope.template || '',\n      },\n    });\n  } catch (err) {\n    /** ignore errors*/\n    return Promise.resolve();\n  }\n}\n\nfunction trackUsage({ event, scope, error }) {\n  try {\n    return trackEvent(event, {\n      uuid: scope.uuid,\n      deviceId: scope.deviceId,\n      properties: {\n        error: typeof error == 'string' ? error : error && error.message,\n        os: os.type(),\n        os_platform: os.platform(),\n        os_release: os.release(),\n        node_version: process.version,\n        version: scope.strapiVersion,\n        docker: scope.docker,\n        useYarn: scope.useYarn.toString(),\n        noRun: (scope.runQuickstartApp !== true).toString(),\n        template: scope.template || null,\n      },\n    });\n  } catch (err) {\n    /** ignore errors*/\n    return Promise.resolve();\n  }\n}\n\nmodule.exports = {\n  trackError,\n  trackUsage,\n  captureException,\n  captureStderr,\n};\n",
    "packages/strapi-helper-plugin/lib/src/hooks/useUserPermissions/index.js": "import { useCallback, useEffect, useMemo, useReducer, useRef } from 'react';\nimport hasPermissions from '../../utils/hasPermissions';\nimport useUser from '../useUser';\n\nimport generateResultsObject from './utils/generateResultsObject';\nimport reducer from './reducer';\nimport init from './init';\n\nconst useUserPermissions = pluginPermissions => {\n  const abortController = new AbortController();\n  const { signal } = abortController;\n\n  const isMounted = useRef(true);\n  const permissionNames = useMemo(() => {\n    return Object.keys(pluginPermissions);\n  }, [pluginPermissions]);\n  const currentUserPermissions = useUser();\n  const [state, dispatch] = useReducer(reducer, {}, () => init(permissionNames));\n  const checkPermissionsRef = useRef();\n  const generateArrayOfPromisesRef = useRef();\n\n  checkPermissionsRef.current = async permissionName => {\n    const hasPermission = await hasPermissions(\n      currentUserPermissions,\n      pluginPermissions[permissionName],\n      signal\n    );\n\n    return { permissionName, hasPermission };\n  };\n\n  generateArrayOfPromisesRef.current = array =>\n    array.map(permissionName => checkPermissionsRef.current(permissionName));\n\n  useEffect(() => {\n    isMounted.current = true;\n\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        dispatch({\n          type: 'GET_DATA',\n          permissionNames,\n        });\n        const arrayOfPromises = generateArrayOfPromisesRef.current(permissionNames);\n        const results = await Promise.all(arrayOfPromises);\n        const data = generateResultsObject(results);\n\n        if (isMounted.current) {\n          dispatch({\n            type: 'GET_DATA_SUCCEEDED',\n            data,\n          });\n        }\n      } catch (err) {\n        // Silent\n      }\n    };\n\n    getData();\n\n    return () => {\n      abortController.abort();\n    };\n  }, [permissionNames]);\n\n  // This function is used to synchronise the hook when used in dynamic components\n  const setIsLoading = useCallback(() => {\n    dispatch({\n      type: 'SET_IS_LOADING',\n    });\n  }, []);\n\n  return { ...state, setIsLoading };\n};\n\nexport default useUserPermissions;\n",
    "packages/strapi-helper-plugin/lib/src/utils/hasPermissions.js": "import { isEmpty, pickBy, transform } from 'lodash';\nimport request from './request';\n\nconst findMatchingPermissions = (userPermissions, permissions) => {\n  return transform(\n    userPermissions,\n    (result, value) => {\n      const associatedPermission = permissions.find(\n        perm => perm.action === value.action && perm.subject === value.subject\n      );\n\n      if (associatedPermission) {\n        result.push(value);\n      }\n    },\n    []\n  );\n};\n\nconst formatPermissionsForRequest = permissions =>\n  permissions.map(permission =>\n    pickBy(permission, (value, key) => {\n      return ['action', 'subject'].includes(key) && !isEmpty(value);\n    })\n  );\n\nconst shouldCheckPermissions = permissions =>\n  !isEmpty(permissions) && permissions.every(perm => !isEmpty(perm.conditions));\n\nconst hasPermissions = async (userPermissions, permissions, signal) => {\n  if (!permissions || !permissions.length) {\n    return true;\n  }\n\n  const matchingPermissions = findMatchingPermissions(userPermissions, permissions);\n\n  if (shouldCheckPermissions(matchingPermissions)) {\n    let hasPermission = false;\n\n    try {\n      const { data } = await request('/admin/permissions/check', {\n        method: 'POST',\n        body: {\n          permissions: formatPermissionsForRequest(matchingPermissions),\n        },\n        signal,\n      });\n\n      hasPermission = data.every(v => v === true);\n    } catch (err) {\n      console.error('Error while checking permissions', err);\n    }\n\n    return hasPermission;\n  }\n\n  return matchingPermissions.length > 0;\n};\n\nexport default hasPermissions;\nexport { findMatchingPermissions, formatPermissionsForRequest, shouldCheckPermissions };\n",
    "packages/strapi-hook-redis/lib/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Core\nconst util = require('util');\n/* eslint-disable prefer-template */\n\n// Public node modules.\nconst _ = require('lodash');\nconst Redis = require('ioredis');\nconst stackTrace = require('stack-trace');\n/**\n * Redis hook\n */\n\nmodule.exports = function(strapi) {\n  const hook = {\n    /**\n     * Default options\n     */\n\n    defaults: {\n      port: 6379,\n      host: 'localhost',\n      options: {\n        db: 0,\n      },\n      showFriendlyErrorStack: process.env.NODE_ENV !== 'production',\n    },\n\n    /**\n     * Initialize the hook\n     */\n\n    initialize: () => {\n      if (\n        _.isEmpty(strapi.models) ||\n        !_.pickBy(strapi.config.connections, {\n          connector: 'strapi-hook-redis',\n        })\n      ) {\n        return;\n      }\n\n      const connections = _.pickBy(strapi.config.connections, {\n        connector: 'strapi-hook-redis',\n      });\n\n      if (_.size(connections) === 0) {\n        return;\n      }\n\n      const done = _.after(_.size(connections), () => {\n        return;\n      });\n\n      // For each connection in the config register a new Knex connection.\n      _.forEach(connections, (connection, name) => {\n        // Apply defaults\n        _.defaults(connection.settings, strapi.config.hook.settings.redis);\n\n        const redis = new Redis(\n          _.defaultsDeep(\n            {\n              port: _.get(connection.settings, 'port'),\n              host: _.get(connection.settings, 'host'),\n              options: {\n                db: _.get(connection.options, 'database') || 0,\n              },\n            },\n            strapi.config.hook.settings.redis\n          )\n        );\n\n        redis.on('error', err => {\n          strapi.log.error(err);\n          process.exit(0);\n        });\n\n        // Utils function.\n        // Behavior: Try to retrieve data from Redis, if null\n        // execute callback and set the value in Redis for this serial key.\n        redis.cache = async ({ expired = 60 * 60, serial }, cb, type) => {\n          if (_.isEmpty(serial)) {\n            strapi.log.warn(\n              `Be careful, you're using cache() function of strapi-redis without serial`\n            );\n\n            const traces = stackTrace.get();\n\n            strapi.log.warn(\n              `> [${traces[1].getLineNumber()}] ${traces[1]\n                .getFileName()\n                .replace(strapi.config.appPath, '')}`\n            );\n\n            return await cb();\n          }\n\n          let cache = await redis.get(serial);\n\n          if (!cache) {\n            cache = await cb();\n\n            if (cache && _.get(connection, 'options.disabledCaching') !== true) {\n              switch (type) {\n                case 'json':\n                  redis.set(serial, JSON.stringify(cache), 'ex', expired);\n                  break;\n                case 'int':\n                default:\n                  redis.set(serial, cache, 'ex', expired);\n                  break;\n              }\n            }\n          }\n\n          switch (type) {\n            case 'int':\n              return parseInt(cache);\n            case 'float':\n              return _.toNumber(cache);\n            case 'json':\n              try {\n                return _.isObject(cache) ? cache : JSON.parse(cache);\n              } catch (e) {\n                return cache;\n              }\n            default:\n              return cache;\n          }\n        };\n\n        // Define as new connection.\n        strapi.connections[name] = redis;\n\n        // Expose global\n        if (_.get(connection, 'options.global') !== false) {\n          global[_.get(connection, 'options.globalName') || 'redis'] = redis;\n        }\n\n        if (_.get(connection, 'options.debug') === true) {\n          redis.monitor((err, monitor) => {\n            if (err) {\n              console.error(err);\n            }\n            // Entering monitoring mode.\n            monitor.on('monitor', (time, args) => {\n              console.log(time + ': ' + util.inspect(args));\n            });\n          });\n        }\n\n        redis.on('ready', () => {\n          done();\n        });\n      });\n    },\n  };\n\n  return hook;\n};\n",
    "packages/strapi-plugin-content-manager/admin/src/components/DraggedFieldWithPreview/DynamicComponent.js": "import React, { useEffect, useState } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport PropTypes from 'prop-types';\nimport { hasPermissions, useUser } from 'strapi-helper-plugin';\nimport pluginId from '../../pluginId';\nimport pluginPermissions from '../../permissions';\nimport DynamicComponentCard from '../DynamicComponentCard';\nimport Tooltip from './Tooltip';\n\nconst DynamicComponent = ({ componentUid, friendlyName, icon, setIsOverDynamicZone }) => {\n  const [isOver, setIsOver] = useState(false);\n  const [{ isLoading, canAccess }, setState] = useState({ isLoading: true, canAccess: false });\n  const { push } = useHistory();\n  const userPermissions = useUser();\n\n  useEffect(() => {\n    const checkPermission = async () => {\n      try {\n        const canAccess = await hasPermissions(\n          userPermissions,\n          pluginPermissions.componentsConfigurations\n        );\n\n        setState({ isLoading: false, canAccess });\n      } catch (err) {\n        setState({ isLoading: false });\n      }\n    };\n\n    checkPermission();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handleMouseEvent = () => {\n    setIsOverDynamicZone(v => !v);\n    setIsOver(v => !v);\n  };\n\n  return (\n    <DynamicComponentCard\n      componentUid={componentUid}\n      friendlyName={friendlyName}\n      icon={icon}\n      isOver={isOver}\n      onClick={() => {\n        if (!isLoading && canAccess) {\n          push(`/plugins/${pluginId}/components/${componentUid}/configurations/edit`);\n        }\n      }}\n      onMouseEvent={handleMouseEvent}\n      tradId=\"components.DraggableAttr.edit\"\n    >\n      <Tooltip isOver={isOver}>{componentUid}</Tooltip>\n    </DynamicComponentCard>\n  );\n};\n\nDynamicComponent.defaultProps = {\n  friendlyName: '',\n  icon: 'smile',\n};\n\nDynamicComponent.propTypes = {\n  componentUid: PropTypes.string.isRequired,\n  friendlyName: PropTypes.string,\n  icon: PropTypes.string,\n  setIsOverDynamicZone: PropTypes.func.isRequired,\n};\n\nexport default DynamicComponent;\n",
    "packages/strapi-plugin-content-manager/admin/src/components/InputUID/index.js": "import React, { useEffect, useState, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { Sync } from '@buffetjs/icons';\nimport { ErrorMessage, Description } from '@buffetjs/styles';\nimport { Label, Error } from '@buffetjs/core';\nimport { useDebounce, useClickAwayListener } from '@buffetjs/hooks';\nimport styled from 'styled-components';\nimport { request, LoadingIndicator, useGlobalContext } from 'strapi-helper-plugin';\nimport { FormattedMessage } from 'react-intl';\nimport { get } from 'lodash';\n\nimport getTrad from '../../utils/getTrad';\nimport pluginId from '../../pluginId';\nimport getRequestUrl from '../../utils/getRequestUrl';\nimport useDataManager from '../../hooks/useDataManager';\nimport RightLabel from './RightLabel';\nimport Options from './Options';\nimport RegenerateButton from './RegenerateButton';\nimport RightContent from './RightContent';\nimport Input from './InputUID';\nimport Wrapper from './Wrapper';\nimport SubLabel from './SubLabel';\nimport UID_REGEX from './regex';\nimport RightContentLabel from './RightContentLabel';\n\nconst InputContainer = styled.div`\n  position: relative;\n`;\nconst Name = styled(Label)`\n  display: block;\n  text-transform: capitalize;\n  margin-bottom: 1rem;\n`;\n\n// This component should be in buffetjs. It will be used in the media lib.\n// This component will be the strapi custom dropdown component.\n// TODO : Make this component generic -> InputDropdown.\n// TODO : Use the Compounds components pattern\n// https://blog.bitsrc.io/understanding-compound-components-in-react-23c4b84535b5\nconst InputUID = ({\n  attribute,\n  contentTypeUID,\n  description,\n  error: inputError,\n  label: inputLabel,\n  name,\n  onChange,\n  validations,\n  value,\n  editable,\n  ...inputProps\n}) => {\n  const { modifiedData, initialData, layout } = useDataManager();\n  const [isLoading, setIsLoading] = useState(false);\n  const [availability, setAvailability] = useState(null);\n  const [isSuggestionOpen, setIsSuggestionOpen] = useState(true);\n  const [isCustomized, setIsCustomized] = useState(false);\n  const [label, setLabel] = useState();\n  const debouncedValue = useDebounce(value, 300);\n  const debouncedTargetFieldValue = useDebounce(modifiedData[attribute.targetField], 300);\n  const wrapperRef = useRef(null);\n  const generateUid = useRef();\n  const initialValue = initialData[name];\n  const createdAtName = get(layout, ['options', 'timestamps', 0]);\n  const isCreation = !initialData[createdAtName];\n  const { formatMessage } = useGlobalContext();\n\n  generateUid.current = async (shouldSetInitialValue = false) => {\n    setIsLoading(true);\n    const requestURL = getRequestUrl('uid/generate');\n    try {\n      const { data } = await request(requestURL, {\n        method: 'POST',\n        body: {\n          contentTypeUID,\n          field: name,\n          data: modifiedData,\n        },\n      });\n\n      onChange({ target: { name, value: data, type: 'text' } }, shouldSetInitialValue);\n      setIsLoading(false);\n    } catch (err) {\n      console.error({ err });\n      setIsLoading(false);\n    }\n  };\n\n  const checkAvailability = async () => {\n    setIsLoading(true);\n\n    const requestURL = getRequestUrl('uid/check-availability');\n\n    if (!value) {\n      return;\n    }\n\n    try {\n      const data = await request(requestURL, {\n        method: 'POST',\n        body: {\n          contentTypeUID,\n          field: name,\n          value: value ? value.trim() : '',\n        },\n      });\n      setAvailability(data);\n\n      if (data.suggestion) {\n        setIsSuggestionOpen(true);\n      }\n      setIsLoading(false);\n    } catch (err) {\n      console.error({ err });\n      setIsLoading(false);\n    }\n  };\n\n  // FIXME: we need to find a better way to autofill the input when it is required.\n  // useEffect(() => {\n  //   if (!value && validations.required) {\n  //     generateUid.current(true);\n  //   }\n  //   // eslint-disable-next-line react-hooks/exhaustive-deps\n  // }, []);\n\n  useEffect(() => {\n    if (\n      debouncedValue &&\n      debouncedValue.trim().match(UID_REGEX) &&\n      debouncedValue !== initialValue\n    ) {\n      checkAvailability();\n    }\n    if (!debouncedValue) {\n      setAvailability(null);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [debouncedValue, initialValue]);\n\n  useEffect(() => {\n    let timer;\n\n    if (availability && availability.isAvailable) {\n      timer = setTimeout(() => {\n        setAvailability(null);\n      }, 4000);\n    }\n\n    return () => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n    };\n  }, [availability]);\n\n  useEffect(() => {\n    if (\n      !isCustomized &&\n      isCreation &&\n      debouncedTargetFieldValue &&\n      modifiedData[attribute.targetField]\n    ) {\n      generateUid.current(true);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [debouncedTargetFieldValue, isCustomized, isCreation]);\n\n  useClickAwayListener(wrapperRef, () => setIsSuggestionOpen(false));\n\n  const handleFocus = () => {\n    if (availability && availability.suggestion) {\n      setIsSuggestionOpen(true);\n    }\n  };\n\n  const handleSuggestionClick = () => {\n    setIsSuggestionOpen(false);\n    onChange({ target: { name, value: availability.suggestion, type: 'text' } });\n  };\n\n  const handleGenerateMouseEnter = () => {\n    setLabel('regenerate');\n  };\n\n  const handleGenerateMouseLeave = () => {\n    setLabel(null);\n  };\n\n  const handleChange = (e, canCheck, dispatch) => {\n    if (!canCheck) {\n      dispatch({\n        type: 'SET_CHECK',\n      });\n    }\n\n    dispatch({\n      type: 'SET_ERROR',\n      error: null,\n    });\n\n    if (e.target.value && isCreation) {\n      setIsCustomized(true);\n    }\n\n    onChange(e);\n  };\n\n  return (\n    <Error\n      name={name}\n      inputError={inputError}\n      type=\"text\"\n      validations={{ ...validations, regex: UID_REGEX }}\n    >\n      {({ canCheck, onBlur, error, dispatch }) => {\n        const hasError = Boolean(error);\n\n        return (\n          <Wrapper ref={wrapperRef}>\n            <Name htmlFor={name}>{inputLabel}</Name>\n            <InputContainer>\n              <Input\n                {...inputProps}\n                containsEndAdornment={editable}\n                editable={editable}\n                error={hasError}\n                onFocus={handleFocus}\n                name={name}\n                onChange={e => handleChange(e, canCheck, dispatch)}\n                type=\"text\"\n                onBlur={onBlur}\n                // eslint-disable-next-line no-irregular-whitespace\n                value={value || ''}\n              />\n              <RightContent>\n                {label && (\n                  <RightContentLabel color=\"blue\">\n                    {formatMessage({\n                      id: getTrad('components.uid.regenerate'),\n                    })}\n                  </RightContentLabel>\n                )}\n                {!isLoading && !label && availability && (\n                  <RightLabel\n                    isAvailable={availability.isAvailable || value === availability.suggestion}\n                  />\n                )}\n                {editable && (\n                  <RegenerateButton\n                    onMouseEnter={handleGenerateMouseEnter}\n                    onMouseLeave={handleGenerateMouseLeave}\n                    onClick={() => generateUid.current()}\n                  >\n                    {isLoading ? (\n                      <LoadingIndicator small />\n                    ) : (\n                      <Sync fill={label ? '#007EFF' : '#B5B7BB'} width=\"11px\" height=\"11px\" />\n                    )}\n                  </RegenerateButton>\n                )}\n              </RightContent>\n              {availability && availability.suggestion && isSuggestionOpen && (\n                <FormattedMessage id={`${pluginId}.components.uid.suggested`}>\n                  {msg => (\n                    <Options\n                      title={msg}\n                      options={[\n                        {\n                          id: 'suggestion',\n                          label: availability.suggestion,\n                          onClick: handleSuggestionClick,\n                        },\n                      ]}\n                    />\n                  )}\n                </FormattedMessage>\n              )}\n            </InputContainer>\n            {!hasError && description && <SubLabel as={Description}>{description}</SubLabel>}\n            {hasError && <SubLabel as={ErrorMessage}>{error}</SubLabel>}\n          </Wrapper>\n        );\n      }}\n    </Error>\n  );\n};\n\nInputUID.propTypes = {\n  attribute: PropTypes.object.isRequired,\n  contentTypeUID: PropTypes.string.isRequired,\n  description: PropTypes.string,\n  editable: PropTypes.bool,\n  error: PropTypes.string,\n  label: PropTypes.string.isRequired,\n  name: PropTypes.string.isRequired,\n  onChange: PropTypes.func.isRequired,\n  validations: PropTypes.object,\n  value: PropTypes.string,\n};\n\nInputUID.defaultProps = {\n  description: '',\n  editable: false,\n  error: null,\n  validations: {},\n  value: '',\n};\n\nexport default InputUID;\n",
    "packages/strapi-plugin-content-manager/admin/src/components/RelationPreviewList/RelationPreviewTooltip.js": "import React, { useState, useEffect, useCallback, useRef, useLayoutEffect } from 'react';\nimport { Text, Padded } from '@buffetjs/core';\nimport { request } from 'strapi-helper-plugin';\nimport { LoadingIndicator } from '@buffetjs/styles';\nimport PropTypes from 'prop-types';\nimport { getDisplayedValue, getRequestUrl } from '../../utils';\nimport Tooltip from '../Tooltip';\n\nconst RelationPreviewTooltip = ({\n  tooltipId,\n  rowId,\n  mainField,\n  name,\n  queryInfos: { endPoint },\n  size,\n}) => {\n  const [isLoading, setIsLoading] = useState(true);\n  const [relationData, setRelationData] = useState([]);\n  const tooltipRef = useRef();\n\n  const fetchRelationData = useCallback(\n    async signal => {\n      const requestURL = getRequestUrl(`${endPoint}/${rowId}/${name}`);\n      try {\n        const { results } = await request(requestURL, {\n          method: 'GET',\n          signal,\n        });\n\n        setRelationData(results);\n        setIsLoading(false);\n      } catch (err) {\n        console.error({ err });\n        setIsLoading(false);\n      }\n    },\n    [endPoint, name, rowId]\n  );\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const timeout = setTimeout(() => {\n      fetchRelationData(signal);\n    }, 500);\n\n    return () => {\n      clearTimeout(timeout);\n      abortController.abort();\n    };\n  }, [fetchRelationData]);\n\n  const getValueToDisplay = useCallback(\n    item => {\n      return getDisplayedValue(mainField.schema.type, item[mainField.name], mainField.name);\n    },\n    [mainField]\n  );\n\n  // Used to update the position after the loader\n  useLayoutEffect(() => {\n    if (!isLoading && tooltipRef.current) {\n      // A react-tooltip uncaught error is triggered when updatePosition is called in firefox.\n      // https://github.com/wwayne/react-tooltip/issues/619\n      try {\n        tooltipRef.current.updatePosition();\n      } catch (err) {\n        console.log(err);\n      }\n    }\n  }, [isLoading]);\n\n  return (\n    <Tooltip ref={tooltipRef} id={tooltipId}>\n      <div>\n        {isLoading ? (\n          <Padded left right size=\"sm\">\n            <LoadingIndicator borderWidth=\"3px\" size=\"2rem\" />\n          </Padded>\n        ) : (\n          <>\n            {relationData.map(item => (\n              <Padded key={item.id} top bottom size=\"xs\">\n                <Text ellipsis color=\"white\">\n                  {getValueToDisplay(item)}\n                </Text>\n              </Padded>\n            ))}\n            {size > 10 && (\n              <Padded top size=\"xs\">\n                <Text color=\"white\">[...]</Text>\n              </Padded>\n            )}\n          </>\n        )}\n      </div>\n    </Tooltip>\n  );\n};\n\nRelationPreviewTooltip.propTypes = {\n  tooltipId: PropTypes.string.isRequired,\n  mainField: PropTypes.exact({\n    name: PropTypes.string.isRequired,\n    schema: PropTypes.shape({\n      type: PropTypes.string.isRequired,\n    }).isRequired,\n  }).isRequired,\n  name: PropTypes.string.isRequired,\n  size: PropTypes.number.isRequired,\n  rowId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n  queryInfos: PropTypes.shape({\n    endPoint: PropTypes.string.isRequired,\n  }).isRequired,\n};\n\nexport default RelationPreviewTooltip;\n",
    "packages/strapi-plugin-content-manager/admin/src/components/SelectWrapper/index.js": "import React, { useCallback, useState, useEffect, useMemo, memo } from 'react';\nimport PropTypes from 'prop-types';\nimport { FormattedMessage } from 'react-intl';\nimport { Link, useLocation } from 'react-router-dom';\nimport { findIndex, get, isArray, isEmpty } from 'lodash';\nimport { request } from 'strapi-helper-plugin';\nimport { Flex, Text, Padded } from '@buffetjs/core';\nimport pluginId from '../../pluginId';\nimport useDataManager from '../../hooks/useDataManager';\nimport NotAllowedInput from '../NotAllowedInput';\nimport SelectOne from '../SelectOne';\nimport SelectMany from '../SelectMany';\nimport ClearIndicator from './ClearIndicator';\nimport DropdownIndicator from './DropdownIndicator';\nimport IndicatorSeparator from './IndicatorSeparator';\nimport Option from './Option';\nimport { A, BaselineAlignment } from './components';\nimport { connect, select, styles } from './utils';\n\nconst initialPaginationState = {\n  _contains: '',\n  _limit: 20,\n  _start: 0,\n};\nfunction SelectWrapper({\n  description,\n  editable,\n  label,\n  isCreatingEntry,\n  isFieldAllowed,\n  isFieldReadable,\n  mainField,\n  name,\n  relationType,\n  targetModel,\n  placeholder,\n  queryInfos,\n}) {\n  // Disable the input in case of a polymorphic relation\n  const isMorph = useMemo(() => relationType.toLowerCase().includes('morph'), [relationType]);\n  const { addRelation, modifiedData, moveRelation, onChange, onRemoveRelation } = useDataManager();\n  const { pathname } = useLocation();\n\n  const value = get(modifiedData, name, null);\n  const [state, setState] = useState(initialPaginationState);\n  const [options, setOptions] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isOpen, setIsOpen] = useState(false);\n\n  const filteredOptions = useMemo(() => {\n    return options.filter(option => {\n      if (!isEmpty(value)) {\n        // SelectMany\n        if (Array.isArray(value)) {\n          return findIndex(value, o => o.id === option.value.id) === -1;\n        }\n\n        // SelectOne\n        return get(value, 'id', '') !== option.value.id;\n      }\n\n      return true;\n    });\n  }, [options, value]);\n\n  const { endPoint, containsKey, defaultParams, shouldDisplayRelationLink } = queryInfos;\n\n  const isSingle = ['oneWay', 'oneToOne', 'manyToOne', 'oneToManyMorph', 'oneToOneMorph'].includes(\n    relationType\n  );\n\n  const idsToOmit = useMemo(() => {\n    if (!value) {\n      return [];\n    }\n\n    if (isSingle) {\n      return [value.id];\n    }\n\n    return value.map(val => val.id);\n  }, [isSingle, value]);\n\n  const getData = useCallback(\n    async signal => {\n      // Currently polymorphic relations are not handled\n      if (isMorph) {\n        setIsLoading(false);\n\n        return;\n      }\n\n      if (!isFieldAllowed) {\n        setIsLoading(false);\n\n        return;\n      }\n\n      setIsLoading(true);\n\n      const params = { _limit: state._limit, ...defaultParams };\n\n      if (state._contains) {\n        params[containsKey] = state._contains;\n      }\n\n      try {\n        const data = await request(endPoint, {\n          method: 'POST',\n          params,\n          signal,\n          body: { idsToOmit },\n        });\n\n        const formattedData = data.map(obj => {\n          return { value: obj, label: obj[mainField.name] };\n        });\n\n        setOptions(prevState =>\n          prevState.concat(formattedData).filter((obj, index) => {\n            const objIndex = prevState.findIndex(el => el.value.id === obj.value.id);\n\n            if (objIndex === -1) {\n              return true;\n            }\n\n            return prevState.findIndex(el => el.value.id === obj.value.id) === index;\n          })\n        );\n        setIsLoading(false);\n      } catch (err) {\n        // Silent\n      }\n    },\n    [\n      isMorph,\n      isFieldAllowed,\n      state._limit,\n      state._contains,\n      defaultParams,\n      containsKey,\n      endPoint,\n      idsToOmit,\n      mainField.name,\n    ]\n  );\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    if (isOpen) {\n      getData(signal);\n    }\n\n    return () => abortController.abort();\n  }, [getData, isOpen]);\n\n  const handleInputChange = (inputValue, { action }) => {\n    if (action === 'input-change') {\n      setState(prevState => {\n        if (prevState._contains === inputValue) {\n          return prevState;\n        }\n\n        return { ...prevState, _contains: inputValue, _start: 0 };\n      });\n    }\n\n    return inputValue;\n  };\n\n  const handleMenuScrollToBottom = () => {\n    setState(prevState => ({ ...prevState, _limit: prevState._limit + 20 }));\n  };\n\n  const handleMenuClose = () => {\n    setState(initialPaginationState);\n    setIsOpen(false);\n  };\n\n  const handleChange = value => {\n    onChange({ target: { name, value: value ? value.value : value } });\n  };\n\n  const handleAddRelation = value => {\n    addRelation({ target: { name, value } });\n  };\n\n  const handleMenuOpen = () => {\n    setIsOpen(true);\n  };\n\n  const to = `/plugins/${pluginId}/collectionType/${targetModel}/${value ? value.id : null}`;\n\n  const link = useMemo(() => {\n    if (!value) {\n      return null;\n    }\n\n    if (!shouldDisplayRelationLink) {\n      return null;\n    }\n\n    return (\n      <Link to={{ pathname: to, state: { from: pathname } }}>\n        <FormattedMessage id=\"content-manager.containers.Edit.seeDetails\">\n          {msg => <A color=\"mediumBlue\">{msg}</A>}\n        </FormattedMessage>\n      </Link>\n    );\n  }, [shouldDisplayRelationLink, pathname, to, value]);\n\n  const Component = isSingle ? SelectOne : SelectMany;\n  const associationsLength = isArray(value) ? value.length : 0;\n\n  const isDisabled = useMemo(() => {\n    if (isMorph) {\n      return true;\n    }\n\n    if (!isCreatingEntry) {\n      return (!isFieldAllowed && isFieldReadable) || !editable;\n    }\n\n    return !editable;\n  }, [isMorph, isCreatingEntry, editable, isFieldAllowed, isFieldReadable]);\n\n  if (!isFieldAllowed && isCreatingEntry) {\n    return <NotAllowedInput label={label} />;\n  }\n\n  if (!isCreatingEntry && !isFieldAllowed && !isFieldReadable) {\n    return <NotAllowedInput label={label} />;\n  }\n\n  return (\n    <Padded>\n      <BaselineAlignment />\n      <Flex justifyContent=\"space-between\">\n        <Text fontWeight=\"semiBold\">\n          {label}\n          {!isSingle && ` (${associationsLength})`}\n        </Text>\n        {isSingle && link}\n      </Flex>\n      {!isEmpty(description) && (\n        <Padded top size=\"xs\">\n          <BaselineAlignment />\n          <Text fontSize=\"sm\" color=\"grey\" lineHeight=\"12px\" ellipsis>\n            {description}\n          </Text>\n        </Padded>\n      )}\n      <Padded top size=\"sm\">\n        <BaselineAlignment />\n\n        <Component\n          addRelation={handleAddRelation}\n          components={{ ClearIndicator, DropdownIndicator, IndicatorSeparator, Option }}\n          displayNavigationLink={shouldDisplayRelationLink}\n          id={name}\n          isDisabled={isDisabled}\n          isLoading={isLoading}\n          isClearable\n          mainField={mainField}\n          move={moveRelation}\n          name={name}\n          options={filteredOptions}\n          onChange={handleChange}\n          onInputChange={handleInputChange}\n          onMenuClose={handleMenuClose}\n          onMenuOpen={handleMenuOpen}\n          onMenuScrollToBottom={handleMenuScrollToBottom}\n          onRemove={onRemoveRelation}\n          placeholder={\n            isEmpty(placeholder) ? (\n              <FormattedMessage id={`${pluginId}.containers.Edit.addAnItem`} />\n            ) : (\n              placeholder\n            )\n          }\n          styles={styles}\n          targetModel={targetModel}\n          value={value}\n        />\n      </Padded>\n      <div style={{ marginBottom: 28 }} />\n    </Padded>\n  );\n}\n\nSelectWrapper.defaultProps = {\n  editable: true,\n  description: '',\n  label: '',\n  isFieldAllowed: true,\n  placeholder: '',\n};\n\nSelectWrapper.propTypes = {\n  editable: PropTypes.bool,\n  description: PropTypes.string,\n  label: PropTypes.string,\n  isCreatingEntry: PropTypes.bool.isRequired,\n  isFieldAllowed: PropTypes.bool,\n  isFieldReadable: PropTypes.bool.isRequired,\n  mainField: PropTypes.shape({\n    name: PropTypes.string.isRequired,\n    schema: PropTypes.shape({\n      type: PropTypes.string.isRequired,\n    }).isRequired,\n  }).isRequired,\n  name: PropTypes.string.isRequired,\n  placeholder: PropTypes.string,\n  relationType: PropTypes.string.isRequired,\n  targetModel: PropTypes.string.isRequired,\n  queryInfos: PropTypes.exact({\n    containsKey: PropTypes.string.isRequired,\n    defaultParams: PropTypes.object,\n    endPoint: PropTypes.string.isRequired,\n    shouldDisplayRelationLink: PropTypes.bool.isRequired,\n  }).isRequired,\n};\n\nconst Memoized = memo(SelectWrapper);\n\nexport default connect(Memoized, select);\n",
    "packages/strapi-plugin-content-manager/admin/src/components/SettingsViewWrapper/index.js": "import React, { useState, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { get, isEqual, upperFirst } from 'lodash';\nimport { withRouter } from 'react-router-dom';\nimport { FormattedMessage } from 'react-intl';\nimport { Inputs as Input, Header } from '@buffetjs/custom';\nimport {\n  BackHeader,\n  LoadingIndicatorPage,\n  PopUpWarning,\n  // contexts\n  useGlobalContext,\n} from 'strapi-helper-plugin';\nimport pluginId from '../../pluginId';\nimport Block from '../Block';\nimport Container from '../Container';\nimport SectionTitle from '../SectionTitle';\nimport Separator from '../Separator';\n\nconst SettingsViewWrapper = ({\n  children,\n  history: { goBack },\n  displayedFields,\n  inputs,\n  initialData,\n  isEditSettings,\n  isLoading,\n  modifiedData,\n  onChange,\n  onConfirmReset,\n  onConfirmSubmit,\n  name,\n}) => {\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const [showWarningCancel, setWarningCancel] = useState(false);\n  const [showWarningSubmit, setWarningSubmit] = useState(false);\n\n  const attributes = useMemo(() => {\n    return get(modifiedData, ['attributes'], {});\n  }, [modifiedData]);\n\n  const toggleWarningCancel = () => setWarningCancel(prevState => !prevState);\n  const toggleWarningSubmit = () => setWarningSubmit(prevState => !prevState);\n\n  const getPluginHeaderActions = () => {\n    return [\n      {\n        color: 'cancel',\n        onClick: toggleWarningCancel,\n        label: formatMessage({\n          id: 'app.components.Button.reset',\n        }),\n        type: 'button',\n        disabled: isEqual(modifiedData, initialData),\n        style: {\n          fontWeight: 600,\n          paddingLeft: 15,\n          paddingRight: 15,\n        },\n      },\n      {\n        color: 'success',\n        label: formatMessage({\n          id: `${pluginId}.containers.Edit.submit`,\n        }),\n        type: 'submit',\n        disabled: isEqual(modifiedData, initialData),\n        style: {\n          minWidth: 150,\n          fontWeight: 600,\n        },\n      },\n    ];\n  };\n\n  const headerProps = {\n    actions: getPluginHeaderActions(),\n    title: {\n      label: formatMessage(\n        {\n          id: `${pluginId}.components.SettingsViewWrapper.pluginHeader.title`,\n        },\n        { name: upperFirst(name) }\n      ),\n    },\n    content: formatMessage({\n      id: `${pluginId}.components.SettingsViewWrapper.pluginHeader.description.${\n        isEditSettings ? 'edit' : 'list'\n      }-settings`,\n    }),\n  };\n\n  const getSelectOptions = input => {\n    if (input.name === 'settings.defaultSortBy') {\n      return [\n        'id',\n        ...displayedFields.filter(name => {\n          const type = get(attributes, [name, 'type']);\n\n          return !['media', 'richtext', 'dynamiczone', 'relation'].includes(type) && name !== 'id';\n        }),\n      ];\n    }\n\n    if (input.name === 'settings.mainField') {\n      const options = Object.keys(attributes).filter(attr => {\n        const type = get(attributes, [attr, 'type'], '');\n\n        return (\n          ![\n            'dynamiczone',\n            'json',\n            'text',\n            'relation',\n            'component',\n            'boolean',\n            'date',\n            'media',\n            'richtext',\n            'timestamp',\n          ].includes(type) && !!type\n        );\n      });\n\n      return options;\n    }\n\n    return input.options;\n  };\n\n  const handleSubmit = e => {\n    e.preventDefault();\n    toggleWarningSubmit();\n    emitEvent('willSaveContentTypeLayout');\n  };\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <>\n      <BackHeader onClick={goBack} />\n      <Container className=\"container-fluid\">\n        <form onSubmit={handleSubmit}>\n          <Header {...headerProps} />\n          <div\n            className=\"row\"\n            style={{\n              paddingTop: '3px',\n            }}\n          >\n            <Block\n              style={{\n                marginBottom: '13px',\n                paddingBottom: '30px',\n                paddingTop: '24px',\n              }}\n            >\n              <SectionTitle isSettings />\n              <div className=\"row\">\n                {inputs.map(input => {\n                  return (\n                    <FormattedMessage key={input.name} id={input.label.id}>\n                      {label => (\n                        <div className={input.customBootstrapClass}>\n                          <FormattedMessage\n                            id={get(input, 'description.id', 'app.utils.defaultMessage')}\n                          >\n                            {description => (\n                              <Input\n                                {...input}\n                                description={description}\n                                label={label === ' ' ? null : label}\n                                onChange={onChange}\n                                options={getSelectOptions(input)}\n                                value={get(modifiedData, input.name, '')}\n                              />\n                            )}\n                          </FormattedMessage>\n                        </div>\n                      )}\n                    </FormattedMessage>\n                  );\n                })}\n                <div className=\"col-12\">\n                  <Separator style={{ marginBottom: 20 }} />\n                </div>\n              </div>\n              <SectionTitle />\n              {children}\n            </Block>\n          </div>\n          <PopUpWarning\n            isOpen={showWarningCancel}\n            toggleModal={toggleWarningCancel}\n            content={{\n              message: `${pluginId}.popUpWarning.warning.cancelAllSettings`,\n            }}\n            popUpWarningType=\"danger\"\n            onConfirm={() => {\n              onConfirmReset();\n              toggleWarningCancel();\n            }}\n          />\n          <PopUpWarning\n            isOpen={showWarningSubmit}\n            toggleModal={toggleWarningSubmit}\n            content={{\n              message: `${pluginId}.popUpWarning.warning.updateAllSettings`,\n            }}\n            popUpWarningType=\"danger\"\n            onConfirm={async () => {\n              await onConfirmSubmit();\n              toggleWarningSubmit();\n            }}\n          />\n        </form>\n      </Container>\n    </>\n  );\n};\n\nSettingsViewWrapper.defaultProps = {\n  displayedFields: [],\n  inputs: [],\n  initialData: {},\n  isEditSettings: false,\n  modifiedData: {},\n  name: '',\n  onConfirmReset: () => {},\n  onConfirmSubmit: async () => {},\n  onSubmit: () => {},\n  pluginHeaderProps: {\n    actions: [],\n    description: {\n      id: 'app.utils.defaultMessage',\n    },\n    title: {\n      id: 'app.utils.defaultMessage',\n      values: {},\n    },\n  },\n};\n\nSettingsViewWrapper.propTypes = {\n  children: PropTypes.node.isRequired,\n  displayedFields: PropTypes.array,\n  history: PropTypes.shape({\n    goBack: PropTypes.func.isRequired,\n  }).isRequired,\n  initialData: PropTypes.object,\n  inputs: PropTypes.array,\n  isEditSettings: PropTypes.bool,\n  isLoading: PropTypes.bool.isRequired,\n  modifiedData: PropTypes.object,\n  name: PropTypes.string,\n  onChange: PropTypes.func.isRequired,\n  onConfirmReset: PropTypes.func,\n  onConfirmSubmit: PropTypes.func,\n  onSubmit: PropTypes.func,\n  pluginHeaderProps: PropTypes.shape({\n    actions: PropTypes.array,\n    description: PropTypes.shape({\n      id: PropTypes.string,\n    }),\n    title: PropTypes.shape({\n      id: PropTypes.string,\n      values: PropTypes.object,\n    }),\n  }),\n};\n\nexport default withRouter(SettingsViewWrapper);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/CollectionTypeFormWrapper/index.js": "import { memo, useCallback, useEffect, useMemo, useRef, useReducer } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { get } from 'lodash';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\nimport PropTypes from 'prop-types';\nimport {\n  createDefaultForm,\n  formatComponentData,\n  getTrad,\n  removePasswordFieldsFromData,\n  removeFieldsFromClonedData,\n} from '../../utils';\nimport pluginId from '../../pluginId';\nimport { crudInitialState, crudReducer } from '../../sharedReducers';\nimport { getRequestUrl } from './utils';\n\n// This container is used to handle the CRUD\nconst CollectionTypeFormWrapper = ({ allLayoutData, children, from, slug, id, origin }) => {\n  const { emitEvent } = useGlobalContext();\n  const { push, replace } = useHistory();\n\n  const [\n    { componentsDataStructure, contentTypeDataStructure, data, isLoading, status },\n    dispatch,\n  ] = useReducer(crudReducer, crudInitialState);\n  const emitEventRef = useRef(emitEvent);\n\n  const isCreatingEntry = id === 'create';\n\n  const requestURL = useMemo(() => {\n    if (isCreatingEntry && !origin) {\n      return null;\n    }\n\n    return getRequestUrl(`${slug}/${origin || id}`);\n  }, [slug, id, isCreatingEntry, origin]);\n\n  const cleanClonedData = useCallback(\n    data => {\n      if (!origin) {\n        return data;\n      }\n\n      const cleaned = removeFieldsFromClonedData(\n        data,\n        allLayoutData.contentType,\n        allLayoutData.components\n      );\n\n      return cleaned;\n    },\n    [allLayoutData, origin]\n  );\n\n  const cleanReceivedData = useCallback(\n    data => {\n      const cleaned = removePasswordFieldsFromData(\n        data,\n        allLayoutData.contentType,\n        allLayoutData.components\n      );\n\n      return formatComponentData(cleaned, allLayoutData.contentType, allLayoutData.components);\n    },\n    [allLayoutData]\n  );\n\n  // SET THE DEFAULT LAYOUT the effect is applied when the slug changes\n  useEffect(() => {\n    const componentsDataStructure = Object.keys(allLayoutData.components).reduce((acc, current) => {\n      const defaultComponentForm = createDefaultForm(\n        get(allLayoutData, ['components', current, 'attributes'], {}),\n        allLayoutData.components\n      );\n\n      acc[current] = formatComponentData(\n        defaultComponentForm,\n        allLayoutData.components[current],\n        allLayoutData.components\n      );\n\n      return acc;\n    }, {});\n\n    const contentTypeDataStructure = createDefaultForm(\n      allLayoutData.contentType.attributes,\n      allLayoutData.components\n    );\n\n    dispatch({\n      type: 'SET_DATA_STRUCTURES',\n      componentsDataStructure,\n      contentTypeDataStructure: formatComponentData(\n        contentTypeDataStructure,\n        allLayoutData.contentType,\n        allLayoutData.components\n      ),\n    });\n  }, [allLayoutData]);\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const getData = async signal => {\n      dispatch({ type: 'GET_DATA' });\n\n      try {\n        const data = await request(requestURL, { method: 'GET', signal });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data: cleanReceivedData(cleanClonedData(data)),\n        });\n      } catch (err) {\n        if (err.name === 'AbortError') {\n          return;\n        }\n\n        console.error(err);\n\n        const resStatus = get(err, 'response.status', null);\n\n        if (resStatus === 404) {\n          push(from);\n\n          return;\n        }\n\n        // Not allowed to read a document\n        if (resStatus === 403) {\n          strapi.notification.info(getTrad('permissions.not-allowed.update'));\n\n          push(from);\n        }\n      }\n    };\n\n    if (requestURL) {\n      getData(signal);\n    } else {\n      dispatch({ type: 'INIT_FORM' });\n    }\n\n    return () => {\n      abortController.abort();\n    };\n  }, [requestURL, push, from, cleanReceivedData, cleanClonedData]);\n\n  const displayErrors = useCallback(err => {\n    const errorPayload = err.response.payload;\n    console.error(errorPayload);\n\n    let errorMessage = get(errorPayload, ['message'], 'Bad Request');\n\n    // TODO handle errors correctly when back-end ready\n    if (Array.isArray(errorMessage)) {\n      errorMessage = get(errorMessage, ['0', 'messages', '0', 'id']);\n    }\n\n    if (typeof errorMessage === 'string') {\n      strapi.notification.error(errorMessage);\n    }\n  }, []);\n\n  const onDelete = useCallback(\n    async trackerProperty => {\n      try {\n        emitEventRef.current('willDeleteEntry', trackerProperty);\n\n        const response = await request(getRequestUrl(`${slug}/${id}`), {\n          method: 'DELETE',\n        });\n\n        strapi.notification.success(getTrad('success.record.delete'));\n\n        emitEventRef.current('didDeleteEntry', trackerProperty);\n\n        return Promise.resolve(response);\n      } catch (err) {\n        emitEventRef.current('didNotDeleteEntry', { error: err, ...trackerProperty });\n\n        return Promise.reject(err);\n      }\n    },\n    [id, slug]\n  );\n\n  const onDeleteSucceeded = useCallback(() => {\n    replace(from);\n  }, [from, replace]);\n\n  const onPost = useCallback(\n    async (body, trackerProperty) => {\n      const endPoint = getRequestUrl(slug);\n\n      try {\n        // Show a loading button in the EditView/Header.js && lock the app => no navigation\n        dispatch({ type: 'SET_STATUS', status: 'submit-pending' });\n\n        const response = await request(endPoint, { method: 'POST', body });\n\n        emitEventRef.current('didCreateEntry', trackerProperty);\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('success.record.save') },\n        });\n\n        dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n        // Enable navigation and remove loaders\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n\n        replace(`/plugins/${pluginId}/collectionType/${slug}/${response.id}`);\n      } catch (err) {\n        emitEventRef.current('didNotCreateEntry', { error: err, trackerProperty });\n        displayErrors(err);\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      }\n    },\n    [cleanReceivedData, displayErrors, replace, slug]\n  );\n\n  const onPublish = useCallback(async () => {\n    try {\n      emitEventRef.current('willPublishEntry');\n      const endPoint = getRequestUrl(`${slug}/${id}/actions/publish`);\n\n      dispatch({ type: 'SET_STATUS', status: 'publish-pending' });\n\n      const data = await request(endPoint, { method: 'POST' });\n\n      emitEventRef.current('didPublishEntry');\n\n      dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(data) });\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: getTrad('success.record.publish') },\n      });\n    } catch (err) {\n      displayErrors(err);\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n    }\n  }, [cleanReceivedData, displayErrors, id, slug]);\n\n  const onPut = useCallback(\n    async (body, trackerProperty) => {\n      const endPoint = getRequestUrl(`${slug}/${id}`);\n\n      try {\n        emitEventRef.current('willEditEntry', trackerProperty);\n\n        dispatch({ type: 'SET_STATUS', status: 'submit-pending' });\n\n        const response = await request(endPoint, { method: 'PUT', body });\n\n        emitEventRef.current('didEditEntry', { trackerProperty });\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('success.record.save') },\n        });\n\n        dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      } catch (err) {\n        emitEventRef.current('didNotEditEntry', { error: err, trackerProperty });\n        displayErrors(err);\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      }\n    },\n    [cleanReceivedData, displayErrors, slug, id]\n  );\n\n  const onUnpublish = useCallback(async () => {\n    const endPoint = getRequestUrl(`${slug}/${id}/actions/unpublish`);\n\n    dispatch({ type: 'SET_STATUS', status: 'unpublish-pending' });\n\n    try {\n      emitEventRef.current('willUnpublishEntry');\n\n      const response = await request(endPoint, { method: 'POST' });\n\n      emitEventRef.current('didUnpublishEntry');\n      strapi.notification.success(getTrad('success.record.unpublish'));\n\n      dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n    } catch (err) {\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      displayErrors(err);\n    }\n  }, [cleanReceivedData, displayErrors, id, slug]);\n\n  return children({\n    componentsDataStructure,\n    contentTypeDataStructure,\n    data,\n    isCreatingEntry,\n    isLoadingForData: isLoading,\n    onDelete,\n    onDeleteSucceeded,\n    onPost,\n    onPublish,\n    onPut,\n    onUnpublish,\n    status,\n  });\n};\n\nCollectionTypeFormWrapper.defaultProps = {\n  from: '/',\n  origin: null,\n};\n\nCollectionTypeFormWrapper.propTypes = {\n  allLayoutData: PropTypes.exact({\n    components: PropTypes.object.isRequired,\n    contentType: PropTypes.exact({\n      apiID: PropTypes.string.isRequired,\n      attributes: PropTypes.object.isRequired,\n      info: PropTypes.object.isRequired,\n      isDisplayed: PropTypes.bool.isRequired,\n      kind: PropTypes.string.isRequired,\n      layouts: PropTypes.object.isRequired,\n      metadatas: PropTypes.object.isRequired,\n      options: PropTypes.object.isRequired,\n      settings: PropTypes.object.isRequired,\n      uid: PropTypes.string.isRequired,\n    }).isRequired,\n  }).isRequired,\n  children: PropTypes.func.isRequired,\n  from: PropTypes.string,\n  id: PropTypes.string.isRequired,\n  origin: PropTypes.string,\n  slug: PropTypes.string.isRequired,\n};\n\nexport default memo(CollectionTypeFormWrapper);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/ComponentSetttingsView/index.js": "import React, { memo, useEffect, useMemo, useReducer } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { CheckPagePermissions, LoadingIndicatorPage, request } from 'strapi-helper-plugin';\nimport { useSelector } from 'react-redux';\nimport { getRequestUrl, mergeMetasWithSchema } from '../../utils';\nimport { makeSelectModelAndComponentSchemas } from '../Main/selectors';\nimport pluginPermissions from '../../permissions';\nimport { crudInitialState, crudReducer } from '../../sharedReducers';\nimport EditSettingsView from '../EditSettingsView';\n\nconst ComponentSettingsView = () => {\n  const [{ isLoading, data: layout }, dispatch] = useReducer(crudReducer, crudInitialState);\n  const schemasSelector = useMemo(makeSelectModelAndComponentSchemas, []);\n  const { schemas } = useSelector(state => schemasSelector(state), []);\n  const { uid } = useParams();\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const getData = async signal => {\n      try {\n        dispatch({ type: 'GET_DATA' });\n\n        const { data } = await request(getRequestUrl(`components/${uid}/configuration`), {\n          method: 'GET',\n          signal,\n        });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data: mergeMetasWithSchema(data, schemas, 'component'),\n        });\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    getData(signal);\n\n    return () => {\n      abortController.abort();\n    };\n  }, [uid, schemas]);\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <CheckPagePermissions permissions={pluginPermissions.componentsConfigurations}>\n      <EditSettingsView components={layout.components} mainLayout={layout.component} slug={uid} />\n    </CheckPagePermissions>\n  );\n};\n\nexport default memo(ComponentSettingsView);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/EditSettingsView/index.js": "import React, { useCallback, useMemo, useReducer, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { useHistory } from 'react-router-dom';\nimport { useSelector } from 'react-redux';\nimport { cloneDeep, flatMap, get, set, pick } from 'lodash';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\nimport { Inputs as Input } from '@buffetjs/custom';\nimport { FormattedMessage } from 'react-intl';\nimport pluginId from '../../pluginId';\nimport { getInjectedComponents, getRequestUrl } from '../../utils';\nimport FieldsReorder from '../../components/FieldsReorder';\nimport FormTitle from '../../components/FormTitle';\nimport LayoutTitle from '../../components/LayoutTitle';\nimport PopupForm from '../../components/PopupForm';\nimport SettingsViewWrapper from '../../components/SettingsViewWrapper';\nimport SortableList from '../../components/SortableList';\nimport { makeSelectModelAndComponentSchemas } from '../Main/selectors';\nimport LayoutDndProvider from '../LayoutDndProvider';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\nimport { createPossibleMainFieldsForModelsAndComponents, getInputProps } from './utils';\nimport { unformatLayout } from './utils/layout';\n\nconst EditSettingsView = ({ components, mainLayout, isContentTypeView, slug, updateLayout }) => {\n  const { push } = useHistory();\n  const { currentEnvironment, emitEvent, plugins } = useGlobalContext();\n\n  const [reducerState, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, mainLayout, components)\n  );\n  const [isModalFormOpen, setIsModalFormOpen] = useState(false);\n  const [isDraggingSibling, setIsDraggingSibling] = useState(false);\n\n  const schemasSelector = useMemo(makeSelectModelAndComponentSchemas, []);\n  const { schemas } = useSelector(state => schemasSelector(state), []);\n\n  const { componentLayouts, initialData, metaToEdit, modifiedData, metaForm } = reducerState.toJS();\n\n  const componentsAndModelsPossibleMainFields = useMemo(() => {\n    return createPossibleMainFieldsForModelsAndComponents(schemas);\n  }, [schemas]);\n\n  const fieldsReorderClassName = isContentTypeView ? 'col-8' : 'col-12';\n\n  const attributes = useMemo(() => get(modifiedData, 'attributes', {}), [modifiedData]);\n  const editLayout = modifiedData.layouts.edit;\n  const relationsLayout = modifiedData.layouts.editRelations;\n  const editRelationsLayoutRemainingFields = useMemo(() => {\n    return Object.keys(attributes)\n      .filter(attr => attributes[attr].type === 'relation')\n      .filter(attr => relationsLayout.indexOf(attr) === -1);\n  }, [attributes, relationsLayout]);\n\n  const formToDisplay = useMemo(() => {\n    if (!metaToEdit) {\n      return [];\n    }\n\n    const associatedMetas = get(modifiedData, ['metadatas', metaToEdit, 'edit'], {});\n\n    return Object.keys(associatedMetas).filter(meta => meta !== 'visible');\n  }, [metaToEdit, modifiedData]);\n\n  const editLayoutRemainingFields = useMemo(() => {\n    const displayedFields = flatMap(modifiedData.layouts.edit, 'rowContent');\n\n    return Object.keys(modifiedData.attributes)\n      .filter(attr => {\n        if (!isContentTypeView) {\n          return true;\n        }\n\n        return get(modifiedData, ['attributes', attr, 'type'], '') !== 'relation';\n      })\n      .filter(attr => get(modifiedData, ['metadatas', attr, 'edit', 'visible'], false) === true)\n      .filter(attr => {\n        return displayedFields.findIndex(el => el.name === attr) === -1;\n      })\n      .sort();\n  }, [isContentTypeView, modifiedData]);\n\n  const getSelectedItemSelectOptions = useCallback(\n    formType => {\n      if (formType !== 'relation' && formType !== 'component') {\n        return [];\n      }\n\n      const targetKey = formType === 'component' ? 'component' : 'targetModel';\n      const key = get(modifiedData, ['attributes', metaToEdit, targetKey], '');\n\n      return get(componentsAndModelsPossibleMainFields, [key], []);\n    },\n\n    [metaToEdit, componentsAndModelsPossibleMainFields, modifiedData]\n  );\n\n  const handleChange = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name.split('.'),\n      value,\n    });\n  };\n\n  const handleChangeMeta = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE_META',\n      keys: name.split('.'),\n      value,\n    });\n  };\n\n  const handleConfirm = async () => {\n    try {\n      const body = pick(cloneDeep(modifiedData), ['layouts', 'metadatas', 'settings']);\n\n      // We need to send the unformated edit layout\n      set(body, 'layouts.edit', unformatLayout(body.layouts.edit));\n\n      const requestURL = isContentTypeView\n        ? getRequestUrl(`content-types/${slug}/configuration`)\n        : getRequestUrl(`components/${slug}/configuration`);\n\n      const response = await request(requestURL, { method: 'PUT', body });\n\n      if (updateLayout) {\n        updateLayout(response.data);\n      }\n\n      dispatch({\n        type: 'SUBMIT_SUCCEEDED',\n      });\n\n      emitEvent('didEditEditSettings');\n    } catch (err) {\n      strapi.notification.error('notification.error');\n    }\n  };\n\n  const handleSubmitMetaForm = e => {\n    e.preventDefault();\n    dispatch({\n      type: 'SUBMIT_META_FORM',\n    });\n    toggleModalForm();\n  };\n\n  const moveItem = (dragIndex, hoverIndex, dragRowIndex, hoverRowIndex) => {\n    // Same row = just reorder\n    if (dragRowIndex === hoverRowIndex) {\n      dispatch({\n        type: 'REORDER_ROW',\n        dragRowIndex,\n        dragIndex,\n        hoverIndex,\n      });\n    } else {\n      dispatch({\n        type: 'REORDER_DIFF_ROW',\n        dragIndex,\n        hoverIndex,\n        dragRowIndex,\n        hoverRowIndex,\n      });\n    }\n  };\n\n  const moveRow = (dragRowIndex, hoverRowIndex) => {\n    dispatch({\n      type: 'MOVE_ROW',\n      dragRowIndex,\n      hoverRowIndex,\n    });\n  };\n\n  const toggleModalForm = () => {\n    setIsModalFormOpen(prevState => !prevState);\n  };\n\n  const renderForm = () =>\n    formToDisplay.map((meta, index) => {\n      const formType = get(attributes, [metaToEdit, 'type']);\n\n      if (formType === 'dynamiczone' && !['label', 'description'].includes(meta)) {\n        return null;\n      }\n\n      if ((formType === 'component' || formType === 'media') && meta !== 'label') {\n        return null;\n      }\n\n      if ((formType === 'json' || formType === 'boolean') && meta === 'placeholder') {\n        return null;\n      }\n\n      if (formType === 'richtext' && meta === 'editable') {\n        return null;\n      }\n\n      return (\n        <div className=\"col-6\" key={meta}>\n          <FormattedMessage\n            id={`${pluginId}.containers.SettingPage.editSettings.relation-field.description`}\n          >\n            {description => (\n              <FormattedMessage\n                id={get(getInputProps(meta), 'label.id', 'app.utils.defaultMessage')}\n              >\n                {label => (\n                  <Input\n                    autoFocus={index === 0}\n                    description={meta === 'mainField' ? description : ''}\n                    label={label}\n                    name={meta}\n                    type={getInputProps(meta).type}\n                    value={get(metaForm, meta, '')}\n                    onChange={handleChangeMeta}\n                    options={getSelectedItemSelectOptions(formType)}\n                  />\n                )}\n              </FormattedMessage>\n            )}\n          </FormattedMessage>\n        </div>\n      );\n    });\n\n  return (\n    <LayoutDndProvider\n      attributes={attributes}\n      buttonData={editLayoutRemainingFields}\n      componentLayouts={componentLayouts}\n      goTo={push}\n      isDraggingSibling={isDraggingSibling}\n      layout={editLayout}\n      metadatas={get(modifiedData, ['metadatas'], {})}\n      moveItem={moveItem}\n      moveRow={moveRow}\n      onAddData={name => {\n        dispatch({\n          type: 'ON_ADD_DATA',\n          name,\n        });\n      }}\n      relationsLayout={relationsLayout}\n      removeField={(rowIndex, fieldIndex) => {\n        dispatch({\n          type: 'REMOVE_FIELD',\n          rowIndex,\n          fieldIndex,\n        });\n      }}\n      setEditFieldToSelect={name => {\n        dispatch({\n          type: 'SET_FIELD_TO_EDIT',\n          name,\n        });\n        toggleModalForm();\n      }}\n      setIsDraggingSibling={setIsDraggingSibling}\n      selectedItemName={metaToEdit}\n    >\n      <SettingsViewWrapper\n        inputs={[\n          {\n            label: {\n              id: `${pluginId}.containers.SettingPage.editSettings.entry.title`,\n            },\n            description: {\n              id: `${pluginId}.containers.SettingPage.editSettings.entry.title.description`,\n            },\n            type: 'select',\n            name: 'settings.mainField',\n            customBootstrapClass: 'col-md-4',\n            selectOptions: ['id'],\n            didCheckErrors: false,\n            validations: {},\n          },\n        ]}\n        initialData={initialData}\n        isLoading={false}\n        modifiedData={modifiedData}\n        name={modifiedData.info.name}\n        onChange={handleChange}\n        onConfirmReset={() => {\n          dispatch({\n            type: 'ON_RESET',\n          });\n        }}\n        onConfirmSubmit={handleConfirm}\n        slug={slug}\n        isEditSettings\n      >\n        <div className=\"row\">\n          <LayoutTitle className={fieldsReorderClassName}>\n            <div\n              style={{\n                display: 'flex',\n                justifyContent: 'space-between',\n              }}\n            >\n              <div>\n                <FormTitle\n                  title={`${pluginId}.global.displayedFields`}\n                  description={`${pluginId}.containers.SettingPage.editSettings.description`}\n                />\n              </div>\n              <div\n                style={{\n                  marginTop: -6,\n                }}\n              >\n                {getInjectedComponents(\n                  'editSettingsView',\n                  'left.links',\n                  plugins,\n                  currentEnvironment,\n                  slug,\n                  push,\n                  {\n                    componentSlug: slug,\n                    type: isContentTypeView ? 'content-types' : 'components',\n                    modifiedData,\n                  }\n                )}\n              </div>\n            </div>\n          </LayoutTitle>\n          {isContentTypeView && (\n            <LayoutTitle className=\"col-4\">\n              <FormTitle\n                title={`${pluginId}.containers.SettingPage.relations`}\n                description={`${pluginId}.containers.SettingPage.editSettings.description`}\n              />\n            </LayoutTitle>\n          )}\n\n          <FieldsReorder className={fieldsReorderClassName} />\n          {isContentTypeView && (\n            <SortableList\n              addItem={name => {\n                dispatch({\n                  type: 'ADD_RELATION',\n                  name,\n                });\n              }}\n              buttonData={editRelationsLayoutRemainingFields}\n              moveItem={(dragIndex, hoverIndex) => {\n                dispatch({\n                  type: 'MOVE_RELATION',\n                  dragIndex,\n                  hoverIndex,\n                });\n              }}\n              removeItem={index => {\n                dispatch({\n                  type: 'REMOVE_RELATION',\n                  index,\n                });\n              }}\n            />\n          )}\n        </div>\n      </SettingsViewWrapper>\n\n      <PopupForm\n        headerId={`${pluginId}.containers.EditSettingsView.modal-form.edit-field`}\n        isOpen={isModalFormOpen}\n        onClosed={() => {\n          dispatch({\n            type: 'UNSET_FIELD_TO_EDIT',\n          });\n        }}\n        onSubmit={handleSubmitMetaForm}\n        onToggle={toggleModalForm}\n        renderForm={renderForm}\n        subHeaderContent={metaToEdit}\n        type={get(attributes, [metaToEdit, 'type'], '')}\n      />\n    </LayoutDndProvider>\n  );\n};\n\nEditSettingsView.defaultProps = {\n  isContentTypeView: false,\n  updateLayout: null,\n};\n\nEditSettingsView.propTypes = {\n  components: PropTypes.object.isRequired,\n  mainLayout: PropTypes.shape({\n    attributes: PropTypes.object.isRequired,\n    info: PropTypes.object.isRequired,\n    layouts: PropTypes.shape({\n      list: PropTypes.array.isRequired,\n      editRelations: PropTypes.array.isRequired,\n      edit: PropTypes.array.isRequired,\n    }).isRequired,\n    metadatas: PropTypes.object.isRequired,\n    options: PropTypes.object.isRequired,\n  }).isRequired,\n  isContentTypeView: PropTypes.bool,\n\n  slug: PropTypes.string.isRequired,\n  updateLayout: PropTypes.func,\n};\n\nexport default EditSettingsView;\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/EditView/DeleteLink/index.js": "import React, { memo, useState } from 'react';\nimport { useIntl } from 'react-intl';\nimport { get } from 'lodash';\nimport isEqual from 'react-fast-compare';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { Text } from '@buffetjs/core';\nimport { PopUpWarning } from 'strapi-helper-plugin';\nimport PropTypes from 'prop-types';\nimport pluginId from '../../../pluginId';\nimport { getTrad } from '../../../utils';\nimport { DeleteButton } from '../components';\nimport { connect, select } from './utils';\n\nconst DeleteLink = ({ isCreatingEntry, onDelete, onDeleteSucceeded, trackerProperty }) => {\n  const [showWarningDelete, setWarningDelete] = useState(false);\n  const [didDeleteEntry, setDidDeleteEntry] = useState(false);\n  const [isModalConfirmButtonLoading, setIsModalConfirmButtonLoading] = useState(false);\n  const { formatMessage } = useIntl();\n\n  const toggleWarningDelete = () => setWarningDelete(prevState => !prevState);\n\n  const handleConfirmDelete = async () => {\n    try {\n      // Show the loading state\n      setIsModalConfirmButtonLoading(true);\n\n      await onDelete(trackerProperty);\n\n      // This is used to perform action after the modal is closed\n      // so the transitions are smoother\n      // Actions will be performed in the handleClosed function\n      setDidDeleteEntry(true);\n    } catch (err) {\n      const errorMessage = get(\n        err,\n        'response.payload.message',\n        formatMessage({ id: `${pluginId}.error.record.delete` })\n      );\n      strapi.notification.error(errorMessage);\n    } finally {\n      setIsModalConfirmButtonLoading(false);\n      toggleWarningDelete();\n    }\n  };\n\n  const handleClosed = () => {\n    setDidDeleteEntry(false);\n\n    if (didDeleteEntry) {\n      onDeleteSucceeded();\n    }\n  };\n\n  if (isCreatingEntry) {\n    return null;\n  }\n\n  return (\n    <>\n      <li>\n        <DeleteButton onClick={toggleWarningDelete}>\n          <FontAwesomeIcon icon=\"trash-alt\" />\n          <Text lineHeight=\"22px\" color=\"lightOrange\">\n            {formatMessage({\n              id: getTrad('containers.Edit.delete-entry'),\n            })}\n          </Text>\n        </DeleteButton>\n      </li>\n      <PopUpWarning\n        isOpen={showWarningDelete}\n        toggleModal={toggleWarningDelete}\n        content={{\n          message: getTrad('popUpWarning.bodyMessage.contentType.delete'),\n        }}\n        popUpWarningType=\"danger\"\n        onConfirm={handleConfirmDelete}\n        onClosed={handleClosed}\n        isConfirmButtonLoading={isModalConfirmButtonLoading}\n      />\n    </>\n  );\n};\n\nDeleteLink.propTypes = {\n  isCreatingEntry: PropTypes.bool.isRequired,\n  onDelete: PropTypes.func.isRequired,\n  onDeleteSucceeded: PropTypes.func.isRequired,\n  trackerProperty: PropTypes.object.isRequired,\n};\n\nconst Memoized = memo(DeleteLink, isEqual);\n\nexport default connect(Memoized, select);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/EditViewDataManagerProvider/index.js": "import React, { useCallback, useEffect, useMemo, useRef, useReducer } from 'react';\nimport { cloneDeep, get, isEmpty, isEqual, set } from 'lodash';\nimport PropTypes from 'prop-types';\nimport { Prompt, Redirect } from 'react-router-dom';\nimport { LoadingIndicatorPage, useGlobalContext, OverlayBlocker } from 'strapi-helper-plugin';\nimport EditViewDataManagerContext from '../../contexts/EditViewDataManager';\nimport { getTrad, removeKeyInObject } from '../../utils';\nimport reducer, { initialState } from './reducer';\nimport { cleanData, createYupSchema, getYupInnerErrors } from './utils';\n\nconst EditViewDataManagerProvider = ({\n  allLayoutData,\n  allowedActions: { canCreate, canRead, canUpdate },\n  children,\n  componentsDataStructure,\n  contentTypeDataStructure,\n  createActionAllowedFields,\n  from,\n  initialValues,\n  isCreatingEntry,\n  isLoadingForData,\n  isSingleType,\n  onPost,\n  onPublish,\n  onPut,\n  onUnpublish,\n  readActionAllowedFields,\n  // Not sure this is needed anymore\n  redirectToPreviousPage,\n  slug,\n  status,\n  updateActionAllowedFields,\n}) => {\n  const [reducerState, dispatch] = useReducer(reducer, initialState);\n  const {\n    formErrors,\n    initialData,\n    modifiedData,\n    modifiedDZName,\n    shouldCheckErrors,\n  } = reducerState.toJS();\n\n  const currentContentTypeLayout = get(allLayoutData, ['contentType'], {});\n\n  const hasDraftAndPublish = useMemo(() => {\n    return get(currentContentTypeLayout, ['options', 'draftAndPublish'], false);\n  }, [currentContentTypeLayout]);\n\n  const shouldNotRunValidations = useMemo(() => {\n    return hasDraftAndPublish && !initialData.published_at;\n  }, [hasDraftAndPublish, initialData.published_at]);\n\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const emitEventRef = useRef(emitEvent);\n\n  const shouldRedirectToHomepageWhenCreatingEntry = useMemo(() => {\n    if (isLoadingForData) {\n      return false;\n    }\n\n    if (!isCreatingEntry) {\n      return false;\n    }\n\n    if (canCreate === false) {\n      return true;\n    }\n\n    return false;\n  }, [isCreatingEntry, canCreate, isLoadingForData]);\n\n  const shouldRedirectToHomepageWhenEditingEntry = useMemo(() => {\n    if (isLoadingForData) {\n      return false;\n    }\n\n    if (isCreatingEntry) {\n      return false;\n    }\n\n    if (canRead === false && canUpdate === false) {\n      return true;\n    }\n\n    return false;\n  }, [isLoadingForData, isCreatingEntry, canRead, canUpdate]);\n\n  // TODO check this effect if it is really needed (not prio)\n  useEffect(() => {\n    if (!isLoadingForData) {\n      checkFormErrors();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [shouldCheckErrors]);\n\n  useEffect(() => {\n    if (shouldRedirectToHomepageWhenEditingEntry) {\n      strapi.notification.info(getTrad('permissions.not-allowed.update'));\n    }\n  }, [shouldRedirectToHomepageWhenEditingEntry]);\n\n  useEffect(() => {\n    if (shouldRedirectToHomepageWhenCreatingEntry) {\n      strapi.notification.info(getTrad('permissions.not-allowed.create'));\n    }\n  }, [shouldRedirectToHomepageWhenCreatingEntry]);\n\n  useEffect(() => {\n    dispatch({\n      type: 'SET_DEFAULT_DATA_STRUCTURES',\n      componentsDataStructure,\n      contentTypeDataStructure,\n    });\n  }, [componentsDataStructure, contentTypeDataStructure]);\n\n  useEffect(() => {\n    dispatch({\n      type: 'INIT_FORM',\n      initialValues,\n    });\n  }, [initialValues]);\n\n  const addComponentToDynamicZone = useCallback((keys, componentUid, shouldCheckErrors = false) => {\n    emitEventRef.current('didAddComponentToDynamicZone');\n\n    dispatch({\n      type: 'ADD_COMPONENT_TO_DYNAMIC_ZONE',\n      keys: keys.split('.'),\n      componentUid,\n      shouldCheckErrors,\n    });\n  }, []);\n\n  const addNonRepeatableComponentToField = useCallback((keys, componentUid) => {\n    dispatch({\n      type: 'ADD_NON_REPEATABLE_COMPONENT_TO_FIELD',\n      keys: keys.split('.'),\n      componentUid,\n    });\n  }, []);\n\n  const addRelation = useCallback(({ target: { name, value } }) => {\n    dispatch({\n      type: 'ADD_RELATION',\n      keys: name.split('.'),\n      value,\n    });\n  }, []);\n\n  const addRepeatableComponentToField = useCallback(\n    (keys, componentUid, shouldCheckErrors = false) => {\n      dispatch({\n        type: 'ADD_REPEATABLE_COMPONENT_TO_FIELD',\n        keys: keys.split('.'),\n        componentUid,\n        shouldCheckErrors,\n      });\n    },\n    []\n  );\n\n  const yupSchema = useMemo(() => {\n    const options = { isCreatingEntry, isDraft: shouldNotRunValidations, isFromComponent: false };\n\n    return createYupSchema(\n      currentContentTypeLayout,\n      {\n        components: allLayoutData.components || {},\n      },\n      options\n    );\n  }, [\n    allLayoutData.components,\n    currentContentTypeLayout,\n    isCreatingEntry,\n    shouldNotRunValidations,\n  ]);\n\n  const checkFormErrors = useCallback(\n    async (dataToSet = {}) => {\n      let errors = {};\n      const updatedData = cloneDeep(modifiedData);\n\n      if (!isEmpty(updatedData)) {\n        set(updatedData, dataToSet.path, dataToSet.value);\n      }\n\n      try {\n        // Validate the form using yup\n        await yupSchema.validate(updatedData, { abortEarly: false });\n      } catch (err) {\n        errors = getYupInnerErrors(err);\n\n        if (modifiedDZName) {\n          errors = Object.keys(errors).reduce((acc, current) => {\n            const dzName = current.split('.')[0];\n\n            if (dzName !== modifiedDZName) {\n              acc[current] = errors[current];\n            }\n\n            return acc;\n          }, {});\n        }\n      }\n\n      dispatch({\n        type: 'SET_FORM_ERRORS',\n        errors,\n      });\n    },\n    [modifiedDZName, modifiedData, yupSchema]\n  );\n\n  const handleChange = useCallback(\n    ({ target: { name, value, type } }, shouldSetInitialValue = false) => {\n      let inputValue = value;\n\n      // Empty string is not a valid date,\n      // Set the date to null when it's empty\n      if (type === 'date' && value === '') {\n        inputValue = null;\n      }\n\n      if (type === 'password' && !value) {\n        dispatch({\n          type: 'REMOVE_PASSWORD_FIELD',\n          keys: name.split('.'),\n        });\n\n        return;\n      }\n\n      // Allow to reset enum\n      if (type === 'select-one' && value === '') {\n        inputValue = null;\n      }\n\n      // Allow to reset number input\n      if (type === 'number' && value === '') {\n        inputValue = null;\n      }\n\n      dispatch({\n        type: 'ON_CHANGE',\n        keys: name.split('.'),\n        value: inputValue,\n        shouldSetInitialValue,\n      });\n    },\n    []\n  );\n\n  const createFormData = useCallback(\n    data => {\n      // First we need to remove the added keys needed for the dnd\n      const preparedData = removeKeyInObject(cloneDeep(data), '__temp_key__');\n      // Then we need to apply our helper\n      const cleanedData = cleanData(\n        preparedData,\n        currentContentTypeLayout,\n        allLayoutData.components\n      );\n\n      return cleanedData;\n    },\n    [allLayoutData.components, currentContentTypeLayout]\n  );\n\n  const trackerProperty = useMemo(() => {\n    if (!hasDraftAndPublish) {\n      return {};\n    }\n\n    return shouldNotRunValidations ? { status: 'draft' } : {};\n  }, [hasDraftAndPublish, shouldNotRunValidations]);\n\n  const handleSubmit = useCallback(\n    async e => {\n      e.preventDefault();\n      let errors = {};\n\n      // First validate the form\n      try {\n        await yupSchema.validate(modifiedData, { abortEarly: false });\n\n        const formData = createFormData(modifiedData);\n\n        if (isCreatingEntry) {\n          onPost(formData, trackerProperty);\n        } else {\n          onPut(formData, trackerProperty);\n        }\n      } catch (err) {\n        console.error('ValidationError');\n        console.error(err);\n\n        errors = getYupInnerErrors(err);\n      }\n\n      dispatch({\n        type: 'SET_FORM_ERRORS',\n        errors,\n      });\n    },\n    [createFormData, isCreatingEntry, modifiedData, onPost, onPut, trackerProperty, yupSchema]\n  );\n\n  const handlePublish = useCallback(async () => {\n    // Create yup schema here's we need to apply all the validations\n    const schema = createYupSchema(\n      currentContentTypeLayout,\n      {\n        components: get(allLayoutData, 'components', {}),\n      },\n      { isCreatingEntry, isDraft: false, isFromComponent: false }\n    );\n    let errors = {};\n\n    try {\n      // Validate the form using yup\n      await schema.validate(modifiedData, { abortEarly: false });\n\n      onPublish();\n    } catch (err) {\n      console.error('ValidationError');\n      console.error(err);\n\n      errors = getYupInnerErrors(err);\n    }\n\n    dispatch({\n      type: 'SET_FORM_ERRORS',\n      errors,\n    });\n  }, [allLayoutData, currentContentTypeLayout, isCreatingEntry, modifiedData, onPublish]);\n\n  const shouldCheckDZErrors = useCallback(\n    dzName => {\n      const doesDZHaveError = Object.keys(formErrors).some(key => key.split('.')[0] === dzName);\n      const shouldCheckErrors = !isEmpty(formErrors) && doesDZHaveError;\n\n      return shouldCheckErrors;\n    },\n    [formErrors]\n  );\n\n  const moveComponentDown = useCallback(\n    (dynamicZoneName, currentIndex) => {\n      emitEventRef.current('changeComponentsOrder');\n\n      dispatch({\n        type: 'MOVE_COMPONENT_DOWN',\n        dynamicZoneName,\n        currentIndex,\n        shouldCheckErrors: shouldCheckDZErrors(dynamicZoneName),\n      });\n    },\n    [shouldCheckDZErrors]\n  );\n\n  const moveComponentUp = useCallback(\n    (dynamicZoneName, currentIndex) => {\n      emitEventRef.current('changeComponentsOrder');\n\n      dispatch({\n        type: 'MOVE_COMPONENT_UP',\n        dynamicZoneName,\n        currentIndex,\n        shouldCheckErrors: shouldCheckDZErrors(dynamicZoneName),\n      });\n    },\n    [shouldCheckDZErrors]\n  );\n\n  const moveComponentField = useCallback((pathToComponent, dragIndex, hoverIndex) => {\n    dispatch({\n      type: 'MOVE_COMPONENT_FIELD',\n      pathToComponent,\n      dragIndex,\n      hoverIndex,\n    });\n  }, []);\n\n  const moveRelation = useCallback((dragIndex, overIndex, name) => {\n    dispatch({\n      type: 'MOVE_FIELD',\n      dragIndex,\n      overIndex,\n      keys: name.split('.'),\n    });\n  }, []);\n\n  const onRemoveRelation = useCallback(keys => {\n    dispatch({\n      type: 'REMOVE_RELATION',\n      keys,\n    });\n  }, []);\n\n  const removeComponentFromDynamicZone = useCallback(\n    (dynamicZoneName, index) => {\n      emitEventRef.current('removeComponentFromDynamicZone');\n\n      dispatch({\n        type: 'REMOVE_COMPONENT_FROM_DYNAMIC_ZONE',\n        dynamicZoneName,\n        index,\n        shouldCheckErrors: shouldCheckDZErrors(dynamicZoneName),\n      });\n    },\n    [shouldCheckDZErrors]\n  );\n\n  const removeComponentFromField = useCallback((keys, componentUid) => {\n    dispatch({\n      type: 'REMOVE_COMPONENT_FROM_FIELD',\n      keys: keys.split('.'),\n      componentUid,\n    });\n  }, []);\n\n  const removeRepeatableField = useCallback((keys, componentUid) => {\n    dispatch({\n      type: 'REMOVE_REPEATABLE_FIELD',\n      keys: keys.split('.'),\n      componentUid,\n    });\n  }, []);\n\n  const triggerFormValidation = useCallback(() => {\n    dispatch({\n      type: 'TRIGGER_FORM_VALIDATION',\n    });\n  }, []);\n\n  const overlayBlockerParams = useMemo(\n    () => ({\n      children: <div />,\n      noGradient: true,\n    }),\n    []\n  );\n\n  // Redirect the user to the homepage if he is not allowed to create a document\n  if (shouldRedirectToHomepageWhenCreatingEntry) {\n    return <Redirect to=\"/\" />;\n  }\n\n  // Redirect the user to the previous page if he is not allowed to read/update a document\n  if (shouldRedirectToHomepageWhenEditingEntry) {\n    return <Redirect to={from} />;\n  }\n\n  return (\n    <EditViewDataManagerContext.Provider\n      value={{\n        addComponentToDynamicZone,\n        addNonRepeatableComponentToField,\n        addRelation,\n        addRepeatableComponentToField,\n        allLayoutData,\n        checkFormErrors,\n        createActionAllowedFields,\n        formErrors,\n        hasDraftAndPublish,\n        initialData,\n        isCreatingEntry,\n        isSingleType,\n        shouldNotRunValidations,\n        status,\n        layout: currentContentTypeLayout,\n        modifiedData,\n        moveComponentDown,\n        moveComponentField,\n        moveComponentUp,\n        moveRelation,\n        onChange: handleChange,\n        onPublish: handlePublish,\n        onUnpublish,\n        onRemoveRelation,\n        readActionAllowedFields,\n        redirectToPreviousPage,\n        removeComponentFromDynamicZone,\n        removeComponentFromField,\n        removeRepeatableField,\n        slug,\n        triggerFormValidation,\n        updateActionAllowedFields,\n      }}\n    >\n      <>\n        <OverlayBlocker\n          key=\"overlayBlocker\"\n          isOpen={status !== 'resolved'}\n          {...overlayBlockerParams}\n        />\n        {isLoadingForData ? (\n          <LoadingIndicatorPage />\n        ) : (\n          <>\n            <Prompt\n              when={!isEqual(modifiedData, initialData)}\n              message={formatMessage({ id: 'global.prompt.unsaved' })}\n            />\n            <form onSubmit={handleSubmit}>{children}</form>\n          </>\n        )}\n      </>\n    </EditViewDataManagerContext.Provider>\n  );\n};\n\nEditViewDataManagerProvider.defaultProps = {\n  from: '/',\n  redirectToPreviousPage: () => {},\n};\n\nEditViewDataManagerProvider.propTypes = {\n  allLayoutData: PropTypes.object.isRequired,\n  allowedActions: PropTypes.object.isRequired,\n  children: PropTypes.arrayOf(PropTypes.element).isRequired,\n  componentsDataStructure: PropTypes.object.isRequired,\n  contentTypeDataStructure: PropTypes.object.isRequired,\n  createActionAllowedFields: PropTypes.array.isRequired,\n  from: PropTypes.string,\n  initialValues: PropTypes.object.isRequired,\n  isCreatingEntry: PropTypes.bool.isRequired,\n  isLoadingForData: PropTypes.bool.isRequired,\n  isSingleType: PropTypes.bool.isRequired,\n  onPost: PropTypes.func.isRequired,\n  onPublish: PropTypes.func.isRequired,\n  onPut: PropTypes.func.isRequired,\n  onUnpublish: PropTypes.func.isRequired,\n  readActionAllowedFields: PropTypes.array.isRequired,\n  redirectToPreviousPage: PropTypes.func,\n  slug: PropTypes.string.isRequired,\n  status: PropTypes.string.isRequired,\n  updateActionAllowedFields: PropTypes.array.isRequired,\n};\n\nexport default EditViewDataManagerProvider;\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/ListSettingsView/index.js": "import React, { memo, useMemo, useReducer, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { get, pick } from 'lodash';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\nimport { FormattedMessage, useIntl } from 'react-intl';\nimport { useDrop } from 'react-dnd';\nimport { DropdownItem } from 'reactstrap';\nimport { Inputs as Input } from '@buffetjs/custom';\nimport pluginId from '../../pluginId';\nimport { checkIfAttributeIsDisplayable, ItemTypes, getRequestUrl } from '../../utils';\nimport PopupForm from '../../components/PopupForm';\nimport SettingsViewWrapper from '../../components/SettingsViewWrapper';\nimport SortWrapper from '../../components/SortWrapper';\nimport LayoutDndProvider from '../LayoutDndProvider';\nimport Label from './Label';\nimport MenuDropdown from './MenuDropdown';\nimport DropdownButton from './DropdownButton';\nimport DragWrapper from './DragWrapper';\nimport Toggle from './Toggle';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\nimport forms from './forms.json';\n\nconst ListSettingsView = ({ layout, slug, updateLayout }) => {\n  const [reducerState, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, layout)\n  );\n  const [isOpen, setIsOpen] = useState(false);\n  const [isModalFormOpen, setIsModalFormOpen] = useState(false);\n  const [isDraggingSibling, setIsDraggingSibling] = useState(false);\n  const { formatMessage } = useIntl();\n  const { emitEvent } = useGlobalContext();\n  const toggleModalForm = () => setIsModalFormOpen(prevState => !prevState);\n  const { labelForm, labelToEdit, initialData, modifiedData } = reducerState.toJS();\n  const attributes = useMemo(() => {\n    return get(modifiedData, ['attributes'], {});\n  }, [modifiedData]);\n\n  const getName = useMemo(() => {\n    return get(modifiedData, ['info', 'name'], '');\n  }, [modifiedData]);\n\n  const displayedFields = useMemo(() => {\n    return get(modifiedData, ['layouts', 'list'], []);\n  }, [modifiedData]);\n\n  const listRemainingFields = useMemo(() => {\n    const metadatas = get(modifiedData, ['metadatas'], {});\n\n    return Object.keys(metadatas)\n      .filter(key => {\n        return checkIfAttributeIsDisplayable(get(attributes, key, {}));\n      })\n      .filter(field => {\n        return !displayedFields.includes(field);\n      })\n      .sort();\n  }, [displayedFields, attributes, modifiedData]);\n\n  const handleClickEditLabel = labelToEdit => {\n    dispatch({\n      type: 'SET_LABEL_TO_EDIT',\n      labelToEdit,\n    });\n    toggleModalForm();\n  };\n\n  const handleClosed = () => {\n    dispatch({\n      type: 'UNSET_LABEL_TO_EDIT',\n    });\n  };\n\n  const handleChange = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name,\n      value: name === 'settings.pageSize' ? parseInt(value, 10) : value,\n    });\n  };\n\n  const handleChangeEditLabel = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE_LABEL_METAS',\n      name,\n      value,\n    });\n  };\n\n  const handleConfirm = async () => {\n    try {\n      const body = pick(modifiedData, ['layouts', 'settings', 'metadatas']);\n\n      const response = await request(getRequestUrl(`content-types/${slug}/configuration`), {\n        method: 'PUT',\n        body,\n      });\n\n      updateLayout(response.data);\n\n      dispatch({\n        type: 'SUBMIT_SUCCEEDED',\n      });\n      emitEvent('didEditListSettings');\n    } catch (err) {\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  const move = (originalIndex, atIndex) => {\n    dispatch({\n      type: 'MOVE_FIELD',\n      originalIndex,\n      atIndex,\n    });\n  };\n\n  const [, drop] = useDrop({ accept: ItemTypes.FIELD });\n\n  const renderForm = () => {\n    const type = get(attributes, [labelToEdit, 'type'], 'text');\n    const relationType = get(attributes, [labelToEdit, 'relationType']);\n    let shouldDisplaySortToggle = !['media', 'relation'].includes(type);\n    const label = formatMessage({ id: `${pluginId}.form.Input.label` });\n    const description = formatMessage({ id: `${pluginId}.form.Input.label.inputDescription` });\n\n    if (['oneWay', 'oneToOne', 'manyToOne'].includes(relationType)) {\n      shouldDisplaySortToggle = true;\n    }\n\n    return (\n      <>\n        <div className=\"col-6\" style={{ marginBottom: 4 }}>\n          <Input\n            description={description}\n            label={label}\n            type=\"text\"\n            name=\"label\"\n            onBlur={() => {}}\n            value={get(labelForm, 'label', '')}\n            onChange={handleChangeEditLabel}\n          />\n        </div>\n        {shouldDisplaySortToggle && (\n          <div className=\"col-6\" style={{ marginBottom: 4 }}>\n            <FormattedMessage id={`${pluginId}.form.Input.sort.field`}>\n              {label => (\n                <Input\n                  label={label}\n                  type=\"bool\"\n                  name=\"sortable\"\n                  value={get(labelForm, 'sortable', false)}\n                  onChange={handleChangeEditLabel}\n                />\n              )}\n            </FormattedMessage>\n          </div>\n        )}\n      </>\n    );\n  };\n\n  return (\n    <LayoutDndProvider\n      isDraggingSibling={isDraggingSibling}\n      setIsDraggingSibling={setIsDraggingSibling}\n    >\n      <SettingsViewWrapper\n        displayedFields={displayedFields}\n        inputs={forms}\n        isLoading={false}\n        initialData={initialData}\n        modifiedData={modifiedData}\n        onChange={handleChange}\n        onConfirmReset={() => {\n          dispatch({\n            type: 'ON_RESET',\n          });\n        }}\n        onConfirmSubmit={handleConfirm}\n        name={getName}\n      >\n        <DragWrapper>\n          <div className=\"row\">\n            <div className=\"col-12\">\n              <SortWrapper\n                ref={drop}\n                style={{\n                  display: 'flex',\n                  width: '100%',\n                }}\n              >\n                {displayedFields.map((item, index) => {\n                  const label = get(modifiedData, ['metadatas', item, 'list', 'label'], '');\n\n                  return (\n                    <Label\n                      count={displayedFields.length}\n                      key={item}\n                      index={index}\n                      isDraggingSibling={isDraggingSibling}\n                      label={label}\n                      move={move}\n                      name={item}\n                      onClick={handleClickEditLabel}\n                      onRemove={e => {\n                        e.stopPropagation();\n\n                        if (displayedFields.length === 1) {\n                          strapi.notification.toggle({\n                            type: 'info',\n                            message: { id: `${pluginId}.notification.info.minimumFields` },\n                          });\n                        } else {\n                          dispatch({\n                            type: 'REMOVE_FIELD',\n                            index,\n                          });\n                        }\n                      }}\n                      selectedItem={labelToEdit}\n                      setIsDraggingSibling={setIsDraggingSibling}\n                    />\n                  );\n                })}\n              </SortWrapper>\n            </div>\n          </div>\n          <DropdownButton\n            isOpen={isOpen}\n            toggle={() => {\n              if (listRemainingFields.length > 0) {\n                setIsOpen(prevState => !prevState);\n              }\n            }}\n            direction=\"down\"\n            style={{\n              position: 'absolute',\n              top: 11,\n              right: 10,\n            }}\n          >\n            <Toggle disabled={listRemainingFields.length === 0} />\n            <MenuDropdown>\n              {listRemainingFields.map(item => (\n                <DropdownItem\n                  key={item}\n                  onClick={() => {\n                    dispatch({\n                      type: 'ADD_FIELD',\n                      item,\n                    });\n                  }}\n                >\n                  {item}\n                </DropdownItem>\n              ))}\n            </MenuDropdown>\n          </DropdownButton>\n        </DragWrapper>\n      </SettingsViewWrapper>\n      <PopupForm\n        headerId={`${pluginId}.containers.ListSettingsView.modal-form.edit-label`}\n        isOpen={isModalFormOpen}\n        onClosed={handleClosed}\n        onSubmit={e => {\n          e.preventDefault();\n          toggleModalForm();\n          dispatch({\n            type: 'SUBMIT_LABEL_FORM',\n          });\n        }}\n        onToggle={toggleModalForm}\n        renderForm={renderForm}\n        subHeaderContent={labelToEdit}\n        type={get(attributes, [labelToEdit, 'type'], 'text')}\n      />\n    </LayoutDndProvider>\n  );\n};\n\nListSettingsView.propTypes = {\n  layout: PropTypes.shape({\n    uid: PropTypes.string.isRequired,\n    settings: PropTypes.object.isRequired,\n    metadatas: PropTypes.object.isRequired,\n    options: PropTypes.object.isRequired,\n    attributes: PropTypes.object.isRequired,\n  }).isRequired,\n  slug: PropTypes.string.isRequired,\n  updateLayout: PropTypes.func.isRequired,\n};\n\nexport default memo(ListSettingsView);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/ListView/index.js": "import React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { bindActionCreators, compose } from 'redux';\nimport { get, isEmpty } from 'lodash';\nimport { FormattedMessage, useIntl } from 'react-intl';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { Header } from '@buffetjs/custom';\nimport isEqual from 'react-fast-compare';\nimport { stringify } from 'qs';\nimport {\n  PopUpWarning,\n  request,\n  CheckPermissions,\n  useGlobalContext,\n  useUserPermissions,\n} from 'strapi-helper-plugin';\nimport pluginId from '../../pluginId';\nimport pluginPermissions from '../../permissions';\nimport { useQueryParams } from '../../hooks';\nimport {\n  formatFiltersFromQuery,\n  generatePermissionsObject,\n  getRequestUrl,\n  getTrad,\n} from '../../utils';\nimport Container from '../../components/Container';\nimport CustomTable from '../../components/CustomTable';\nimport FilterPicker from '../../components/FilterPicker';\nimport Search from '../../components/Search';\nimport ListViewProvider from '../ListViewProvider';\nimport { AddFilterCta, FilterIcon, Wrapper } from './components';\nimport FieldPicker from './FieldPicker';\nimport Filter from './Filter';\nimport Footer from './Footer';\nimport {\n  getData,\n  getDataSucceeded,\n  onChangeBulk,\n  onChangeBulkSelectall,\n  onDeleteDataError,\n  onDeleteDataSucceeded,\n  onDeleteSeveralDataSucceeded,\n  resetProps,\n  setModalLoadingState,\n  toggleModalDelete,\n  toggleModalDeleteAll,\n  setLayout,\n  onChangeListHeaders,\n  onResetListHeaders,\n} from './actions';\nimport makeSelectListView from './selectors';\n\nimport { getAllAllowedHeaders, getFirstSortableHeader } from './utils';\n\n/* eslint-disable react/no-array-index-key */\n\nfunction ListView({\n  didDeleteData,\n  entriesToDelete,\n  onChangeBulk,\n  onChangeBulkSelectall,\n  onDeleteDataError,\n  onDeleteDataSucceeded,\n  onDeleteSeveralDataSucceeded,\n  setModalLoadingState,\n  showWarningDelete,\n  showModalConfirmButtonLoading,\n  showWarningDeleteAll,\n  toggleModalDelete,\n  toggleModalDeleteAll,\n  data,\n  displayedHeaders,\n  getData,\n  getDataSucceeded,\n  isLoading,\n  layout,\n  onChangeListHeaders,\n  onResetListHeaders,\n  pagination: { total },\n  resetProps,\n  setLayout,\n  slug,\n}) {\n  const {\n    contentType: {\n      attributes,\n      metadatas,\n      settings: {\n        defaultSortBy,\n        defaultSortOrder,\n        bulkable: isBulkable,\n        filterable: isFilterable,\n        searchable: isSearchable,\n        pageSize: defaultPageSize,\n      },\n    },\n  } = layout;\n\n  const { emitEvent } = useGlobalContext();\n  const emitEventRef = useRef(emitEvent);\n  const viewPermissions = useMemo(() => generatePermissionsObject(slug), [slug]);\n  const {\n    isLoading: isLoadingForPermissions,\n    allowedActions: { canCreate, canRead, canUpdate, canDelete },\n  } = useUserPermissions(viewPermissions);\n  const defaultSort = `${defaultSortBy}:${defaultSortOrder}`;\n  const initParams = useMemo(() => ({ page: 1, pageSize: defaultPageSize, _sort: defaultSort }), [\n    defaultPageSize,\n    defaultSort,\n  ]);\n  const [{ query, rawQuery }, setQuery] = useQueryParams(initParams);\n\n  const { pathname } = useLocation();\n  const { push } = useHistory();\n  const { formatMessage } = useIntl();\n\n  const [isFilterPickerOpen, setFilterPickerState] = useState(false);\n  const [idToDelete, setIdToDelete] = useState(null);\n  const contentType = layout.contentType;\n  const hasDraftAndPublish = get(contentType, 'options.draftAndPublish', false);\n  const allAllowedHeaders = useMemo(() => getAllAllowedHeaders(attributes), [attributes]);\n\n  const filters = useMemo(() => {\n    return formatFiltersFromQuery(query);\n  }, [query]);\n\n  const _sort = query._sort;\n  const _q = query._q || '';\n\n  const label = contentType.info.label;\n\n  const params = useMemo(() => {\n    return rawQuery || `?${stringify(initParams, { encode: false })}`;\n  }, [initParams, rawQuery]);\n\n  const firstSortableHeader = useMemo(() => getFirstSortableHeader(displayedHeaders), [\n    displayedHeaders,\n  ]);\n\n  useEffect(() => {\n    setLayout(layout);\n    setFilterPickerState(false);\n\n    return () => {\n      resetProps();\n    };\n  }, [layout, setLayout, resetProps]);\n\n  // Using a ref to avoid requests being fired multiple times on slug on change\n  // We need it because the hook as mulitple dependencies so it may run before the permissions have checked\n  const requestUrlRef = useRef('');\n\n  const fetchData = useCallback(\n    async (endPoint, abortSignal = false) => {\n      getData();\n      const signal = abortSignal || new AbortController().signal;\n\n      try {\n        const { results, pagination } = await request(endPoint, { method: 'GET', signal });\n\n        getDataSucceeded(pagination, results);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          console.error(err);\n          strapi.notification.error(getTrad('error.model.fetch'));\n        }\n      }\n    },\n    [getData, getDataSucceeded]\n  );\n\n  const handleChangeListLabels = useCallback(\n    ({ name, value }) => {\n      // Display a notification if trying to remove the last displayed field\n\n      if (value && displayedHeaders.length === 1) {\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'content-manager.notification.error.displayedFields' },\n        });\n      } else {\n        emitEventRef.current('didChangeDisplayedFields');\n\n        onChangeListHeaders({ name, value });\n      }\n    },\n    [displayedHeaders, onChangeListHeaders]\n  );\n\n  const handleConfirmDeleteAllData = useCallback(async () => {\n    try {\n      setModalLoadingState();\n\n      await request(getRequestUrl(`collection-types/${slug}/actions/bulkDelete`), {\n        method: 'POST',\n        body: { ids: entriesToDelete },\n      });\n\n      onDeleteSeveralDataSucceeded();\n      emitEventRef.current('didBulkDeleteEntries');\n    } catch (err) {\n      strapi.notification.error(`${pluginId}.error.record.delete`);\n    }\n  }, [entriesToDelete, onDeleteSeveralDataSucceeded, slug, setModalLoadingState]);\n\n  const handleConfirmDeleteData = useCallback(async () => {\n    try {\n      let trackerProperty = {};\n\n      if (hasDraftAndPublish) {\n        const dataToDelete = data.find(obj => obj.id.toString() === idToDelete.toString());\n        const isDraftEntry = isEmpty(dataToDelete.published_at);\n        const status = isDraftEntry ? 'draft' : 'published';\n\n        trackerProperty = { status };\n      }\n\n      emitEventRef.current('willDeleteEntry', trackerProperty);\n      setModalLoadingState();\n\n      await request(getRequestUrl(`collection-types/${slug}/${idToDelete}`), {\n        method: 'DELETE',\n      });\n\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: `${pluginId}.success.record.delete` },\n      });\n\n      // Close the modal and refetch data\n      onDeleteDataSucceeded();\n      emitEventRef.current('didDeleteEntry', trackerProperty);\n    } catch (err) {\n      const errorMessage = get(\n        err,\n        'response.payload.message',\n        formatMessage({ id: `${pluginId}.error.record.delete` })\n      );\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message: errorMessage,\n      });\n      // Close the modal\n      onDeleteDataError();\n    }\n  }, [\n    hasDraftAndPublish,\n    setModalLoadingState,\n    slug,\n    idToDelete,\n    onDeleteDataSucceeded,\n    data,\n    formatMessage,\n    onDeleteDataError,\n  ]);\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const shouldSendRequest = !isLoadingForPermissions && canRead;\n    const requestUrl = `/${pluginId}/collection-types/${slug}${params}`;\n\n    if (shouldSendRequest && requestUrl.includes(requestUrlRef.current)) {\n      fetchData(requestUrl, signal);\n    }\n\n    return () => {\n      requestUrlRef.current = slug;\n      abortController.abort();\n    };\n  }, [isLoadingForPermissions, canRead, getData, slug, params, getDataSucceeded, fetchData]);\n\n  const handleClickDelete = id => {\n    setIdToDelete(id);\n    toggleModalDelete();\n  };\n\n  const handleModalClose = useCallback(() => {\n    if (didDeleteData) {\n      const requestUrl = `/${pluginId}/collection-types/${slug}${params}`;\n\n      fetchData(requestUrl);\n    }\n  }, [fetchData, didDeleteData, slug, params]);\n\n  const toggleFilterPickerState = useCallback(() => {\n    setFilterPickerState(prevState => {\n      if (!prevState) {\n        emitEventRef.current('willFilterEntries');\n      }\n\n      return !prevState;\n    });\n  }, []);\n\n  const headerAction = useMemo(() => {\n    if (!canCreate) {\n      return [];\n    }\n\n    return [\n      {\n        label: formatMessage(\n          {\n            id: 'content-manager.containers.List.addAnEntry',\n          },\n          {\n            entity: label || 'Content Manager',\n          }\n        ),\n        onClick: () => {\n          const trackerProperty = hasDraftAndPublish ? { status: 'draft' } : {};\n\n          emitEventRef.current('willCreateEntry', trackerProperty);\n          push({\n            pathname: `${pathname}/create`,\n          });\n        },\n        color: 'primary',\n        type: 'button',\n        icon: true,\n        style: {\n          paddingLeft: 15,\n          paddingRight: 15,\n          fontWeight: 600,\n        },\n      },\n    ];\n  }, [label, pathname, canCreate, formatMessage, hasDraftAndPublish, push]);\n\n  const headerProps = useMemo(() => {\n    /* eslint-disable indent */\n    return {\n      title: {\n        label: label || 'Content Manager',\n      },\n      content: canRead\n        ? formatMessage(\n            {\n              id:\n                total > 1\n                  ? `${pluginId}.containers.List.pluginHeaderDescription`\n                  : `${pluginId}.containers.List.pluginHeaderDescription.singular`,\n            },\n            { label: total }\n          )\n        : null,\n      actions: headerAction,\n    };\n  }, [total, headerAction, label, canRead, formatMessage]);\n\n  const handleToggleModalDeleteAll = e => {\n    emitEventRef.current('willBulkDeleteEntries');\n    toggleModalDeleteAll(e);\n  };\n\n  return (\n    <>\n      <ListViewProvider\n        _q={_q}\n        _sort={_sort}\n        data={data}\n        entriesToDelete={entriesToDelete}\n        filters={filters}\n        firstSortableHeader={firstSortableHeader}\n        label={label}\n        onChangeBulk={onChangeBulk}\n        onChangeBulkSelectall={onChangeBulkSelectall}\n        onClickDelete={handleClickDelete}\n        slug={slug}\n        toggleModalDeleteAll={handleToggleModalDeleteAll}\n        setQuery={setQuery}\n      >\n        <FilterPicker\n          contentType={contentType}\n          filters={filters}\n          isOpen={isFilterPickerOpen}\n          metadatas={metadatas}\n          name={label}\n          toggleFilterPickerState={toggleFilterPickerState}\n          setQuery={setQuery}\n          slug={slug}\n        />\n        <Container className=\"container-fluid\">\n          {!isFilterPickerOpen && <Header {...headerProps} isLoading={isLoading && canRead} />}\n          {isSearchable && canRead && (\n            <Search changeParams={setQuery} initValue={_q} model={label} value={_q} />\n          )}\n          {canRead && (\n            <Wrapper>\n              <div className=\"row\" style={{ marginBottom: '5px' }}>\n                <div className=\"col-10\">\n                  <div className=\"row\" style={{ marginLeft: 0, marginRight: 0 }}>\n                    {isFilterable && (\n                      <>\n                        <AddFilterCta type=\"button\" onClick={toggleFilterPickerState}>\n                          <FilterIcon />\n                          <FormattedMessage id=\"app.utils.filters\" />\n                        </AddFilterCta>\n                        {filters.map(({ filter: filterName, name, value }, key) => (\n                          <Filter\n                            contentType={contentType}\n                            filterName={filterName}\n                            filters={filters}\n                            index={key}\n                            key={key}\n                            metadatas={metadatas}\n                            name={name}\n                            toggleFilterPickerState={toggleFilterPickerState}\n                            isFilterPickerOpen={isFilterPickerOpen}\n                            setQuery={setQuery}\n                            value={value}\n                          />\n                        ))}\n                      </>\n                    )}\n                  </div>\n                </div>\n                <div className=\"col-2\">\n                  <CheckPermissions permissions={pluginPermissions.collectionTypesConfigurations}>\n                    <FieldPicker\n                      displayedHeaders={displayedHeaders}\n                      items={allAllowedHeaders}\n                      onChange={handleChangeListLabels}\n                      onClickReset={onResetListHeaders}\n                      slug={slug}\n                    />\n                  </CheckPermissions>\n                </div>\n              </div>\n              <div className=\"row\" style={{ paddingTop: '12px' }}>\n                <div className=\"col-12\">\n                  <CustomTable\n                    data={data}\n                    canCreate={canCreate}\n                    canDelete={canDelete}\n                    canUpdate={canUpdate}\n                    displayedHeaders={displayedHeaders}\n                    hasDraftAndPublish={hasDraftAndPublish}\n                    isBulkable={isBulkable}\n                    setQuery={setQuery}\n                    showLoader={isLoading}\n                  />\n                  <Footer count={total} params={query} onChange={setQuery} />\n                </div>\n              </div>\n            </Wrapper>\n          )}\n        </Container>\n        <PopUpWarning\n          isOpen={showWarningDelete}\n          toggleModal={toggleModalDelete}\n          content={{\n            message: getTrad('popUpWarning.bodyMessage.contentType.delete'),\n          }}\n          onConfirm={handleConfirmDeleteData}\n          popUpWarningType=\"danger\"\n          onClosed={handleModalClose}\n          isConfirmButtonLoading={showModalConfirmButtonLoading}\n        />\n        <PopUpWarning\n          isOpen={showWarningDeleteAll}\n          toggleModal={toggleModalDeleteAll}\n          content={{\n            message: getTrad(\n              `popUpWarning.bodyMessage.contentType.delete${\n                entriesToDelete.length > 1 ? '.all' : ''\n              }`\n            ),\n          }}\n          popUpWarningType=\"danger\"\n          onConfirm={handleConfirmDeleteAllData}\n          onClosed={handleModalClose}\n          isConfirmButtonLoading={showModalConfirmButtonLoading}\n        />\n      </ListViewProvider>\n    </>\n  );\n}\n\nListView.propTypes = {\n  displayedHeaders: PropTypes.array.isRequired,\n  data: PropTypes.array.isRequired,\n  didDeleteData: PropTypes.bool.isRequired,\n  entriesToDelete: PropTypes.array.isRequired,\n  layout: PropTypes.exact({\n    components: PropTypes.object.isRequired,\n    contentType: PropTypes.shape({\n      attributes: PropTypes.object.isRequired,\n      metadatas: PropTypes.object.isRequired,\n      info: PropTypes.shape({ label: PropTypes.string.isRequired }).isRequired,\n      layouts: PropTypes.shape({\n        list: PropTypes.array.isRequired,\n        editRelations: PropTypes.array,\n      }).isRequired,\n      options: PropTypes.object.isRequired,\n      settings: PropTypes.object.isRequired,\n    }).isRequired,\n  }).isRequired,\n  isLoading: PropTypes.bool.isRequired,\n  getData: PropTypes.func.isRequired,\n  getDataSucceeded: PropTypes.func.isRequired,\n  onChangeBulk: PropTypes.func.isRequired,\n  onChangeBulkSelectall: PropTypes.func.isRequired,\n  onChangeListHeaders: PropTypes.func.isRequired,\n  onDeleteDataError: PropTypes.func.isRequired,\n  onDeleteDataSucceeded: PropTypes.func.isRequired,\n  onDeleteSeveralDataSucceeded: PropTypes.func.isRequired,\n  onResetListHeaders: PropTypes.func.isRequired,\n  pagination: PropTypes.shape({ total: PropTypes.number.isRequired }).isRequired,\n  resetProps: PropTypes.func.isRequired,\n  setModalLoadingState: PropTypes.func.isRequired,\n  showModalConfirmButtonLoading: PropTypes.bool.isRequired,\n  showWarningDelete: PropTypes.bool.isRequired,\n  showWarningDeleteAll: PropTypes.bool.isRequired,\n  slug: PropTypes.string.isRequired,\n  toggleModalDelete: PropTypes.func.isRequired,\n  toggleModalDeleteAll: PropTypes.func.isRequired,\n  setLayout: PropTypes.func.isRequired,\n};\n\nconst mapStateToProps = makeSelectListView();\n\nexport function mapDispatchToProps(dispatch) {\n  return bindActionCreators(\n    {\n      getData,\n      getDataSucceeded,\n      onChangeBulk,\n      onChangeBulkSelectall,\n      onChangeListHeaders,\n      onDeleteDataError,\n      onDeleteDataSucceeded,\n      onDeleteSeveralDataSucceeded,\n      onResetListHeaders,\n      resetProps,\n      setModalLoadingState,\n      toggleModalDelete,\n      toggleModalDeleteAll,\n      setLayout,\n    },\n    dispatch\n  );\n}\nconst withConnect = connect(mapStateToProps, mapDispatchToProps);\n\nexport default compose(withConnect)(memo(ListView, isEqual));\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/Main/index.js": "import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { bindActionCreators, compose } from 'redux';\nimport { Switch, Route } from 'react-router-dom';\nimport {\n  CheckPagePermissions,\n  LoadingIndicatorPage,\n  NotFound,\n  request,\n} from 'strapi-helper-plugin';\nimport { DndProvider } from 'react-dnd';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport pluginId from '../../pluginId';\nimport pluginPermissions from '../../permissions';\nimport { getRequestUrl } from '../../utils';\nimport DragLayer from '../../components/DragLayer';\nimport CollectionTypeRecursivePath from '../CollectionTypeRecursivePath';\nimport ComponentSettingsView from '../ComponentSetttingsView';\nimport SingleTypeRecursivePath from '../SingleTypeRecursivePath';\nimport { getData, getDataSucceeded, resetProps } from './actions';\nimport makeSelectMain from './selectors';\n\nfunction Main({ getData, getDataSucceeded, isLoading, resetProps }) {\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const fetchData = async signal => {\n      getData();\n\n      try {\n        const [{ data: components }, { data: models }] = await Promise.all(\n          ['components', 'content-types'].map(endPoint =>\n            request(getRequestUrl(endPoint), { method: 'GET', signal })\n          )\n        );\n\n        getDataSucceeded(models, components);\n      } catch (err) {\n        console.error(err);\n        strapi.notification.error('notification.error');\n      }\n    };\n\n    fetchData(signal);\n\n    return () => {\n      abortController.abort();\n      resetProps();\n    };\n  }, [getData, getDataSucceeded, resetProps]);\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <DndProvider backend={HTML5Backend}>\n      <DragLayer />\n\n      <Switch>\n        <Route path={`/plugins/${pluginId}/components/:uid/configurations/edit`}>\n          <CheckPagePermissions permissions={pluginPermissions.componentsConfigurations}>\n            <ComponentSettingsView />\n          </CheckPagePermissions>\n        </Route>\n        <Route\n          path={`/plugins/${pluginId}/collectionType/:slug`}\n          component={CollectionTypeRecursivePath}\n        />\n        <Route path={`/plugins/${pluginId}/singleType/:slug`} component={SingleTypeRecursivePath} />\n        <Route path=\"\" component={NotFound} />\n      </Switch>\n    </DndProvider>\n  );\n}\n\nMain.propTypes = {\n  getData: PropTypes.func.isRequired,\n  getDataSucceeded: PropTypes.func.isRequired,\n  isLoading: PropTypes.bool.isRequired,\n  resetProps: PropTypes.func.isRequired,\n};\n\nconst mapStateToProps = makeSelectMain();\n\nexport function mapDispatchToProps(dispatch) {\n  return bindActionCreators(\n    {\n      getData,\n      getDataSucceeded,\n      resetProps,\n    },\n    dispatch\n  );\n}\nconst withConnect = connect(mapStateToProps, mapDispatchToProps);\n\nexport default compose(withConnect)(Main);\n",
    "packages/strapi-plugin-content-manager/admin/src/containers/SingleTypeFormWrapper/index.js": "import { memo, useCallback, useEffect, useRef, useReducer, useState } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { get } from 'lodash';\nimport { request, useGlobalContext } from 'strapi-helper-plugin';\nimport PropTypes from 'prop-types';\nimport {\n  createDefaultForm,\n  formatComponentData,\n  getTrad,\n  removePasswordFieldsFromData,\n} from '../../utils';\nimport { crudInitialState, crudReducer } from '../../sharedReducers';\nimport { getRequestUrl } from './utils';\n\n// This container is used to handle the CRUD\nconst SingleTypeFormWrapper = ({ allLayoutData, children, from, slug }) => {\n  const { emitEvent } = useGlobalContext();\n  const { push } = useHistory();\n  const emitEventRef = useRef(emitEvent);\n  const [isCreatingEntry, setIsCreatingEntry] = useState(true);\n\n  const [\n    { componentsDataStructure, contentTypeDataStructure, data, isLoading, status },\n    dispatch,\n  ] = useReducer(crudReducer, crudInitialState);\n\n  const cleanReceivedData = useCallback(\n    data => {\n      const cleaned = removePasswordFieldsFromData(\n        data,\n        allLayoutData.contentType,\n        allLayoutData.components\n      );\n\n      // This is needed in order to add a unique id for the repeatable components, in order to make the reorder easier\n      return formatComponentData(cleaned, allLayoutData.contentType, allLayoutData.components);\n    },\n    [allLayoutData]\n  );\n\n  useEffect(() => {\n    const componentsDataStructure = Object.keys(allLayoutData.components).reduce((acc, current) => {\n      const defaultComponentForm = createDefaultForm(\n        get(allLayoutData, ['components', current, 'attributes'], {}),\n        allLayoutData.components\n      );\n\n      acc[current] = formatComponentData(\n        defaultComponentForm,\n        allLayoutData.components[current],\n        allLayoutData.components\n      );\n\n      return acc;\n    }, {});\n\n    const contentTypeDataStructure = createDefaultForm(\n      allLayoutData.contentType.attributes,\n      allLayoutData.components\n    );\n\n    dispatch({\n      type: 'SET_DATA_STRUCTURES',\n      componentsDataStructure,\n      contentTypeDataStructure: formatComponentData(\n        contentTypeDataStructure,\n        allLayoutData.contentType,\n        allLayoutData.components\n      ),\n    });\n  }, [allLayoutData]);\n\n  // Check if creation mode or editing mode\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    const fetchData = async signal => {\n      dispatch({ type: 'GET_DATA' });\n\n      setIsCreatingEntry(true);\n\n      try {\n        const data = await request(getRequestUrl(slug), { method: 'GET', signal });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data: cleanReceivedData(data),\n        });\n        setIsCreatingEntry(false);\n      } catch (err) {\n        if (err.name === 'AbortError') {\n          return;\n        }\n\n        const responseStatus = get(err, 'response.status', null);\n\n        // Creating a single type\n        if (responseStatus === 404) {\n          dispatch({ type: 'INIT_FORM' });\n        }\n\n        if (responseStatus === 403) {\n          strapi.notification.info(getTrad('permissions.not-allowed.update'));\n\n          push(from);\n        }\n      }\n    };\n\n    fetchData(signal);\n\n    return () => abortController.abort();\n  }, [cleanReceivedData, from, push, slug]);\n\n  const displayErrors = useCallback(err => {\n    const errorPayload = err.response.payload;\n    console.error(errorPayload);\n\n    let errorMessage = get(errorPayload, ['message'], 'Bad Request');\n\n    // TODO handle errors correctly when back-end ready\n    if (Array.isArray(errorMessage)) {\n      errorMessage = get(errorMessage, ['0', 'messages', '0', 'id']);\n    }\n\n    if (typeof errorMessage === 'string') {\n      strapi.notification.error(errorMessage);\n    }\n  }, []);\n\n  const onDelete = useCallback(\n    async trackerProperty => {\n      try {\n        emitEventRef.current('willDeleteEntry', trackerProperty);\n\n        const response = await request(getRequestUrl(`${slug}`), {\n          method: 'DELETE',\n        });\n\n        strapi.notification.success(getTrad('success.record.delete'));\n\n        emitEventRef.current('didDeleteEntry', trackerProperty);\n\n        return Promise.resolve(response);\n      } catch (err) {\n        emitEventRef.current('didNotDeleteEntry', { error: err, ...trackerProperty });\n\n        return Promise.reject(err);\n      }\n    },\n    [slug]\n  );\n\n  const onDeleteSucceeded = useCallback(() => {\n    setIsCreatingEntry(true);\n\n    dispatch({ type: 'INIT_FORM' });\n  }, []);\n\n  const onPost = useCallback(\n    async (body, trackerProperty) => {\n      const endPoint = getRequestUrl(slug);\n\n      try {\n        dispatch({ type: 'SET_STATUS', status: 'submit-pending' });\n\n        const response = await request(endPoint, { method: 'PUT', body });\n\n        emitEventRef.current('didCreateEntry', trackerProperty);\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('success.record.save') },\n        });\n\n        dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n        setIsCreatingEntry(false);\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      } catch (err) {\n        emitEventRef.current('didNotCreateEntry', { error: err, trackerProperty });\n\n        displayErrors(err);\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      }\n    },\n    [cleanReceivedData, displayErrors, slug]\n  );\n  const onPublish = useCallback(async () => {\n    try {\n      emitEventRef.current('willPublishEntry');\n      const endPoint = getRequestUrl(`${slug}/actions/publish`);\n\n      dispatch({ type: 'SET_STATUS', status: 'publish-pending' });\n\n      const data = await request(endPoint, { method: 'POST' });\n\n      emitEventRef.current('didPublishEntry');\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: getTrad('success.record.publish') },\n      });\n\n      dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(data) });\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n    } catch (err) {\n      displayErrors(err);\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n    }\n  }, [cleanReceivedData, displayErrors, slug]);\n\n  const onPut = useCallback(\n    async (body, trackerProperty) => {\n      const endPoint = getRequestUrl(`${slug}`);\n\n      try {\n        emitEventRef.current('willEditEntry', trackerProperty);\n\n        dispatch({ type: 'SET_STATUS', status: 'submit-pending' });\n\n        const response = await request(endPoint, { method: 'PUT', body });\n\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('success.record.save') },\n        });\n\n        emitEventRef.current('didEditEntry', { trackerProperty });\n\n        dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      } catch (err) {\n        displayErrors(err);\n\n        emitEventRef.current('didNotEditEntry', { error: err, trackerProperty });\n        dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      }\n    },\n    [cleanReceivedData, displayErrors, slug]\n  );\n\n  // The publish and unpublish method could be refactored but let's leave the duplication for now\n  const onUnpublish = useCallback(async () => {\n    const endPoint = getRequestUrl(`${slug}/actions/unpublish`);\n    dispatch({ type: 'SET_STATUS', status: 'unpublish-pending' });\n\n    try {\n      emitEventRef.current('willUnpublishEntry');\n\n      const response = await request(endPoint, { method: 'POST' });\n\n      emitEventRef.current('didUnpublishEntry');\n      strapi.notification.success(getTrad('success.record.unpublish'));\n\n      dispatch({ type: 'SUBMIT_SUCCEEDED', data: cleanReceivedData(response) });\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n    } catch (err) {\n      dispatch({ type: 'SET_STATUS', status: 'resolved' });\n      displayErrors(err);\n    }\n  }, [cleanReceivedData, displayErrors, slug]);\n\n  return children({\n    componentsDataStructure,\n    contentTypeDataStructure,\n    data,\n    isCreatingEntry,\n    isLoadingForData: isLoading,\n    onDelete,\n    onDeleteSucceeded,\n    onPost,\n    onPublish,\n    onPut,\n    onUnpublish,\n    status,\n  });\n};\n\nSingleTypeFormWrapper.defaultProps = {\n  from: '/',\n};\n\nSingleTypeFormWrapper.propTypes = {\n  allLayoutData: PropTypes.shape({\n    components: PropTypes.object.isRequired,\n    contentType: PropTypes.object.isRequired,\n  }).isRequired,\n  children: PropTypes.func.isRequired,\n  from: PropTypes.string,\n  slug: PropTypes.string.isRequired,\n};\n\nexport default memo(SingleTypeFormWrapper);\n",
    "packages/strapi-plugin-content-manager/admin/src/hooks/useFetchContentTypeLayout/index.js": "import { useCallback, useEffect, useMemo, useReducer, useRef } from 'react';\nimport { useSelector } from 'react-redux';\nimport { request } from 'strapi-helper-plugin';\nimport formatLayouts from './utils/formatLayouts';\nimport reducer, { initialState } from './reducer';\nimport { makeSelectModelAndComponentSchemas } from '../../containers/Main/selectors';\n\nconst useFetchContentTypeLayout = contentTypeUID => {\n  const [{ error, isLoading, layout, layouts }, dispatch] = useReducer(reducer, initialState);\n  const schemasSelector = useMemo(makeSelectModelAndComponentSchemas, []);\n  const { schemas } = useSelector(state => schemasSelector(state), []);\n  const isMounted = useRef(true);\n\n  const getData = useCallback(\n    async (uid, abortSignal = false) => {\n      let signal = abortSignal || new AbortController().signal;\n\n      if (layouts[uid]) {\n        dispatch({ type: 'SET_LAYOUT_FROM_STATE', uid });\n\n        return;\n      }\n      dispatch({ type: 'GET_DATA' });\n\n      try {\n        const { data } = await request(`/content-manager/content-types/${uid}/configuration`, {\n          method: 'GET',\n          signal,\n        });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data: formatLayouts(data, schemas),\n        });\n      } catch (error) {\n        if (isMounted.current && error.name !== 'AbortError') {\n          dispatch({ type: 'GET_DATA_ERROR', error });\n        }\n      }\n    },\n    [layouts, schemas]\n  );\n\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    const abortController = new AbortController();\n    const { signal } = abortController;\n\n    getData(contentTypeUID, signal);\n\n    return () => {\n      abortController.abort();\n    };\n  }, [contentTypeUID, getData]);\n\n  const updateLayout = useCallback(\n    newLayout => {\n      dispatch({\n        type: 'UPDATE_LAYOUT',\n        newLayout: formatLayouts({ contentType: newLayout, components: {} }, schemas),\n      });\n    },\n    [schemas]\n  );\n\n  return {\n    error,\n    isLoading,\n    layout,\n    updateLayout,\n  };\n};\n\nexport default useFetchContentTypeLayout;\n",
    "packages/strapi-plugin-content-manager/config/functions/bootstrap.js": "'use strict';\n\nconst { getService } = require('../../utils');\n\nmodule.exports = async () => {\n  await getService('components').syncConfigurations();\n  await getService('content-types').syncConfigurations();\n  await getService('permission').registerPermissions();\n};\n",
    "packages/strapi-plugin-content-manager/config/policies/routing.js": "'use strict';\n\nconst _ = require('lodash');\n\nmodule.exports = async (ctx, next) => {\n  const { model } = ctx.params;\n\n  const ct = strapi.contentTypes[model];\n\n  if (!ct) {\n    return ctx.send({ error: 'contentType.notFound' }, 404);\n  }\n\n  const target = ct.plugin === 'admin' ? strapi.admin : strapi.plugins[ct.plugin];\n\n  const actionPath = ['config', 'layout', ct.modelName, 'actions', ctx.request.route.action];\n\n  if (_.has(target, actionPath)) {\n    const [controller, action] = _.get(target, actionPath, []).split('.');\n\n    if (controller && action) {\n      return await target.controllers[controller.toLowerCase()][action](ctx);\n    }\n  }\n\n  await next();\n};\n",
    "packages/strapi-plugin-content-manager/controllers/collection-types.js": "'use strict';\n\nconst { has, pipe, prop, pick } = require('lodash/fp');\nconst { MANY_RELATIONS } = require('strapi-utils').relations.constants;\n\nconst {\n  getService,\n  wrapBadRequest,\n  setCreatorFields,\n  pickWritableAttributes,\n} = require('../utils');\nconst { validateBulkDeleteInput, validatePagination } = require('./validation');\n\nmodule.exports = {\n  async find(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { query } = ctx.request;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const method = has('_q', query) ? 'searchWithRelationCounts' : 'findWithRelationCounts';\n\n    const permissionQuery = permissionChecker.buildReadQuery(query);\n\n    const { results, pagination } = await entityManager[method](permissionQuery, model);\n\n    ctx.body = {\n      results: results.map(entity => permissionChecker.sanitizeOutput(entity)),\n      pagination,\n    };\n  },\n\n  async findOne(ctx) {\n    const { userAbility } = ctx.state;\n    const { model, id } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.read(entity)) {\n      return ctx.forbidden();\n    }\n\n    ctx.body = permissionChecker.sanitizeOutput(entity);\n  },\n\n  async create(ctx) {\n    const { userAbility, user } = ctx.state;\n    const { model } = ctx.params;\n    const { body } = ctx.request;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.create()) {\n      return ctx.forbidden();\n    }\n\n    const pickWritables = pickWritableAttributes({ model });\n    const pickPermittedFields = permissionChecker.sanitizeCreateInput;\n    const setCreator = setCreatorFields({ user });\n\n    const sanitizeFn = pipe([pickWritables, pickPermittedFields, setCreator]);\n\n    await wrapBadRequest(async () => {\n      const entity = await entityManager.create(sanitizeFn(body), model);\n      ctx.body = permissionChecker.sanitizeOutput(entity);\n\n      await strapi.telemetry.send('didCreateFirstContentTypeEntry', { model });\n    })();\n  },\n\n  async update(ctx) {\n    const { userAbility, user } = ctx.state;\n    const { id, model } = ctx.params;\n    const { body } = ctx.request;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.update()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.update(entity)) {\n      return ctx.forbidden();\n    }\n\n    const pickWritables = pickWritableAttributes({ model });\n    const pickPermittedFields = permissionChecker.sanitizeUpdateInput(entity);\n    const setCreator = setCreatorFields({ user, isEdition: true });\n\n    const sanitizeFn = pipe([pickWritables, pickPermittedFields, setCreator]);\n\n    await wrapBadRequest(async () => {\n      const updatedEntity = await entityManager.update(entity, sanitizeFn(body), model);\n\n      ctx.body = permissionChecker.sanitizeOutput(updatedEntity);\n    })();\n  },\n\n  async delete(ctx) {\n    const { userAbility } = ctx.state;\n    const { id, model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.delete()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.delete(entity)) {\n      return ctx.forbidden();\n    }\n\n    const result = await entityManager.delete(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(result);\n  },\n\n  async publish(ctx) {\n    const { userAbility } = ctx.state;\n    const { id, model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.publish()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.publish(entity)) {\n      return ctx.forbidden();\n    }\n\n    const result = await entityManager.publish(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(result);\n  },\n\n  async unpublish(ctx) {\n    const { userAbility } = ctx.state;\n    const { id, model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.unpublish()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.unpublish(entity)) {\n      return ctx.forbidden();\n    }\n\n    const result = await entityManager.unpublish(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(result);\n  },\n\n  async bulkDelete(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { query, body } = ctx.request;\n    const { ids } = body;\n\n    await validateBulkDeleteInput(body);\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.delete()) {\n      return ctx.forbidden();\n    }\n\n    const permissionQuery = permissionChecker.buildDeleteQuery(query);\n\n    const idsWhereClause = { [`id_in`]: ids };\n    const params = {\n      ...permissionQuery,\n      _where: [idsWhereClause].concat(permissionQuery._where || {}),\n    };\n\n    const results = await entityManager.findAndDelete(params, model);\n\n    ctx.body = results.map(result => permissionChecker.sanitizeOutput(result));\n  },\n\n  async previewManyRelations(ctx) {\n    const { userAbility } = ctx.state;\n    const { model, id, targetField } = ctx.params;\n    const { pageSize = 10, page = 1 } = ctx.request.query;\n\n    validatePagination({ page, pageSize });\n\n    const contentTypeService = getService('content-types');\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const modelDef = strapi.getModel(model);\n    const assoc = modelDef.associations.find(a => a.alias === targetField);\n\n    if (!assoc || !MANY_RELATIONS.includes(assoc.nature)) {\n      return ctx.badRequest('Invalid target field');\n    }\n\n    const entity = await entityManager.findOneWithCreatorRoles(id, model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.read(entity, targetField)) {\n      return ctx.forbidden();\n    }\n\n    let relationList;\n    if (assoc.nature === 'manyWay') {\n      const populatedEntity = await entityManager.findOne(id, model, [targetField]);\n      const relationsListIds = populatedEntity[targetField].map(prop('id'));\n      relationList = await entityManager.findPage(\n        { page, pageSize, id_in: relationsListIds },\n        assoc.targetUid\n      );\n    } else {\n      const assocModel = strapi.db.getModelByAssoc(assoc);\n      relationList = await entityManager.findPage(\n        { page, pageSize, [`${assoc.via}.${assocModel.primaryKey}`]: entity.id },\n        assoc.targetUid\n      );\n    }\n\n    const config = await contentTypeService.findConfiguration({ uid: model });\n    const mainField = prop(['metadatas', assoc.alias, 'edit', 'mainField'], config);\n\n    ctx.body = {\n      pagination: relationList.pagination,\n      results: relationList.results.map(pick(['id', modelDef.primaryKey, mainField])),\n    };\n  },\n};\n",
    "packages/strapi-plugin-content-manager/controllers/components.js": "'use strict';\n\nconst { getService } = require('../utils');\nconst { createModelConfigurationSchema } = require('./validation');\n\nmodule.exports = {\n  findComponents(ctx) {\n    const components = getService('components').findAllComponents();\n    const { toDto } = getService('data-mapper');\n\n    ctx.body = { data: components.map(toDto) };\n  },\n\n  async findComponentConfiguration(ctx) {\n    const { uid } = ctx.params;\n\n    const componentService = getService('components');\n\n    const component = componentService.findComponent(uid);\n\n    if (!component) {\n      return ctx.notFound('component.notFound');\n    }\n\n    const configuration = await componentService.findConfiguration(component);\n    const componentsConfigurations = await componentService.findComponentsConfigurations(component);\n\n    ctx.body = {\n      data: {\n        component: configuration,\n        components: componentsConfigurations,\n      },\n    };\n  },\n\n  async updateComponentConfiguration(ctx) {\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    const componentService = getService('components');\n\n    const component = componentService.findComponent(uid);\n\n    if (!component) {\n      return ctx.notFound('component.notFound');\n    }\n\n    let input;\n    try {\n      input = await createModelConfigurationSchema(component).validate(body, {\n        abortEarly: false,\n        stripUnknown: true,\n        strict: true,\n      });\n    } catch (error) {\n      return ctx.badRequest(null, {\n        name: 'validationError',\n        errors: error.errors,\n      });\n    }\n\n    const newConfiguration = await componentService.updateConfiguration(component, input);\n\n    ctx.body = { data: newConfiguration };\n  },\n};\n",
    "packages/strapi-plugin-content-manager/controllers/content-types.js": "'use strict';\n\nconst { has, assoc, mapValues, prop } = require('lodash/fp');\nconst { getService } = require('../utils');\nconst { createModelConfigurationSchema, validateKind } = require('./validation');\n\nconst hasEditMainField = has('edit.mainField');\nconst getEditMainField = prop('edit.mainField');\nconst assocListMainField = assoc('list.mainField');\n\nconst assocMainField = metadata =>\n  hasEditMainField(metadata) ? assocListMainField(getEditMainField(metadata), metadata) : metadata;\n\nmodule.exports = {\n  async findContentTypes(ctx) {\n    const { kind } = ctx.query;\n\n    try {\n      await validateKind(kind);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    const contentTypes = getService('content-types').findContentTypesByKind(kind);\n    const { toDto } = getService('data-mapper');\n\n    ctx.body = { data: contentTypes.map(toDto) };\n  },\n\n  async findContentTypeConfiguration(ctx) {\n    const { uid } = ctx.params;\n\n    const contentTypeService = getService('content-types');\n\n    const contentType = await contentTypeService.findContentType(uid);\n\n    if (!contentType) {\n      return ctx.notFound('contentType.notFound');\n    }\n\n    const configuration = await contentTypeService.findConfiguration(contentType);\n\n    const confWithUpdatedMetadata = {\n      ...configuration,\n      metadatas: mapValues(assocMainField, configuration.metadatas),\n    };\n\n    const components = await contentTypeService.findComponentsConfigurations(contentType);\n\n    ctx.body = {\n      data: {\n        contentType: confWithUpdatedMetadata,\n        components,\n      },\n    };\n  },\n\n  async updateContentTypeConfiguration(ctx) {\n    const { userAbility } = ctx.state;\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    const contentTypeService = getService('content-types');\n    const metricsService = getService('metrics');\n\n    const contentType = await contentTypeService.findContentType(uid);\n\n    if (!contentType) {\n      return ctx.notFound('contentType.notFound');\n    }\n\n    if (!getService('permission').canConfigureContentType({ userAbility, contentType })) {\n      return ctx.forbidden();\n    }\n\n    let input;\n    try {\n      input = await createModelConfigurationSchema(contentType).validate(body, {\n        abortEarly: false,\n        stripUnknown: true,\n        strict: true,\n      });\n    } catch (error) {\n      return ctx.badRequest(null, {\n        name: 'validationError',\n        errors: error.errors,\n      });\n    }\n\n    const newConfiguration = await contentTypeService.updateConfiguration(contentType, input);\n\n    await metricsService.sendDidConfigureListView(contentType, newConfiguration);\n\n    ctx.body = { data: newConfiguration };\n  },\n};\n",
    "packages/strapi-plugin-content-manager/controllers/relations.js": "'use strict';\n\nconst { has, prop, pick, concat } = require('lodash/fp');\nconst { PUBLISHED_AT_ATTRIBUTE } = require('strapi-utils').contentTypes.constants;\n\nconst { getService } = require('../utils');\n\nmodule.exports = {\n  async find(ctx) {\n    const { model, targetField } = ctx.params;\n    const { _component, ...query } = ctx.request.query;\n    const { idsToOmit } = ctx.request.body;\n\n    if (!targetField) {\n      return ctx.badRequest();\n    }\n\n    const modelDef = _component ? strapi.db.getModel(_component) : strapi.db.getModel(model);\n\n    if (!modelDef) {\n      return ctx.notFound('model.notFound');\n    }\n\n    const attr = modelDef.attributes[targetField];\n    if (!attr) {\n      return ctx.badRequest('targetField.invalid');\n    }\n\n    const target = strapi.db.getModelByAssoc(attr);\n\n    if (!target) {\n      return ctx.notFound('target.notFound');\n    }\n\n    if (idsToOmit && Array.isArray(idsToOmit)) {\n      query._where = query._where || {};\n      query._where.id_nin = concat(query._where.id_nin || [], idsToOmit);\n    }\n\n    const entityManager = getService('entity-manager');\n\n    let entities = [];\n\n    if (has('_q', ctx.request.query)) {\n      entities = await entityManager.search(query, target.uid);\n    } else {\n      entities = await entityManager.find(query, target.uid);\n    }\n\n    if (!entities) {\n      return ctx.notFound();\n    }\n\n    const modelConfig = _component\n      ? await getService('components').findConfiguration(modelDef)\n      : await getService('content-types').findConfiguration(modelDef);\n\n    const field = prop(`metadatas.${targetField}.edit.mainField`, modelConfig) || 'id';\n    const pickFields = [field, 'id', target.primaryKey, PUBLISHED_AT_ATTRIBUTE];\n\n    ctx.body = entities.map(pick(pickFields));\n  },\n};\n",
    "packages/strapi-plugin-content-manager/controllers/single-types.js": "'use strict';\n\nconst { pipe } = require('lodash/fp');\nconst {\n  getService,\n  wrapBadRequest,\n  setCreatorFields,\n  pickWritableAttributes,\n} = require('../utils');\n\nconst findEntity = async model => {\n  const entityManager = getService('entity-manager');\n\n  const entity = await entityManager.find({}, model);\n  return entityManager.assocCreatorRoles(entity);\n};\n\nmodule.exports = {\n  async find(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.read()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await findEntity(model);\n\n    // allow user with create permission to know a single type is not created\n    if (!entity) {\n      if (permissionChecker.cannot.create()) {\n        return ctx.forbidden();\n      }\n\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.read(entity)) {\n      return ctx.forbidden();\n    }\n\n    ctx.body = permissionChecker.sanitizeOutput(entity);\n  },\n\n  async createOrUpdate(ctx) {\n    const { user, userAbility } = ctx.state;\n    const { model } = ctx.params;\n    const { body } = ctx.request;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.create() && permissionChecker.cannot.update()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await findEntity(model);\n\n    const pickWritables = pickWritableAttributes({ model });\n\n    const pickPermittedFields = entity\n      ? permissionChecker.sanitizeUpdateInput(entity)\n      : permissionChecker.sanitizeCreateInput;\n\n    const setCreator = entity\n      ? setCreatorFields({ user, isEdition: true })\n      : setCreatorFields({ user });\n\n    const sanitizeFn = pipe([pickWritables, pickPermittedFields, setCreator]);\n\n    await wrapBadRequest(async () => {\n      if (!entity) {\n        const newEntity = await entityManager.create(sanitizeFn(body), model);\n        ctx.body = permissionChecker.sanitizeOutput(newEntity);\n\n        await strapi.telemetry.send('didCreateFirstContentTypeEntry', { model });\n        return;\n      }\n\n      if (permissionChecker.cannot.update(entity)) {\n        return ctx.forbidden();\n      }\n\n      const updatedEntity = await entityManager.update(entity, sanitizeFn(body), model);\n      ctx.body = permissionChecker.sanitizeOutput(updatedEntity);\n    })();\n  },\n\n  async delete(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.delete()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await findEntity(model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.delete(entity)) {\n      return ctx.forbidden();\n    }\n\n    const deletedEntity = await entityManager.delete(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(deletedEntity);\n  },\n\n  async publish(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.publish()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await findEntity(model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.publish(entity)) {\n      return ctx.forbidden();\n    }\n\n    const publishedEntity = await entityManager.publish(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(publishedEntity);\n  },\n\n  async unpublish(ctx) {\n    const { userAbility } = ctx.state;\n    const { model } = ctx.params;\n\n    const entityManager = getService('entity-manager');\n    const permissionChecker = getService('permission-checker').create({ userAbility, model });\n\n    if (permissionChecker.cannot.unpublish()) {\n      return ctx.forbidden();\n    }\n\n    const entity = await findEntity(model);\n\n    if (!entity) {\n      return ctx.notFound();\n    }\n\n    if (permissionChecker.cannot.unpublish(entity)) {\n      return ctx.forbidden();\n    }\n\n    const unpublishedEntity = await entityManager.unpublish(entity, model);\n\n    ctx.body = permissionChecker.sanitizeOutput(unpublishedEntity);\n  },\n};\n",
    "packages/strapi-plugin-content-manager/controllers/uid.js": "'use strict';\n\nconst { getService } = require('../utils');\nconst {\n  validateGenerateUIDInput,\n  validateCheckUIDAvailabilityInput,\n  validateUIDField,\n} = require('./validation');\n\nmodule.exports = {\n  async generateUID(ctx) {\n    const { contentTypeUID, field, data } = await validateGenerateUIDInput(ctx.request.body);\n\n    await validateUIDField(contentTypeUID, field);\n\n    const uidService = getService('uid');\n\n    ctx.body = {\n      data: await uidService.generateUIDField({ contentTypeUID, field, data }),\n    };\n  },\n\n  async checkUIDAvailability(ctx) {\n    const { contentTypeUID, field, value } = await validateCheckUIDAvailabilityInput(\n      ctx.request.body\n    );\n\n    await validateUIDField(contentTypeUID, field);\n\n    const uidService = getService('uid');\n\n    const isAvailable = await uidService.checkUIDAvailability({ contentTypeUID, field, value });\n\n    ctx.body = {\n      isAvailable,\n      suggestion: !isAvailable\n        ? await uidService.findUniqueUID({ contentTypeUID, field, value })\n        : null,\n    };\n  },\n};\n",
    "packages/strapi-plugin-content-manager/services/__tests__/content-types.test.js": "'use strict';\n\nconst createConfigurationService = require('../configuration');\nconst storeUtils = require('../utils/store');\n\nconst createCfg = (opts = {}) => {\n  return createConfigurationService({\n    prefix: 'test_prefix',\n    storeUtils,\n    get models() {\n      return {};\n    },\n    ...opts,\n  });\n};\n\ndescribe('Model Configuration', () => {\n  test('getConfiguration calls store with right key', async () => {\n    const uid = 'test-uid';\n    const spyFn = jest.spyOn(storeUtils, 'getModelConfiguration').mockImplementation(() => {});\n\n    const { getConfiguration } = createCfg();\n    await getConfiguration(uid);\n\n    expect(spyFn).toHaveBeenCalledWith('test_prefix::test-uid');\n    spyFn.mockRestore();\n  });\n\n  test('setConfiguration calls store with right params', async () => {\n    const uid = 'test-uid';\n    const spyFn = jest.spyOn(storeUtils, 'setModelConfiguration').mockImplementation(() => {});\n\n    const { setConfiguration } = createCfg();\n    await setConfiguration(uid, {\n      settings: {},\n      layouts: {},\n      metadatas: {},\n    });\n\n    expect(spyFn).toHaveBeenCalledWith('test_prefix::test-uid', {\n      layouts: {},\n      metadatas: {},\n      settings: {},\n      uid: 'test-uid',\n    });\n\n    spyFn.mockRestore();\n  });\n\n  test('setConfiguration calls store with isComponent if set in factory option', async () => {\n    const uid = 'test-uid';\n    const spyFn = jest.spyOn(storeUtils, 'setModelConfiguration').mockImplementation(() => {});\n\n    const { setConfiguration } = createCfg({ isComponent: true });\n    await setConfiguration(uid, {\n      settings: {},\n      layouts: {},\n      metadatas: {},\n    });\n\n    expect(spyFn).toHaveBeenCalledWith('test_prefix::test-uid', {\n      layouts: {},\n      metadatas: {},\n      isComponent: true,\n      settings: {},\n      uid: 'test-uid',\n    });\n\n    spyFn.mockRestore();\n  });\n\n  test('deleteConfiguration calls store with right params', async () => {\n    const uid = 'test-uid';\n    const spyFn = jest.spyOn(storeUtils, 'deleteKey').mockImplementation(() => {});\n\n    const { deleteConfiguration } = createCfg();\n    await deleteConfiguration(uid);\n\n    expect(spyFn).toHaveBeenCalledWith('test_prefix::test-uid');\n\n    spyFn.mockRestore();\n  });\n\n  test.todo('Sync Configuration');\n});\n",
    "packages/strapi-plugin-content-manager/services/__tests__/entity-manager.test.js": "'use strict';\n\nconst entityManager = require('../entity-manager');\n\ndescribe('Content-Manager', () => {\n  const fakeModel = {\n    modelName: 'fake model',\n  };\n\n  describe('Publish', () => {\n    beforeEach(() => {\n      global.strapi = {\n        entityService: {\n          update: jest.fn(),\n        },\n        entityValidator: {\n          validateEntityCreation() {},\n        },\n        eventHub: { emit: jest.fn() },\n        getModel: jest.fn(() => fakeModel),\n      };\n    });\n\n    afterEach(() => {\n      jest.clearAllMocks();\n    });\n\n    test('Publish a content-type', async () => {\n      const model = 'application::test.test';\n      const entity = { id: 1, published_at: null };\n      await entityManager.publish(entity, model);\n\n      expect(strapi.entityService.update).toBeCalledWith(\n        { params: { id: entity.id }, data: { published_at: expect.any(Date) } },\n        { model }\n      );\n    });\n  });\n\n  describe('Unpublish', () => {\n    beforeEach(() => {\n      global.strapi = {\n        entityService: {\n          update: jest.fn(),\n        },\n        eventHub: { emit: jest.fn() },\n        getModel: jest.fn(() => fakeModel),\n      };\n    });\n\n    afterEach(() => {\n      jest.clearAllMocks();\n    });\n\n    test('Unpublish a content-type', async () => {\n      const model = 'application::test.test';\n      const entity = { id: 1, published_at: new Date() };\n      await entityManager.unpublish(entity, model);\n\n      expect(strapi.entityService.update).toHaveBeenCalledWith(\n        { params: { id: entity.id }, data: { published_at: null } },\n        { model }\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/services/components.js": "'use strict';\n\nconst { has, isNil, mapValues } = require('lodash/fp');\n\nconst { getService } = require('../utils');\nconst storeUtils = require('./utils/store');\nconst createConfigurationService = require('./configuration');\n\nconst STORE_KEY_PREFIX = 'components';\n\nconst configurationService = createConfigurationService({\n  storeUtils,\n  isComponent: true,\n  prefix: STORE_KEY_PREFIX,\n  getModels() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return mapValues(toContentManagerModel, strapi.components);\n  },\n});\n\nmodule.exports = {\n  findAllComponents() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return Object.values(strapi.components).map(toContentManagerModel);\n  },\n\n  findComponent(uid) {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    const component = strapi.components[uid];\n\n    return isNil(component) ? component : toContentManagerModel(component);\n  },\n\n  // configuration\n\n  async findConfiguration(component) {\n    const configuration = await configurationService.getConfiguration(component.uid);\n\n    return {\n      uid: component.uid,\n      category: component.categoru,\n      ...configuration,\n    };\n  },\n\n  async updateConfiguration(component, newConfiguration) {\n    await configurationService.setConfiguration(component.uid, newConfiguration);\n\n    return this.findConfiguration(component);\n  },\n\n  async findComponentsConfigurations(model) {\n    const componentsMap = {};\n\n    const getComponentConfigurations = async uid => {\n      const component = this.findComponent(uid);\n\n      if (has(uid, componentsMap)) return;\n\n      const componentConfiguration = await this.findConfiguration(component);\n      const componentsConfigurations = await this.findComponentsConfigurations(component);\n\n      Object.assign(componentsMap, {\n        [uid]: componentConfiguration,\n        ...componentsConfigurations,\n      });\n    };\n\n    for (const key in model.attributes) {\n      const attribute = model.attributes[key];\n\n      if (attribute.type === 'component') {\n        await getComponentConfigurations(attribute.component);\n      }\n\n      if (attribute.type === 'dynamiczone') {\n        for (const componentUid of attribute.components) {\n          await getComponentConfigurations(componentUid);\n        }\n      }\n    }\n\n    return componentsMap;\n  },\n\n  syncConfigurations() {\n    return configurationService.syncConfigurations();\n  },\n};\n",
    "packages/strapi-plugin-content-manager/services/configuration.js": "'use strict';\n\nconst { intersection, difference } = require('lodash');\nconst { createDefaultConfiguration, syncConfiguration } = require('./utils/configuration');\n\nmodule.exports = ({ isComponent, prefix, storeUtils, getModels }) => {\n  const uidToStoreKey = uid => {\n    return `${prefix}::${uid}`;\n  };\n\n  const getConfiguration = uid => {\n    const storeKey = uidToStoreKey(uid);\n    return storeUtils.getModelConfiguration(storeKey);\n  };\n\n  const setConfiguration = (uid, input) => {\n    const { settings, metadatas, layouts } = input;\n\n    const configuration = {\n      uid,\n      settings,\n      metadatas,\n      layouts,\n    };\n\n    if (isComponent) {\n      configuration.isComponent = isComponent;\n    }\n\n    const storeKey = uidToStoreKey(uid);\n    return storeUtils.setModelConfiguration(storeKey, configuration);\n  };\n\n  const deleteConfiguration = uid => {\n    const storeKey = uidToStoreKey(uid);\n    return storeUtils.deleteKey(storeKey);\n  };\n\n  const syncConfigurations = async () => {\n    const models = getModels();\n\n    const configurations = await storeUtils.findByKey(\n      `plugin_content_manager_configuration_${prefix}`\n    );\n\n    const updateConfiguration = async uid => {\n      const conf = configurations.find(conf => conf.uid === uid);\n\n      return setConfiguration(uid, await syncConfiguration(conf, models[uid]));\n    };\n\n    const generateNewConfiguration = async uid => {\n      return setConfiguration(uid, await createDefaultConfiguration(models[uid]));\n    };\n\n    const currentUIDS = Object.keys(models);\n    const DBUIDs = configurations.map(({ uid }) => uid);\n\n    const contentTypesToUpdate = intersection(currentUIDS, DBUIDs);\n    const contentTypesToAdd = difference(currentUIDS, DBUIDs);\n    const contentTypesToDelete = difference(DBUIDs, currentUIDS);\n\n    // delete old schemas\n    await Promise.all(contentTypesToDelete.map(uid => deleteConfiguration(uid)));\n\n    // create new schemas\n    await Promise.all(contentTypesToAdd.map(uid => generateNewConfiguration(uid)));\n\n    // update current schemas\n    await Promise.all(contentTypesToUpdate.map(uid => updateConfiguration(uid)));\n  };\n\n  return {\n    getConfiguration,\n    setConfiguration,\n    deleteConfiguration,\n    syncConfigurations,\n  };\n};\n",
    "packages/strapi-plugin-content-manager/services/content-types.js": "'use strict';\n\nconst { isNil, mapValues } = require('lodash/fp');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\n\nconst { getService } = require('../utils');\nconst storeUtils = require('./utils/store');\nconst createConfigurationService = require('./configuration');\n\nconst configurationService = createConfigurationService({\n  storeUtils,\n  prefix: 'content_types',\n  getModels() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return mapValues(toContentManagerModel, strapi.contentTypes);\n  },\n});\n\nconst service = {\n  findAllContentTypes() {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    return Object.values(strapi.contentTypes).map(toContentManagerModel);\n  },\n\n  findContentType(uid) {\n    const { toContentManagerModel } = getService('data-mapper');\n\n    const contentType = strapi.contentTypes[uid];\n\n    return isNil(contentType) ? contentType : toContentManagerModel(contentType);\n  },\n\n  findDisplayedContentTypes() {\n    return this.findAllContentTypes().filter(({ isDisplayed }) => isDisplayed === true);\n  },\n\n  findContentTypesByKind(kind) {\n    if (!kind) {\n      return this.findAllContentTypes();\n    }\n\n    return this.findAllContentTypes().filter(contentTypesUtils.isKind(kind));\n  },\n\n  // configuration\n\n  async findConfiguration(contentType) {\n    const configuration = await configurationService.getConfiguration(contentType.uid);\n\n    return {\n      uid: contentType.uid,\n      ...configuration,\n    };\n  },\n\n  async updateConfiguration(contentType, newConfiguration) {\n    await configurationService.setConfiguration(contentType.uid, newConfiguration);\n    return this.findConfiguration(contentType);\n  },\n\n  findComponentsConfigurations(contentType) {\n    // delegate to componentService\n    return getService('components').findComponentsConfigurations(contentType);\n  },\n\n  syncConfigurations() {\n    return configurationService.syncConfigurations();\n  },\n};\n\nmodule.exports = service;\n",
    "packages/strapi-plugin-content-manager/services/entity-manager.js": "'use strict';\n\nconst { assoc, has, prop, omit } = require('lodash/fp');\nconst strapiUtils = require('strapi-utils');\n\nconst { sanitizeEntity } = strapiUtils;\nconst { hasDraftAndPublish } = strapiUtils.contentTypes;\nconst { PUBLISHED_AT_ATTRIBUTE, CREATED_BY_ATTRIBUTE } = strapiUtils.contentTypes.constants;\nconst { ENTRY_PUBLISH, ENTRY_UNPUBLISH } = strapiUtils.webhook.webhookEvents;\n\nconst omitPublishedAtField = omit(PUBLISHED_AT_ATTRIBUTE);\n\nconst emitEvent = (event, fn) => async (entity, model) => {\n  const result = await fn(entity, model);\n\n  const modelDef = strapi.getModel(model);\n\n  strapi.eventHub.emit(event, {\n    model: modelDef.modelName,\n    entry: sanitizeEntity(result, { model: modelDef }),\n  });\n\n  return result;\n};\n\nconst findCreatorRoles = entity => {\n  const createdByPath = `${CREATED_BY_ATTRIBUTE}.id`;\n\n  if (has(createdByPath, entity)) {\n    const creatorId = prop(createdByPath, entity);\n    return strapi.query('role', 'admin').find({ 'users.id': creatorId }, []);\n  }\n\n  return [];\n};\n\nmodule.exports = {\n  async assocCreatorRoles(entity) {\n    if (!entity) {\n      return entity;\n    }\n\n    const roles = await findCreatorRoles(entity);\n    return assoc(`${CREATED_BY_ATTRIBUTE}.roles`, roles, entity);\n  },\n\n  find(params, model, populate) {\n    return strapi.entityService.find({ params, populate }, { model });\n  },\n\n  findPage(params, model, populate) {\n    return strapi.entityService.findPage({ params, populate }, { model });\n  },\n\n  findWithRelationCounts(params, model, populate) {\n    return strapi.entityService.findWithRelationCounts({ params, populate }, { model });\n  },\n\n  search(params, model, populate) {\n    return strapi.entityService.search({ params, populate }, { model });\n  },\n\n  searchPage(params, model, populate) {\n    return strapi.entityService.searchPage({ params, populate }, { model });\n  },\n\n  searchWithRelationCounts(params, model, populate) {\n    return strapi.entityService.searchWithRelationCounts({ params, populate }, { model });\n  },\n\n  count(params, model) {\n    return strapi.entityService.count({ params }, { model });\n  },\n\n  async findOne(id, model, populate) {\n    return strapi.entityService.findOne({ params: { id }, populate }, { model });\n  },\n\n  async findOneWithCreatorRoles(id, model, populate) {\n    const entity = await this.findOne(id, model, populate);\n\n    if (!entity) {\n      return entity;\n    }\n\n    return this.assocCreatorRoles(entity);\n  },\n\n  async create(body, model) {\n    const modelDef = strapi.getModel(model);\n    const publishData = { ...body };\n\n    if (hasDraftAndPublish(modelDef)) {\n      publishData[PUBLISHED_AT_ATTRIBUTE] = null;\n    }\n\n    return strapi.entityService.create({ data: publishData }, { model });\n  },\n\n  update(entity, body, model) {\n    const params = { id: entity.id };\n    const publishData = omitPublishedAtField(body);\n\n    return strapi.entityService.update({ params, data: publishData }, { model });\n  },\n\n  delete(entity, model) {\n    const params = { id: entity.id };\n    return strapi.entityService.delete({ params }, { model });\n  },\n\n  findAndDelete(params, model) {\n    return strapi.entityService.delete({ params }, { model });\n  },\n\n  publish: emitEvent(ENTRY_PUBLISH, async (entity, model) => {\n    if (entity[PUBLISHED_AT_ATTRIBUTE]) {\n      throw strapi.errors.badRequest('already.published');\n    }\n\n    // validate the entity is valid for publication\n    await strapi.entityValidator.validateEntityCreation(strapi.getModel(model), entity);\n\n    const params = { id: entity.id };\n    const data = { [PUBLISHED_AT_ATTRIBUTE]: new Date() };\n\n    return strapi.entityService.update({ params, data }, { model });\n  }),\n\n  unpublish: emitEvent(ENTRY_UNPUBLISH, (entity, model) => {\n    if (!entity[PUBLISHED_AT_ATTRIBUTE]) {\n      throw strapi.errors.badRequest('already.draft');\n    }\n\n    const params = { id: entity.id };\n    const data = { [PUBLISHED_AT_ATTRIBUTE]: null };\n\n    return strapi.entityService.update({ params, data }, { model });\n  }),\n};\n",
    "packages/strapi-plugin-content-manager/services/metrics.js": "'use strict';\n\nconst { intersection, prop } = require('lodash/fp');\nconst { getRelationalFields } = require('strapi-utils').relations;\n\nconst sendDidConfigureListView = async (contentType, configuration) => {\n  const displayedFields = prop('length', configuration.layouts.list);\n  const relationalFields = getRelationalFields(contentType);\n  const displayedRelationalFields = intersection(relationalFields, configuration.layouts.list)\n    .length;\n\n  const data = {\n    containsRelationalFields: !!displayedRelationalFields,\n  };\n\n  if (data.containsRelationalFields) {\n    Object.assign(data, {\n      displayedFields,\n      displayedRelationalFields,\n    });\n  }\n\n  try {\n    await strapi.telemetry.send('didConfigureListView', data);\n  } catch (e) {\n    // silence\n  }\n};\n\nmodule.exports = {\n  sendDidConfigureListView,\n};\n",
    "packages/strapi-plugin-content-manager/services/uid.js": "'use strict';\n\nconst _ = require('lodash');\nconst slugify = require('@sindresorhus/slugify');\n\nmodule.exports = {\n  async generateUIDField({ contentTypeUID, field, data }) {\n    const contentType = strapi.contentTypes[contentTypeUID];\n    const { attributes } = contentType;\n\n    const { targetField, default: defaultValue, options } = attributes[field];\n    const targetValue = _.get(data, targetField);\n\n    if (!_.isEmpty(targetValue)) {\n      return this.findUniqueUID({\n        contentTypeUID,\n        field,\n        value: slugify(targetValue, options),\n      });\n    }\n\n    return this.findUniqueUID({\n      contentTypeUID,\n      field,\n      value: slugify(defaultValue || contentType.modelName, options),\n    });\n  },\n\n  async findUniqueUID({ contentTypeUID, field, value }) {\n    const query = strapi.db.query(contentTypeUID);\n\n    const possibleColisions = await query\n      .find({\n        [`${field}_contains`]: value,\n        _limit: -1,\n      })\n      .then(results => results.map(result => result[field]));\n\n    if (possibleColisions.length === 0) {\n      return value;\n    }\n\n    let i = 1;\n    let tmpUId = `${value}-${i}`;\n    while (possibleColisions.includes(tmpUId)) {\n      i += 1;\n      tmpUId = `${value}-${i}`;\n    }\n\n    return tmpUId;\n  },\n\n  async checkUIDAvailability({ contentTypeUID, field, value }) {\n    const query = strapi.db.query(contentTypeUID);\n\n    const count = await query.count({\n      [field]: value,\n    });\n\n    if (count > 0) return false;\n    return true;\n  },\n};\n",
    "packages/strapi-plugin-content-manager/services/utils/configuration/index.js": "'use strict';\n\nconst { createModelConfigurationSchema } = require('../../../controllers/validation');\nconst { createDefaultSettings, syncSettings } = require('./settings');\nconst { createDefaultMetadatas, syncMetadatas } = require('./metadatas');\nconst { createDefaultLayouts, syncLayouts } = require('./layouts');\n\nasync function validateCustomConfig(schema) {\n  try {\n    await createModelConfigurationSchema(schema, {\n      allowUndefined: true,\n    }).validate(schema.config);\n  } catch (error) {\n    throw new Error(\n      `Invalid Model configuration for model ${schema.uid}. Verify your {{modelName}}.config.js(on) file:\\n  - ${error.message}\\n`\n    );\n  }\n}\n\nasync function createDefaultConfiguration(schema) {\n  await validateCustomConfig(schema);\n\n  return {\n    settings: await createDefaultSettings(schema),\n    metadatas: await createDefaultMetadatas(schema),\n    layouts: await createDefaultLayouts(schema),\n  };\n}\n\nasync function syncConfiguration(conf, schema) {\n  await validateCustomConfig(schema);\n\n  return {\n    settings: await syncSettings(conf, schema),\n    layouts: await syncLayouts(conf, schema),\n    metadatas: await syncMetadatas(conf, schema),\n  };\n}\n\nmodule.exports = {\n  createDefaultConfiguration,\n  syncConfiguration,\n};\n",
    "packages/strapi-plugin-content-manager/services/utils/store.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst keys = {\n  CONFIGURATION: 'configuration',\n};\n\nconst getStore = () => {\n  return strapi.store({\n    environment: '',\n    type: 'plugin',\n    name: 'content_manager',\n  });\n};\n\n/** Model configuration */\nconst EMPTY_CONFIG = {\n  settings: {},\n  metadatas: {},\n  layouts: {},\n};\n\nconst configurationKey = key => `${keys.CONFIGURATION}_${key}`;\n\nconst getModelConfiguration = async key => {\n  const config = await getStore().get({ key: configurationKey(key) });\n  return _.merge({}, EMPTY_CONFIG, config);\n};\n\nconst setModelConfiguration = async (key, value) => {\n  const storedConfig = (await getStore().get({ key: configurationKey(key) })) || {};\n  const currentConfig = { ...storedConfig };\n  Object.keys(value).forEach(key => {\n    if (value[key] !== null && value[key] !== undefined) {\n      _.set(currentConfig, key, value[key]);\n    }\n  });\n\n  if (!_.isEqual(currentConfig, storedConfig)) {\n    return getStore().set({\n      key: configurationKey(key),\n      value: currentConfig,\n    });\n  }\n};\n\nconst deleteKey = key => {\n  return strapi.query('core_store').delete({ key: `plugin_content_manager_configuration_${key}` });\n};\n\nfunction findByKeyQuery({ model }, key) {\n  if (model.orm === 'mongoose') {\n    return model\n      .find({\n        key: { $regex: `${key}.*` },\n      })\n      .then(results => results.map(({ value }) => JSON.parse(value)));\n  }\n\n  return model\n    .query(qb => {\n      qb.where('key', 'like', `${key}%`);\n    })\n    .fetchAll()\n    .then(config => config && config.toJSON())\n    .then(results => results.map(({ value }) => JSON.parse(value)));\n}\n\nconst findByKey = key => strapi.query('core_store').custom(findByKeyQuery)(key);\nconst moveKey = (oldKey, newKey) => {\n  return strapi.query('core_store').update(\n    {\n      key: `plugin_content_manager_configuration_${oldKey}`,\n    },\n    {\n      key: `plugin_content_manager_configuration_${newKey}`,\n    }\n  );\n};\n\nconst getAllConfigurations = () => findByKey('plugin_content_manager_configuration');\n\nmodule.exports = {\n  getAllConfigurations,\n  findByKey,\n  getModelConfiguration,\n  setModelConfiguration,\n\n  deleteKey,\n  moveKey,\n  keys,\n};\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-compo-repeatable.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompo: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\nconst productWithCompo = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      component: 'default.compo',\n      type: 'component',\n      required: true,\n      repeatable: true,\n    },\n  },\n  connection: 'default',\n  name: 'product with compo',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic + compo', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompo)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: [\n        {\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithCompo[0]);\n    res.body.results.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: [\n        {\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-compo.product-with-compo/${data.productsWithCompo[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-compo.product-with-compo/${data.productsWithCompo[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompo[0]);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo', '0'])).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at least 4 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at most 30 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].name', '0'])).toBe(\n        'compo[0].name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-compo.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompo: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\nconst productWithCompo = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      component: 'default.compo',\n      type: 'component',\n      required: true,\n    },\n  },\n  connection: 'default',\n  name: 'product with compo',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic + compo', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompo)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: {\n        name: 'compo name',\n        description: 'short',\n      },\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithCompo[0]);\n    res.body.results.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: {\n        name: 'compo name updated',\n        description: 'update',\n      },\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-compo.product-with-compo/${data.productsWithCompo[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-compo.product-with-compo/${data.productsWithCompo[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompo[0]);\n    expect(res.body.id).toEqual(data.productsWithCompo[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithCompo.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.compo.0')).toBe('compo must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: '',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at least 4 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at most 30 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          description: 'short',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-compo.product-with-compo',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.name', '0'])).toBe(\n        'compo.name must be defined.'\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo-repeatable.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompoAndDP: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\nconst productWithCompoAndDP = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      type: 'component',\n      component: 'default.compo',\n      required: true,\n      repeatable: true,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product with compo and DP',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic + compo + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompoAndDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: [\n        {\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url:\n        '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url:\n        '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithCompoAndDP[0]);\n    res.body.results.forEach(p => {\n      expect(p.published_at).toBeNull();\n    });\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: [\n        {\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp/${data.productsWithCompoAndDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp/${data.productsWithCompoAndDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompoAndDP[0]);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP.shift();\n  });\n\n  describe('validation', () => {\n    test('Can create product with compo - compo required - []', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [],\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n\n    test('Can create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo[0].description', '0'])).toBe(\n        'compo[0].description must be at most 30 characters'\n      );\n    });\n\n    test('Can create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [\n          {\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-dp-compo.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithCompoAndDP: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\nconst productWithCompoAndDP = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    compo: {\n      type: 'component',\n      component: 'default.compo',\n      required: true,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product with compo and DP',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic + compo + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompoAndDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: {\n        name: 'compo name',\n        description: 'short',\n      },\n    };\n    const res = await rq({\n      method: 'POST',\n      url:\n        '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url:\n        '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithCompoAndDP[0]);\n    res.body.results.forEach(p => {\n      expect(p.published_at).toBeNull();\n    });\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: {\n        name: 'compo name updated',\n        description: 'update',\n      },\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp/${data.productsWithCompoAndDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp/${data.productsWithCompoAndDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithCompoAndDP[0]);\n    expect(res.body.id).toEqual(data.productsWithCompoAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithCompoAndDP.shift();\n  });\n\n  describe('validation', () => {\n    test('Can create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: null,\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n\n    test('Can create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: '',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'compo.description', '0'])).toBe(\n        'compo.description must be at most 30 characters'\n      );\n    });\n\n    test('Can create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          description: 'short',\n        },\n      };\n      const res = await rq({\n        method: 'POST',\n        url:\n          '/content-manager/collection-types/application::product-with-compo-and-dp.product-with-compo-and-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithCompoAndDP.push(res.body);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-dp-dz.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithDzAndDP: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\nconst productWithCompoAndDP = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    dz: {\n      components: ['default.compo'],\n      type: 'dynamiczone',\n      required: true,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product with dz and DP',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic + dz + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithCompoAndDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url:\n        '/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDzAndDP.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url:\n        '/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithDzAndDP[0]);\n    res.body.results.forEach(p => {\n      expect(p.published_at).toBeNull();\n    });\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${data.productsWithDzAndDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithDzAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDzAndDP[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${data.productsWithDzAndDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithDzAndDP[0]);\n    expect(res.body.id).toEqual(data.productsWithDzAndDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDzAndDP.shift();\n  });\n\n  describe('validation', () => {\n    describe.each(['create', 'update'])('%p', method => {\n      test(`Can ${method} product with compo - compo required - []`, async () => {\n        const product = {\n          name: 'Product 1',\n          description: 'Product description',\n          dz: [],\n        };\n        const res = await rq({\n          method: method === 'create' ? 'POST' : 'PUT',\n          url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${\n            method === 'update' ? data.productsWithDzAndDP[0].id : ''\n          }`,\n          body: product,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject(product);\n        data.productsWithDzAndDP.push(res.body);\n      });\n\n      test(`Can ${method} product with compo - minLength`, async () => {\n        const product = {\n          name: 'Product 1',\n          description: 'Product description',\n          dz: [\n            {\n              __component: 'default.compo',\n              name: 'compo name',\n              description: 'k',\n            },\n          ],\n        };\n        const res = await rq({\n          method: method === 'create' ? 'POST' : 'PUT',\n          url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${\n            method === 'update' ? data.productsWithDzAndDP[0].id : ''\n          }`,\n          body: product,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject(product);\n        data.productsWithDzAndDP.push(res.body);\n      });\n\n      test(`Cannot ${method} product with compo - maxLength`, async () => {\n        const product = {\n          name: 'Product 1',\n          description: 'Product description',\n          dz: [\n            {\n              __component: 'default.compo',\n              name: 'compo name',\n              description: 'A very long description that exceed the min length.',\n            },\n          ],\n        };\n        const res = await rq({\n          method: method === 'create' ? 'POST' : 'PUT',\n          url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${\n            method === 'update' ? data.productsWithDzAndDP[0].id : ''\n          }`,\n          body: product,\n        });\n\n        expect(res.statusCode).toBe(400);\n        expect(_.get(res.body.data, ['errors', 'dz[0].description', '0'])).toBe(\n          'dz[0].description must be at most 30 characters'\n        );\n      });\n\n      test(`Can ${method} product with compo - required`, async () => {\n        const product = {\n          name: 'Product 1',\n          description: 'Product description',\n          dz: [\n            {\n              __component: 'default.compo',\n              description: 'short',\n            },\n          ],\n        };\n        const res = await rq({\n          method: method === 'create' ? 'POST' : 'PUT',\n          url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${\n            method === 'update' ? data.productsWithDzAndDP[0].id : ''\n          }`,\n          body: product,\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject(product);\n        data.productsWithDzAndDP.push(res.body);\n      });\n\n      test(`Cannot ${method} product with compo - missing __component`, async () => {\n        const product = {\n          name: 'Product 1',\n          description: 'Product description',\n          dz: [\n            {\n              name: 'Product 1',\n              description: 'short',\n            },\n          ],\n        };\n        const res = await rq({\n          method: method === 'create' ? 'POST' : 'PUT',\n          url: `/content-manager/collection-types/application::product-with-dz-and-dp.product-with-dz-and-dp/${\n            method === 'update' ? data.productsWithDzAndDP[0].id : ''\n          }`,\n          body: product,\n        });\n\n        expect(res.statusCode).toBe(400);\n        expect(_.get(res.body.data, ['errors', 'dz[0].__component', '0'])).toBe(\n          'dz[0].__component is a required field'\n        );\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-dp.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithDP: [],\n};\n\nconst productWithDP = {\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 30,\n    },\n  },\n  connection: 'default',\n  draftAndPublish: true,\n  name: 'product with DP',\n  description: '',\n  collectionName: '',\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n};\n\ndescribe('CM API - Basic + draftAndPublish', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithDP)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create a product', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDP.push(res.body);\n  });\n\n  test('Create a product + cannot overwrite published_at', async () => {\n    const product = {\n      name: 'Product 2',\n      description: 'Product description',\n      published_at: '2020-08-20T10:27:55.866Z',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.omit(product, 'published_at'));\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDP.push(res.body);\n  });\n\n  test('Read all products', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(2);\n    expect(res.body.results).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          name: 'Product 1',\n          description: 'Product description',\n        }),\n      ])\n    );\n    res.body.results.forEach(p => {\n      expect(p.published_at).toBeNull();\n    });\n  });\n\n  test('Update a draft', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${data.productsWithDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.omit(product, 'published_at'));\n    expect(res.body.id).toEqual(data.productsWithDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDP[0] = res.body;\n  });\n\n  test('Update product + cannot overwrite published_at', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      published_at: '2020-08-27T09:50:50.465Z',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${data.productsWithDP[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(_.omit(product, ['published_at']));\n    expect(res.body.published_at).toBeNull();\n    expect(res.body.id).toEqual(data.productsWithDP[0].id);\n    data.productsWithDP[0] = res.body;\n  });\n\n  test('Publish a product, expect published_at to be defined', async () => {\n    const entry = data.productsWithDP[0];\n\n    let { body } = await rq({\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${entry.id}/actions/publish`,\n      method: 'POST',\n    });\n\n    data.productsWithDP[0] = body;\n\n    expect(body.published_at).toBeISODate();\n  });\n\n  test('Publish article1, expect article1 to be already published', async () => {\n    const entry = data.productsWithDP[0];\n\n    let { body } = await rq({\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${entry.id}/actions/publish`,\n      method: 'POST',\n    });\n\n    expect(body.statusCode).toBe(400);\n    expect(body.message).toBe('already.published');\n  });\n\n  test('Unpublish article1, expect article1 to be set to null', async () => {\n    const entry = data.productsWithDP[0];\n\n    let { body } = await rq({\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${entry.id}/actions/unpublish`,\n      method: 'POST',\n    });\n\n    data.productsWithDP[0] = body;\n\n    expect(body.published_at).toBeNull();\n  });\n\n  test('Unpublish article1, expect article1 to already be a draft', async () => {\n    const entry = data.productsWithDP[0];\n\n    let { body } = await rq({\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${entry.id}/actions/unpublish`,\n      method: 'POST',\n    });\n\n    expect(body.statusCode).toBe(400);\n    expect(body.message).toBe('already.draft');\n  });\n\n  test('Delete a draft', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-dp.product-with-dp/${data.productsWithDP[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithDP[0]);\n    expect(res.body.id).toEqual(data.productsWithDP[0].id);\n    expect(res.body.published_at).toBeNull();\n    data.productsWithDP.shift();\n  });\n\n  describe('validators', () => {\n    test('Can create a product - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: '',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject(product);\n      data.productsWithDP.push(res.body);\n    });\n\n    test('Can create a product - required', async () => {\n      const product = {\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        ...product,\n      });\n      expect(_.isNil(res.body.name)).toBe(true);\n      data.productsWithDP.push(res.body);\n    });\n\n    test('Cannot create a product - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: \"I'm a product description that is very long. At least thirty characters.\",\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dp.product-with-dp',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.description.0')).toBe(\n        'description must be at most 30 characters'\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-dz.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  productsWithDz: [],\n};\n\nconst compo = {\n  name: 'compo',\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 3,\n      maxLength: 10,\n    },\n  },\n};\n\nconst productWithDz = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    description: {\n      type: 'text',\n    },\n    dz: {\n      components: ['default.compo'],\n      type: 'dynamiczone',\n      required: true,\n    },\n  },\n  connection: 'default',\n  name: 'product with dz',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Core API - Basic + dz', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(compo)\n      .addContentType(productWithDz)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name',\n          description: 'short',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithDz.push(res.body);\n  });\n\n  test('Read product with compo', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results[0]).toMatchObject(data.productsWithDz[0]);\n    res.body.results.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      dz: [\n        {\n          __component: 'default.compo',\n          name: 'compo name updated',\n          description: 'update',\n        },\n      ],\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product-with-dz.product-with-dz/${data.productsWithDz[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.productsWithDz[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithDz[0] = res.body;\n  });\n\n  test('Delete product with compo', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product-with-dz.product-with-dz/${data.productsWithDz[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.productsWithDz[0]);\n    expect(res.body.id).toEqual(data.productsWithDz[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.productsWithDz.shift();\n  });\n\n  describe('validation', () => {\n    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz', '0'])).toBe('dz must be defined.');\n    });\n\n    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            name: 'compo name',\n            description: '',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].description', '0'])).toBe(\n        'dz[0].description must be at least 3 characters'\n      );\n    });\n\n    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            name: 'compo name',\n            description: 'A very long description that exceed the min length.',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].description', '0'])).toBe(\n        'dz[0].description must be at most 10 characters'\n      );\n    });\n\n    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            __component: 'default.compo',\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].name', '0'])).toBe(\n        'dz[0].name must be defined.'\n      );\n    });\n\n    test('Cannot create product with compo - missing __component', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [\n          {\n            name: 'Product 1',\n            description: 'short',\n          },\n        ],\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product-with-dz.product-with-dz',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res.body.data, ['errors', 'dz[0].__component', '0'])).toBe(\n        'dz[0].__component is a required field'\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic-relations.test.e2e.js": "'use strict';\n\nconst { createAuthRequest } = require('../../../../test/helpers/request');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\n\nlet strapi;\nlet rq;\nconst builder = createTestBuilder();\n\nlet data = {\n  stamps: [],\n  collectors: [],\n};\n\nconst stamp = {\n  name: 'stamp',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst collector = {\n  name: 'collector',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    age: {\n      type: 'integer',\n    },\n    stamps: {\n      nature: 'manyWay',\n      target: 'application::stamp.stamp',\n      unique: false,\n    },\n    stamps_one_way: {\n      nature: 'oneWay',\n      target: 'application::stamp.stamp',\n      unique: false,\n    },\n    stamps_m2m: {\n      nature: 'manyToMany',\n      targetAttribute: 'collectors',\n      target: 'application::stamp.stamp',\n      unique: false,\n      dominant: true,\n    },\n    stamps_one_many: {\n      nature: 'oneToMany',\n      targetAttribute: 'collector',\n      target: 'application::stamp.stamp',\n      unique: false,\n    },\n    stamps_one_one: {\n      nature: 'oneToOne',\n      targetAttribute: 'collector_one_one',\n      target: 'application::stamp.stamp',\n      unique: false,\n    },\n  },\n};\n\nconst stampFixtures = [\n  {\n    name: '1946',\n  },\n  {\n    name: '1947',\n  },\n  {\n    name: '1948',\n  },\n];\n\nconst collectorFixtures = ({ stamp }) => [\n  {\n    name: 'Bernard',\n    age: 25,\n    stamps: [stamp[0].id, stamp[1].id],\n    stamps_m2m: [stamp[0].id],\n    stamps_one_many: [],\n    stamps_one_way: stamp[0].id,\n    stamps_one_one: stamp[0].id,\n  },\n  {\n    name: 'Isabelle',\n    age: 55,\n    stamps: [stamp[0].id],\n    stamps_m2m: [],\n    stamps_one_many: [stamp[1].id, stamp[2].id],\n    stamps_one_way: stamp[1].id,\n    stamps_one_one: stamp[1].id,\n  },\n  {\n    name: 'Emma',\n    age: 23,\n    stamps: [],\n    stamps_m2m: [stamp[0].id, stamp[1].id],\n    stamps_one_many: [stamp[0].id],\n    stamps_one_way: stamp[2].id,\n    stamps_one_one: stamp[2].id,\n  },\n];\n\nconst getCollectorByName = (collectors, name) => collectors.find(c => c.name === name);\nconst getStampByName = (stamps, name) => stamps.find(s => s.name === name);\n\ndescribe('CM API', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentTypes([stamp, collector])\n      .addFixtures(stamp.name, stampFixtures)\n      .addFixtures(collector.name, collectorFixtures)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    data.collectors = builder.sanitizedFixturesFor(collector.name, strapi);\n    data.stamps = builder.sanitizedFixturesFor(stamp.name, strapi);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Count relations', () => {\n    test('many-way', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(getCollectorByName(res.body.results, 'Bernard').stamps.count).toBe(2);\n      expect(getCollectorByName(res.body.results, 'Isabelle').stamps.count).toBe(1);\n      expect(getCollectorByName(res.body.results, 'Emma').stamps.count).toBe(0);\n    });\n\n    test('many-to-many (collector -> stamps)', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(getCollectorByName(res.body.results, 'Bernard').stamps_m2m.count).toBe(1);\n      expect(getCollectorByName(res.body.results, 'Isabelle').stamps_m2m.count).toBe(0);\n      expect(getCollectorByName(res.body.results, 'Emma').stamps_m2m.count).toBe(2);\n    });\n\n    test('many-to-many (stamp -> collectors)', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::stamp.stamp',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(getStampByName(res.body.results, '1946').collectors.count).toBe(2);\n      expect(getStampByName(res.body.results, '1947').collectors.count).toBe(1);\n      expect(getStampByName(res.body.results, '1948').collectors.count).toBe(0);\n    });\n\n    test('one-to-many', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(getCollectorByName(res.body.results, 'Bernard').stamps_one_many.count).toBe(0);\n      expect(getCollectorByName(res.body.results, 'Isabelle').stamps_one_many.count).toBe(2);\n      expect(getCollectorByName(res.body.results, 'Emma').stamps_one_many.count).toBe(1);\n    });\n  });\n\n  describe('Filter relations', () => {\n    test('many-way', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _where: { 'stamps.name': '1946' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(2);\n      expect(res.body.results[0].name).toBe('Bernard');\n      expect(res.body.results[1].name).toBe('Isabelle');\n    });\n\n    test('many-to-many (collector -> stamps)', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _where: { 'stamps_m2m.name': '1946' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(2);\n      expect(getCollectorByName(res.body.results, 'Bernard')).toBeDefined();\n      expect(getCollectorByName(res.body.results, 'Emma')).toBeDefined();\n    });\n\n    test('many-to-many (stamp -> collectors)', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::stamp.stamp',\n        qs: {\n          _where: { 'collectors.name': 'Emma' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(2);\n      expect(getStampByName(res.body.results, '1946')).toBeDefined();\n      expect(getStampByName(res.body.results, '1947')).toBeDefined();\n    });\n\n    test('one-to-many', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _where: { 'stamps_one_many.name': '1947' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(1);\n      expect(res.body.results[0].name).toBe('Isabelle');\n    });\n\n    test('many-to-one', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::stamp.stamp',\n        qs: {\n          _where: { 'collector.name': 'Isabelle' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(2);\n      expect(getStampByName(res.body.results, '1947')).toBeDefined();\n      expect(getStampByName(res.body.results, '1948')).toBeDefined();\n    });\n\n    test('one-way', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _where: { 'stamps_one_way.name': '1947' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(1);\n      expect(getCollectorByName(res.body.results, 'Isabelle')).toBeDefined();\n    });\n\n    test('one-one', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _where: { 'stamps_one_one.name': '1947' },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(1);\n      expect(getCollectorByName(res.body.results, 'Isabelle')).toBeDefined();\n    });\n  });\n\n  describe('Sort relations', () => {\n    test('many-to-one', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::stamp.stamp',\n        qs: {\n          _sort: 'collector.name:ASC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].collector.name).toBe('Emma');\n      expect(res.body.results[1].collector.name).toBe('Isabelle');\n      expect(res.body.results[2].collector.name).toBe('Isabelle');\n\n      res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::stamp.stamp',\n        qs: {\n          _sort: 'collector.name:DESC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].collector.name).toBe('Isabelle');\n      expect(res.body.results[1].collector.name).toBe('Isabelle');\n      expect(res.body.results[2].collector.name).toBe('Emma');\n    });\n\n    test('one-way', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _sort: 'stamps_one_way.name:ASC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].stamps_one_way.name).toBe('1946');\n      expect(res.body.results[1].stamps_one_way.name).toBe('1947');\n      expect(res.body.results[2].stamps_one_way.name).toBe('1948');\n\n      res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _sort: 'stamps_one_way.name:DESC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].stamps_one_way.name).toBe('1948');\n      expect(res.body.results[1].stamps_one_way.name).toBe('1947');\n      expect(res.body.results[2].stamps_one_way.name).toBe('1946');\n    });\n\n    test('one-one', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _sort: 'stamps_one_one.name:ASC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].stamps_one_one.name).toBe('1946');\n      expect(res.body.results[1].stamps_one_one.name).toBe('1947');\n      expect(res.body.results[2].stamps_one_one.name).toBe('1948');\n\n      res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::collector.collector',\n        qs: {\n          _sort: 'stamps_one_one.name:DESC',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results).toHaveLength(3);\n      expect(res.body.results[0].stamps_one_one.name).toBe('1948');\n      expect(res.body.results[1].stamps_one_one.name).toBe('1947');\n      expect(res.body.results[2].stamps_one_one.name).toBe('1946');\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/basic.test.e2e.js": "'use strict';\n\nconst _ = require('lodash');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  products: [],\n};\n\nconst product = {\n  attributes: {\n    name: {\n      type: 'string',\n      required: true,\n    },\n    description: {\n      type: 'text',\n      minLength: 4,\n      maxLength: 30,\n    },\n  },\n  connection: 'default',\n  name: 'product',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('CM API - Basic', () => {\n  beforeAll(async () => {\n    await builder.addContentType(product).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create product', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/content-manager/collection-types/application::product.product',\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.published_at).toBeUndefined();\n    data.products.push(res.body);\n  });\n\n  test('Read product', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/content-manager/collection-types/application::product.product',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toHaveLength(1);\n    expect(res.body.results).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          name: 'Product 1',\n          description: 'Product description',\n        }),\n      ])\n    );\n    res.body.results.forEach(p => expect(p.published_at).toBeUndefined());\n  });\n\n  test('Update product', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/content-manager/collection-types/application::product.product/${data.products[0].id}`,\n      body: product,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(product);\n    expect(res.body.id).toEqual(data.products[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.products[0] = res.body;\n  });\n\n  test('Delete product', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/content-manager/collection-types/application::product.product/${data.products[0].id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject(data.products[0]);\n    expect(res.body.id).toEqual(data.products[0].id);\n    expect(res.body.published_at).toBeUndefined();\n    data.products.shift();\n  });\n\n  describe('validators', () => {\n    test('Cannot create a product - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: '',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product.product',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.description.0')).toBe(\n        'description must be at least 4 characters'\n      );\n    });\n\n    test('Cannot create a product - required', async () => {\n      const product = {\n        description: 'Product description',\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product.product',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.name.0')).toBe('name must be defined.');\n    });\n\n    test('Cannot create a product - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: \"I'm a product description that is very long. At least thirty characters.\",\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/application::product.product',\n        body: product,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(_.get(res, 'body.data.errors.description.0')).toBe(\n        'description must be at most 30 characters'\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/api/x-to-many-rf-preview.test.e2e.js": "'use strict';\n\nconst { prop, difference, map, uniq } = require('lodash/fp');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\n\nconst toIds = arr => uniq(map(prop('id'))(arr));\n\nlet strapi;\nlet rq;\nconst builder = createTestBuilder();\n\nconst data = {\n  product: [],\n  category: [],\n  shop: [],\n};\n\nconst productModel = {\n  attributes: {\n    name: {\n      type: 'string',\n      unique: true,\n    },\n    categories: {\n      nature: 'oneToMany',\n      private: false,\n      target: 'application::category.category',\n      targetAttribute: 'product',\n    },\n    shops: {\n      nature: 'manyWay',\n      target: 'application::shop.shop',\n    },\n  },\n  name: 'product',\n};\n\nconst categoryModel = {\n  attributes: {\n    name: {\n      type: 'string',\n      unique: true,\n    },\n  },\n  name: 'category',\n};\n\nconst shopModel = {\n  attributes: {\n    name: {\n      type: 'string',\n      unique: true,\n    },\n    metadata: {\n      type: 'string',\n    },\n  },\n  name: 'shop',\n};\n\nconst fixtures = {\n  shop: [\n    { name: 'SH.A', metadata: 'foobar' },\n    { name: 'SH.B', metadata: 'foobar' },\n    { name: 'SH.C', metadata: 'foobar' },\n    { name: 'SH.D', metadata: 'foobar' },\n    { name: 'SH.E', metadata: 'foobar' },\n    { name: 'SH.F', metadata: 'foobar' },\n    { name: 'SH.G', metadata: 'foobar' },\n    { name: 'SH.H', metadata: 'foobar' },\n    { name: 'SH.I', metadata: 'foobar' },\n    { name: 'SH.J', metadata: 'foobar' },\n    { name: 'SH.K', metadata: 'foobar' },\n    { name: 'SH.L', metadata: 'foobar' },\n  ],\n  category: [\n    { name: 'CT.A' },\n    { name: 'CT.B' },\n    { name: 'CT.C' },\n    { name: 'CT.D' },\n    { name: 'CT.E' },\n    { name: 'CT.F' },\n    { name: 'CT.G' },\n    { name: 'CT.H' },\n    { name: 'CT.I' },\n    { name: 'CT.J' },\n    { name: 'CT.K' },\n    { name: 'CT.L' },\n  ],\n  product: ({ shop, category }) => [\n    {\n      name: 'PD.A',\n      categories: category.slice(0, 5).map(prop('id')),\n      shops: shop.slice(0, 12).map(prop('id')),\n    },\n  ],\n};\n\nconst getUID = modelName => `application::${modelName}.${modelName}`;\nconst getCMPrefixUrl = modelName => `/content-manager/collection-types/${getUID(modelName)}`;\n\ndescribe('x-to-many RF Preview', () => {\n  const cmProductUrl = getCMPrefixUrl(productModel.name);\n\n  beforeAll(async () => {\n    await builder\n      .addContentTypes([shopModel, categoryModel, productModel])\n      .addFixtures(shopModel.name, fixtures.shop)\n      .addFixtures(categoryModel.name, fixtures.category)\n      .addFixtures(productModel.name, fixtures.product)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    Object.assign(data, builder.sanitizedFixtures(strapi));\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Entity Misc', () => {\n    test.each(['foobar', 'name'])(`Throws if the targeted field is invalid (%s)`, async field => {\n      const product = data.product[0];\n      const { body, statusCode } = await rq.get(`${cmProductUrl}/${product.id}/${field}`);\n\n      expect(statusCode).toBe(400);\n      expect(body.error).toBe('Bad Request');\n      expect(body.message).toBe('Invalid target field');\n    });\n\n    test('Throws if the entity does not exist', async () => {\n      const { body, statusCode } = await rq.get(`${cmProductUrl}/${data.shop[11].id}/categories`);\n\n      expect(statusCode).toBe(404);\n      expect(body.error).toBe('Not Found');\n    });\n  });\n\n  describe('Relation Nature', () => {\n    test(`Throws if the relation's nature is not a x-to-many`, async () => {\n      const url = getCMPrefixUrl(categoryModel.name);\n      const id = data.category[0].id;\n\n      const { body, statusCode } = await rq.get(`${url}/${id}/product`);\n\n      expect(statusCode).toBe(400);\n      expect(body.error).toBe('Bad Request');\n      expect(body.message).toBe('Invalid target field');\n    });\n  });\n\n  describe('Default Behavior', () => {\n    test.each(['shops', 'categories'])('Should return a preview for the %s field', async field => {\n      const product = data.product[0];\n\n      const { body, statusCode } = await rq.get(`${cmProductUrl}/${product.id}/${field}`);\n\n      const expected = product[field].slice(0, 10);\n\n      expect(statusCode).toBe(200);\n      expect(body.results).toHaveLength(expected.length);\n      expect(difference(toIds(body.results), toIds(product[field]))).toHaveLength(0);\n    });\n  });\n\n  describe('Pagination', () => {\n    test.each([\n      [1, 10],\n      [2, 10],\n      [5, 1],\n      [4, 2],\n      [1, 100],\n    ])('Custom pagination (%s, %s)', async (page, pageSize) => {\n      const product = data.product[0];\n\n      const { body, statusCode } = await rq.get(\n        `${cmProductUrl}/${product.id}/shops?page=${page}&pageSize=${pageSize}`\n      );\n\n      expect(statusCode).toBe(200);\n\n      const { pagination, results } = body;\n\n      expect(pagination.page).toBe(page);\n      expect(pagination.pageSize).toBe(pageSize);\n      expect(results).toHaveLength(\n        Math.min(pageSize, product.shops.length - pageSize * (page - 1))\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required-min-max.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: true,\n      required: false,\n      min: 2,\n      max: 5,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and Not required component', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someString',\n          }),\n        ])\n      );\n    });\n\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws if the field is not an array %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Throws when sending a non empty array with less then the min', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'test',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Success when sending an empty array', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n    });\n\n    test('Throws when sending too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Can send input without the component field', async () => {\n      const res = await rq.post('/', {\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual([]);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Data is ordered in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'firstString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'firstString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          expect(Array.isArray(entry.field)).toBe(true);\n\n          if (entry.field.length === 0) return;\n\n          expect(entry.field).toEqual(\n            expect.arrayContaining([\n              expect.objectContaining({\n                name: expect.any(String),\n              }),\n            ])\n          );\n        });\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        expect(Array.isArray(entry.field)).toBe(true);\n\n        if (entry.field.length === 0) return;\n\n        expect(entry.field).toEqual(\n          expect.arrayContaining([\n            expect.objectContaining({\n              name: expect.any(String),\n            }),\n          ])\n        );\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: [\n              {\n                name: 'someString',\n              },\n              {\n                name: 'someString',\n              },\n            ],\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      expect(res.body.field[0]).toMatchObject({\n        name: 'someString',\n      });\n      expect(res.body.field[1]).toMatchObject({\n        name: 'otherString',\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'otherString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.field)).toBe(true);\n\n      expect(updateRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(updateRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Throws when not enough items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'lala',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(res.body);\n    });\n\n    test('Throws when too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'test',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(res.body);\n    });\n\n    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            { name: 'test' },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'new String',\n            },\n            {\n              name: 'test',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n\n      const oldIds = res.body.field.map(val => val.id);\n      updateRes.body.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n          {\n            name: 'test',\n          },\n        ],\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n          {\n            name: 'test',\n          },\n        ],\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'test',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: 'invalid_id',\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'two',\n            },\n            {\n              name: 'three',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: res.body.field[0].id, // send old id to update the previous component\n              name: 'newOne',\n            },\n            {\n              name: 'newTwo',\n            },\n            {\n              id: res.body.field[2].id,\n              name: 'three',\n            },\n            {\n              name: 'four',\n            },\n          ],\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: [\n          {\n            id: res.body.field[0].id,\n            name: 'newOne',\n          },\n          {\n            name: 'newTwo',\n          },\n          {\n            id: res.body.field[2].id,\n            name: 'three',\n          },\n          {\n            name: 'four',\n          },\n        ],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someOtherString',\n            },\n            {\n              name: 'otherSomeString',\n            },\n          ],\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/repeatable-not-required.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: true,\n      required: false,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and Not required component', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someString',\n          }),\n        ])\n      );\n    });\n\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws if the field is not an object %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Can send an empty array', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual([]);\n    });\n\n    test('Can send input without the component field', async () => {\n      const res = await rq.post('/', {\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual([]);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Data is orderd in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'firstString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'firstString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          expect(Array.isArray(entry.field)).toBe(true);\n\n          if (entry.field.length === 0) return;\n\n          expect(entry.field).toEqual(\n            expect.arrayContaining([\n              expect.objectContaining({\n                name: expect.any(String),\n              }),\n            ])\n          );\n        });\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        expect(Array.isArray(entry.field)).toBe(true);\n\n        if (entry.field.length === 0) return;\n\n        expect(entry.field).toEqual(\n          expect.arrayContaining([\n            expect.objectContaining({\n              name: expect.any(String),\n            }),\n          ])\n        );\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: [\n              {\n                name: 'someString',\n              },\n            ],\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      expect(res.body.field[0]).toMatchObject({\n        name: 'someString',\n      });\n      expect(res.body.field[1]).toMatchObject({\n        name: 'otherString',\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'otherString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.field)).toBe(true);\n\n      expect(updateRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(updateRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Removes previous components if empty array sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [],\n        },\n      });\n\n      const expectResult = {\n        id: res.body.id,\n        field: [],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectResult);\n    });\n\n    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n\n      const oldIds = res.body.field.map(val => val.id);\n      updateRes.body.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: 'invalid_id',\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'two',\n            },\n            {\n              name: 'three',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: res.body.field[0].id, // send old id to update the previous component\n              name: 'newOne',\n            },\n            {\n              name: 'newTwo',\n            },\n            {\n              id: res.body.field[2].id,\n              name: 'three',\n            },\n            {\n              name: 'four',\n            },\n          ],\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: [\n          {\n            id: res.body.field[0].id,\n            name: 'newOne',\n          },\n          {\n            name: 'newTwo',\n          },\n          {\n            id: res.body.field[2].id,\n            name: 'three',\n          },\n          {\n            name: 'four',\n          },\n        ],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someOtherString',\n            },\n            {\n              name: 'otherSomeString',\n            },\n          ],\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/repeatable-required-min-max.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: true,\n      required: true,\n      min: 1,\n      max: 5,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and Not required component', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someString',\n          }),\n        ])\n      );\n    });\n\n    test('Creating second entry', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someValue',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someValue',\n          }),\n        ])\n      );\n    });\n\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws if the field is not an object %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Throws when sending an empty array or an array with less than the min', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Throws when sending too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n            {\n              name: 'one',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Data is orderd in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'firstString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'firstString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          expect(Array.isArray(entry.field)).toBe(true);\n\n          if (entry.field.length === 0) return;\n\n          expect(entry.field).toEqual(\n            expect.arrayContaining([\n              expect.objectContaining({\n                name: expect.any(String),\n              }),\n            ])\n          );\n        });\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        expect(Array.isArray(entry.field)).toBe(true);\n\n        if (entry.field.length === 0) return;\n\n        expect(entry.field).toEqual(\n          expect.arrayContaining([\n            expect.objectContaining({\n              name: expect.any(String),\n            }),\n          ])\n        );\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: [\n              {\n                name: 'someString',\n              },\n            ],\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      expect(res.body.field[0]).toMatchObject({\n        name: 'someString',\n      });\n      expect(res.body.field[1]).toMatchObject({\n        name: 'otherString',\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'otherString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.field)).toBe(true);\n\n      expect(updateRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(updateRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Throws when not enough items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(res.body);\n    });\n\n    test('Throws when too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(res.body);\n    });\n\n    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n\n      const oldIds = res.body.field.map(val => val.id);\n      updateRes.body.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: 'invalid_id',\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'two',\n            },\n            {\n              name: 'three',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: res.body.field[0].id, // send old id to update the previous component\n              name: 'newOne',\n            },\n            {\n              name: 'newTwo',\n            },\n            {\n              id: res.body.field[2].id,\n              name: 'three',\n            },\n            {\n              name: 'four',\n            },\n          ],\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: [\n          {\n            id: res.body.field[0].id,\n            name: 'newOne',\n          },\n          {\n            name: 'newTwo',\n          },\n          {\n            id: res.body.field[2].id,\n            name: 'three',\n          },\n          {\n            name: 'four',\n          },\n        ],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someOtherString',\n            },\n            {\n              name: 'otherSomeString',\n            },\n          ],\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/repeatable-required.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: true,\n      required: true,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and Not required component', (_, path) => {\n  const hasPagination = path.includes('/content-manager');\n  const builder = createTestBuilder();\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someString',\n          }),\n        ])\n      );\n    });\n\n    test('Creating second entry', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someValue',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'someValue',\n          }),\n        ])\n      );\n    });\n\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws if the field is not an object %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Can send an empty array', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual([]);\n    });\n\n    test('Throws when component is not provided', async () => {\n      const res = await rq.post('/', {\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Data is orderd in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'firstString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'firstString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          expect(Array.isArray(entry.field)).toBe(true);\n\n          if (entry.field.length === 0) return;\n\n          expect(entry.field).toEqual(\n            expect.arrayContaining([\n              expect.objectContaining({\n                name: expect.any(String),\n              }),\n            ])\n          );\n        });\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        expect(Array.isArray(entry.field)).toBe(true);\n\n        if (entry.field.length === 0) return;\n\n        expect(entry.field).toEqual(\n          expect.arrayContaining([\n            expect.objectContaining({\n              name: expect.any(String),\n            }),\n          ])\n        );\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each(['someString', 128219, false, {}, null])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: [\n              {\n                name: 'someString',\n              },\n            ],\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      expect(res.body.field[0]).toMatchObject({\n        name: 'someString',\n      });\n      expect(res.body.field[1]).toMatchObject({\n        name: 'otherString',\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'otherString',\n            },\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.field)).toBe(true);\n\n      expect(updateRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(updateRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.field)).toBe(true);\n\n      expect(getRes.body.field[0]).toMatchObject({\n        name: 'otherString',\n      });\n      expect(getRes.body.field[1]).toMatchObject({\n        name: 'someString',\n      });\n    });\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Removes previous components if empty array sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [],\n        },\n      });\n\n      const expectResult = {\n        id: res.body.id,\n        field: [],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectResult);\n    });\n\n    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n\n      const oldIds = res.body.field.map(val => val.id);\n      updateRes.body.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: [\n          {\n            name: 'new String',\n          },\n        ],\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: 'invalid_id',\n              name: 'new String',\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'one',\n            },\n            {\n              name: 'two',\n            },\n            {\n              name: 'three',\n            },\n          ],\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: [\n            {\n              id: res.body.field[0].id, // send old id to update the previous component\n              name: 'newOne',\n            },\n            {\n              name: 'newTwo',\n            },\n            {\n              id: res.body.field[2].id,\n              name: 'three',\n            },\n            {\n              name: 'four',\n            },\n          ],\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: [\n          {\n            id: res.body.field[0].id,\n            name: 'newOne',\n          },\n          {\n            name: 'newTwo',\n          },\n          {\n            id: res.body.field[2].id,\n            name: 'three',\n          },\n          {\n            name: 'four',\n          },\n        ],\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: [\n            {\n              name: 'someString',\n            },\n            {\n              name: 'someOtherString',\n            },\n            {\n              name: 'otherSomeString',\n            },\n          ],\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/single-not-required.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: false,\n      required: false,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and Not required component', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'someString',\n        })\n      );\n    });\n\n    test('Creating second entry ', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someValue',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'someValue',\n        })\n      );\n    });\n\n    test.each([[], 'someString', 128219, false])(\n      'Throws if the field is not an object %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Can send a null value', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: null,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toBe(null);\n    });\n\n    test('Can send input without the component field', async () => {\n      const res = await rq.post('/', {\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toBe(null);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          if (entry.field === null) return;\n\n          expect(entry.field).toMatchObject({\n            name: expect.any(String),\n          });\n        });\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        if (entry.field === null) return;\n\n        expect(entry.field).toMatchObject({\n          name: expect.any(String),\n        });\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each([[], 'someString', 128219, false])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: {\n              name: 'someString',\n            },\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Removes previous component if null sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: null,\n        },\n      });\n\n      const expectResult = {\n        id: res.body.id,\n        field: null,\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectResult);\n    });\n\n    test('Replaces the previous component if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            name: 'new String',\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.field.id).not.toBe(res.body.field.id);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: {\n          name: 'new String',\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: {\n          name: 'new String',\n        },\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            id: 'invalid_id',\n            name: 'new String',\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component if previsous component id is sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            id: res.body.field.id, // send old id to update the previous component\n            name: 'new String',\n          },\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: {\n          id: res.body.field.id,\n          name: 'new String',\n        },\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/components/single-required.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst component = {\n  name: 'somecomponent',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n};\n\nconst ct = {\n  name: 'withcomponent',\n  attributes: {\n    field: {\n      type: 'component',\n      component: 'default.somecomponent',\n      repeatable: false,\n      required: true,\n    },\n  },\n};\n\ndescribe.each([\n  ['CONTENT MANAGER', '/content-manager/collection-types/application::withcomponent.withcomponent'],\n  ['GENERATED API', '/withcomponents'],\n])('[%s] => Non repeatable and required component', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(component)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('POST new entry', () => {\n    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'someString',\n        })\n      );\n    });\n\n    test('Creating a second entry works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someValue',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.field).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'someValue',\n        })\n      );\n    });\n\n    test.each([[], 'someString', 128219, false])(\n      'Throws if the field is not an object %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(res.statusCode).toBe(400);\n      }\n    );\n\n    test('Throws when sending a null value', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: null,\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Throws when the component is not provided', async () => {\n      const res = await rq.post('/', {\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n\n  describe('GET entries', () => {\n    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/');\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        res.body.results.forEach(entry => {\n          if (entry.field === null) return;\n\n          expect(entry.field).toMatchObject({\n            name: expect.any(String),\n          });\n        });\n\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      res.body.forEach(entry => {\n        if (entry.field === null) return;\n\n        expect(entry.field).toMatchObject({\n          name: expect.any(String),\n        });\n      });\n    });\n  });\n\n  describe('PUT entry', () => {\n    test.each([[], 'someString', 128219, false])(\n      'Throws when sending invalid updated field %p',\n      async value => {\n        const res = await rq.post('/', {\n          body: {\n            field: {\n              name: 'someString',\n            },\n          },\n        });\n\n        const updateRes = await rq.put(`/${res.body.id}`, {\n          body: {\n            field: value,\n          },\n        });\n\n        expect(updateRes.statusCode).toBe(400);\n\n        // shouldn't have been updated\n        const getRes = await rq.get(`/${res.body.id}`);\n\n        expect(getRes.statusCode).toBe(200);\n        expect(getRes.body).toMatchObject({\n          id: res.body.id,\n          field: res.body.field,\n        });\n      }\n    );\n\n    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {},\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: res.body.field,\n      });\n    });\n\n    test('Throws if component is null', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: null,\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(res.body);\n    });\n\n    test('Replaces the previous component if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            name: 'new String',\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.field.id).not.toBe(res.body.field.id);\n      expect(updateRes.body).toMatchObject({\n        id: res.body.id,\n        field: {\n          name: 'new String',\n        },\n      });\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        id: res.body.id,\n        field: {\n          name: 'new String',\n        },\n      });\n    });\n\n    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            id: 'invalid_id',\n            name: 'new String',\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n    });\n\n    test('Updates component if previsous component id is sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const updateRes = await rq.put(`/${res.body.id}`, {\n        body: {\n          field: {\n            id: res.body.field.id, // send old id to update the previous component\n            name: 'new String',\n          },\n        },\n      });\n\n      const expectedResult = {\n        id: res.body.id,\n        field: {\n          id: res.body.field.id,\n          name: 'new String',\n        },\n      };\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toMatchObject(expectedResult);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(expectedResult);\n    });\n  });\n\n  describe('DELETE entry', () => {\n    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          field: {\n            name: 'someString',\n          },\n        },\n      });\n\n      const deleteRes = await rq.delete(`/${res.body.id}`);\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n\n      const getRes = await rq.get(`/${res.body.id}`);\n\n      expect(getRes.statusCode).toBe(404);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/content-manager/uid.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet uid = 'application::uid-model.uid-model';\n\nconst model = {\n  kind: 'collectionType',\n  name: 'uid-model',\n  attributes: {\n    title: {\n      type: 'string',\n    },\n    slug: {\n      type: 'uid',\n      targetField: 'title',\n    },\n    otherField: {\n      type: 'integer',\n    },\n  },\n};\n\ndescribe('Content Manager single types', () => {\n  beforeAll(async () => {\n    await builder.addContentType(model).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Generate UID', () => {\n    test('Throws if input is not provided', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          contentTypeUID: expect.arrayContaining([expect.stringMatching('required field')]),\n          field: expect.arrayContaining([expect.stringMatching('required field')]),\n          data: expect.arrayContaining([expect.stringMatching('required field')]),\n        },\n      });\n    });\n\n    test('Throws when contentType is not found', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: 'non-existent',\n          field: 'slug',\n          data: {},\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: ['ContentType not found'],\n      });\n    });\n\n    test('Throws when field is not a uid field', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'otherField',\n          data: {},\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          field: [expect.stringMatching('must be a valid `uid` attribute')],\n        },\n      });\n    });\n\n    test('Generates a unique field when targetField is empty', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {},\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toBe('uid-model');\n\n      await rq({\n        url: `/content-manager/collection-types/${uid}`,\n        method: 'POST',\n        body: {\n          slug: res.body.data,\n        },\n      });\n\n      const secondRes = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {},\n        },\n      });\n\n      expect(secondRes.statusCode).toBe(200);\n      expect(secondRes.body.data).toBe('uid-model-1');\n    });\n\n    test('Generates a unique field based on targetField', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {\n            title: 'This is a super title',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toBe('this-is-a-super-title');\n\n      await rq({\n        url: `/content-manager/collection-types/${uid}`,\n        method: 'POST',\n        body: {\n          slug: res.body.data,\n        },\n      });\n\n      const secondRes = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {\n            title: 'This is a super title',\n          },\n        },\n      });\n\n      expect(secondRes.statusCode).toBe(200);\n      expect(secondRes.body.data).toBe('this-is-a-super-title-1');\n    });\n\n    test('Avoids collisions with already generated uids', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {\n            title: 'My title',\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toBe('my-title');\n\n      await rq({\n        url: `/content-manager/collection-types/${uid}`,\n        method: 'POST',\n        body: {\n          slug: res.body.data,\n        },\n      });\n\n      const secondRes = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {\n            title: 'My title',\n          },\n        },\n      });\n\n      expect(secondRes.statusCode).toBe(200);\n      expect(secondRes.body.data).toBe('my-title-1');\n\n      await rq({\n        url: `/content-manager/collection-types/${uid}`,\n        method: 'POST',\n        body: {\n          slug: secondRes.body.data,\n        },\n      });\n\n      const thridRes = await rq({\n        url: `/content-manager/uid/generate`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          data: {\n            title: 'My title 1',\n          },\n        },\n      });\n\n      expect(thridRes.statusCode).toBe(200);\n      expect(thridRes.body.data).toBe('my-title-1-1');\n    });\n  });\n\n  describe('Check UID availability', () => {\n    test('Throws if input is not provided', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {},\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          contentTypeUID: expect.arrayContaining([expect.stringMatching('required field')]),\n          field: expect.arrayContaining([expect.stringMatching('required field')]),\n          value: expect.arrayContaining([expect.stringMatching('required field')]),\n        },\n      });\n    });\n\n    test('Throws on invalid uid value', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          value: 'Invalid UID valuéééé',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: {\n          value: expect.arrayContaining([expect.stringMatching('must match')]),\n        },\n      });\n    });\n\n    test('Throws when contentType is not found', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {\n          contentTypeUID: 'non-existent',\n          field: 'slug',\n          value: 'some-slug',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: ['ContentType not found'],\n      });\n    });\n\n    test('Throws when field is not a uid field', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'otherField',\n          value: 'some-slug',\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        statusCode: 400,\n        error: 'Bad Request',\n        message: 'ValidationError',\n        data: {\n          field: [expect.stringMatching('must be a valid `uid` attribute')],\n        },\n      });\n    });\n\n    test('Checks availability', async () => {\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          value: 'some-available-slug',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        isAvailable: true,\n        suggestion: null,\n      });\n    });\n\n    test('Gives a suggestion when not available', async () => {\n      // create data\n      await rq({\n        url: `/content-manager/collection-types/${uid}`,\n        method: 'POST',\n        body: {\n          slug: 'custom-slug',\n        },\n      });\n\n      const res = await rq({\n        url: `/content-manager/uid/check-availability`,\n        method: 'POST',\n        body: {\n          contentTypeUID: uid,\n          field: 'slug',\n          value: 'custom-slug',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        isAvailable: false,\n        suggestion: 'custom-slug-1',\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/dynamiczones/simple.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst defaultBody = {\n  field: [\n    {\n      __component: 'default.simple-compo',\n      name: 'someString',\n    },\n    {\n      __component: 'default.compo-with-other-compo',\n      compo: {\n        name: 'someString',\n      },\n    },\n  ],\n};\n\nconst models = {\n  ct: {\n    name: 'withdynamiczone',\n    attributes: {\n      field: {\n        type: 'dynamiczone',\n        components: ['default.compo-with-other-compo', 'default.simple-compo'],\n        required: false,\n        min: 2,\n        max: 5,\n      },\n    },\n  },\n  simpleCompo: {\n    name: 'simple-compo',\n    attributes: {\n      name: {\n        type: 'string',\n      },\n    },\n  },\n  otherCompo: {\n    name: 'compo-with-other-compo',\n    attributes: {\n      compo: {\n        type: 'component',\n        component: 'default.simple-compo',\n      },\n    },\n  },\n};\n\nconst createEntry = () => {\n  return rq({\n    method: 'POST',\n    url: '/',\n    body: defaultBody,\n  });\n};\n\nconst createEmpty = () => {\n  return rq({\n    method: 'POST',\n    url: '/',\n    body: {\n      field: [],\n    },\n  });\n};\n\ndescribe.each([\n  [\n    'CONTENT MANAGER',\n    '/content-manager/collection-types/application::withdynamiczone.withdynamiczone',\n  ],\n  ['GENERATED API', '/withdynamiczones'],\n])('[%s] => Not required dynamiczone', (_, path) => {\n  const builder = createTestBuilder();\n  const hasPagination = path.includes('/content-manager');\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(models.simpleCompo)\n      .addComponent(models.otherCompo)\n      .addContentType(models.ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Creation', () => {\n    test('Can create an entry with a dynamic zone and a nested compo', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.simple-compo',\n              name: 'someString',\n            },\n            {\n              __component: 'default.compo-with-other-compo',\n              compo: {\n                name: 'someString',\n              },\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'someString',\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.compo-with-other-compo',\n            compo: {\n              id: expect.anything(),\n              name: 'someString',\n            },\n          },\n        ],\n      });\n    });\n\n    test('Can create entry with empty dynamiczone if it is not required', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field.length).toBe(0);\n    });\n\n    test('Throw if min items is not respected', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.simple-compo',\n              name: 'someString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Throws if max items is not respected', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: Array(10).fill({\n            __component: 'default.simple-compo',\n            name: 'someString',\n          }),\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n\n  describe('Getting one entry', () => {\n    test('The entry has its dynamic zone populated', async () => {\n      const createRes = await createEntry();\n      const entryId = createRes.body.id;\n\n      const res = await rq({ method: 'GET', url: `/${entryId}` });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'someString',\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.compo-with-other-compo',\n            compo: {\n              id: expect.anything(),\n              name: 'someString',\n            },\n          },\n        ],\n      });\n    });\n  });\n\n  describe('Listing entries', () => {\n    test('The entries have their dynamic zones populated', async () => {\n      const res = await rq({ method: 'GET', url: '/' });\n\n      expect(res.statusCode).toBe(200);\n\n      if (hasPagination) {\n        expect(res.body.pagination).toBeDefined();\n        expect(Array.isArray(res.body.results)).toBe(true);\n        expect(res.body.results).toEqual(\n          expect.arrayContaining([\n            expect.objectContaining({\n              field: expect.arrayContaining([\n                expect.objectContaining({\n                  id: expect.anything(),\n                  __component: expect.any(String),\n                }),\n              ]),\n            }),\n          ])\n        );\n        return;\n      }\n\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            field: expect.arrayContaining([\n              expect.objectContaining({\n                id: expect.anything(),\n                __component: expect.any(String),\n              }),\n            ]),\n          }),\n        ])\n      );\n    });\n  });\n\n  describe('Edition', () => {\n    test('Can empty non required dynamic zone', async () => {\n      const createRes = await createEntry();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          field: [],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body.field).toEqual([]);\n    });\n\n    test('Can add items to empty dynamic zone', async () => {\n      const createRes = await createEmpty();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: defaultBody,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'someString',\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.compo-with-other-compo',\n            compo: {\n              id: expect.anything(),\n              name: 'someString',\n            },\n          },\n        ],\n      });\n    });\n\n    test('Can remove items from dynamic zone', async () => {\n      const createRes = await createEntry();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          field: [\n            {\n              __component: 'default.simple-compo',\n              name: 'otherString',\n            },\n            {\n              __component: 'default.simple-compo',\n              name: 'secondString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'otherString',\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'secondString',\n          },\n        ],\n      });\n    });\n\n    test('Respects min items', async () => {\n      const createRes = await createEntry();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          field: [\n            {\n              __component: 'default.simple-compo',\n              name: 'otherString',\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Respects max items', async () => {\n      const createRes = await createEntry();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          field: Array(10).fill({\n            __component: 'default.simple-compo',\n            name: 'otherString',\n          }),\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n\n  describe('Deletion', () => {\n    test('Returns the entry with its paths populated', async () => {\n      const createRes = await createEntry();\n\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.id;\n\n      const res = await rq({ method: 'DELETE', url: `/${entryId}` });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toEqual(\n        expect.objectContaining({\n          field: expect.arrayContaining([\n            expect.objectContaining({\n              id: expect.anything(),\n              __component: expect.any(String),\n            }),\n          ]),\n        })\n      );\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/dynamiczones/with-media.test.e2e.js": "'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\nlet baseRq;\n\nconst uploadImg = () => {\n  return baseRq({\n    method: 'POST',\n    url: '/upload',\n    formData: {\n      files: fs.createReadStream(path.join(__dirname, 'rec.jpg')),\n    },\n  });\n};\n\nconst components = {\n  singleMedia: {\n    name: 'single-media',\n    attributes: {\n      media: {\n        type: 'media',\n      },\n    },\n  },\n  multipleMedia: {\n    name: 'multiple-media',\n    attributes: {\n      media: {\n        type: 'media',\n        multiple: true,\n      },\n    },\n  },\n  withNested: {\n    name: 'with-nested',\n    attributes: {\n      singleMedia: {\n        type: 'component',\n        component: 'default.single-media',\n      },\n      multipleMedia: {\n        type: 'component',\n        component: 'default.multiple-media',\n      },\n    },\n  },\n};\n\nconst ct = {\n  name: 'withdynamiczonemedia',\n  attributes: {\n    field: {\n      type: 'dynamiczone',\n      components: ['default.single-media', 'default.multiple-media', 'default.with-nested'],\n    },\n  },\n};\n\ndescribe.each([\n  [\n    'CONTENT MANAGER',\n    '/content-manager/collection-types/application::withdynamiczonemedia.withdynamiczonemedia',\n  ],\n  ['GENERATED API', '/withdynamiczonemedias'],\n])('[%s] => Not required dynamiczone', (_, path) => {\n  const builder = createTestBuilder();\n\n  beforeAll(async () => {\n    await builder\n      .addComponent(components.singleMedia)\n      .addComponent(components.multipleMedia)\n      .addComponent(components.withNested)\n      .addContentType(ct)\n      .build();\n\n    strapi = await createStrapiInstance();\n\n    baseRq = await createAuthRequest({ strapi });\n\n    rq = await createAuthRequest({ strapi });\n    rq.setURLPrefix(path);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Contains components with medias', () => {\n    test('The medias are correctly related to the components on creation', async () => {\n      const imgRes = await uploadImg();\n\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.single-media',\n              media: mediaId,\n            },\n            {\n              __component: 'default.multiple-media',\n              media: [mediaId, mediaId],\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.single-media',\n            media: {\n              id: mediaId,\n              url: expect.any(String),\n            },\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.multiple-media',\n            media: expect.arrayContaining([\n              expect.objectContaining({\n                id: mediaId,\n                url: expect.any(String),\n              }),\n            ]),\n          },\n        ],\n      });\n    });\n\n    test('The medias are correctly related to the components on edition', async () => {\n      const imgRes = await uploadImg();\n\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.single-media',\n              media: mediaId,\n            },\n            {\n              __component: 'default.multiple-media',\n              media: [mediaId, mediaId],\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n\n      const newImgRes = await uploadImg();\n\n      expect(newImgRes.statusCode).toBe(200);\n      const newMediaId = newImgRes.body[0].id;\n      const updateRes = await rq({\n        method: 'PUT',\n        url: `/${res.body.id}`,\n        body: {\n          field: [\n            {\n              __component: 'default.single-media',\n              media: newMediaId,\n            },\n            {\n              __component: 'default.multiple-media',\n              media: [newMediaId, newMediaId],\n            },\n          ],\n        },\n      });\n\n      expect(updateRes.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.single-media',\n            media: {\n              id: newMediaId,\n              url: expect.any(String),\n            },\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.multiple-media',\n            media: expect.arrayContaining([\n              expect.objectContaining({\n                id: newMediaId,\n                url: expect.any(String),\n              }),\n            ]),\n          },\n        ],\n      });\n    });\n\n    test('The media are populated on the components', async () => {\n      const imgRes = await uploadImg();\n\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.single-media',\n              media: mediaId,\n            },\n            {\n              __component: 'default.multiple-media',\n              media: [mediaId, mediaId],\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n\n      const getRes = await rq({ method: 'GET', url: `/${res.body.id}` });\n      expect(getRes.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.single-media',\n            media: {\n              id: mediaId,\n              url: expect.any(String),\n            },\n          },\n          {\n            id: expect.anything(),\n            __component: 'default.multiple-media',\n            media: expect.arrayContaining([\n              expect.objectContaining({\n                id: mediaId,\n                url: expect.any(String),\n              }),\n            ]),\n          },\n        ],\n      });\n    });\n  });\n\n  describe('Contains components with nested components having medias', () => {\n    test('The medias are correctly related to the nested components on creation', async () => {\n      const imgRes = await uploadImg();\n\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          field: [\n            {\n              __component: 'default.with-nested',\n              singleMedia: {\n                media: mediaId,\n              },\n              multipleMedia: {\n                media: [mediaId, mediaId],\n              },\n            },\n          ],\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.field)).toBe(true);\n      expect(res.body).toMatchObject({\n        field: [\n          {\n            id: expect.anything(),\n            __component: 'default.with-nested',\n            singleMedia: {\n              media: {\n                id: mediaId,\n                url: expect.any(String),\n              },\n            },\n            multipleMedia: {\n              media: expect.arrayContaining([\n                expect.objectContaining({\n                  id: mediaId,\n                  url: expect.any(String),\n                }),\n              ]),\n            },\n          },\n        ],\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/biginteger.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withbiginteger',\n  attributes: {\n    field: {\n      type: 'biginteger',\n    },\n  },\n};\n\ndescribe('Test type biginteger', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const inputValue = '1223372036854775';\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withbiginteger.withbiginteger',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: inputValue,\n    });\n  });\n\n  test('Create entry with integer should return a string', async () => {\n    const inputValue = 1821;\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withbiginteger.withbiginteger',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: `${inputValue}`,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withbiginteger.withbiginteger'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(String));\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const inputValue = '1223372036854775';\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withbiginteger.withbiginteger',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    const newVal = '9882823782712112';\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withbiginteger.withbiginteger/${res.body.id}`,\n      {\n        body: {\n          field: newVal,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: newVal,\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/boolean.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withboolean',\n  attributes: {\n    field: {\n      type: 'boolean',\n    },\n  },\n};\n\ndescribe('Test type boolean', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withboolean.withboolean',\n      {\n        body: {\n          field: true,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: true,\n    });\n  });\n\n  test('Throws on invalid boolean value', async () => {\n    let res = await rq.post(\n      '/content-manager/collection-types/application::withboolean.withboolean',\n      {\n        body: { field: 'random' },\n      }\n    );\n\n    expect(res.statusCode).toBe(400);\n  });\n\n  test('Convert integer to boolean value', async () => {\n    let res = await rq.post(\n      '/content-manager/collection-types/application::withboolean.withboolean',\n      {\n        body: { field: 1 },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: true,\n    });\n\n    res = await rq.post('/content-manager/collection-types/application::withboolean.withboolean', {\n      body: { field: 0 },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: false,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withboolean.withboolean'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(Boolean));\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withboolean.withboolean',\n      {\n        body: {\n          field: true,\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withboolean.withboolean/${res.body.id}`,\n      {\n        body: {\n          field: false,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: false,\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/date.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withdate',\n  attributes: {\n    field: {\n      type: 'date',\n    },\n  },\n};\n\ndescribe('Test type date', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with valid value JSON', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withdate.withdate', {\n      body: {\n        field: '2019-08-08',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: '2019-08-08',\n    });\n  });\n\n  test.each([\n    '2019-08-08',\n    '2019-08-08 12:11:12',\n    '2019-08-08T00:00:00',\n    '2019-08-08T00:00:00Z',\n    '2019-08-08 00:00:00.123',\n    '2019-08-08 00:00:00.123Z',\n    '2019-08-08T00:00:00.123',\n    '2019-08-08T00:00:00.123Z',\n  ])('Date can be sent in any iso format and the date part will be kept, (%s)', async input => {\n    const res = await rq.post('/content-manager/collection-types/application::withdate.withdate', {\n      body: {\n        field: input,\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: '2019-08-08',\n    });\n  });\n\n  test.each([1234567891012, '1234567891012', '2019/12/11', '12:11:11'])(\n    'Throws on invalid date (%s)',\n    async value => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withdate.withdate',\n        {\n          body: {\n            field: value,\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(400);\n    }\n  );\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withdate.withdate');\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toMatch(/^([12]\\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]))$/);\n    });\n  });\n\n  test('Updating entry sets the right value and format JSON', async () => {\n    const now = new Date(2018, 7, 5);\n\n    const res = await rq.post('/content-manager/collection-types/application::withdate.withdate', {\n      body: {\n        field: now,\n      },\n    });\n\n    const newDate = new Date(2017, 10, 23);\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withdate.withdate/${res.body.id}`,\n      {\n        body: {\n          field: newDate,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: '2017-11-23',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/datetime.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withdatetime',\n  attributes: {\n    field: {\n      type: 'datetime',\n    },\n  },\n};\n\ndescribe('Test type datetime', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with valid value JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdatetime.withdatetime',\n      {\n        body: {\n          field: '2019-08-08T10:10:57.000Z',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: '2019-08-08T10:10:57.000Z',\n    });\n  });\n\n  test('Create entry with timestamp value should be converted to ISO', async () => {\n    const now = new Date(2016, 4, 8);\n\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdatetime.withdatetime',\n      {\n        body: {\n          field: now.getTime(),\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: now.toISOString(),\n    });\n  });\n\n  test('Accepts string timestamp', async () => {\n    const now = new Date(2000, 0, 1);\n\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdatetime.withdatetime',\n      {\n        body: {\n          field: `${now.getTime()}`,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: now.toISOString(),\n    });\n  });\n\n  test('Throws on invalid date format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdatetime.withdatetime',\n      {\n        body: {\n          field: 'azdazindoaizdnoainzd',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(400);\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withdatetime.withdatetime'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(new Date(entry.field).toISOString()).toBe(entry.field);\n    });\n  });\n\n  test('Updating entry sets the right value and format JSON', async () => {\n    const now = new Date(2018, 7, 5);\n\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdatetime.withdatetime',\n      {\n        body: {\n          field: now.getTime(),\n        },\n      }\n    );\n\n    const newDate = new Date(2017, 10, 23);\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withdatetime.withdatetime/${res.body.id}`,\n      {\n        body: {\n          field: newDate,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: newDate.toISOString(),\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/decimal.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withdecimal',\n  attributes: {\n    field: {\n      type: 'decimal',\n    },\n  },\n};\n\ndescribe('Test type decimal', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const inputValue = 12.31;\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdecimal.withdecimal',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: inputValue,\n    });\n  });\n\n  test('Create entry with integer should convert to decimal', async () => {\n    const inputValue = 1821;\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdecimal.withdecimal',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 1821.0,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withdecimal.withdecimal'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(Number));\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withdecimal.withdecimal',\n      {\n        body: {\n          field: 11.2,\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withdecimal.withdecimal/${res.body.id}`,\n      {\n        body: {\n          field: 14,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 14.0,\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/email.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withemail',\n  attributes: {\n    field: {\n      type: 'email',\n    },\n  },\n};\n\ndescribe('Test type email', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withemail.withemail',\n      {\n        body: {\n          field: 'validemail@test.fr',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 'validemail@test.fr',\n    });\n  });\n\n  test('Should Throw on invalid email', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withemail.withemail',\n      {\n        body: {\n          field: 'invalidemail',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(400);\n  });\n\n  test('Create entry with value input Formdata', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withemail.withemail',\n      {\n        body: {\n          field: 'test@email.fr',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 'test@email.fr',\n    });\n  });\n\n  test('Reading entry returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withemail.withemail');\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    expect(res.body.results).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          field: expect.any(String),\n        }),\n      ])\n    );\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withemail.withemail',\n      {\n        body: {\n          field: 'valid@email.fr',\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withemail.withemail/${res.body.id}`,\n      {\n        body: {\n          field: 'new-email@email.fr',\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 'new-email@email.fr',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/enumeration.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withenumeration',\n  attributes: {\n    field: {\n      type: 'enumeration',\n      enum: ['one', 'two'],\n    },\n  },\n};\n\ndescribe('Test type enumeration', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry value enumeration input JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withenumeration.withenumeration',\n      {\n        body: {\n          field: 'one',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200); // should return 201\n    expect(res.body).toMatchObject({\n      field: 'one',\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withenumeration.withenumeration'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(['one', 'two'].includes(entry.field)).toBe(true);\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withenumeration.withenumeration',\n      {\n        body: {\n          field: 'two',\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withenumeration.withenumeration/${res.body.id}`,\n      {\n        body: {\n          field: 'one',\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 'one',\n    });\n  });\n\n  test('Allows null value', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withenumeration.withenumeration',\n      {\n        body: {\n          field: null,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200); // should return 201\n    expect(res.body).toMatchObject({\n      field: null,\n    });\n  });\n\n  test('Throws an error when the enumeration value is not in the options', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withenumeration.withenumeration',\n      {\n        body: {\n          field: 'invalid-value',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(400);\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/float.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withfloat',\n  attributes: {\n    field: {\n      type: 'float',\n    },\n  },\n};\n\ndescribe('Test type float', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const inputValue = 12.31;\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withfloat.withfloat',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: inputValue,\n    });\n  });\n\n  test('Create entry with integer should convert to float', async () => {\n    const inputValue = 1821;\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withfloat.withfloat',\n      {\n        body: {\n          field: inputValue,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 1821.0,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withfloat.withfloat');\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(Number));\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withfloat.withfloat',\n      {\n        body: {\n          field: 11.2,\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withfloat.withfloat/${res.body.id}`,\n      {\n        body: {\n          field: 14,\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 14.0,\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/integer.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withinteger',\n  attributes: {\n    field: {\n      type: 'integer',\n    },\n  },\n};\n\ndescribe('Test type integer', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withinteger.withinteger',\n      {\n        body: {\n          field: 123456,\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 123456,\n    });\n  });\n\n  // I don't think it will work everywhere ...\n  test('Create entry with a string should cast the value', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withinteger.withinteger',\n      {\n        body: {\n          field: '123456',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 123456,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withinteger.withinteger'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(Number.isInteger(entry.field)).toBe(true);\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withinteger.withinteger',\n      {\n        body: {\n          field: 123,\n        },\n      }\n    );\n\n    const updatedRes = await rq.put(\n      `/content-manager/collection-types/application::withinteger.withinteger/${res.body.id}`,\n      {\n        body: {\n          field: 543,\n        },\n      }\n    );\n\n    expect(updatedRes.statusCode).toBe(200);\n    expect(updatedRes.body).toMatchObject({\n      id: res.body.id,\n      field: 543,\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/json.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withjson',\n  attributes: {\n    field: {\n      type: 'json',\n    },\n  },\n};\n\ndescribe('Test type json', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const inputValue = {\n      key: 'value',\n    };\n    const res = await rq.post('/content-manager/collection-types/application::withjson.withjson', {\n      body: {\n        field: inputValue,\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: inputValue,\n    });\n  });\n\n  test('Create entry with array value input JSON', async () => {\n    const inputValue = [\n      {\n        key: 'value',\n      },\n      {\n        key: 'value',\n      },\n    ];\n    const res = await rq.post('/content-manager/collection-types/application::withjson.withjson', {\n      body: {\n        field: inputValue,\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: inputValue,\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withjson.withjson');\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toBeDefined();\n      expect(entry.field).not.toBeNull();\n      expect(typeof entry.field).toBe('object');\n    });\n  });\n\n  test.todo('Throw when input is not a nested object');\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withjson.withjson', {\n      body: {\n        field: {\n          key: 'value',\n        },\n      },\n    });\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withjson.withjson/${res.body.id}`,\n      {\n        body: {\n          field: {\n            newKey: 'newVal',\n          },\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: { newKey: 'newVal' },\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/password.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withpassword',\n  attributes: {\n    field: {\n      type: 'password',\n    },\n  },\n};\n\ndescribe('Test type password', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with value input JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withpassword.withpassword',\n      {\n        body: {\n          field: 'somePassword',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.field).toBeUndefined();\n  });\n\n  test.todo('Should be private by default');\n\n  test('Create entry with value input Formdata', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withpassword.withpassword',\n      {\n        body: {\n          field: '1234567',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.field).toBeUndefined();\n  });\n\n  test('Reading entry returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withpassword.withpassword'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(element => {\n      expect(element.field).toBeUndefined();\n    });\n  });\n\n  test('Updating entry sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withpassword.withpassword',\n      {\n        body: {\n          field: 'somePassword',\n        },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withpassword.withpassword/${res.body.id}`,\n      {\n        body: {\n          field: 'otherPwd',\n        },\n      }\n    );\n\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n    });\n    expect(res.body.field).toBeUndefined();\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/richtext.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withrichtext',\n  attributes: {\n    field: {\n      type: 'richtext',\n    },\n  },\n};\n\ndescribe('Test type richtext', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Creates an entry with JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withrichtext.withrichtext',\n      {\n        body: {\n          field: 'Some\\ntext',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 'Some\\ntext',\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withrichtext.withrichtext'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(String));\n    });\n  });\n\n  test('Updating entry with JSON sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withrichtext.withrichtext',\n      {\n        body: { field: 'Some \\ntext' },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withrichtext.withrichtext/${res.body.id}`,\n      {\n        body: { field: 'Updated \\nstring' },\n      }\n    );\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 'Updated \\nstring',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/string.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withstring',\n  attributes: {\n    field: {\n      type: 'string',\n    },\n  },\n};\n\ndescribe('Test type string', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Creates an entry with JSON', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withstring.withstring',\n      {\n        body: {\n          field: 'Some string',\n        },\n      }\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 'Some string',\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get(\n      '/content-manager/collection-types/application::withstring.withstring'\n    );\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(String));\n    });\n  });\n\n  test('Updating entry with JSON sets the right value and format', async () => {\n    const res = await rq.post(\n      '/content-manager/collection-types/application::withstring.withstring',\n      {\n        body: { field: 'Some string' },\n      }\n    );\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withstring.withstring/${res.body.id}`,\n      {\n        body: { field: 'Updated string' },\n      }\n    );\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 'Updated string',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/text.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withtext',\n  attributes: {\n    field: {\n      type: 'text',\n    },\n  },\n};\n\ndescribe('Test type text', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Creates an entry with JSON', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withtext.withtext', {\n      body: {\n        field: 'Some\\ntext',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: 'Some\\ntext',\n    });\n  });\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withtext.withtext');\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.pagination).toBeDefined();\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toEqual(expect.any(String));\n    });\n  });\n\n  test('Updating entry with JSON sets the right value and format', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withtext.withtext', {\n      body: { field: 'Some \\ntext' },\n    });\n\n    const updateRes = await rq.put(\n      `/content-manager/collection-types/application::withtext.withtext/${res.body.id}`,\n      {\n        body: { field: 'Updated \\nstring' },\n      }\n    );\n    expect(updateRes.statusCode).toBe(200);\n    expect(updateRes.body).toMatchObject({\n      id: res.body.id,\n      field: 'Updated \\nstring',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/time.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\n\nconst ct = {\n  name: 'withtime',\n  attributes: {\n    field: {\n      type: 'time',\n    },\n  },\n};\n\ndescribe('Test type time', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Create entry with valid value JSON', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withtime.withtime', {\n      body: {\n        field: '10:10:57.123',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      field: '10:10:57.123',\n    });\n  });\n\n  test.each(['00:00:00', '01:03:11.2', '01:03:11.93', '01:03:11.123'])(\n    'Accepts multiple time formats %s',\n    async input => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withtime.withtime',\n        {\n          body: {\n            field: input,\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(200);\n    }\n  );\n\n  test.each(['24:11:23', '23:72:11', '12:45:83', 1234, {}, 'test', new Date()])(\n    'Throws on invalid time (%s)',\n    async input => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withtime.withtime',\n        {\n          body: {\n            field: input,\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(400);\n    }\n  );\n\n  test('Reading entry, returns correct value', async () => {\n    const res = await rq.get('/content-manager/collection-types/application::withtime.withtime');\n\n    expect(res.statusCode).toBe(200);\n    expect(Array.isArray(res.body.results)).toBe(true);\n    res.body.results.forEach(entry => {\n      expect(entry.field).toMatch(/^2[0-3]|[01][0-9]:[0-5][0-9]:[0-5][0-9](.[0-9]{1,3})?$/);\n    });\n  });\n\n  test('Updating entry sets the right value and format JSON', async () => {\n    const res = await rq.post('/content-manager/collection-types/application::withtime.withtime', {\n      body: {\n        field: '12:11:04',\n      },\n    });\n\n    const uptimeRes = await rq.put(\n      `/content-manager/collection-types/application::withtime.withtime/${res.body.id}`,\n      {\n        body: {\n          field: '13:45:19.123',\n        },\n      }\n    );\n\n    expect(uptimeRes.statusCode).toBe(200);\n    expect(uptimeRes.body).toMatchObject({\n      id: res.body.id,\n      field: '13:45:19.123',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/fields/uid.test.e2e.js": "'use strict';\n\nconst { createTestBuilder } = require('../../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\ndescribe('Test type UID', () => {\n  describe('No targetField, required=false, not length limits', () => {\n    const model = {\n      name: 'withuid',\n      attributes: {\n        slug: {\n          type: 'uid',\n        },\n      },\n    };\n\n    const builder = createTestBuilder();\n\n    beforeAll(async () => {\n      await builder.addContentType(model).build();\n\n      strapi = await createStrapiInstance();\n      rq = await createAuthRequest({ strapi });\n    }, 60000);\n\n    afterAll(async () => {\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    test('Creates an entry successfully', async () => {\n      const res = await rq.post('/content-manager/collection-types/application::withuid.withuid', {\n        body: {\n          slug: 'valid-uid',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        slug: 'valid-uid',\n      });\n    });\n\n    test('Throws error on duplicate value', async () => {\n      const res = await rq.post('/content-manager/collection-types/application::withuid.withuid', {\n        body: {\n          slug: 'duplicate-uid',\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        slug: 'duplicate-uid',\n      });\n\n      const conflicting = await rq.post(\n        '/content-manager/collection-types/application::withuid.withuid',\n        {\n          body: {\n            slug: 'duplicate-uid',\n          },\n        }\n      );\n\n      expect(conflicting.statusCode).toBe(400);\n    });\n\n    test('Can set value to be null', async () => {\n      const res = await rq.post('/content-manager/collection-types/application::withuid.withuid', {\n        body: {\n          slug: null,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        slug: null,\n      });\n    });\n  });\n\n  describe('No targetField, required, no length limits', () => {\n    const model = {\n      name: 'withrequireduid',\n      attributes: {\n        slug: {\n          type: 'uid',\n          required: true,\n        },\n      },\n    };\n\n    const builder = createTestBuilder();\n\n    beforeAll(async () => {\n      await builder.addContentType(model).build();\n\n      strapi = await createStrapiInstance();\n      rq = await createAuthRequest({ strapi });\n    }, 60000);\n\n    afterAll(async () => {\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    test('Creates an entry successfully', async () => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withrequireduid.withrequireduid',\n        {\n          body: {\n            slug: 'valid-uid',\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        slug: 'valid-uid',\n      });\n    });\n\n    test('Throws error on duplicate value', async () => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withrequireduid.withrequireduid',\n        {\n          body: {\n            slug: 'duplicate-uid',\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        slug: 'duplicate-uid',\n      });\n\n      const conflicting = await rq.post(\n        '/content-manager/collection-types/application::withrequireduid.withrequireduid',\n        {\n          body: {\n            slug: 'duplicate-uid',\n          },\n        }\n      );\n\n      expect(conflicting.statusCode).toBe(400);\n    });\n\n    test('Cannot set value to be null', async () => {\n      const res = await rq.post(\n        '/content-manager/collection-types/application::withrequireduid.withrequireduid',\n        {\n          body: {\n            slug: null,\n          },\n        }\n      );\n\n      expect(res.statusCode).toBe(400);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/index.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst form = require('../../../test/helpers/generators');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst cleanDate = entry => {\n  delete entry.updatedAt;\n  delete entry.createdAt;\n  delete entry.created_at;\n  delete entry.updated_at;\n};\n\nconst builder = createTestBuilder();\nlet strapi;\nlet data;\nlet rq;\n\nconst deleteFixtures = async () => {\n  for (const [name, modelName] of [\n    ['references', 'reference'],\n    ['tags', 'tag'],\n    ['categories', 'category'],\n    ['articles', 'article'],\n    ['articlesWithTag', 'articlewithtag'],\n  ]) {\n    const uid = `application::${modelName}.${modelName}`;\n\n    await rq({\n      method: 'POST',\n      url: `/content-manager/collection-types/${uid}/actions/bulkDelete`,\n      body: {\n        ids: (data[name] || []).map(({ id }) => id),\n      },\n    });\n  }\n};\n\ndescribe('Content Manager End to End', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentTypes(\n        [form.article, form.tag, form.category, form.reference, form.articlewithtag],\n        { batch: true }\n      )\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Content Types api', () => {\n    test('Label is pluralized', async () => {\n      const res = await rq({\n        url: `/content-manager/content-types`,\n        method: 'GET',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toEqual(\n        expect.arrayContaining([\n          expect.objectContaining({\n            info: expect.objectContaining({\n              label: 'Articles',\n            }),\n          }),\n          expect.objectContaining({\n            info: expect.objectContaining({\n              label: 'Tags',\n            }),\n          }),\n          expect.objectContaining({\n            info: expect.objectContaining({\n              label: 'Categories',\n            }),\n          }),\n        ])\n      );\n    });\n  });\n\n  describe('Test manyToMany relation (article - tag) with Content Manager', () => {\n    beforeAll(async () => {\n      data = {\n        articles: [],\n        tags: [],\n      };\n    });\n\n    afterAll(async () => {\n      await deleteFixtures();\n    });\n\n    test('Create tag1', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag1',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag1');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create tag2', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag2',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag2');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create tag3', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag3',\n        },\n      });\n\n      data.tags.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('tag3');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create article1 without relation', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'My super content 1',\n        date: '2019-08-13T00:00:00.000Z',\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(0);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create article2 with tag1', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n        tags: [data.tags[0]],\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(1);\n      expect(body.tags[0].id).toBe(data.tags[0].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Update article1 add tag2', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        tags: [data.tags[1]],\n      });\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(1);\n      expect(body.tags[0].id).toBe(data.tags[1].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Update article1 add tag1 and tag3', async () => {\n      const entry = Object.assign({}, data.articles[0]);\n      entry.tags.push(data.tags[0]);\n      entry.tags.push(data.tags[2]);\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(3);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Update article1 remove one tag', async () => {\n      const entry = Object.assign({}, data.articles[0]);\n      entry.tags = entry.tags.slice(1);\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(2);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Update article1 remove all tag', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        tags: [],\n      });\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(0);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Delete all articles should remove the association in each tags related to them', async () => {\n      const { body: createdTag } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag11',\n        },\n      });\n\n      const { body: article12 } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: {\n          title: 'article12',\n          content: 'Content',\n          tags: [createdTag],\n        },\n      });\n\n      const { body: updatedTag } = await rq({\n        url: `/content-manager/collection-types/application::tag.tag/${createdTag.id}`,\n        method: 'GET',\n      });\n\n      const { body: article13 } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: {\n          title: 'article13',\n          content: 'Content',\n          tags: [updatedTag],\n        },\n      });\n\n      const articles = [article12, article13];\n\n      expect(Array.isArray(articles[0].tags)).toBeTruthy();\n      expect(articles[0].tags.length).toBe(1);\n      expect(Array.isArray(articles[1].tags)).toBeTruthy();\n      expect(articles[1].tags.length).toBe(1);\n\n      let { body: tagToGet } = await rq({\n        url: `/content-manager/collection-types/application::tag.tag/${createdTag.id}`,\n        method: 'GET',\n      });\n\n      expect(Array.isArray(tagToGet.articles)).toBeTruthy();\n      expect(tagToGet.articles.length).toBe(2);\n\n      await rq({\n        url: '/content-manager/collection-types/application::article.article/actions/bulkDelete',\n        method: 'POST',\n        body: {\n          ids: articles.map(article => article.id),\n        },\n      });\n\n      let { body: tagToGet2 } = await rq({\n        url: `/content-manager/collection-types/application::tag.tag/${createdTag.id}`,\n        method: 'GET',\n      });\n\n      expect(Array.isArray(tagToGet2.articles)).toBeTruthy();\n      expect(tagToGet2.articles.length).toBe(0);\n    });\n  });\n\n  describe('Test manyWay articlesWithTags and tags', () => {\n    beforeAll(() => {\n      data = {\n        tags: [],\n        articlesWithTag: [],\n      };\n    });\n\n    afterAll(async () => {\n      await deleteFixtures();\n    });\n\n    test('Creating an article with some many way tags', async () => {\n      const { body: createdTag } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag11',\n        },\n      });\n\n      data.tags.push(createdTag);\n\n      const entry = {\n        tags: [createdTag.id],\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::articlewithtag.articlewithtag',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articlesWithTag.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.tags.length).toBe(1);\n      expect(body.tags[0].id).toBe(data.tags[0].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n  });\n\n  describe('Test oneToMany - manyToOne relation (article - category) with Content Manager', () => {\n    beforeAll(() => {\n      data = {\n        articles: [],\n        categories: [],\n      };\n    });\n\n    afterAll(async () => {\n      await deleteFixtures();\n    });\n\n    test('Create cat1', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::category.category',\n        method: 'POST',\n        body: {\n          name: 'cat1',\n        },\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('cat1');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create cat2', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::category.category',\n        method: 'POST',\n        body: {\n          name: 'cat2',\n        },\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.name).toBe('cat2');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Create article1 with cat1', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'Content 1',\n        category: data.categories[0],\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Update article1 with cat2', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        category: data.categories[1],\n      });\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Create article2', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Update article2 with cat2', async () => {\n      const entry = Object.assign({}, data.articles[1], {\n        category: data.categories[1],\n      });\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[1] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.category.name).toBe(entry.category.name);\n      expect(Array.isArray(body.tags)).toBeTruthy();\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Update cat1 with article1', async () => {\n      const entry = Object.assign({}, data.categories[0]);\n      entry.articles.push(data.articles[0]);\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::category.category/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.categories[0] = body;\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.articles.length).toBe(1);\n      expect(body.name).toBe(entry.name);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Create cat3 with article1', async () => {\n      const entry = {\n        name: 'cat3',\n        articles: [data.articles[0]],\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::category.category',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.categories.push(body);\n\n      expect(body.id);\n      expect(Array.isArray(body.articles)).toBeTruthy();\n      expect(body.articles.length).toBe(1);\n      expect(body.name).toBe(entry.name);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Get article1 with cat3', async () => {\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${data.articles[0].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.category.id).toBe(data.categories[2].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Get article2 with cat2', async () => {\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${data.articles[1].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.category.id).toBe(data.categories[1].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Get cat1 without relations', async () => {\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::category.category/${data.categories[0].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(0);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Get cat2 with article2', async () => {\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::category.category/${data.categories[1].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(1);\n      expect(body.articles[0].id).toBe(data.articles[1].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Get cat3 with article1', async () => {\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::category.category/${data.categories[2].id}`,\n        method: 'GET',\n      });\n\n      expect(body.id);\n      expect(body.articles.length).toBe(1);\n      expect(body.articles[0].id).toBe(data.articles[0].id);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n  });\n\n  describe('Test oneToOne relation (article - reference) with Content Manager', () => {\n    beforeAll(() => {\n      data = {\n        articles: [],\n        references: [],\n      };\n    });\n\n    afterAll(async () => {\n      await deleteFixtures();\n    });\n\n    test('Create ref1', async () => {\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::reference.reference',\n        method: 'POST',\n        body: {\n          name: 'ref1',\n        },\n      });\n\n      data.references.push(body);\n\n      expect(body.id);\n      expect(body.name).toBe('ref1');\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Create article1', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'Content 1',\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.published_at).toBeUndefined();\n    });\n\n    test('Update article1 with ref1', async () => {\n      const entry = Object.assign({}, data.articles[0], {\n        reference: data.references[0].id,\n      });\n\n      cleanDate(entry);\n\n      let { body } = await rq({\n        url: `/content-manager/collection-types/application::article.article/${entry.id}`,\n        method: 'PUT',\n        body: entry,\n      });\n\n      data.articles[0] = body;\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.reference.id).toBe(entry.reference);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n\n    test('Create article2 with ref1', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n        reference: data.references[0].id,\n      };\n\n      let { body } = await rq({\n        url: '/content-manager/collection-types/application::article.article',\n        method: 'POST',\n        body: entry,\n      });\n\n      data.articles.push(body);\n\n      expect(body.id);\n      expect(body.title).toBe(entry.title);\n      expect(body.content).toBe(entry.content);\n      expect(body.reference.id).toBe(entry.reference);\n      expect(body.created_by).toMatchObject({ email: 'admin@strapi.io' });\n      expect(body.updated_by).toMatchObject({ email: 'admin@strapi.io' });\n    });\n  });\n\n  describe('Test oneWay relation (reference - tag) with Content Manager', () => {\n    test('Attach Tag to a Reference', async () => {\n      const { body: tagToCreate } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      });\n\n      const { body: referenceToCreate } = await rq({\n        url: '/content-manager/collection-types/application::reference.reference',\n        method: 'POST',\n        body: {\n          name: 'cat111',\n          tag: tagToCreate,\n        },\n      });\n\n      expect(referenceToCreate.tag.id).toBe(tagToCreate.id);\n    });\n\n    test('Detach Tag to a Reference', async () => {\n      const { body: tagToCreate } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      });\n\n      const { body: referenceToCreate } = await rq({\n        url: '/content-manager/collection-types/application::reference.reference',\n        method: 'POST',\n        body: {\n          name: 'cat111',\n          tag: tagToCreate,\n        },\n      });\n\n      expect(referenceToCreate.tag.id).toBe(tagToCreate.id);\n\n      const { body: referenceToUpdate } = await rq({\n        url: `/content-manager/collection-types/application::reference.reference/${referenceToCreate.id}`,\n        method: 'PUT',\n        body: {\n          tag: null,\n        },\n      });\n\n      expect(referenceToUpdate.tag).toBe(null);\n    });\n\n    test('Delete Tag so the relation in the Reference side should be removed', async () => {\n      const { body: tagToCreate } = await rq({\n        url: '/content-manager/collection-types/application::tag.tag',\n        method: 'POST',\n        body: {\n          name: 'tag111',\n        },\n      });\n\n      const { body: referenceToCreate } = await rq({\n        url: '/content-manager/collection-types/application::reference.reference',\n        method: 'POST',\n        body: {\n          name: 'cat111',\n          tag: tagToCreate,\n        },\n      });\n\n      await rq({\n        url: `/content-manager/collection-types/application::tag.tag/${tagToCreate.id}`,\n        method: 'DELETE',\n      });\n\n      const { body: referenceToGet } = await rq({\n        url: `/content-manager/collection-types/application::reference.reference/${referenceToCreate.id}`,\n        method: 'GET',\n      });\n\n      if (!referenceToGet.tag || Object.keys(referenceToGet.tag).length === 0) return;\n      expect(referenceToGet.tag).toBe(null);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/relation-list.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst { omit, pick } = require('lodash/fp');\n\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\nlet data = {\n  products: [],\n  shops: [],\n};\n\nconst productModel = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n  connection: 'default',\n  name: 'product',\n  description: '',\n  collectionName: '',\n};\n\nconst productWithDPModel = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n  },\n  connection: 'default',\n  name: 'product',\n  draftAndPublish: true,\n  description: '',\n  collectionName: '',\n};\n\nconst shopModel = {\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    products: {\n      dominant: true,\n      nature: 'manyToMany',\n      target: 'application::product.product',\n      targetAttribute: 'shops',\n    },\n  },\n  connection: 'default',\n  name: 'shop',\n};\n\nconst shops = [\n  {\n    name: 'market',\n  },\n];\n\nconst products = ({ withPublished = false }) => ({ shop }) => {\n  const shops = [shop[0].id];\n\n  const entries = [\n    {\n      name: 'tomato',\n      shops,\n      published_at: new Date(),\n    },\n    {\n      name: 'apple',\n      shops,\n      published_at: null,\n    },\n  ];\n\n  if (withPublished) {\n    return entries;\n  }\n\n  return entries.map(omit('published_at'));\n};\n\ndescribe('Relation-list route', () => {\n  describe('without draftAndPublish', () => {\n    const builder = createTestBuilder();\n\n    beforeAll(async () => {\n      await builder\n        .addContentTypes([productModel, shopModel])\n        .addFixtures(shopModel.name, shops)\n        .addFixtures(productModel.name, products({ withPublished: false }))\n        .build();\n\n      strapi = await createStrapiInstance();\n      rq = await createAuthRequest({ strapi });\n\n      data.shops = builder.sanitizedFixturesFor(shopModel.name, strapi);\n      data.products = builder.sanitizedFixturesFor(productModel.name, strapi);\n    }, 60000);\n\n    afterAll(async () => {\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    test('Can get relation-list for products of a shop', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/relations/application::shop.shop/products',\n      });\n\n      expect(res.body).toHaveLength(data.products.length);\n      data.products.forEach((product, index) => {\n        expect(res.body[index]).toStrictEqual(pick(['_id', 'id', 'name'], product));\n      });\n    });\n\n    test('Can get relation-list for products of a shop and omit some results', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/relations/application::shop.shop/products',\n        body: {\n          idsToOmit: [data.products[0].id],\n        },\n      });\n\n      expect(res.body).toHaveLength(1);\n      expect(res.body[0]).toStrictEqual(pick(['_id', 'id', 'name'], data.products[1]));\n    });\n  });\n\n  describe('with draftAndPublish', () => {\n    const builder = createTestBuilder();\n\n    beforeAll(async () => {\n      await builder\n        .addContentTypes([productWithDPModel, shopModel])\n        .addFixtures(shopModel.name, shops)\n        .addFixtures(productWithDPModel.name, products({ withPublished: true }))\n        .build();\n\n      strapi = await createStrapiInstance();\n      rq = await createAuthRequest({ strapi });\n\n      data.shops = builder.sanitizedFixturesFor(shopModel.name, strapi);\n      data.products = builder.sanitizedFixturesFor(productWithDPModel.name, strapi);\n    }, 60000);\n\n    afterAll(async () => {\n      await strapi.destroy();\n      await builder.cleanup();\n    }, 60000);\n\n    test('Can get relation-list for products of a shop', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/relations/application::shop.shop/products',\n      });\n\n      expect(res.body).toHaveLength(data.products.length);\n\n      const tomatoProductRes = res.body.find(p => p.name === 'tomato');\n      const appleProductRes = res.body.find(p => p.name === 'apple');\n\n      expect(tomatoProductRes).toMatchObject(pick(['_id', 'id', 'name'], data.products[0]));\n      expect(tomatoProductRes.published_at).toBeISODate();\n      expect(appleProductRes).toStrictEqual({\n        ...pick(['_id', 'id', 'name'], data.products[1]),\n        published_at: null,\n      });\n    });\n\n    test('Can get relation-list for products of a shop and omit some results', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/relations/application::shop.shop/products',\n        body: {\n          idsToOmit: [data.products[1].id],\n        },\n      });\n\n      expect(res.body).toHaveLength(1);\n      expect(res.body[0]).toMatchObject(pick(['_id', 'id', 'name'], data.products[0]));\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/search.test.e2e.js": "'use strict';\n\n// Test an API with all the possible filed types and simple filterings (no deep filtering, no relations)\nconst { omit } = require('lodash/fp');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst CREATOR_FIELDS = ['updated_by', 'created_by'];\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet data = {\n  beds: [],\n};\n\nconst bedModel = {\n  name: 'bed',\n  kind: 'collectionType',\n  attributes: {\n    name: {\n      type: 'string',\n    },\n    weight: {\n      type: 'decimal',\n    },\n    shortDescription: {\n      type: 'text',\n    },\n    description: {\n      type: 'richtext',\n    },\n    sku: {\n      type: 'uid',\n    },\n    savEmail: {\n      type: 'email',\n    },\n    type: {\n      enum: ['spring', 'foam', 'feather'],\n      type: 'enumeration',\n    },\n    serialNumber: {\n      type: 'biginteger',\n    },\n    peopleNumber: {\n      type: 'integer',\n    },\n    fabricThickness: {\n      type: 'float',\n    },\n  },\n};\n\nconst bedFixtures = [\n  {\n    name: 'Sleepy Bed',\n    weight: 12.4,\n    shortDescription: 'Is a good bed to sleep in.',\n    description: '**Is a very good bed to sleep in.** We promise.',\n    sku: 'sleepybed_0152',\n    savEmail: 'sav@bed.fr',\n    type: 'foam',\n    serialNumber: 9999999999999999,\n    peopleNumber: 6,\n    fabricThickness: 1.14157,\n  },\n  {\n    name: 'Tired Bed',\n    weight: 11.1,\n    shortDescription: 'You will never wake up again.',\n    description: '**You will never wake up again.** Never.',\n    sku: 'tiredbed_0001',\n    savEmail: 'sav@sleep.fr',\n    type: 'feather',\n    serialNumber: 1111111111111111,\n    peopleNumber: 1,\n    fabricThickness: 1.0001,\n  },\n  {\n    name: 'Zombie Bed',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: null,\n    fabricThickness: null,\n  },\n  {\n    name: 'a*b_c%d\\\\e+f',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: null,\n    fabricThickness: null,\n  },\n  {\n    name: 'Tired Bed',\n    weight: null,\n    shortDescription: null,\n    description: null,\n    sku: null,\n    savEmail: null,\n    type: null,\n    serialNumber: null,\n    peopleNumber: 7,\n    fabricThickness: null,\n  },\n];\n\ndescribe('Search query', () => {\n  beforeAll(async () => {\n    await builder\n      .addContentType(bedModel)\n      .addFixtures(bedModel.name, bedFixtures)\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    data.beds = builder.sanitizedFixturesFor(bedModel.name, strapi);\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Without filters', () => {\n    test('search for \"id\"', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: data.beds[2].id,\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(1);\n      expect(res.body.results[0]).toMatchObject(data.beds[2]);\n    });\n\n    test.each(Object.keys(bedFixtures[0]))('search that target column %p', async columnName => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: bedFixtures[0][columnName],\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(1);\n      expect(res.body.results[0]).toMatchObject(data.beds[0]);\n    });\n\n    test('search with an empty query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: '',\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(data.beds.length);\n      expect(res.body.results.map(omit(CREATOR_FIELDS))).toEqual(expect.arrayContaining(data.beds));\n    });\n\n    test('search with special characters', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: data.beds[3].name,\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(1);\n      expect(res.body.results[0]).toMatchObject(data.beds[3]);\n    });\n  });\n\n  describe('With filters', () => {\n    test('search with an empty query & peopleNumber > 0', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: '',\n          peopleNumber_gt: 0,\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(3);\n      expect(res.body.results).toMatchObject([data.beds[0], data.beds[1], data.beds[4]]);\n    });\n    test('search with an empty query & peopleNumber > 1', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: '',\n          peopleNumber_gt: 1,\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(2);\n      expect(res.body.results).toMatchObject([data.beds[0], data.beds[4]]);\n    });\n    test('search with an empty query & peopleNumber in [1, 6]', async () => {\n      const res = await rq({\n        method: 'GET',\n        url:\n          '/content-manager/collection-types/application::bed.bed?peopleNumber=1&peopleNumber=6&_q=',\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(2);\n      expect(res.body.results).toMatchObject(data.beds.slice(0, 2));\n    });\n    test('search for \"Sleepy Bed\" & peopleNumber < 7', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/application::bed.bed',\n        qs: {\n          _q: 'Sleepy Bed',\n          peopleNumber_lt: 7,\n        },\n      });\n\n      expect(Array.isArray(res.body.results)).toBe(true);\n      expect(res.body.results.length).toBe(1);\n      expect(res.body.results).toMatchObject([data.beds[0]]);\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/tests/single-type.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet uid = 'application::single-type-model.single-type-model';\n\nconst ct = {\n  kind: 'singleType',\n  name: 'single-type-model',\n  attributes: {\n    title: {\n      type: 'string',\n    },\n  },\n};\n\ndescribe('Content Manager single types', () => {\n  beforeAll(async () => {\n    await builder.addContentType(ct).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  test('Label is not pluralized', async () => {\n    const res = await rq({\n      url: `/content-manager/content-types?kind=singleType`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toEqual(\n      expect.arrayContaining([\n        expect.objectContaining({\n          info: expect.objectContaining({\n            label: 'Single-type-model',\n          }),\n        }),\n      ])\n    );\n  });\n\n  test('find single type content returns 404 when not created', async () => {\n    const res = await rq({\n      url: `/content-manager/single-types/${uid}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(404);\n  });\n\n  test('Create content', async () => {\n    const res = await rq({\n      url: `/content-manager/single-types/${uid}`,\n      method: 'PUT',\n      body: {\n        title: 'Title',\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: expect.anything(),\n      title: 'Title',\n    });\n  });\n\n  test('find single type content returns an object ', async () => {\n    const res = await rq({\n      url: `/content-manager/single-types/${uid}`,\n      method: 'GET',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      id: expect.anything(),\n      title: 'Title',\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-manager/utils/wrap-bad-request.js": "'use strict';\n\nmodule.exports = fn => async (...args) => {\n  try {\n    await fn(...args);\n  } catch (error) {\n    if (strapi.errors.isBoom(error)) {\n      throw error;\n    }\n\n    // these are errors like unique constraints\n    strapi.log.error(error);\n    throw strapi.errors.badRequest('Invalid input data. Please verify unique constraints');\n  }\n};\n",
    "packages/strapi-plugin-content-type-builder/admin/src/containers/DataManagerProvider/index.js": "import React, { memo, useEffect, useMemo, useReducer, useState, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { get, groupBy, set, size } from 'lodash';\nimport {\n  request,\n  LoadingIndicatorPage,\n  useGlobalContext,\n  PopUpWarning,\n} from 'strapi-helper-plugin';\nimport { useHistory, useLocation, useRouteMatch, Redirect } from 'react-router-dom';\nimport DataManagerContext from '../../contexts/DataManagerContext';\nimport getTrad from '../../utils/getTrad';\nimport makeUnique from '../../utils/makeUnique';\nimport pluginId from '../../pluginId';\nimport FormModal from '../FormModal';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\nimport createDataObject from './utils/createDataObject';\nimport createModifiedDataSchema, {\n  orderAllDataAttributesWithImmutable,\n} from './utils/createModifiedDataSchema';\nimport retrieveSpecificInfoFromComponents from './utils/retrieveSpecificInfoFromComponents';\nimport retrieveComponentsFromSchema from './utils/retrieveComponentsFromSchema';\nimport retrieveNestedComponents from './utils/retrieveNestedComponents';\nimport { retrieveComponentsThatHaveComponents } from './utils/retrieveComponentsThatHaveComponents';\nimport {\n  getComponentsToPost,\n  formatMainDataType,\n  getCreatedAndModifiedComponents,\n  sortContentType,\n} from './utils/cleanData';\n\nconst DataManagerProvider = ({ allIcons, children }) => {\n  const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n  const [infoModals, toggleInfoModal] = useState({ cancel: false });\n  const {\n    autoReload,\n    currentEnvironment,\n    emitEvent,\n    fetchUserPermissions,\n    formatMessage,\n    menu,\n  } = useGlobalContext();\n  const {\n    components,\n    contentTypes,\n    isLoading,\n    isLoadingForDataToBeSet,\n    initialData,\n    modifiedData,\n    reservedNames,\n  } = reducerState.toJS();\n  const { pathname } = useLocation();\n  const { push } = useHistory();\n  const contentTypeMatch = useRouteMatch(`/plugins/${pluginId}/content-types/:uid`);\n  const componentMatch = useRouteMatch(\n    `/plugins/${pluginId}/component-categories/:categoryUid/:componentUid`\n  );\n\n  const formatMessageRef = useRef();\n  formatMessageRef.current = formatMessage;\n  const isInDevelopmentMode = currentEnvironment === 'development' && autoReload;\n\n  const isInContentTypeView = contentTypeMatch !== null;\n  const firstKeyToMainSchema = isInContentTypeView ? 'contentType' : 'component';\n  const currentUid = isInContentTypeView\n    ? get(contentTypeMatch, 'params.uid', null)\n    : get(componentMatch, 'params.componentUid', null);\n  const abortController = new AbortController();\n  const { signal } = abortController;\n  const getDataRef = useRef();\n  const endPoint = isInContentTypeView ? 'content-types' : 'components';\n\n  getDataRef.current = async () => {\n    try {\n      const [\n        { data: componentsArray },\n        { data: contentTypesArray },\n        reservedNames,\n      ] = await Promise.all(\n        ['components', 'content-types', 'reserved-names'].map(endPoint => {\n          return request(`/${pluginId}/${endPoint}`, {\n            method: 'GET',\n            signal,\n          });\n        })\n      );\n\n      const components = createDataObject(componentsArray);\n      const contentTypes = createDataObject(contentTypesArray);\n      const orderedComponents = orderAllDataAttributesWithImmutable({\n        components,\n      });\n      const orderedContenTypes = orderAllDataAttributesWithImmutable({\n        components: contentTypes,\n      });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        components: orderedComponents.get('components'),\n        contentTypes: orderedContenTypes.get('components'),\n        reservedNames,\n      });\n    } catch (err) {\n      console.error({ err });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  useEffect(() => {\n    getDataRef.current();\n  }, []);\n\n  useEffect(() => {\n    // We need to set the modifiedData after the data has been retrieved\n    // and also on pathname change\n    if (!isLoading && currentUid) {\n      setModifiedData();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isLoading, pathname, currentUid]);\n\n  useEffect(() => {\n    if (currentEnvironment === 'development' && !autoReload) {\n      strapi.notification.toggle({\n        type: 'info',\n        message: { id: getTrad('notification.info.autoreaload-disable') },\n      });\n    }\n  }, [autoReload, currentEnvironment]);\n\n  const didModifiedComponents =\n    getCreatedAndModifiedComponents(modifiedData.components || {}, components).length > 0;\n\n  const addAttribute = (\n    attributeToSet,\n    forTarget,\n    targetUid,\n    isEditing = false,\n    initialAttribute,\n    shouldAddComponentToData = false\n  ) => {\n    const actionType = isEditing ? 'EDIT_ATTRIBUTE' : 'ADD_ATTRIBUTE';\n\n    dispatch({\n      type: actionType,\n      attributeToSet,\n      forTarget,\n      targetUid,\n      initialAttribute,\n      shouldAddComponentToData,\n    });\n  };\n\n  const addCreatedComponentToDynamicZone = (dynamicZoneTarget, componentsToAdd) => {\n    dispatch({\n      type: 'ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE',\n      dynamicZoneTarget,\n      componentsToAdd,\n    });\n  };\n\n  const cancelChanges = () => {\n    toggleModalCancel();\n    dispatch({ type: 'CANCEL_CHANGES' });\n  };\n\n  const createSchema = (\n    data,\n    schemaType,\n    uid,\n    componentCategory,\n    shouldAddComponentToData = false\n  ) => {\n    const type = schemaType === 'contentType' ? 'CREATE_SCHEMA' : 'CREATE_COMPONENT_SCHEMA';\n\n    dispatch({\n      type,\n      data,\n      componentCategory,\n      schemaType,\n      uid,\n      shouldAddComponentToData,\n    });\n  };\n\n  const changeDynamicZoneComponents = (dynamicZoneTarget, newComponents) => {\n    dispatch({\n      type: 'CHANGE_DYNAMIC_ZONE_COMPONENTS',\n      dynamicZoneTarget,\n      newComponents,\n    });\n  };\n\n  const removeAttribute = (mainDataKey, attributeToRemoveName, componentUid = '') => {\n    const type =\n      mainDataKey === 'components' ? 'REMOVE_FIELD_FROM_DISPLAYED_COMPONENT' : 'REMOVE_FIELD';\n\n    if (mainDataKey === 'contentType') {\n      emitEvent('willDeleteFieldOfContentType');\n    }\n\n    dispatch({\n      type,\n      mainDataKey,\n      attributeToRemoveName,\n      componentUid,\n    });\n  };\n\n  const deleteCategory = async categoryUid => {\n    try {\n      const requestURL = `/${pluginId}/component-categories/${categoryUid}`;\n      // eslint-disable-next-line no-alert\n      const userConfirm = window.confirm(\n        formatMessage({\n          id: getTrad('popUpWarning.bodyMessage.category.delete'),\n        })\n      );\n      // Close the modal\n      push({ search: '' });\n\n      if (userConfirm) {\n        strapi.lockApp();\n\n        await request(requestURL, { method: 'DELETE' }, true);\n\n        await updatePermissions();\n\n        // Reload the plugin so the cycle is new again\n        dispatch({ type: 'RELOAD_PLUGIN' });\n        // Refetch all the data\n        getDataRef.current();\n      }\n    } catch (err) {\n      console.error({ err });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  const deleteData = async () => {\n    try {\n      const requestURL = `/${pluginId}/${endPoint}/${currentUid}`;\n      const isTemporary = get(modifiedData, [firstKeyToMainSchema, 'isTemporary'], false);\n      // eslint-disable-next-line no-alert\n      const userConfirm = window.confirm(\n        formatMessage({\n          id: getTrad(\n            `popUpWarning.bodyMessage.${isInContentTypeView ? 'contentType' : 'component'}.delete`\n          ),\n        })\n      );\n\n      // Close the modal\n      push({ search: '' });\n\n      if (userConfirm) {\n        if (isTemporary) {\n          // Delete the not saved type\n          // Here we just need to reset the components to the initial ones and also the content types\n          // Doing so will trigging a url change since the type doesn't exist in either the contentTypes or the components\n          // so the modified and the initial data will also be reset in the useEffect...\n          dispatch({ type: 'DELETE_NOT_SAVED_TYPE' });\n\n          return;\n        }\n\n        strapi.lockApp();\n\n        await request(requestURL, { method: 'DELETE' }, true);\n\n        // Reload the plugin so the cycle is new again\n        dispatch({ type: 'RELOAD_PLUGIN' });\n\n        // Refetch the permissions\n        await updatePermissions();\n\n        // Update the app menu\n        await updateAppMenu();\n        // Refetch all the data\n        getDataRef.current();\n      }\n    } catch (err) {\n      console.error({ err });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  const editCategory = async (categoryUid, body) => {\n    try {\n      const requestURL = `/${pluginId}/component-categories/${categoryUid}`;\n\n      // Close the modal\n      push({ search: '' });\n\n      // Lock the app\n      strapi.lockApp();\n\n      // Update the category\n      await request(requestURL, { method: 'PUT', body }, true);\n\n      await updatePermissions();\n\n      // Reload the plugin so the cycle is new again\n      dispatch({ type: 'RELOAD_PLUGIN' });\n      // Refetch all the data\n      getDataRef.current();\n    } catch (err) {\n      console.error({ err });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  const getAllComponentsThatHaveAComponentInTheirAttributes = () => {\n    // We need to create an object with all the non modified compos\n    // plus the ones that are created on the fly\n    const allCompos = Object.assign({}, components, modifiedData.components);\n\n    // Since we apply the modification of a specific component only in the modified data\n    // we need to update all compos with the modifications\n    if (!isInContentTypeView) {\n      const currentEditedCompo = get(modifiedData, 'component', {});\n\n      set(allCompos, get(currentEditedCompo, ['uid'], ''), currentEditedCompo);\n    }\n\n    const composWithCompos = retrieveComponentsThatHaveComponents(allCompos);\n\n    return makeUnique(composWithCompos);\n  };\n\n  const getAllNestedComponents = () => {\n    const appNestedCompo = retrieveNestedComponents(components);\n    const editingDataNestedCompos = retrieveNestedComponents(modifiedData.components || {});\n\n    return makeUnique([...editingDataNestedCompos, ...appNestedCompo]);\n  };\n\n  const removeComponentFromDynamicZone = (dzName, componentToRemoveIndex) => {\n    dispatch({\n      type: 'REMOVE_COMPONENT_FROM_DYNAMIC_ZONE',\n      dzName,\n      componentToRemoveIndex,\n    });\n  };\n\n  const setModifiedData = () => {\n    const currentSchemas = isInContentTypeView ? contentTypes : components;\n    const schemaToSet = get(currentSchemas, currentUid, {\n      schema: { attributes: {} },\n    });\n\n    const retrievedComponents = retrieveComponentsFromSchema(\n      schemaToSet.schema.attributes,\n      components\n    );\n    const newSchemaToSet = createModifiedDataSchema(\n      schemaToSet,\n      retrievedComponents,\n      components,\n      isInContentTypeView\n    );\n\n    const dataShape = orderAllDataAttributesWithImmutable(newSchemaToSet, isInContentTypeView);\n\n    // This prevents from losing the created content type or component when clicking on the link from the left menu\n    const hasJustCreatedSchema =\n      get(schemaToSet, 'isTemporary', false) &&\n      size(get(schemaToSet, 'schema.attributes', {})) === 0;\n\n    dispatch({\n      type: 'SET_MODIFIED_DATA',\n      schemaToSet: dataShape,\n      hasJustCreatedSchema,\n    });\n  };\n\n  const shouldRedirect = useMemo(() => {\n    const dataSet = isInContentTypeView ? contentTypes : components;\n\n    return !Object.keys(dataSet).includes(currentUid) && !isLoading;\n  }, [components, contentTypes, currentUid, isInContentTypeView, isLoading]);\n\n  const redirectEndpoint = useMemo(() => {\n    const allowedEndpoints = Object.keys(contentTypes)\n      .filter(uid => get(contentTypes, [uid, 'schema', 'editable'], true))\n      .sort();\n\n    return get(allowedEndpoints, '0', '');\n  }, [contentTypes]);\n\n  if (shouldRedirect) {\n    return <Redirect to={`/plugins/${pluginId}/content-types/${redirectEndpoint}`} />;\n  }\n\n  const submitData = async additionalContentTypeData => {\n    try {\n      const isCreating = get(modifiedData, [firstKeyToMainSchema, 'isTemporary'], false);\n      const body = {\n        components: getComponentsToPost(\n          modifiedData.components,\n          components,\n          currentUid,\n          isCreating\n        ),\n      };\n\n      if (isInContentTypeView) {\n        body.contentType = {\n          ...formatMainDataType(modifiedData.contentType),\n          ...additionalContentTypeData,\n        };\n\n        emitEvent('willSaveContentType');\n      } else {\n        body.component = formatMainDataType(modifiedData.component, true);\n\n        emitEvent('willSaveComponent');\n      }\n\n      const method = isCreating ? 'POST' : 'PUT';\n\n      const baseURL = `/${pluginId}/${endPoint}`;\n      const requestURL = isCreating ? baseURL : `${baseURL}/${currentUid}`;\n\n      // Lock the app\n      strapi.lockApp();\n\n      await request(requestURL, { method, body }, true);\n\n      await updatePermissions();\n\n      // Update the app menu\n      await updateAppMenu();\n\n      // Submit ct tracking success\n      if (isInContentTypeView) {\n        emitEvent('didSaveContentType');\n\n        const oldName = get(body, ['contentType', 'schema', 'name'], '');\n        const newName = get(initialData, ['contentType', 'schema', 'name'], '');\n\n        if (!isCreating && oldName !== newName) {\n          emitEvent('didEditNameOfContentType');\n        }\n      } else {\n        emitEvent('didSaveComponent');\n      }\n\n      // Reload the plugin so the cycle is new again\n      dispatch({ type: 'RELOAD_PLUGIN' });\n      // Refetch all the data\n      getDataRef.current();\n    } catch (err) {\n      if (!isInContentTypeView) {\n        emitEvent('didNotSaveComponent');\n      }\n\n      console.error({ err: err.response });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    } finally {\n      strapi.unlockApp();\n    }\n  };\n\n  // Open the modal warning cancel changes\n  const toggleModalCancel = () => {\n    toggleInfoModal(prev => ({ ...prev, cancel: !prev.cancel }));\n  };\n\n  // Update the menu using the internal API\n  const updateAppMenu = async () => {\n    if (menu.getModels) {\n      await menu.getModels();\n    }\n  };\n\n  const updatePermissions = async () => {\n    await fetchUserPermissions();\n  };\n\n  const updateSchema = (data, schemaType, componentUID) => {\n    dispatch({\n      type: 'UPDATE_SCHEMA',\n      data,\n      schemaType,\n      uid: componentUID,\n    });\n  };\n\n  return (\n    <DataManagerContext.Provider\n      value={{\n        addAttribute,\n        addCreatedComponentToDynamicZone,\n        allComponentsCategories: retrieveSpecificInfoFromComponents(components, ['category']),\n        allComponentsIconAlreadyTaken: retrieveSpecificInfoFromComponents(components, [\n          'schema',\n          'icon',\n        ]),\n        allIcons,\n        changeDynamicZoneComponents,\n        components,\n        componentsGroupedByCategory: groupBy(components, 'category'),\n        componentsThatHaveOtherComponentInTheirAttributes: getAllComponentsThatHaveAComponentInTheirAttributes(),\n        contentTypes,\n        createSchema,\n        deleteCategory,\n        deleteData,\n        editCategory,\n        isInDevelopmentMode,\n        initialData,\n        isInContentTypeView,\n        modifiedData,\n        nestedComponents: getAllNestedComponents(),\n        removeAttribute,\n        removeComponentFromDynamicZone,\n        reservedNames,\n        setModifiedData,\n        sortedContentTypesList: sortContentType(contentTypes),\n        submitData,\n        toggleModalCancel,\n        updateSchema,\n      }}\n    >\n      {isLoadingForDataToBeSet ? (\n        <LoadingIndicatorPage />\n      ) : (\n        <>\n          {children}\n          {isInDevelopmentMode && (\n            <>\n              <FormModal />\n              <PopUpWarning\n                isOpen={infoModals.cancel}\n                toggleModal={toggleModalCancel}\n                content={{\n                  message: getTrad(\n                    `popUpWarning.bodyMessage.cancel-modifications${\n                      didModifiedComponents ? '.with-components' : ''\n                    }`\n                  ),\n                }}\n                popUpWarningType=\"danger\"\n                onConfirm={() => {\n                  cancelChanges();\n                }}\n              />\n            </>\n          )}\n        </>\n      )}\n    </DataManagerContext.Provider>\n  );\n};\n\nDataManagerProvider.propTypes = {\n  allIcons: PropTypes.array.isRequired,\n  children: PropTypes.node.isRequired,\n};\n\nexport default memo(DataManagerProvider);\n",
    "packages/strapi-plugin-content-type-builder/admin/src/containers/FormModal/index.js": "import React, { useCallback, useEffect, useReducer, useRef, useState } from 'react';\nimport {\n  HeaderModal,\n  HeaderModalTitle,\n  Modal,\n  ModalBody,\n  ModalFooter,\n  ModalForm,\n  PopUpWarning,\n  getYupInnerErrors,\n  useGlobalContext,\n  useQuery,\n  InputsIndex,\n} from 'strapi-helper-plugin';\nimport { Button, Text, Padded } from '@buffetjs/core';\nimport { Inputs } from '@buffetjs/custom';\n\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { FormattedMessage } from 'react-intl';\nimport { get, has, isEmpty, set, toLower, toString, upperFirst } from 'lodash';\nimport pluginId from '../../pluginId';\nimport useDataManager from '../../hooks/useDataManager';\nimport AttributeOption from '../../components/AttributeOption';\nimport BooleanBox from '../../components/BooleanBox';\nimport ComponentIconPicker from '../../components/ComponentIconPicker';\nimport CustomCheckbox from '../../components/CustomCheckbox';\nimport ModalHeader from '../../components/ModalHeader';\nimport HeaderModalNavContainer from '../../components/HeaderModalNavContainer';\nimport RelationForm from '../../components/RelationForm';\nimport HeaderNavLink from '../../components/HeaderNavLink';\nimport WrapperSelect from '../../components/WrapperSelect';\nimport getTrad from '../../utils/getTrad';\nimport makeSearch from '../../utils/makeSearch';\nimport getAttributes from './utils/attributes';\nimport forms from './utils/forms';\nimport createHeadersArray from './utils/createHeadersArray';\nimport createHeadersObjectFromArray from './utils/createHeadersObjectFromArray';\nimport { createComponentUid, createUid } from './utils/createUid';\nimport getModalTitleSubHeader from './utils/getModalTitleSubHeader';\nimport getNextSearch from './utils/getNextSearch';\nimport { NAVLINKS, INITIAL_STATE_DATA } from './utils/staticData';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\nimport CustomButton from './CustomButton';\nimport canEditContentType from './utils/canEditContentType';\n\n/* eslint-disable indent */\n/* eslint-disable react/no-array-index-key */\n\nconst FormModal = () => {\n  const [state, setState] = useState(INITIAL_STATE_DATA);\n  const [showConfirmModal, setShowConfirmModal] = useState(false);\n  const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n  const { push } = useHistory();\n  const { search } = useLocation();\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const query = useQuery();\n  const attributeOptionRef = useRef();\n\n  const {\n    addAttribute,\n    addCreatedComponentToDynamicZone,\n    allComponentsCategories,\n    changeDynamicZoneComponents,\n    contentTypes,\n    components,\n    createSchema,\n    deleteCategory,\n    deleteData,\n    editCategory,\n    submitData,\n    modifiedData: allDataSchema,\n    nestedComponents,\n    setModifiedData,\n    sortedContentTypesList,\n    updateSchema,\n    reservedNames,\n  } = useDataManager();\n  const {\n    componentToCreate,\n    formErrors,\n    initialData,\n    isCreatingComponentWhileAddingAField,\n    modifiedData,\n  } = reducerState.toJS();\n\n  useEffect(() => {\n    if (!isEmpty(search)) {\n      const actionType = query.get('actionType');\n      // Returns 'null' if there isn't any attributeType search params\n      const attributeName = query.get('attributeName');\n      const attributeType = query.get('attributeType');\n      const dynamicZoneTarget = query.get('dynamicZoneTarget');\n      const forTarget = query.get('forTarget');\n      const modalType = query.get('modalType');\n      const kind = query.get('kind') || get(allDataSchema, ['contentType', 'schema', 'kind'], null);\n      const targetUid = query.get('targetUid');\n      const settingType = query.get('settingType');\n      const headerId = query.get('headerId');\n      const header_label_1 = query.get('header_label_1');\n      const header_icon_name_1 = query.get('header_icon_name_1');\n      const header_icon_isCustom_1 = query.get('header_icon_isCustom_1');\n      const header_info_category_1 = query.get('header_info_category_1');\n      const header_info_name_1 = query.get('header_info_name_1');\n      const header_label_2 = query.get('header_label_2');\n      const header_icon_name_2 = query.get('header_icon_name_2');\n      const header_icon_isCustom_2 = query.get('header_icon_isCustom_2');\n      const header_info_category_2 = query.get('header_info_category_2');\n      const header_info_name_2 = query.get('header_info_name_2');\n      const header_label_3 = query.get('header_label_3');\n      const header_icon_name_3 = query.get('header_icon_name_3');\n      const header_icon_isCustom_3 = query.get('header_icon_isCustom_3');\n      const header_info_category_3 = query.get('header_info_category_3');\n      const header_info_name_3 = query.get('header_info_name_3');\n      const header_label_4 = query.get('header_label_4');\n      const header_icon_name_4 = query.get('header_icon_name_4');\n      const header_icon_isCustom_4 = query.get('header_icon_isCustom_4');\n      const header_info_category_4 = query.get('header_info_category_4');\n      const header_info_name_4 = query.get('header_info_name_4');\n      const header_label_5 = query.get('header_label_5');\n      const header_icon_name_5 = query.get('header_icon_name_5');\n      const header_icon_isCustom_5 = query.get('header_icon_isCustom_5');\n      const header_info_category_5 = query.get('header_info_category_5');\n      const header_info_name_5 = query.get('header_info_name_5');\n      const step = query.get('step');\n      const pathToSchema =\n        forTarget === 'contentType' || forTarget === 'component'\n          ? [forTarget]\n          : [forTarget, targetUid];\n\n      setState({\n        actionType,\n        attributeName,\n        attributeType,\n        kind,\n        dynamicZoneTarget,\n        forTarget,\n        modalType,\n        pathToSchema,\n        settingType,\n        step,\n        targetUid,\n        header_label_1,\n        header_icon_name_1,\n        header_icon_isCustom_1,\n        header_info_name_1,\n        header_info_category_1,\n        header_label_2,\n        header_icon_name_2,\n        header_icon_isCustom_2,\n        header_info_name_2,\n        header_info_category_2,\n        header_label_3,\n        header_icon_name_3,\n        header_icon_isCustom_3,\n        header_info_name_3,\n        header_info_category_3,\n        header_label_4,\n        header_icon_name_4,\n        header_icon_isCustom_4,\n        header_info_name_4,\n        header_info_category_4,\n        header_label_5,\n        header_icon_name_5,\n        header_icon_isCustom_5,\n        header_info_name_5,\n        header_info_category_5,\n        headerId,\n      });\n\n      const collectionTypesForRelation = sortedContentTypesList.filter(\n        ({ kind }) => kind === 'collectionType'\n      );\n\n      // Reset all the modification when opening the edit category modal\n      if (modalType === 'editCategory') {\n        setModifiedData();\n      }\n\n      if (actionType === 'edit' && modalType === 'attribute' && forTarget === 'contentType') {\n        emitEvent('willEditFieldOfContentType');\n      }\n\n      // Case:\n      // the user opens the modal chooseAttributes\n      // selects dynamic zone => set the field name\n      // then goes to step 1 (the modal is addComponentToDynamicZone) and finally reloads the app.\n      // In this particular if the user tries to add components to the zone it will pop an error since the dz is unknown\n      const shouldCloseModalToPreventErrorWhenCreatingADZ =\n        get(allDataSchema, [...pathToSchema, 'schema', 'attributes', dynamicZoneTarget], null) ===\n          null && modalType === 'addComponentToDynamicZone';\n\n      // Similarly when creating a component on the fly if the user reloads the app\n      // The previous data is lost\n      // Since the modal uses the search it will still be opened\n      const shouldCloseModalChooseAttribute =\n        get(allDataSchema, ['components', targetUid], null) === null &&\n        // modalType === 'chooseAttribute' &&\n        forTarget === 'components';\n\n      if (shouldCloseModalToPreventErrorWhenCreatingADZ || shouldCloseModalChooseAttribute) {\n        push({ search: '' });\n      }\n\n      // Edit category\n      if (modalType === 'editCategory' && actionType === 'edit') {\n        dispatch({\n          type: 'SET_DATA_TO_EDIT',\n          data: {\n            name: query.get('categoryName'),\n          },\n        });\n      }\n\n      // Create content type we need to add the default option draftAndPublish\n      if (\n        modalType === 'contentType' &&\n        state.modalType !== 'contentType' && // Prevent setting the data structure when navigating from one tab to another\n        actionType === 'create'\n      ) {\n        dispatch({\n          type: 'SET_DATA_TO_EDIT',\n          data: {\n            draftAndPublish: true,\n          },\n        });\n      }\n\n      // Edit content type\n      if (\n        modalType === 'contentType' &&\n        state.modalType !== 'contentType' &&\n        actionType === 'edit'\n      ) {\n        const { name, collectionName, draftAndPublish, kind } = get(\n          allDataSchema,\n          [...pathToSchema, 'schema'],\n          {\n            name: null,\n            collectionName: null,\n          }\n        );\n\n        dispatch({\n          type: 'SET_DATA_TO_EDIT',\n          data: {\n            name,\n            collectionName,\n            draftAndPublish,\n            kind,\n          },\n        });\n      }\n\n      // Edit component\n      if (modalType === 'component' && state.modalType !== 'component' && actionType === 'edit') {\n        const data = get(allDataSchema, pathToSchema, {});\n\n        dispatch({\n          type: 'SET_DATA_TO_EDIT',\n          data: {\n            name: data.schema.name,\n            category: data.category,\n            icon: data.schema.icon,\n            collectionName: data.schema.collectionName,\n          },\n        });\n      }\n\n      // Special case for the dynamic zone\n      if (\n        modalType === 'addComponentToDynamicZone' &&\n        state.modalType !== 'addComponentToDynamicZone' &&\n        actionType === 'edit'\n      ) {\n        const attributeToEditNotFormatted = get(\n          allDataSchema,\n          [...pathToSchema, 'schema', 'attributes', dynamicZoneTarget],\n          {}\n        );\n        const attributeToEdit = {\n          ...attributeToEditNotFormatted,\n          // We filter the available components\n          // Because this modal is only used for adding components\n          components: [],\n          name: dynamicZoneTarget,\n          createComponent: false,\n          componentToCreate: { type: 'component' },\n        };\n\n        dispatch({\n          type: 'SET_DYNAMIC_ZONE_DATA_SCHEMA',\n          attributeToEdit,\n        });\n      }\n\n      // Set the predefined data structure to create an attribute\n      if (\n        attributeType &&\n        attributeType !== 'null' &&\n        // This condition is added to prevent the reducer state to be cleared when navigating from the base tab to tha advanced one\n        state.modalType !== 'attribute'\n      ) {\n        const attributeToEditNotFormatted = get(\n          allDataSchema,\n          [...pathToSchema, 'schema', 'attributes', attributeName],\n          {}\n        );\n        const attributeToEdit = {\n          ...attributeToEditNotFormatted,\n          name: attributeName,\n        };\n\n        // We need to set the repeatable key to false when editing a component\n        // The API doesn't send this info\n        if (attributeType === 'component' && actionType === 'edit') {\n          if (!attributeToEdit.repeatable) {\n            set(attributeToEdit, 'repeatable', false);\n          }\n        }\n\n        if (attributeType === 'relation' && !has(attributeToEdit, ['targetAttribute'])) {\n          set(attributeToEdit, ['targetAttribute'], '-');\n        }\n\n        dispatch({\n          type: 'SET_ATTRIBUTE_DATA_SCHEMA',\n          attributeType,\n          nameToSetForRelation: get(collectionTypesForRelation, ['0', 'title'], 'error'),\n          targetUid: get(collectionTypesForRelation, ['0', 'uid'], 'error'),\n          isEditing: actionType === 'edit',\n          modifiedDataToSetForEditing: attributeToEdit,\n          step,\n        });\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [search]);\n\n  const form = get(forms, [state.modalType, 'form', state.settingType], () => ({\n    items: [],\n  }));\n  const headers = createHeadersArray(state);\n\n  const isCreatingContentType = state.modalType === 'contentType';\n  const isCreatingComponent = state.modalType === 'component';\n  const isCreatingAttribute = state.modalType === 'attribute';\n  const isComponentAttribute = state.attributeType === 'component' && isCreatingAttribute;\n\n  const isCreating = state.actionType === 'create';\n  const isCreatingComponentFromAView =\n    get(modifiedData, 'createComponent', false) || isCreatingComponentWhileAddingAField;\n  const isInFirstComponentStep = state.step === '1';\n  const isEditingCategory = state.modalType === 'editCategory';\n  const isOpen = !isEmpty(search);\n  const isPickingAttribute = state.modalType === 'chooseAttribute';\n  const uid = createUid(modifiedData.name || '');\n  const attributes = get(allDataSchema, [...state.pathToSchema, 'schema', 'attributes'], null);\n\n  const checkFormValidity = async () => {\n    let schema;\n    const dataToValidate =\n      isCreatingComponentFromAView && state.step === '1'\n        ? get(modifiedData, 'componentToCreate', {})\n        : modifiedData;\n\n    // Check form validity for content type\n    if (isCreatingContentType) {\n      schema = forms.contentType.schema(\n        Object.keys(contentTypes),\n        state.actionType === 'edit',\n        // currentUID\n        get(allDataSchema, [...state.pathToSchema, 'uid'], null),\n        reservedNames\n      );\n\n      // Check form validity for component\n      // This is happening when the user click on the link from the left menu\n    } else if (isCreatingComponent) {\n      schema = forms.component.schema(\n        Object.keys(components),\n        modifiedData.category || '',\n        reservedNames,\n        state.actionType === 'edit',\n        get(allDataSchema, [...state.pathToSchema, 'uid'], null)\n      );\n\n      // Check for validity for creating a component\n      // This is happening when the user creates a component \"on the fly\"\n      // Since we temporarily store the component info in another object\n      // The data is set in the componentToCreate key\n    } else if (isComponentAttribute && isCreatingComponentFromAView && isInFirstComponentStep) {\n      schema = forms.component.schema(\n        Object.keys(components),\n        get(modifiedData, 'componentToCreate.category', ''),\n        reservedNames\n      );\n\n      // Check form validity for creating a 'common attribute'\n      // We need to make sure that it is independent from the step\n    } else if (isCreatingAttribute && !isInFirstComponentStep) {\n      const type = state.attributeType === 'relation' ? 'relation' : modifiedData.type;\n\n      let alreadyTakenTargetContentTypeAttributes = [];\n\n      if (type === 'relation') {\n        const targetContentTypeUID = get(modifiedData, ['target'], null);\n        const targetContentTypeAttributes = get(\n          contentTypes,\n          [targetContentTypeUID, 'schema', 'attributes'],\n          {}\n        );\n\n        // Create an array with all the targetContentType attributes name\n        // in order to prevent the user from creating a relation with a targetAttribute\n        // that may exist in the other content type\n        alreadyTakenTargetContentTypeAttributes = Object.keys(targetContentTypeAttributes).filter(\n          attrName => {\n            // Keep all the target content type attributes when creating a relation\n            if (state.actionType !== 'edit') {\n              return true;\n            }\n\n            // Remove the already created one when editing\n            return attrName !== initialData.targetAttribute;\n          }\n        );\n      }\n      schema = forms[state.modalType].schema(\n        get(allDataSchema, state.pathToSchema, {}),\n        type,\n        modifiedData,\n        state.actionType === 'edit',\n        state.attributeName,\n        initialData,\n        alreadyTakenTargetContentTypeAttributes,\n        reservedNames\n      );\n    } else if (isEditingCategory) {\n      schema = forms.editCategory.schema(allComponentsCategories, initialData);\n    } else {\n      // The user is either in the addComponentToDynamicZone modal or\n      // in step 1 of the add component (modalType=attribute&attributeType=component) but not creating a component\n\n      // eslint-disable-next-line no-lonely-if\n      if (isInFirstComponentStep && isCreatingComponentFromAView) {\n        schema = forms.component.schema(\n          Object.keys(components),\n          get(modifiedData, 'componentToCreate.category', ''),\n          reservedNames\n        );\n      } else {\n        // The form is valid\n        // The case here is being in the addComponentToDynamicZone modal and not creating a component\n        return;\n      }\n    }\n\n    await schema.validate(dataToValidate, { abortEarly: false });\n  };\n\n  // TODO this should be a util for testing\n  const getButtonSubmitMessage = () => {\n    const { attributeType, modalType } = state;\n    const isCreatingAComponent = get(modifiedData, 'createComponent', false);\n    let tradId;\n\n    switch (modalType) {\n      case 'contentType':\n      case 'component':\n      case 'editCategory':\n        tradId = !isCreating ? getTrad('form.button.finish') : getTrad('form.button.continue');\n        break;\n      case 'addComponentToDynamicZone': {\n        tradId = isCreatingAComponent\n          ? getTrad('form.button.add-first-field-to-created-component')\n          : getTrad('form.button.finish');\n        break;\n      }\n      case 'attribute': {\n        if (attributeType === 'dynamiczone') {\n          tradId = getTrad('form.button.add-components-to-dynamiczone');\n        } else if (attributeType === 'component') {\n          if (isInFirstComponentStep) {\n            tradId = isCreatingAComponent\n              ? getTrad('form.button.configure-component')\n              : getTrad('form.button.select-component');\n          } else {\n            tradId = isCreatingComponentWhileAddingAField\n              ? getTrad('form.button.add-first-field-to-created-component')\n              : getTrad('form.button.add-field');\n          }\n        } else {\n          tradId = getTrad('form.button.add-field');\n        }\n        break;\n      }\n      default:\n        tradId = getTrad('form.button.add-field');\n    }\n\n    return formatMessage({ id: tradId });\n  };\n\n  // TODO remove and use the utils/makeSearch\n  const makeNextSearch = (searchObj, shouldContinue = isCreating) => {\n    if (!shouldContinue) {\n      return '';\n    }\n\n    return Object.keys(searchObj).reduce((acc, current, index) => {\n      if (searchObj[current] !== null) {\n        acc = `${acc}${index === 0 ? '' : '&'}${current}=${searchObj[current]}`;\n      }\n\n      return acc;\n    }, '');\n  };\n\n  const handleClickAddComponentsToDynamicZone = ({\n    target: { name, components, shouldAddComponents },\n  }) => {\n    dispatch({\n      type: 'ADD_COMPONENTS_TO_DYNAMIC_ZONE',\n      name,\n      components,\n      shouldAddComponents,\n    });\n  };\n\n  const handleChangeMediaAllowedTypes = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE_ALLOWED_TYPE',\n      name,\n      value,\n    });\n  };\n\n  const toggleConfirmModal = useCallback(() => setShowConfirmModal(prev => !prev), []);\n\n  const handleChange = useCallback(\n    ({ target: { name, value, type, ...rest } }) => {\n      const namesThatCanResetToNullValue = [\n        'enumName',\n        'max',\n        'min',\n        'maxLength',\n        'minLength',\n        'regex',\n      ];\n\n      // When toggling the draftAndPublish from true to false\n      // We need to display a confirmation box\n      if (name === 'draftAndPublish' && state.actionType === 'edit' && value === false) {\n        toggleConfirmModal();\n\n        return;\n      }\n\n      let val;\n\n      if (['default', ...namesThatCanResetToNullValue].includes(name) && value === '') {\n        val = null;\n      } else if (\n        type === 'radio' &&\n        (name === 'multiple' ||\n          name === 'single' ||\n          name === 'createComponent' ||\n          name === 'repeatable')\n      ) {\n        // eslint-disable-next-line no-unneeded-ternary\n        val = value === 'false' ? false : true;\n\n        // The boolean default accepts 3 different values\n        // This check has been added to allow a reset to null for the bool\n      } else if (type === 'radio' && name === 'default') {\n        if (value === 'false') {\n          val = false;\n        } else if (value === 'true') {\n          val = true;\n        } else {\n          val = null;\n        }\n\n        // We store an array for the enum\n      } else if (name === 'enum') {\n        val = value.split('\\n');\n      } else {\n        val = value;\n      }\n\n      const clonedErrors = Object.assign({}, formErrors);\n\n      // Reset min error when modifying the max\n      if (name === 'max') {\n        delete clonedErrors.min;\n      }\n\n      // Same here\n      if (name === 'maxLength') {\n        delete clonedErrors.minLength;\n      }\n\n      // Since the onBlur is deactivated we remove the errors directly when changing an input\n      delete clonedErrors[name];\n\n      dispatch({\n        type: 'SET_ERRORS',\n        errors: clonedErrors,\n      });\n\n      dispatch({\n        type: 'ON_CHANGE',\n        keys: name.split('.'),\n        value: val,\n        ...rest,\n      });\n    },\n    [formErrors, state.actionType, toggleConfirmModal]\n  );\n\n  const handleConfirmDisableDraftAndPublish = useCallback(() => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: ['draftAndPublish'],\n      value: false,\n    });\n\n    toggleConfirmModal();\n  }, [toggleConfirmModal]);\n\n  const handleSubmit = async (e, shouldContinue = isCreating) => {\n    e.preventDefault();\n\n    try {\n      await checkFormValidity();\n      sendButtonAddMoreFieldEvent(shouldContinue);\n      const targetUid = state.forTarget === 'components' ? state.targetUid : uid;\n      let headerIcon;\n\n      if (state.forTarget === 'contentType') {\n        const currentKind = get(allDataSchema, ['contentType', 'schema', 'kind'], 'contentType');\n\n        headerIcon = state.kind || currentKind;\n      } else if (state.forTarget === 'component') {\n        headerIcon = 'component';\n      } else {\n        headerIcon = get(allDataSchema, ['components', state.targetUid, 'schema', 'icon'], '');\n      }\n\n      // Remove the last header when editing\n      if (state.actionType === 'edit') {\n        headers.pop();\n      }\n\n      const headersObject = createHeadersObjectFromArray(headers);\n      const nextHeaderIndex = headers.length + 1;\n\n      if (isCreatingContentType) {\n        // Create the content type schema\n        if (isCreating) {\n          createSchema({ ...modifiedData, kind: state.kind }, state.modalType, uid);\n        } else {\n          if (canEditContentType(allDataSchema, modifiedData)) {\n            push({ search: '' });\n            submitData(modifiedData);\n          } else {\n            strapi.notification.toggle({\n              type: 'warning',\n              message: { id: 'notification.contentType.relations.conflict' },\n            });\n          }\n\n          return;\n        }\n\n        push({\n          pathname: `/plugins/${pluginId}/content-types/${uid}`,\n          search: makeNextSearch({\n            modalType: 'chooseAttribute',\n            forTarget: state.forTarget,\n            targetUid,\n            header_label_1: modifiedData.name,\n            header_icon_name_1: headerIcon,\n            header_icon_isCustom_1: null,\n          }),\n        });\n      } else if (isCreatingComponent) {\n        if (isCreating) {\n          // Create the component schema\n          const componentUid = createComponentUid(modifiedData.name, modifiedData.category);\n          const { category, ...rest } = modifiedData;\n\n          createSchema(rest, 'component', componentUid, category);\n\n          push({\n            search: makeNextSearch({\n              modalType: 'chooseAttribute',\n              forTarget: state.forTarget,\n              targetUid: componentUid,\n              header_label_1: modifiedData.name,\n              header_icon_name_1: 'contentType',\n              header_icon_isCustom_1: null,\n            }),\n            pathname: `/plugins/${pluginId}/component-categories/${category}/${componentUid}`,\n          });\n        } else {\n          updateSchema(modifiedData, state.modalType, state.targetUid);\n\n          // Close the modal\n          push({ search: '' });\n\n          return;\n        }\n      } else if (isEditingCategory) {\n        if (toLower(initialData.name) === toLower(modifiedData.name)) {\n          // Close the modal\n          push({ search: '' });\n\n          return;\n        }\n\n        editCategory(initialData.name, modifiedData);\n\n        return;\n        // Add/edit a field to a content type\n        // Add/edit a field to a created component (the end modal is not step 2)\n      } else if (isCreatingAttribute && !isCreatingComponentFromAView) {\n        // Normal fields like boolean relations or dynamic zone\n        if (!isComponentAttribute) {\n          addAttribute(\n            modifiedData,\n            state.forTarget,\n            state.targetUid,\n            state.actionType === 'edit',\n            initialData\n          );\n\n          const isDynamicZoneAttribute = state.attributeType === 'dynamiczone';\n          // Adding a component to a dynamiczone is not the same logic as creating a simple field\n          // so the search is different\n\n          const dzSearch = makeNextSearch({\n            modalType: 'addComponentToDynamicZone',\n            forTarget: 'contentType',\n            targetUid: state.targetUid,\n\n            dynamicZoneTarget: modifiedData.name,\n            settingType: 'base',\n            step: '1',\n            actionType: 'create',\n            ...headersObject,\n            header_label_2: modifiedData.name,\n            header_icon_name_2: null,\n            header_icon_isCustom_2: false,\n          });\n          const nextSearch = isDynamicZoneAttribute\n            ? dzSearch\n            : makeNextSearch(\n                {\n                  modalType: 'chooseAttribute',\n                  forTarget: state.forTarget,\n                  targetUid,\n                  ...headersObject,\n                  header_icon_isCustom_1: !['contentType', 'component'].includes(state.forTarget),\n                  header_icon_name_1: headerIcon,\n                },\n                shouldContinue\n              );\n\n          // The user is creating a DZ (he had entered the name of the dz)\n          if (isDynamicZoneAttribute) {\n            // Step 1 of adding a component to a DZ, the user has the option to create a component\n            dispatch({\n              type: 'RESET_PROPS_AND_SET_THE_FORM_FOR_ADDING_A_COMPO_TO_A_DZ',\n            });\n\n            push({ search: isCreating ? nextSearch : '' });\n\n            return;\n          }\n\n          push({ search: nextSearch });\n\n          return;\n\n          // Adding an existing component\n        }\n        // eslint-disable-next-line no-lonely-if\n        if (isInFirstComponentStep) {\n          // Navigate the user to step 2\n          const nextSearchObj = {\n            modalType: 'attribute',\n            actionType: state.actionType,\n            settingType: 'base',\n            forTarget: state.forTarget,\n            targetUid: state.targetUid,\n            attributeType: 'component',\n            step: '2',\n            ...headersObject,\n            header_icon_isCustom_1: !['contentType', 'component'].includes(state.forTarget),\n            header_icon_name_1: headerIcon,\n          };\n\n          push({\n            search: makeNextSearch(nextSearchObj, shouldContinue),\n          });\n\n          // Clear the reducer and prepare the modified data\n          // This way we don't have to add some logic to re-run the useEffect\n          // The first step is either needed to create a component or just to navigate\n          // To the modal for adding a \"common field\"\n          dispatch({\n            type: 'RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO',\n          });\n\n          // We don't want all the props to be reset\n          return;\n\n          // Here we are in step 2\n          // The step 2 is also use to edit an attribute that is a component\n        }\n        addAttribute(\n          modifiedData,\n          state.forTarget,\n          state.targetUid,\n          // This change the dispatched type\n          // either 'EDIT_ATTRIBUTE' or 'ADD_ATTRIBUTE' in the DataManagerProvider\n          state.actionType === 'edit',\n          // This is for the edit part\n          initialData,\n          // Passing true will add the component to the components object\n          // This way we can add fields to the added component (if it wasn't there already)\n          true\n        );\n        const nextSearch = {\n          modalType: 'chooseAttribute',\n          forTarget: state.forTarget,\n          targetUid: state.targetUid,\n          ...headersObject,\n          header_icon_isCustom_1: !['contentType', 'component'].includes(state.forTarget),\n          header_icon_name_1: headerIcon,\n        };\n\n        push({ search: makeSearch(nextSearch, shouldContinue) });\n\n        // We don't need to end the loop here we want the reducer to be reinitialised\n\n        // Logic for creating a component without clicking on the link in\n        // the left menu\n        // We need to separate the logic otherwise the component would be created\n        // even though the user didn't set any field\n        // We need to prevent the component from being created if the user closes the modal at step 2 without any submission\n      } else if (isCreatingAttribute && isCreatingComponentFromAView) {\n        // Step 1\n        if (isInFirstComponentStep) {\n          // Here the search could be refactored since it is the same as the case from above\n          // Navigate the user to step 2\n\n          let searchObj = {\n            modalType: 'attribute',\n            actionType: state.actionType,\n            settingType: 'base',\n            forTarget: state.forTarget,\n            targetUid: state.targetUid,\n            attributeType: 'component',\n            step: '2',\n            ...headersObject,\n            header_icon_isCustom_1: false,\n            header_icon_name_1: 'component',\n          };\n\n          emitEvent('willCreateComponentFromAttributesModal');\n\n          push({\n            search: makeNextSearch(searchObj, shouldContinue),\n          });\n\n          // Here we clear the reducer state but we also keep the created component\n          // If we were to create the component before\n          dispatch({\n            type: 'RESET_PROPS_AND_SAVE_CURRENT_DATA',\n          });\n\n          // Terminate because we don't want the reducer to be entirely reset\n          return;\n\n          // Step 2 of creating a component (which is setting the attribute name in the parent's schema)\n        }\n        // We are destructuring because the modifiedData object doesn't have the appropriate format to create a field\n        const { category, type, ...rest } = componentToCreate;\n        // Create a the component temp UID\n        // This could be refactored but I think it's more understandable to separate the logic\n        const componentUid = createComponentUid(componentToCreate.name, category);\n        // Create the component first and add it to the components data\n        createSchema(\n          // Component data\n          rest,\n          // Type will always be component\n          // It will dispatch the CREATE_COMPONENT_SCHEMA action\n          // So the component will be added in the main components object\n          // This might not be needed if we don't allow navigation between entries while editing\n          type,\n          componentUid,\n          category,\n          // This will add the created component in the datamanager modifiedData components key\n          // Like explained above we will be able to modify the created component structure\n          isCreatingComponentFromAView\n        );\n        // Add the field to the schema\n        addAttribute(modifiedData, state.forTarget, state.targetUid, false);\n\n        dispatch({ type: 'RESET_PROPS' });\n\n        // Open modal attribute for adding attr to component\n\n        const searchToOpenModalAttributeToAddAttributesToAComponent = {\n          modalType: 'chooseAttribute',\n          forTarget: 'components',\n          targetUid: componentUid,\n          ...headersObject,\n          header_icon_isCustom_1: true,\n          header_icon_name_1: componentToCreate.icon,\n          [`header_label_${nextHeaderIndex}`]: modifiedData.name,\n          [`header_icon_name_${nextHeaderIndex}`]: 'component',\n          [`header_icon_isCustom_${nextHeaderIndex}`]: false,\n          [`header_info_category_${nextHeaderIndex}`]: category,\n          [`header_info_name_${nextHeaderIndex}`]: componentToCreate.name,\n        };\n\n        push({\n          search: makeNextSearch(\n            searchToOpenModalAttributeToAddAttributesToAComponent,\n            shouldContinue\n          ),\n        });\n\n        return;\n\n        // The modal is addComponentToDynamicZone\n      } else {\n        // The modal is addComponentToDynamicZone\n        if (isInFirstComponentStep) {\n          if (isCreatingComponentFromAView) {\n            const { category, type, ...rest } = modifiedData.componentToCreate;\n            const componentUid = createComponentUid(modifiedData.componentToCreate.name, category);\n            // Create the component first and add it to the components data\n            createSchema(\n              // Component data\n              rest,\n              // Type will always be component\n              // It will dispatch the CREATE_COMPONENT_SCHEMA action\n              // So the component will be added in the main components object\n              // This might not be needed if we don't allow navigation between entries while editing\n              type,\n              componentUid,\n              category,\n              // This will add the created component in the datamanager modifiedData components key\n              // Like explained above we will be able to modify the created component structure\n              isCreatingComponentFromAView\n            );\n            // Add the created component to the DZ\n            // We don't want to remove the old ones\n            addCreatedComponentToDynamicZone(state.dynamicZoneTarget, [componentUid]);\n\n            // The Dynamic Zone and the component is created created\n            // Open the modal to add fields to the created component\n\n            const searchToOpenAddField = {\n              modalType: 'chooseAttribute',\n              forTarget: 'components',\n              targetUid: componentUid,\n              ...headersObject,\n              header_icon_isCustom_1: true,\n              header_icon_name_1: modifiedData.componentToCreate.icon,\n              [`header_label_${nextHeaderIndex}`]: modifiedData.name,\n              [`header_icon_name_${nextHeaderIndex}`]: 'component',\n              [`header_icon_isCustom_${nextHeaderIndex}`]: false,\n              [`header_info_category_${nextHeaderIndex}`]: category,\n              [`header_info_name_${nextHeaderIndex}`]: modifiedData.componentToCreate.name,\n            };\n\n            push({ search: makeSearch(searchToOpenAddField, true) });\n          } else {\n            // Add the components to the DZ\n            changeDynamicZoneComponents(state.dynamicZoneTarget, modifiedData.components);\n\n            // TODO nav\n            // Search to open modal add fields for the main type (content type)\n            push({ search: '' });\n          }\n        } else {\n          console.error('This case is not handled');\n        }\n\n        return;\n      }\n\n      dispatch({\n        type: 'RESET_PROPS',\n      });\n    } catch (err) {\n      const errors = getYupInnerErrors(err);\n\n      dispatch({\n        type: 'SET_ERRORS',\n        errors,\n      });\n    }\n  };\n  const handleToggle = () => {\n    push({ search: '' });\n  };\n\n  const onClosed = () => {\n    setState(INITIAL_STATE_DATA);\n    dispatch({\n      type: 'RESET_PROPS',\n    });\n  };\n  const onOpened = () => {\n    if (state.modalType === 'chooseAttribute') {\n      attributeOptionRef.current.focus();\n    }\n  };\n\n  const sendAdvancedTabEvent = tab => {\n    if (tab !== 'advanced') {\n      return;\n    }\n\n    if (isCreatingContentType) {\n      emitEvent('didSelectContentTypeSettings');\n\n      return;\n    }\n\n    if (state.forTarget === 'contentType') {\n      emitEvent('didSelectContentTypeFieldSettings');\n    }\n  };\n\n  const sendButtonAddMoreFieldEvent = shouldContinue => {\n    if (\n      state.modalType === 'attribute' &&\n      state.forTarget === 'contentType' &&\n      state.attributeType !== 'dynamiczone' &&\n      shouldContinue\n    ) {\n      emitEvent('willAddMoreFieldToContentType');\n    }\n  };\n\n  const shouldDisableAdvancedTab = () => {\n    return (\n      ((state.attributeType === 'component' || state.modalType === 'addComponentToDynamicZone') &&\n        get(modifiedData, ['createComponent'], null) === false) ||\n      state.modalType === 'editCategory'\n    );\n  };\n\n  // Display data for the attributes picker modal\n  const displayedAttributes = getAttributes(\n    state.forTarget,\n    state.targetUid,\n    // We need the nested components so we know when to remove the component option\n    nestedComponents\n  );\n\n  // Styles\n  const modalBodyStyle = isPickingAttribute ? { paddingTop: '0.5rem', paddingBottom: '3rem' } : {};\n\n  return (\n    <>\n      <Modal\n        isOpen={isOpen}\n        onOpened={onOpened}\n        onClosed={onClosed}\n        onToggle={handleToggle}\n        withoverflow={toString(\n          state.modalType === 'addComponentToDynamicZone' ||\n            (state.modalType === 'attribute' && state.attributeType === 'media')\n        )}\n      >\n        <HeaderModal>\n          <ModalHeader headerId={state.headerId} headers={headers} />\n          <section>\n            <HeaderModalTitle>\n              <FormattedMessage\n                id={getModalTitleSubHeader(state)}\n                values={{\n                  type: upperFirst(\n                    formatMessage({\n                      id: getTrad(`attribute.${state.attributeType}`),\n                    })\n                  ),\n                  name: upperFirst(state.attributeName),\n                  step: state.step,\n                }}\n              >\n                {msg => <span>{upperFirst(msg)}</span>}\n              </FormattedMessage>\n\n              {!isPickingAttribute && (\n                <>\n                  <div className=\"settings-tabs\">\n                    <HeaderModalNavContainer>\n                      {NAVLINKS.map((link, index) => {\n                        return (\n                          <HeaderNavLink\n                            // The advanced tab is disabled when adding an existing component\n                            // step 1\n                            isDisabled={index === 1 && shouldDisableAdvancedTab()}\n                            isActive={state.settingType === link.id}\n                            key={link.id}\n                            {...link}\n                            onClick={() => {\n                              setState(prev => ({\n                                ...prev,\n                                settingType: link.id,\n                              }));\n                              sendAdvancedTabEvent(link.id);\n                              push({ search: getNextSearch(link.id, state) });\n                            }}\n                            nextTab={index === NAVLINKS.length - 1 ? 0 : index + 1}\n                          />\n                        );\n                      })}\n                    </HeaderModalNavContainer>\n                  </div>\n                  <hr />\n                </>\n              )}\n            </HeaderModalTitle>\n          </section>\n        </HeaderModal>\n        <form onSubmit={handleSubmit}>\n          <ModalForm>\n            <ModalBody style={modalBodyStyle}>\n              <div className=\"container-fluid\">\n                {isPickingAttribute\n                  ? displayedAttributes.map((row, i) => {\n                      return (\n                        <div key={i} className=\"row\">\n                          {i === 1 && (\n                            <hr\n                              style={{\n                                width: 'calc(100% - 30px)',\n                                marginBottom: 16,\n                                marginTop: 19,\n                                borderColor: '#F0F3F8',\n                              }}\n                            />\n                          )}\n                          {row.map((attr, index) => {\n                            const tabIndex =\n                              i === 0 ? index : displayedAttributes[0].length + index;\n\n                            return (\n                              <AttributeOption\n                                key={attr}\n                                tabIndex={tabIndex}\n                                isDisplayed\n                                onClick={() => {}}\n                                ref={i === 0 && index === 0 ? attributeOptionRef : null}\n                                type={attr}\n                              />\n                            );\n                          })}\n                        </div>\n                      );\n                    })\n                  : form(\n                      modifiedData,\n                      state.attributeType,\n                      state.step,\n                      state.actionType,\n                      attributes\n                    ).items.map((row, index) => {\n                      return (\n                        <div className=\"row\" key={index}>\n                          {row.map((input, i) => {\n                            // The divider type is used mainly the advanced tab\n                            // It is the one responsible for displaying the settings label\n                            if (input.type === 'divider' || input.type === 'dividerDraftPublish') {\n                              const tradId =\n                                input.type === 'divider'\n                                  ? 'form.attribute.item.settings.name'\n                                  : 'form.contentType.divider.draft-publish';\n\n                              return (\n                                <div className=\"col-12\" key=\"divider\">\n                                  <Padded bottom size=\"smd\">\n                                    <div style={{ paddingTop: 3 }} />\n                                    <Text\n                                      fontSize=\"xs\"\n                                      color=\"grey\"\n                                      fontWeight=\"bold\"\n                                      textTransform=\"uppercase\"\n                                    >\n                                      <FormattedMessage id={getTrad(tradId)}>\n                                        {txt => txt}\n                                      </FormattedMessage>\n                                    </Text>\n                                  </Padded>\n                                </div>\n                              );\n                            }\n\n                            // The spacer type is used mainly to align the icon picker...\n                            if (input.type === 'spacer') {\n                              return <div key=\"spacer\" style={{ height: 8 }} />;\n                            }\n\n                            // The spacer type is used mainly to align the icon picker...\n                            if (input.type === 'spacer-small') {\n                              return <div key={`${index}.${i}`} style={{ height: 4 }} />;\n                            }\n\n                            if (input.type === 'spacer-medium') {\n                              return <div key={`${index}.${i}`} style={{ height: 8 }} />;\n                            }\n\n                            // This type is used in the addComponentToDynamicZone modal when selecting the option add an existing component\n                            // It pushes select the components to the right\n                            if (input.type === 'pushRight') {\n                              return <div key={`${index}.${i}`} className={`col-${input.size}`} />;\n                            }\n\n                            if (input.type === 'relation') {\n                              return (\n                                <RelationForm\n                                  key=\"relation\"\n                                  mainBoxHeader={get(headers, [0, 'label'], '')}\n                                  modifiedData={modifiedData}\n                                  naturePickerType={state.forTarget}\n                                  onChange={handleChange}\n                                  errors={formErrors}\n                                />\n                              );\n                            }\n\n                            // Retrieve the error for a specific input\n                            const errorId = get(\n                              formErrors,\n                              [\n                                ...input.name\n                                  .split('.')\n                                  // The filter here is used when creating a component\n                                  // in the component step 1 modal\n                                  // Since the component info is stored in the\n                                  // componentToCreate object we can access the error\n                                  // By removing the key\n                                  .filter(key => key !== 'componentToCreate'),\n                                'id',\n                              ],\n                              null\n                            );\n\n                            const retrievedValue = get(modifiedData, input.name, '');\n\n                            let value;\n\n                            // Condition for the boolean default value\n                            // The radio input doesn't accept false, true or null as value\n                            // So we pass them as string\n                            // This way the data stays accurate and we don't have to operate\n                            // any data mutation\n                            if (input.name === 'default' && state.attributeType === 'boolean') {\n                              value = toString(retrievedValue);\n                              // Same here for the enum\n                            } else if (input.name === 'enum' && Array.isArray(retrievedValue)) {\n                              value = retrievedValue.join('\\n');\n                            } else if (input.name === 'uid') {\n                              value = input.value;\n                            } else if (input.name === 'allowedTypes' && retrievedValue === '') {\n                              value = null;\n                            } else {\n                              value = retrievedValue;\n                            }\n\n                            // The addon input is not present in @buffetjs so we are using the old lib\n                            // for the moment that's why we don't want them be passed to buffet\n                            // like the other created inputs\n                            if (input.type === 'addon') {\n                              return (\n                                <InputsIndex\n                                  key={input.name}\n                                  {...input}\n                                  type=\"string\"\n                                  onChange={handleChange}\n                                  value={value}\n                                />\n                              );\n                            }\n\n                            return (\n                              <div className={`col-${input.size || 6}`} key={input.name}>\n                                <Inputs\n                                  {...input}\n                                  modifiedData={modifiedData}\n                                  addComponentsToDynamicZone={handleClickAddComponentsToDynamicZone}\n                                  changeMediaAllowedTypes={handleChangeMediaAllowedTypes}\n                                  customInputs={{\n                                    allowedTypesSelect: WrapperSelect,\n                                    componentIconPicker: ComponentIconPicker,\n                                    componentSelect: WrapperSelect,\n                                    creatableSelect: WrapperSelect,\n                                    customCheckboxWithChildren: CustomCheckbox,\n                                    booleanBox: BooleanBox,\n                                  }}\n                                  isCreating={isCreating}\n                                  // Props for the componentSelect\n                                  isCreatingComponentWhileAddingAField={\n                                    isCreatingComponentWhileAddingAField\n                                  }\n                                  // Props for the componentSelect\n                                  // Since the component is created after adding it to a type\n                                  // its name and category can't be retrieved from the data manager\n                                  componentCategoryNeededForAddingAfieldWhileCreatingAComponent={get(\n                                    componentToCreate,\n                                    'category',\n                                    null\n                                  )}\n                                  // Props for the componentSelect same explanation\n                                  componentNameNeededForAddingAfieldWhileCreatingAComponent={get(\n                                    componentToCreate,\n                                    'name',\n                                    null\n                                  )}\n                                  isAddingAComponentToAnotherComponent={\n                                    state.forTarget === 'components' ||\n                                    state.forTarget === 'component'\n                                  }\n                                  value={value}\n                                  error={isEmpty(errorId) ? null : formatMessage({ id: errorId })}\n                                  onChange={handleChange}\n                                  onBlur={() => {}}\n                                  description={\n                                    get(input, 'description.id', null)\n                                      ? formatMessage(input.description)\n                                      : input.description\n                                  }\n                                  placeholder={\n                                    get(input, 'placeholder.id', null)\n                                      ? formatMessage(input.placeholder)\n                                      : input.placeholder\n                                  }\n                                  label={\n                                    get(input, 'label.id', null)\n                                      ? formatMessage(input.label)\n                                      : input.label\n                                  }\n                                />\n                              </div>\n                            );\n                          })}\n                        </div>\n                      );\n                    })}\n              </div>\n            </ModalBody>\n          </ModalForm>\n          {!isPickingAttribute && (\n            <ModalFooter>\n              <section style={{ alignItems: 'center' }}>\n                <Button type=\"button\" color=\"cancel\" onClick={handleToggle}>\n                  {formatMessage({\n                    id: 'app.components.Button.cancel',\n                  })}\n                </Button>\n                <div>\n                  {isCreatingAttribute && !isInFirstComponentStep && (\n                    <Button\n                      type={isCreating ? 'button' : 'submit'}\n                      color=\"success\"\n                      onClick={e => {\n                        handleSubmit(e, false);\n                      }}\n                      style={{ marginRight: '10px' }}\n                    >\n                      {formatMessage({ id: 'form.button.finish' })}\n                    </Button>\n                  )}\n                  {(isCreatingContentType || isCreatingComponent) && !isCreating && (\n                    <Button\n                      type=\"button\"\n                      color=\"delete\"\n                      onClick={e => {\n                        e.preventDefault();\n                        deleteData();\n                      }}\n                      style={{ marginRight: '10px' }}\n                    >\n                      {formatMessage({ id: getTrad('form.button.delete') })}\n                    </Button>\n                  )}\n                  {isEditingCategory && (\n                    <Button\n                      type=\"button\"\n                      color=\"delete\"\n                      onClick={e => {\n                        e.preventDefault();\n\n                        deleteCategory(initialData.name);\n                      }}\n                      style={{ marginRight: '10px' }}\n                    >\n                      {formatMessage({ id: getTrad('form.button.delete') })}\n                    </Button>\n                  )}\n                  {isCreating && state.attributeType === 'dynamiczone' && (\n                    <CustomButton\n                      type={isCreating ? 'submit' : 'button'}\n                      color={\n                        (isCreatingContentType ||\n                          isCreatingComponent ||\n                          isEditingCategory ||\n                          (state.modalType === 'addComponentToDynamicZone' &&\n                            state.step === '1' &&\n                            !isCreatingComponentFromAView)) &&\n                        !isCreating\n                          ? 'success'\n                          : 'primary'\n                      }\n                      onClick={e => handleSubmit(e, true)}\n                      icon={\n                        (isCreatingAttribute &&\n                          !isCreatingComponentFromAView &&\n                          state.step !== '1') ||\n                        (state.modalType === 'addComponentToDynamicZone' &&\n                          isCreatingComponentFromAView) ||\n                        (isCreatingComponentFromAView && state.step === '2')\n                      }\n                    >\n                      {getButtonSubmitMessage()}\n                    </CustomButton>\n                  )}\n                  {state.attributeType !== 'dynamiczone' && (\n                    <CustomButton\n                      type={isCreating ? 'submit' : 'button'}\n                      color={\n                        (isCreatingContentType ||\n                          isCreatingComponent ||\n                          isEditingCategory ||\n                          (state.modalType === 'addComponentToDynamicZone' &&\n                            state.step === '1' &&\n                            !isCreatingComponentFromAView)) &&\n                        !isCreating\n                          ? 'success'\n                          : 'primary'\n                      }\n                      onClick={e => handleSubmit(e, true)}\n                      icon={\n                        (isCreatingAttribute &&\n                          !isCreatingComponentFromAView &&\n                          state.step !== '1') ||\n                        (state.modalType === 'addComponentToDynamicZone' &&\n                          isCreatingComponentFromAView) ||\n                        (isCreatingComponentFromAView && state.step === '2')\n                      }\n                    >\n                      {getButtonSubmitMessage()}\n                    </CustomButton>\n                  )}\n                </div>\n              </section>\n            </ModalFooter>\n          )}\n        </form>\n      </Modal>\n      {/* CONFIRM MODAL FOR DRAFT AND PUBLISH */}\n      <PopUpWarning\n        isOpen={showConfirmModal}\n        onConfirm={handleConfirmDisableDraftAndPublish}\n        toggleModal={toggleConfirmModal}\n        popUpWarningType=\"danger\"\n        content={{\n          message: getTrad('popUpWarning.draft-publish.message'),\n          secondMessage: getTrad('popUpWarning.draft-publish.second-message'),\n          confirm: getTrad('popUpWarning.draft-publish.button.confirm'),\n        }}\n      />\n    </>\n  );\n};\n\nexport default FormModal;\n",
    "packages/strapi-plugin-content-type-builder/admin/src/containers/LeftMenu/index.js": "/**\n *\n * LeftMenu\n *\n */\n\nimport React, { useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { sortBy, camelCase, upperFirst } from 'lodash';\nimport { useHistory } from 'react-router-dom';\nimport { LeftMenuList, useGlobalContext } from 'strapi-helper-plugin';\nimport { Text } from '@buffetjs/core';\nimport pluginId from '../../pluginId';\nimport getTrad from '../../utils/getTrad';\nimport CustomLink from '../../components/CustomLink';\nimport useDataManager from '../../hooks/useDataManager';\nimport makeSearch from '../../utils/makeSearch';\nimport Wrapper from './Wrapper';\n\n/* eslint-disable indent */\n\nconst displayNotificationCTNotSaved = () => {\n  strapi.notification.toggle({\n    type: 'info',\n    message: { id: `${pluginId}.notification.info.creating.notSaved` },\n  });\n};\n\nfunction LeftMenu({ wait }) {\n  const {\n    components,\n    componentsGroupedByCategory,\n    contentTypes,\n    isInDevelopmentMode,\n    sortedContentTypesList,\n  } = useDataManager();\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const { push } = useHistory();\n  const componentsData = sortBy(\n    Object.keys(componentsGroupedByCategory).map(category => ({\n      name: category,\n      title: category,\n      isEditable: isInDevelopmentMode,\n      onClickEdit: (e, data) => {\n        e.stopPropagation();\n\n        const search = makeSearch({\n          actionType: 'edit',\n          modalType: 'editCategory',\n          categoryName: data.name,\n          header_label_1: formatMessage({\n            id: getTrad('modalForm.header.categories'),\n          }),\n          header_icon_name_1: 'component',\n          header_icon_isCustom_1: false,\n          header_info_category_1: null,\n          header_info_name_1: null,\n          header_label_2: data.name,\n          header_icon_name_2: null,\n          header_icon_isCustom_2: false,\n          header_info_category_2: null,\n          header_info_name_2: null,\n\n          settingType: 'base',\n        });\n\n        push({ search });\n      },\n      links: sortBy(\n        componentsGroupedByCategory[category].map(compo => ({\n          name: compo.uid,\n          to: `/plugins/${pluginId}/component-categories/${category}/${compo.uid}`,\n          title: compo.schema.name,\n        })),\n        obj => obj.title\n      ),\n    })),\n    obj => obj.title\n  );\n\n  const canOpenModalCreateCTorComponent = () => {\n    return (\n      !Object.keys(contentTypes).some(ct => contentTypes[ct].isTemporary === true) &&\n      !Object.keys(components).some(component => components[component].isTemporary === true)\n    );\n  };\n\n  const handleClickOpenModal = async (modalType, kind = '') => {\n    const type = kind === 'singleType' ? kind : modalType;\n\n    if (canOpenModalCreateCTorComponent()) {\n      emitEvent(`willCreate${upperFirst(camelCase(type))}`);\n\n      await wait();\n      const search = makeSearch({\n        modalType,\n        kind,\n        actionType: 'create',\n        settingType: 'base',\n        forTarget: modalType,\n        headerId: getTrad(`modalForm.${type}.header-create`),\n        header_icon_isCustom_1: 'false',\n        header_icon_name_1: type,\n        header_label_1: 'null',\n      });\n      push({\n        search,\n      });\n    } else {\n      displayNotificationCTNotSaved();\n    }\n  };\n\n  const displayedContentTypes = useMemo(() => {\n    return sortedContentTypesList\n      .filter(obj => obj.editable)\n      .map(obj => {\n        if (obj.plugin) {\n          return {\n            ...obj,\n            CustomComponent: () => (\n              <p style={{ justifyContent: 'normal' }}>\n                {obj.title}&nbsp;\n                <Text\n                  as=\"span\"\n                  ellipsis\n                  // This is needed here\n                  style={{ fontStyle: 'italic' }}\n                  fontWeight=\"inherit\"\n                  lineHeight=\"inherit\"\n                >\n                  ({formatMessage({ id: getTrad('from') })}: {obj.plugin})&nbsp;\n                </Text>\n              </p>\n            ),\n          };\n        }\n\n        return obj;\n      });\n  }, [sortedContentTypesList, formatMessage]);\n\n  const data = [\n    {\n      name: 'models',\n      title: {\n        id: `${pluginId}.menu.section.models.name.`,\n      },\n      searchable: true,\n      customLink: isInDevelopmentMode\n        ? {\n            Component: CustomLink,\n            componentProps: {\n              id: `${pluginId}.button.model.create`,\n              onClick: () => {\n                handleClickOpenModal('contentType', 'collectionType');\n              },\n            },\n          }\n        : null,\n      links: displayedContentTypes.filter(contentType => contentType.kind === 'collectionType'),\n    },\n    {\n      name: 'singleTypes',\n      title: {\n        id: `${pluginId}.menu.section.single-types.name.`,\n      },\n      searchable: true,\n      customLink: isInDevelopmentMode\n        ? {\n            Component: CustomLink,\n            componentProps: {\n              id: `${pluginId}.button.single-types.create`,\n              onClick: () => {\n                handleClickOpenModal('contentType', 'singleType');\n              },\n            },\n          }\n        : null,\n      links: displayedContentTypes.filter(singleType => singleType.kind === 'singleType'),\n    },\n    {\n      name: 'components',\n      title: {\n        id: `${pluginId}.menu.section.components.name.`,\n      },\n      searchable: true,\n      customLink: isInDevelopmentMode\n        ? {\n            Component: CustomLink,\n            componentProps: {\n              id: `${pluginId}.button.component.create`,\n              onClick: () => {\n                handleClickOpenModal('component');\n              },\n            },\n          }\n        : null,\n      links: componentsData,\n    },\n  ];\n\n  return (\n    <Wrapper className=\"col-md-3\">\n      {data.map(list => {\n        return <LeftMenuList {...list} key={list.name} />;\n      })}\n    </Wrapper>\n  );\n}\n\nLeftMenu.defaultProps = {\n  wait: () => {},\n};\n\nLeftMenu.propTypes = {\n  wait: PropTypes.func,\n};\n\nexport default LeftMenu;\n",
    "packages/strapi-plugin-content-type-builder/controllers/ComponentCategories.js": "'use strict';\n\nconst validateComponentCategory = require('./validation/component-category');\n\nmodule.exports = {\n  async editCategory(ctx) {\n    const { body } = ctx.request;\n\n    try {\n      await validateComponentCategory(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    const { name } = ctx.params;\n\n    strapi.reload.isWatching = false;\n\n    const componentCategoryService =\n      strapi.plugins['content-type-builder'].services.componentcategories;\n\n    const newName = await componentCategoryService.editCategory(name, body);\n\n    setImmediate(() => strapi.reload());\n\n    ctx.send({ name: newName });\n  },\n\n  async deleteCategory(ctx) {\n    const { name } = ctx.params;\n\n    strapi.reload.isWatching = false;\n\n    const componentCategoryService =\n      strapi.plugins['content-type-builder'].services.componentcategories;\n\n    await componentCategoryService.deleteCategory(name);\n\n    setImmediate(() => strapi.reload());\n\n    ctx.send({ name });\n  },\n};\n",
    "packages/strapi-plugin-content-type-builder/controllers/Components.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst {\n  validateComponentInput,\n  validateUpdateComponentInput,\n} = require('./validation/component');\n\n/**\n * Components controller\n */\n\nmodule.exports = {\n  /**\n   * GET /components handler\n   * Returns a list of available components\n   * @param {Object} ctx - koa context\n   */\n  async getComponents(ctx) {\n    const componentService =\n      strapi.plugins['content-type-builder'].services.components;\n\n    const data = Object.keys(strapi.components).map(uid => {\n      return componentService.formatComponent(strapi.components[uid]);\n    });\n\n    ctx.send({ data });\n  },\n\n  /**\n   * GET /components/:uid\n   * Returns a specific component\n   * @param {Object} ctx - koa context\n   */\n  async getComponent(ctx) {\n    const { uid } = ctx.params;\n\n    const component = strapi.components[uid];\n\n    if (!component) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    const componentService =\n      strapi.plugins['content-type-builder'].services.components;\n\n    ctx.send({ data: componentService.formatComponent(component) });\n  },\n\n  /**\n   * POST /components\n   * Creates a component and returns its infos\n   * @param {Object} ctx - koa context\n   */\n  async createComponent(ctx) {\n    const { body } = ctx.request;\n\n    try {\n      await validateComponentInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService =\n        strapi.plugins['content-type-builder'].services.components;\n\n      const component = await componentService.createComponent({\n        component: body.component,\n        components: body.components,\n      });\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } }, 201);\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n\n  /**\n   * PUT /components/:uid\n   * Updates a component and return its infos\n   * @param {Object} ctx - koa context - enhanced koa context\n   */\n  async updateComponent(ctx) {\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    if (!_.has(strapi.components, uid)) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    try {\n      await validateUpdateComponentInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService =\n        strapi.plugins['content-type-builder'].services.components;\n\n      const component = await componentService.editComponent(uid, {\n        component: body.component,\n        components: body.components,\n      });\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n\n  /**\n   * DELETE /components/:uid\n   * Deletes a components and returns its old infos\n   * @param {Object} ctx - koa context\n   */\n  async deleteComponent(ctx) {\n    const { uid } = ctx.params;\n\n    if (!_.has(strapi.components, uid)) {\n      return ctx.send({ error: 'component.notFound' }, 404);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const componentService =\n        strapi.plugins['content-type-builder'].services.components;\n\n      const component = await componentService.deleteComponent(uid);\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n};\n",
    "packages/strapi-plugin-content-type-builder/controllers/ContentTypes.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst {\n  validateContentTypeInput,\n  validateUpdateContentTypeInput,\n  validateKind,\n} = require('./validation/content-type');\n\nmodule.exports = {\n  async getContentTypes(ctx) {\n    const { kind } = ctx.query;\n\n    try {\n      await validateKind(kind);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n\n    const contentTypes = Object.keys(strapi.contentTypes)\n      .filter(uid => !kind || _.get(strapi.contentTypes[uid], 'kind', 'collectionType') === kind)\n      .map(uid => contentTypeService.formatContentType(strapi.contentTypes[uid]));\n\n    ctx.send({\n      data: contentTypes,\n    });\n  },\n\n  getContentType(ctx) {\n    const { uid } = ctx.params;\n\n    const contentType = strapi.contentTypes[uid];\n\n    if (!contentType) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n\n    ctx.send({ data: contentTypeService.formatContentType(contentType) });\n  },\n\n  async createContentType(ctx) {\n    const { body } = ctx.request;\n\n    try {\n      await validateContentTypeInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n\n      const contentType = await contentTypeService.createContentType({\n        contentType: body.contentType,\n        components: body.components,\n      });\n\n      if (_.isEmpty(strapi.api)) {\n        await strapi.telemetry.send('didCreateFirstContentType', { kind: contentType.kind });\n      } else {\n        await strapi.telemetry.send('didCreateContentType', { kind: contentType.kind });\n      }\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: contentType.uid } }, 201);\n    } catch (error) {\n      strapi.log.error(error);\n      await strapi.telemetry.send('didNotCreateContentType', { error: error.message });\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n\n  async updateContentType(ctx) {\n    const { uid } = ctx.params;\n    const { body } = ctx.request;\n\n    if (!_.has(strapi.contentTypes, uid)) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    try {\n      await validateUpdateContentTypeInput(body);\n    } catch (error) {\n      return ctx.send({ error }, 400);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n\n      const component = await contentTypeService.editContentType(uid, {\n        contentType: body.contentType,\n        components: body.components,\n      });\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } }, 201);\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n\n  async deleteContentType(ctx) {\n    const { uid } = ctx.params;\n\n    if (!_.has(strapi.contentTypes, uid)) {\n      return ctx.send({ error: 'contentType.notFound' }, 404);\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n\n      const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n\n      const component = await contentTypeService.deleteContentType(uid);\n\n      setImmediate(() => strapi.reload());\n\n      ctx.send({ data: { uid: component.uid } });\n    } catch (error) {\n      strapi.log.error(error);\n      ctx.send({ error: error.message }, 400);\n    }\n  },\n};\n",
    "packages/strapi-plugin-content-type-builder/controllers/validation/__tests__/content-type.test.js": "'use strict';\n\nconst {\n  validateKind,\n  validateUpdateContentTypeInput,\n  validateContentTypeInput,\n} = require('../content-type');\n\ndescribe('Content type validator', () => {\n  global.strapi = {\n    contentTypes: {},\n    plugins: {\n      'content-type-builder': {\n        services: {\n          builder: {\n            getReservedNames() {\n              return {\n                models: [],\n                attributes: ['thisIsReserved'],\n              };\n            },\n          },\n        },\n      },\n    },\n  };\n\n  describe('validateKind', () => {\n    it('Only allows for single and collection types', async () => {\n      await expect(validateKind('wrong')).rejects.toBeDefined();\n    });\n\n    it('allows singleType and collectionType', async () => {\n      await expect(validateKind('singleType')).resolves.toBe('singleType');\n      await expect(validateKind('collectionType')).resolves.toBe('collectionType');\n    });\n\n    it('allows undefined', async () => {\n      await expect(validateKind()).resolves.toBeUndefined();\n    });\n  });\n\n  describe('Prevents use of reservedNames', () => {\n    test('Throws when reserved names are used', async () => {\n      const data = {\n        contentType: {\n          name: 'test',\n          attributes: {\n            thisIsReserved: {\n              type: 'string',\n              default: '',\n            },\n          },\n        },\n      };\n\n      await validateUpdateContentTypeInput(data).catch(err => {\n        expect(err).toMatchObject({\n          'contentType.attributes.thisIsReserved': [\n            expect.stringMatching('Attribute keys cannot be one of'),\n          ],\n        });\n      });\n    });\n  });\n\n  describe('Prevents use of names without plural form', () => {\n    test('Throws when using name without plural form', async () => {\n      const data = {\n        contentType: {\n          name: 'news',\n          attributes: {\n            title: {\n              type: 'string',\n            },\n          },\n        },\n      };\n\n      await validateContentTypeInput(data).catch(err => {\n        expect(err).toMatchObject({\n          'contentType.name': [expect.stringMatching('cannot be pluralized')],\n        });\n      });\n    });\n  });\n\n  describe('validateUpdateContentTypeInput', () => {\n    test('Deletes empty defaults', async () => {\n      const data = {\n        contentType: {\n          name: 'test',\n          attributes: {\n            slug: {\n              type: 'string',\n              default: '',\n            },\n          },\n        },\n        components: [\n          {\n            uid: 'edit',\n            icon: 'star',\n            name: 'test',\n            category: 'test',\n            attributes: {\n              title: {\n                type: 'string',\n                default: '',\n              },\n            },\n          },\n          {\n            tmpUID: 'random',\n            icon: 'star',\n            name: 'test2',\n            category: 'test',\n            attributes: {\n              title: {\n                type: 'string',\n                default: '',\n              },\n            },\n          },\n        ],\n      };\n\n      await validateUpdateContentTypeInput(data).then(() => {\n        expect(data.contentType.attributes.slug.default).toBeUndefined();\n        expect(data.components[0].attributes.title.default).toBeUndefined();\n        expect(data.components[1].attributes.title.default).toBe('');\n      });\n    });\n\n    test('Deleted UID target fields are removed from input data', async () => {\n      const data = {\n        contentType: {\n          name: 'test',\n          attributes: {\n            slug: {\n              type: 'uid',\n              targetField: 'deletedField',\n            },\n          },\n        },\n      };\n\n      expect.assertions(1);\n\n      await validateUpdateContentTypeInput(data).then(() => {\n        expect(data.contentType.attributes.slug.targetField).toBeUndefined();\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-content-type-builder/services/ComponentCategories.js": "'use strict';\n\nconst { join } = require('path');\n\nconst { nameToSlug } = require('strapi-utils');\nconst createBuilder = require('./schema-builder');\n\n/**\n * Edit a category name and move components to the write folder\n * @param {string} name category name\n * @param {Object} infos new category data\n */\nconst editCategory = async (name, infos) => {\n  const componentsDir = join(strapi.dir, 'components');\n  const newName = nameToSlug(infos.name);\n\n  // don't do anything the name doesn't change\n  if (name === newName) return;\n\n  if (!categoryExists(name)) {\n    throw strapi.errors.notFound('cateogry.notFound');\n  }\n\n  if (categoryExists(newName)) {\n    throw strapi.errors.badRequest('Name already taken');\n  }\n\n  const builder = createBuilder();\n\n  builder.components.forEach(component => {\n    const oldUID = component.uid;\n    const newUID = `${newName}.${component.modelName}`;\n\n    // only edit the components in this specific category\n    if (component.category !== name) return;\n\n    component.setUID(newUID).setDir(join(componentsDir, newName));\n\n    builder.components.forEach(compo => {\n      compo.updateComponent(oldUID, newUID);\n    });\n\n    builder.contentTypes.forEach(ct => {\n      ct.updateComponent(oldUID, newUID);\n    });\n  });\n\n  await builder.writeFiles();\n\n  return newName;\n};\n\n/**\n * Deletes a category and its components\n * @param {string} name category name to delete\n */\nconst deleteCategory = async name => {\n  if (!categoryExists(name)) {\n    throw strapi.errors.notFound('cateogry.notFound');\n  }\n\n  const builder = createBuilder();\n\n  builder.components.forEach(component => {\n    if (component.category === name) {\n      builder.deleteComponent(component.uid);\n    }\n  });\n\n  await builder.writeFiles();\n};\n\n/**\n * Checks if a category exists\n * @param {string} name category name to serach for\n */\nconst categoryExists = name => {\n  const matchingIndex = Object.values(strapi.components).findIndex(\n    component => component.category === name\n  );\n\n  return matchingIndex > -1;\n};\n\nmodule.exports = {\n  editCategory,\n  deleteCategory,\n};\n",
    "packages/strapi-plugin-content-type-builder/services/Components.js": "'use strict';\n\nconst _ = require('lodash');\nconst pluralize = require('pluralize');\n\nconst { formatAttributes, replaceTemporaryUIDs } = require('../utils/attributes');\nconst createBuilder = require('./schema-builder');\n\n/**\n * Formats a component attributes\n * @param {string} uid - string\n * @param {Object} component - strapi component model\n */\nconst formatComponent = component => {\n  const { uid, modelName, connection, collectionName, info, category } = component;\n\n  return {\n    uid,\n    category,\n    apiId: modelName,\n    schema: {\n      icon: _.get(info, 'icon'),\n      name: _.get(info, 'name') || _.upperFirst(pluralize(uid)),\n      description: _.get(info, 'description', ''),\n      connection,\n      collectionName,\n      attributes: formatAttributes(component),\n    },\n  };\n};\n\n/**\n * Creates a component and handle the nested components sent with it\n * @param {Object} params params object\n * @param {Object} params.component Main component to create\n * @param {Array<Object>} params.components List of nested components to created or edit\n */\nconst createComponent = async ({ component, components = [] }) => {\n  const builder = createBuilder();\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const newComponent = builder.createComponent(replaceTmpUIDs(component));\n\n  components.forEach(component => {\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  await builder.writeFiles();\n  return newComponent;\n};\n\n/**\n * Edits a component and handle the nested components sent with it\n * @param {Object} params params object\n * @param {Object} params.component Main component to create\n * @param {Array<Object>} params.components List of nested components to created or edit\n */\nconst editComponent = async (uid, { component, components = [] }) => {\n  const builder = createBuilder();\n\n  const uidMap = builder.createNewComponentUIDMap(components);\n  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);\n\n  const updatedComponent = builder.editComponent({\n    uid,\n    ...replaceTmpUIDs(component),\n  });\n\n  components.forEach(component => {\n    if (!_.has(component, 'uid')) {\n      return builder.createComponent(replaceTmpUIDs(component));\n    }\n\n    return builder.editComponent(replaceTmpUIDs(component));\n  });\n\n  await builder.writeFiles();\n  return updatedComponent;\n};\n\nconst deleteComponent = async uid => {\n  const builder = createBuilder();\n\n  const deletedComponent = builder.deleteComponent(uid);\n\n  await builder.writeFiles();\n  return deletedComponent;\n};\n\nmodule.exports = {\n  createComponent,\n  editComponent,\n  deleteComponent,\n\n  formatComponent,\n};\n",
    "packages/strapi-plugin-content-type-builder/services/api-handler.js": "'use strict';\n\nconst path = require('path');\nconst fse = require('fs-extra');\nconst _ = require('lodash');\n\n/**\n * Deletes the API folder of a contentType\n * @param {string} uid content type uid\n */\nasync function clear(uid) {\n  const { apiName, __filename__ } = strapi.contentTypes[uid];\n\n  const apiFolder = path.join(strapi.dir, 'api', apiName);\n\n  // base name of the model file that will be use as comparator\n  const baseName = path.basename(__filename__, '.settings.json');\n\n  await recursiveRemoveFiles(apiFolder, createDeleteApiFunction(baseName));\n  await deleteBackup(uid);\n}\n\n/**\n * Backups the API folder of a contentType\n * @param {string} uid content type uid\n */\nasync function backup(uid) {\n  const { apiName } = strapi.contentTypes[uid];\n\n  const apiFolder = path.join(strapi.dir, 'api', apiName);\n  const backupFolder = path.join(strapi.dir, 'api', '.backup', apiName);\n\n  // backup the api folder\n  await fse.copy(apiFolder, backupFolder);\n}\n\n/**\n * Deletes an API backup folder\n * @param {string} uid content type uid\n */\nasync function deleteBackup(uid) {\n  const { apiName } = strapi.contentTypes[uid];\n\n  const backupFolder = path.join(strapi.dir, 'api', '.backup');\n  const apiBackupFolder = path.join(strapi.dir, 'api', '.backup', apiName);\n\n  await fse.remove(apiBackupFolder);\n\n  const list = await fse.readdir(backupFolder);\n  if (list.length === 0) {\n    await fse.remove(backupFolder);\n  }\n}\n\n/**\n * Rollbacks the API folder of a contentType\n * @param {string} uid content type uid\n */\nasync function rollback(uid) {\n  const { apiName } = strapi.contentTypes[uid];\n\n  const apiFolder = path.join(strapi.dir, 'api', apiName);\n  const backupFolder = path.join(strapi.dir, 'api', '.backup', apiName);\n\n  const exists = await fse.exists(backupFolder);\n\n  if (!exists) {\n    throw new Error('Cannot rollback api that was not backed up');\n  }\n\n  await fse.remove(apiFolder);\n  await fse.copy(backupFolder, apiFolder);\n  await deleteBackup(uid);\n}\n\n/**\n * Creates a delete function to clear an api folder\n * @param {string} baseName\n */\nconst createDeleteApiFunction = baseName => {\n  const startWithBaseName = startWithName(baseName + '.');\n\n  /**\n   * Delets a file in an api.\n   * Will only update routes.json instead of deleting it if other routes are present\n   * @param {string} filePath file path to delete\n   */\n  return async filePath => {\n    const fileName = path.basename(filePath);\n\n    if (startWithBaseName(fileName)) return fse.remove(filePath);\n\n    if (fileName === 'routes.json') {\n      const { routes } = await fse.readJSON(filePath);\n\n      const routesToKeep = routes.filter(route => !startWithBaseName(route.handler));\n\n      if (routesToKeep.length === 0) {\n        return fse.remove(filePath);\n      }\n\n      await fse.writeJSON(\n        filePath,\n        {\n          routes: routesToKeep,\n        },\n        {\n          spaces: 2,\n        }\n      );\n    }\n  };\n};\n\n/**\n * Returns a function that checks if the passed string starts with the name\n * @param {string} prefix\n * @returns {Function} a comparing function\n */\nconst startWithName = prefix => {\n  /**\n   * Checks if str starts with prefix case insensitive\n   * @param {string} str string to compare\n   */\n  return str => _.startsWith(_.toLower(str), _.toLower(prefix));\n};\n\n/**\n * Deletes a folder recursively using a delete function\n * @param {string} folder folder to delete\n * @param {Function} deleteFn function to call with the file path to delete\n */\nconst recursiveRemoveFiles = async (folder, deleteFn) => {\n  const filesName = await fse.readdir(folder);\n\n  for (const fileName of filesName) {\n    const filePath = path.join(folder, fileName);\n\n    const stat = await fse.stat(filePath);\n\n    if (stat.isDirectory()) {\n      await recursiveRemoveFiles(filePath, deleteFn);\n    } else {\n      await deleteFn(filePath);\n    }\n  }\n\n  const files = await fse.readdir(folder);\n  if (files.length === 0) {\n    await fse.remove(folder);\n  }\n};\n\nmodule.exports = {\n  clear,\n  backup,\n  rollback,\n};\n",
    "packages/strapi-plugin-content-type-builder/services/schema-builder/schema-handler.js": "'use strict';\n\nconst path = require('path');\nconst fse = require('fs-extra');\nconst _ = require('lodash');\nconst { toUID, isConfigurable } = require('../../utils/attributes');\n\nmodule.exports = function createSchemaHandler(infos) {\n  const { category, modelName, plugin, uid, dir, filename, schema } = infos;\n\n  const initialState = {\n    modelName,\n    plugin,\n    category,\n    uid,\n    dir,\n    filename,\n    schema: schema || {\n      info: {},\n      options: {},\n      attributes: {},\n    },\n  };\n\n  const state = _.cloneDeep(initialState);\n\n  // always keep it the same to rollback\n  Object.freeze(initialState.schema);\n\n  let modified = false;\n  let deleted = false;\n\n  return {\n    get modelName() {\n      return initialState.modelName;\n    },\n\n    get plugin() {\n      return initialState.plugin;\n    },\n\n    get category() {\n      return initialState.category;\n    },\n\n    get kind() {\n      return _.get(state.schema, 'kind', 'collectionType');\n    },\n\n    get uid() {\n      return state.uid;\n    },\n\n    get writable() {\n      return _.get(state, 'plugin') !== 'admin';\n    },\n\n    setUID(val) {\n      modified = true;\n\n      state.uid = val;\n      return this;\n    },\n\n    setDir(val) {\n      modified = true;\n\n      state.dir = val;\n      return this;\n    },\n\n    get schema() {\n      return _.cloneDeep(state.schema);\n    },\n\n    setSchema(val) {\n      modified = true;\n\n      state.schema = _.cloneDeep(val);\n      return this;\n    },\n\n    // get a particuar path inside the schema\n    get(path) {\n      return _.get(state.schema, path);\n    },\n\n    // set a particuar path inside the schema\n    set(path, val) {\n      modified = true;\n\n      const value = _.defaultTo(val, _.get(state.schema, path));\n      _.set(state.schema, path, value);\n\n      return this;\n    },\n\n    // delete a particuar path inside the schema\n    unset(path) {\n      modified = true;\n\n      _.unset(state.schema, path);\n\n      return this;\n    },\n\n    delete() {\n      deleted = true;\n      return this;\n    },\n\n    getAttribute(key) {\n      return this.get(['attributes', key]);\n    },\n\n    setAttribute(key, attribute) {\n      return this.set(['attributes', key], attribute);\n    },\n\n    deleteAttribute(key) {\n      return this.unset(['attributes', key]);\n    },\n\n    setAttributes(newAttributes) {\n      // delete old configurable attributes\n      for (let key in this.schema.attributes) {\n        if (isConfigurable(this.schema.attributes[key])) {\n          this.deleteAttribute(key);\n        }\n      }\n\n      // set new Attributes\n      for (let key in newAttributes) {\n        this.setAttribute(key, newAttributes[key]);\n      }\n\n      return this;\n    },\n\n    removeContentType(uid) {\n      const { attributes } = state.schema;\n\n      Object.keys(attributes).forEach(key => {\n        const attr = attributes[key];\n        const target = attr.model || attr.collection;\n        const plugin = attr.plugin;\n\n        const relationUID = toUID(target, plugin);\n\n        if (relationUID === uid) {\n          this.deleteAttribute(key);\n        }\n      });\n\n      return this;\n    },\n\n    // utils\n    removeComponent(uid) {\n      const { attributes } = state.schema;\n\n      Object.keys(attributes).forEach(key => {\n        const attr = attributes[key];\n\n        if (attr.type === 'component' && attr.component === uid) {\n          this.deleteAttribute(key);\n        }\n\n        if (\n          attr.type === 'dynamiczone' &&\n          Array.isArray(attr.components) &&\n          attr.components.includes(uid)\n        ) {\n          const updatedComponentList = attributes[key].components.filter(val => val !== uid);\n          this.set(['attributes', key, 'components'], updatedComponentList);\n        }\n      });\n\n      return this;\n    },\n\n    updateComponent(uid, newUID) {\n      const { attributes } = state.schema;\n\n      Object.keys(attributes).forEach(key => {\n        const attr = attributes[key];\n\n        if (attr.type === 'component' && attr.component === uid) {\n          this.set(['attributes', key, 'component'], newUID);\n        }\n\n        if (\n          attr.type === 'dynamiczone' &&\n          Array.isArray(attr.components) &&\n          attr.components.includes(uid)\n        ) {\n          const updatedComponentList = attr.components.map(val => (val === uid ? newUID : val));\n\n          this.set(['attributes', key, 'components'], updatedComponentList);\n        }\n      });\n\n      return this;\n    },\n\n    // save the schema to disk\n    async flush() {\n      if (!this.writable) {\n        return;\n      }\n\n      const initialPath = path.join(initialState.dir, initialState.filename);\n      const filePath = path.join(state.dir, state.filename);\n\n      if (deleted === true) {\n        await fse.remove(initialPath);\n\n        const list = await fse.readdir(initialState.dir);\n        if (list.length === 0) {\n          await fse.remove(initialState.dir);\n        }\n\n        return;\n      }\n\n      if (modified === true) {\n        await fse.ensureFile(filePath);\n\n        await fse.writeJSON(\n          filePath,\n          {\n            kind: state.schema.kind,\n            connection: state.schema.connection,\n            collectionName: state.schema.collectionName,\n            info: state.schema.info,\n            options: state.schema.options,\n            attributes: state.schema.attributes,\n          },\n          { spaces: 2 }\n        );\n\n        // remove from oldPath\n        if (initialPath !== filePath) {\n          await fse.remove(initialPath);\n\n          const list = await fse.readdir(initialState.dir);\n          if (list.length === 0) {\n            await fse.remove(initialState.dir);\n          }\n        }\n\n        return;\n      }\n\n      return Promise.resolve();\n    },\n\n    // reset the schema to its initial value\n    async rollback() {\n      if (!this.writable) {\n        return;\n      }\n\n      const initialPath = path.join(initialState.dir, initialState.filename);\n      const filePath = path.join(state.dir, state.filename);\n\n      // it was a creation so it needs to be deleted\n      if (!initialState.uid) {\n        await fse.remove(filePath);\n\n        const list = await fse.readdir(state.dir);\n        if (list.length === 0) {\n          await fse.remove(state.dir);\n        }\n        return;\n      }\n\n      if (modified === true || deleted === true) {\n        await fse.ensureFile(initialPath);\n        await fse.writeJSON(initialPath, initialState.schema, { spaces: 2 });\n\n        // remove\n        if (initialPath !== filePath) {\n          await fse.remove(filePath);\n\n          const list = await fse.readdir(state.dir);\n          if (list.length === 0) {\n            await fse.remove(state.dir);\n          }\n        }\n      }\n\n      return Promise.resolve();\n    },\n  };\n};\n",
    "packages/strapi-plugin-content-type-builder/tests/components.test.e2e.js": "'use strict';\n\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\n\nlet strapi;\nlet rq;\n\nconst restart = async () => {\n  await strapi.destroy();\n  strapi = await createStrapiInstance();\n  rq = await createAuthRequest({ strapi });\n};\n\ndescribe('Content Type Builder - Components', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('POST /components', () => {\n    test('Validates input and return 400 in case of invalid input', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/components',\n        body: {\n          component: {},\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        error: {\n          'component.category': ['category.required'],\n          'component.icon': ['icon.required'],\n          'component.attributes': ['attributes.required'],\n          'component.name': ['name.required'],\n        },\n      });\n    });\n\n    test('Creates a component properly', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/components',\n        body: {\n          component: {\n            category: 'default',\n            icon: 'default',\n            name: 'Some Component',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n              pic: {\n                type: 'media',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: 'default.some-component',\n        },\n      });\n\n      await restart();\n    }, 60000);\n\n    test('Errors on already existing components', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/components',\n        body: {\n          component: {\n            category: 'default',\n            icon: 'default',\n            name: 'someComponent',\n            attributes: {},\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        error: 'component.alreadyExists',\n      });\n    });\n  });\n\n  describe('Get /components', () => {\n    test('Returns valid enveloppe', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: expect.any(Array),\n      });\n\n      res.body.data.forEach(el => {\n        expect(el).toMatchObject({\n          uid: expect.any(String),\n          schema: expect.objectContaining({\n            name: expect.any(String),\n            description: expect.any(String),\n            connection: expect.any(String),\n            collectionName: expect.any(String),\n            attributes: expect.objectContaining({}),\n          }),\n        });\n      });\n    });\n  });\n\n  describe('GET /components/:uid', () => {\n    test('Returns 404 on not found', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/nonexistent-component',\n      });\n\n      expect(res.statusCode).toBe(404);\n      expect(res.body).toEqual({\n        error: 'component.notFound',\n      });\n    });\n\n    test('Returns correct format', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/default.some-component',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          uid: 'default.some-component',\n          category: 'default',\n          schema: {\n            icon: 'default',\n            name: 'Some Component',\n            description: '',\n            connection: 'default',\n            collectionName: 'components_default_some_components',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n              pic: {\n                type: 'media',\n                multiple: false,\n                required: false,\n              },\n            },\n          },\n        },\n      });\n    });\n  });\n\n  describe('PUT /components/:uid', () => {\n    test('Throws 404 on updating non existent component', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: '/content-type-builder/components/nonexistent-components',\n      });\n\n      expect(res.statusCode).toBe(404);\n      expect(res.body).toEqual({\n        error: 'component.notFound',\n      });\n    });\n\n    test('Validates input and return 400 in case of invalid input', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: '/content-type-builder/components/default.some-component',\n        body: {\n          component: {\n            attributes: {},\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        error: {\n          'component.category': ['category.required'],\n          'component.icon': ['icon.required'],\n          'component.name': ['name.required'],\n        },\n      });\n    });\n\n    test('Updates a component properly', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: '/content-type-builder/components/default.some-component',\n        body: {\n          component: {\n            category: 'default',\n            icon: 'default',\n            name: 'New Component',\n            attributes: {},\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          uid: 'default.some-component',\n        },\n      });\n\n      await restart();\n\n      const getRes = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/default.some-component',\n      });\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        data: {\n          uid: 'default.some-component',\n          schema: {\n            name: 'New Component',\n          },\n        },\n      });\n    }, 60000);\n  });\n\n  describe('DELETE /components/:uid', () => {\n    test('Throws 404 on non existent component', async () => {\n      const res = await rq({\n        method: 'DELETE',\n        url: '/content-type-builder/components/nonexistent-components',\n      });\n\n      expect(res.statusCode).toBe(404);\n      expect(res.body).toEqual({\n        error: 'component.notFound',\n      });\n    });\n\n    test('Deletes a component correctly', async () => {\n      const res = await rq({\n        method: 'DELETE',\n        url: '/content-type-builder/components/default.some-component',\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          uid: 'default.some-component',\n        },\n      });\n\n      await restart();\n\n      const tryGet = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/default.some-component',\n      });\n\n      expect(tryGet.statusCode).toBe(404);\n      expect(tryGet.body).toEqual({\n        error: 'component.notFound',\n      });\n    }, 60000);\n  });\n});\n",
    "packages/strapi-plugin-content-type-builder/tests/content-types.test.e2e.js": "/**\n * Integration test for the content-type-builder content types management apis\n */\n'use strict';\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\nconst modelsUtils = require('../../../test/helpers/models');\n\nlet strapi;\nlet rq;\n\nconst restart = async () => {\n  await strapi.destroy();\n  strapi = await createStrapiInstance();\n  rq = await createAuthRequest({ strapi });\n};\n\ndescribe('Content Type Builder - Content types', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterEach(async () => {\n    await restart();\n  }, 60000);\n\n  afterAll(async () => {\n    const modelsName = [\n      'test-collection-type',\n      'test-collection',\n      'test-single-type',\n      'ct-with-dp',\n    ];\n\n    await modelsUtils.cleanupModels(modelsName, { strapi });\n    await modelsUtils.deleteContentTypes(modelsName, { strapi });\n\n    await strapi.destroy();\n  }, 60000);\n\n  describe('Collection Types', () => {\n    const testCollectionTypeUID = 'application::test-collection-type.test-collection-type';\n    const ctWithDpUID = 'application::ct-with-dp.ct-with-dp';\n\n    test('Successful creation of a collection type', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            name: 'Test Collection Type',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: testCollectionTypeUID,\n        },\n      });\n    });\n\n    test('Get collection type returns full schema and information', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${testCollectionTypeUID}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchSnapshot();\n    });\n\n    test('Successfull creation of a collection type with draftAndPublish enabled', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            name: 'CT with DP',\n            draftAndPublish: true,\n            attributes: {\n              title: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: ctWithDpUID,\n        },\n      });\n    });\n\n    test('Get collection type returns full schema and informations with draftAndPublish', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${ctWithDpUID}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchSnapshot();\n    });\n  });\n\n  describe('Single Types', () => {\n    const singleTypeUID = 'application::test-single-type.test-single-type';\n\n    test('Successful creation of a single type', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            kind: 'singleType',\n            name: 'Test Single Type',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: singleTypeUID,\n        },\n      });\n    });\n\n    test('Get single type returns full schema and information', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${singleTypeUID}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchSnapshot();\n    });\n\n    test('Fails on invalid relations', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            kind: 'singleType',\n            name: 'test-st',\n            attributes: {\n              relation: {\n                nature: 'oneToOne',\n                target: 'plugins::users-permissions.user',\n                targetAttribute: 'test',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        error: {\n          ['contentType.attributes.relation.nature']: expect.arrayContaining([\n            expect.stringMatching('must be one of the following values: oneWay, manyWay'),\n          ]),\n        },\n      });\n    });\n\n    test('Cannot switch collectionType to singleType when multiple entries in DB', async () => {\n      const createRes = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            kind: 'collectionType',\n            name: 'test-collection',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      });\n\n      expect(createRes.statusCode).toBe(201);\n\n      await restart();\n\n      const { uid } = createRes.body.data;\n\n      // create data\n      for (let i = 0; i < 2; i++) {\n        const res = await rq({\n          method: 'POST',\n          url: `/test-collections`,\n          body: {\n            title: 'Test',\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n      }\n\n      const updateRes = await rq({\n        method: 'PUT',\n        url: `/content-type-builder/content-types/${uid}`,\n        body: {\n          contentType: {\n            kind: 'singleType',\n            name: 'test-collection',\n            attributes: {\n              title: {\n                type: 'string',\n              },\n            },\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(400);\n      expect(updateRes.body.error).toMatch('multiple entries in DB');\n    }, 60000);\n  });\n\n  describe('Private relation field', () => {\n    const singleTypeUID = 'application::test-single-type.test-single-type';\n\n    test('should add a relation field', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: `/content-type-builder/content-types/${singleTypeUID}`,\n        body: {\n          contentType: {\n            kind: 'singleType',\n            name: 'test-collection',\n            attributes: {\n              relation: {\n                private: true,\n                nature: 'oneWay',\n                target: 'plugins::users-permissions.user',\n                targetAttribute: 'test',\n              },\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: singleTypeUID,\n        },\n      });\n    });\n\n    test('should contain a private relation field', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${singleTypeUID}`,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.schema.attributes.relation).toBeDefined();\n      expect(res.body.data.schema.attributes.relation.private).toBeTruthy();\n    });\n  });\n});\n",
    "packages/strapi-plugin-documentation/config/functions/bootstrap.js": "'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst _ = require('lodash');\n\nmodule.exports = async () => {\n  // Check if the plugin users-permissions is installed because the documentation needs it\n  if (Object.keys(strapi.plugins).indexOf('users-permissions') === -1) {\n    throw new Error(\n      'In order to make the documentation plugin works the users-permissions one is required'\n    );\n  }\n\n  const pluginStore = strapi.store({\n    environment: '',\n    type: 'plugin',\n    name: 'documentation',\n  });\n  const restrictedAccess = await pluginStore.get({ key: 'config' });\n\n  if (!restrictedAccess) {\n    pluginStore.set({ key: 'config', value: { restrictedAccess: false } });\n  }\n\n  let shouldUpdateFullDoc = false;\n  const services = strapi.plugins['documentation'].services.documentation;\n  // Generate plugins' documentation\n  const pluginsWithDocumentationNeeded = services.getPluginsWithDocumentationNeeded();\n  pluginsWithDocumentationNeeded.forEach(plugin => {\n    const isDocExisting = services.checkIfPluginDocumentationFolderExists(plugin);\n\n    if (!isDocExisting) {\n      services.createDocumentationDirectory(services.getPluginDocumentationPath(plugin));\n      // create the overrides directory\n      services.createDocumentationDirectory(services.getPluginOverrideDocumentationPath(plugin));\n      services.createPluginDocumentationFile(plugin);\n      shouldUpdateFullDoc = true;\n    } else {\n      const needToUpdatePluginDoc = services.checkIfPluginDocNeedsUpdate(plugin);\n\n      if (needToUpdatePluginDoc) {\n        services.createPluginDocumentationFile(plugin);\n        shouldUpdateFullDoc = true;\n      }\n    }\n  });\n\n  // Retrieve all the apis from the apis directory\n  const apis = services.getApis();\n  // Generate APIS' documentation\n  apis.forEach(api => {\n    const isDocExisting = services.checkIfDocumentationFolderExists(api);\n\n    if (!isDocExisting) {\n      // If the documentation directory doesn't exist create it\n      services.createDocumentationDirectory(services.getDocumentationPath(api));\n      // Create the overrides directory\n      services.createDocumentationDirectory(services.getDocumentationOverridesPath(api));\n      // Create the documentation files per version\n      services.createDocumentationFile(api); // Then create the {api}.json documentation file\n      shouldUpdateFullDoc = true;\n    } else {\n      const needToUpdateAPIDoc = services.checkIfAPIDocNeedsUpdate(api);\n\n      if (needToUpdateAPIDoc) {\n        services.createDocumentationFile(api);\n        shouldUpdateFullDoc = true;\n      }\n    }\n  });\n\n  const fullDoc = services.generateFullDoc();\n  // Verify that the correct documentation folder exists in the documentation plugin\n  const isMergedDocumentationExists = services.checkIfMergedDocumentationFolderExists();\n  const documentationPath = services.getMergedDocumentationPath();\n\n  if (isMergedDocumentationExists) {\n    /**\n     * Retrieve all tags from the documentation and join them\n     * @param {Object} documentation\n     * @returns {String}\n     */\n    const getDocTagsToString = documentation => {\n      return _.get(documentation, 'tags', [])\n        .map(tag => {\n          return tag.name.toLowerCase();\n        })\n        .sort((a, b) => a - b)\n        .join('.');\n    };\n    const oldDoc = require(path.resolve(documentationPath, 'full_documentation.json'));\n    const oldDocTags = getDocTagsToString(oldDoc);\n    const currentDocTags = getDocTagsToString(fullDoc);\n\n    // If the tags are different (an api has been deleted) we need to rebuild the documentation\n    if (oldDocTags !== currentDocTags) {\n      shouldUpdateFullDoc = true;\n    }\n  }\n\n  if (!isMergedDocumentationExists || shouldUpdateFullDoc) {\n    // Create the folder\n    services.createDocumentationDirectory(documentationPath);\n    // Write the file\n    fs.writeFileSync(\n      path.resolve(documentationPath, 'full_documentation.json'),\n      JSON.stringify(fullDoc, null, 2),\n      'utf8'\n    );\n  }\n\n  // Add permissions\n  const actions = [\n    {\n      section: 'plugins',\n      displayName: 'Access the Documentation',\n      uid: 'read',\n      pluginName: 'documentation',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Update and delete',\n      uid: 'settings.update',\n      subCategory: 'settings',\n      pluginName: 'documentation',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Regenerate',\n      uid: 'settings.regenerate',\n      subCategory: 'settings',\n      pluginName: 'documentation',\n    },\n  ];\n\n  const { actionProvider } = strapi.admin.services.permission;\n  actionProvider.register(actions);\n};\n",
    "packages/strapi-plugin-documentation/config/policies/index.js": "'use strict';\n\nmodule.exports = async (ctx, next) => {\n  const pluginStore = strapi.store({\n    environment: '',\n    type: 'plugin',\n    name: 'documentation',\n  });\n  const config = await pluginStore.get({ key: 'config' });\n\n  if (!config.restrictedAccess) {\n    return await next();\n  }\n\n  if (!ctx.session.documentation) {\n    const querystring = ctx.querystring ? `?${ctx.querystring}` : '';\n\n    return ctx.redirect(\n      `${strapi.config.server.url}${strapi.plugins.documentation.config['x-strapi-config'].path}/login${querystring}`\n    );\n  }\n  const isValid = await strapi.plugins['users-permissions'].services.user.validatePassword(\n    ctx.session.documentation,\n    config.password\n  );\n\n  if (!isValid) {\n    ctx.session.documentation = null;\n  }\n\n  // Execute the action.\n  await next();\n};\n",
    "packages/strapi-plugin-documentation/controllers/Documentation.js": "'use strict';\n\n/**\n * Documentation.js controller\n *\n * @description: A set of functions called \"actions\" of the `documentation` plugin.\n */\n\n// Core dependencies.\nconst path = require('path');\n\n// Public dependencies.\nconst fs = require('fs-extra');\nconst cheerio = require('cheerio');\nconst _ = require('lodash');\nconst koaStatic = require('koa-static');\n\nmodule.exports = {\n  getInfos: async ctx => {\n    try {\n      const service = strapi.plugins.documentation.services.documentation;\n      const docVersions = service.retrieveDocumentationVersions();\n      const form = await service.retrieveFrontForm();\n\n      ctx.send({\n        docVersions,\n        currentVersion: service.getDocumentationVersion(),\n        prefix: strapi.plugins.documentation.config['x-strapi-config'].path,\n        form,\n      });\n    } catch (err) {\n      ctx.badRequest(null, err.message);\n    }\n  },\n\n  async index(ctx, next) {\n    try {\n      /**\n       * We don't expose the specs using koa-static or something else due to security reasons.\n       * That's why, we need to read the file localy and send the specs through it when we serve the Swagger UI.\n       */\n      const { major, minor, patch } = ctx.params;\n      const version =\n        major && minor && patch\n          ? `${major}.${minor}.${patch}`\n          : strapi.plugins.documentation.config.info.version;\n      const openAPISpecsPath = path.join(\n        strapi.config.appPath,\n        'extensions',\n        'documentation',\n        'documentation',\n        version,\n        'full_documentation.json'\n      );\n\n      try {\n        const documentation = fs.readFileSync(openAPISpecsPath, 'utf8');\n        const layout = fs.readFileSync(\n          path.resolve(__dirname, '..', 'public', 'index.html'),\n          'utf8'\n        );\n        const filledLayout = _.template(layout)({\n          backendUrl: strapi.config.server.url,\n          spec: JSON.stringify(JSON.parse(documentation)),\n        });\n\n        try {\n          const layoutPath = path.resolve(\n            strapi.config.appPath,\n            'extensions',\n            'documentation',\n            'public',\n            'index.html'\n          );\n          await fs.ensureFile(layoutPath);\n          await fs.writeFile(layoutPath, filledLayout);\n\n          // Serve the file.\n          ctx.url = path.basename(`${ctx.url}/index.html`);\n\n          try {\n            const staticFolder = path.resolve(\n              strapi.config.appPath,\n              'extensions',\n              'documentation',\n              'public'\n            );\n            return await koaStatic(staticFolder)(ctx, next);\n          } catch (e) {\n            strapi.log.error(e);\n          }\n        } catch (e) {\n          strapi.log.error(e);\n        }\n      } catch (e) {\n        strapi.log.error(e);\n      }\n    } catch (e) {\n      strapi.log.error(e);\n    }\n  },\n\n  async loginView(ctx, next) {\n    const { error } = ctx.query;\n\n    try {\n      const layout = fs.readFileSync(path.join(__dirname, '..', 'public', 'login.html'));\n      const filledLayout = _.template(layout)({\n        actionUrl: `${strapi.config.server.url}${strapi.plugins.documentation.config['x-strapi-config'].path}/login`,\n      });\n      const $ = cheerio.load(filledLayout);\n\n      $('.error').text(_.isEmpty(error) ? '' : 'Wrong password...');\n\n      try {\n        const layoutPath = path.resolve(\n          strapi.config.appPath,\n          'extensions',\n          'documentation',\n          'public',\n          'login.html'\n        );\n        await fs.ensureFile(layoutPath);\n        await fs.writeFile(layoutPath, $.html());\n\n        ctx.url = path.basename(`${ctx.url}/login.html`);\n\n        try {\n          const staticFolder = path.resolve(\n            strapi.config.appPath,\n            'extensions',\n            'documentation',\n            'public'\n          );\n          return await koaStatic(staticFolder)(ctx, next);\n        } catch (e) {\n          strapi.log.error(e);\n        }\n      } catch (e) {\n        strapi.log.error(e);\n      }\n    } catch (e) {\n      strapi.log.error(e);\n    }\n  },\n\n  async login(ctx) {\n    const {\n      body: { password },\n    } = ctx.request;\n\n    const { password: storedPassword } = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'documentation',\n        key: 'config',\n      })\n      .get();\n\n    const isValid = await strapi.plugins['users-permissions'].services.user.validatePassword(\n      password,\n      storedPassword\n    );\n    let querystring = '?error=password';\n\n    if (isValid) {\n      ctx.session.documentation = password;\n      querystring = '';\n    }\n\n    ctx.redirect(\n      `${strapi.config.server.url}${strapi.plugins.documentation.config['x-strapi-config'].path}${querystring}`\n    );\n  },\n\n  regenerateDoc: async ctx => {\n    const service = strapi.plugins.documentation.services.documentation;\n    const documentationVersions = service.retrieveDocumentationVersions().map(el => el.version);\n    const {\n      request: {\n        body: { version },\n        admin,\n      },\n    } = ctx;\n\n    if (_.isEmpty(version)) {\n      return ctx.badRequest(\n        null,\n        admin ? 'documentation.error.noVersion' : 'Please provide a version.'\n      );\n    }\n\n    if (!documentationVersions.includes(version)) {\n      return ctx.badRequest(\n        null,\n        admin\n          ? 'documentation.error.regenerateDoc.versionMissing'\n          : 'The version you are trying to generate does not exist.'\n      );\n    }\n\n    try {\n      strapi.reload.isWatching = false;\n      const fullDoc = service.generateFullDoc(version);\n      const documentationPath = service.getMergedDocumentationPath(version);\n      // Write the file\n      fs.writeFileSync(\n        path.resolve(documentationPath, 'full_documentation.json'),\n        JSON.stringify(fullDoc, null, 2),\n        'utf8'\n      );\n      ctx.send({ ok: true });\n    } catch (err) {\n      ctx.badRequest(null, admin ? 'documentation.error.regenerateDoc' : 'An error occured');\n    } finally {\n      strapi.reload.isWatching = true;\n    }\n  },\n\n  deleteDoc: async ctx => {\n    strapi.reload.isWatching = false;\n    const service = strapi.plugins.documentation.services.documentation;\n    const documentationVersions = service.retrieveDocumentationVersions().map(el => el.version);\n    const {\n      request: {\n        params: { version },\n        admin,\n      },\n    } = ctx;\n\n    if (_.isEmpty(version)) {\n      return ctx.badRequest(\n        null,\n        admin ? 'documentation.error.noVersion' : 'Please provide a version.'\n      );\n    }\n\n    if (!documentationVersions.includes(version)) {\n      return ctx.badRequest(\n        null,\n        admin\n          ? 'documentation.error.deleteDoc.versionMissing'\n          : 'The version you are trying to delete does not exist.'\n      );\n    }\n\n    try {\n      await service.deleteDocumentation(version);\n      ctx.send({ ok: true });\n    } catch (err) {\n      ctx.badRequest(null, admin ? 'notification.error' : err.message);\n    } finally {\n      strapi.reload.isWatching = true;\n    }\n  },\n\n  updateSettings: async ctx => {\n    const {\n      admin,\n      body: { restrictedAccess, password },\n    } = ctx.request;\n    const usersPermService = strapi.plugins['users-permissions'].services;\n    const pluginStore = strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'documentation',\n    });\n    const prevConfig = await pluginStore.get({ key: 'config' });\n\n    if (restrictedAccess && _.isEmpty(password)) {\n      return ctx.badRequest(\n        null,\n        admin ? 'users-permissions.Auth.form.error.password.provide' : 'Please provide a password'\n      );\n    }\n\n    const isNewPassword = !_.isEmpty(password) && password !== prevConfig.password;\n\n    if (isNewPassword && usersPermService.user.isHashed(password)) {\n      // Throw an error if the password selected by the user\n      // contains more than two times the symbol '$'.\n      return ctx.badRequest(\n        null,\n        admin\n          ? 'users-permissions.Auth.form.error.password.format'\n          : 'our password cannot contain more than three times the symbol `$`.'\n      );\n    }\n\n    if (isNewPassword) {\n      prevConfig.password = await usersPermService.user.hashPassword({\n        password,\n      });\n    }\n\n    _.set(prevConfig, 'restrictedAccess', restrictedAccess);\n\n    await pluginStore.set({ key: 'config', value: prevConfig });\n\n    return ctx.send({ ok: true });\n  },\n};\n",
    "packages/strapi-plugin-documentation/middlewares/documentation/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst path = require('path');\nconst _ = require('lodash');\nconst swaggerUi = require('swagger-ui-dist');\nconst koaStatic = require('koa-static');\n\n// Variables.\nconst initialRoutes = [];\n\nmodule.exports = strapi => {\n  return {\n    beforeInitialize() {\n      strapi.config.middleware.load.before.push('documentation');\n\n      initialRoutes.push(..._.cloneDeep(strapi.plugins.documentation.config.routes));\n    },\n\n    initialize() {\n      // Find the plugins routes.\n      strapi.plugins.documentation.config.routes = strapi.plugins.documentation.config.routes.map(\n        (route, index) => {\n          if (route.handler === 'Documentation.getInfos') {\n            return route;\n          }\n\n          if (route.handler === 'Documentation.index' || route.path === '/login') {\n            route.config.policies = initialRoutes[index].config.policies;\n          }\n\n          // Set prefix to empty to be able to customise it.\n          if (_.get(strapi.plugins, ['documentation', 'config', 'x-strapi-config', 'path'])) {\n            route.config.prefix = '';\n            route.path = `/${strapi.plugins.documentation.config['x-strapi-config'].path}${route.path}`.replace(\n              '//',\n              '/'\n            );\n          }\n\n          return route;\n        }\n      );\n\n      strapi.router.get('/plugins/documentation/*', async (ctx, next) => {\n        ctx.url = path.basename(ctx.url);\n\n        return await koaStatic(swaggerUi.getAbsoluteFSPath(), {\n          maxage: strapi.config.middleware.settings.public.maxAge,\n          defer: true,\n        })(ctx, next);\n      });\n    },\n  };\n};\n",
    "packages/strapi-plugin-documentation/services/Documentation.js": "'use strict';\n\n/**\n * Documentation.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\nconst fs = require('fs');\nconst path = require('path');\nconst _ = require('lodash');\nconst moment = require('moment');\nconst pathToRegexp = require('path-to-regexp');\nconst defaultSettings = require('../config/settings.json');\nconst defaultComponents = require('./utils/components.json');\nconst form = require('./utils/forms.json');\nconst parametersOptions = require('./utils/parametersOptions.json');\n\n// keys to pick from the extended config\nconst defaultSettingsKeys = Object.keys(defaultSettings);\nconst customIsEqual = (obj1, obj2) => _.isEqualWith(obj1, obj2, customComparator);\n\nconst customComparator = (value1, value2) => {\n  if (_.isArray(value1) && _.isArray(value2)) {\n    if (value1.length !== value2.length) {\n      return false;\n    }\n    return value1.every(el1 => value2.findIndex(el2 => customIsEqual(el1, el2)) >= 0);\n  }\n};\n\nmodule.exports = {\n  areObjectsEquals: function(obj1, obj2) {\n    // stringify to remove nested empty objects\n    return customIsEqual(this.cleanObject(obj1), this.cleanObject(obj2));\n  },\n\n  cleanObject: obj => JSON.parse(JSON.stringify(obj)),\n\n  arrayCustomizer: (objValue, srcValue) => {\n    if (_.isArray(objValue)) return objValue.concat(srcValue);\n  },\n\n  checkIfAPIDocNeedsUpdate: function(apiName) {\n    const prevDocumentation = this.createDocObject(this.retrieveDocumentation(apiName));\n    const currentDocumentation = this.createDocObject(this.createDocumentationFile(apiName, false));\n\n    return !this.areObjectsEquals(prevDocumentation, currentDocumentation);\n  },\n\n  /**\n   * Check if the documentation folder with its related version of an API exists\n   * @param {String} apiName\n   */\n  checkIfDocumentationFolderExists: function(apiName) {\n    try {\n      fs.accessSync(this.getDocumentationPath(apiName));\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n\n  checkIfPluginDocumentationFolderExists: function(pluginName) {\n    try {\n      fs.accessSync(this.getPluginDocumentationPath(pluginName));\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n\n  checkIfPluginDocNeedsUpdate: function(pluginName) {\n    const prevDocumentation = this.createDocObject(this.retrieveDocumentation(pluginName, true));\n    const currentDocumentation = this.createDocObject(\n      this.createPluginDocumentationFile(pluginName, false)\n    );\n\n    return !this.areObjectsEquals(prevDocumentation, currentDocumentation);\n  },\n\n  checkIfApiDefaultDocumentationFileExist: function(apiName, docName) {\n    try {\n      fs.accessSync(this.getAPIOverrideDocumentationPath(apiName, docName));\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n\n  checkIfPluginDefaultDocumentFileExists: function(pluginName, docName) {\n    try {\n      fs.accessSync(this.getPluginOverrideDocumentationPath(pluginName, docName));\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n\n  /**\n   * Check if the documentation folder exists in the documentation plugin\n   * @returns {Boolean}\n   */\n  checkIfMergedDocumentationFolderExists: function() {\n    try {\n      fs.accessSync(this.getMergedDocumentationPath());\n      return true;\n    } catch (err) {\n      return false;\n    }\n  },\n\n  /**\n   * Recursively create missing directories\n   * @param {String} targetDir\n   *\n   */\n  createDocumentationDirectory: function(targetDir) {\n    const sep = path.sep;\n    const initDir = path.isAbsolute(targetDir) ? sep : '';\n    const baseDir = '.';\n\n    return targetDir.split(sep).reduce((parentDir, childDir) => {\n      const curDir = path.resolve(baseDir, parentDir, childDir);\n\n      try {\n        fs.mkdirSync(curDir);\n      } catch (err) {\n        if (err.code === 'EEXIST') {\n          // curDir already exists!\n          return curDir;\n        }\n\n        // To avoid `EISDIR` error on Mac and `EACCES`-->`ENOENT` and `EPERM` on Windows.\n        if (err.code === 'ENOENT') {\n          // Throw the original parentDir error on curDir `ENOENT` failure.\n          throw new Error(\n            `Impossible to create the documentation folder in '${parentDir}', please check the permissions.`\n          );\n        }\n\n        const caughtErr = ['EACCES', 'EPERM', 'EISDIR'].indexOf(err.code) > -1;\n\n        if (!caughtErr || (caughtErr && targetDir === curDir)) {\n          throw err; // Throw if it's just the last created dir.\n        }\n      }\n\n      return curDir;\n    }, initDir);\n  },\n\n  /**\n   * Create the apiName.json and unclassified.json files inside an api's documentation/version folder\n   * @param {String} apiName\n   */\n  createDocumentationFile: function(apiName, writeFile = true) {\n    // Retrieve all the routes from an API\n    const apiRoutes = this.getApiRoutes(apiName);\n    const apiDocumentation = this.generateApiDocumentation(apiName, apiRoutes);\n\n    return Object.keys(apiDocumentation).reduce((acc, docName) => {\n      const targetFile = path.resolve(this.getDocumentationPath(apiName), `${docName}.json`);\n      // Create the components object in each documentation file when we can create it\n      const components =\n        strapi.models[docName] !== undefined ? this.generateResponseComponent(docName) : {};\n      const tags = docName.split('-').length > 1 ? [] : this.generateTags(apiName, docName);\n      const documentation = Object.assign(apiDocumentation[docName], components, { tags });\n\n      try {\n        if (writeFile) {\n          return fs.writeFileSync(targetFile, JSON.stringify(documentation, null, 2), 'utf8');\n        } else {\n          return acc.concat(documentation);\n        }\n      } catch (err) {\n        return acc;\n      }\n    }, []);\n  },\n\n  createPluginDocumentationFile: function(pluginName, writeFile = true) {\n    const pluginRoutes = this.getPluginRoutesWithDescription(pluginName);\n    const pluginDocumentation = this.generatePluginDocumentation(pluginName, pluginRoutes);\n\n    return Object.keys(pluginDocumentation).reduce((acc, docName) => {\n      const targetFile = path.resolve(\n        this.getPluginDocumentationPath(pluginName),\n        `${docName}.json`\n      );\n      const components =\n        _.get(strapi, this.getModelForPlugin(docName, pluginName)) !== undefined &&\n        pluginName !== 'upload'\n          ? this.generateResponseComponent(docName, pluginName, true)\n          : {};\n      const [plugin, name] = this.getModelAndNameForPlugin(docName, pluginName);\n      const tags =\n        docName !== 'unclassified'\n          ? this.generateTags(plugin, docName, _.upperFirst(this.formatTag(plugin, name)), true)\n          : [];\n      const documentation = Object.assign(pluginDocumentation[docName], components, { tags });\n\n      try {\n        if (writeFile) {\n          return fs.writeFileSync(targetFile, JSON.stringify(documentation, null, 2), 'utf8');\n        } else {\n          return acc.concat(documentation);\n        }\n      } catch (err) {\n        // Silent\n      }\n    }, []);\n  },\n\n  createDocObject: function(array) {\n    // use custom merge for arrays\n    return array.reduce((acc, curr) => _.mergeWith(acc, curr, this.arrayCustomizer), {});\n  },\n\n  deleteDocumentation: async function(version = this.getDocumentationVersion()) {\n    const recursiveDeleteFiles = async (folderPath, removeCompleteFolder = true) => {\n      // Check if folderExist\n      try {\n        const arrayOfPromises = [];\n        fs.accessSync(folderPath);\n        const items = fs.readdirSync(folderPath).filter(x => x[0] !== '.');\n\n        items.forEach(item => {\n          const itemPath = path.join(folderPath, item);\n\n          // Check if directory\n          if (fs.lstatSync(itemPath).isDirectory()) {\n            if (removeCompleteFolder) {\n              return arrayOfPromises.push(recursiveDeleteFiles(itemPath), removeCompleteFolder);\n            } else if (!itemPath.includes('overrides')) {\n              return arrayOfPromises.push(recursiveDeleteFiles(itemPath), removeCompleteFolder);\n            }\n          } else {\n            // Delete all files\n            try {\n              fs.unlinkSync(itemPath);\n            } catch (err) {\n              console.log('Cannot delete file', err);\n            }\n          }\n        });\n\n        await Promise.all(arrayOfPromises);\n\n        try {\n          if (removeCompleteFolder) {\n            fs.rmdirSync(folderPath);\n          }\n        } catch (err) {\n          // console.log(err);\n        }\n      } catch (err) {\n        // console.log('The folder does not exist');\n      }\n    };\n\n    const arrayOfPromises = [];\n\n    // Delete api's documentation\n    const apis = this.getApis();\n    const plugins = this.getPluginsWithDocumentationNeeded();\n\n    apis.forEach(api => {\n      const apiPath = path.join(strapi.config.appPath, 'api', api, 'documentation', version);\n      arrayOfPromises.push(recursiveDeleteFiles(apiPath));\n    });\n\n    plugins.forEach(plugin => {\n      const pluginPath = path.join(\n        strapi.config.appPath,\n        'extensions',\n        plugin,\n        'documentation',\n        version\n      );\n\n      if (version !== '1.0.0') {\n        arrayOfPromises.push(recursiveDeleteFiles(pluginPath));\n      } else {\n        arrayOfPromises.push(recursiveDeleteFiles(pluginPath, false));\n      }\n    });\n\n    const fullDocPath = path.join(\n      strapi.config.appPath,\n      'extensions',\n      'documentation',\n      'documentation',\n      version\n    );\n    arrayOfPromises.push(recursiveDeleteFiles(fullDocPath));\n\n    return await Promise.all(arrayOfPromises);\n  },\n\n  /**\n   *\n   * Wrap endpoints variables in curly braces\n   * @param {String} endPoint\n   * @returns {String} (/products/{id})\n   */\n  formatApiEndPoint: endPoint => {\n    return pathToRegexp\n      .parse(endPoint)\n      .map(token => {\n        if (_.isObject(token)) {\n          return token.prefix + '{' + token.name + '}'; // eslint-disable-line prefer-template\n        }\n\n        return token;\n      })\n      .join('');\n  },\n\n  /**\n   * Format a plugin model for example users-permissions, user => Users-Permissions - User\n   * @param {Sting} plugin\n   * @param {String} name\n   * @param {Boolean} withoutSpace\n   * @return {String}\n   */\n  formatTag: (plugin, name, withoutSpace = false) => {\n    const formattedPluginName = plugin\n      .split('-')\n      .map(i => _.upperFirst(i))\n      .join('');\n    const formattedName = _.upperFirst(name);\n\n    if (withoutSpace) {\n      return `${formattedPluginName}${formattedName}`;\n    }\n\n    return `${formattedPluginName} - ${formattedName}`;\n  },\n\n  generateAssociationSchema: function(attributes, getter) {\n    return Object.keys(attributes).reduce(\n      (acc, curr) => {\n        const attribute = attributes[curr];\n        const isField = !_.has(attribute, 'model') && !_.has(attribute, 'collection');\n\n        if (attribute.required) {\n          acc.required.push(curr);\n        }\n\n        if (isField) {\n          acc.properties[curr] = { type: this.getType(attribute.type) };\n        } else {\n          const newGetter = getter.slice();\n          newGetter.splice(newGetter.length - 1, 1, 'associations');\n          const relationNature = _.get(strapi, newGetter).filter(\n            association => association.alias === curr\n          )[0].nature;\n\n          switch (relationNature) {\n            case 'manyToMany':\n            case 'oneToMany':\n            case 'manyToManyMorph':\n              acc.properties[curr] = {\n                type: 'array',\n                items: { type: 'string' },\n              };\n              break;\n            default:\n              acc.properties[curr] = { type: 'string' };\n          }\n        }\n\n        return acc;\n      },\n      { required: ['id'], properties: { id: { type: 'string' } } }\n    );\n  },\n\n  /**\n   * Creates the paths object with all the needed information\n   * The object has the following structure { apiName: { paths: {} }, knownTag1: { paths: {} }, unclassified: { paths: {} } }\n   * Each key will create a documentation.json file\n   *\n   * @param {String} apiName\n   * @param {Array} routes\n   * @returns {Object}\n   */\n  generateApiDocumentation: function(apiName, routes) {\n    return routes.reduce((acc, current) => {\n      const [controllerName, controllerMethod] = current.handler.split('.');\n      // Retrieve the tag key in the config object\n      const routeTagConfig = _.get(current, ['config', 'tag']);\n      // Add curly braces between dynamic params\n      const endPoint = this.formatApiEndPoint(current.path);\n      let verb;\n\n      if (Array.isArray(current.method)) {\n        verb = current.method.map(method => method.toLowerCase());\n      } else {\n        verb = current.method.toLowerCase();\n      }\n      // The key corresponds to firsts keys of the returned object\n      let key;\n      let tags;\n\n      if (controllerName.toLowerCase() === apiName && !_.isObject(routeTagConfig)) {\n        key = apiName;\n      } else if (routeTagConfig !== undefined) {\n        if (_.isObject(routeTagConfig)) {\n          const { name, plugin } = routeTagConfig;\n          const referencePlugin = !_.isEmpty(plugin);\n\n          key = referencePlugin ? `${plugin}-${name}` : name.toLowerCase();\n          tags = referencePlugin ? this.formatTag(plugin, name) : _.upperFirst(name);\n        } else {\n          key = routeTagConfig.toLowerCase();\n        }\n      } else {\n        key = 'unclassified';\n      }\n\n      const verbObject = {\n        deprecated: false,\n        description: this.generateVerbDescription(\n          verb,\n          current.handler,\n          key,\n          endPoint.split('/')[1],\n          _.get(current, 'config.description')\n        ),\n        responses: this.generateResponses(verb, current, key),\n        summary: '',\n        tags: _.isEmpty(tags) ? [_.upperFirst(key)] : [_.upperFirst(tags)],\n      };\n\n      // Swagger is not support key with ',' symbol, for array of methods need generate documentation for each method\n      if (Array.isArray(verb)) {\n        verb.forEach(method => {\n          _.set(acc, [key, 'paths', endPoint, method], verbObject);\n        });\n      } else {\n        _.set(acc, [key, 'paths', endPoint, verb], verbObject);\n      }\n\n      if (verb.includes('post') || verb.includes('put')) {\n        let requestBody;\n\n        if (controllerMethod === 'create' || controllerMethod === 'update') {\n          requestBody = {\n            description: '',\n            required: true,\n            content: {\n              'application/json': {\n                schema: {\n                  $ref: `#/components/schemas/New${_.upperFirst(key)}`,\n                },\n              },\n            },\n          };\n        } else {\n          requestBody = {\n            description: '',\n            required: true,\n            content: {\n              'application/json': {\n                schema: {\n                  properties: {\n                    foo: {\n                      type: 'string',\n                    },\n                  },\n                },\n              },\n            },\n          };\n        }\n\n        if (Array.isArray(verb)) {\n          verb.forEach(method => {\n            _.set(acc, [key, 'paths', endPoint, method, 'requestBody'], requestBody);\n          });\n        } else {\n          _.set(acc, [key, 'paths', endPoint, verb, 'requestBody'], requestBody);\n        }\n      }\n\n      // Refer to https://swagger.io/specification/#pathItemObject\n      const parameters = this.generateVerbParameters(verb, controllerMethod, current.path);\n\n      if (!verb.includes('post')) {\n        if (Array.isArray(verb)) {\n          verb.forEach(method => {\n            _.set(acc, [key, 'paths', endPoint, method, 'parameters'], parameters);\n          });\n        } else {\n          _.set(acc, [key, 'paths', endPoint, verb, 'parameters'], parameters);\n        }\n      }\n\n      return acc;\n    }, {});\n  },\n\n  generateFullDoc: function(version = this.getDocumentationVersion()) {\n    const apisDoc = this.retrieveDocumentationFiles(false, version);\n    const pluginsDoc = this.retrieveDocumentationFiles(true, version);\n    const appDoc = [...apisDoc, ...pluginsDoc];\n    const defaultSettings = _.cloneDeep(\n      _.pick(strapi.plugins.documentation.config, defaultSettingsKeys)\n    );\n    _.set(defaultSettings, ['info', 'x-generation-date'], moment().format('L LTS'));\n    _.set(defaultSettings, ['info', 'version'], version);\n    const tags = appDoc.reduce((acc, current) => {\n      const tags = current.tags.filter(el => {\n        return _.findIndex(acc, ['name', el.name || '']) === -1;\n      });\n\n      return acc.concat(tags);\n    }, []);\n    const fullDoc = _.merge(\n      appDoc.reduce((acc, current) => {\n        return _.merge(acc, current);\n      }, defaultSettings),\n      defaultComponents\n      // { tags },\n    );\n\n    fullDoc.tags = tags;\n\n    return fullDoc;\n  },\n  /**\n   * Generate the main component that has refs to sub components\n   * @param {Object} attributes\n   * @param {Array} associations\n   * @returns {Object}\n   */\n  generateMainComponent: function(attributes, associations) {\n    return Object.keys(attributes).reduce(\n      (acc, current) => {\n        const attribute = attributes[current];\n        // Refer to https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#dataTypes\n        const type = this.getType(attribute.type);\n        const {\n          description,\n          default: defaultValue,\n          minimum,\n          maxmimun,\n          maxLength,\n          minLength,\n          enum: enumeration,\n        } = attribute;\n\n        if (attribute.required === true) {\n          acc.required.push(current);\n        }\n\n        if (attribute.model || attribute.collection) {\n          const currentAssociation = associations.filter(\n            association => association.alias === current\n          )[0];\n          const relationNature = currentAssociation.nature;\n          const name = currentAssociation.model || currentAssociation.collection;\n          const getter =\n            currentAssociation.plugin !== undefined\n              ? currentAssociation.plugin === 'admin'\n                ? ['admin', 'models', name, 'attributes']\n                : ['plugins', currentAssociation.plugin, 'models', name, 'attributes']\n              : ['models', name.toLowerCase(), 'attributes'];\n          const associationAttributes = _.get(strapi, getter);\n          const associationSchema = this.generateAssociationSchema(associationAttributes, getter);\n\n          switch (relationNature) {\n            case 'manyToMany':\n            case 'oneToMany':\n            case 'manyToManyMorph':\n              acc.properties[current] = {\n                type: 'array',\n                items: associationSchema,\n              };\n              break;\n            default:\n              acc.properties[current] = associationSchema;\n          }\n        } else if (type === 'component') {\n          const { repeatable, component, min, max } = attribute;\n\n          const cmp = this.generateMainComponent(\n            strapi.components[component].attributes,\n            strapi.components[component].associations\n          );\n\n          if (repeatable) {\n            acc.properties[current] = {\n              type: 'array',\n              items: {\n                type: 'object',\n                ...cmp,\n              },\n              minItems: min,\n              maxItems: max,\n            };\n          } else {\n            acc.properties[current] = {\n              type: 'object',\n              ...cmp,\n              description,\n            };\n          }\n        } else if (type === 'dynamiczone') {\n          const { components, min, max } = attribute;\n\n          const cmps = components.map(component => {\n            const schema = this.generateMainComponent(\n              strapi.components[component].attributes,\n              strapi.components[component].associations\n            );\n\n            return _.merge(\n              {\n                properties: {\n                  __component: {\n                    type: 'string',\n                    enum: components,\n                  },\n                },\n              },\n              schema\n            );\n          });\n\n          acc.properties[current] = {\n            type: 'array',\n            items: {\n              oneOf: cmps,\n            },\n            minItems: min,\n            maxItems: max,\n          };\n        } else {\n          acc.properties[current] = {\n            type,\n            format: this.getFormat(attribute.type),\n            description,\n            default: defaultValue,\n            minimum,\n            maxmimun,\n            maxLength,\n            minLength,\n            enum: enumeration,\n          };\n        }\n\n        return acc;\n      },\n      { required: ['id'], properties: { id: { type: 'string' } } }\n    );\n  },\n\n  generatePluginDocumentation: function(pluginName, routes) {\n    return routes.reduce((acc, current) => {\n      const {\n        config: { description, prefix },\n      } = current;\n      const endPoint =\n        prefix === undefined\n          ? this.formatApiEndPoint(`/${pluginName}${current.path}`)\n          : this.formatApiEndPoint(`${prefix}${current.path}`);\n      let verb;\n\n      if (Array.isArray(current.method)) {\n        verb = current.method.map(method => method.toLowerCase());\n      } else {\n        verb = current.method.toLowerCase();\n      }\n\n      const actionType = _.get(current, ['config', 'tag', 'actionType'], '');\n      let key;\n      let tags;\n\n      if (_.isObject(current.config.tag)) {\n        const { name, plugin } = current.config.tag;\n        key = plugin ? `${plugin}-${name}` : name;\n        tags = plugin ? [this.formatTag(plugin, name)] : [name];\n      } else {\n        const tag = current.config.tag;\n        key = !_.isEmpty(tag) ? tag : 'unclassified';\n        tags = !_.isEmpty(tag) ? [tag] : ['Unclassified'];\n      }\n\n      const hasDefaultDocumentation = this.checkIfPluginDefaultDocumentFileExists(pluginName, key);\n      const defaultDocumentation = hasDefaultDocumentation\n        ? this.getPluginDefaultVerbDocumentation(pluginName, key, endPoint, verb)\n        : null;\n      const verbObject = {\n        deprecated: false,\n        description,\n        responses: this.generatePluginVerbResponses(current),\n        summary: '',\n        tags,\n      };\n\n      _.set(acc, [key, 'paths', endPoint, verb], verbObject);\n\n      const parameters = this.generateVerbParameters(\n        verb,\n        actionType,\n        `/${pluginName}${current.path}`\n      );\n\n      if (_.isEmpty(defaultDocumentation)) {\n        if (!verb.includes('post')) {\n          if (Array.isArray(verb)) {\n            verb.forEach(method => {\n              _.set(acc, [key, 'paths', endPoint, method, 'parameters'], parameters);\n            });\n          } else {\n            _.set(acc, [key, 'paths', endPoint, verb, 'parameters'], parameters);\n          }\n        }\n\n        if (verb.includes('post') || verb.includes('put')) {\n          let requestBody;\n\n          if (actionType === 'create' || actionType === 'update') {\n            const { name, plugin } = _.isObject(current.config.tag)\n              ? current.config.tag\n              : { tag: current.config.tag };\n            const $ref = plugin\n              ? `#/components/schemas/New${this.formatTag(plugin, name, true)}`\n              : `#/components/schemas/New${_.upperFirst(name)}`;\n            requestBody = {\n              description: '',\n              required: true,\n              content: {\n                'application/json': {\n                  schema: {\n                    $ref,\n                  },\n                },\n              },\n            };\n          } else {\n            requestBody = {\n              description: '',\n              required: true,\n              content: {\n                'application/json': {\n                  schema: {\n                    properties: {\n                      foo: {\n                        type: 'string',\n                      },\n                    },\n                  },\n                },\n              },\n            };\n          }\n\n          if (Array.isArray(verb)) {\n            verb.forEach(method => {\n              _.set(acc, [key, 'paths', endPoint, method, 'requestBody'], requestBody);\n            });\n          } else {\n            _.set(acc, [key, 'paths', endPoint, verb, 'requestBody'], requestBody);\n          }\n        }\n      }\n\n      return acc;\n    }, {});\n  },\n\n  generatePluginResponseSchema: function(tag) {\n    const { actionType, name, plugin } = _.isObject(tag) ? tag : { tag };\n    const getter = plugin ? ['plugins', plugin, 'models', name.toLowerCase()] : ['models', name];\n    const isModelRelated =\n      _.get(strapi, getter) !== undefined &&\n      ['find', 'findOne', 'create', 'search', 'update', 'destroy', 'count'].includes(actionType);\n    const $ref = plugin\n      ? `#/components/schemas/${this.formatTag(plugin, name, true)}`\n      : `#/components/schemas/${_.upperFirst(name)}`;\n\n    if (isModelRelated) {\n      switch (actionType) {\n        case 'find':\n          return {\n            type: 'array',\n            items: {\n              $ref,\n            },\n          };\n        case 'count':\n          return {\n            properties: {\n              count: {\n                type: 'integer',\n              },\n            },\n          };\n        case 'findOne':\n        case 'update':\n        case 'create':\n          return {\n            $ref,\n          };\n        default:\n          return {\n            properties: {\n              foo: {\n                type: 'string',\n              },\n            },\n          };\n      }\n    }\n\n    return {\n      properties: {\n        foo: {\n          type: 'string',\n        },\n      },\n    };\n  },\n\n  generatePluginVerbResponses: function(routeObject) {\n    const {\n      config: { tag },\n    } = routeObject;\n    const actionType = _.get(tag, 'actionType');\n    let schema;\n\n    if (!tag || !actionType) {\n      schema = {\n        properties: {\n          foo: {\n            type: 'string',\n          },\n        },\n      };\n    } else {\n      schema = this.generatePluginResponseSchema(tag);\n    }\n\n    const response = {\n      200: {\n        description: 'response',\n        content: {\n          'application/json': {\n            schema,\n          },\n        },\n      },\n      403: {\n        description: 'Forbidden',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n      404: {\n        description: 'Not found',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n    };\n\n    const { generateDefaultResponse } = strapi.plugins.documentation.config['x-strapi-config'];\n\n    if (generateDefaultResponse) {\n      response.default = {\n        description: 'unexpected error',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      };\n    }\n\n    return response;\n  },\n\n  /**\n   * Create the response object https://swagger.io/specification/#responsesObject\n   * @param {String} verb\n   * @param {Object} routeObject\n   * @param {String} tag\n   * @returns {Object}\n   */\n  generateResponses: function(verb, routeObject, tag) {\n    const endPoint = routeObject.path.split('/')[1];\n    const description = this.generateResponseDescription(verb, tag, endPoint);\n    const schema = this.generateResponseSchema(verb, routeObject, tag, endPoint);\n\n    const response = {\n      200: {\n        description,\n        content: {\n          'application/json': {\n            schema,\n          },\n        },\n      },\n      403: {\n        description: 'Forbidden',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n      404: {\n        description: 'Not found',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      },\n    };\n\n    const { generateDefaultResponse } = strapi.plugins.documentation.config['x-strapi-config'];\n\n    if (generateDefaultResponse) {\n      response.default = {\n        description: 'unexpected error',\n        content: {\n          'application/json': {\n            schema: {\n              $ref: '#/components/schemas/Error',\n            },\n          },\n        },\n      };\n    }\n\n    return response;\n  },\n\n  /**\n   * Retrieve all privates attributes from a model\n   * @param {Object} attributes\n   */\n  getPrivateAttributes: function(attributes) {\n    const privateAttributes = Object.keys(attributes).reduce((acc, current) => {\n      if (attributes[current].private === true) {\n        acc.push(current);\n      }\n      return acc;\n    }, []);\n\n    return privateAttributes;\n  },\n\n  /**\n   * Create a component object with the model's attributes and relations\n   * Refer to https://swagger.io/docs/specification/components/\n   * @param {String} tag\n   * @returns {Object}\n   */\n  generateResponseComponent: function(tag, pluginName = '', isPlugin = false) {\n    // The component's name have to be capitalised\n    const [plugin, name] = isPlugin ? this.getModelAndNameForPlugin(tag, pluginName) : [null, null];\n    const upperFirstTag = isPlugin ? this.formatTag(plugin, name, true) : _.upperFirst(tag);\n    const attributesGetter = isPlugin\n      ? [...this.getModelForPlugin(tag, plugin), 'attributes']\n      : ['models', tag, 'attributes'];\n    const associationGetter = isPlugin\n      ? [...this.getModelForPlugin(tag, plugin), 'associations']\n      : ['models', tag, 'associations'];\n    const attributesObject = _.get(strapi, attributesGetter);\n    const privateAttributes = this.getPrivateAttributes(attributesObject);\n    const modelAssociations = _.get(strapi, associationGetter);\n    const { attributes } = this.getModelAttributes(attributesObject);\n    const associationsWithUpload = modelAssociations\n      .filter(association => {\n        return association.plugin === 'upload';\n      })\n      .map(obj => obj.alias);\n\n    // We always create two nested components from the main one\n    const mainComponent = this.generateMainComponent(attributes, modelAssociations, upperFirstTag);\n\n    // Get Component that doesn't display the privates attributes since a mask is applied\n    // Please refer https://github.com/strapi/strapi/blob/585800b7b98093f596759b296a43f89c491d4f4f/packages/strapi/lib/middlewares/mask/index.js#L92-L100\n    const getComponent = Object.keys(mainComponent.properties).reduce(\n      (acc, current) => {\n        if (privateAttributes.indexOf(current) === -1) {\n          acc.properties[current] = mainComponent.properties[current];\n        }\n        return acc;\n      },\n      { required: mainComponent.required, properties: {} }\n    );\n\n    // Special component only for POST || PUT verbs since the upload is made with a different route\n    const postComponent = Object.keys(mainComponent).reduce((acc, current) => {\n      if (current === 'required') {\n        const required = mainComponent.required.slice().filter(attr => {\n          return associationsWithUpload.indexOf(attr) === -1 && attr !== 'id' && attr !== '_id';\n        });\n\n        if (required.length > 0) {\n          acc.required = required;\n        }\n      }\n\n      if (current === 'properties') {\n        const properties = Object.keys(mainComponent.properties).reduce((acc, current) => {\n          if (\n            associationsWithUpload.indexOf(current) === -1 &&\n            current !== 'id' &&\n            current !== '_id'\n          ) {\n            // The post request shouldn't include nested relations of type 2\n            // For instance if a product has many tags\n            // we expect to find an array of tags objects containing other relations in the get response\n            // and since we use to getComponent to generate this one we need to\n            // remove this object since we only send an array of tag ids.\n            if (_.find(modelAssociations, ['alias', current])) {\n              const isArrayProperty =\n                _.get(mainComponent, ['properties', current, 'type']) !== undefined;\n\n              if (isArrayProperty) {\n                acc[current] = { type: 'array', items: { type: 'string' } };\n              } else {\n                acc[current] = { type: 'string' };\n              }\n            } else {\n              // If the field is not an association we take the one from the component\n              acc[current] = mainComponent.properties[current];\n            }\n          }\n\n          return acc;\n        }, {});\n\n        acc.properties = properties;\n      }\n\n      return acc;\n    }, {});\n\n    return {\n      components: {\n        schemas: {\n          [upperFirstTag]: getComponent,\n          [`New${upperFirstTag}`]: postComponent,\n        },\n      },\n    };\n  },\n\n  /**\n   * Generate a better description for a response when we can guess what's the user is going to retrieve\n   * @param {String} verb\n   * @param {String} tag\n   * @param {String} endPoint\n   * @returns {String}\n   */\n  generateResponseDescription: function(verb, tag, endPoint) {\n    const isModelRelated = strapi.models[tag] !== undefined && tag === endPoint;\n\n    if (Array.isArray(verb)) {\n      verb = verb.map(method => method.toLocaleLowerCase());\n    }\n\n    if (verb.includes('get') || verb.includes('put') || verb.includes('post')) {\n      return isModelRelated ? `Retrieve ${tag} document(s)` : 'response';\n    } else if (verb.includes('delete')) {\n      return isModelRelated\n        ? `deletes a single ${tag} based on the ID supplied`\n        : 'deletes a single record based on the ID supplied';\n    } else {\n      return 'response';\n    }\n  },\n\n  /**\n   * For each response generate its schema\n   * Its schema is either a component when we know what the routes returns otherwise, it returns a dummy schema\n   * that the user will modify later\n   * @param {String} verb\n   * @param {Object} route\n   * @param {String} tag\n   * @param {String} endPoint\n   * @returns {Object}\n   */\n  generateResponseSchema: function(verb, routeObject, tag) {\n    const { handler } = routeObject;\n    let [controller, handlerMethod] = handler.split('.');\n    let upperFirstTag = _.upperFirst(tag);\n\n    if (verb === 'delete') {\n      return {\n        type: 'integer',\n        format: 'int64',\n      };\n    }\n\n    // A tag key might be added to a route to tell if a custom endPoint in an api/<model>/config/routes.json\n    // Retrieves data from another model it is a faster way to generate the response\n    const routeReferenceTag = _.get(routeObject, ['config', 'tag']);\n    let isModelRelated = false;\n    const shouldCheckIfACustomEndPointReferencesAnotherModel =\n      _.isObject(routeReferenceTag) && !_.isEmpty(_.get(routeReferenceTag, 'name'));\n\n    if (shouldCheckIfACustomEndPointReferencesAnotherModel) {\n      const { actionType, name, plugin } = routeReferenceTag;\n      // A model could be in either a plugin or the api folder\n      // The path is different depending on the case\n      const getter = !_.isEmpty(plugin)\n        ? ['plugins', plugin, 'models', name.toLowerCase()]\n        : ['models', name.toLowerCase()];\n\n      // An actionType key might be added to the tag object to guide the algorithm is generating an automatic response\n      const isKnownAction = [\n        'find',\n        'findOne',\n        'create',\n        'search',\n        'update',\n        'destroy',\n        'count',\n      ].includes(actionType);\n\n      // Check if a route points to a model\n      isModelRelated = _.get(strapi, getter) !== undefined && isKnownAction;\n\n      if (isModelRelated && isKnownAction) {\n        // We need to change the handlerMethod name if it is know to generate the good schema\n        handlerMethod = actionType;\n\n        // This is to retrieve the correct component if a custom endpoints references a plugin model\n        if (!_.isEmpty(plugin)) {\n          upperFirstTag = this.formatTag(plugin, name, true);\n        }\n      }\n    } else {\n      // Normal way there's no tag object\n      isModelRelated = strapi.models[tag] !== undefined && tag === _.lowerCase(controller);\n    }\n\n    // We create a component when we are sure that we can 'guess' what's needed to be sent\n    // https://swagger.io/specification/#referenceObject\n    if (isModelRelated) {\n      switch (handlerMethod) {\n        case 'find':\n          return {\n            type: 'array',\n            items: {\n              $ref: `#/components/schemas/${upperFirstTag}`,\n            },\n          };\n        case 'count':\n          return {\n            properties: {\n              count: {\n                type: 'integer',\n              },\n            },\n          };\n        case 'findOne':\n        case 'update':\n        case 'create':\n          return {\n            $ref: `#/components/schemas/${upperFirstTag}`,\n          };\n        default:\n          return {\n            properties: {\n              foo: {\n                type: 'string',\n              },\n            },\n          };\n      }\n    }\n\n    return {\n      properties: {\n        foo: {\n          type: 'string',\n        },\n      },\n    };\n  },\n\n  generateTags: function(name, docName, tag = '', isPlugin = false) {\n    return [\n      {\n        name: isPlugin ? tag : _.upperFirst(docName),\n      },\n    ];\n  },\n\n  /**\n   * Add a default description when it's implied\n   *\n   * @param {String} verb\n   * @param {String} handler\n   * @param {String} tag\n   * @param {String} endPoint\n   * @returns {String}\n   */\n  generateVerbDescription: (verb, handler, tag, endPoint, description) => {\n    const isModelRelated = strapi.models[tag] !== undefined && tag === endPoint;\n\n    if (description) {\n      return description;\n    }\n\n    if (Array.isArray(verb)) {\n      const [, controllerMethod] = handler.split('.');\n\n      if ((verb.includes('get') && verb.includes('post')) || controllerMethod === 'findOrCreate') {\n        return `Find or create ${tag} record`;\n      }\n\n      if (\n        (verb.includes('put') && verb.includes('post')) ||\n        controllerMethod === 'createOrUpdate'\n      ) {\n        return `Create or update ${tag} record`;\n      }\n\n      return '';\n    }\n\n    switch (verb) {\n      case 'get': {\n        const [, controllerMethod] = handler.split('.');\n\n        if (isModelRelated) {\n          switch (controllerMethod) {\n            case 'count':\n              return `Retrieve the numver of ${tag} documents`;\n            case 'findOne':\n              return `Find one ${tag} record`;\n            case 'find':\n              return `Find all the ${tag}'s records`;\n            default:\n              return '';\n          }\n        }\n\n        return '';\n      }\n      case 'delete':\n        return isModelRelated ? `Delete a single ${tag} record` : 'Delete a record';\n      case 'post':\n        return isModelRelated ? `Create a new ${tag} record` : 'Create a new record';\n      case 'put':\n        return isModelRelated ? `Update a single ${tag} record` : 'Update a record';\n      case 'patch':\n        return '';\n      case 'head':\n        return '';\n      default:\n        return '';\n    }\n  },\n\n  /**\n   * Generate the verb parameters object\n   * Refer to https://swagger.io/specification/#pathItemObject\n   * @param {Sting} verb\n   * @param {String} controllerMethod\n   * @param {String} endPoint\n   */\n  generateVerbParameters: function(verb, controllerMethod, endPoint) {\n    const params = pathToRegexp\n      .parse(endPoint)\n      .filter(token => _.isObject(token))\n      .reduce((acc, current) => {\n        const param = {\n          name: current.name,\n          in: 'path',\n          description: '',\n          deprecated: false,\n          required: true,\n          schema: { type: 'string' },\n        };\n\n        return acc.concat(param);\n      }, []);\n\n    if (verb === 'get' && controllerMethod === 'find') {\n      // parametersOptions corresponds to this section\n      // of the documentation https://strapi.io/documentation/guides/filters.html\n      return [...params, ...parametersOptions];\n    }\n\n    return params;\n  },\n\n  /**\n   * Retrieve the apis in /api\n   * @returns {Array}\n   */\n  getApis: () => {\n    return Object.keys(strapi.api || {});\n  },\n\n  getAPIOverrideComponentsDocumentation: function(apiName, docName) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getAPIOverrideDocumentationPath(apiName, docName), 'utf8')\n      );\n\n      return _.get(documentation, 'components', null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getAPIDefaultTagsDocumentation: function(name, docName) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getAPIOverrideDocumentationPath(name, docName), 'utf8')\n      );\n\n      return _.get(documentation, 'tags', null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getAPIDefaultVerbDocumentation: function(apiName, docName, routePath, verb) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getAPIOverrideDocumentationPath(apiName, docName), 'utf8')\n      );\n\n      return _.get(documentation, ['paths', routePath, verb], null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getAPIOverrideDocumentationPath: function(apiName, docName) {\n    return path.join(\n      strapi.config.appPath,\n      'api',\n      apiName,\n      'documentation',\n      'overrides',\n      this.getDocumentationVersion(),\n      `${docName}.json`\n    );\n  },\n\n  /**\n   * Given an api retrieve its endpoints\n   * @param {String}\n   * @returns {Array}\n   */\n  getApiRoutes: apiName => {\n    return _.get(strapi, ['api', apiName, 'config', 'routes'], []);\n  },\n\n  getDocumentationOverridesPath: function(apiName) {\n    return path.join(\n      strapi.config.appPath,\n      'api',\n      apiName,\n      'documentation',\n      this.getDocumentationVersion(),\n      'overrides'\n    );\n  },\n\n  /**\n   * Given an api from /api retrieve its version directory\n   * @param {String} apiName\n   * @returns {Path}\n   */\n  getDocumentationPath: function(apiName) {\n    return path.join(\n      strapi.config.appPath,\n      'api',\n      apiName,\n      'documentation',\n      this.getDocumentationVersion()\n    );\n  },\n\n  getFullDocumentationPath: () => {\n    return path.join(strapi.config.appPath, 'extensions', 'documentation', 'documentation');\n  },\n\n  /**\n   * Retrieve the plugin's configuration version\n   */\n  getDocumentationVersion: () => {\n    const version = strapi.plugins['documentation'].config.info.version;\n\n    return version;\n  },\n\n  /**\n   * Retrieve the documentation plugin documentation directory\n   */\n  getMergedDocumentationPath: function(version = this.getDocumentationVersion()) {\n    return path.join(\n      strapi.config.appPath,\n      'extensions',\n      'documentation',\n      'documentation',\n      version\n    );\n  },\n\n  /**\n   * Retrieve the model's attributes\n   * @param {Objet} modelAttributes\n   * @returns {Object} { associations: [{ name: 'foo', getter: [], tag: 'foos' }], attributes }\n   */\n  getModelAttributes: function(modelAttributes) {\n    const associations = [];\n    const attributes = Object.keys(modelAttributes)\n      .map(attr => {\n        const attribute = modelAttributes[attr];\n        const isField = !_.has(attribute, 'model') && !_.has(attribute, 'collection');\n\n        if (!isField) {\n          const name = attribute.model || attribute.collection;\n          const getter =\n            attribute.plugin !== undefined\n              ? ['plugins', attribute.plugin, 'models', name, 'attributes']\n              : ['models', name, 'attributes'];\n          associations.push({ name, getter, tag: attr });\n        }\n\n        return attr;\n      })\n      .reduce((acc, current) => {\n        acc[current] = modelAttributes[current];\n\n        return acc;\n      }, {});\n\n    return { associations, attributes };\n  },\n\n  /**\n   * Refer to https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#dataTypes\n   * @param {String} type\n   * @returns {String}\n   */\n  getType: type => {\n    switch (type) {\n      case 'string':\n      case 'byte':\n      case 'binary':\n      case 'password':\n      case 'email':\n      case 'text':\n      case 'enumeration':\n      case 'date':\n      case 'datetime':\n      case 'time':\n      case 'richtext':\n        return 'string';\n      case 'float':\n      case 'decimal':\n      case 'double':\n        return 'number';\n      case 'integer':\n      case 'biginteger':\n      case 'long':\n        return 'integer';\n      case 'json':\n        return 'object';\n      default:\n        return type;\n    }\n  },\n\n  /**\n   * Refer to https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#dataTypes\n   * @param {String} type\n   * @returns {String}\n   */\n  getFormat: type => {\n    switch (type) {\n      case 'date':\n        return 'date';\n      case 'datetime':\n        return 'date-time';\n      case 'password':\n        return 'password';\n      default:\n        return undefined;\n    }\n  },\n\n  getPluginDefaultVerbDocumentation: function(pluginName, docName, routePath, verb) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getPluginOverrideDocumentationPath(pluginName, docName), 'utf8')\n      );\n\n      return _.get(documentation, ['paths', routePath, verb], null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getPluginDefaultTagsDocumentation: function(pluginName, docName) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getPluginOverrideDocumentationPath(pluginName, docName), 'utf8')\n      );\n\n      return _.get(documentation, ['tags'], null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getPluginOverrideComponents: function(pluginName, docName) {\n    try {\n      const documentation = JSON.parse(\n        fs.readFileSync(this.getPluginOverrideDocumentationPath(pluginName, docName), 'utf8')\n      );\n\n      return _.get(documentation, 'components', null);\n    } catch (err) {\n      return null;\n    }\n  },\n\n  getPluginOverrideDocumentationPath: function(pluginName, docName) {\n    const defaultPath = path.join(\n      strapi.config.appPath,\n      'extensions',\n      pluginName,\n      'documentation',\n      this.getDocumentationVersion(),\n      'overrides'\n    );\n\n    if (docName) {\n      return path.resolve(defaultPath, `${docName.json}`);\n    } else {\n      return defaultPath;\n    }\n  },\n\n  /**\n   * Given a plugin retrieve its documentation version\n   */\n  getPluginDocumentationPath: function(pluginName) {\n    return path.join(\n      strapi.config.appPath,\n      'extensions',\n      pluginName,\n      'documentation',\n      this.getDocumentationVersion()\n    );\n  },\n\n  /**\n   * Retrieve all plugins that have a description inside one of its route\n   * @return {Arrray}\n   */\n  getPluginsWithDocumentationNeeded: function() {\n    return Object.keys(strapi.plugins).reduce((acc, current) => {\n      const isDocumentationNeeded = this.isPluginDocumentationNeeded(current);\n\n      if (isDocumentationNeeded) {\n        return acc.concat(current);\n      }\n\n      return acc;\n    }, []);\n  },\n\n  /**\n   * Retrieve all the routes that have a description from a plugin\n   * @param {String} pluginName\n   * @returns {Array}\n   */\n  getPluginRoutesWithDescription: function(pluginName) {\n    return _.get(strapi, ['plugins', pluginName, 'config', 'routes'], []).filter(\n      route => _.get(route, ['config', 'description']) !== undefined\n    );\n  },\n\n  /**\n   * Given a string and a pluginName retrieve the model and the pluginName\n   * @param {String} string\n   * @param {Sting} pluginName\n   * @returns {Array}\n   */\n  getModelAndNameForPlugin: (string, pluginName) => {\n    return _.replace(string, `${pluginName}-`, `${pluginName}.`).split('.');\n  },\n\n  /**\n   * Retrieve the path needed to get a model from a plugin\n   * @param (String) string\n   * @param {String} plugin\n   * @returns {Array}\n   */\n  getModelForPlugin: function(string, pluginName) {\n    const [plugin, model] = this.getModelAndNameForPlugin(string, pluginName);\n\n    return ['plugins', plugin, 'models', _.lowerCase(model)];\n  },\n\n  /**\n   * Check whether or not a plugin needs documentation\n   * @param {String} pluginName\n   * @returns {Boolean}\n   */\n  isPluginDocumentationNeeded: function(pluginName) {\n    const { pluginsForWhichToGenerateDoc } = strapi.plugins.documentation.config['x-strapi-config'];\n    if (\n      Array.isArray(pluginsForWhichToGenerateDoc) &&\n      !pluginsForWhichToGenerateDoc.includes(pluginName)\n    ) {\n      return false;\n    } else {\n      return this.getPluginRoutesWithDescription(pluginName).length > 0;\n    }\n  },\n\n  /**\n   * Merge two components by replacing the default ones by the overides and keeping the others\n   * @param {Object} initObj\n   * @param {Object} srcObj\n   * @returns {Object}\n   */\n  mergeComponents: (initObj, srcObj) => {\n    const cleanedObj = Object.keys(_.get(initObj, 'schemas', {})).reduce((acc, current) => {\n      const targetObj = _.has(_.get(srcObj, ['schemas'], {}), current) ? srcObj : initObj;\n\n      _.set(acc, ['schemas', current], _.get(targetObj, ['schemas', current], {}));\n\n      return acc;\n    }, {});\n\n    return _.merge(cleanedObj, srcObj);\n  },\n\n  mergePaths: function(initObj, srcObj) {\n    return Object.keys(initObj.paths).reduce((acc, current) => {\n      if (_.has(_.get(srcObj, ['paths'], {}), current)) {\n        const verbs = Object.keys(initObj.paths[current]).reduce((acc1, curr) => {\n          const verb = this.mergeVerbObject(\n            initObj.paths[current][curr],\n            _.get(srcObj, ['paths', current, curr], {})\n          );\n          _.set(acc1, [curr], verb);\n\n          return acc1;\n        }, {});\n        _.set(acc, ['paths', current], verbs);\n      } else {\n        _.set(acc, ['paths', current], _.get(initObj, ['paths', current], {}));\n      }\n\n      return acc;\n    }, {});\n  },\n\n  mergeTags: (initObj, srcObj) => {\n    return _.get(srcObj, 'tags', _.get(initObj, 'tags', []));\n  },\n\n  /**\n   * Merge two verb objects with a customizer\n   * @param {Object} initObj\n   * @param {Object} srcObj\n   * @returns {Object}\n   */\n  mergeVerbObject: function(initObj, srcObj) {\n    return _.mergeWith(initObj, srcObj, (objValue, srcValue) => {\n      if (_.isPlainObject(objValue)) {\n        return Object.assign(objValue, srcValue);\n      }\n\n      return srcValue;\n    });\n  },\n\n  retrieveDocumentation: function(name, isPlugin = false) {\n    const documentationPath = isPlugin\n      ? [strapi.config.appPath, 'extensions', name, 'documentation', this.getDocumentationVersion()]\n      : [strapi.config.appPath, 'api', name, 'documentation', this.getDocumentationVersion()];\n\n    try {\n      const documentationFiles = fs\n        .readdirSync(path.resolve(documentationPath.join('/')))\n        .filter(el => el.includes('.json'));\n\n      return documentationFiles.reduce((acc, current) => {\n        try {\n          const doc = JSON.parse(\n            fs.readFileSync(path.resolve([...documentationPath, current].join('/')), 'utf8')\n          );\n          acc.push(doc);\n        } catch (err) {\n          // console.log(path.resolve([...documentationPath, current].join('/')), err);\n        }\n\n        return acc;\n      }, []);\n    } catch (err) {\n      return [];\n    }\n  },\n\n  /**\n   * Retrieve all documentation files from either the APIs or the plugins\n   * @param {Boolean} isPlugin\n   * @returns {Array}\n   */\n  retrieveDocumentationFiles: function(isPlugin = false, version = this.getDocumentationVersion()) {\n    const array = isPlugin ? this.getPluginsWithDocumentationNeeded() : this.getApis();\n\n    return array.reduce((acc, current) => {\n      const documentationPath = isPlugin\n        ? [strapi.config.appPath, 'extensions', current, 'documentation', version]\n        : [strapi.config.appPath, 'api', current, 'documentation', version];\n\n      try {\n        const documentationFiles = fs\n          .readdirSync(path.resolve(documentationPath.join('/')))\n          .filter(el => el.includes('.json'));\n\n        documentationFiles.forEach(el => {\n          try {\n            let documentation = JSON.parse(\n              fs.readFileSync(path.resolve([...documentationPath, el].join('/')), 'utf8')\n            );\n            /* eslint-disable indent */\n            const overrideDocumentationPath = isPlugin\n              ? path.resolve(\n                  strapi.config.appPath,\n                  'extensions',\n                  current,\n                  'documentation',\n                  version,\n                  'overrides',\n                  el\n                )\n              : path.resolve(\n                  strapi.config.appPath,\n                  'api',\n                  current,\n                  'documentation',\n                  version,\n                  'overrides',\n                  el\n                );\n            /* eslint-enable indent */\n            let overrideDocumentation;\n\n            try {\n              overrideDocumentation = JSON.parse(\n                fs.readFileSync(overrideDocumentationPath, 'utf8')\n              );\n            } catch (err) {\n              overrideDocumentation = null;\n            }\n\n            if (!_.isEmpty(overrideDocumentation)) {\n              documentation.paths = this.mergePaths(documentation, overrideDocumentation).paths;\n              documentation.tags = _.cloneDeep(\n                this.mergeTags(documentation, overrideDocumentation)\n              );\n              const documentationComponents = _.get(documentation, 'components', {});\n              const overrideComponents = _.get(overrideDocumentation, 'components', {});\n              const mergedComponents = this.mergeComponents(\n                documentationComponents,\n                overrideComponents\n              );\n\n              if (!_.isEmpty(mergedComponents)) {\n                documentation.components = mergedComponents;\n              }\n            }\n\n            acc.push(documentation);\n          } catch (err) {\n            strapi.log.error(err);\n            console.log(\n              `Unable to access the documentation for ${[...documentationPath, el].join('/')}`\n            );\n          }\n        });\n      } catch (err) {\n        strapi.log.error(err);\n        console.log(\n          `Unable to retrieve documentation for the ${isPlugin ? 'plugin' : 'api'} ${current}`\n        );\n      }\n\n      return acc;\n    }, []);\n  },\n\n  retrieveDocumentationVersions: function() {\n    return fs\n      .readdirSync(this.getFullDocumentationPath())\n      .map(version => {\n        try {\n          const doc = JSON.parse(\n            fs.readFileSync(\n              path.resolve(this.getFullDocumentationPath(), version, 'full_documentation.json')\n            )\n          );\n          const generatedDate = _.get(doc, ['info', 'x-generation-date'], null);\n\n          return { version, generatedDate, url: '' };\n        } catch (err) {\n          return null;\n        }\n      })\n      .filter(x => x);\n  },\n\n  retrieveFrontForm: async function() {\n    const config = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'documentation',\n        key: 'config',\n      })\n      .get();\n    const forms = JSON.parse(JSON.stringify(form));\n\n    _.set(forms, [0, 0, 'value'], config.restrictedAccess);\n    _.set(forms, [0, 1, 'value'], config.password || '');\n\n    return forms;\n  },\n};\n",
    "packages/strapi-plugin-email/controllers/Email.js": "'use strict';\n\n/**\n * Email.js controller\n *\n * @description: A set of functions called \"actions\" of the `email` plugin.\n */\nmodule.exports = {\n  send: async ctx => {\n    let options = ctx.request.body;\n    try {\n      await strapi.plugins.email.services.email.send(options);\n    } catch (e) {\n      if (e.statusCode === 400) {\n        return ctx.badRequest(e.message);\n      } else {\n        throw new Error(`Couldn't send email: ${e.message}.`);\n      }\n    }\n\n    // Send 200 `ok`\n    ctx.send({});\n  },\n};\n",
    "packages/strapi-plugin-graphql/hooks/graphql/index.js": "'use strict';\n\n/**\n * Module dependencies\n */\n\n// Public node modules.\nconst _ = require('lodash');\nconst { ApolloServer } = require('apollo-server-koa');\nconst depthLimit = require('graphql-depth-limit');\nconst { graphqlUploadKoa } = require('graphql-upload');\nconst loadConfigs = require('./load-config');\n\nconst attachMetadataToResolvers = (schema, { api, plugin }) => {\n  const { resolver = {} } = schema;\n  if (_.isEmpty(resolver)) return schema;\n\n  Object.keys(resolver).forEach(type => {\n    if (!_.isPlainObject(resolver[type])) return;\n\n    Object.keys(resolver[type]).forEach(resolverName => {\n      if (!_.isPlainObject(resolver[type][resolverName])) return;\n\n      resolver[type][resolverName]['_metadatas'] = {\n        api,\n        plugin,\n      };\n    });\n  });\n\n  return schema;\n};\n\nmodule.exports = strapi => {\n  const { appPath, installedPlugins } = strapi.config;\n\n  return {\n    async beforeInitialize() {\n      // Try to inject this hook just after the others hooks to skip the router processing.\n      if (!strapi.config.get('hook.load.after')) {\n        _.set(strapi.config.hook.load, 'after', []);\n      }\n\n      strapi.config.hook.load.after.push('graphql');\n      // Load core utils.\n\n      const { api, plugins, extensions } = await loadConfigs({\n        appPath,\n        installedPlugins,\n      });\n      _.merge(strapi, { api, plugins });\n\n      /*\n       * Create a merge of all the GraphQL configuration.\n       */\n      const apisSchemas = Object.keys(strapi.api || {}).map(key => {\n        const schema = _.get(strapi.api[key], 'config.schema.graphql', {});\n        return attachMetadataToResolvers(schema, { api: key });\n      });\n\n      const pluginsSchemas = Object.keys(strapi.plugins || {}).map(key => {\n        const schema = _.get(strapi.plugins[key], 'config.schema.graphql', {});\n        return attachMetadataToResolvers(schema, { plugin: key });\n      });\n\n      const extensionsSchemas = Object.keys(extensions || {}).map(key => {\n        const schema = _.get(extensions[key], 'config.schema.graphql', {});\n        return attachMetadataToResolvers(schema, { plugin: key });\n      });\n\n      const baseSchema = mergeSchemas([...apisSchemas, ...pluginsSchemas, ...extensionsSchemas]);\n\n      // save the final schema in the plugin's config\n      _.set(strapi, ['plugins', 'graphql', 'config', '_schema', 'graphql'], baseSchema);\n    },\n\n    initialize() {\n      const schema = strapi.plugins.graphql.services['schema-generator'].generateSchema();\n\n      if (_.isEmpty(schema)) {\n        strapi.log.warn('The GraphQL schema has not been generated because it is empty');\n\n        return;\n      }\n\n      const config = _.get(strapi.plugins.graphql, 'config', {});\n\n      // TODO: Remove these deprecated options in favor of `apolloServer` in the next major version\n      const deprecatedApolloServerConfig = {\n        tracing: _.get(config, 'tracing', false),\n        introspection: _.get(config, 'introspection', true),\n        engine: _.get(config, 'engine', false),\n      };\n\n      if (['tracing', 'introspection', 'engine'].some(key => _.has(config, key))) {\n        strapi.log.warn(\n          'The `tracing`, `introspection` and `engine` options are deprecated in favor of the `apolloServer` object and they will be removed in the next major version.'\n        );\n      }\n\n      const apolloServerConfig = _.get(config, 'apolloServer', {});\n\n      const serverParams = {\n        schema,\n        uploads: false,\n        context: ({ ctx }) => {\n          // Initiliase loaders for this request.\n          // TODO: set loaders in the context not globally\n\n          strapi.plugins.graphql.services['data-loaders'].initializeLoader();\n\n          return {\n            context: ctx,\n          };\n        },\n        formatError: err => {\n          const formatError = _.get(config, 'formatError', null);\n\n          return typeof formatError === 'function' ? formatError(err) : err;\n        },\n        validationRules: [depthLimit(config.depthLimit)],\n        playground: false,\n        cors: false,\n        bodyParserConfig: true,\n        // TODO: Remove these deprecated options in favor of `apolloServerConfig` in the next major version\n        ...deprecatedApolloServerConfig,\n        ...apolloServerConfig,\n      };\n\n      // Disable GraphQL Playground in production environment.\n      if (strapi.config.environment !== 'production' || config.playgroundAlways) {\n        serverParams.playground = {\n          endpoint: `${strapi.config.server.url}${config.endpoint}`,\n          shareEnabled: config.shareEnabled,\n        };\n      }\n\n      const server = new ApolloServer(serverParams);\n\n      const uploadMiddleware = graphqlUploadKoa();\n      strapi.app.use((ctx, next) => {\n        if (ctx.path === config.endpoint) {\n          return uploadMiddleware(ctx, next);\n        }\n\n        return next();\n      });\n      server.applyMiddleware({\n        app: strapi.app,\n        path: config.endpoint,\n      });\n\n      strapi.plugins.graphql.destroy = async () => {\n        await server.stop();\n      };\n    },\n  };\n};\n\n/**\n * Merges a  list of schemas\n * @param {Array<Object>} schemas - The list of schemas to merge\n */\nconst mergeSchemas = schemas => {\n  return schemas.reduce((acc, el) => {\n    const { definition, query, mutation, type, resolver } = el;\n\n    return _.merge(acc, {\n      definition: `${acc.definition || ''} ${definition || ''}`,\n      query: `${acc.query || ''} ${query || ''}`,\n      mutation: `${acc.mutation || ''} ${mutation || ''}`,\n      type,\n      resolver,\n    });\n  }, {});\n};\n",
    "packages/strapi-plugin-graphql/hooks/graphql/load-config.js": "'use strict';\n\n// eslint-disable-next-line node/no-extraneous-require\nconst loadUtils = require('strapi/lib/load');\nconst _ = require('lodash');\n\nconst loadApisGraphqlConfig = appPath =>\n  loadUtils.loadFiles(appPath, 'api/**/config/*.graphql?(.js)');\n\nconst loadPluginsGraphqlConfig = async installedPlugins => {\n  const root = {};\n\n  for (let pluginName of installedPlugins) {\n    const pluginDir = loadUtils.findPackagePath(`strapi-plugin-${pluginName}`);\n\n    const result = await loadUtils.loadFiles(pluginDir, 'config/*.graphql?(.js)');\n\n    _.set(root, ['plugins', pluginName], result);\n  }\n\n  return root;\n};\n\nconst loadLocalPluginsGraphqlConfig = async appPath =>\n  loadUtils.loadFiles(appPath, 'plugins/**/config/*.graphql?(.js)');\n\nconst loadExtensions = async appPath =>\n  loadUtils.loadFiles(appPath, 'extensions/**/config/*.graphql?(.js)');\n\n/**\n * Loads the graphql config files\n */\nmodule.exports = async ({ appPath, installedPlugins }) => {\n  const [apis, plugins, localPlugins, extensions] = await Promise.all([\n    loadApisGraphqlConfig(appPath),\n    loadPluginsGraphqlConfig(installedPlugins),\n    loadLocalPluginsGraphqlConfig(appPath),\n    loadExtensions(appPath),\n  ]);\n\n  return _.merge({}, apis, plugins, extensions, localPlugins);\n};\n",
    "packages/strapi-plugin-graphql/services/build-aggregation.js": "/**\n * Aggregator.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\n'use strict';\n\nconst _ = require('lodash');\nconst pluralize = require('pluralize');\nconst { convertRestQueryParams, buildQuery } = require('strapi-utils');\n\nconst { buildQuery: buildQueryResolver } = require('./resolvers-builder');\nconst { convertToParams, convertToQuery, nonRequired } = require('./utils');\nconst { toSDL } = require('./schema-definitions');\n\n/**\n * Returns all fields of type primitive\n *\n * @returns {Boolean}\n */\nconst isPrimitiveType = type => {\n  const nonRequiredType = nonRequired(type);\n  return (\n    nonRequiredType === 'Int' ||\n    nonRequiredType === 'Float' ||\n    nonRequiredType === 'String' ||\n    nonRequiredType === 'Boolean' ||\n    nonRequiredType === 'DateTime' ||\n    nonRequiredType === 'JSON'\n  );\n};\n\n/**\n * Checks if the field is of type enum\n *\n * @returns {Boolean}\n */\nconst isEnumType = type => {\n  return type === 'enumeration';\n};\n\n/**\n * Returns all fields that are not of type array\n *\n * @returns {Boolean}\n *\n * @example\n *\n * isNotOfTypeArray([String])\n * // => false\n * isNotOfTypeArray(String!)\n * // => true\n */\nconst isNotOfTypeArray = type => {\n  return !/(\\[\\w+!?\\])/.test(type);\n};\n\n/**\n * Returns all fields of type Integer or float\n */\nconst isNumberType = type => {\n  const nonRequiredType = nonRequired(type);\n  return nonRequiredType === 'Int' || nonRequiredType === 'Float';\n};\n\n/**\n * Returns a list of fields that have type included in fieldTypes.\n */\nconst getFieldsByTypes = (fields, typeCheck, returnType) => {\n  return _.reduce(\n    fields,\n    (acc, fieldType, fieldName) => {\n      if (typeCheck(fieldType)) {\n        acc[fieldName] = returnType(fieldType, fieldName);\n      }\n      return acc;\n    },\n    {}\n  );\n};\n\n/**\n * Use the field resolver otherwise fall through the field value\n *\n * @returns {function}\n */\nconst fieldResolver = (field, key) => {\n  return object => {\n    const resolver =\n      field.resolve ||\n      function resolver(obj) {\n        // eslint-disable-line no-unused-vars\n        return obj[key];\n      };\n    return resolver(object);\n  };\n};\n\n/**\n * Create fields resolvers\n *\n * @return {Object}\n */\nconst createFieldsResolver = function(fields, resolverFn, typeCheck) {\n  const resolver = Object.keys(fields).reduce((acc, fieldKey) => {\n    const field = fields[fieldKey];\n    // Check if the field is of the correct type\n    if (typeCheck(field)) {\n      return _.set(acc, fieldKey, (obj, options, context) => {\n        return resolverFn(\n          obj,\n          options,\n          context,\n          fieldResolver(field, fieldKey),\n          fieldKey,\n          obj,\n          field\n        );\n      });\n    }\n    return acc;\n  }, {});\n\n  return resolver;\n};\n\n/**\n * Convert non-primitive type to string (non-primitive types corresponds to a reference to an other model)\n *\n * @returns {String}\n *\n * @example\n *\n * extractType(String!)\n * // => String\n *\n * extractType(user)\n * // => ID\n *\n * extractType(ENUM_TEST_FIELD, enumeration)\n * // => String\n *\n */\nconst extractType = function(_type, attributeType) {\n  return isPrimitiveType(_type)\n    ? _type.replace('!', '')\n    : isEnumType(attributeType)\n    ? 'String'\n    : 'ID';\n};\n\n/**\n * Create the resolvers for each aggregation field\n *\n * @return {Object}\n *\n * @example\n *\n * const model = // Strapi model\n *\n * const fields = {\n *   username: String,\n *   age: Int,\n * }\n *\n * const typeCheck = (type) => type === 'Int' || type === 'Float',\n *\n * const fieldsResoler = createAggregationFieldsResolver(model, fields, 'sum', typeCheck);\n *\n * // => {\n *   age: function ageResolver() { .... }\n * }\n */\nconst createAggregationFieldsResolver = function(model, fields, operation, typeCheck) {\n  return createFieldsResolver(\n    fields,\n    async (obj, options, context, fieldResolver, fieldKey) => {\n      const filters = convertRestQueryParams({\n        ...convertToParams(_.omit(obj, 'where')),\n        ...convertToQuery(obj.where),\n      });\n\n      if (model.orm === 'mongoose') {\n        return buildQuery({ model, filters, aggregate: true })\n          .group({\n            _id: null,\n            [fieldKey]: { [`$${operation}`]: `$${fieldKey}` },\n          })\n          .exec()\n          .then(result => _.get(result, [0, fieldKey]));\n      }\n\n      if (model.orm === 'bookshelf') {\n        return model\n          .query(qb => {\n            // apply filters\n            buildQuery({ model, filters })(qb);\n\n            // `sum, avg, min, max` pass nicely to knex :->\n            qb[operation](`${fieldKey} as ${operation}_${fieldKey}`);\n          })\n          .fetch()\n          .then(result => result.get(`${operation}_${fieldKey}`));\n      }\n    },\n    typeCheck\n  );\n};\n\n/**\n * Correctly format the data returned by the group by\n */\nconst preProcessGroupByData = function({ result, fieldKey, filters }) {\n  const _result = _.toArray(result).filter(value => Boolean(value._id));\n  return _.map(_result, value => {\n    return {\n      key: value._id.toString(),\n      connection: () => {\n        // filter by the grouped by value in next connection\n\n        return {\n          ...filters,\n          where: {\n            ...(filters.where || {}),\n            [fieldKey]: value._id.toString(),\n          },\n        };\n      },\n    };\n  });\n};\n\n/**\n * Create the resolvers for each group by field\n *\n * @return {Object}\n *\n * @example\n *\n * const model = // Strapi model\n * const fields = {\n *   username: [UserConnectionUsername],\n *   email: [UserConnectionEmail],\n * }\n * const fieldsResoler = createGroupByFieldsResolver(model, fields);\n *\n * // => {\n *   username: function usernameResolver() { .... }\n *   email: function emailResolver() { .... }\n * }\n */\nconst createGroupByFieldsResolver = function(model, fields) {\n  const resolver = async (filters, options, context, fieldResolver, fieldKey) => {\n    const params = convertRestQueryParams({\n      ...convertToParams(_.omit(filters, 'where')),\n      ...convertToQuery(filters.where),\n    });\n\n    if (model.orm === 'mongoose') {\n      const result = await buildQuery({\n        model,\n        filters: params,\n        aggregate: true,\n      }).group({\n        _id: `$${fieldKey === 'id' ? model.primaryKey : fieldKey}`,\n      });\n\n      return preProcessGroupByData({\n        result,\n        fieldKey,\n        filters,\n      });\n    }\n\n    if (model.orm === 'bookshelf') {\n      return model\n        .query(qb => {\n          buildQuery({ model, filters: params })(qb);\n          qb.groupBy(fieldKey);\n          qb.select(fieldKey);\n        })\n        .fetchAll()\n        .then(result => {\n          let values = result.models\n            .map(m => m.get(fieldKey)) // extract aggregate field\n            .filter(v => !!v) // remove null\n            .map(v => '' + v); // convert to string\n          return values.map(v => ({\n            key: v,\n            connection: () => {\n              return {\n                ..._.omit(filters, ['limit']), // we shouldn't carry limit to sub-field\n                where: {\n                  ...(filters.where || {}),\n                  [fieldKey]: v,\n                },\n              };\n            },\n          }));\n        });\n    }\n  };\n\n  return createFieldsResolver(fields, resolver, () => true);\n};\n/**\n * Generate the connection type of each non-array field of the model\n *\n * @return {String}\n */\nconst generateConnectionFieldsTypes = function(fields, model) {\n  const { globalId, attributes } = model;\n  const primitiveFields = getFieldsByTypes(fields, isNotOfTypeArray, (type, name) =>\n    extractType(type, (attributes[name] || {}).type)\n  );\n\n  const connectionFields = _.mapValues(primitiveFields, fieldType => ({\n    key: fieldType,\n    connection: `${globalId}Connection`,\n  }));\n\n  return Object.keys(primitiveFields)\n    .map(\n      fieldKey =>\n        `type ${globalId}Connection${_.upperFirst(fieldKey)} {${toSDL(connectionFields[fieldKey])}}`\n    )\n    .join('\\n\\n');\n};\n\nconst formatConnectionGroupBy = function(fields, model) {\n  const { globalId } = model;\n  const groupByGlobalId = `${globalId}GroupBy`;\n\n  // Extract all primitive fields and change their types\n  const groupByFields = getFieldsByTypes(\n    fields,\n    isNotOfTypeArray,\n    (fieldType, fieldName) => `[${globalId}Connection${_.upperFirst(fieldName)}]`\n  );\n\n  // Get the generated field types\n  let groupByTypes = `type ${groupByGlobalId} {${toSDL(groupByFields)}}\\n\\n`;\n  groupByTypes += generateConnectionFieldsTypes(fields, model);\n\n  return {\n    globalId: groupByGlobalId,\n    type: groupByTypes,\n    resolver: {\n      [groupByGlobalId]: createGroupByFieldsResolver(model, groupByFields),\n    },\n  };\n};\n\nconst formatConnectionAggregator = function(fields, model, modelName) {\n  const { globalId } = model;\n\n  // Extract all fields of type Integer and Float and change their type to Float\n  const numericFields = getFieldsByTypes(fields, isNumberType, () => 'Float');\n\n  // Don't create an aggregator field if the model has not number fields\n  const aggregatorGlobalId = `${globalId}Aggregator`;\n  const initialFields = {\n    count: 'Int',\n    totalCount: 'Int',\n  };\n\n  // Only add the aggregator's operations if there are some numeric fields\n  if (!_.isEmpty(numericFields)) {\n    ['sum', 'avg', 'min', 'max'].forEach(agg => {\n      initialFields[agg] = `${aggregatorGlobalId}${_.startCase(agg)}`;\n    });\n  }\n\n  const gqlNumberFormat = toSDL(numericFields);\n  let aggregatorTypes = `type ${aggregatorGlobalId} {${toSDL(initialFields)}}\\n\\n`;\n\n  let resolvers = {\n    [aggregatorGlobalId]: {\n      count(obj) {\n        const opts = convertToQuery(obj.where);\n\n        if (opts._q) {\n          // allow search param\n          return strapi.query(modelName, model.plugin).countSearch(opts);\n        }\n        return strapi.query(modelName, model.plugin).count(opts);\n      },\n      totalCount() {\n        return strapi.query(modelName, model.plugin).count({});\n      },\n    },\n  };\n\n  // Only add the aggregator's operations types and resolver if there are some numeric fields\n  if (!_.isEmpty(numericFields)) {\n    // Returns the actual object and handle aggregation in the query resolvers\n    const defaultAggregatorFunc = obj => {\n      // eslint-disable-line no-unused-vars\n      return obj;\n    };\n\n    aggregatorTypes += `type ${aggregatorGlobalId}Sum {${gqlNumberFormat}}\\n\\n`;\n    aggregatorTypes += `type ${aggregatorGlobalId}Avg {${gqlNumberFormat}}\\n\\n`;\n    aggregatorTypes += `type ${aggregatorGlobalId}Min {${gqlNumberFormat}}\\n\\n`;\n    aggregatorTypes += `type ${aggregatorGlobalId}Max {${gqlNumberFormat}}\\n\\n`;\n\n    _.merge(resolvers[aggregatorGlobalId], {\n      sum: defaultAggregatorFunc,\n      avg: defaultAggregatorFunc,\n      min: defaultAggregatorFunc,\n      max: defaultAggregatorFunc,\n    });\n\n    resolvers = {\n      ...resolvers,\n      [`${aggregatorGlobalId}Sum`]: createAggregationFieldsResolver(\n        model,\n        fields,\n        'sum',\n        isNumberType\n      ),\n      [`${aggregatorGlobalId}Avg`]: createAggregationFieldsResolver(\n        model,\n        fields,\n        'avg',\n        isNumberType\n      ),\n      [`${aggregatorGlobalId}Min`]: createAggregationFieldsResolver(\n        model,\n        fields,\n        'min',\n        isNumberType\n      ),\n      [`${aggregatorGlobalId}Max`]: createAggregationFieldsResolver(\n        model,\n        fields,\n        'max',\n        isNumberType\n      ),\n    };\n  }\n\n  return {\n    globalId: aggregatorGlobalId,\n    type: aggregatorTypes,\n    resolver: resolvers,\n  };\n};\n\n/**\n * This method is the entry point to the GraphQL's Aggregation.\n * It takes as param the model and its fields and it'll create the aggregation types and resolver to it\n * Example:\n *  type User {\n *     username: String,\n *     age: Int,\n *  }\n *\n * It'll create\n *  type UserConnection {\n *    values: [User],\n *    groupBy: UserGroupBy,\n *    aggreate: UserAggregate\n *  }\n *\n *  type UserAggregate {\n *     count: Int\n *     sum: UserAggregateSum\n *     avg: UserAggregateAvg\n *  }\n *\n *  type UserAggregateSum {\n *     age: Float\n *  }\n *\n *  type UserAggregateAvg {\n *    age: Float\n *  }\n *\n *  type UserGroupBy {\n *     username: [UserConnectionUsername]\n *     age: [UserConnectionAge]\n *  }\n *\n *  type UserConnectionUsername {\n *    key: String\n *    connection: UserConnection\n *  }\n *\n *  type UserConnectionAge {\n *    key: Int\n *    connection: UserConnection\n *  }\n *\n */\nconst formatModelConnectionsGQL = function({ fields, model, name, resolver }) {\n  const { globalId } = model;\n\n  const connectionGlobalId = `${globalId}Connection`;\n\n  const aggregatorFormat = formatConnectionAggregator(fields, model, name);\n  const groupByFormat = formatConnectionGroupBy(fields, model);\n  const connectionFields = {\n    values: `[${globalId}]`,\n    groupBy: `${globalId}GroupBy`,\n    aggregate: `${globalId}Aggregator`,\n  };\n  const pluralName = pluralize.plural(_.camelCase(name));\n\n  let modelConnectionTypes = `type ${connectionGlobalId} {${toSDL(connectionFields)}}\\n\\n`;\n  if (aggregatorFormat) {\n    modelConnectionTypes += aggregatorFormat.type;\n  }\n  modelConnectionTypes += groupByFormat.type;\n\n  const queryName = `${pluralName}Connection(sort: String, limit: Int, start: Int, where: JSON)`;\n\n  const connectionResolver = buildQueryResolver(`${pluralName}Connection.values`, resolver);\n\n  const connectionQueryName = `${pluralName}Connection`;\n\n  return {\n    globalId: connectionGlobalId,\n    definition: modelConnectionTypes,\n    query: {\n      [queryName]: connectionGlobalId,\n    },\n    resolvers: {\n      Query: {\n        [connectionQueryName]: buildQueryResolver(connectionQueryName, {\n          resolverOf: resolver.resolverOf || resolver.resolver,\n          resolver(obj, options) {\n            return options;\n          },\n        }),\n      },\n      [connectionGlobalId]: {\n        values(obj, options, gqlCtx) {\n          return connectionResolver(obj, obj, gqlCtx);\n        },\n        groupBy(obj) {\n          return obj;\n        },\n        aggregate(obj) {\n          return obj;\n        },\n      },\n      ...aggregatorFormat.resolver,\n      ...groupByFormat.resolver,\n    },\n  };\n};\n\nmodule.exports = {\n  formatModelConnectionsGQL,\n};\n",
    "packages/strapi-plugin-graphql/services/resolvers-builder.js": "/**\n * Build queries and mutation resolvers\n */\n\n'use strict';\n\nconst _ = require('lodash');\nconst compose = require('koa-compose');\n\nconst { policy: policyUtils } = require('strapi-utils');\nconst {\n  convertToParams,\n  convertToQuery,\n  amountLimiting,\n  getAction,\n  getActionDetails,\n  isResolvablePath,\n} = require('./utils');\n\nconst buildMutation = (mutationName, config) => {\n  const { resolver, resolverOf, transformOutput = _.identity } = config;\n\n  if (_.isFunction(resolver) && !isResolvablePath(resolverOf)) {\n    throw new Error(\n      `Cannot create mutation \"${mutationName}\". Missing \"resolverOf\" option with custom resolver.`\n    );\n  }\n\n  const policiesMiddleware = compose(getPolicies(config));\n\n  // custom resolvers\n  if (_.isFunction(resolver)) {\n    return async (root, options = {}, graphqlContext, info) => {\n      const ctx = buildMutationContext({ options, graphqlContext });\n\n      await policiesMiddleware(ctx);\n      graphqlContext.context = ctx;\n\n      return resolver(root, options, graphqlContext, info);\n    };\n  }\n\n  const action = getAction(resolver);\n\n  return async (root, options = {}, graphqlContext) => {\n    const ctx = buildMutationContext({ options, graphqlContext });\n\n    await policiesMiddleware(ctx);\n\n    const values = await action(ctx);\n    const result = ctx.body || values;\n\n    if (_.isError(result)) {\n      throw result;\n    }\n\n    return transformOutput(result);\n  };\n};\n\nconst buildMutationContext = ({ options, graphqlContext }) => {\n  const { context } = graphqlContext;\n\n  const ctx = cloneKoaContext(context);\n\n  if (options.input && options.input.where) {\n    ctx.params = convertToParams(options.input.where || {});\n  } else {\n    ctx.params = {};\n  }\n\n  if (options.input && options.input.data) {\n    ctx.request.body = options.input.data || {};\n  } else {\n    ctx.request.body = options;\n  }\n\n  return ctx;\n};\n\nconst buildQuery = (queryName, config) => {\n  const { resolver } = config;\n\n  try {\n    validateResolverOption(config);\n  } catch (error) {\n    throw new Error(`Cannot create query \"${queryName}\": ${error.message}`);\n  }\n\n  const policiesMiddleware = compose(getPolicies(config));\n\n  // custom resolvers\n  if (_.isFunction(resolver)) {\n    return async (root, options = {}, graphqlContext, info) => {\n      const { ctx, opts } = buildQueryContext({ options, graphqlContext });\n\n      await policiesMiddleware(ctx);\n      graphqlContext.context = ctx;\n\n      return resolver(root, opts, graphqlContext, info);\n    };\n  }\n\n  const action = getAction(resolver);\n\n  return async (root, options = {}, graphqlContext) => {\n    const { ctx } = buildQueryContext({ options, graphqlContext });\n\n    // duplicate context\n    await policiesMiddleware(ctx);\n\n    const values = await action(ctx);\n    const result = ctx.body || values;\n\n    if (_.isError(result)) {\n      throw result;\n    }\n\n    return result;\n  };\n};\n\nconst validateResolverOption = config => {\n  const { resolver, resolverOf, policies } = config;\n\n  if (_.isFunction(resolver) && !isResolvablePath(resolverOf)) {\n    throw new Error(`Missing \"resolverOf\" option with custom resolver.`);\n  }\n\n  if (!_.isUndefined(policies) && (!Array.isArray(policies) || !_.every(policies, _.isString))) {\n    throw new Error('Policies option must be an array of string.');\n  }\n\n  return true;\n};\n\nconst cloneKoaContext = ctx => {\n  return Object.assign(ctx.app.createContext(_.clone(ctx.req), _.clone(ctx.res)), {\n    state: {\n      ...ctx.state,\n    },\n  });\n};\n\nconst buildQueryContext = ({ options, graphqlContext }) => {\n  const { context } = graphqlContext;\n  const _options = _.cloneDeep(options);\n\n  const ctx = cloneKoaContext(context);\n\n  const opts = amountLimiting(_options);\n\n  ctx.query = {\n    ...convertToParams(_.omit(opts, 'where')),\n    ...convertToQuery(opts.where),\n  };\n\n  ctx.params = convertToParams(opts);\n\n  return { ctx, opts };\n};\n\n/**\n * Checks if a resolverPath (resolver or resovlerOf) might be resolved\n */\nconst getPolicies = config => {\n  const { resolver, policies = [], resolverOf } = config;\n\n  const { api, plugin } = config['_metadatas'] || {};\n\n  const policyFns = [];\n\n  const { controller, action, plugin: pathPlugin } = isResolvablePath(resolverOf)\n    ? getActionDetails(resolverOf)\n    : getActionDetails(resolver);\n\n  const globalPolicy = policyUtils.globalPolicy({\n    controller,\n    action,\n    plugin: pathPlugin,\n  });\n\n  policyFns.push(globalPolicy);\n\n  if (strapi.plugins['users-permissions']) {\n    policies.unshift('plugins::users-permissions.permissions');\n  }\n\n  policies.forEach(policy => {\n    const policyFn = policyUtils.get(policy, plugin, api);\n    policyFns.push(policyFn);\n  });\n\n  return policyFns;\n};\n\nmodule.exports = {\n  buildQuery,\n  buildMutation,\n};\n",
    "packages/strapi-plugin-graphql/services/type-definitions.js": "'use strict';\n\n/**\n * GraphQL.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\nconst _ = require('lodash');\nconst { contentTypes } = require('strapi-utils');\n\nconst {\n  hasDraftAndPublish,\n  constants: { DP_PUB_STATE_LIVE },\n} = contentTypes;\n\nconst DynamicZoneScalar = require('../types/dynamiczoneScalar');\n\nconst { formatModelConnectionsGQL } = require('./build-aggregation');\nconst types = require('./type-builder');\nconst { mergeSchemas, convertToParams, convertToQuery, amountLimiting } = require('./utils');\nconst { toSDL, getTypeDescription } = require('./schema-definitions');\nconst { toSingular, toPlural } = require('./naming');\nconst { buildQuery, buildMutation } = require('./resolvers-builder');\nconst { actionExists } = require('./utils');\n\nconst OPTIONS = Symbol();\n\nconst FIND_QUERY_ARGUMENTS = `(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState)`;\nconst FIND_ONE_QUERY_ARGUMENTS = `(id: ID!, publicationState: PublicationState)`;\n\nconst assignOptions = (element, parent) => {\n  if (Array.isArray(element)) {\n    return element.map(el => assignOptions(el, parent));\n  }\n\n  return _.set(element, OPTIONS, _.get(parent, OPTIONS, {}));\n};\n\nconst isQueryEnabled = (schema, name) => {\n  return _.get(schema, `resolver.Query.${name}`) !== false;\n};\n\nconst isMutationEnabled = (schema, name) => {\n  return _.get(schema, `resolver.Mutation.${name}`) !== false;\n};\n\nconst isNotPrivate = _.curry((model, attributeName) => {\n  return !contentTypes.isPrivateAttribute(model, attributeName);\n});\n\nconst wrapPublicationStateResolver = query => async (parent, args, ctx, ast) => {\n  const results = await query(parent, args, ctx, ast);\n\n  const queryOptions = _.pick(args, 'publicationState');\n  return assignOptions(results, { [OPTIONS]: queryOptions });\n};\n\nconst buildTypeDefObj = model => {\n  const { associations = [], attributes, primaryKey, globalId } = model;\n\n  const typeDef = {\n    id: 'ID!',\n    [primaryKey]: 'ID!',\n  };\n\n  // Add timestamps attributes.\n  if (_.isArray(_.get(model, 'options.timestamps'))) {\n    const [createdAtKey, updatedAtKey] = model.options.timestamps;\n    typeDef[createdAtKey] = 'DateTime!';\n    typeDef[updatedAtKey] = 'DateTime!';\n  }\n\n  Object.keys(attributes)\n    .filter(isNotPrivate(model))\n    .forEach(attributeName => {\n      const attribute = attributes[attributeName];\n      // Convert our type to the GraphQL type.\n      typeDef[attributeName] = types.convertType({\n        attribute,\n        modelName: globalId,\n        attributeName,\n      });\n    });\n\n  // Change field definition for collection relations\n  associations\n    .filter(association => association.type === 'collection')\n    .filter(association => isNotPrivate(model, association.alias))\n    .forEach(association => {\n      typeDef[`${association.alias}(sort: String, limit: Int, start: Int, where: JSON)`] =\n        typeDef[association.alias];\n\n      delete typeDef[association.alias];\n    });\n\n  return typeDef;\n};\n\nconst generateEnumDefinitions = (attributes, globalId) => {\n  return Object.keys(attributes)\n    .filter(attribute => attributes[attribute].type === 'enumeration')\n    .map(attribute => {\n      const definition = attributes[attribute];\n\n      const name = types.convertEnumType(definition, globalId, attribute);\n      const values = definition.enum.map(v => `\\t${v}`).join('\\n');\n      return `enum ${name} {\\n${values}\\n}\\n`;\n    })\n    .join('');\n};\n\nconst generateDynamicZoneDefinitions = (attributes, globalId, schema) => {\n  Object.keys(attributes)\n    .filter(attribute => attributes[attribute].type === 'dynamiczone')\n    .forEach(attribute => {\n      const { components } = attributes[attribute];\n\n      const typeName = `${globalId}${_.upperFirst(_.camelCase(attribute))}DynamicZone`;\n\n      if (components.length === 0) {\n        // Create dummy type because graphql doesn't support empty ones\n\n        schema.definition += `type ${typeName} { _:Boolean}`;\n        schema.definition += `\\nscalar EmptyQuery\\n`;\n      } else {\n        const componentsTypeNames = components.map(componentUID => {\n          const compo = strapi.components[componentUID];\n          if (!compo) {\n            throw new Error(\n              `Trying to creating dynamiczone type with unkown component ${componentUID}`\n            );\n          }\n\n          return compo.globalId;\n        });\n\n        const unionType = `union ${typeName} = ${componentsTypeNames.join(' | ')}`;\n\n        schema.definition += `\\n${unionType}\\n`;\n      }\n\n      const inputTypeName = `${typeName}Input`;\n      schema.definition += `\\nscalar ${inputTypeName}\\n`;\n\n      schema.resolvers[typeName] = {\n        __resolveType(obj) {\n          return strapi.components[obj.__component].globalId;\n        },\n      };\n\n      schema.resolvers[inputTypeName] = new DynamicZoneScalar({\n        name: inputTypeName,\n        attribute,\n        globalId,\n        components,\n      });\n    });\n};\n\nconst initQueryOptions = (targetModel, parent) => {\n  if (hasDraftAndPublish(targetModel)) {\n    return {\n      _publicationState: _.get(parent, [OPTIONS, 'publicationState'], DP_PUB_STATE_LIVE),\n    };\n  }\n\n  return {};\n};\n\nconst buildAssocResolvers = model => {\n  const { primaryKey, associations = [] } = model;\n\n  return associations\n    .filter(association => isNotPrivate(model, association.alias))\n    .reduce((resolver, association) => {\n      const target = association.model || association.collection;\n      const targetModel = strapi.getModel(target, association.plugin);\n\n      const { nature, alias } = association;\n\n      switch (nature) {\n        case 'oneToManyMorph':\n        case 'manyMorphToOne':\n        case 'manyMorphToMany':\n        case 'manyToManyMorph': {\n          resolver[alias] = async obj => {\n            if (obj[alias]) {\n              return assignOptions(obj[alias], obj);\n            }\n\n            const params = {\n              ...initQueryOptions(targetModel, obj),\n              id: obj[primaryKey],\n            };\n\n            const entry = await strapi.query(model.uid).findOne(params, [alias]);\n\n            return assignOptions(entry[alias], obj);\n          };\n          break;\n        }\n        default: {\n          resolver[alias] = async (obj, options) => {\n            const loader = strapi.plugins.graphql.services['data-loaders'].loaders[targetModel.uid];\n\n            const localId = obj[model.primaryKey];\n            const targetPK = targetModel.primaryKey;\n            const foreignId = _.get(obj[alias], targetModel.primaryKey, obj[alias]);\n\n            const params = {\n              ...initQueryOptions(targetModel, obj),\n              ...convertToParams(_.omit(amountLimiting(options), 'where')),\n              ...convertToQuery(options.where),\n            };\n\n            if (['oneToOne', 'oneWay', 'manyToOne'].includes(nature)) {\n              if (!_.has(obj, alias) || _.isNil(foreignId)) {\n                return null;\n              }\n\n              // check this is an entity and not a mongo ID\n              if (_.has(obj[alias], targetPK)) {\n                return assignOptions(obj[alias], obj);\n              }\n\n              const query = {\n                single: true,\n                filters: {\n                  ...params,\n                  [targetPK]: foreignId,\n                },\n              };\n\n              return loader.load(query).then(r => assignOptions(r, obj));\n            }\n\n            if (['oneToMany', 'manyToMany'].includes(nature)) {\n              const { via } = association;\n\n              const filters = {\n                ...params,\n                [`${via}.id`]: localId,\n              };\n\n              return loader.load({ filters }).then(r => assignOptions(r, obj));\n            }\n\n            if (nature === 'manyWay') {\n              let targetIds = [];\n\n              // find the related ids to query them and apply the filters\n              if (Array.isArray(obj[alias])) {\n                targetIds = obj[alias].map(value => value[targetPK] || value);\n              } else {\n                const entry = await strapi\n                  .query(model.uid)\n                  .findOne({ [primaryKey]: obj[primaryKey] }, [alias]);\n\n                if (_.isEmpty(entry[alias])) {\n                  return [];\n                }\n\n                targetIds = entry[alias].map(el => el[targetPK]);\n              }\n\n              const filters = {\n                ...params,\n                [`${targetPK}_in`]: targetIds.map(_.toString),\n              };\n\n              return loader.load({ filters }).then(r => assignOptions(r, obj));\n            }\n          };\n          break;\n        }\n      }\n\n      return resolver;\n    }, {});\n};\n\n/**\n * Construct the GraphQL query & definition and apply the right resolvers.\n *\n * @return Object\n */\nconst buildModels = models => {\n  return models.map(model => {\n    const { kind, modelType } = model;\n\n    if (modelType === 'component') {\n      return buildComponent(model);\n    }\n\n    switch (kind) {\n      case 'singleType':\n        return buildSingleType(model);\n      default:\n        return buildCollectionType(model);\n    }\n  });\n};\n\nconst buildModelDefinition = (model, globalType = {}) => {\n  const { globalId, primaryKey } = model;\n\n  const schema = {\n    definition: '',\n    query: {},\n    mutation: {},\n    resolvers: {\n      Query: {},\n      Mutation: {},\n      [globalId]: {\n        id: parent => parent[primaryKey] || parent.id,\n        ...buildAssocResolvers(model),\n      },\n    },\n  };\n\n  const typeDefObj = buildTypeDefObj(model);\n\n  schema.definition += generateEnumDefinitions(model.attributes, globalId);\n  generateDynamicZoneDefinitions(model.attributes, globalId, schema);\n\n  const description = getTypeDescription(globalType, model);\n  const fields = toSDL(typeDefObj, globalType, model);\n  const typeDef = `${description}type ${globalId} {${fields}}\\n`;\n\n  schema.definition += typeDef;\n  return schema;\n};\n\nconst buildComponent = component => {\n  const { globalId } = component;\n  const schema = buildModelDefinition(component);\n\n  schema.definition += types.generateInputModel(component, globalId, {\n    allowIds: true,\n  });\n\n  return schema;\n};\n\nconst buildSingleType = model => {\n  const { uid, modelName } = model;\n\n  const singularName = toSingular(modelName);\n\n  const _schema = _.cloneDeep(_.get(strapi.plugins, 'graphql.config._schema.graphql', {}));\n\n  const globalType = _.get(_schema, `type.${model.globalId}`, {});\n\n  const localSchema = buildModelDefinition(model, globalType);\n\n  // Add definition to the schema but this type won't be \"queriable\" or \"mutable\".\n  if (globalType === false) {\n    return localSchema;\n  }\n\n  if (isQueryEnabled(_schema, singularName)) {\n    const resolver = buildQuery(singularName, {\n      resolver: `${uid}.find`,\n      ..._.get(_schema, `resolver.Query.${singularName}`, {}),\n    });\n\n    _.merge(localSchema, {\n      query: {\n        [`${singularName}(publicationState: PublicationState)`]: model.globalId,\n      },\n      resolvers: {\n        Query: {\n          [singularName]: wrapPublicationStateResolver(resolver),\n        },\n      },\n    });\n  }\n\n  // Add model Input definition.\n  localSchema.definition += types.generateInputModel(model, modelName);\n\n  // build every mutation\n  ['update', 'delete'].forEach(action => {\n    const mutationSchema = buildMutationTypeDef({ model, action }, { _schema });\n\n    mergeSchemas(localSchema, mutationSchema);\n  });\n\n  return localSchema;\n};\n\nconst buildCollectionType = model => {\n  const { globalId, plugin, modelName, uid } = model;\n\n  const singularName = toSingular(modelName);\n  const pluralName = toPlural(modelName);\n\n  const _schema = _.cloneDeep(_.get(strapi.plugins, 'graphql.config._schema.graphql', {}));\n\n  const globalType = _.get(_schema, `type.${model.globalId}`, {});\n\n  const localSchema = {\n    definition: '',\n    query: {},\n    mutation: {},\n    resolvers: {\n      Query: {},\n      Mutation: {},\n      // define default resolver for this model\n      [globalId]: {\n        id: parent => parent[model.primaryKey] || parent.id,\n        ...buildAssocResolvers(model),\n      },\n    },\n  };\n\n  const typeDefObj = buildTypeDefObj(model);\n\n  localSchema.definition += generateEnumDefinitions(model.attributes, globalId);\n  generateDynamicZoneDefinitions(model.attributes, globalId, localSchema);\n\n  const description = getTypeDescription(globalType, model);\n  const fields = toSDL(typeDefObj, globalType, model);\n  const typeDef = `${description}type ${globalId} {${fields}}\\n`;\n\n  localSchema.definition += typeDef;\n\n  // Add definition to the schema but this type won't be \"queriable\" or \"mutable\".\n  if (globalType === false) {\n    return localSchema;\n  }\n\n  if (isQueryEnabled(_schema, singularName)) {\n    const resolverOpts = {\n      resolver: `${uid}.findOne`,\n      ..._.get(_schema, `resolver.Query.${singularName}`, {}),\n    };\n    if (actionExists(resolverOpts)) {\n      const resolver = buildQuery(singularName, resolverOpts);\n      _.merge(localSchema, {\n        query: {\n          // TODO: support all the unique fields\n          [`${singularName}${FIND_ONE_QUERY_ARGUMENTS}`]: model.globalId,\n        },\n        resolvers: {\n          Query: {\n            [singularName]: wrapPublicationStateResolver(resolver),\n          },\n        },\n      });\n    }\n  }\n\n  if (isQueryEnabled(_schema, pluralName)) {\n    const resolverOpts = {\n      resolver: `${uid}.find`,\n      ..._.get(_schema, `resolver.Query.${pluralName}`, {}),\n    };\n    if (actionExists(resolverOpts)) {\n      const resolver = buildQuery(pluralName, resolverOpts);\n      _.merge(localSchema, {\n        query: {\n          [`${pluralName}${FIND_QUERY_ARGUMENTS}`]: `[${model.globalId}]`,\n        },\n        resolvers: {\n          Query: {\n            [pluralName]: wrapPublicationStateResolver(resolver),\n          },\n        },\n      });\n\n      if (isQueryEnabled(_schema, `${pluralName}Connection`)) {\n        // Generate the aggregation for the given model\n        const aggregationSchema = formatModelConnectionsGQL({\n          fields: typeDefObj,\n          model,\n          name: modelName,\n          resolver: resolverOpts,\n          plugin,\n        });\n\n        mergeSchemas(localSchema, aggregationSchema);\n      }\n    }\n  }\n\n  // Add model Input definition.\n  localSchema.definition += types.generateInputModel(model, modelName);\n\n  // build every mutation\n  ['create', 'update', 'delete'].forEach(action => {\n    const mutationSchema = buildMutationTypeDef({ model, action }, { _schema });\n    mergeSchemas(localSchema, mutationSchema);\n  });\n\n  return localSchema;\n};\n\n// TODO:\n// - Implement batch methods (need to update the content-manager as well).\n// - Implement nested transactional methods (create/update).\nconst buildMutationTypeDef = ({ model, action }, { _schema }) => {\n  const capitalizedName = _.upperFirst(toSingular(model.modelName));\n  const mutationName = `${action}${capitalizedName}`;\n\n  const resolverOpts = {\n    resolver: `${model.uid}.${action}`,\n    transformOutput: result => ({ [toSingular(model.modelName)]: result }),\n    ..._.get(_schema, `resolver.Mutation.${mutationName}`, {}),\n  };\n\n  if (!actionExists(resolverOpts)) {\n    return {};\n  }\n\n  const definition = types.generateInputPayloadArguments({\n    model,\n    name: model.modelName,\n    mutationName,\n    action,\n  });\n\n  // ignore if disabled\n  if (!isMutationEnabled(_schema, mutationName)) {\n    return {\n      definition,\n    };\n  }\n\n  const { kind } = model;\n\n  let mutationDef = `${mutationName}(input: ${mutationName}Input)`;\n  if (kind === 'singleType' && action === 'delete') {\n    mutationDef = mutationName;\n  }\n\n  return {\n    definition,\n    mutation: {\n      [mutationDef]: `${mutationName}Payload`,\n    },\n    resolvers: {\n      Mutation: {\n        [mutationName]: buildMutation(mutationName, resolverOpts),\n      },\n    },\n  };\n};\n\nmodule.exports = {\n  buildModels,\n};\n",
    "packages/strapi-plugin-graphql/tests/graphqlCrud.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet graphqlQuery;\n\nconst postModel = {\n  attributes: {\n    name: {\n      type: 'richtext',\n    },\n    bigint: {\n      type: 'biginteger',\n    },\n    nullable: {\n      type: 'string',\n    },\n  },\n  connection: 'default',\n  name: 'post',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Test Graphql API End to End', () => {\n  beforeAll(async () => {\n    await builder.addContentType(postModel).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    graphqlQuery = body => {\n      return rq({\n        url: '/graphql',\n        method: 'POST',\n        body,\n      });\n    };\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Test CRUD', () => {\n    const postsPayload = [\n      { name: 'post 1', bigint: 1316130638171, nullable: 'value' },\n      { name: 'post 2', bigint: 1416130639261, nullable: null },\n    ];\n    let data = {\n      posts: [],\n    };\n\n    test.each(postsPayload)('Create Post %o', async post => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation createPost($input: createPostInput) {\n            createPost(input: $input) {\n              post {\n                name\n                bigint\n                nullable\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: post,\n          },\n        },\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toEqual({\n        data: {\n          createPost: {\n            post,\n          },\n        },\n      });\n    });\n\n    test('List posts', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            posts {\n              id\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          posts: postsPayload,\n        },\n      });\n\n      // assign for later use\n      data.posts = res.body.data.posts;\n    });\n\n    test('List posts with limit', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            posts(limit: 1) {\n              id\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          posts: [data.posts[0]],\n        },\n      });\n    });\n\n    test('List posts with sort', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            posts(sort: \"name:desc\") {\n              id\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          posts: [...data.posts].reverse(),\n        },\n      });\n    });\n\n    test('List posts with start', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            posts(start: 1) {\n              id\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          posts: [data.posts[1]],\n        },\n      });\n    });\n\n    test.skip('List posts with `created_by` and `updated_by`', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            posts(start: 1) {\n              id\n              name\n              bigint\n              nullable\n              created_by {\n                username\n              }\n              updated_by {\n                username\n              }\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n\n      // no errors should be present in the response\n      expect(res.body.error).toBeUndefined();\n\n      // since the posts are created without AdminUser, it should return null\n      expect(res.body.data.posts[0].created_by).toBeNull();\n    });\n\n    test.each([\n      [\n        {\n          name: 'post 1',\n          bigint: 1316130638171,\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          name_eq: 'post 1',\n          bigint_eq: 1316130638171,\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          name_ne: 'post 1',\n          bigint_ne: 1316130638171,\n        },\n        [postsPayload[1]],\n      ],\n      [\n        {\n          name_contains: 'Post',\n        },\n        postsPayload,\n      ],\n      [\n        {\n          name_contains: 'Post 1',\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          name_containss: 'post',\n        },\n        postsPayload,\n      ],\n      [\n        {\n          name_ncontainss: 'post 1',\n        },\n        [postsPayload[1]],\n      ],\n      [\n        {\n          name_in: ['post 1', 'post 2', 'post 3'],\n        },\n        postsPayload,\n      ],\n      [\n        {\n          name_nin: ['post 2'],\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          nullable_null: true,\n        },\n        [postsPayload[1]],\n      ],\n      [\n        {\n          nullable_null: false,\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          _or: [{ name_in: ['post 2'] }, { bigint_eq: 1316130638171 }],\n        },\n        [postsPayload[0], postsPayload[1]],\n      ],\n      [\n        {\n          _where: { nullable_null: false },\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          _where: { _or: { nullable_null: false } },\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          _where: [{ nullable_null: false }],\n        },\n        [postsPayload[0]],\n      ],\n      [\n        {\n          _where: [{ _or: [{ name_in: ['post 2'] }, { bigint_eq: 1316130638171 }] }],\n        },\n        [postsPayload[0], postsPayload[1]],\n      ],\n      [\n        {\n          _where: [\n            {\n              _or: [\n                { name_in: ['post 2'] },\n                { _or: [{ bigint_eq: 1316130638171 }, { nullable_null: false }] },\n              ],\n            },\n          ],\n        },\n        [postsPayload[0], postsPayload[1]],\n      ],\n    ])('List posts with where clause %o', async (where, expected) => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          query findPosts($where: JSON) {\n            posts(where: $where) {\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n        variables: {\n          where,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n\n      // same length\n      expect(res.body.data.posts.length).toBe(expected.length);\n\n      // all the posts returned are in the expected array\n      res.body.data.posts.forEach(post => {\n        expect(expected).toEqual(expect.arrayContaining([post]));\n      });\n\n      // all expected values are in the result\n      expected.forEach(expectedPost => {\n        expect(res.body.data.posts).toEqual(expect.arrayContaining([expectedPost]));\n      });\n    });\n\n    test('Get One Post', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          query getPost($id: ID!) {\n            post(id: $id) {\n              id\n              name\n              bigint\n              nullable\n            }\n          }\n        `,\n        variables: {\n          id: data.posts[0].id,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          post: data.posts[0],\n        },\n      });\n    });\n\n    test('Update Post', async () => {\n      const newName = 'new post name';\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation updatePost($input: updatePostInput) {\n            updatePost(input: $input) {\n              post {\n                id\n                name\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            where: {\n              id: data.posts[0].id,\n            },\n            data: {\n              name: newName,\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          updatePost: {\n            post: {\n              id: data.posts[0].id,\n              name: newName,\n            },\n          },\n        },\n      });\n\n      data.posts[0] = res.body.data.updatePost.post;\n    });\n\n    test('Delete Posts', async () => {\n      for (let post of data.posts) {\n        const res = await graphqlQuery({\n          query: /* GraphQL */ `\n            mutation deletePost($input: deletePostInput) {\n              deletePost(input: $input) {\n                post {\n                  id\n                  name\n                  bigint\n                }\n              }\n            }\n          `,\n          variables: {\n            input: {\n              where: {\n                id: post.id,\n              },\n            },\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject({\n          data: {\n            deletePost: {\n              post: {\n                id: post.id,\n              },\n            },\n          },\n        });\n      }\n    });\n  });\n});\n",
    "packages/strapi-plugin-graphql/tests/graphqlRelations.test.e2e.js": "'use strict';\n\n// Helpers.\nconst _ = require('lodash');\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet graphqlQuery;\n\n// utils\nconst selectFields = doc => _.pick(doc, ['id', 'name', 'color']);\n\nconst rgbColorComponent = {\n  attributes: {\n    name: {\n      type: 'text',\n    },\n    red: {\n      type: 'integer',\n    },\n    green: {\n      type: 'integer',\n    },\n    blue: {\n      type: 'integer',\n    },\n  },\n  name: 'rgbColor',\n};\n\nconst documentModel = {\n  attributes: {\n    name: {\n      type: 'richtext',\n    },\n    content: {\n      type: 'richtext',\n    },\n  },\n  connection: 'default',\n  name: 'document',\n  description: '',\n  collectionName: '',\n};\n\nconst labelModel = {\n  attributes: {\n    name: {\n      type: 'richtext',\n    },\n    documents: {\n      dominant: true,\n      nature: 'manyToMany',\n      target: 'application::document.document',\n      targetAttribute: 'labels',\n    },\n    color: {\n      type: 'component',\n      component: 'default.rgb-color',\n      repeatable: false,\n    },\n  },\n  connection: 'default',\n  name: 'label',\n  description: '',\n  collectionName: '',\n};\n\nconst carModel = {\n  attributes: {\n    name: {\n      type: 'text',\n    },\n  },\n  connection: 'default',\n  name: 'car',\n  description: '',\n  collectionName: '',\n};\n\nconst personModel = {\n  attributes: {\n    name: {\n      type: 'text',\n    },\n    privateName: {\n      type: 'text',\n      private: true,\n    },\n    privateCars: {\n      nature: 'oneToMany',\n      target: 'application::car.car',\n      dominant: false,\n      targetAttribute: 'person',\n      private: true,\n    },\n  },\n  connection: 'default',\n  name: 'person',\n  description: '',\n  collectionName: '',\n};\n\ndescribe('Test Graphql Relations API End to End', () => {\n  beforeAll(async () => {\n    await builder\n      .addComponent(rgbColorComponent)\n      .addContentTypes([documentModel, labelModel, carModel, personModel])\n      .build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    graphqlQuery = body => {\n      return rq({\n        url: '/graphql',\n        method: 'POST',\n        body,\n      });\n    };\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Test relations features', () => {\n    let data = {\n      labels: [],\n      documents: [],\n      people: [],\n      cars: [],\n    };\n    const labelsPayload = [\n      { name: 'label 1', color: null },\n      { name: 'label 2', color: null },\n      { name: 'labelWithColor', color: { name: 'tomato', red: 255, green: 99, blue: 71 } },\n    ];\n    const documentsPayload = [{ name: 'document 1' }, { name: 'document 2' }];\n\n    test.each(labelsPayload)('Create label %o', async label => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation createLabel($input: createLabelInput) {\n            createLabel(input: $input) {\n              label {\n                name\n                color {\n                  name\n                  red\n                  green\n                  blue\n                }\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: label,\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          createLabel: {\n            label,\n          },\n        },\n      });\n    });\n\n    test('List labels', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            labels {\n              id\n              name\n              color {\n                name\n                red\n                green\n                blue\n              }\n            }\n          }\n        `,\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          labels: labelsPayload,\n        },\n      });\n\n      // assign for later use\n      data.labels = data.labels.concat(res.body.data.labels);\n    });\n\n    test.each(documentsPayload)('Create document linked to every labels %o', async document => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation createDocument($input: createDocumentInput) {\n            createDocument(input: $input) {\n              document {\n                name\n                labels {\n                  id\n                  name\n                  color {\n                    name\n                    red\n                    green\n                    blue\n                  }\n                }\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: {\n              ...document,\n              labels: data.labels.map(t => t.id),\n            },\n          },\n        },\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n\n      expect(body).toMatchObject({\n        data: {\n          createDocument: {\n            document: {\n              ...selectFields(document),\n              labels: expect.arrayContaining(data.labels.map(selectFields)),\n            },\n          },\n        },\n      });\n    });\n\n    test('List documents with labels', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            documents {\n              id\n              name\n              labels {\n                id\n                name\n                color {\n                  name\n                  red\n                  green\n                  blue\n                }\n              }\n            }\n          }\n        `,\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          documents: expect.arrayContaining(\n            data.documents.map(document => ({\n              ...selectFields(document),\n              labels: expect.arrayContaining(data.labels.map(selectFields)),\n            }))\n          ),\n        },\n      });\n\n      // assign for later use\n      data.documents = res.body.data.documents;\n    });\n\n    test('List Labels with documents', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            labels {\n              id\n              name\n              color {\n                name\n                red\n                green\n                blue\n              }\n              documents {\n                id\n                name\n              }\n            }\n          }\n        `,\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          labels: expect.arrayContaining(\n            data.labels.map(label => ({\n              ...selectFields(label),\n              documents: expect.arrayContaining(data.documents.map(selectFields)),\n            }))\n          ),\n        },\n      });\n\n      // assign for later use\n      data.labels = res.body.data.labels;\n    });\n\n    test('Deep query', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            documents(where: { labels: { name_contains: \"label 1\" } }) {\n              id\n              name\n              labels {\n                id\n                name\n                color {\n                  name\n                  red\n                  green\n                  blue\n                }\n              }\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          documents: expect.arrayContaining(data.documents),\n        },\n      });\n    });\n\n    test('Update Document relations removes correctly a relation', async () => {\n      // if I remove a label from an document is it working\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation updateDocument($input: updateDocumentInput) {\n            updateDocument(input: $input) {\n              document {\n                id\n                name\n                labels {\n                  id\n                  name\n                  color {\n                    name\n                    red\n                    green\n                    blue\n                  }\n                }\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            where: {\n              id: data.documents[0].id,\n            },\n            data: {\n              labels: [data.labels[0].id],\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          updateDocument: {\n            document: {\n              ...selectFields(data.documents[0]),\n              labels: [selectFields(data.labels[0])],\n            },\n          },\n        },\n      });\n    });\n\n    test('Delete Labels and test Documents relations', async () => {\n      for (let label of data.labels) {\n        const res = await graphqlQuery({\n          query: /* GraphQL */ `\n            mutation deleteLabel($input: deleteLabelInput) {\n              deleteLabel(input: $input) {\n                label {\n                  id\n                  name\n                  color {\n                    name\n                    red\n                    green\n                    blue\n                  }\n                }\n              }\n            }\n          `,\n          variables: {\n            input: {\n              where: {\n                id: label.id,\n              },\n            },\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject({\n          data: {\n            deleteLabel: {\n              label: {\n                id: label.id,\n              },\n            },\n          },\n        });\n      }\n\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            documents {\n              id\n              name\n              labels {\n                id\n                name\n                color {\n                  name\n                  red\n                  green\n                  blue\n                }\n              }\n            }\n          }\n        `,\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          documents: expect.arrayContaining(\n            data.documents.map(document => ({\n              ...selectFields(document),\n              labels: [],\n            }))\n          ),\n        },\n      });\n    });\n\n    test('Delete Documents', async () => {\n      for (let document of data.documents) {\n        const res = await graphqlQuery({\n          query: /* GraphQL */ `\n            mutation deleteDocument($input: deleteDocumentInput) {\n              deleteDocument(input: $input) {\n                document {\n                  id\n                  name\n                }\n              }\n            }\n          `,\n          variables: {\n            input: {\n              where: {\n                id: document.id,\n              },\n            },\n          },\n        });\n\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject({\n          data: {\n            deleteDocument: {\n              document: {\n                id: document.id,\n              },\n            },\n          },\n        });\n      }\n    });\n\n    test('Create person', async () => {\n      const person = {\n        name: 'Chuck Norris',\n        privateName: 'Jean-Eude',\n      };\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation createPerson($input: createPersonInput) {\n            createPerson(input: $input) {\n              person {\n                id\n                name\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: person,\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          createPerson: {\n            person: {\n              id: expect.anything(),\n              name: person.name,\n            },\n          },\n        },\n      });\n      data.people.push(res.body.data.createPerson.person);\n    });\n\n    test(\"Can't list a private field\", async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            people {\n              name\n              privateName\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        errors: [\n          {\n            message: 'Cannot query field \"privateName\" on type \"Person\".',\n          },\n        ],\n      });\n    });\n\n    test('Create a car linked to a person (oneToMany)', async () => {\n      const car = {\n        name: 'Peugeot 508',\n        person: data.people[0].id,\n      };\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation createCar($input: createCarInput) {\n            createCar(input: $input) {\n              car {\n                id\n                name\n                person {\n                  id\n                  name\n                }\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: {\n              ...car,\n            },\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          createCar: {\n            car: {\n              id: expect.anything(),\n              name: car.name,\n              person: data.people[0],\n            },\n          },\n        },\n      });\n\n      data.cars.push({ id: res.body.data.createCar.car.id });\n    });\n\n    test(\"Can't list a private oneToMany relation\", async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            people {\n              name\n              privateCars\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        errors: [\n          {\n            message: 'Cannot query field \"privateCars\" on type \"Person\".',\n          },\n        ],\n      });\n    });\n\n    test('Edit person/cars relations removes correctly a car', async () => {\n      const newPerson = {\n        name: 'Check Norris Junior',\n        privateCars: [],\n      };\n\n      const mutationRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation updatePerson($input: updatePersonInput) {\n            updatePerson(input: $input) {\n              person {\n                id\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            where: {\n              id: data.people[0].id,\n            },\n            data: {\n              ...newPerson,\n            },\n          },\n        },\n      });\n      expect(mutationRes.statusCode).toBe(200);\n\n      const queryRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          query($id: ID!) {\n            car(id: $id) {\n              person {\n                id\n              }\n            }\n          }\n        `,\n        variables: {\n          id: data.cars[0].id,\n        },\n      });\n      expect(queryRes.statusCode).toBe(200);\n      expect(queryRes.body).toEqual({\n        data: {\n          car: {\n            person: null,\n          },\n        },\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-graphql/tests/single-type.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createTestBuilder } = require('../../../test/helpers/builder');\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nconst builder = createTestBuilder();\nlet strapi;\nlet rq;\nlet graphqlQuery;\nconst data = {};\n\nconst homePageModel = {\n  name: 'home-page',\n  kind: 'singleType',\n  attributes: {\n    title: {\n      type: 'string',\n    },\n  },\n};\n\nconst updateContent = data => {\n  return graphqlQuery({\n    query: /* GraphQL */ `\n      mutation updateHomePage($input: updateHomePageInput) {\n        updateHomePage(input: $input) {\n          homePage {\n            id\n          }\n        }\n      }\n    `,\n    variables: {\n      input: {\n        data,\n      },\n    },\n  });\n};\n\ndescribe('Single type Graphql support', () => {\n  beforeAll(async () => {\n    await builder.addContentType(homePageModel).build();\n\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    graphqlQuery = body => {\n      return rq({\n        url: '/graphql',\n        method: 'POST',\n        body,\n      });\n    };\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n    await builder.cleanup();\n  }, 60000);\n\n  describe('Queries', () => {\n    test('No list available', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            homePages {\n              id\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body.errors).toMatchObject(\n        expect.arrayContaining([\n          expect.objectContaining({\n            message: expect.stringMatching('Cannot query field \"homePages\"'),\n          }),\n        ])\n      );\n    });\n\n    test('Access the single type without args', async () => {\n      await updateContent({\n        title: 'Test',\n      });\n\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            homePage {\n              id\n              title\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data).toEqual({\n        homePage: {\n          id: expect.anything(),\n          title: 'Test',\n        },\n      });\n\n      data.id = res.body.data.homePage.id;\n    });\n  });\n\n  describe('Mutations', () => {\n    test('Cannot create', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation {\n            createHomePage(input: { data: { title: \"Test\" } }) {\n              id\n            }\n          }\n        `,\n      });\n\n      expect(res.statusCode).toBe(400);\n      expect(res.body.errors).toMatchObject(\n        expect.arrayContaining([\n          expect.objectContaining({\n            message: expect.stringMatching('Cannot query field \"createHomePage\"'),\n          }),\n        ])\n      );\n    });\n\n    test('update a single type does not require id', async () => {\n      const updateRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation updateHomePage($input: updateHomePageInput) {\n            updateHomePage(input: $input) {\n              homePage {\n                id\n                title\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            data: {\n              title: 'New Title',\n            },\n          },\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toEqual({\n        updateHomePage: {\n          homePage: {\n            id: data.id,\n            title: 'New Title',\n          },\n        },\n      });\n\n      const getRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            homePage {\n              id\n              title\n            }\n          }\n        `,\n      });\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toEqual({\n        homePage: {\n          id: data.id,\n          title: 'New Title',\n        },\n      });\n    });\n\n    test('Can delete without params', async () => {\n      const deleteRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation {\n            deleteHomePage {\n              homePage {\n                id\n                title\n              }\n            }\n          }\n        `,\n      });\n\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body.data).toEqual({\n        deleteHomePage: {\n          homePage: {\n            id: data.id,\n            title: 'New Title',\n          },\n        },\n      });\n\n      const getRes = await graphqlQuery({\n        query: /* GraphQL */ `\n          {\n            homePage {\n              id\n              title\n            }\n          }\n        `,\n      });\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toEqual({\n        homePage: null,\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-upload/admin/src/containers/HomePage/index.js": "import React, { useCallback, useReducer, useRef, useState, useEffect } from 'react';\nimport { get, includes, toString, isEqual, intersectionWith } from 'lodash';\nimport { useHistory, useLocation } from 'react-router-dom';\nimport { Header } from '@buffetjs/custom';\nimport { Button } from '@buffetjs/core';\nimport {\n  PopUpWarning,\n  useGlobalContext,\n  generateFiltersFromSearch,\n  generateSearchFromFilters,\n  request,\n  useQuery,\n} from 'strapi-helper-plugin';\nimport { formatFileForEditing, getRequestUrl, getTrad, getFileModelTimestamps } from '../../utils';\nimport Container from '../../components/Container';\nimport HomePageContent from './HomePageContent';\nimport Padded from '../../components/Padded';\nimport { useAppContext } from '../../hooks';\nimport ModalStepper from '../ModalStepper';\nimport { generateStringFromParams, getHeaderLabel } from './utils';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\nconst HomePage = () => {\n  const { allowedActions } = useAppContext();\n  const { canRead } = allowedActions;\n  const { formatMessage, plugins } = useGlobalContext();\n  const [, updated_at] = getFileModelTimestamps(plugins);\n  const [reducerState, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, allowedActions)\n  );\n  const query = useQuery();\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  const [isPopupOpen, setIsPopupOpen] = useState(false);\n  const [fileToEdit, setFileToEdit] = useState(null);\n  const [shouldRefetch, setShouldRefetch] = useState(false);\n  const [modalInitialStep, setModalInitialStep] = useState('browse');\n  const { push } = useHistory();\n  const { search } = useLocation();\n  const isMounted = useRef(true);\n  const {\n    data,\n    dataCount,\n    dataToDelete,\n    isLoading,\n    shouldRefetchData,\n    showModalConfirmButtonLoading,\n  } = reducerState.toJS();\n  const pluginName = formatMessage({ id: getTrad('plugin.name') });\n  const paramsKeys = ['_limit', '_start', '_q', '_sort'];\n\n  useEffect(() => {\n    return () => (isMounted.current = false);\n  }, []);\n\n  useEffect(() => {\n    fetchListData();\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [search]);\n\n  const deleteMedia = async id => {\n    const requestURL = getRequestUrl(`files/${id}`);\n\n    try {\n      await request(requestURL, {\n        method: 'DELETE',\n      });\n\n      return Promise.resolve();\n    } catch (err) {\n      const errorMessage = get(err, 'response.payload.message', 'An error occured');\n\n      return Promise.reject(errorMessage);\n    }\n  };\n\n  const fetchData = async () => {\n    const dataRequestURL = getRequestUrl('files');\n    const params = generateStringFromParams(query);\n\n    const paramsToSend = params.includes('_sort')\n      ? params\n      : params.concat(`&_sort=${updated_at}:DESC`);\n\n    try {\n      const data = await request(`${dataRequestURL}?${paramsToSend}`, {\n        method: 'GET',\n      });\n\n      return Promise.resolve(data);\n    } catch (err) {\n      if (isMounted.current) {\n        dispatch({ type: 'GET_DATA_ERROR' });\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      }\n    }\n\n    return [];\n  };\n\n  const fetchDataCount = async () => {\n    const params = generateStringFromParams(query, ['_limit', '_sort', '_start']);\n    const requestURL = getRequestUrl('files/count');\n\n    try {\n      const { count } = await request(`${requestURL}?${params}`, {\n        method: 'GET',\n      });\n\n      return Promise.resolve(count);\n    } catch (err) {\n      if (isMounted.current) {\n        dispatch({ type: 'GET_DATA_ERROR' });\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      }\n    }\n\n    return null;\n  };\n\n  const fetchListData = async () => {\n    if (canRead) {\n      dispatch({ type: 'GET_DATA' });\n\n      const [data, count] = await Promise.all([fetchData(), fetchDataCount()]);\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n          count,\n        });\n      }\n    }\n  };\n\n  const generateNewSearch = (updatedParams = {}) => {\n    return {\n      ...getSearchParams(),\n      filters: generateFiltersFromSearch(search),\n      ...updatedParams,\n    };\n  };\n\n  const getSearchParams = () => {\n    const params = {};\n\n    query.forEach((value, key) => {\n      if (includes(paramsKeys, key)) {\n        params[key] = value;\n      }\n    });\n\n    return params;\n  };\n\n  const handleChangeCheck = ({ target: { name } }) => {\n    dispatch({\n      type: 'ON_CHANGE_DATA_TO_DELETE',\n      id: name,\n    });\n  };\n\n  const handleChangeParams = ({ target: { name, value } }) => {\n    let updatedQueryParams = generateNewSearch({ [name]: value });\n\n    if (name === 'filters') {\n      const existingFilters = generateFiltersFromSearch(search);\n      const canAddFilter = intersectionWith(existingFilters, [value], isEqual).length === 0;\n      updatedQueryParams = generateNewSearch({ [name]: existingFilters });\n\n      if (canAddFilter) {\n        const filters = [...existingFilters, value];\n\n        updatedQueryParams = generateNewSearch({ [name]: filters });\n      }\n    }\n\n    if (name === '_limit') {\n      updatedQueryParams = generateNewSearch({ [name]: value, _start: 0 });\n    }\n\n    const newSearch = generateSearchFromFilters(updatedQueryParams);\n\n    push({ search: newSearch });\n  };\n\n  const handleClickEditFile = id => {\n    if (allowedActions.canUpdate) {\n      const file = formatFileForEditing(data.find(file => toString(file.id) === toString(id)));\n\n      setFileToEdit(file);\n      setModalInitialStep('edit');\n      handleClickToggleModal();\n    }\n  };\n\n  const handleClickToggleModal = (refetch = false) => {\n    setIsModalOpen(prev => !prev);\n    setShouldRefetch(refetch);\n  };\n\n  const handleClickTogglePopup = () => {\n    setIsPopupOpen(prev => !prev);\n  };\n\n  const handleDeleteFilter = index => {\n    const filters = generateFiltersFromSearch(search).filter(\n      (filter, filterIndex) => filterIndex !== index\n    );\n\n    const updatedQueryParams = generateNewSearch({ filters });\n\n    const newSearch = generateSearchFromFilters(updatedQueryParams);\n\n    push({ search: newSearch });\n  };\n\n  const handleConfirmDeleteMedias = useCallback(async () => {\n    dispatch({ type: 'ON_DELETE_MEDIAS' });\n\n    try {\n      await Promise.all(dataToDelete.map(item => deleteMedia(item.id)));\n\n      dispatch({\n        type: 'ON_DELETE_MEDIAS_SUCCEEDED',\n      });\n    } catch (err) {\n      strapi.notification.toggle({\n        type: 'warning',\n        message: err,\n      });\n\n      dispatch({\n        type: 'ON_DELETE_MEDIAS_ERROR',\n      });\n    } finally {\n      setIsPopupOpen(false);\n    }\n  }, [dataToDelete]);\n\n  const handleClosedModalDeleteAll = useCallback(() => {\n    if (shouldRefetchData) {\n      fetchListData();\n    } else {\n      dispatch({ type: 'RESET_DATA_TO_DELETE' });\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [shouldRefetchData]);\n\n  const handleModalClose = () => {\n    resetModalState();\n\n    if (shouldRefetch) {\n      fetchListData();\n      setShouldRefetch(false);\n    }\n  };\n\n  const handleSelectAll = () => {\n    dispatch({\n      type: 'TOGGLE_SELECT_ALL',\n    });\n  };\n\n  const resetModalState = () => {\n    setModalInitialStep('browse');\n    setFileToEdit(null);\n  };\n\n  const headerProps = {\n    title: {\n      label: pluginName,\n    },\n    /* eslint-disable indent */\n    content: canRead\n      ? formatMessage(\n          {\n            id: getTrad(getHeaderLabel(dataCount)),\n          },\n          { number: dataCount }\n        )\n      : null,\n    /* eslint-enable indent */\n    actions: [\n      {\n        disabled: dataToDelete.length === 0,\n        color: 'delete',\n        // TradId from the strapi-admin package\n        label: formatMessage({ id: 'app.utils.delete' }),\n        onClick: () => setIsPopupOpen(true),\n        type: 'button',\n        Component: buttonProps => {\n          if (!allowedActions.canUpdate) {\n            return null;\n          }\n\n          return <Button {...buttonProps} />;\n        },\n      },\n      {\n        disabled: false,\n        color: 'primary',\n        label: formatMessage({ id: getTrad('header.actions.upload-assets') }),\n        onClick: () => handleClickToggleModal(),\n        type: 'button',\n        Component: buttonProps => {\n          if (!allowedActions.canCreate) {\n            return null;\n          }\n\n          return <Button {...buttonProps} />;\n        },\n      },\n    ],\n  };\n\n  const handleRemoveFileFromDataToDelete = useCallback(id => {\n    dispatch({\n      type: 'ON_CHANGE_DATA_TO_DELETE',\n      id,\n    });\n  }, []);\n\n  const content = canRead ? (\n    <HomePageContent\n      data={data}\n      dataCount={dataCount}\n      dataToDelete={dataToDelete}\n      isLoading={isLoading}\n      onCardCheck={handleChangeCheck}\n      onCardClick={handleClickEditFile}\n      onClick={handleClickToggleModal}\n      onFilterDelete={handleDeleteFilter}\n      onParamsChange={handleChangeParams}\n      onSelectAll={handleSelectAll}\n    />\n  ) : null;\n\n  return (\n    <Container>\n      <Header {...headerProps} isLoading={isLoading} />\n      {content}\n      <ModalStepper\n        initialFileToEdit={fileToEdit}\n        initialStep={modalInitialStep}\n        isOpen={isModalOpen}\n        onClosed={handleModalClose}\n        onRemoveFileFromDataToDelete={handleRemoveFileFromDataToDelete}\n        onToggle={handleClickToggleModal}\n        refetchData={fetchListData}\n      />\n      <PopUpWarning\n        isOpen={isPopupOpen}\n        isConfirmButtonLoading={showModalConfirmButtonLoading}\n        onConfirm={handleConfirmDeleteMedias}\n        onClosed={handleClosedModalDeleteAll}\n        toggleModal={handleClickTogglePopup}\n        popUpWarningType=\"danger\"\n      />\n      <Padded bottom size=\"md\" />\n      <Padded bottom size=\"md\" />\n    </Container>\n  );\n};\n\nexport default HomePage;\n",
    "packages/strapi-plugin-upload/admin/src/containers/Initializer/index.js": "/**\n *\n * Initializer\n *\n */\n\nimport { useEffect, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { request } from 'strapi-helper-plugin';\nimport pluginId from '../../pluginId';\n\nconst Initializer = ({ updatePlugin }) => {\n  const ref = useRef();\n  ref.current = updatePlugin;\n\n  useEffect(() => {\n    const getData = async () => {\n      const requestURL = '/content-manager/content-types';\n\n      try {\n        const { data } = await request(requestURL, { method: 'GET' });\n        const fileModel = data.find(model => model.uid === 'plugins::upload.file');\n\n        ref.current(pluginId, 'fileModel', fileModel);\n        ref.current(pluginId, 'isReady', true);\n      } catch (err) {\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'content-manager.error.model.fetch' },\n        });\n      }\n    };\n\n    getData();\n  }, []);\n\n  return null;\n};\n\nInitializer.propTypes = {\n  updatePlugin: PropTypes.func.isRequired,\n};\n\nexport default Initializer;\n",
    "packages/strapi-plugin-upload/admin/src/containers/InputModalStepper/InputModalStepper.js": "import React, { useEffect, useState, useRef, memo } from 'react';\nimport PropTypes from 'prop-types';\nimport { Modal, ModalFooter, PopUpWarning, useGlobalContext, request } from 'strapi-helper-plugin';\nimport { Button } from '@buffetjs/core';\nimport { get, isEmpty, isEqual } from 'lodash';\nimport { getRequestUrl, getTrad } from '../../utils';\nimport ModalHeader from '../../components/ModalHeader';\nimport pluginId from '../../pluginId';\nimport stepper from './stepper';\nimport useModalContext from '../../hooks/useModalContext';\n\nconst InputModalStepper = ({\n  allowedActions,\n  isOpen,\n  onToggle,\n  noNavigation,\n  onInputMediaChange,\n}) => {\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const [shouldDeleteFile, setShouldDeleteFile] = useState(false);\n  const [displayNextButton, setDisplayNextButton] = useState(false);\n  const {\n    addFilesToUpload,\n    currentStep,\n    downloadFiles,\n    fetchMediaLib,\n    filesToDownload,\n    filesToUpload,\n    fileToEdit,\n    formErrors,\n    goTo,\n    handleAbortUpload,\n    handleCancelFileToUpload,\n    handleCleanFilesError,\n    handleClearFilesToUploadAndDownload,\n    handleClickNextButton,\n    handleClose,\n    handleEditExistingFile,\n    handleFileSelection,\n    handleFileToEditChange,\n    handleFormDisabled,\n    handleGoToEditNewFile,\n    handleRemoveFileToUpload,\n    handleResetFileToEdit,\n    handleSetCropResult,\n    handleSetFileToEditError,\n    handleUploadFiles,\n    initialFileToEdit,\n    initialSelectedFiles,\n    isFormDisabled,\n    isWarningDeleteOpen,\n    multiple,\n    selectedFiles,\n    submitEditNewFile,\n    submitEditExistingFile,\n    toggleModalWarning,\n  } = useModalContext();\n  const {\n    backButtonDestination,\n    Component,\n    components,\n    headerBreadcrumbs,\n    next,\n    prev,\n    withBackButton,\n    HeaderComponent,\n  } = stepper[currentStep];\n  const filesToUploadLength = filesToUpload.length;\n  const editModalRef = useRef();\n\n  const handleReplaceMedia = () => {\n    emitEvent('didReplaceMedia', { location: 'upload' });\n\n    editModalRef.current.click();\n  };\n\n  useEffect(() => {\n    if (currentStep === 'upload') {\n      // Go to the modal list view when file uploading is over\n\n      if (filesToUploadLength === 0) {\n        goToList();\n      } else {\n        downloadFiles();\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filesToUploadLength, currentStep]);\n\n  const addFilesToUploadList = ({ target: { value } }) => {\n    addFilesToUpload({ target: { value } });\n\n    goNext();\n  };\n\n  const goBack = (elementName = null) => {\n    const hasFilesToUpload = !isEmpty(filesToUpload);\n\n    // Redirect the user to the list modal from the upload one\n    if (elementName === 'backButton' && backButtonDestination && currentStep === 'upload') {\n      if (hasFilesToUpload) {\n        // eslint-disable-next-line no-alert\n        const confirm = window.confirm(\n          formatMessage({ id: getTrad('window.confirm.close-modal.files') })\n        );\n\n        if (!confirm) {\n          return;\n        }\n      }\n\n      goTo(backButtonDestination);\n      handleClearFilesToUploadAndDownload();\n\n      return;\n    }\n\n    if (\n      elementName === 'backButton' &&\n      backButtonDestination &&\n      currentStep === 'browse' &&\n      hasFilesToUpload\n    ) {\n      goTo(backButtonDestination);\n\n      return;\n    }\n\n    goTo(prev);\n  };\n\n  const goNext = () => {\n    if (next === null) {\n      onToggle();\n\n      return;\n    }\n\n    goTo(next);\n  };\n\n  const goToList = () => {\n    fetchMediaLib();\n    goTo('list');\n  };\n\n  const handleClickDeleteFile = async () => {\n    toggleModalWarning();\n  };\n\n  const handleClickDeleteFileToUpload = fileIndex => {\n    handleRemoveFileToUpload(fileIndex);\n\n    if (currentStep === 'edit-new') {\n      handleResetFileToEdit();\n\n      goNext();\n    }\n  };\n\n  const handleCloseModal = () => {\n    setDisplayNextButton(false);\n    handleClose();\n  };\n\n  const handleConfirmDeleteFile = () => {\n    setShouldDeleteFile(true);\n    toggleModalWarning();\n  };\n\n  const handleGoToAddBrowseFiles = () => {\n    handleCleanFilesError();\n\n    goBack();\n  };\n\n  const handleSubmitEditNewFile = e => {\n    e.preventDefault();\n    submitEditNewFile();\n    goNext();\n  };\n\n  const handleSubmit = e => {\n    e.preventDefault();\n    onInputMediaChange(multiple ? selectedFiles : selectedFiles[0]);\n    goNext();\n  };\n\n  const handleCloseModalWarning = async () => {\n    if (shouldDeleteFile) {\n      const { id } = fileToEdit;\n\n      try {\n        const requestURL = getRequestUrl(`files/${id}`);\n\n        await request(requestURL, { method: 'DELETE' });\n\n        setShouldDeleteFile(false);\n\n        // Remove file from selected files on delete and go back to the list.\n        handleFileSelection({ target: { name: id } });\n        goToList();\n      } catch (err) {\n        console.error(err);\n\n        const status = get(err, 'response.status', get(err, 'status', null));\n        const statusText = get(err, 'response.statusText', get(err, 'statusText', null));\n        const errorMessage = get(\n          err,\n          ['response', 'payload', 'message', '0', 'messages', '0', 'message'],\n          get(err, ['response', 'payload', 'message'], statusText)\n        );\n        strapi.notification.toggle({\n          type: 'warning',\n          message: errorMessage,\n        });\n\n        if (status) {\n          handleSetFileToEditError(errorMessage);\n        }\n      }\n    }\n  };\n\n  const handleSubmitEditExistingFile = async (\n    e,\n    shouldDuplicateMedia = false,\n    file = fileToEdit.file,\n    isSubmittingAfterCrop = false\n  ) => {\n    e.preventDefault();\n\n    submitEditExistingFile();\n\n    if (isSubmittingAfterCrop) {\n      emitEvent('didCropFile', {\n        duplicatedFile: shouldDuplicateMedia,\n        location: 'content-manager',\n      });\n    }\n\n    const headers = {};\n    const formData = new FormData();\n\n    // If the file has been cropped we need to add it to the formData\n    // otherwise we just don't send it\n    const didCropFile = file instanceof File;\n    const { abortController, id, fileInfo } = fileToEdit;\n    const requestURL = shouldDuplicateMedia ? `/${pluginId}` : `/${pluginId}?id=${id}`;\n\n    if (didCropFile) {\n      formData.append('files', file);\n    }\n\n    formData.append('fileInfo', JSON.stringify(fileInfo));\n\n    try {\n      const editedFile = await request(\n        requestURL,\n        {\n          method: 'POST',\n          headers,\n          body: formData,\n          signal: abortController.signal,\n        },\n        false,\n        false\n      );\n\n      handleEditExistingFile(editedFile);\n      goToList();\n    } catch (err) {\n      const status = get(err, 'response.status', get(err, 'status', null));\n      const statusText = get(err, 'response.statusText', get(err, 'statusText', null));\n      let errorMessage = get(\n        err,\n        ['response', 'payload', 'message', '0', 'messages', '0', 'message'],\n        get(err, ['response', 'payload', 'message'], statusText)\n      );\n\n      // TODO fix errors globally when the back-end sends readable one\n      if (status === 413) {\n        errorMessage = formatMessage({ id: 'app.utils.errors.file-too-big.message' });\n      }\n\n      if (status) {\n        handleSetFileToEditError(errorMessage);\n      }\n    }\n  };\n\n  const handleToggle = () => {\n    if (filesToUploadLength > 0) {\n      // eslint-disable-next-line no-alert\n      const confirm = window.confirm(\n        formatMessage({ id: getTrad('window.confirm.close-modal.files') })\n      );\n\n      if (!confirm) {\n        return;\n      }\n    }\n\n    if (\n      (currentStep === 'list' && !isEqual(selectedFiles, initialSelectedFiles)) ||\n      (currentStep === 'edit' && initialFileToEdit && !isEqual(fileToEdit, initialFileToEdit)) ||\n      (currentStep === 'edit' && selectedFiles.length > 0)\n    ) {\n      // eslint-disable-next-line no-alert\n      const confirm = window.confirm(\n        formatMessage({ id: getTrad('window.confirm.close-modal.file') })\n      );\n\n      if (!confirm) {\n        return;\n      }\n    }\n\n    onToggle(true);\n  };\n\n  const shouldDisplayNextButton = currentStep === 'browse' && displayNextButton;\n  const isFinishButtonDisabled = filesToUpload.some(file => file.isDownloading || file.isUploading);\n  const areButtonsDisabledOnEditExistingFile =\n    currentStep === 'edit' && fileToEdit.isUploading === true;\n\n  return (\n    <>\n      <Modal isOpen={isOpen} onToggle={handleToggle} onClosed={handleCloseModal}>\n        {/* header title */}\n        <ModalHeader\n          goBack={goBack}\n          HeaderComponent={HeaderComponent}\n          headerBreadcrumbs={headerBreadcrumbs}\n          withBackButton={withBackButton}\n        />\n        {/* body of the modal */}\n        {Component && (\n          <Component\n            {...allowedActions}\n            addFilesToUpload={addFilesToUploadList}\n            components={components}\n            filesToDownload={filesToDownload}\n            filesToUpload={filesToUpload}\n            fileToEdit={fileToEdit}\n            formErrors={formErrors}\n            isEditingUploadedFile={currentStep === 'edit'}\n            isFormDisabled={isFormDisabled}\n            noNavigation={noNavigation}\n            onAbortUpload={handleAbortUpload}\n            onChange={handleFileToEditChange}\n            onClickCancelUpload={handleCancelFileToUpload}\n            onClickDeleteFileToUpload={\n              currentStep === 'edit' ? handleClickDeleteFile : handleClickDeleteFileToUpload\n            }\n            onSubmitEdit={\n              currentStep === 'edit' ? handleSubmitEditExistingFile : handleSubmitEditNewFile\n            }\n            onClickEditNewFile={handleGoToEditNewFile}\n            onGoToAddBrowseFiles={handleGoToAddBrowseFiles}\n            onSubmitEditNewFile={handleSubmitEditNewFile}\n            ref={currentStep === 'edit' ? editModalRef : null}\n            toggleDisableForm={handleFormDisabled}\n            onToggle={handleToggle}\n            setCropResult={handleSetCropResult}\n            setShouldDisplayNextButton={setDisplayNextButton}\n            withBackButton={withBackButton}\n          />\n        )}\n\n        <ModalFooter>\n          <section>\n            <Button type=\"button\" color=\"cancel\" onClick={handleToggle}>\n              {formatMessage({ id: 'app.components.Button.cancel' })}\n            </Button>\n            {currentStep === 'upload' && (\n              <Button\n                type=\"button\"\n                color=\"success\"\n                onClick={handleUploadFiles}\n                disabled={isFinishButtonDisabled}\n              >\n                {formatMessage(\n                  {\n                    id: getTrad(\n                      `modal.upload-list.footer.button.${\n                        filesToUploadLength > 1 ? 'plural' : 'singular'\n                      }`\n                    ),\n                  },\n                  { number: filesToUploadLength }\n                )}\n              </Button>\n            )}\n            {shouldDisplayNextButton && (\n              <Button\n                type=\"button\"\n                color=\"primary\"\n                onClick={handleClickNextButton}\n                disabled={isEmpty(filesToDownload)}\n              >\n                {formatMessage({ id: getTrad('button.next') })}\n              </Button>\n            )}\n            {currentStep === 'edit-new' && (\n              <Button color=\"success\" type=\"button\" onClick={handleSubmitEditNewFile}>\n                {formatMessage({ id: 'form.button.finish' })}\n              </Button>\n            )}\n            {currentStep === 'edit' && (\n              <div style={{ margin: 'auto 0' }}>\n                <Button\n                  disabled={isFormDisabled || areButtonsDisabledOnEditExistingFile}\n                  color=\"primary\"\n                  onClick={handleReplaceMedia}\n                  style={{ marginRight: 10 }}\n                >\n                  {formatMessage({ id: getTrad('control-card.replace-media') })}\n                </Button>\n\n                <Button\n                  disabled={isFormDisabled || areButtonsDisabledOnEditExistingFile}\n                  color=\"success\"\n                  type=\"button\"\n                  onClick={handleSubmitEditExistingFile}\n                >\n                  {formatMessage({ id: 'form.button.finish' })}\n                </Button>\n              </div>\n            )}\n            {currentStep === 'list' && (\n              <Button color=\"success\" type=\"button\" onClick={handleSubmit}>\n                {formatMessage({ id: 'form.button.finish' })}\n              </Button>\n            )}\n          </section>\n        </ModalFooter>\n      </Modal>\n      <PopUpWarning\n        onClosed={handleCloseModalWarning}\n        isOpen={isWarningDeleteOpen}\n        toggleModal={toggleModalWarning}\n        popUpWarningType=\"danger\"\n        onConfirm={handleConfirmDeleteFile}\n      />\n    </>\n  );\n};\n\nInputModalStepper.defaultProps = {\n  allowedActions: {\n    canCopyLink: true,\n    canCreate: true,\n    canDownload: true,\n    canMain: true,\n    canRead: true,\n    canSettings: true,\n    canUpdate: true,\n  },\n  noNavigation: false,\n  onToggle: () => {},\n};\n\nInputModalStepper.propTypes = {\n  allowedActions: PropTypes.shape({\n    canCopyLink: PropTypes.bool,\n    canCreate: PropTypes.bool,\n    canDownload: PropTypes.bool,\n    canMain: PropTypes.bool,\n    canRead: PropTypes.bool,\n    canSettings: PropTypes.bool,\n    canUpdate: PropTypes.bool,\n  }),\n  isOpen: PropTypes.bool.isRequired,\n  noNavigation: PropTypes.bool,\n  onInputMediaChange: PropTypes.func.isRequired,\n  onToggle: PropTypes.func,\n};\n\nexport default memo(InputModalStepper);\n",
    "packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js": "import React, { useReducer, useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { request, generateSearchFromFilters, useGlobalContext } from 'strapi-helper-plugin';\nimport { clone, get, isEmpty, set } from 'lodash';\nimport { useIntl } from 'react-intl';\nimport axios from 'axios';\nimport pluginId from '../../pluginId';\nimport {\n  getFilesToDownload,\n  getRequestUrl,\n  getYupError,\n  compactParams,\n  createNewFilesToUploadArray,\n  urlSchema,\n  getFileModelTimestamps,\n  formatFilters,\n} from '../../utils';\nimport InputModalStepperContext from '../../contexts/InputModal/InputModalDataManager';\n\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\n/* eslint-disable indent */\n\nconst InputModalStepperProvider = ({\n  allowedActions,\n  allowedTypes,\n  children,\n  initialFilesToUpload,\n  initialFileToEdit,\n  isOpen,\n  multiple,\n  noNavigation,\n  onClosed,\n  onInputMediaChange,\n  selectedFiles,\n  step,\n}) => {\n  const [formErrors, setFormErrors] = useState(null);\n\n  const { formatMessage } = useIntl();\n  const { emitEvent, plugins } = useGlobalContext();\n  const [, updated_at] = getFileModelTimestamps(plugins);\n  const [reducerState, dispatch] = useReducer(reducer, initialState, state =>\n    init({\n      ...state,\n      allowedTypes,\n      currentStep: step,\n      initialFileToEdit,\n      fileToEdit: initialFileToEdit,\n      initialSelectedFiles: Array.isArray(selectedFiles) ? selectedFiles : [selectedFiles],\n      selectedFiles: Array.isArray(selectedFiles) ? selectedFiles : [selectedFiles],\n      filesToUpload: initialFilesToUpload\n        ? createNewFilesToUploadArray(initialFilesToUpload).map((file, index) => ({\n            ...file,\n            originalIndex: index,\n          }))\n        : [],\n      params: {\n        ...state.params,\n        _sort: `${updated_at}:DESC`,\n      },\n    })\n  );\n  const { params, filesToDownload, filesToUpload, fileToEdit } = reducerState;\n\n  useEffect(() => {\n    if (isOpen) {\n      fetchMediaLib();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen, params]);\n\n  const downloadFiles = async () => {\n    const files = getFilesToDownload(filesToUpload);\n\n    // Emit event when the users download files from url\n    if (files.length > 0) {\n      emitEvent('didSelectFile', { source: 'url', location: 'content-manager' });\n    }\n\n    try {\n      await Promise.all(\n        files.map(file => {\n          const { source } = file;\n\n          return axios\n            .get(file.fileURL, {\n              responseType: 'blob',\n              cancelToken: source.token,\n              timeout: 60000,\n            })\n            .then(({ data }) => {\n              const createdFile = new File([data], file.fileURL, {\n                type: data.type,\n              });\n\n              dispatch({\n                type: 'FILE_DOWNLOADED',\n                blob: createdFile,\n                originalIndex: file.originalIndex,\n                fileTempId: file.tempId,\n              });\n            })\n            .catch(err => {\n              console.error('fetch file error', err);\n\n              dispatch({\n                type: 'SET_FILE_TO_DOWNLOAD_ERROR',\n                originalIndex: file.originalIndex,\n                fileTempId: file.tempId,\n              });\n            });\n        })\n      );\n    } catch (err) {\n      // Silent\n    }\n  };\n\n  const handleRemoveFileToUpload = fileIndex => {\n    dispatch({\n      type: 'REMOVE_FILE_TO_UPLOAD',\n      fileIndex,\n    });\n  };\n\n  const handleModalTabChange = to => {\n    dispatch({\n      type: 'ON_CHANGE_MODAL_TAB',\n      to,\n    });\n  };\n\n  const handleClickNextButton = async () => {\n    try {\n      await urlSchema.validate(\n        { filesToDownload: filesToDownload.filter(url => !isEmpty(url)) },\n        { abortEarly: false }\n      );\n\n      setFormErrors(null);\n      // Navigate to next step\n      dispatch({\n        type: 'ADD_URLS_TO_FILES_TO_UPLOAD',\n        nextStep: 'upload',\n      });\n    } catch (err) {\n      const formattedErrors = getYupError(err);\n\n      setFormErrors(formattedErrors.filesToDownload);\n    }\n  };\n\n  const handleFileToEditChange = ({ target: { name, value } }) => {\n    let val = value;\n    let type = 'ON_CHANGE';\n\n    if (name === 'url') {\n      setFormErrors(null);\n\n      val = value.split('\\n');\n      type = 'ON_CHANGE_URLS_TO_DOWNLOAD';\n    }\n\n    dispatch({\n      type,\n      keys: name,\n      value: val,\n    });\n  };\n\n  const handleMoveAsset = (dragIndex, hoverIndex) => {\n    dispatch({\n      type: 'MOVE_ASSET',\n      dragIndex,\n      hoverIndex,\n    });\n  };\n\n  const toggleModalWarning = () => {\n    dispatch({\n      type: 'TOGGLE_MODAL_WARNING',\n    });\n  };\n\n  const submitEditNewFile = () => {\n    dispatch({\n      type: 'ON_SUBMIT_EDIT_NEW_FILE',\n    });\n  };\n\n  const submitEditExistingFile = () => {\n    dispatch({\n      type: 'ON_SUBMIT_EDIT_EXISTING_FILE',\n    });\n  };\n\n  const handleEditExistingFile = file => {\n    dispatch({\n      type: 'EDIT_EXISTING_FILE',\n      file,\n    });\n  };\n\n  const handleResetFileToEdit = () => {\n    dispatch({\n      type: 'RESET_FILE_TO_EDIT',\n    });\n  };\n\n  const removeFilter = index => {\n    dispatch({\n      type: 'REMOVE_FILTER',\n      filterToRemove: index,\n    });\n  };\n\n  const handleClose = () => {\n    setFormErrors(null);\n\n    dispatch({\n      type: 'RESET_PROPS',\n      defaultSort: `${updated_at}:DESC`,\n    });\n    onClosed();\n  };\n\n  const handleFileSelection = ({ target: { name } }) => {\n    dispatch({\n      type: 'ON_FILE_SELECTION',\n      id: name,\n    });\n  };\n\n  const handleAllFilesSelection = () => {\n    dispatch({\n      type: 'TOGGLE_SELECT_ALL',\n    });\n  };\n\n  const setParam = param => {\n    dispatch({\n      type: 'SET_PARAM',\n      param,\n    });\n  };\n\n  const goTo = to => {\n    dispatch({\n      type: 'GO_TO',\n      to,\n    });\n  };\n\n  const handleGoToEditNewFile = fileIndex => {\n    dispatch({\n      type: 'SET_NEW_FILE_TO_EDIT',\n      fileIndex,\n    });\n\n    goTo('edit-new');\n  };\n\n  const handleGoToEditFile = fileId => {\n    dispatch({\n      type: 'SET_FILE_TO_EDIT',\n      fileId,\n    });\n\n    goTo('edit');\n  };\n\n  const handleCleanFilesError = () => {\n    dispatch({\n      type: 'CLEAN_FILES_ERROR',\n    });\n  };\n\n  const handleSetCropResult = blob => {\n    // Emit event : the user cropped a file that is not uploaded\n    emitEvent('didCropFile', { duplicatedFile: null, location: 'content-manager' });\n\n    dispatch({\n      type: 'SET_CROP_RESULT',\n      blob,\n    });\n  };\n\n  const handleFormDisabled = isFormDisabled => {\n    dispatch({\n      type: 'SET_FORM_DISABLED',\n      isFormDisabled,\n    });\n  };\n\n  const handleAbortUpload = () => {\n    const { abortController } = fileToEdit;\n\n    abortController.abort();\n\n    dispatch({\n      type: 'ON_ABORT_UPLOAD',\n    });\n  };\n\n  const handleCancelFileToUpload = fileIndex => {\n    const fileToCancel = get(filesToUpload, fileIndex, {});\n\n    const { source } = fileToCancel;\n\n    // Cancel upload\n    if (source) {\n      // Cancel dowload file upload with axios\n      source.cancel('Operation canceled by the user.');\n    } else {\n      // Cancel uplodad file with fetch\n      fileToCancel.abortController.abort();\n    }\n\n    handleRemoveFileToUpload(fileIndex);\n  };\n\n  const getFilters = (filtersToOmit = []) => {\n    const compactedParams = compactParams(params);\n    const searchParams = generateSearchFromFilters(compactedParams, filtersToOmit);\n\n    return formatFilters(searchParams);\n  };\n\n  const fetchMediaLibFilesCount = async () => {\n    const requestURL = getRequestUrl('files/count');\n    const paramsToSend = getFilters(['_limit', '_sort', '_start']);\n\n    try {\n      return await request(`${requestURL}?${paramsToSend}`, {\n        method: 'GET',\n      });\n    } catch (err) {\n      console.error(err);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n\n      return 0;\n    }\n  };\n\n  const fetchMediaLib = async () => {\n    if (allowedActions.canRead) {\n      const [files, count] = await Promise.all([fetchMediaLibFiles(), fetchMediaLibFilesCount()]);\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        files,\n        countData: count,\n      });\n    }\n  };\n\n  const fetchMediaLibFiles = async () => {\n    const requestURL = getRequestUrl('files');\n    const paramsToSend = getFilters();\n\n    try {\n      return await request(`${requestURL}?${paramsToSend}`, {\n        method: 'GET',\n      });\n    } catch (err) {\n      console.error(err);\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n\n      return [];\n    }\n  };\n\n  const addFilesToUpload = ({ target: { value } }) => {\n    emitEvent('didSelectFile', { source: 'computer', location: 'content-manager' });\n\n    dispatch({\n      type: 'ADD_FILES_TO_UPLOAD',\n      filesToUpload: value,\n    });\n  };\n\n  const handleClearFilesToUploadAndDownload = () => {\n    dispatch({\n      type: 'CLEAR_FILES_TO_UPLOAD_AND_DOWNLOAD',\n    });\n  };\n\n  const handleSetFileToEditError = errorMessage => {\n    dispatch({\n      type: 'SET_FILE_TO_EDIT_ERROR',\n      errorMessage,\n    });\n  };\n\n  const handleUploadFiles = async () => {\n    dispatch({\n      type: 'SET_FILES_UPLOADING_STATE',\n    });\n\n    const requests = filesToUpload.map(\n      async ({ file, fileInfo, originalIndex, originalName, abortController }) => {\n        const formData = new FormData();\n        const headers = {};\n        const infos = clone(fileInfo);\n\n        if (originalName === infos.name) {\n          set(infos, 'name', null);\n        }\n\n        formData.append('files', file);\n        formData.append('fileInfo', JSON.stringify(infos));\n\n        try {\n          const uploadedFile = await request(\n            `/${pluginId}`,\n            {\n              method: 'POST',\n              headers,\n              body: formData,\n              signal: abortController.signal,\n            },\n            false,\n            false\n          );\n\n          const filesToSelect = uploadedFile.filter(file => {\n            const fileType = file.mime.split('/')[0];\n\n            if (allowedTypes.includes('file') && !['video', 'image'].includes(fileType)) {\n              return true;\n            }\n\n            return allowedTypes.length === 0 || allowedTypes.includes(fileType);\n          });\n\n          dispatch({\n            type: 'REMOVE_FILE_TO_UPLOAD',\n            fileIndex: originalIndex,\n            addToSelectedFiles: filesToSelect,\n            multiple,\n          });\n        } catch (err) {\n          const status = get(err, 'response.status', get(err, 'status', null));\n          const statusText = get(err, 'response.statusText', get(err, 'statusText', null));\n          let errorMessage = get(\n            err,\n            ['response', 'payload', 'message', '0', 'messages', '0', 'message'],\n            get(err, ['response', 'payload', 'message'], statusText)\n          );\n\n          // TODO fix errors globally when the back-end sends readable one\n          if (status === 413) {\n            errorMessage = formatMessage({ id: 'app.utils.errors.file-too-big.message' });\n          }\n\n          if (status) {\n            dispatch({\n              type: 'SET_FILE_ERROR',\n              fileIndex: originalIndex,\n              errorMessage,\n            });\n          }\n        }\n      }\n    );\n\n    await Promise.all(requests);\n  };\n\n  return (\n    <InputModalStepperContext.Provider\n      value={{\n        ...reducerState,\n        allowedActions,\n        addFilesToUpload,\n        downloadFiles,\n        fetchMediaLib,\n        formErrors,\n        goTo,\n        handleAbortUpload,\n        handleAllFilesSelection,\n        handleCancelFileToUpload,\n        handleClickNextButton,\n        handleCleanFilesError,\n        handleClearFilesToUploadAndDownload,\n        handleClose,\n        handleEditExistingFile,\n        handleFileSelection,\n        handleFileToEditChange,\n        handleFormDisabled,\n        handleGoToEditFile,\n        handleGoToEditNewFile,\n        handleModalTabChange,\n        handleRemoveFileToUpload,\n        handleResetFileToEdit,\n        handleSetCropResult,\n        handleUploadFiles,\n        handleSetFileToEditError,\n        moveAsset: handleMoveAsset,\n        multiple,\n        noNavigation,\n        onInputMediaChange,\n        removeFilter,\n        setParam,\n        submitEditNewFile,\n        submitEditExistingFile,\n        toggleModalWarning,\n      }}\n    >\n      {children}\n    </InputModalStepperContext.Provider>\n  );\n};\n\nInputModalStepperProvider.propTypes = {\n  allowedActions: PropTypes.shape({\n    canCopyLink: PropTypes.bool,\n    canCreate: PropTypes.bool,\n    canDownload: PropTypes.bool,\n    canMain: PropTypes.bool,\n    canRead: PropTypes.bool,\n    canSettings: PropTypes.bool,\n    canUpdate: PropTypes.bool,\n  }),\n  allowedTypes: PropTypes.arrayOf(PropTypes.string),\n  children: PropTypes.node.isRequired,\n  initialFilesToUpload: PropTypes.object,\n  initialFileToEdit: PropTypes.object,\n  isOpen: PropTypes.bool,\n  multiple: PropTypes.bool.isRequired,\n  noNavigation: PropTypes.bool,\n  onClosed: PropTypes.func.isRequired,\n  onInputMediaChange: PropTypes.func,\n  selectedFiles: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),\n  step: PropTypes.string.isRequired,\n};\n\nInputModalStepperProvider.defaultProps = {\n  allowedActions: {\n    canCopyLink: true,\n    canCreate: true,\n    canDownload: true,\n    canMain: true,\n    canRead: true,\n    canSettings: true,\n    canUpdate: true,\n  },\n  initialFileToEdit: null,\n  initialFilesToUpload: null,\n  isOpen: false,\n  noNavigation: false,\n  onInputMediaChange: () => {},\n  selectedFiles: null,\n  allowedTypes: [],\n};\n\nexport default InputModalStepperProvider;\n",
    "packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js": "import React, { useCallback, useEffect, useState, useReducer, useRef } from 'react';\nimport axios from 'axios';\nimport PropTypes from 'prop-types';\nimport { isEqual, isEmpty, get, set } from 'lodash';\nimport { Modal, ModalFooter, PopUpWarning, useGlobalContext, request } from 'strapi-helper-plugin';\nimport { Button } from '@buffetjs/core';\nimport pluginId from '../../pluginId';\nimport { getFilesToDownload, getTrad, getYupError, urlSchema } from '../../utils';\nimport { useAppContext } from '../../hooks';\nimport ModalHeader from '../../components/ModalHeader';\nimport stepper from './stepper';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\nconst ModalStepper = ({\n  initialFileToEdit,\n  initialStep,\n  isOpen,\n  onClosed,\n  onRemoveFileFromDataToDelete,\n  onToggle,\n}) => {\n  const { allowedActions } = useAppContext();\n  const { emitEvent, formatMessage } = useGlobalContext();\n  const [isWarningDeleteOpen, setIsWarningDeleteOpen] = useState(false);\n  const [showModalConfirmButtonLoading, setShowModalConfirmButtonLoading] = useState(false);\n  const [isFormDisabled, setIsFormDisabled] = useState(false);\n  const [formErrors, setFormErrors] = useState(null);\n  const [shouldRefetch, setShouldRefetch] = useState(false);\n  const [displayNextButton, setDisplayNextButton] = useState(false);\n  const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n  const { currentStep, fileToEdit, filesToDownload, filesToUpload } = reducerState.toJS();\n  const { Component, components, headerBreadcrumbs, next, prev, withBackButton } = stepper[\n    currentStep\n  ];\n  const filesToUploadLength = filesToUpload.length;\n  const toggleRef = useRef(onToggle);\n  const editModalRef = useRef();\n  const downloadFilesRef = useRef();\n\n  useEffect(() => {\n    if (currentStep === 'upload') {\n      // Close the modal\n      if (filesToUploadLength === 0) {\n        // Passing true to the onToggle prop will refetch the data when the modal closes\n        toggleRef.current(true);\n      } else {\n        // Download files from url\n        downloadFilesRef.current();\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filesToUploadLength, currentStep]);\n\n  useEffect(() => {\n    if (isOpen) {\n      goTo(initialStep);\n\n      if (initialFileToEdit) {\n        dispatch({\n          type: 'INIT_FILE_TO_EDIT',\n          fileToEdit: initialFileToEdit,\n        });\n      }\n    }\n    // Disabling the rule because we just want to let the ability to open the modal\n    // at a specific step then we will let the stepper handle the navigation\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen]);\n\n  const addFilesToUpload = ({ target: { value } }) => {\n    emitEvent('didSelectFile', { source: 'computer', location: 'upload' });\n\n    dispatch({\n      type: 'ADD_FILES_TO_UPLOAD',\n      filesToUpload: value,\n    });\n\n    goTo(next);\n  };\n\n  downloadFilesRef.current = async () => {\n    const files = getFilesToDownload(filesToUpload);\n\n    // Emit event when the users download files from url\n    if (files.length > 0) {\n      emitEvent('didSelectFile', { source: 'url', location: 'upload' });\n    }\n\n    try {\n      await Promise.all(\n        files.map(file => {\n          const { source } = file;\n\n          return axios\n            .get(file.fileURL, {\n              responseType: 'blob',\n              cancelToken: source.token,\n              timeout: 60000,\n            })\n            .then(({ data }) => {\n              const fileName = file.fileInfo.name;\n              const createdFile = new File([data], fileName, {\n                type: data.type,\n              });\n\n              dispatch({\n                type: 'FILE_DOWNLOADED',\n                blob: createdFile,\n                originalIndex: file.originalIndex,\n                fileTempId: file.tempId,\n              });\n            })\n            .catch(err => {\n              console.error('fetch file error', err);\n\n              dispatch({\n                type: 'SET_FILE_TO_DOWNLOAD_ERROR',\n                originalIndex: file.originalIndex,\n                fileTempId: file.tempId,\n              });\n            });\n        })\n      );\n    } catch (err) {\n      // Silent\n    }\n  };\n\n  const handleAbortUpload = () => {\n    const { abortController } = fileToEdit;\n\n    abortController.abort();\n\n    dispatch({\n      type: 'ON_ABORT_UPLOAD',\n    });\n  };\n\n  const handleCancelFileToUpload = fileOriginalIndex => {\n    const fileToCancel = filesToUpload.find(file => file.originalIndex === fileOriginalIndex);\n    const { source } = fileToCancel;\n\n    // Cancel\n    if (source) {\n      // Cancel dowload file upload with axios\n      source.cancel('Operation canceled by the user.');\n    } else {\n      // Cancel upload with fetch\n      fileToCancel.abortController.abort();\n    }\n\n    dispatch({\n      type: 'REMOVE_FILE_TO_UPLOAD',\n      fileIndex: fileOriginalIndex,\n    });\n  };\n\n  const handleChange = ({ target: { name, value } }) => {\n    let val = value;\n    let type = 'ON_CHANGE';\n\n    if (name === 'url') {\n      setFormErrors(null);\n\n      val = value.split('\\n');\n      type = 'ON_CHANGE_URLS_TO_DOWNLOAD';\n    }\n\n    dispatch({\n      type,\n      keys: name,\n      value: val,\n    });\n  };\n\n  const handleConfirmDeleteFile = useCallback(async () => {\n    const { id } = fileToEdit;\n    // Remove the file from the selected data to delete\n    onRemoveFileFromDataToDelete(id);\n\n    // Show a loader in the popup warning\n    setShowModalConfirmButtonLoading(true);\n\n    try {\n      await request(`/${pluginId}/files/${id}`, {\n        method: 'DELETE',\n      });\n\n      setShouldRefetch(true);\n    } catch (err) {\n      const errorMessage = get(err, 'response.payload.message', 'An error occured');\n\n      strapi.notification.toggle({\n        type: 'warning',\n        message: errorMessage,\n      });\n    } finally {\n      setShowModalConfirmButtonLoading(true);\n      toggleModalWarning();\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [fileToEdit]);\n\n  const handleClickNextButton = async () => {\n    try {\n      await urlSchema.validate(\n        { filesToDownload: filesToDownload.filter(url => !isEmpty(url)) },\n        { abortEarly: false }\n      );\n\n      setFormErrors(null);\n      // Navigate to next step\n      dispatch({\n        type: 'ADD_URLS_TO_FILES_TO_UPLOAD',\n        nextStep: next,\n      });\n    } catch (err) {\n      const formattedErrors = getYupError(err);\n\n      setFormErrors(formattedErrors.filesToDownload);\n    }\n  };\n\n  const handleClickDeleteFile = async () => {\n    toggleModalWarning();\n  };\n\n  const handleClickDeleteFileToUpload = fileIndex => {\n    dispatch({\n      type: 'REMOVE_FILE_TO_UPLOAD',\n      fileIndex,\n    });\n\n    if (currentStep === 'edit-new') {\n      dispatch({\n        type: 'RESET_FILE_TO_EDIT',\n      });\n\n      goNext();\n    }\n  };\n\n  const handleClose = () => {\n    onClosed();\n    setIsFormDisabled(false);\n    setDisplayNextButton(false);\n    setFormErrors(null);\n    setShouldRefetch(false);\n\n    dispatch({\n      type: 'RESET_PROPS',\n    });\n  };\n\n  const handleCloseModalWarning = async () => {\n    setShowModalConfirmButtonLoading(false);\n\n    onToggle(shouldRefetch);\n  };\n\n  const handleGoToEditNewFile = fileIndex => {\n    dispatch({\n      type: 'SET_FILE_TO_EDIT',\n      fileIndex,\n    });\n\n    goTo('edit-new');\n  };\n\n  const handleGoToAddBrowseFiles = () => {\n    dispatch({\n      type: 'CLEAN_FILES_ERROR',\n    });\n\n    goBack();\n  };\n\n  const handleSetCropResult = blob => {\n    // Emit event : the user cropped a file that is not uploaded\n    emitEvent('didCropFile', { duplicatedFile: null, location: 'upload' });\n\n    dispatch({\n      type: 'SET_CROP_RESULT',\n      blob,\n    });\n  };\n\n  const handleSubmitEditNewFile = e => {\n    e.preventDefault();\n\n    dispatch({\n      type: 'ON_SUBMIT_EDIT_NEW_FILE',\n    });\n\n    goNext();\n  };\n\n  const handleSubmitEditExistingFile = async (\n    e,\n    shouldDuplicateMedia = false,\n    file = fileToEdit.file,\n    isSubmittingAfterCrop = false\n  ) => {\n    e.preventDefault();\n\n    if (isSubmittingAfterCrop) {\n      emitEvent('didCropFile', { duplicatedFile: shouldDuplicateMedia, location: 'upload' });\n    }\n\n    dispatch({\n      type: 'ON_SUBMIT_EDIT_EXISTING_FILE',\n    });\n\n    const headers = {};\n    const formData = new FormData();\n\n    // If the file has been cropped we need to add it to the formData\n    // otherwise we just don't send it\n    const didCropFile = file instanceof File;\n    const { abortController, id, fileInfo } = fileToEdit;\n    const requestURL = shouldDuplicateMedia ? `/${pluginId}` : `/${pluginId}?id=${id}`;\n\n    if (didCropFile) {\n      formData.append('files', file);\n    }\n\n    formData.append('fileInfo', JSON.stringify(fileInfo));\n\n    try {\n      await request(\n        requestURL,\n        {\n          method: 'POST',\n          headers,\n          body: formData,\n          signal: abortController.signal,\n        },\n        false,\n        false\n      );\n      // Close the modal and refetch data\n      toggleRef.current(true);\n    } catch (err) {\n      console.error(err);\n      const status = get(err, 'response.status', get(err, 'status', null));\n      const statusText = get(err, 'response.statusText', get(err, 'statusText', null));\n      let errorMessage = get(\n        err,\n        ['response', 'payload', 'message', '0', 'messages', '0', 'message'],\n        get(err, ['response', 'payload', 'message'], statusText)\n      );\n\n      // TODO fix errors globally when the back-end sends readable one\n      if (status === 413) {\n        errorMessage = formatMessage({ id: 'app.utils.errors.file-too-big.message' });\n      }\n\n      if (status) {\n        dispatch({\n          type: 'SET_FILE_TO_EDIT_ERROR',\n          errorMessage,\n        });\n      }\n    }\n  };\n\n  const handleReplaceMedia = () => {\n    emitEvent('didReplaceMedia', { location: 'upload' });\n    editModalRef.current.click();\n  };\n\n  const handleToggle = () => {\n    if (filesToUploadLength > 0) {\n      // eslint-disable-next-line no-alert\n      const confirm = window.confirm(\n        formatMessage({ id: getTrad('window.confirm.close-modal.files') })\n      );\n\n      if (!confirm) {\n        return;\n      }\n    }\n\n    if (!isEqual(initialFileToEdit, fileToEdit) && currentStep === 'edit') {\n      // eslint-disable-next-line no-alert\n      const confirm = window.confirm(\n        formatMessage({ id: getTrad('window.confirm.close-modal.file') })\n      );\n\n      if (!confirm) {\n        return;\n      }\n    }\n\n    onToggle(shouldRefetch);\n  };\n\n  const handleUploadFiles = async () => {\n    dispatch({\n      type: 'SET_FILES_UPLOADING_STATE',\n    });\n\n    const requests = filesToUpload.map(\n      async ({ file, fileInfo, originalName, originalIndex, abortController }) => {\n        const formData = new FormData();\n        const headers = {};\n\n        if (originalName === fileInfo.name) {\n          set(fileInfo, 'name', null);\n        }\n\n        formData.append('files', file);\n        formData.append('fileInfo', JSON.stringify(fileInfo));\n\n        try {\n          await request(\n            `/${pluginId}`,\n            {\n              method: 'POST',\n              headers,\n              body: formData,\n              signal: abortController.signal,\n            },\n            false,\n            false\n          );\n\n          setShouldRefetch(true);\n\n          dispatch({\n            type: 'REMOVE_FILE_TO_UPLOAD',\n            fileIndex: originalIndex,\n          });\n        } catch (err) {\n          console.error(err);\n          const status = get(err, 'response.status', get(err, 'status', null));\n          const statusText = get(err, 'response.statusText', get(err, 'statusText', null));\n          let errorMessage = get(\n            err,\n            ['response', 'payload', 'message', '0', 'messages', '0', 'message'],\n            get(err, ['response', 'payload', 'message'], statusText)\n          );\n\n          // TODO fix errors globally when the back-end sends readable one\n          if (status === 413) {\n            errorMessage = formatMessage({ id: 'app.utils.errors.file-too-big.message' });\n          }\n\n          if (status) {\n            dispatch({\n              type: 'SET_FILE_ERROR',\n              fileIndex: originalIndex,\n              errorMessage,\n            });\n          }\n        }\n      }\n    );\n\n    await Promise.all(requests);\n  };\n\n  const goBack = () => {\n    goTo(prev);\n  };\n\n  const goNext = () => {\n    if (next === null) {\n      onToggle();\n\n      return;\n    }\n\n    goTo(next);\n  };\n\n  const goTo = to => {\n    dispatch({\n      type: 'GO_TO',\n      to,\n    });\n  };\n\n  const toggleModalWarning = () => {\n    setIsWarningDeleteOpen(prev => !prev);\n  };\n\n  const shouldDisplayNextButton = currentStep === 'browse' && displayNextButton;\n  const isFinishButtonDisabled = filesToUpload.some(file => file.isDownloading || file.isUploading);\n  const areButtonsDisabledOnEditExistingFile =\n    currentStep === 'edit' && fileToEdit.isUploading === true;\n\n  return (\n    <>\n      <Modal isOpen={isOpen} onToggle={handleToggle} onClosed={handleClose}>\n        {/* header title */}\n        <ModalHeader\n          goBack={goBack}\n          headerBreadcrumbs={headerBreadcrumbs}\n          withBackButton={withBackButton}\n        />\n\n        {/* body of the modal */}\n        {Component && (\n          <Component\n            {...allowedActions}\n            onAbortUpload={handleAbortUpload}\n            addFilesToUpload={addFilesToUpload}\n            fileToEdit={fileToEdit}\n            filesToDownload={filesToDownload}\n            filesToUpload={filesToUpload}\n            formErrors={formErrors}\n            components={components}\n            isEditingUploadedFile={currentStep === 'edit'}\n            isFormDisabled={isFormDisabled}\n            onChange={handleChange}\n            onClickCancelUpload={handleCancelFileToUpload}\n            onClickDeleteFileToUpload={\n              currentStep === 'edit' ? handleClickDeleteFile : handleClickDeleteFileToUpload\n            }\n            onClickEditNewFile={handleGoToEditNewFile}\n            onGoToAddBrowseFiles={handleGoToAddBrowseFiles}\n            onSubmitEdit={\n              currentStep === 'edit' ? handleSubmitEditExistingFile : handleSubmitEditNewFile\n            }\n            onToggle={handleToggle}\n            toggleDisableForm={setIsFormDisabled}\n            ref={currentStep === 'edit' ? editModalRef : null}\n            setCropResult={handleSetCropResult}\n            setShouldDisplayNextButton={setDisplayNextButton}\n            withBackButton={withBackButton}\n          />\n        )}\n\n        <ModalFooter>\n          <section>\n            <Button type=\"button\" color=\"cancel\" onClick={handleToggle}>\n              {formatMessage({ id: 'app.components.Button.cancel' })}\n            </Button>\n            {shouldDisplayNextButton && (\n              <Button\n                type=\"button\"\n                color=\"primary\"\n                onClick={handleClickNextButton}\n                disabled={isEmpty(filesToDownload)}\n              >\n                {formatMessage({ id: getTrad('button.next') })}\n              </Button>\n            )}\n            {currentStep === 'upload' && (\n              <Button\n                type=\"button\"\n                color=\"success\"\n                onClick={handleUploadFiles}\n                disabled={isFinishButtonDisabled}\n              >\n                {formatMessage(\n                  {\n                    id: getTrad(\n                      `modal.upload-list.footer.button.${\n                        filesToUploadLength > 1 ? 'plural' : 'singular'\n                      }`\n                    ),\n                  },\n                  { number: filesToUploadLength }\n                )}\n              </Button>\n            )}\n            {currentStep === 'edit-new' && (\n              <Button color=\"success\" type=\"button\" onClick={handleSubmitEditNewFile}>\n                {formatMessage({ id: 'form.button.finish' })}\n              </Button>\n            )}\n            {currentStep === 'edit' && (\n              <div style={{ margin: 'auto 0' }}>\n                <Button\n                  disabled={isFormDisabled || areButtonsDisabledOnEditExistingFile}\n                  color=\"primary\"\n                  onClick={handleReplaceMedia}\n                  style={{ marginRight: 10 }}\n                >\n                  {formatMessage({ id: getTrad('control-card.replace-media') })}\n                </Button>\n\n                <Button\n                  disabled={isFormDisabled || areButtonsDisabledOnEditExistingFile}\n                  color=\"success\"\n                  type=\"button\"\n                  onClick={handleSubmitEditExistingFile}\n                >\n                  {formatMessage({ id: 'form.button.finish' })}\n                </Button>\n              </div>\n            )}\n          </section>\n        </ModalFooter>\n      </Modal>\n      <PopUpWarning\n        onClosed={handleCloseModalWarning}\n        isOpen={isWarningDeleteOpen}\n        toggleModal={toggleModalWarning}\n        popUpWarningType=\"danger\"\n        onConfirm={handleConfirmDeleteFile}\n        isConfirmButtonLoading={showModalConfirmButtonLoading}\n      />\n    </>\n  );\n};\n\nModalStepper.defaultProps = {\n  initialFileToEdit: null,\n  initialStep: 'browse',\n  onClosed: () => {},\n  onRemoveFileFromDataToDelete: () => {},\n  onToggle: () => {},\n};\n\nModalStepper.propTypes = {\n  initialFileToEdit: PropTypes.object,\n  initialStep: PropTypes.string,\n  isOpen: PropTypes.bool.isRequired,\n  onClosed: PropTypes.func,\n  onRemoveFileFromDataToDelete: PropTypes.func,\n  onToggle: PropTypes.func,\n};\n\nexport default ModalStepper;\n",
    "packages/strapi-plugin-upload/admin/src/containers/SettingsPage/index.js": "import React, { useEffect, useReducer, useRef } from 'react';\nimport { Header, Inputs } from '@buffetjs/custom';\nimport { isEqual } from 'lodash';\nimport { LoadingIndicatorPage, useGlobalContext, request } from 'strapi-helper-plugin';\n\nimport { getRequestUrl, getTrad } from '../../utils';\nimport Text from '../../components/Text';\n// import Divider from './Divider';\nimport SectionTitleWrapper from './SectionTitleWrapper';\nimport Wrapper from './Wrapper';\nimport init from './init';\nimport reducer, { initialState } from './reducer';\n\nconst SettingsPage = () => {\n  const { formatMessage } = useGlobalContext();\n  const [reducerState, dispatch] = useReducer(reducer, initialState, init);\n  const { initialData, isLoading, modifiedData } = reducerState.toJS();\n  const isMounted = useRef(true);\n  const getDataRef = useRef();\n  const abortController = new AbortController();\n\n  getDataRef.current = async () => {\n    try {\n      const { signal } = abortController;\n      const { data } = await request(getRequestUrl('settings', { method: 'GET', signal }));\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n        });\n      }\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  useEffect(() => {\n    getDataRef.current();\n\n    return () => {\n      abortController.abort();\n      isMounted.current = false;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handleSubmit = async () => {\n    try {\n      await request(getRequestUrl('settings'), {\n        method: 'PUT',\n        body: modifiedData,\n      });\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'SUBMIT_SUCCEEDED',\n        });\n      }\n\n      strapi.notification.toggle({\n        type: 'success',\n        message: { id: 'notification.form.success.fields' },\n      });\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  const headerProps = {\n    title: {\n      label: formatMessage({ id: getTrad('settings.header.label') }),\n    },\n    content: formatMessage({\n      id: getTrad('settings.sub-header.label'),\n    }),\n    actions: [\n      {\n        color: 'cancel',\n        disabled: isEqual(initialData, modifiedData),\n        // TradId from the strapi-admin package\n        label: formatMessage({ id: 'app.components.Button.cancel' }),\n        onClick: () => {\n          dispatch({\n            type: 'CANCEL_CHANGES',\n          });\n        },\n        type: 'button',\n      },\n      {\n        disabled: false,\n        color: 'success',\n        // TradId from the strapi-admin package\n        label: formatMessage({ id: 'app.components.Button.save' }),\n        onClick: handleSubmit,\n        type: 'button',\n      },\n    ],\n  };\n\n  const handleChange = ({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name,\n      value,\n    });\n  };\n\n  if (isLoading) {\n    return <LoadingIndicatorPage />;\n  }\n\n  return (\n    <>\n      <Header {...headerProps} />\n      <Wrapper>\n        <div className=\"container-fluid\">\n          <div className=\"row\">\n            <SectionTitleWrapper className=\"col-12\">\n              <Text fontSize=\"xs\" fontWeight=\"semiBold\" color=\"#787E8F\">\n                {formatMessage({ id: getTrad('settings.section.image.label') })}\n              </Text>\n            </SectionTitleWrapper>\n            <div className=\"col-6\">\n              <Inputs\n                label={formatMessage({\n                  id: getTrad('settings.form.responsiveDimensions.label'),\n                })}\n                description={formatMessage({\n                  id: getTrad('settings.form.responsiveDimensions.description'),\n                })}\n                name=\"responsiveDimensions\"\n                onChange={handleChange}\n                type=\"bool\"\n                value={modifiedData.responsiveDimensions}\n              />\n            </div>\n            <div className=\"col-6\">\n              <Inputs\n                label={formatMessage({\n                  id: getTrad('settings.form.sizeOptimization.label'),\n                })}\n                name=\"sizeOptimization\"\n                onChange={handleChange}\n                type=\"bool\"\n                value={modifiedData.sizeOptimization}\n              />\n            </div>\n          </div>\n          <div className=\"row\">\n            <div className=\"col-6\">\n              <Inputs\n                label={formatMessage({\n                  id: getTrad('settings.form.autoOrientation.label'),\n                })}\n                description={formatMessage({\n                  id: getTrad('settings.form.autoOrientation.description'),\n                })}\n                name=\"autoOrientation\"\n                onChange={handleChange}\n                type=\"bool\"\n                value={modifiedData.autoOrientation}\n              />\n            </div>\n          </div>\n\n          {/*\n          <Divider />\n          <div className=\"row\">\n            <SectionTitleWrapper className=\"col-12\">\n              <Text fontSize=\"xs\" fontWeight=\"semiBold\" color=\"#787E8F\">\n                {formatMessage({ id: getTrad('settings.section.video.label') })}\n              </Text>\n            </SectionTitleWrapper>\n            <div className=\"col-6\">\n              <Inputs\n                label={formatMessage({\n                  id: getTrad('settings.form.videoPreview.label'),\n                })}\n                description={formatMessage({\n                  id: getTrad('settings.form.videoPreview.description'),\n                })}\n                name=\"videoPreview\"\n                onChange={handleChange}\n                type=\"bool\"\n                value={modifiedData.videoPreview}\n              />\n            </div>\n          </div> */}\n        </div>\n      </Wrapper>\n    </>\n  );\n};\n\nexport default SettingsPage;\n",
    "packages/strapi-plugin-upload/config/functions/bootstrap.js": "'use strict';\n\nconst { convertToStrapiError } = require('../../errors');\n\nmodule.exports = async () => {\n  // set plugin store\n  const configurator = strapi.store({\n    type: 'plugin',\n    name: 'upload',\n    key: 'settings',\n  });\n\n  strapi.plugins.upload.provider = createProvider(strapi.plugins.upload.config || {});\n\n  // if provider config does not exist set one by default\n  const config = await configurator.get();\n\n  if (!config) {\n    await configurator.set({\n      value: {\n        sizeOptimization: true,\n        responsiveDimensions: true,\n      },\n    });\n  }\n\n  await pruneObsoleteRelations();\n  registerPermissionActions();\n};\n\nconst wrapFunctionForErrors = fn => async (...args) => {\n  try {\n    return await fn(...args);\n  } catch (err) {\n    throw convertToStrapiError(err);\n  }\n};\n\nconst createProvider = ({ provider, providerOptions, actionOptions = {} }) => {\n  try {\n    const providerInstance = require(`strapi-provider-upload-${provider}`).init(providerOptions);\n\n    return Object.assign(Object.create(baseProvider), {\n      ...providerInstance,\n      upload: wrapFunctionForErrors((file, options = actionOptions.upload) => {\n        return providerInstance.upload(file, options);\n      }),\n      delete: wrapFunctionForErrors((file, options = actionOptions.delete) => {\n        return providerInstance.delete(file, options);\n      }),\n    });\n  } catch (err) {\n    strapi.log.error(err);\n    throw new Error(\n      `The provider package isn't installed. Please run \\`npm install strapi-provider-upload-${provider}\\``\n    );\n  }\n};\n\nconst baseProvider = {\n  extend(obj) {\n    Object.assign(this, obj);\n  },\n  upload() {\n    throw new Error('Provider upload method is not implemented');\n  },\n  delete() {\n    throw new Error('Provider delete method is not implemented');\n  },\n};\n\nconst pruneObsoleteRelations = async () => {\n  const { upload: plugin } = strapi.plugins;\n  const modelIsNotDefined = !plugin || !plugin.models || !plugin.models.file;\n\n  if (modelIsNotDefined) {\n    return Promise.resolve();\n  }\n\n  await strapi.query('file', 'upload').custom(pruneObsoleteRelationsQuery)();\n};\n\nconst pruneObsoleteRelationsQuery = ({ model }) => {\n  if (model.orm !== 'mongoose') {\n    return Promise.resolve();\n  }\n\n  const models = Array.from(strapi.db.models.values());\n  const modelsId = models.map(model => model.globalId);\n\n  return model.updateMany(\n    { related: { $elemMatch: { kind: { $nin: modelsId } } } },\n    { $pull: { related: { kind: { $nin: modelsId } } } }\n  );\n};\n\nconst registerPermissionActions = () => {\n  const actions = [\n    {\n      section: 'plugins',\n      displayName: 'Access the Media Library',\n      uid: 'read',\n      pluginName: 'upload',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Create (upload)',\n      uid: 'assets.create',\n      subCategory: 'assets',\n      pluginName: 'upload',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Update (crop, details, replace) + delete',\n      uid: 'assets.update',\n      subCategory: 'assets',\n      pluginName: 'upload',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Download',\n      uid: 'assets.download',\n      subCategory: 'assets',\n      pluginName: 'upload',\n    },\n    {\n      section: 'plugins',\n      displayName: 'Copy link',\n      uid: 'assets.copy-link',\n      subCategory: 'assets',\n      pluginName: 'upload',\n    },\n    {\n      section: 'settings',\n      displayName: 'Access the Media Library settings page',\n      uid: 'settings.read',\n      category: 'media library',\n      pluginName: 'upload',\n    },\n  ];\n\n  const { actionProvider } = strapi.admin.services.permission;\n  actionProvider.register(actions);\n};\n",
    "packages/strapi-plugin-upload/config/schema.graphql.js": "'use strict';\n\nconst _ = require('lodash');\nconst { streamToBuffer } = require('../utils/file');\n\nmodule.exports = {\n  definition: `\n    input FileInfoInput {\n      name: String\n      alternativeText: String\n      caption: String\n    }\n  `,\n  mutation: `\n    upload(refId: ID, ref: String, field: String, source: String, info: FileInfoInput, file: Upload!): UploadFile!\n    multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!\n    updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!\n  `,\n  resolver: {\n    Query: {\n      file: false,\n      files: {\n        resolver: 'plugins::upload.upload.find',\n      },\n    },\n    Mutation: {\n      createFile: false,\n      updateFile: false,\n      upload: {\n        description: 'Upload one file',\n        resolverOf: 'plugins::upload.upload.upload',\n        resolver: async (obj, { file: upload, info, ...fields }) => {\n          const file = await formatFile(upload, info, fields);\n\n          const uploadedFiles = await strapi.plugins.upload.services.upload.uploadFileAndPersist(\n            file\n          );\n\n          // Return response.\n          return uploadedFiles.length === 1 ? uploadedFiles[0] : uploadedFiles;\n        },\n      },\n      multipleUpload: {\n        description: 'Upload one file',\n        resolverOf: 'plugins::upload.upload.upload',\n        resolver: async (obj, { files: uploads, ...fields }) => {\n          const files = await Promise.all(uploads.map(upload => formatFile(upload, {}, fields)));\n\n          const uploadService = strapi.plugins.upload.services.upload;\n\n          return Promise.all(files.map(file => uploadService.uploadFileAndPersist(file)));\n        },\n      },\n      updateFileInfo: {\n        description: 'Update file information',\n        resolverOf: 'plugins::upload.upload.upload',\n        resolver: async (obj, { id, info }) => {\n          return await strapi.plugins.upload.services.upload.updateFileInfo(id, info);\n        },\n      },\n      deleteFile: {\n        description: 'Delete one file',\n        resolverOf: 'plugins::upload.upload.destroy',\n        resolver: async (obj, options, { context }) => {\n          const file = await strapi.plugins.upload.services.upload.fetch({ id: context.params.id });\n          if (file) {\n            const fileResult = await strapi.plugins.upload.services.upload.remove(file);\n            return { file: fileResult };\n          }\n        },\n      },\n    },\n  },\n};\n\nconst formatFile = async (upload, extraInfo, metas) => {\n  const { filename, mimetype, createReadStream } = await upload;\n\n  const { optimize } = strapi.plugins.upload.services['image-manipulation'];\n  const readBuffer = await streamToBuffer(createReadStream());\n\n  const { buffer, info } = await optimize(readBuffer);\n\n  const uploadService = strapi.plugins.upload.services.upload;\n  const fileInfo = uploadService.formatFileInfo(\n    {\n      filename,\n      type: mimetype,\n      size: buffer.length,\n    },\n    extraInfo || {},\n    metas\n  );\n\n  return _.assign(fileInfo, info, { buffer });\n};\n",
    "packages/strapi-plugin-upload/controllers/Upload.js": "'use strict';\n\n/**\n * Upload.js controller\n *\n */\n\nconst _ = require('lodash');\nconst { sanitizeEntity } = require('strapi-utils');\nconst apiUploadController = require('./upload/api');\nconst adminUploadController = require('./upload/admin');\n\nconst resolveController = ctx => {\n  const {\n    state: { isAuthenticatedAdmin },\n  } = ctx;\n\n  return isAuthenticatedAdmin ? adminUploadController : apiUploadController;\n};\n\nconst resolveControllerMethod = method => ctx => {\n  const controller = resolveController(ctx);\n  const callbackFn = controller[method];\n\n  if (!_.isFunction(callbackFn)) {\n    return ctx.notFound();\n  }\n\n  return callbackFn(ctx);\n};\n\nmodule.exports = {\n  find: resolveControllerMethod('find'),\n  findOne: resolveControllerMethod('findOne'),\n  count: resolveControllerMethod('count'),\n  destroy: resolveControllerMethod('destroy'),\n  updateSettings: resolveControllerMethod('updateSettings'),\n  getSettings: resolveControllerMethod('getSettings'),\n\n  async upload(ctx) {\n    const isUploadDisabled = _.get(strapi.plugins, 'upload.config.enabled', true) === false;\n\n    if (isUploadDisabled) {\n      throw strapi.errors.badRequest(null, {\n        errors: [{ id: 'Upload.status.disabled', message: 'File upload is disabled' }],\n      });\n    }\n\n    const {\n      query: { id },\n      request: { files: { files } = {} },\n    } = ctx;\n    const controller = resolveController(ctx);\n\n    if (id && (_.isEmpty(files) || files.size === 0)) {\n      return controller.updateFileInfo(ctx);\n    }\n\n    if (_.isEmpty(files) || files.size === 0) {\n      throw strapi.errors.badRequest(null, {\n        errors: [{ id: 'Upload.status.empty', message: 'Files are empty' }],\n      });\n    }\n\n    await (id ? controller.replaceFile : controller.uploadFiles)(ctx);\n  },\n\n  async search(ctx) {\n    const { id } = ctx.params;\n    const model = strapi.getModel('file', 'upload');\n    const entries = await strapi.query('file', 'upload').custom(searchQueries)({\n      id,\n    });\n\n    ctx.body = sanitizeEntity(entries, { model });\n  },\n};\n\nconst searchQueries = {\n  bookshelf({ model }) {\n    return ({ id }) => {\n      return model\n        .query(qb => {\n          qb.whereRaw('LOWER(hash) LIKE ?', [`%${id}%`]).orWhereRaw('LOWER(name) LIKE ?', [\n            `%${id}%`,\n          ]);\n        })\n        .fetchAll()\n        .then(results => results.toJSON());\n    };\n  },\n  mongoose({ model }) {\n    return ({ id }) => {\n      const re = new RegExp(id, 'i');\n\n      return model\n        .find({\n          $or: [{ hash: re }, { name: re }],\n        })\n        .lean();\n    };\n  },\n};\n",
    "packages/strapi-plugin-upload/controllers/upload/admin.js": "'use strict';\n\nconst _ = require('lodash');\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\nconst validateSettings = require('../validation/settings');\nconst validateUploadBody = require('../validation/upload');\n\nconst { CREATED_BY_ATTRIBUTE } = contentTypesUtils.constants;\n\nconst ACTIONS = {\n  read: 'plugins::upload.read',\n  readSettings: 'plugins::upload.settings.read',\n  create: 'plugins::upload.assets.create',\n  update: 'plugins::upload.assets.update',\n  download: 'plugins::upload.assets.download',\n  copyLink: 'plugins::upload.assets.copy-link',\n};\n\nconst fileModel = 'plugins::upload.file';\n\nmodule.exports = {\n  async find(ctx) {\n    const {\n      state: { userAbility },\n    } = ctx;\n\n    const pm = strapi.admin.services.permission.createPermissionsManager({\n      ability: userAbility,\n      action: ACTIONS.read,\n      model: fileModel,\n    });\n\n    if (!pm.isAllowed) {\n      return ctx.forbidden();\n    }\n\n    const method = _.has(ctx.query, '_q') ? 'search' : 'fetchAll';\n\n    const query = pm.queryFrom(ctx.query);\n    const files = await strapi.plugins.upload.services.upload[method](query);\n\n    ctx.body = pm.sanitize(files, { withPrivate: false });\n  },\n\n  async findOne(ctx) {\n    const {\n      state: { userAbility },\n      params: { id },\n    } = ctx;\n\n    const { pm, file } = await findEntityAndCheckPermissions(\n      userAbility,\n      ACTIONS.read,\n      fileModel,\n      id\n    );\n\n    ctx.body = pm.sanitize(file, { withPrivate: false });\n  },\n\n  async count(ctx) {\n    const pm = strapi.admin.services.permission.createPermissionsManager({\n      ability: ctx.state.userAbility,\n      action: ACTIONS.read,\n      model: fileModel,\n    });\n\n    if (!pm.isAllowed) {\n      return ctx.forbidden();\n    }\n\n    const method = _.has(ctx.query, '_q') ? 'countSearch' : 'count';\n    const query = pm.queryFrom(ctx.query);\n\n    const count = await strapi.plugins.upload.services.upload[method](query);\n\n    ctx.body = { count };\n  },\n\n  async destroy(ctx) {\n    const {\n      state: { userAbility },\n      params: { id },\n    } = ctx;\n\n    const { pm, file } = await findEntityAndCheckPermissions(\n      userAbility,\n      ACTIONS.update,\n      fileModel,\n      id\n    );\n\n    await strapi.plugins['upload'].services.upload.remove(file);\n\n    ctx.body = pm.sanitize(file, { action: ACTIONS.read, withPrivate: false });\n  },\n\n  async updateSettings(ctx) {\n    const {\n      request: { body },\n      state: { userAbility },\n    } = ctx;\n\n    if (userAbility.cannot(ACTIONS.readSettings, fileModel)) {\n      return ctx.forbidden();\n    }\n\n    const data = await validateSettings(body);\n\n    await strapi.plugins.upload.services.upload.setSettings(data);\n\n    ctx.body = { data };\n  },\n\n  async getSettings(ctx) {\n    const {\n      state: { userAbility },\n    } = ctx;\n\n    if (userAbility.cannot(ACTIONS.readSettings, fileModel)) {\n      return ctx.forbidden();\n    }\n\n    const data = await strapi.plugins.upload.services.upload.getSettings();\n\n    ctx.body = { data };\n  },\n\n  async updateFileInfo(ctx) {\n    const {\n      state: { userAbility, user },\n      query: { id },\n      request: { body },\n    } = ctx;\n\n    const uploadService = strapi.plugins.upload.services.upload;\n    const { pm } = await findEntityAndCheckPermissions(userAbility, ACTIONS.update, fileModel, id);\n\n    const data = await validateUploadBody(body);\n    const file = await uploadService.updateFileInfo(id, data.fileInfo, { user });\n\n    ctx.body = pm.sanitize(file, { action: ACTIONS.read, withPrivate: false });\n  },\n\n  async replaceFile(ctx) {\n    const {\n      state: { userAbility, user },\n      query: { id },\n      request: { body, files: { files } = {} },\n    } = ctx;\n\n    const uploadService = strapi.plugins.upload.services.upload;\n    const { pm } = await findEntityAndCheckPermissions(userAbility, ACTIONS.update, fileModel, id);\n\n    if (Array.isArray(files)) {\n      throw strapi.errors.badRequest(null, {\n        errors: [\n          { id: 'Upload.replace.single', message: 'Cannot replace a file with multiple ones' },\n        ],\n      });\n    }\n\n    const data = await validateUploadBody(body);\n    const replacedFiles = await uploadService.replace(id, { data, file: files }, { user });\n\n    ctx.body = pm.sanitize(replacedFiles, { action: ACTIONS.read, withPrivate: false });\n  },\n\n  async uploadFiles(ctx) {\n    const {\n      state: { userAbility, user },\n      request: { body, files: { files } = {} },\n    } = ctx;\n\n    const uploadService = strapi.plugins.upload.services.upload;\n    const pm = strapi.admin.services.permission.createPermissionsManager({\n      ability: userAbility,\n      action: ACTIONS.create,\n      model: fileModel,\n    });\n\n    if (!pm.isAllowed) {\n      throw strapi.errors.forbidden();\n    }\n\n    const data = await validateUploadBody(body);\n    const uploadedFiles = await uploadService.upload({ data, files }, { user });\n\n    ctx.body = pm.sanitize(uploadedFiles, { action: ACTIONS.read, withPrivate: false });\n  },\n};\n\nconst findEntityAndCheckPermissions = async (ability, action, model, id) => {\n  const file = await strapi.plugins.upload.services.upload.fetch({ id });\n\n  if (_.isNil(file)) {\n    throw strapi.errors.notFound();\n  }\n\n  const pm = strapi.admin.services.permission.createPermissionsManager({ ability, action, model });\n\n  const roles = _.has(file, 'created_by.id')\n    ? await strapi.query('role', 'admin').find({ 'users.id': file[CREATED_BY_ATTRIBUTE].id }, [])\n    : [];\n  const fileWithRoles = _.set(_.cloneDeep(file), 'created_by.roles', roles);\n\n  if (pm.ability.cannot(pm.action, pm.toSubject(fileWithRoles))) {\n    throw strapi.errors.forbidden();\n  }\n\n  return { pm, file };\n};\n",
    "packages/strapi-plugin-upload/controllers/upload/api.js": "'use strict';\n\nconst _ = require('lodash');\nconst { sanitizeEntity } = require('strapi-utils');\nconst validateSettings = require('../validation/settings');\nconst validateUploadBody = require('../validation/upload');\n\nconst sanitize = (data, options = {}) => {\n  return sanitizeEntity(data, {\n    model: strapi.getModel('file', 'upload'),\n    ...options,\n  });\n};\n\nmodule.exports = {\n  async find(ctx) {\n    const method = _.has(ctx.query, '_q') ? 'search' : 'fetchAll';\n\n    const files = await strapi.plugins.upload.services.upload[method](ctx.query);\n\n    ctx.body = sanitize(files);\n  },\n\n  async findOne(ctx) {\n    const {\n      params: { id },\n    } = ctx;\n\n    const file = await strapi.plugins.upload.services.upload.fetch({ id });\n\n    if (!file) {\n      return ctx.notFound('file.notFound');\n    }\n\n    ctx.body = sanitize(file);\n  },\n\n  async count(ctx) {\n    const method = _.has(ctx.query, '_q') ? 'countSearch' : 'count';\n\n    ctx.body = await strapi.plugins.upload.services.upload[method](ctx.query);\n  },\n\n  async destroy(ctx) {\n    const {\n      params: { id },\n    } = ctx;\n\n    const file = await strapi.plugins['upload'].services.upload.fetch({ id });\n\n    if (!file) {\n      return ctx.notFound('file.notFound');\n    }\n\n    await strapi.plugins['upload'].services.upload.remove(file);\n\n    ctx.body = sanitize(file);\n  },\n\n  async updateSettings(ctx) {\n    const {\n      request: { body },\n    } = ctx;\n\n    const data = await validateSettings(body);\n\n    await strapi.plugins.upload.services.upload.setSettings(data);\n\n    ctx.body = { data };\n  },\n\n  async getSettings(ctx) {\n    const data = await strapi.plugins.upload.services.upload.getSettings();\n\n    ctx.body = { data };\n  },\n\n  async updateFileInfo(ctx) {\n    const {\n      query: { id },\n      request: { body },\n    } = ctx;\n    const data = await validateUploadBody(body);\n\n    const result = await strapi.plugins.upload.services.upload.updateFileInfo(id, data.fileInfo);\n\n    ctx.body = sanitize(result);\n  },\n\n  async replaceFile(ctx) {\n    const {\n      query: { id },\n      request: { body, files: { files } = {} },\n    } = ctx;\n\n    // cannot replace with more than one file\n    if (Array.isArray(files)) {\n      throw strapi.errors.badRequest(null, {\n        errors: [\n          { id: 'Upload.replace.single', message: 'Cannot replace a file with multiple ones' },\n        ],\n      });\n    }\n\n    const replacedFiles = await strapi.plugins.upload.services.upload.replace(id, {\n      data: await validateUploadBody(body),\n      file: files,\n    });\n\n    ctx.body = sanitize(replacedFiles);\n  },\n\n  async uploadFiles(ctx) {\n    const {\n      request: { body, files: { files } = {} },\n    } = ctx;\n\n    const uploadedFiles = await strapi.plugins.upload.services.upload.upload({\n      data: await validateUploadBody(body),\n      files,\n    });\n\n    ctx.body = sanitize(uploadedFiles);\n  },\n};\n",
    "packages/strapi-plugin-upload/services/Upload.js": "'use strict';\n\n/**\n * Upload.js service\n *\n * @description: A set of functions similar to controller's actions to avoid code duplication.\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst util = require('util');\nconst _ = require('lodash');\nconst {\n  nameToSlug,\n  contentTypes: contentTypesUtils,\n  sanitizeEntity,\n  webhook: webhookUtils,\n} = require('strapi-utils');\n\nconst { MEDIA_UPDATE, MEDIA_CREATE, MEDIA_DELETE } = webhookUtils.webhookEvents;\n\nconst { bytesToKbytes } = require('../utils/file');\n\nconst { UPDATED_BY_ATTRIBUTE, CREATED_BY_ATTRIBUTE } = contentTypesUtils.constants;\n\nconst randomSuffix = () => crypto.randomBytes(5).toString('hex');\n\nconst generateFileName = name => {\n  const baseName = nameToSlug(name, { separator: '_', lowercase: false });\n\n  return `${baseName}_${randomSuffix()}`;\n};\n\nconst sendMediaMetrics = data => {\n  if (_.has(data, 'caption') && !_.isEmpty(data.caption)) {\n    strapi.telemetry.send('didSaveMediaWithCaption');\n  }\n\n  if (_.has(data, 'alternativeText') && !_.isEmpty(data.alternativeText)) {\n    strapi.telemetry.send('didSaveMediaWithAlternativeText');\n  }\n};\n\nconst combineFilters = params => {\n  // FIXME: until we support boolean operators for querying we need to make mime_ncontains use AND instead of OR\n  if (_.has(params, 'mime_ncontains') && Array.isArray(params.mime_ncontains)) {\n    params._where = params.mime_ncontains.map(val => ({ mime_ncontains: val }));\n    delete params.mime_ncontains;\n  }\n};\n\nmodule.exports = {\n  formatFileInfo({ filename, type, size }, fileInfo = {}, metas = {}) {\n    const ext = path.extname(filename);\n    const basename = path.basename(fileInfo.name || filename, ext);\n\n    const usedName = fileInfo.name || filename;\n\n    const entity = {\n      name: usedName,\n      alternativeText: fileInfo.alternativeText,\n      caption: fileInfo.caption,\n      hash: generateFileName(basename),\n      ext,\n      mime: type,\n      size: bytesToKbytes(size),\n    };\n\n    const { refId, ref, source, field } = metas;\n\n    if (refId && ref && field) {\n      entity.related = [\n        {\n          refId,\n          ref,\n          source,\n          field,\n        },\n      ];\n    }\n\n    if (metas.path) {\n      entity.path = metas.path;\n    }\n\n    return entity;\n  },\n\n  async enhanceFile(file, fileInfo = {}, metas = {}) {\n    let readBuffer;\n    try {\n      readBuffer = await util.promisify(fs.readFile)(file.path);\n    } catch (e) {\n      if (e.code === 'ERR_FS_FILE_TOO_LARGE') {\n        throw strapi.errors.entityTooLarge('FileTooBig', {\n          errors: [\n            {\n              id: 'Upload.status.sizeLimit',\n              message: `${file.name} file is bigger than the limit size!`,\n              values: { file: file.name },\n            },\n          ],\n        });\n      }\n      throw e;\n    }\n\n    const { optimize } = strapi.plugins.upload.services['image-manipulation'];\n\n    const { buffer, info } = await optimize(readBuffer);\n\n    const formattedFile = this.formatFileInfo(\n      {\n        filename: file.name,\n        type: file.type,\n        size: file.size,\n      },\n      fileInfo,\n      metas\n    );\n\n    return _.assign(formattedFile, info, {\n      buffer,\n    });\n  },\n\n  async upload({ data, files }, { user } = {}) {\n    const { fileInfo, ...metas } = data;\n\n    const fileArray = Array.isArray(files) ? files : [files];\n    const fileInfoArray = Array.isArray(fileInfo) ? fileInfo : [fileInfo];\n\n    const doUpload = async (file, fileInfo) => {\n      const fileData = await this.enhanceFile(file, fileInfo, metas);\n\n      return this.uploadFileAndPersist(fileData, { user });\n    };\n\n    return await Promise.all(\n      fileArray.map((file, idx) => doUpload(file, fileInfoArray[idx] || {}))\n    );\n  },\n\n  async uploadFileAndPersist(fileData, { user } = {}) {\n    const config = strapi.plugins.upload.config;\n\n    const {\n      getDimensions,\n      generateThumbnail,\n      generateResponsiveFormats,\n    } = strapi.plugins.upload.services['image-manipulation'];\n\n    await strapi.plugins.upload.provider.upload(fileData);\n\n    const thumbnailFile = await generateThumbnail(fileData);\n    if (thumbnailFile) {\n      await strapi.plugins.upload.provider.upload(thumbnailFile);\n      delete thumbnailFile.buffer;\n      _.set(fileData, 'formats.thumbnail', thumbnailFile);\n    }\n\n    const formats = await generateResponsiveFormats(fileData);\n    if (Array.isArray(formats) && formats.length > 0) {\n      for (const format of formats) {\n        if (!format) continue;\n\n        const { key, file } = format;\n\n        await strapi.plugins.upload.provider.upload(file);\n        delete file.buffer;\n\n        _.set(fileData, ['formats', key], file);\n      }\n    }\n\n    const { width, height } = await getDimensions(fileData.buffer);\n\n    delete fileData.buffer;\n\n    _.assign(fileData, {\n      provider: config.provider,\n      width,\n      height,\n    });\n\n    return this.add(fileData, { user });\n  },\n\n  async updateFileInfo(id, { name, alternativeText, caption }, { user } = {}) {\n    const dbFile = await this.fetch({ id });\n\n    if (!dbFile) {\n      throw strapi.errors.notFound('file not found');\n    }\n\n    const newInfos = {\n      name: _.isNil(name) ? dbFile.name : name,\n      alternativeText: _.isNil(alternativeText) ? dbFile.alternativeText : alternativeText,\n      caption: _.isNil(caption) ? dbFile.caption : caption,\n    };\n\n    return this.update({ id }, newInfos, { user });\n  },\n\n  async replace(id, { data, file }, { user } = {}) {\n    const config = strapi.plugins.upload.config;\n\n    const {\n      getDimensions,\n      generateThumbnail,\n      generateResponsiveFormats,\n    } = strapi.plugins.upload.services['image-manipulation'];\n\n    const dbFile = await this.fetch({ id });\n\n    if (!dbFile) {\n      throw strapi.errors.notFound('file not found');\n    }\n\n    const { fileInfo } = data;\n    const fileData = await this.enhanceFile(file, fileInfo);\n\n    // keep a constant hash\n    _.assign(fileData, {\n      hash: dbFile.hash,\n      ext: dbFile.ext,\n    });\n\n    // execute delete function of the provider\n    if (dbFile.provider === config.provider) {\n      await strapi.plugins.upload.provider.delete(dbFile);\n\n      if (dbFile.formats) {\n        await Promise.all(\n          Object.keys(dbFile.formats).map(key => {\n            return strapi.plugins.upload.provider.delete(dbFile.formats[key]);\n          })\n        );\n      }\n    }\n\n    await strapi.plugins.upload.provider.upload(fileData);\n\n    // clear old formats\n    _.set(fileData, 'formats', {});\n\n    const thumbnailFile = await generateThumbnail(fileData);\n    if (thumbnailFile) {\n      await strapi.plugins.upload.provider.upload(thumbnailFile);\n      delete thumbnailFile.buffer;\n      _.set(fileData, 'formats.thumbnail', thumbnailFile);\n    }\n\n    const formats = await generateResponsiveFormats(fileData);\n    if (Array.isArray(formats) && formats.length > 0) {\n      for (const format of formats) {\n        if (!format) continue;\n\n        const { key, file } = format;\n\n        await strapi.plugins.upload.provider.upload(file);\n        delete file.buffer;\n\n        _.set(fileData, ['formats', key], file);\n      }\n    }\n\n    const { width, height } = await getDimensions(fileData.buffer);\n    delete fileData.buffer;\n\n    _.assign(fileData, {\n      provider: config.provider,\n      width,\n      height,\n    });\n\n    return this.update({ id }, fileData, { user });\n  },\n\n  async update(params, values, { user } = {}) {\n    const fileValues = { ...values };\n    if (user) {\n      fileValues[UPDATED_BY_ATTRIBUTE] = user.id;\n    }\n    sendMediaMetrics(fileValues);\n\n    const res = await strapi.query('file', 'upload').update(params, fileValues);\n    const modelDef = strapi.getModel('file', 'upload');\n    strapi.eventHub.emit(MEDIA_UPDATE, { media: sanitizeEntity(res, { model: modelDef }) });\n    return res;\n  },\n\n  async add(values, { user } = {}) {\n    const fileValues = { ...values };\n    if (user) {\n      fileValues[UPDATED_BY_ATTRIBUTE] = user.id;\n      fileValues[CREATED_BY_ATTRIBUTE] = user.id;\n    }\n    sendMediaMetrics(fileValues);\n\n    const res = await strapi.query('file', 'upload').create(fileValues);\n    const modelDef = strapi.getModel('file', 'upload');\n    strapi.eventHub.emit(MEDIA_CREATE, { media: sanitizeEntity(res, { model: modelDef }) });\n    return res;\n  },\n\n  fetch(params) {\n    return strapi.query('file', 'upload').findOne(params);\n  },\n\n  fetchAll(params) {\n    combineFilters(params);\n    return strapi.query('file', 'upload').find(params);\n  },\n\n  search(params) {\n    return strapi.query('file', 'upload').search(params);\n  },\n\n  countSearch(params) {\n    return strapi.query('file', 'upload').countSearch(params);\n  },\n\n  count(params) {\n    combineFilters(params);\n    return strapi.query('file', 'upload').count(params);\n  },\n\n  async remove(file) {\n    const config = strapi.plugins.upload.config;\n\n    // execute delete function of the provider\n    if (file.provider === config.provider) {\n      await strapi.plugins.upload.provider.delete(file);\n\n      if (file.formats) {\n        await Promise.all(\n          Object.keys(file.formats).map(key => {\n            return strapi.plugins.upload.provider.delete(file.formats[key]);\n          })\n        );\n      }\n    }\n\n    const media = await strapi.query('file', 'upload').findOne({\n      id: file.id,\n    });\n\n    const modelDef = strapi.getModel('file', 'upload');\n    strapi.eventHub.emit(MEDIA_DELETE, { media: sanitizeEntity(media, { model: modelDef }) });\n\n    return strapi.query('file', 'upload').delete({ id: file.id });\n  },\n\n  async uploadToEntity(params, files, source) {\n    const { id, model, field } = params;\n\n    const arr = Array.isArray(files) ? files : [files];\n    const enhancedFiles = await Promise.all(\n      arr.map(file => {\n        return this.enhanceFile(\n          file,\n          {},\n          {\n            refId: id,\n            ref: model,\n            source,\n            field,\n          }\n        );\n      })\n    );\n\n    await Promise.all(enhancedFiles.map(file => this.uploadFileAndPersist(file)));\n  },\n\n  getSettings() {\n    return strapi\n      .store({\n        type: 'plugin',\n        name: 'upload',\n        key: 'settings',\n      })\n      .get();\n  },\n\n  setSettings(value) {\n    if (value.responsiveDimensions === true) {\n      strapi.telemetry.send('didEnableResponsiveDimensions');\n    } else {\n      strapi.telemetry.send('didDisableResponsiveDimensions');\n    }\n\n    return strapi\n      .store({\n        type: 'plugin',\n        name: 'upload',\n        key: 'settings',\n      })\n      .set({ value });\n  },\n};\n",
    "packages/strapi-plugin-upload/services/image-manipulation.js": "'use strict';\n/**\n * Image manipulation functions\n */\nconst sharp = require('sharp');\n\nconst { bytesToKbytes } = require('../utils/file');\n\nconst getMetadatas = buffer =>\n  sharp(buffer)\n    .metadata()\n    .catch(() => ({})); // ignore errors\n\nconst getDimensions = buffer =>\n  getMetadatas(buffer)\n    .then(({ width = null, height = null }) => ({ width, height }))\n    .catch(() => ({})); // ignore errors\n\nconst THUMBNAIL_RESIZE_OPTIONS = {\n  width: 245,\n  height: 156,\n  fit: 'inside',\n};\n\nconst resizeTo = (buffer, options) =>\n  sharp(buffer)\n    .resize(options)\n    .toBuffer()\n    .catch(() => null);\n\nconst generateThumbnail = async file => {\n  if (!(await canBeProccessed(file.buffer))) {\n    return null;\n  }\n\n  const { width, height } = await getDimensions(file.buffer);\n\n  if (width > THUMBNAIL_RESIZE_OPTIONS.width || height > THUMBNAIL_RESIZE_OPTIONS.height) {\n    const newBuff = await resizeTo(file.buffer, THUMBNAIL_RESIZE_OPTIONS);\n\n    if (newBuff) {\n      const { width, height, size } = await getMetadatas(newBuff);\n\n      return {\n        name: `thumbnail_${file.name}`,\n        hash: `thumbnail_${file.hash}`,\n        ext: file.ext,\n        mime: file.mime,\n        width,\n        height,\n        size: bytesToKbytes(size),\n        buffer: newBuff,\n        path: file.path ? file.path : null,\n      };\n    }\n  }\n\n  return null;\n};\n\nconst optimize = async buffer => {\n  const {\n    sizeOptimization = false,\n    autoOrientation = false,\n  } = await strapi.plugins.upload.services.upload.getSettings();\n\n  if (!sizeOptimization || !(await canBeProccessed(buffer))) {\n    return { buffer };\n  }\n\n  const sharpInstance = autoOrientation ? sharp(buffer).rotate() : sharp(buffer);\n\n  return sharpInstance\n    .toBuffer({ resolveWithObject: true })\n    .then(({ data, info }) => {\n      const output = buffer.length < data.length ? buffer : data;\n\n      return {\n        buffer: output,\n        info: {\n          width: info.width,\n          height: info.height,\n          size: bytesToKbytes(output.length),\n        },\n      };\n    })\n    .catch(() => ({ buffer }));\n};\n\nconst DEFAULT_BREAKPOINTS = {\n  large: 1000,\n  medium: 750,\n  small: 500,\n};\n\nconst getBreakpoints = () => strapi.config.get('plugins.upload.breakpoints', DEFAULT_BREAKPOINTS);\n\nconst generateResponsiveFormats = async file => {\n  const {\n    responsiveDimensions = false,\n  } = await strapi.plugins.upload.services.upload.getSettings();\n\n  if (!responsiveDimensions) return [];\n\n  if (!(await canBeProccessed(file.buffer))) {\n    return [];\n  }\n\n  const originalDimensions = await getDimensions(file.buffer);\n\n  const breakpoints = getBreakpoints();\n  return Promise.all(\n    Object.keys(breakpoints).map(key => {\n      const breakpoint = breakpoints[key];\n\n      if (breakpointSmallerThan(breakpoint, originalDimensions)) {\n        return generateBreakpoint(key, { file, breakpoint, originalDimensions });\n      }\n    })\n  );\n};\n\nconst generateBreakpoint = async (key, { file, breakpoint }) => {\n  const newBuff = await resizeTo(file.buffer, {\n    width: breakpoint,\n    height: breakpoint,\n    fit: 'inside',\n  });\n\n  if (newBuff) {\n    const { width, height, size } = await getMetadatas(newBuff);\n\n    return {\n      key,\n      file: {\n        name: `${key}_${file.name}`,\n        hash: `${key}_${file.hash}`,\n        ext: file.ext,\n        mime: file.mime,\n        width,\n        height,\n        size: bytesToKbytes(size),\n        buffer: newBuff,\n        path: file.path ? file.path : null,\n      },\n    };\n  }\n};\n\nconst breakpointSmallerThan = (breakpoint, { width, height }) => {\n  return breakpoint < width || breakpoint < height;\n};\n\nconst formatsToProccess = ['jpeg', 'png', 'webp', 'tiff'];\nconst canBeProccessed = async buffer => {\n  const { format } = await getMetadatas(buffer);\n  return format && formatsToProccess.includes(format);\n};\n\nmodule.exports = {\n  getDimensions,\n  generateResponsiveFormats,\n  generateThumbnail,\n  bytesToKbytes,\n  optimize,\n};\n",
    "packages/strapi-plugin-upload/tests/graphqlUpload.test.e2e.js": "'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\nconst data = {};\n\ndescribe('Upload plugin end to end tests', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  test('Upload a single file', async () => {\n    const formData = {\n      operations: JSON.stringify({\n        query: /* GraphQL */ `\n          mutation uploadFiles($file: Upload!) {\n            upload(file: $file) {\n              id\n              name\n              mime\n              url\n            }\n          }\n        `,\n        variables: {\n          file: null,\n        },\n      }),\n      map: JSON.stringify({\n        nFile1: ['variables.file'],\n      }),\n      nFile1: fs.createReadStream(path.join(__dirname, '/rec.jpg')),\n    };\n\n    const res = await rq({ method: 'POST', url: '/graphql', formData });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      data: {\n        upload: {\n          id: expect.anything(),\n          name: 'rec.jpg',\n        },\n      },\n    });\n\n    data.file = res.body.data.upload;\n  });\n\n  test('Upload multiple files', async () => {\n    const formData = {\n      operations: JSON.stringify({\n        query: /* GraphQL */ `\n          mutation uploadFiles($files: [Upload]!) {\n            multipleUpload(files: $files) {\n              id\n              name\n              mime\n              url\n            }\n          }\n        `,\n        variables: {\n          files: [null, null],\n        },\n      }),\n      map: JSON.stringify({\n        nFile0: ['variables.files.0'],\n        nFile1: ['variables.files.1'],\n      }),\n      nFile0: fs.createReadStream(path.join(__dirname, '/rec.jpg')),\n      nFile1: fs.createReadStream(path.join(__dirname, '/rec.jpg')),\n    };\n\n    const res = await rq({ method: 'POST', url: '/graphql', formData });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toEqual({\n      data: {\n        multipleUpload: expect.arrayContaining([\n          expect.objectContaining({\n            id: expect.anything(),\n            name: 'rec.jpg',\n          }),\n        ]),\n      },\n    });\n  });\n\n  test('Update file information', async () => {\n    const res = await rq({\n      url: '/graphql',\n      method: 'POST',\n      body: {\n        query: /* GraphQL */ `\n          mutation updateFileInfo($id: ID!, $info: FileInfoInput!) {\n            updateFileInfo(id: $id, info: $info) {\n              id\n              name\n              alternativeText\n              caption\n            }\n          }\n        `,\n        variables: {\n          id: data.file.id,\n          info: {\n            name: 'test name',\n            alternativeText: 'alternative text test',\n            caption: 'caption test',\n          },\n        },\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      data: {\n        updateFileInfo: {\n          id: data.file.id,\n          name: 'test name',\n          alternativeText: 'alternative text test',\n          caption: 'caption test',\n        },\n      },\n    });\n  });\n\n  test('Delete a file', async () => {\n    const res = await rq({\n      url: '/graphql',\n      method: 'POST',\n      body: {\n        query: /* GraphQL */ `\n          mutation removeFile($id: ID!) {\n            deleteFile(input: { where: { id: $id } }) {\n              file {\n                id\n              }\n            }\n          }\n        `,\n        variables: {\n          id: data.file.id,\n        },\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      data: {\n        deleteFile: {\n          file: {\n            id: data.file.id,\n          },\n        },\n      },\n    });\n  });\n\n  test('Delete a file that dont exist', async () => {\n    const res = await rq({\n      url: '/graphql',\n      method: 'POST',\n      body: {\n        query: /* GraphQL */ `\n          mutation removeFile($id: ID!) {\n            deleteFile(input: { where: { id: $id } }) {\n              file {\n                id\n              }\n            }\n          }\n        `,\n        variables: {\n          id: '404',\n        },\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      data: {\n        deleteFile: null,\n      },\n    });\n  });\n\n  test('Upload a single file with info', async () => {\n    const formData = {\n      operations: JSON.stringify({\n        query: /* GraphQL */ `\n          mutation uploadFilesWithInfo($file: Upload!, $info: FileInfoInput) {\n            upload(file: $file, info: $info) {\n              id\n              name\n              alternativeText\n              caption\n            }\n          }\n        `,\n        variables: {\n          file: null,\n          info: {\n            alternativeText: 'alternative text test',\n            caption: 'caption test',\n          },\n        },\n      }),\n      map: JSON.stringify({\n        nFile1: ['variables.file'],\n      }),\n      nFile1: fs.createReadStream(path.join(__dirname, '/rec.jpg')),\n    };\n\n    const res = await rq({ method: 'POST', url: '/graphql', formData });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      data: {\n        upload: {\n          id: expect.anything(),\n          name: 'rec.jpg',\n          alternativeText: 'alternative text test',\n          caption: 'caption test',\n        },\n      },\n    });\n  });\n});\n",
    "packages/strapi-plugin-upload/tests/upload.test.e2e.js": "'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Helpers.\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\n\ndescribe('Upload plugin end to end tests', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('GET /upload/settings => Get settings for an environment', () => {\n    test('Returns the settings', async () => {\n      const res = await rq({ method: 'GET', url: '/upload/settings' });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          sizeOptimization: true,\n          responsiveDimensions: true,\n        },\n      });\n    });\n  });\n\n  describe('PUT /upload/settings/:environment', () => {\n    test('Updates an environment config correctly', async () => {\n      const updateRes = await rq({\n        method: 'PUT',\n        url: '/upload/settings',\n        body: {\n          sizeOptimization: true,\n          responsiveDimensions: true,\n        },\n      });\n\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body).toEqual({\n        data: {\n          sizeOptimization: true,\n          responsiveDimensions: true,\n        },\n      });\n\n      const getRes = await rq({ method: 'GET', url: '/upload/settings' });\n\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toEqual({\n        data: {\n          sizeOptimization: true,\n          responsiveDimensions: true,\n        },\n      });\n    });\n  });\n\n  describe('POST /upload => Upload a file', () => {\n    test('Simple image upload', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/upload',\n        formData: {\n          files: fs.createReadStream(path.join(__dirname, 'rec.jpg')),\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body[0]).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'rec.jpg',\n          ext: '.jpg',\n          mime: 'image/jpeg',\n          hash: expect.any(String),\n          size: expect.any(Number),\n          width: expect.any(Number),\n          height: expect.any(Number),\n          url: expect.any(String),\n          provider: 'local',\n        })\n      );\n    });\n\n    test('Rejects when no files are provided', async () => {\n      const res = await rq({ method: 'POST', url: '/upload', formData: {} });\n      expect(res.statusCode).toBe(400);\n    });\n\n    test('Generates a thumbnail on large enough files', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/upload',\n        formData: {\n          files: fs.createReadStream(path.join(__dirname, 'thumbnail_target.png')),\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body)).toBe(true);\n      expect(res.body.length).toBe(1);\n      expect(res.body[0]).toEqual(\n        expect.objectContaining({\n          id: expect.anything(),\n          name: 'thumbnail_target.png',\n          ext: '.png',\n          mime: 'image/png',\n          hash: expect.any(String),\n          size: expect.any(Number),\n          width: expect.any(Number),\n          height: expect.any(Number),\n          url: expect.any(String),\n          provider: 'local',\n          formats: {\n            thumbnail: {\n              name: 'thumbnail_thumbnail_target.png',\n              hash: expect.any(String),\n              ext: '.png',\n              mime: 'image/png',\n              size: expect.any(Number),\n              width: expect.any(Number),\n              height: expect.any(Number),\n              url: expect.any(String),\n              path: null,\n            },\n          },\n        })\n      );\n    });\n  });\n\n  describe('GET /upload/files => Find files', () => {});\n  describe('GET /upload/files/count => Count available files', () => {});\n  describe('GET /upload/files/:id => Find one file', () => {});\n  describe('GET /upload/search/:id => Search files', () => {});\n  describe('DELETE /upload/files/:id => Delete a file ', () => {});\n});\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/AdvancedSettings/index.js": "import React, { useCallback, useEffect, useMemo, useReducer, useRef, useState } from 'react';\nimport { useIntl } from 'react-intl';\nimport { Header } from '@buffetjs/custom';\nimport { isEqual } from 'lodash';\nimport {\n  FormBloc,\n  PopUpWarning,\n  SettingsPageTitle,\n  SizedInput,\n  useUserPermissions,\n  request,\n} from 'strapi-helper-plugin';\nimport pluginPermissions from '../../permissions';\nimport { getTrad, getRequestURL } from '../../utils';\nimport ListBaselineAlignment from '../../components/ListBaselineAlignment';\nimport form from './utils/form';\nimport reducer, { initialState } from './reducer';\n\nconst AdvancedSettingsPage = () => {\n  const { formatMessage } = useIntl();\n  const [showModalWarning, setShowModalWarning] = useState(false);\n  const pageTitle = formatMessage({ id: getTrad('HeaderNav.link.advancedSettings') });\n  const updatePermissions = useMemo(() => {\n    return { update: pluginPermissions.updateAdvancedSettings };\n  }, []);\n  const {\n    isLoading: isLoadingForPermissions,\n    allowedActions: { canUpdate },\n  } = useUserPermissions(updatePermissions);\n  const [\n    { initialData, isConfirmButtonLoading, isLoading, modifiedData, roles },\n    dispatch,\n  ] = useReducer(reducer, initialState);\n  const isMounted = useRef(true);\n  const abortController = new AbortController();\n  const { signal } = abortController;\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        dispatch({\n          type: 'GET_DATA',\n        });\n\n        const data = await request(getRequestURL('advanced'), { method: 'GET', signal });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n        });\n      } catch (err) {\n        if (isMounted.current) {\n          dispatch({\n            type: 'GET_DATA_ERROR',\n          });\n          console.error(err);\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      }\n    };\n\n    if (!isLoadingForPermissions) {\n      getData();\n    }\n\n    return () => {\n      abortController.abort();\n      isMounted.current = false;\n    };\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isLoadingForPermissions]);\n\n  const handleChange = useCallback(({ target }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: target.name,\n      value: target.value,\n    });\n  }, []);\n\n  const handleSubmit = useCallback(\n    async e => {\n      e.preventDefault();\n\n      try {\n        dispatch({\n          type: 'ON_SUBMIT',\n        });\n\n        strapi.lockAppWithOverlay();\n        await request(getRequestURL('advanced'), { method: 'PUT', body: modifiedData });\n\n        dispatch({\n          type: 'ON_SUBMIT_SUCCEEDED',\n        });\n\n        strapi.notification.toggle({\n          type: 'success',\n          message: { id: getTrad('notification.success.submit') },\n        });\n      } catch (err) {\n        dispatch({\n          type: 'ON_SUBMIT_ERROR',\n        });\n        console.error(err);\n        strapi.notification.toggle({\n          type: 'warning',\n          message: { id: 'notification.error' },\n        });\n      }\n\n      strapi.unlockApp();\n    },\n    [modifiedData]\n  );\n\n  const handleConfirmReset = useCallback(() => {\n    dispatch({\n      type: 'ON_RESET',\n    });\n\n    setShowModalWarning(false);\n  }, []);\n\n  const handleToggleModal = useCallback(() => {\n    setShowModalWarning(prev => !prev);\n  }, []);\n\n  const headerActions = useMemo(() => {\n    const isDisabled = isEqual(initialData, modifiedData);\n\n    return [\n      {\n        disabled: isDisabled,\n        onClick: () => {\n          handleToggleModal();\n        },\n        color: 'cancel',\n        label: formatMessage({\n          id: 'app.components.Button.reset',\n        }),\n\n        type: 'button',\n        style: {\n          paddingLeft: 15,\n          paddingRight: 15,\n          fontWeight: 600,\n        },\n      },\n      {\n        disabled: isDisabled,\n        color: 'success',\n        label: formatMessage({\n          id: 'app.components.Button.save',\n        }),\n        isLoading: isConfirmButtonLoading,\n        type: 'submit',\n        style: {\n          minWidth: 150,\n          fontWeight: 600,\n        },\n      },\n    ];\n  }, [initialData, isConfirmButtonLoading, modifiedData, formatMessage, handleToggleModal]);\n\n  const showLoader = isLoadingForPermissions || isLoading;\n\n  return (\n    <>\n      <SettingsPageTitle name={pageTitle} />\n      <div>\n        <form onSubmit={handleSubmit}>\n          <Header actions={headerActions} title={{ label: pageTitle }} isLoading={showLoader} />\n          <ListBaselineAlignment />\n          <FormBloc title=\"Settings\" isLoading={showLoader}>\n            {form.map(input => {\n              return (\n                <SizedInput\n                  key={input.name}\n                  {...input}\n                  disabled={!canUpdate}\n                  onChange={handleChange}\n                  options={roles}\n                  value={modifiedData[input.name]}\n                />\n              );\n            })}\n          </FormBloc>\n        </form>\n      </div>\n      <PopUpWarning\n        isOpen={showModalWarning}\n        toggleModal={handleToggleModal}\n        content={{\n          title: getTrad('popUpWarning.title'),\n          message: getTrad('popUpWarning.warning.cancel'),\n          cancel: getTrad('popUpWarning.button.cancel'),\n          confirm: getTrad('popUpWarning.button.confirm'),\n        }}\n        popUpWarningType=\"danger\"\n        onConfirm={handleConfirmReset}\n      />\n    </>\n  );\n};\n\nexport default AdvancedSettingsPage;\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/EmailTemplates/index.js": "import React, { useCallback, useMemo, useRef, useState } from 'react';\nimport { useIntl } from 'react-intl';\nimport { Header, List } from '@buffetjs/custom';\nimport { Pencil } from '@buffetjs/icons';\nimport { get } from 'lodash';\nimport {\n  SettingsPageTitle,\n  SizedInput,\n  useGlobalContext,\n  request,\n  getYupInnerErrors,\n} from 'strapi-helper-plugin';\nimport { Row } from 'reactstrap';\nimport pluginPermissions from '../../permissions';\nimport { useForm } from '../../hooks';\nimport ListBaselineAlignment from '../../components/ListBaselineAlignment';\nimport ListRow from '../../components/ListRow';\nimport ModalForm from '../../components/ModalForm';\nimport { getRequestURL, getTrad } from '../../utils';\nimport forms from './utils/forms';\nimport schema from './utils/schema';\n\nconst EmailTemplatesPage = () => {\n  const { formatMessage } = useIntl();\n  const { emitEvent } = useGlobalContext();\n  const emitEventRef = useRef(emitEvent);\n  const buttonSubmitRef = useRef(null);\n  const pageTitle = formatMessage({ id: getTrad('HeaderNav.link.emailTemplates') });\n  const updatePermissions = useMemo(() => {\n    return { update: pluginPermissions.updateEmailTemplates };\n  }, []);\n  const [isOpen, setIsOpen] = useState(false);\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const [showForm, setShowForm] = useState(false);\n  const [templateToEdit, setTemplateToEdit] = useState(null);\n\n  const {\n    allowedActions: { canUpdate },\n    dispatchResetForm,\n    dispatchSetFormErrors,\n    dispatchSubmitSucceeded,\n    formErrors,\n    handleChange,\n    isLoading,\n    isLoadingForPermissions,\n    modifiedData,\n  } = useForm('email-templates', updatePermissions);\n\n  const emailTemplates = useMemo(() => {\n    return Object.keys(modifiedData).reduce((acc, current) => {\n      const { display, icon } = modifiedData[current];\n\n      acc.push({\n        id: current,\n        name: formatMessage({ id: getTrad(display) }),\n        icon: ['fas', icon],\n      });\n\n      return acc;\n    }, []);\n  }, [modifiedData, formatMessage]);\n\n  const listTitle = useMemo(() => {\n    const count = emailTemplates.length;\n\n    return formatMessage(\n      {\n        id: getTrad(`List.title.emailTemplates.${count > 1 ? 'plural' : 'singular'}`),\n      },\n      { number: count }\n    );\n  }, [emailTemplates.length, formatMessage]);\n\n  const handleClosed = useCallback(() => {\n    setTemplateToEdit(null);\n    setShowForm(false);\n    dispatchResetForm();\n  }, [dispatchResetForm]);\n\n  const handleToggle = useCallback(() => {\n    setIsOpen(prev => !prev);\n  }, []);\n\n  const handleClickEdit = useCallback(\n    template => {\n      setTemplateToEdit(template);\n      handleToggle();\n    },\n    [handleToggle]\n  );\n\n  const handleSubmit = useCallback(\n    async e => {\n      e.preventDefault();\n\n      let errors = {};\n\n      try {\n        setIsSubmiting(true);\n        await schema.validate(modifiedData[templateToEdit.id], { abortEarly: false });\n\n        strapi.lockAppWithOverlay();\n\n        try {\n          emitEventRef.current('willEditEmailTemplates');\n\n          await request(getRequestURL('email-templates'), {\n            method: 'PUT',\n            body: { 'email-templates': modifiedData },\n          });\n\n          emitEventRef.current('didEditEmailTemplates');\n\n          strapi.notification.toggle({\n            type: 'success',\n            message: { id: getTrad('notification.success.submit') },\n          });\n\n          dispatchSubmitSucceeded();\n\n          handleToggle();\n        } catch (err) {\n          console.error(err);\n\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      } catch (err) {\n        errors = getYupInnerErrors(err);\n      } finally {\n        setIsSubmiting(false);\n        strapi.unlockApp();\n      }\n\n      dispatchSetFormErrors(errors);\n    },\n    [dispatchSetFormErrors, dispatchSubmitSucceeded, modifiedData, templateToEdit, handleToggle]\n  );\n\n  const handleClick = useCallback(() => {\n    buttonSubmitRef.current.click();\n  }, []);\n\n  const handleOpened = useCallback(() => {\n    setShowForm(true);\n  }, []);\n\n  return (\n    <>\n      <SettingsPageTitle name={pageTitle} />\n      <div>\n        <Header title={{ label: pageTitle }} isLoading={isLoadingForPermissions || isLoading} />\n        <ListBaselineAlignment />\n        <List\n          title={listTitle}\n          items={emailTemplates}\n          isLoading={isLoadingForPermissions || isLoading}\n          customRowComponent={template => (\n            <ListRow\n              {...template}\n              onClick={() => {\n                if (canUpdate) {\n                  handleClickEdit(template);\n                }\n              }}\n              links={[\n                {\n                  icon: canUpdate ? <Pencil fill=\"#0e1622\" /> : null,\n                  onClick: e => {\n                    e.stopPropagation();\n                    handleClickEdit(template);\n                  },\n                },\n              ]}\n            />\n          )}\n        />\n      </div>\n      <ModalForm\n        isOpen={isOpen}\n        onOpened={handleOpened}\n        onToggle={handleToggle}\n        onClosed={handleClosed}\n        headerBreadcrumbs={[\n          getTrad('PopUpForm.header.edit.email-templates'),\n          get(templateToEdit, 'name', ''),\n        ]}\n        onClick={handleClick}\n        onCancel={handleToggle}\n        isLoading={isSubmiting}\n      >\n        {showForm && (\n          <form onSubmit={handleSubmit}>\n            <Row>\n              {forms.map(input => {\n                const id = get(templateToEdit, 'id');\n\n                return (\n                  <SizedInput\n                    key={input.name}\n                    {...input}\n                    error={formErrors[input.name]}\n                    name={`${id}.${input.name}`}\n                    onChange={handleChange}\n                    value={get(modifiedData, [id, ...input.name.split('.')], '')}\n                  />\n                );\n              })}\n            </Row>\n            <button type=\"submit\" style={{ display: 'none' }} ref={buttonSubmitRef}>\n              hidden button to use the native form event\n            </button>\n          </form>\n        )}\n      </ModalForm>\n    </>\n  );\n};\n\nexport default EmailTemplatesPage;\n",
    "packages/strapi-plugin-users-permissions/admin/src/containers/Providers/index.js": "import React, { useCallback, useMemo, useRef, useState } from 'react';\nimport { useIntl } from 'react-intl';\nimport { Header, List } from '@buffetjs/custom';\nimport { Text } from '@buffetjs/core';\nimport { Pencil } from '@buffetjs/icons';\nimport {\n  SettingsPageTitle,\n  SizedInput,\n  useGlobalContext,\n  getYupInnerErrors,\n  request,\n} from 'strapi-helper-plugin';\nimport { get, upperFirst, has } from 'lodash';\nimport { Row } from 'reactstrap';\nimport pluginPermissions from '../../permissions';\nimport { useForm } from '../../hooks';\nimport { getRequestURL, getTrad } from '../../utils';\nimport ListBaselineAlignment from '../../components/ListBaselineAlignment';\nimport ListRow from '../../components/ListRow';\nimport ModalForm from '../../components/ModalForm';\nimport createProvidersArray from './utils/createProvidersArray';\nimport forms from './utils/forms';\n\nconst ProvidersPage = () => {\n  const { formatMessage } = useIntl();\n  const { emitEvent } = useGlobalContext();\n  const emitEventRef = useRef(emitEvent);\n  const [isOpen, setIsOpen] = useState(false);\n  const [isSubmiting, setIsSubmiting] = useState(false);\n  const buttonSubmitRef = useRef(null);\n  const [showForm, setShowForm] = useState(false);\n  const [providerToEditName, setProviderToEditName] = useState(null);\n\n  const updatePermissions = useMemo(() => {\n    return { update: pluginPermissions.updateProviders };\n  }, []);\n\n  const {\n    allowedActions: { canUpdate },\n    dispatchResetForm,\n    dispatchSetFormErrors,\n    dispatchSubmitSucceeded,\n    formErrors,\n    handleChange,\n    isLoading,\n    isLoadingForPermissions,\n    modifiedData,\n  } = useForm('providers', updatePermissions);\n\n  const providers = useMemo(() => createProvidersArray(modifiedData), [modifiedData]);\n  const enabledProvidersCount = useMemo(\n    () => providers.filter(provider => provider.enabled).length,\n    [providers]\n  );\n  const isProviderWithSubdomain = useMemo(() => {\n    if (!providerToEditName) {\n      return false;\n    }\n\n    const providerToEdit = providers.find(obj => obj.name === providerToEditName);\n\n    return has(providerToEdit, 'subdomain');\n  }, [providers, providerToEditName]);\n  const disabledProvidersCount = useMemo(() => {\n    return providers.length - enabledProvidersCount;\n  }, [providers, enabledProvidersCount]);\n\n  const listTitle = useMemo(() => {\n    const enabledMessage = formatMessage(\n      {\n        id: getTrad(\n          `List.title.providers.enabled.${enabledProvidersCount > 1 ? 'plural' : 'singular'}`\n        ),\n      },\n      { number: enabledProvidersCount }\n    );\n    const disabledMessage = formatMessage(\n      {\n        id: getTrad(\n          `List.title.providers.disabled.${disabledProvidersCount > 1 ? 'plural' : 'singular'}`\n        ),\n      },\n      { number: disabledProvidersCount }\n    );\n\n    return `${enabledMessage} ${disabledMessage}`;\n  }, [formatMessage, enabledProvidersCount, disabledProvidersCount]);\n\n  const pageTitle = formatMessage({ id: getTrad('HeaderNav.link.providers') });\n\n  const formToRender = useMemo(() => {\n    if (providerToEditName === 'email') {\n      return forms.email;\n    }\n\n    if (isProviderWithSubdomain) {\n      return forms.providersWithSubdomain;\n    }\n\n    return forms.providers;\n  }, [providerToEditName, isProviderWithSubdomain]);\n\n  const handleClick = useCallback(() => {\n    buttonSubmitRef.current.click();\n  }, []);\n\n  const handleToggle = useCallback(() => {\n    setIsOpen(prev => !prev);\n  }, []);\n\n  const handleClickEdit = useCallback(\n    provider => {\n      if (canUpdate) {\n        setProviderToEditName(provider.name);\n        handleToggle();\n      }\n    },\n    [canUpdate, handleToggle]\n  );\n\n  const handleClosed = useCallback(() => {\n    setProviderToEditName(null);\n    setShowForm(false);\n    dispatchResetForm();\n  }, [dispatchResetForm]);\n\n  const handleOpened = useCallback(() => {\n    setShowForm(true);\n  }, []);\n\n  const handleSubmit = useCallback(\n    async e => {\n      e.preventDefault();\n      const { schema } = formToRender;\n      let errors = {};\n\n      setIsSubmiting(true);\n\n      try {\n        await schema.validate(modifiedData[providerToEditName], { abortEarly: false });\n        strapi.lockAppWithOverlay();\n\n        try {\n          emitEventRef.current('willEditAuthenticationProvider');\n\n          await request(getRequestURL('providers'), {\n            method: 'PUT',\n            body: { providers: modifiedData },\n          });\n\n          emitEventRef.current('didEditAuthenticationProvider');\n\n          strapi.notification.toggle({\n            type: 'success',\n            message: { id: getTrad('notification.success.submit') },\n          });\n\n          dispatchSubmitSucceeded();\n\n          handleToggle();\n        } catch (err) {\n          console.error(err);\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      } catch (err) {\n        console.error(err);\n        errors = getYupInnerErrors(err);\n        console.log(errors);\n      }\n\n      dispatchSetFormErrors(errors);\n\n      setIsSubmiting(false);\n      strapi.unlockApp();\n    },\n    [\n      dispatchSetFormErrors,\n      dispatchSubmitSucceeded,\n      formToRender,\n      handleToggle,\n      modifiedData,\n      providerToEditName,\n    ]\n  );\n\n  return (\n    <>\n      <SettingsPageTitle name={pageTitle} />\n      <div>\n        <Header title={{ label: pageTitle }} isLoading={isLoadingForPermissions || isLoading} />\n        <ListBaselineAlignment />\n        <List\n          title={listTitle}\n          items={providers}\n          isLoading={isLoadingForPermissions || isLoading}\n          customRowComponent={provider => (\n            <ListRow\n              {...provider}\n              onClick={() => handleClickEdit(provider)}\n              links={[\n                {\n                  icon: canUpdate ? <Pencil fill=\"#0e1622\" /> : null,\n                  onClick: e => {\n                    e.stopPropagation();\n                    handleClickEdit(provider);\n                  },\n                },\n              ]}\n            >\n              <td key=\"enabled\">\n                <Text\n                  fontWeight=\"semiBold\"\n                  lineHeight=\"18px\"\n                  color={provider.enabled ? 'green' : 'lightOrange'}\n                >\n                  {provider.enabled ? 'Enabled' : 'Disabled'}\n                </Text>\n              </td>\n            </ListRow>\n          )}\n        />\n      </div>\n      <ModalForm\n        isOpen={isOpen}\n        onClick={handleClick}\n        onCancel={handleToggle}\n        isLoading={isSubmiting}\n        onOpened={handleOpened}\n        onClosed={handleClosed}\n        onToggle={handleToggle}\n        headerBreadcrumbs={[\n          getTrad('PopUpForm.header.edit.providers'),\n          upperFirst(providerToEditName),\n        ]}\n      >\n        {showForm && (\n          <form onSubmit={handleSubmit}>\n            <Row>\n              {formToRender.form.map(input => {\n                const label = input.label.params\n                  ? { ...input.label, params: { provider: upperFirst(providerToEditName) } }\n                  : input.label;\n\n                const value =\n                  input.name === 'noName'\n                    ? `${strapi.backendURL}/connect/${providerToEditName}/callback`\n                    : get(modifiedData, [providerToEditName, ...input.name.split('.')], '');\n\n                return (\n                  <SizedInput\n                    key={input.name}\n                    {...input}\n                    label={label}\n                    error={formErrors[input.name]}\n                    name={`${providerToEditName}.${input.name}`}\n                    onChange={handleChange}\n                    value={value}\n                  />\n                );\n              })}\n            </Row>\n            <button type=\"submit\" style={{ display: 'none' }} ref={buttonSubmitRef}>\n              hidden button to use the native form event\n            </button>\n          </form>\n        )}\n      </ModalForm>\n    </>\n  );\n};\n\nexport default ProvidersPage;\n",
    "packages/strapi-plugin-users-permissions/admin/src/hooks/useFetchRole/index.js": "import { useCallback, useReducer, useEffect } from 'react';\nimport { request } from 'strapi-helper-plugin';\n\nimport reducer, { initialState } from './reducer';\n\nimport pluginId from '../../pluginId';\n\nconst useFetchRole = id => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  useEffect(() => {\n    if (id) {\n      fetchRole(id);\n    } else {\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        role: {},\n      });\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [id]);\n\n  const fetchRole = async roleId => {\n    try {\n      const { role } = await request(`/${pluginId}/roles/${roleId}`, { method: 'GET' });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        role,\n      });\n    } catch (err) {\n      console.error(err);\n\n      dispatch({\n        type: 'GET_DATA_ERROR',\n      });\n      strapi.notification.toggle({\n        type: 'warning',\n        message: { id: 'notification.error' },\n      });\n    }\n  };\n\n  const handleSubmitSucceeded = useCallback(data => {\n    dispatch({\n      type: 'ON_SUBMIT_SUCCEEDED',\n      ...data,\n    });\n  }, []);\n\n  return { ...state, onSubmitSucceeded: handleSubmitSucceeded };\n};\n\nexport default useFetchRole;\n",
    "packages/strapi-plugin-users-permissions/admin/src/hooks/useForm/index.js": "import { useCallback, useEffect, useReducer, useRef } from 'react';\nimport { useUserPermissions, request } from 'strapi-helper-plugin';\nimport { getRequestURL } from '../../utils';\nimport reducer, { initialState } from './reducer';\n\nconst useUserForm = (endPoint, permissions) => {\n  const { isLoading: isLoadingForPermissions, allowedActions } = useUserPermissions(permissions);\n  const [{ formErrors, initialData, isLoading, modifiedData }, dispatch] = useReducer(\n    reducer,\n    initialState\n  );\n\n  const isMounted = useRef(true);\n\n  const abortController = new AbortController();\n  const { signal } = abortController;\n\n  useEffect(() => {\n    const getData = async () => {\n      try {\n        dispatch({\n          type: 'GET_DATA',\n        });\n\n        const data = await request(getRequestURL(endPoint), { method: 'GET', signal });\n\n        dispatch({\n          type: 'GET_DATA_SUCCEEDED',\n          data,\n        });\n      } catch (err) {\n        // The user aborted the request\n        if (isMounted.current) {\n          dispatch({\n            type: 'GET_DATA_ERROR',\n          });\n          console.error(err);\n          strapi.notification.toggle({\n            type: 'warning',\n            message: { id: 'notification.error' },\n          });\n        }\n      }\n    };\n\n    if (!isLoadingForPermissions) {\n      getData();\n    }\n\n    return () => {\n      abortController.abort();\n      isMounted.current = false;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isLoadingForPermissions, endPoint]);\n\n  const handleChange = useCallback(({ target: { name, value } }) => {\n    dispatch({\n      type: 'ON_CHANGE',\n      keys: name,\n      value,\n    });\n  }, []);\n\n  const dispatchResetForm = useCallback(() => {\n    dispatch({\n      type: 'RESET_FORM',\n    });\n  }, []);\n\n  const dispatchSetFormErrors = useCallback(errors => {\n    dispatch({ type: 'SET_ERRORS', errors });\n  }, []);\n\n  const dispatchSubmitSucceeded = useCallback(() => {\n    dispatch({\n      type: 'ON_SUBMIT_SUCCEEDED',\n    });\n  }, []);\n\n  return {\n    allowedActions,\n    dispatch,\n    dispatchResetForm,\n    dispatchSetFormErrors,\n    dispatchSubmitSucceeded,\n    formErrors,\n    handleChange,\n    initialData,\n    isLoading,\n    isLoadingForPermissions,\n    modifiedData,\n  };\n};\n\nexport default useUserForm;\n",
    "packages/strapi-plugin-users-permissions/admin/src/hooks/usePlugins/index.js": "import { useCallback, useEffect, useReducer } from 'react';\nimport { request } from 'strapi-helper-plugin';\nimport { useIntl } from 'react-intl';\nimport { get } from 'lodash';\nimport init from './init';\nimport pluginId from '../../pluginId';\nimport { cleanPermissions, formatPolicies, getTrad } from '../../utils';\nimport reducer, { initialState } from './reducer';\n\nconst usePlugins = (shouldFetchData = true) => {\n  const { formatMessage } = useIntl();\n  const [{ permissions, routes, policies, isLoading }, dispatch] = useReducer(\n    reducer,\n    initialState,\n    () => init(initialState, shouldFetchData)\n  );\n\n  const fetchPlugins = useCallback(async () => {\n    try {\n      dispatch({\n        type: 'GET_DATA',\n      });\n\n      const [{ permissions }, { routes }, { policies }] = await Promise.all(\n        [`/${pluginId}/permissions`, `/${pluginId}/routes`, `/${pluginId}/policies`].map(endpoint =>\n          request(endpoint, { method: 'GET' })\n        )\n      );\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        permissions: cleanPermissions(permissions),\n        routes,\n        policies: [\n          {\n            label: formatMessage({ id: getTrad('Policies.InputSelect.empty') }),\n            value: 'empty__string_value',\n          },\n          ...formatPolicies(policies),\n        ],\n      });\n    } catch (err) {\n      const message = get(err, ['response', 'payload', 'message'], 'An error occured');\n\n      dispatch({\n        type: 'GET_DATA_ERROR',\n      });\n\n      if (message !== 'Forbidden') {\n        strapi.notification.toggle({\n          type: 'warning',\n          message,\n        });\n      }\n    }\n  }, [formatMessage]);\n\n  useEffect(() => {\n    if (shouldFetchData) {\n      fetchPlugins();\n    }\n  }, [fetchPlugins, shouldFetchData]);\n\n  return {\n    permissions,\n    routes,\n    policies,\n    getData: fetchPlugins,\n    isLoading,\n  };\n};\n\nexport default usePlugins;\n",
    "packages/strapi-plugin-users-permissions/admin/src/hooks/useRolesList/index.js": "import { useEffect, useReducer, useRef } from 'react';\nimport { request } from 'strapi-helper-plugin';\nimport { get } from 'lodash';\nimport init from './init';\nimport pluginId from '../../pluginId';\nimport reducer, { initialState } from './reducer';\n\nconst useRolesList = (shouldFetchData = true) => {\n  const [{ roles, isLoading }, dispatch] = useReducer(reducer, initialState, () =>\n    init(initialState, shouldFetchData)\n  );\n\n  const isMounted = useRef(true);\n  const abortController = new AbortController();\n  const { signal } = abortController;\n\n  useEffect(() => {\n    if (shouldFetchData) {\n      fetchRolesList();\n    }\n\n    return () => {\n      abortController.abort();\n      isMounted.current = false;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [shouldFetchData]);\n\n  const fetchRolesList = async () => {\n    try {\n      dispatch({\n        type: 'GET_DATA',\n      });\n\n      const { roles } = await request(`/${pluginId}/roles`, { method: 'GET', signal });\n\n      dispatch({\n        type: 'GET_DATA_SUCCEEDED',\n        data: roles,\n      });\n    } catch (err) {\n      const message = get(err, ['response', 'payload', 'message'], 'An error occured');\n\n      if (isMounted.current) {\n        dispatch({\n          type: 'GET_DATA_ERROR',\n        });\n\n        if (message !== 'Forbidden') {\n          strapi.notification.toggle({\n            type: 'warning',\n            message,\n          });\n        }\n      }\n    }\n  };\n\n  return { roles, isLoading, getData: fetchRolesList };\n};\n\nexport default useRolesList;\n",
    "packages/strapi-plugin-users-permissions/config/functions/bootstrap.js": "'use strict';\n\n/**\n * An asynchronous bootstrap function that runs before\n * your application gets started.\n *\n * This gives you an opportunity to set up your data model,\n * run jobs, or perform some special logic.\n */\nconst _ = require('lodash');\nconst uuid = require('uuid/v4');\n\nconst usersPermissionsActions = require('../users-permissions-actions');\n\nmodule.exports = async () => {\n  const pluginStore = strapi.store({\n    environment: '',\n    type: 'plugin',\n    name: 'users-permissions',\n  });\n\n  const grantConfig = {\n    email: {\n      enabled: true,\n      icon: 'envelope',\n    },\n    discord: {\n      enabled: false,\n      icon: 'discord',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/discord/callback`,\n      scope: ['identify', 'email'],\n    },\n    facebook: {\n      enabled: false,\n      icon: 'facebook-square',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/facebook/callback`,\n      scope: ['email'],\n    },\n    google: {\n      enabled: false,\n      icon: 'google',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/google/callback`,\n      scope: ['email'],\n    },\n    github: {\n      enabled: false,\n      icon: 'github',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/github/callback`,\n      scope: ['user', 'user:email'],\n    },\n    microsoft: {\n      enabled: false,\n      icon: 'windows',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/microsoft/callback`,\n      scope: ['user.read'],\n    },\n    twitter: {\n      enabled: false,\n      icon: 'twitter',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/twitter/callback`,\n    },\n    instagram: {\n      enabled: false,\n      icon: 'instagram',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/instagram/callback`,\n      scope: ['user_profile'],\n    },\n    vk: {\n      enabled: false,\n      icon: 'vk',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/vk/callback`,\n      scope: ['email'],\n    },\n    twitch: {\n      enabled: false,\n      icon: 'twitch',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/twitch/callback`,\n      scope: ['user:read:email'],\n    },\n    linkedin: {\n      enabled: false,\n      icon: 'linkedin',\n      key: '',\n      secret: '',\n      callback: `${strapi.config.server.url}/auth/linkedin/callback`,\n      scope: ['r_liteprofile', 'r_emailaddress'],\n    },\n    cognito: {\n      enabled: false,\n      icon: 'aws',\n      key: '',\n      secret: '',\n      subdomain: 'my.subdomain.com',\n      callback: `${strapi.config.server.url}/auth/cognito/callback`,\n      scope: ['email', 'openid', 'profile'],\n    },\n    reddit: {\n      enabled: false,\n      icon: 'reddit',\n      key: '',\n      secret: '',\n      state: true,\n      callback: `${strapi.config.server.url}/auth/reddit/callback`,\n      scope: ['identity'],\n    },\n    auth0: {\n      enabled: false,\n      icon: '',\n      key: '',\n      secret: '',\n      subdomain: 'my-tenant.eu',\n      callback: `${strapi.config.server.url}/auth/auth0/callback`,\n      scope: ['openid', 'email', 'profile'],\n    },\n  };\n  const prevGrantConfig = (await pluginStore.get({ key: 'grant' })) || {};\n  // store grant auth config to db\n  // when plugin_users-permissions_grant is not existed in db\n  // or we have added/deleted provider here.\n  if (!prevGrantConfig || !_.isEqual(_.keys(prevGrantConfig), _.keys(grantConfig))) {\n    // merge with the previous provider config.\n    _.keys(grantConfig).forEach(key => {\n      if (key in prevGrantConfig) {\n        grantConfig[key] = _.merge(grantConfig[key], prevGrantConfig[key]);\n      }\n    });\n    await pluginStore.set({ key: 'grant', value: grantConfig });\n  }\n\n  if (!(await pluginStore.get({ key: 'email' }))) {\n    const value = {\n      reset_password: {\n        display: 'Email.template.reset_password',\n        icon: 'sync',\n        options: {\n          from: {\n            name: 'Administration Panel',\n            email: 'no-reply@strapi.io',\n          },\n          response_email: '',\n          object: 'Reset password',\n          message: `<p>We heard that you lost your password. Sorry about that!</p>\n\n<p>But don’t worry! You can use the following link to reset your password:</p>\n<p><%= URL %>?code=<%= TOKEN %></p>\n\n<p>Thanks.</p>`,\n        },\n      },\n      email_confirmation: {\n        display: 'Email.template.email_confirmation',\n        icon: 'check-square',\n        options: {\n          from: {\n            name: 'Administration Panel',\n            email: 'no-reply@strapi.io',\n          },\n          response_email: '',\n          object: 'Account confirmation',\n          message: `<p>Thank you for registering!</p>\n\n<p>You have to confirm your email address. Please click on the link below.</p>\n\n<p><%= URL %>?confirmation=<%= CODE %></p>\n\n<p>Thanks.</p>`,\n        },\n      },\n    };\n\n    await pluginStore.set({ key: 'email', value });\n  }\n\n  if (!(await pluginStore.get({ key: 'advanced' }))) {\n    const value = {\n      unique_email: true,\n      allow_register: true,\n      email_confirmation: false,\n      email_reset_password: null,\n      email_confirmation_redirection: null,\n      default_role: 'authenticated',\n    };\n\n    await pluginStore.set({ key: 'advanced', value });\n  }\n\n  await strapi.plugins['users-permissions'].services.userspermissions.initialize();\n\n  if (!_.get(strapi.plugins['users-permissions'], 'config.jwtSecret')) {\n    const jwtSecret = uuid();\n    _.set(strapi.plugins['users-permissions'], 'config.jwtSecret', jwtSecret);\n\n    strapi.reload.isWatching = false;\n\n    await strapi.fs.writePluginFile(\n      'users-permissions',\n      'config/jwt.js',\n      `module.exports = {\\n  jwtSecret: process.env.JWT_SECRET || '${jwtSecret}'\\n};`\n    );\n\n    strapi.reload.isWatching = true;\n  }\n\n  const { actionProvider } = strapi.admin.services.permission;\n  actionProvider.register(usersPermissionsActions.actions);\n};\n",
    "packages/strapi-plugin-users-permissions/config/policies/isAuthenticated.js": "'use strict';\n\nmodule.exports = async (ctx, next) => {\n  if (!ctx.state.user) {\n    return ctx.unauthorized();\n  }\n\n  await next();\n};\n",
    "packages/strapi-plugin-users-permissions/config/policies/permissions.js": "'use strict';\n\nconst _ = require('lodash');\n\nmodule.exports = async (ctx, next) => {\n  let role;\n\n  if (ctx.state.user) {\n    // request is already authenticated in a different way\n    return next();\n  }\n\n  if (ctx.request && ctx.request.header && ctx.request.header.authorization) {\n    try {\n      const { id } = await strapi.plugins['users-permissions'].services.jwt.getToken(ctx);\n\n      if (id === undefined) {\n        throw new Error('Invalid token: Token did not contain required fields');\n      }\n\n      // fetch authenticated user\n      ctx.state.user = await strapi.plugins[\n        'users-permissions'\n      ].services.user.fetchAuthenticatedUser(id);\n    } catch (err) {\n      return handleErrors(ctx, err, 'unauthorized');\n    }\n\n    if (!ctx.state.user) {\n      return handleErrors(ctx, 'User Not Found', 'unauthorized');\n    }\n\n    role = ctx.state.user.role;\n\n    if (role.type === 'root') {\n      return await next();\n    }\n\n    const store = await strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n    });\n\n    if (\n      _.get(await store.get({ key: 'advanced' }), 'email_confirmation') &&\n      !ctx.state.user.confirmed\n    ) {\n      return handleErrors(ctx, 'Your account email is not confirmed.', 'unauthorized');\n    }\n\n    if (ctx.state.user.blocked) {\n      return handleErrors(\n        ctx,\n        'Your account has been blocked by the administrator.',\n        'unauthorized'\n      );\n    }\n  }\n\n  // Retrieve `public` role.\n  if (!role) {\n    role = await strapi.query('role', 'users-permissions').findOne({ type: 'public' }, []);\n  }\n\n  const route = ctx.request.route;\n  const permission = await strapi.query('permission', 'users-permissions').findOne(\n    {\n      role: role.id,\n      type: route.plugin || 'application',\n      controller: route.controller,\n      action: route.action,\n      enabled: true,\n    },\n    []\n  );\n\n  if (!permission) {\n    return handleErrors(ctx, undefined, 'forbidden');\n  }\n\n  // Execute the policies.\n  if (permission.policy) {\n    return await strapi.plugins['users-permissions'].config.policies[permission.policy](ctx, next);\n  }\n\n  // Execute the action.\n  await next();\n};\n\nconst handleErrors = (ctx, err = undefined, type) => {\n  throw strapi.errors[type](err);\n};\n",
    "packages/strapi-plugin-users-permissions/config/schema.graphql.js": "'use strict';\n\nconst _ = require('lodash');\n\n/**\n * Throws an ApolloError if context body contains a bad request\n * @param contextBody - body of the context object given to the resolver\n * @throws ApolloError if the body is a bad request\n */\nfunction checkBadRequest(contextBody) {\n  if (_.get(contextBody, 'statusCode', 200) !== 200) {\n    const message = _.get(contextBody, 'error', 'Bad Request');\n    const exception = new Error(message);\n    exception.code = _.get(contextBody, 'statusCode', 400);\n    exception.data = contextBody;\n    throw exception;\n  }\n}\n\nmodule.exports = {\n  type: {\n    UsersPermissionsPermission: false, // Make this type NOT queriable.\n  },\n  definition: /* GraphQL */ `\n    type UsersPermissionsMe {\n      id: ID!\n      username: String!\n      email: String!\n      confirmed: Boolean\n      blocked: Boolean\n      role: UsersPermissionsMeRole\n    }\n\n    type UsersPermissionsMeRole {\n      id: ID!\n      name: String!\n      description: String\n      type: String\n    }\n\n    input UsersPermissionsRegisterInput {\n      username: String!\n      email: String!\n      password: String!\n    }\n\n    input UsersPermissionsLoginInput {\n      identifier: String!\n      password: String!\n      provider: String = \"local\"\n    }\n\n    type UsersPermissionsLoginPayload {\n      jwt: String\n      user: UsersPermissionsMe!\n    }\n\n    type UserPermissionsPasswordPayload {\n      ok: Boolean!\n    }\n  `,\n  query: `\n    me: UsersPermissionsMe\n  `,\n  mutation: `\n    login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!\n    register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!\n    forgotPassword(email: String!): UserPermissionsPasswordPayload\n    resetPassword(password: String!, passwordConfirmation: String!, code: String!): UsersPermissionsLoginPayload\n    emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload\n  `,\n  resolver: {\n    Query: {\n      me: {\n        resolver: 'plugins::users-permissions.user.me',\n      },\n      role: {\n        resolverOf: 'plugins::users-permissions.userspermissions.getRole',\n        resolver: async (obj, options, { context }) => {\n          context.params = { ...context.params, ...options.input };\n\n          await strapi.plugins['users-permissions'].controllers.userspermissions.getRole(context);\n\n          return context.body.role;\n        },\n      },\n      roles: {\n        description: `Retrieve all the existing roles. You can't apply filters on this query.`,\n        resolverOf: 'plugins::users-permissions.userspermissions.getRoles', // Apply the `getRoles` permissions on the resolver.\n        resolver: async (obj, options, { context }) => {\n          context.params = { ...context.params, ...options.input };\n\n          await strapi.plugins['users-permissions'].controllers.userspermissions.getRoles(context);\n\n          return context.body.roles;\n        },\n      },\n    },\n    Mutation: {\n      createRole: {\n        description: 'Create a new role',\n        resolverOf: 'plugins::users-permissions.userspermissions.createRole',\n        resolver: async (obj, options, { context }) => {\n          await strapi.plugins['users-permissions'].controllers.userspermissions.createRole(\n            context\n          );\n\n          return { ok: true };\n        },\n      },\n      updateRole: {\n        description: 'Update an existing role',\n        resolverOf: 'plugins::users-permissions.userspermissions.updateRole',\n        resolver: async (obj, options, { context }) => {\n          context.params = { ...context.params, ...options.input };\n          context.params.role = context.params.id;\n\n          await strapi.plugins['users-permissions'].controllers.userspermissions.updateRole(\n            context\n          );\n\n          return { ok: true };\n        },\n      },\n      deleteRole: {\n        description: 'Delete an existing role',\n        resolverOf: 'plugins::users-permissions.userspermissions.deleteRole',\n        resolver: async (obj, options, { context }) => {\n          context.params = { ...context.params, ...options.input };\n          context.params.role = context.params.id;\n\n          await strapi.plugins['users-permissions'].controllers.userspermissions.deleteRole(\n            context\n          );\n\n          return { ok: true };\n        },\n      },\n      createUser: {\n        description: 'Create a new user',\n        resolverOf: 'plugins::users-permissions.user.create',\n        resolver: async (obj, options, { context }) => {\n          context.params = _.toPlainObject(options.input.where);\n          context.request.body = _.toPlainObject(options.input.data);\n\n          await strapi.plugins['users-permissions'].controllers.user.create(context);\n\n          return {\n            user: context.body.toJSON ? context.body.toJSON() : context.body,\n          };\n        },\n      },\n      updateUser: {\n        description: 'Update an existing user',\n        resolverOf: 'plugins::users-permissions.user.update',\n        resolver: async (obj, options, { context }) => {\n          context.params = _.toPlainObject(options.input.where);\n          context.request.body = _.toPlainObject(options.input.data);\n\n          await strapi.plugins['users-permissions'].controllers.user.update(context);\n\n          return {\n            user: context.body.toJSON ? context.body.toJSON() : context.body,\n          };\n        },\n      },\n      deleteUser: {\n        description: 'Delete an existing user',\n        resolverOf: 'plugins::users-permissions.user.destroy',\n        resolver: async (obj, options, { context }) => {\n          // Set parameters to context.\n          context.params = _.toPlainObject(options.input.where);\n          context.request.body = _.toPlainObject(options.input.data);\n\n          // Retrieve user to be able to return it because\n          // Bookshelf doesn't return the row once deleted.\n          await strapi.plugins['users-permissions'].controllers.user.findOne(context);\n          // Assign result to user.\n          const user = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          // Run destroy query.\n          await strapi.plugins['users-permissions'].controllers.user.destroy(context);\n\n          return {\n            user,\n          };\n        },\n      },\n      register: {\n        description: 'Register a user',\n        resolverOf: 'plugins::users-permissions.auth.register',\n        resolver: async (obj, options, { context }) => {\n          context.request.body = _.toPlainObject(options.input);\n\n          await strapi.plugins['users-permissions'].controllers.auth.register(context);\n          let output = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          checkBadRequest(output);\n          return {\n            user: output.user || output,\n            jwt: output.jwt,\n          };\n        },\n      },\n      login: {\n        resolverOf: 'plugins::users-permissions.auth.callback',\n        resolver: async (obj, options, { context }) => {\n          context.params = {\n            ...context.params,\n            provider: options.input.provider,\n          };\n          context.request.body = _.toPlainObject(options.input);\n\n          await strapi.plugins['users-permissions'].controllers.auth.callback(context);\n          let output = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          checkBadRequest(output);\n          return {\n            user: output.user || output,\n            jwt: output.jwt,\n          };\n        },\n      },\n      forgotPassword: {\n        description: 'Request a reset password token',\n        resolverOf: 'plugins::users-permissions.auth.forgotPassword',\n        resolver: async (obj, options, { context }) => {\n          context.request.body = _.toPlainObject(options);\n\n          await strapi.plugins['users-permissions'].controllers.auth.forgotPassword(context);\n          let output = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          checkBadRequest(output);\n\n          return {\n            ok: output.ok || output,\n          };\n        },\n      },\n      resetPassword: {\n        description: 'Reset user password. Confirm with a code (resetToken from forgotPassword)',\n        resolverOf: 'plugins::users-permissions.auth.resetPassword',\n        resolver: async (obj, options, { context }) => {\n          context.request.body = _.toPlainObject(options);\n\n          await strapi.plugins['users-permissions'].controllers.auth.resetPassword(context);\n          let output = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          checkBadRequest(output);\n\n          return {\n            user: output.user || output,\n            jwt: output.jwt,\n          };\n        },\n      },\n      emailConfirmation: {\n        description: 'Confirm an email users email address',\n        resolverOf: 'plugins::users-permissions.auth.emailConfirmation',\n        resolver: async (obj, options, { context }) => {\n          context.query = _.toPlainObject(options);\n\n          await strapi.plugins['users-permissions'].controllers.auth.emailConfirmation(\n            context,\n            null,\n            true\n          );\n          let output = context.body.toJSON ? context.body.toJSON() : context.body;\n\n          checkBadRequest(output);\n\n          return {\n            user: output.user || output,\n            jwt: output.jwt,\n          };\n        },\n      },\n    },\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/controllers/Auth.js": "'use strict';\n\n/**\n * Auth.js controller\n *\n * @description: A set of functions called \"actions\" for managing `Auth`.\n */\n\n/* eslint-disable no-useless-escape */\nconst crypto = require('crypto');\nconst _ = require('lodash');\nconst grant = require('grant-koa');\nconst { sanitizeEntity } = require('strapi-utils');\n\nconst emailRegExp = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\nconst formatError = error => [\n  { messages: [{ id: error.id, message: error.message, field: error.field }] },\n];\n\nmodule.exports = {\n  async callback(ctx) {\n    const provider = ctx.params.provider || 'local';\n    const params = ctx.request.body;\n\n    const store = await strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n    });\n\n    if (provider === 'local') {\n      if (!_.get(await store.get({ key: 'grant' }), 'email.enabled')) {\n        return ctx.badRequest(null, 'This provider is disabled.');\n      }\n\n      // The identifier is required.\n      if (!params.identifier) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.email.provide',\n            message: 'Please provide your username or your e-mail.',\n          })\n        );\n      }\n\n      // The password is required.\n      if (!params.password) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.password.provide',\n            message: 'Please provide your password.',\n          })\n        );\n      }\n\n      const query = { provider };\n\n      // Check if the provided identifier is an email or not.\n      const isEmail = emailRegExp.test(params.identifier);\n\n      // Set the identifier to the appropriate query field.\n      if (isEmail) {\n        query.email = params.identifier.toLowerCase();\n      } else {\n        query.username = params.identifier;\n      }\n\n      // Check if the user exists.\n      const user = await strapi.query('user', 'users-permissions').findOne(query);\n\n      if (!user) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.invalid',\n            message: 'Identifier or password invalid.',\n          })\n        );\n      }\n\n      if (\n        _.get(await store.get({ key: 'advanced' }), 'email_confirmation') &&\n        user.confirmed !== true\n      ) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.confirmed',\n            message: 'Your account email is not confirmed',\n          })\n        );\n      }\n\n      if (user.blocked === true) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.blocked',\n            message: 'Your account has been blocked by an administrator',\n          })\n        );\n      }\n\n      // The user never authenticated with the `local` provider.\n      if (!user.password) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.password.local',\n            message:\n              'This user never set a local password, please login with the provider used during account creation.',\n          })\n        );\n      }\n\n      const validPassword = await strapi.plugins[\n        'users-permissions'\n      ].services.user.validatePassword(params.password, user.password);\n\n      if (!validPassword) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.invalid',\n            message: 'Identifier or password invalid.',\n          })\n        );\n      } else {\n        ctx.send({\n          jwt: strapi.plugins['users-permissions'].services.jwt.issue({\n            id: user.id,\n          }),\n          user: sanitizeEntity(user.toJSON ? user.toJSON() : user, {\n            model: strapi.query('user', 'users-permissions').model,\n          }),\n        });\n      }\n    } else {\n      if (!_.get(await store.get({ key: 'grant' }), [provider, 'enabled'])) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'provider.disabled',\n            message: 'This provider is disabled.',\n          })\n        );\n      }\n\n      // Connect the user with the third-party provider.\n      let user, error;\n      try {\n        [user, error] = await strapi.plugins['users-permissions'].services.providers.connect(\n          provider,\n          ctx.query\n        );\n      } catch ([user, error]) {\n        return ctx.badRequest(null, error === 'array' ? error[0] : error);\n      }\n\n      if (!user) {\n        return ctx.badRequest(null, error === 'array' ? error[0] : error);\n      }\n\n      ctx.send({\n        jwt: strapi.plugins['users-permissions'].services.jwt.issue({\n          id: user.id,\n        }),\n        user: sanitizeEntity(user.toJSON ? user.toJSON() : user, {\n          model: strapi.query('user', 'users-permissions').model,\n        }),\n      });\n    }\n  },\n\n  async resetPassword(ctx) {\n    const params = _.assign({}, ctx.request.body, ctx.params);\n\n    if (\n      params.password &&\n      params.passwordConfirmation &&\n      params.password === params.passwordConfirmation &&\n      params.code\n    ) {\n      const user = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ resetPasswordToken: `${params.code}` });\n\n      if (!user) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.code.provide',\n            message: 'Incorrect code provided.',\n          })\n        );\n      }\n\n      const password = await strapi.plugins['users-permissions'].services.user.hashPassword({\n        password: params.password,\n      });\n\n      // Update the user.\n      await strapi\n        .query('user', 'users-permissions')\n        .update({ id: user.id }, { resetPasswordToken: null, password });\n\n      ctx.send({\n        jwt: strapi.plugins['users-permissions'].services.jwt.issue({\n          id: user.id,\n        }),\n        user: sanitizeEntity(user.toJSON ? user.toJSON() : user, {\n          model: strapi.query('user', 'users-permissions').model,\n        }),\n      });\n    } else if (\n      params.password &&\n      params.passwordConfirmation &&\n      params.password !== params.passwordConfirmation\n    ) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.password.matching',\n          message: 'Passwords do not match.',\n        })\n      );\n    } else {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.params.provide',\n          message: 'Incorrect params provided.',\n        })\n      );\n    }\n  },\n\n  async connect(ctx, next) {\n    const grantConfig = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'grant',\n      })\n      .get();\n\n    const [requestPath] = ctx.request.url.split('?');\n    const provider = requestPath.split('/')[2];\n\n    if (!_.get(grantConfig[provider], 'enabled')) {\n      return ctx.badRequest(null, 'This provider is disabled.');\n    }\n\n    if (!strapi.config.server.url.startsWith('http')) {\n      strapi.log.warn(\n        'You are using a third party provider for login. Make sure to set an absolute url in config/server.js. More info here: https://strapi.io/documentation/developer-docs/latest/plugins/users-permissions.html#setting-up-the-server-url'\n      );\n    }\n\n    // Ability to pass OAuth callback dynamically\n    grantConfig[provider].callback = _.get(ctx, 'query.callback') || grantConfig[provider].callback;\n    grantConfig[provider].redirect_uri = strapi.plugins[\n      'users-permissions'\n    ].services.providers.buildRedirectUri(provider);\n\n    return grant(grantConfig)(ctx, next);\n  },\n\n  async forgotPassword(ctx) {\n    let { email } = ctx.request.body;\n\n    // Check if the provided email is valid or not.\n    const isEmail = emailRegExp.test(email);\n\n    if (isEmail) {\n      email = email.toLowerCase();\n    } else {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.email.format',\n          message: 'Please provide valid email address.',\n        })\n      );\n    }\n\n    const pluginStore = await strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n    });\n\n    // Find the user by email.\n    const user = await strapi\n      .query('user', 'users-permissions')\n      .findOne({ email: email.toLowerCase() });\n\n    // User not found.\n    if (!user) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.user.not-exist',\n          message: 'This email does not exist.',\n        })\n      );\n    }\n\n    // Generate random token.\n    const resetPasswordToken = crypto.randomBytes(64).toString('hex');\n\n    const settings = await pluginStore.get({ key: 'email' }).then(storeEmail => {\n      try {\n        return storeEmail['reset_password'].options;\n      } catch (error) {\n        return {};\n      }\n    });\n\n    const advanced = await pluginStore.get({\n      key: 'advanced',\n    });\n\n    const userInfo = sanitizeEntity(user, {\n      model: strapi.query('user', 'users-permissions').model,\n    });\n\n    settings.message = await strapi.plugins['users-permissions'].services.userspermissions.template(\n      settings.message,\n      {\n        URL: advanced.email_reset_password,\n        USER: userInfo,\n        TOKEN: resetPasswordToken,\n      }\n    );\n\n    settings.object = await strapi.plugins['users-permissions'].services.userspermissions.template(\n      settings.object,\n      {\n        USER: userInfo,\n      }\n    );\n\n    try {\n      // Send an email to the user.\n      await strapi.plugins['email'].services.email.send({\n        to: user.email,\n        from:\n          settings.from.email || settings.from.name\n            ? `${settings.from.name} <${settings.from.email}>`\n            : undefined,\n        replyTo: settings.response_email,\n        subject: settings.object,\n        text: settings.message,\n        html: settings.message,\n      });\n    } catch (err) {\n      return ctx.badRequest(null, err);\n    }\n\n    // Update the user.\n    await strapi.query('user', 'users-permissions').update({ id: user.id }, { resetPasswordToken });\n\n    ctx.send({ ok: true });\n  },\n\n  async register(ctx) {\n    const pluginStore = await strapi.store({\n      environment: '',\n      type: 'plugin',\n      name: 'users-permissions',\n    });\n\n    const settings = await pluginStore.get({\n      key: 'advanced',\n    });\n\n    if (!settings.allow_register) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.advanced.allow_register',\n          message: 'Register action is currently disabled.',\n        })\n      );\n    }\n\n    const params = {\n      ..._.omit(ctx.request.body, ['confirmed', 'confirmationToken', 'resetPasswordToken']),\n      provider: 'local',\n    };\n\n    // Password is required.\n    if (!params.password) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.password.provide',\n          message: 'Please provide your password.',\n        })\n      );\n    }\n\n    // Email is required.\n    if (!params.email) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.email.provide',\n          message: 'Please provide your email.',\n        })\n      );\n    }\n\n    // Throw an error if the password selected by the user\n    // contains more than three times the symbol '$'.\n    if (strapi.plugins['users-permissions'].services.user.isHashed(params.password)) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.password.format',\n          message: 'Your password cannot contain more than three times the symbol `$`.',\n        })\n      );\n    }\n\n    const role = await strapi\n      .query('role', 'users-permissions')\n      .findOne({ type: settings.default_role }, []);\n\n    if (!role) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.role.notFound',\n          message: 'Impossible to find the default role.',\n        })\n      );\n    }\n\n    // Check if the provided email is valid or not.\n    const isEmail = emailRegExp.test(params.email);\n\n    if (isEmail) {\n      params.email = params.email.toLowerCase();\n    } else {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.email.format',\n          message: 'Please provide valid email address.',\n        })\n      );\n    }\n\n    params.role = role.id;\n    params.password = await strapi.plugins['users-permissions'].services.user.hashPassword(params);\n\n    const user = await strapi.query('user', 'users-permissions').findOne({\n      email: params.email,\n    });\n\n    if (user && user.provider === params.provider) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.email.taken',\n          message: 'Email is already taken.',\n        })\n      );\n    }\n\n    if (user && user.provider !== params.provider && settings.unique_email) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.email.taken',\n          message: 'Email is already taken.',\n        })\n      );\n    }\n\n    try {\n      if (!settings.email_confirmation) {\n        params.confirmed = true;\n      }\n\n      const user = await strapi.query('user', 'users-permissions').create(params);\n\n      const sanitizedUser = sanitizeEntity(user, {\n        model: strapi.query('user', 'users-permissions').model,\n      });\n\n      if (settings.email_confirmation) {\n        try {\n          await strapi.plugins['users-permissions'].services.user.sendConfirmationEmail(user);\n        } catch (err) {\n          return ctx.badRequest(null, err);\n        }\n\n        return ctx.send({ user: sanitizedUser });\n      }\n\n      const jwt = strapi.plugins['users-permissions'].services.jwt.issue(_.pick(user, ['id']));\n\n      return ctx.send({\n        jwt,\n        user: sanitizedUser,\n      });\n    } catch (err) {\n      const adminError = _.includes(err.message, 'username')\n        ? {\n            id: 'Auth.form.error.username.taken',\n            message: 'Username already taken',\n          }\n        : { id: 'Auth.form.error.email.taken', message: 'Email already taken' };\n\n      ctx.badRequest(null, formatError(adminError));\n    }\n  },\n\n  async emailConfirmation(ctx, next, returnUser) {\n    const { confirmation: confirmationToken } = ctx.query;\n\n    const { user: userService, jwt: jwtService } = strapi.plugins['users-permissions'].services;\n\n    if (_.isEmpty(confirmationToken)) {\n      return ctx.badRequest('token.invalid');\n    }\n\n    const user = await userService.fetch({ confirmationToken }, []);\n\n    if (!user) {\n      return ctx.badRequest('token.invalid');\n    }\n\n    await userService.edit({ id: user.id }, { confirmed: true, confirmationToken: null });\n\n    if (returnUser) {\n      ctx.send({\n        jwt: jwtService.issue({ id: user.id }),\n        user: sanitizeEntity(user, {\n          model: strapi.query('user', 'users-permissions').model,\n        }),\n      });\n    } else {\n      const settings = await strapi\n        .store({\n          environment: '',\n          type: 'plugin',\n          name: 'users-permissions',\n          key: 'advanced',\n        })\n        .get();\n\n      ctx.redirect(settings.email_confirmation_redirection || '/');\n    }\n  },\n\n  async sendEmailConfirmation(ctx) {\n    const params = _.assign(ctx.request.body);\n\n    if (!params.email) {\n      return ctx.badRequest('missing.email');\n    }\n\n    const isEmail = emailRegExp.test(params.email);\n\n    if (isEmail) {\n      params.email = params.email.toLowerCase();\n    } else {\n      return ctx.badRequest('wrong.email');\n    }\n\n    const user = await strapi.query('user', 'users-permissions').findOne({\n      email: params.email,\n    });\n\n    if (user.confirmed) {\n      return ctx.badRequest('already.confirmed');\n    }\n\n    if (user.blocked) {\n      return ctx.badRequest('blocked.user');\n    }\n\n    try {\n      await strapi.plugins['users-permissions'].services.user.sendConfirmationEmail(user);\n      ctx.send({\n        email: user.email,\n        sent: true,\n      });\n    } catch (err) {\n      return ctx.badRequest(null, err);\n    }\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/controllers/User.js": "'use strict';\n\n/**\n * User.js controller\n *\n * @description: A set of functions called \"actions\" for managing `User`.\n */\n\nconst _ = require('lodash');\nconst { sanitizeEntity } = require('strapi-utils');\nconst adminUserController = require('./user/admin');\nconst apiUserController = require('./user/api');\n\nconst sanitizeUser = user =>\n  sanitizeEntity(user, {\n    model: strapi.query('user', 'users-permissions').model,\n  });\n\nconst resolveController = ctx => {\n  const {\n    state: { isAuthenticatedAdmin },\n  } = ctx;\n\n  return isAuthenticatedAdmin ? adminUserController : apiUserController;\n};\n\nconst resolveControllerMethod = method => ctx => {\n  const controller = resolveController(ctx);\n  const callbackFn = controller[method];\n\n  if (!_.isFunction(callbackFn)) {\n    return ctx.notFound();\n  }\n\n  return callbackFn(ctx);\n};\n\nmodule.exports = {\n  create: resolveControllerMethod('create'),\n  update: resolveControllerMethod('update'),\n\n  /**\n   * Retrieve user records.\n   * @return {Object|Array}\n   */\n  async find(ctx, next, { populate } = {}) {\n    let users;\n\n    if (_.has(ctx.query, '_q')) {\n      // use core strapi query to search for users\n      users = await strapi.query('user', 'users-permissions').search(ctx.query, populate);\n    } else {\n      users = await strapi.plugins['users-permissions'].services.user.fetchAll(ctx.query, populate);\n    }\n\n    ctx.body = users.map(sanitizeUser);\n  },\n\n  /**\n   * Retrieve a user record.\n   * @return {Object}\n   */\n  async findOne(ctx) {\n    const { id } = ctx.params;\n    let data = await strapi.plugins['users-permissions'].services.user.fetch({\n      id,\n    });\n\n    if (data) {\n      data = sanitizeUser(data);\n    }\n\n    // Send 200 `ok`\n    ctx.body = data;\n  },\n\n  /**\n   * Retrieve user count.\n   * @return {Number}\n   */\n  async count(ctx) {\n    if (_.has(ctx.query, '_q')) {\n      return await strapi.plugins['users-permissions'].services.user.countSearch(ctx.query);\n    }\n    ctx.body = await strapi.plugins['users-permissions'].services.user.count(ctx.query);\n  },\n\n  /**\n   * Destroy a/an user record.\n   * @return {Object}\n   */\n  async destroy(ctx) {\n    const { id } = ctx.params;\n    const data = await strapi.plugins['users-permissions'].services.user.remove({ id });\n    ctx.send(sanitizeUser(data));\n  },\n\n  async destroyAll(ctx) {\n    const {\n      request: { query },\n    } = ctx;\n\n    const toRemove = Object.values(_.omit(query, 'source'));\n    const { primaryKey } = strapi.query('user', 'users-permissions');\n    const finalQuery = { [`${primaryKey}_in`]: toRemove, _limit: 100 };\n\n    const data = await strapi.plugins['users-permissions'].services.user.removeAll(finalQuery);\n\n    ctx.send(data);\n  },\n\n  /**\n   * Retrieve authenticated user.\n   * @return {Object|Array}\n   */\n  async me(ctx) {\n    const user = ctx.state.user;\n\n    if (!user) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'No authorization header was found' }] }]);\n    }\n\n    ctx.body = sanitizeUser(user);\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/controllers/UsersPermissions.js": "'use strict';\n\n/**\n * UsersPermissions.js controller\n *\n * @description: A set of functions called \"actions\" of the `users-permissions` plugin.\n */\n\nconst _ = require('lodash');\nconst { isValidEmailTemplate } = require('./validation/email-template');\n\nmodule.exports = {\n  /**\n   * Default action.\n   *\n   * @return {Object}\n   */\n  async createRole(ctx) {\n    if (_.isEmpty(ctx.request.body)) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Cannot be empty' }] }]);\n    }\n\n    try {\n      await strapi.plugins['users-permissions'].services.userspermissions.createRole(\n        ctx.request.body\n      );\n\n      ctx.send({ ok: true });\n    } catch (err) {\n      strapi.log.error(err);\n      ctx.badRequest(null, [{ messages: [{ id: 'An error occured' }] }]);\n    }\n  },\n\n  async deleteRole(ctx) {\n    // Fetch public role.\n    const publicRole = await strapi.query('role', 'users-permissions').findOne({ type: 'public' });\n\n    const publicRoleID = publicRole.id;\n\n    const roleID = ctx.params.role;\n\n    if (!roleID) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Bad request' }] }]);\n    }\n\n    // Prevent from removing the public role.\n    if (roleID.toString() === publicRoleID.toString()) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Unauthorized' }] }]);\n    }\n\n    try {\n      await strapi.plugins['users-permissions'].services.userspermissions.deleteRole(\n        roleID,\n        publicRoleID\n      );\n\n      ctx.send({ ok: true });\n    } catch (err) {\n      strapi.log.error(err);\n      ctx.badRequest(null, [{ messages: [{ id: 'Bad request' }] }]);\n    }\n  },\n\n  async getPermissions(ctx) {\n    try {\n      const permissions = await strapi.plugins[\n        'users-permissions'\n      ].services.userspermissions.getActions();\n\n      ctx.send({ permissions });\n    } catch (err) {\n      ctx.badRequest(null, [{ message: [{ id: 'Not Found' }] }]);\n    }\n  },\n\n  async getPolicies(ctx) {\n    ctx.send({\n      policies: _.without(\n        _.keys(strapi.plugins['users-permissions'].config.policies),\n        'permissions'\n      ),\n    });\n  },\n\n  async getRole(ctx) {\n    const { id } = ctx.params;\n    const { lang } = ctx.query;\n    const plugins = await strapi.plugins['users-permissions'].services.userspermissions.getPlugins(\n      lang\n    );\n    const role = await strapi.plugins['users-permissions'].services.userspermissions.getRole(\n      id,\n      plugins\n    );\n\n    if (_.isEmpty(role)) {\n      return ctx.badRequest(null, [{ messages: [{ id: `Role don't exist` }] }]);\n    }\n\n    ctx.send({ role });\n  },\n\n  async getRoles(ctx) {\n    try {\n      const roles = await strapi.plugins['users-permissions'].services.userspermissions.getRoles();\n\n      ctx.send({ roles });\n    } catch (err) {\n      ctx.badRequest(null, [{ messages: [{ id: 'Not found' }] }]);\n    }\n  },\n\n  async getRoutes(ctx) {\n    try {\n      const routes = await strapi.plugins[\n        'users-permissions'\n      ].services.userspermissions.getRoutes();\n\n      ctx.send({ routes });\n    } catch (err) {\n      ctx.badRequest(null, [{ messages: [{ id: 'Not found' }] }]);\n    }\n  },\n\n  async index(ctx) {\n    // Send 200 `ok`\n    ctx.send({ message: 'ok' });\n  },\n\n  async searchUsers(ctx) {\n    const { id } = ctx.params;\n\n    const data = await strapi.query('user', 'users-permissions').custom(searchQueries)({\n      id,\n    });\n\n    ctx.send(data);\n  },\n\n  async updateRole(ctx) {\n    const roleID = ctx.params.role;\n\n    if (_.isEmpty(ctx.request.body)) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Bad request' }] }]);\n    }\n\n    try {\n      await strapi.plugins['users-permissions'].services.userspermissions.updateRole(\n        roleID,\n        ctx.request.body\n      );\n\n      ctx.send({ ok: true });\n    } catch (err) {\n      strapi.log.error(err);\n      ctx.badRequest(null, [{ messages: [{ id: 'An error occurred' }] }]);\n    }\n  },\n\n  async getEmailTemplate(ctx) {\n    ctx.send(\n      await strapi\n        .store({\n          environment: '',\n          type: 'plugin',\n          name: 'users-permissions',\n          key: 'email',\n        })\n        .get()\n    );\n  },\n\n  async updateEmailTemplate(ctx) {\n    if (_.isEmpty(ctx.request.body)) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Cannot be empty' }] }]);\n    }\n\n    const emailTemplates = ctx.request.body['email-templates'];\n\n    for (let key in emailTemplates) {\n      const template = emailTemplates[key].options.message;\n\n      if (!isValidEmailTemplate(template)) {\n        return ctx.badRequest(null, [{ messages: [{ id: 'Invalid template' }] }]);\n      }\n    }\n\n    await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'email',\n      })\n      .set({ value: emailTemplates });\n\n    ctx.send({ ok: true });\n  },\n\n  async getAdvancedSettings(ctx) {\n    ctx.send({\n      settings: await strapi\n        .store({\n          environment: '',\n          type: 'plugin',\n          name: 'users-permissions',\n          key: 'advanced',\n        })\n        .get(),\n      roles: await strapi.plugins['users-permissions'].services.userspermissions.getRoles(),\n    });\n  },\n\n  async updateAdvancedSettings(ctx) {\n    if (_.isEmpty(ctx.request.body)) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Cannot be empty' }] }]);\n    }\n\n    await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'advanced',\n      })\n      .set({ value: ctx.request.body });\n\n    ctx.send({ ok: true });\n  },\n\n  async getProviders(ctx) {\n    const providers = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'grant',\n      })\n      .get();\n\n    for (const provider in providers) {\n      if (provider !== 'email') {\n        providers[provider].redirectUri = strapi.plugins[\n          'users-permissions'\n        ].services.providers.buildRedirectUri(provider);\n      }\n    }\n\n    ctx.send(providers);\n  },\n\n  async updateProviders(ctx) {\n    if (_.isEmpty(ctx.request.body)) {\n      return ctx.badRequest(null, [{ messages: [{ id: 'Cannot be empty' }] }]);\n    }\n\n    await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'grant',\n      })\n      .set({ value: ctx.request.body.providers });\n\n    ctx.send({ ok: true });\n  },\n};\n\nconst searchQueries = {\n  bookshelf({ model }) {\n    return ({ id }) => {\n      return model\n        .query(function(qb) {\n          qb.where('username', 'LIKE', `%${id}%`).orWhere('email', 'LIKE', `%${id}%`);\n        })\n        .fetchAll()\n        .then(results => results.toJSON());\n    };\n  },\n  mongoose({ model }) {\n    return ({ id }) => {\n      const re = new RegExp(id);\n\n      return model.find({\n        $or: [{ username: re }, { email: re }],\n      });\n    };\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/controllers/user/admin.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst { contentTypes: contentTypesUtils } = require('strapi-utils');\n\nconst { UPDATED_BY_ATTRIBUTE, CREATED_BY_ATTRIBUTE } = contentTypesUtils.constants;\n\nconst formatError = error => [\n  { messages: [{ id: error.id, message: error.message, field: error.field }] },\n];\n\nconst userModel = 'plugins::users-permissions.user';\nconst ACTIONS = {\n  read: 'plugins::content-manager.explorer.read',\n  create: 'plugins::content-manager.explorer.create',\n  edit: 'plugins::content-manager.explorer.update',\n  delete: 'plugins::content-manager.explorer.delete',\n};\n\nconst findEntityAndCheckPermissions = async (ability, action, model, id) => {\n  const entity = await strapi.query('user', 'users-permissions').findOne({ id });\n\n  if (_.isNil(entity)) {\n    throw strapi.errors.notFound();\n  }\n\n  const pm = strapi.admin.services.permission.createPermissionsManager({ ability, action, model });\n\n  const roles = _.has(entity, `${CREATED_BY_ATTRIBUTE}.id`)\n    ? await strapi.query('role', 'admin').find({ 'users.id': entity[CREATED_BY_ATTRIBUTE].id }, [])\n    : [];\n  const entityWithRoles = _.set(_.cloneDeep(entity), `${CREATED_BY_ATTRIBUTE}.roles`, roles);\n\n  if (pm.ability.cannot(pm.action, pm.toSubject(entityWithRoles))) {\n    throw strapi.errors.forbidden();\n  }\n\n  return { pm, entity };\n};\n\nmodule.exports = {\n  /**\n   * Create a/an user record.\n   * @return {Object}\n   */\n  async create(ctx) {\n    const {\n      request: { body },\n      state: { userAbility, admin },\n    } = ctx;\n    const { email, username, password } = body;\n\n    const pm = strapi.admin.services.permission.createPermissionsManager({\n      ability: userAbility,\n      action: ACTIONS.create,\n      model: userModel,\n    });\n\n    if (!pm.isAllowed) {\n      throw strapi.errors.forbidden();\n    }\n\n    const sanitizedBody = pm.pickPermittedFieldsOf(body, { subject: userModel });\n\n    const advanced = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'advanced',\n      })\n      .get();\n\n    if (!email) return ctx.badRequest('missing.email');\n    if (!username) return ctx.badRequest('missing.username');\n    if (!password) return ctx.badRequest('missing.password');\n\n    const userWithSameUsername = await strapi\n      .query('user', 'users-permissions')\n      .findOne({ username });\n\n    if (userWithSameUsername) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.username.taken',\n          message: 'Username already taken.',\n          field: ['username'],\n        })\n      );\n    }\n\n    if (advanced.unique_email) {\n      const userWithSameEmail = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ email: email.toLowerCase() });\n\n      if (userWithSameEmail) {\n        return ctx.badRequest(\n          null,\n\n          formatError({\n            id: 'Auth.form.error.email.taken',\n            message: 'Email already taken.',\n            field: ['email'],\n          })\n        );\n      }\n    }\n\n    const user = {\n      ...sanitizedBody,\n      provider: 'local',\n      [CREATED_BY_ATTRIBUTE]: admin.id,\n      [UPDATED_BY_ATTRIBUTE]: admin.id,\n    };\n\n    user.email = user.email.toLowerCase();\n\n    if (!user.role) {\n      const defaultRole = await strapi\n        .query('role', 'users-permissions')\n        .findOne({ type: advanced.default_role }, []);\n\n      user.role = defaultRole.id;\n    }\n\n    try {\n      const data = await strapi.plugins['users-permissions'].services.user.add(user);\n\n      ctx.created(pm.sanitize(data, { action: ACTIONS.read }));\n    } catch (error) {\n      ctx.badRequest(null, formatError(error));\n    }\n  },\n  /**\n   * Update a/an user record.\n   * @return {Object}\n   */\n\n  async update(ctx) {\n    const advancedConfigs = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'advanced',\n      })\n      .get();\n\n    const {\n      params: { id },\n      request: { body },\n      state: { userAbility, admin },\n    } = ctx;\n    const { email, username, password } = body;\n\n    const { pm, entity: user } = await findEntityAndCheckPermissions(\n      userAbility,\n      ACTIONS.edit,\n      userModel,\n      id\n    );\n\n    if (_.has(body, 'email') && !email) {\n      return ctx.badRequest('email.notNull');\n    }\n\n    if (_.has(body, 'username') && !username) {\n      return ctx.badRequest('username.notNull');\n    }\n\n    if (_.has(body, 'password') && !password && user.provider === 'local') {\n      return ctx.badRequest('password.notNull');\n    }\n\n    if (_.has(body, 'username')) {\n      const userWithSameUsername = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ username });\n\n      if (userWithSameUsername && userWithSameUsername.id != id) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.username.taken',\n            message: 'username.alreadyTaken.',\n            field: ['username'],\n          })\n        );\n      }\n    }\n\n    if (_.has(body, 'email') && advancedConfigs.unique_email) {\n      const userWithSameEmail = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ email: email.toLowerCase() });\n\n      if (userWithSameEmail && userWithSameEmail.id != id) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.email.taken',\n            message: 'Email already taken',\n            field: ['email'],\n          })\n        );\n      }\n      body.email = body.email.toLowerCase();\n    }\n\n    const sanitizedData = pm.pickPermittedFieldsOf(body, { subject: pm.toSubject(user) });\n    const updateData = _.omit({ ...sanitizedData, updated_by: admin.id }, 'created_by');\n\n    if (_.has(body, 'password') && password === user.password) {\n      delete updateData.password;\n    }\n\n    const data = await strapi.plugins['users-permissions'].services.user.edit({ id }, updateData);\n\n    ctx.body = pm.sanitize(data, { action: ACTIONS.read });\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/controllers/user/api.js": "'use strict';\n\nconst _ = require('lodash');\nconst { sanitizeEntity } = require('strapi-utils');\n\nconst sanitizeUser = user =>\n  sanitizeEntity(user, {\n    model: strapi.query('user', 'users-permissions').model,\n  });\n\nconst formatError = error => [\n  { messages: [{ id: error.id, message: error.message, field: error.field }] },\n];\n\nmodule.exports = {\n  /**\n   * Create a/an user record.\n   * @return {Object}\n   */\n  async create(ctx) {\n    const advanced = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'advanced',\n      })\n      .get();\n\n    const { email, username, password, role } = ctx.request.body;\n\n    if (!email) return ctx.badRequest('missing.email');\n    if (!username) return ctx.badRequest('missing.username');\n    if (!password) return ctx.badRequest('missing.password');\n\n    const userWithSameUsername = await strapi\n      .query('user', 'users-permissions')\n      .findOne({ username });\n\n    if (userWithSameUsername) {\n      return ctx.badRequest(\n        null,\n        formatError({\n          id: 'Auth.form.error.username.taken',\n          message: 'Username already taken.',\n          field: ['username'],\n        })\n      );\n    }\n\n    if (advanced.unique_email) {\n      const userWithSameEmail = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ email: email.toLowerCase() });\n\n      if (userWithSameEmail) {\n        return ctx.badRequest(\n          null,\n\n          formatError({\n            id: 'Auth.form.error.email.taken',\n            message: 'Email already taken.',\n            field: ['email'],\n          })\n        );\n      }\n    }\n\n    const user = {\n      ...ctx.request.body,\n      provider: 'local',\n    };\n\n    user.email = user.email.toLowerCase();\n\n    if (!role) {\n      const defaultRole = await strapi\n        .query('role', 'users-permissions')\n        .findOne({ type: advanced.default_role }, []);\n\n      user.role = defaultRole.id;\n    }\n\n    try {\n      const data = await strapi.plugins['users-permissions'].services.user.add(user);\n\n      ctx.created(sanitizeUser(data));\n    } catch (error) {\n      ctx.badRequest(null, formatError(error));\n    }\n  },\n  /**\n   * Update a/an user record.\n   * @return {Object}\n   */\n\n  async update(ctx) {\n    const advancedConfigs = await strapi\n      .store({\n        environment: '',\n        type: 'plugin',\n        name: 'users-permissions',\n        key: 'advanced',\n      })\n      .get();\n\n    const { id } = ctx.params;\n    const { email, username, password } = ctx.request.body;\n\n    const user = await strapi.plugins['users-permissions'].services.user.fetch({\n      id,\n    });\n\n    if (_.has(ctx.request.body, 'email') && !email) {\n      return ctx.badRequest('email.notNull');\n    }\n\n    if (_.has(ctx.request.body, 'username') && !username) {\n      return ctx.badRequest('username.notNull');\n    }\n\n    if (_.has(ctx.request.body, 'password') && !password && user.provider === 'local') {\n      return ctx.badRequest('password.notNull');\n    }\n\n    if (_.has(ctx.request.body, 'username')) {\n      const userWithSameUsername = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ username });\n\n      if (userWithSameUsername && userWithSameUsername.id != id) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.username.taken',\n            message: 'username.alreadyTaken.',\n            field: ['username'],\n          })\n        );\n      }\n    }\n\n    if (_.has(ctx.request.body, 'email') && advancedConfigs.unique_email) {\n      const userWithSameEmail = await strapi\n        .query('user', 'users-permissions')\n        .findOne({ email: email.toLowerCase() });\n\n      if (userWithSameEmail && userWithSameEmail.id != id) {\n        return ctx.badRequest(\n          null,\n          formatError({\n            id: 'Auth.form.error.email.taken',\n            message: 'Email already taken',\n            field: ['email'],\n          })\n        );\n      }\n      ctx.request.body.email = ctx.request.body.email.toLowerCase();\n    }\n\n    let updateData = {\n      ...ctx.request.body,\n    };\n\n    if (_.has(ctx.request.body, 'password') && password === user.password) {\n      delete updateData.password;\n    }\n\n    const data = await strapi.plugins['users-permissions'].services.user.edit({ id }, updateData);\n\n    ctx.send(sanitizeUser(data));\n  },\n};\n",
    "packages/strapi-plugin-users-permissions/tests/graphql.test.e2e.js": "'use strict';\n\n// Helpers.\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest, createRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet authReq;\nconst data = {};\n\ndescribe('Test Graphql user service', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    authReq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('Check createUser authorizations', () => {\n    test('createUser is forbidden to public', async () => {\n      const rq = createRequest({ strapi });\n      const res = await rq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation {\n              createUser(input: { data: { username: \"test\", email: \"test\", password: \"test\" } }) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          createUser: null,\n        },\n        errors: [\n          {\n            message: 'Forbidden',\n          },\n        ],\n      });\n    });\n\n    test('createUser is authorized for admins', async () => {\n      const res = await authReq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation {\n              createUser(\n                input: {\n                  data: { username: \"test\", email: \"test-graphql@strapi.io\", password: \"test\" }\n                }\n              ) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          createUser: {\n            user: {\n              id: expect.anything(),\n              username: 'test',\n            },\n          },\n        },\n      });\n\n      data.user = res.body.data.createUser.user;\n    });\n  });\n\n  describe('Check updateUser authorizations', () => {\n    test('updateUser is forbidden to public', async () => {\n      const rq = createRequest({ strapi });\n      const res = await rq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation {\n              updateUser(\n                input: {\n                  where: { id: 1 }\n                  data: { username: \"test\", email: \"test\", password: \"test\" }\n                }\n              ) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          updateUser: null,\n        },\n        errors: [\n          {\n            message: 'Forbidden',\n          },\n        ],\n      });\n    });\n\n    test('updateUser is authorized for admins', async () => {\n      const res = await authReq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation updateUser($id: ID!) {\n              updateUser(input: { where: { id: $id }, data: { username: \"newUsername\" } }) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n          variables: {\n            id: data.user.id,\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          updateUser: {\n            user: {\n              id: expect.anything(),\n              username: 'newUsername',\n            },\n          },\n        },\n      });\n\n      data.user = res.body.data.updateUser.user;\n    });\n  });\n\n  describe('Check deleteUser authorizations', () => {\n    test('deleteUser is forbidden to public', async () => {\n      const rq = createRequest({ strapi });\n      const res = await rq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation deleteUser($id: ID!) {\n              deleteUser(input: { where: { id: $id } }) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n          variables: {\n            id: data.user.id,\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          deleteUser: null,\n        },\n        errors: [\n          {\n            message: 'Forbidden',\n          },\n        ],\n      });\n    });\n\n    test('deleteUser is authorized for admins', async () => {\n      const res = await authReq({\n        url: '/graphql',\n        method: 'POST',\n        body: {\n          query: /* GraphQL */ `\n            mutation deleteUser($id: ID!) {\n              deleteUser(input: { where: { id: $id } }) {\n                user {\n                  id\n                  username\n                }\n              }\n            }\n          `,\n          variables: {\n            id: data.user.id,\n          },\n        },\n      });\n\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          deleteUser: {\n            user: data.user,\n          },\n        },\n      });\n    });\n  });\n});\n",
    "packages/strapi-plugin-users-permissions/tests/roles-api.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\nlet data = {};\nlet internals = {\n  user: {\n    username: 'User 1',\n    email: 'user1@strapi.io',\n    password: 'test1234',\n  },\n  role: {\n    name: 'Test Role',\n    description: 'Some random test role',\n  },\n};\n\n/**\n * Utils for this test files\n */\nconst createTestUser = () =>\n  rq({\n    method: 'POST',\n    url: '/auth/local/register',\n    body: internals.user,\n  });\n\nconst deleteTestUser = () =>\n  rq({\n    method: 'DELETE',\n    url: `/users/${data.user.id}`,\n  });\n\n/*****************************\n * TESTS\n *****************************/\ndescribe('Roles API', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    const res = await createTestUser();\n    data.user = res.body.user;\n  }, 60000);\n\n  afterAll(async () => {\n    await deleteTestUser();\n    await strapi.destroy();\n  });\n\n  test('Create Role', async () => {\n    const res = await rq({\n      method: 'POST',\n      url: '/users-permissions/roles',\n      body: {\n        ...internals.role,\n        permissions: [],\n        users: [data.user],\n      },\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({ ok: true });\n  });\n\n  test('List Roles', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/users-permissions/roles',\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body.roles).toEqual(\n      expect.arrayContaining([expect.objectContaining(internals.role)])\n    );\n\n    data.role = res.body.roles.find(r => r.name === internals.role.name);\n  });\n\n  test('Delete Role', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/users-permissions/roles/${data.role.id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n  });\n});\n",
    "packages/strapi-plugin-users-permissions/tests/users-api.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\nlet data = {};\n\ndescribe('Users API', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  test('Create User', async () => {\n    const user = {\n      username: 'User 1',\n      email: 'user1@strapi.io',\n      password: 'test1234',\n    };\n\n    const res = await rq({\n      method: 'POST',\n      url: '/auth/local/register',\n      body: user,\n    });\n\n    expect(res.statusCode).toBe(200);\n    expect(res.body).toMatchObject({\n      jwt: expect.any(String),\n      user: {\n        username: user.username,\n        email: user.email,\n      },\n    });\n    data.user = res.body.user;\n  });\n\n  test('Delete user', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/users/${data.user.id}`,\n    });\n\n    expect(res.statusCode).toBe(200);\n  });\n});\n",
    "packages/strapi-plugin-users-permissions/tests/users-graphql.test.e2e.js": "'use strict';\n\n// Test a simple default API with no relations\n\nconst { createStrapiInstance } = require('../../../test/helpers/strapi');\nconst { createAuthRequest } = require('../../../test/helpers/request');\n\nlet strapi;\nlet rq;\nlet graphqlQuery;\nlet data = {};\n\ndescribe('Test Graphql Users API End to End', () => {\n  beforeAll(async () => {\n    strapi = await createStrapiInstance();\n    rq = await createAuthRequest({ strapi });\n\n    graphqlQuery = body => {\n      return rq({\n        url: '/graphql',\n        method: 'POST',\n        body,\n      });\n    };\n  }, 60000);\n\n  afterAll(async () => {\n    await strapi.destroy();\n  });\n\n  describe('Test register and login', () => {\n    const user = {\n      username: 'User 1',\n      email: 'user1@strapi.io',\n      password: 'test1234',\n    };\n\n    test('Register a user', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation register($input: UsersPermissionsRegisterInput!) {\n            register(input: $input) {\n              jwt\n              user {\n                id\n                email\n              }\n            }\n          }\n        `,\n        variables: {\n          input: user,\n        },\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          register: {\n            jwt: expect.any(String),\n            user: {\n              id: expect.any(String),\n              email: user.email,\n            },\n          },\n        },\n      });\n      data.user = res.body.data.register.user;\n    });\n\n    test('Log in a user', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation login($input: UsersPermissionsLoginInput!) {\n            login(input: $input) {\n              jwt\n              user {\n                id\n                email\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            identifier: user.username,\n            password: user.password,\n          },\n        },\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          login: {\n            jwt: expect.any(String),\n            user: {\n              id: expect.any(String),\n              email: user.email,\n            },\n          },\n        },\n      });\n      data.user = res.body.data.login.user;\n    });\n\n    test('Delete a user', async () => {\n      const res = await graphqlQuery({\n        query: /* GraphQL */ `\n          mutation deleteUser($input: deleteUserInput) {\n            deleteUser(input: $input) {\n              user {\n                email\n              }\n            }\n          }\n        `,\n        variables: {\n          input: {\n            where: {\n              id: data.user.id,\n            },\n          },\n        },\n      });\n\n      const { body } = res;\n\n      expect(res.statusCode).toBe(200);\n      expect(body).toMatchObject({\n        data: {\n          deleteUser: {\n            user: {\n              email: data.user.email,\n            },\n          },\n        },\n      });\n    });\n  });\n});\n",
    "packages/strapi-utils/lib/policy.js": "/**\n * Policies util\n */\n'use strict';\n\nconst _ = require('lodash');\n\nconst GLOBAL_PREFIX = 'global::';\nconst PLUGIN_PREFIX = 'plugins::';\nconst ADMIN_PREFIX = 'admin::';\nconst APPLICATION_PREFIX = 'application::';\n\nconst isPolicyFactory = _.isArray;\n\nconst getPolicyIn = (container, policy) =>\n  _.get(container, ['config', 'policies', _.toLower(policy)]);\n\nconst policyExistsIn = (container, policy) => !_.isUndefined(getPolicyIn(container, policy));\n\nconst stripPolicy = (policy, prefix) => policy.replace(prefix, '');\n\nconst createPolicy = (policyName, ...args) => ({ policyName, args });\n\nconst resolveHandler = policy => (_.isFunction(policy) ? policy : policy.handler);\n\nconst parsePolicy = policy =>\n  isPolicyFactory(policy) ? createPolicy(...policy) : createPolicy(policy);\n\nconst resolvePolicy = policyName => {\n  const resolver = policyResolvers.find(resolver => resolver.exists(policyName));\n\n  return resolver ? resolveHandler(resolver.get)(policyName) : undefined;\n};\n\nconst searchLocalPolicy = (policy, plugin, apiName) => {\n  let [absoluteApiName, policyName] = policy.split('.');\n  let absoluteApi = _.get(strapi.api, absoluteApiName);\n  const resolver = policyResolvers.find(({ name }) => name === 'plugin');\n\n  if (policyExistsIn(absoluteApi, policyName)) {\n    return resolveHandler(getPolicyIn(absoluteApi, policyName));\n  }\n\n  const pluginPolicy = `${PLUGIN_PREFIX}${plugin}.${policy}`;\n\n  if (plugin && resolver.exists(pluginPolicy)) {\n    return resolveHandler(resolver.get(pluginPolicy));\n  }\n\n  const api = _.get(strapi.api, apiName);\n  if (api && policyExistsIn(api, policy)) {\n    return resolveHandler(getPolicyIn(api, policy));\n  }\n\n  return undefined;\n};\n\nconst globalPolicy = ({ method, endpoint, controller, action, plugin }) => {\n  return async (ctx, next) => {\n    ctx.request.route = {\n      endpoint: `${method} ${endpoint}`,\n      controller: _.toLower(controller),\n      action: _.toLower(action),\n      verb: _.toLower(method),\n      plugin,\n    };\n\n    await next();\n  };\n};\n\nconst policyResolvers = [\n  {\n    name: 'api',\n    is(policy) {\n      return _.startsWith(policy, APPLICATION_PREFIX);\n    },\n    exists(policy) {\n      return this.is(policy) && !_.isUndefined(this.get(policy));\n    },\n    get: policy => {\n      const [, policyWithoutPrefix] = policy.split('::');\n      const [api = '', policyName = ''] = policyWithoutPrefix.split('.');\n      return getPolicyIn(_.get(strapi, ['api', api]), policyName);\n    },\n  },\n  {\n    name: 'admin',\n    is(policy) {\n      return _.startsWith(policy, ADMIN_PREFIX);\n    },\n    exists(policy) {\n      return this.is(policy) && !_.isUndefined(this.get(policy));\n    },\n    get: policy => {\n      return getPolicyIn(_.get(strapi, 'admin'), stripPolicy(policy, ADMIN_PREFIX));\n    },\n  },\n  {\n    name: 'plugin',\n    is(policy) {\n      return _.startsWith(policy, PLUGIN_PREFIX);\n    },\n    exists(policy) {\n      return this.is(policy) && !_.isUndefined(this.get(policy));\n    },\n    get(policy) {\n      const [plugin = '', policyName = ''] = stripPolicy(policy, PLUGIN_PREFIX).split('.');\n      return getPolicyIn(_.get(strapi, ['plugins', plugin]), policyName);\n    },\n  },\n  {\n    name: 'global',\n    is(policy) {\n      return _.startsWith(policy, GLOBAL_PREFIX);\n    },\n    exists(policy) {\n      return this.is(policy) && !_.isUndefined(this.get(policy));\n    },\n    get(policy) {\n      return getPolicyIn(strapi, stripPolicy(policy, GLOBAL_PREFIX));\n    },\n  },\n];\n\nconst get = (policy, plugin, apiName) => {\n  const { policyName, args } = parsePolicy(policy);\n\n  const resolvedPolicy = resolvePolicy(policyName);\n\n  if (resolvedPolicy !== undefined) {\n    return isPolicyFactory(policy) ? resolvedPolicy(...args) : resolvedPolicy;\n  }\n\n  const localPolicy = searchLocalPolicy(policy, plugin, apiName);\n\n  if (localPolicy !== undefined) {\n    return localPolicy;\n  }\n\n  throw new Error(`Could not find policy \"${policy}\"`);\n};\n\nconst createPolicyFactory = (factoryCallback, options) => {\n  const { validator, name = 'unnamed' } = options;\n\n  const validate = (...args) => {\n    try {\n      validator(...args);\n    } catch (e) {\n      throw new Error(`Invalid objects submitted to \"${name}\" policy.`);\n    }\n  };\n\n  return (...args) => {\n    if (validator) {\n      validate(...args);\n    }\n\n    return factoryCallback(...args);\n  };\n};\n\nmodule.exports = {\n  get,\n  globalPolicy,\n  createPolicyFactory,\n};\n",
    "scripts/front/reorder-admin-translation-files.js": "'use strict';\n\nconst { join } = require('path');\nconst { promisify } = require('util');\nconst fs = require('fs-extra');\nconst glob = promisify(require('glob').glob);\n\nasync function orderTrads({ mainTranslationFile, translationFiles }) {\n  const data = await fs.readJSON(mainTranslationFile);\n\n  const orderedData = Object.keys(data)\n    .sort()\n    .reduce((acc, current) => {\n      acc[current] = data[current];\n\n      return acc;\n    }, {});\n\n  await fs.writeJSON(mainTranslationFile, orderedData, { spaces: 2 });\n\n  const cleanFile = async trad => {\n    const cleanedFile = {};\n    const orderedDataKeys = Object.keys(orderedData);\n\n    for (let i in orderedDataKeys) {\n      try {\n        const currentTrad = await fs.readJson(trad);\n        const currentKey = orderedDataKeys[i];\n\n        if (currentTrad[currentKey]) {\n          cleanedFile[currentKey] = currentTrad[currentKey];\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n    try {\n      await fs.writeJSON(trad, cleanedFile, { spaces: 2 });\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  await Promise.all(translationFiles.map(trad => cleanFile(trad)));\n}\n\nasync function run() {\n  const packageDirs = await glob('packages/*');\n  const pathToTranslationsFolder = ['admin', 'src', 'translations'];\n\n  const pluginsWithTranslationFiles = packageDirs\n    .filter(\n      dir =>\n        (dir.startsWith('packages/strapi-plugin') || dir.startsWith('packages/strapi-admin')) &&\n        fs.existsSync(join(dir, ...pathToTranslationsFolder, 'index.js'))\n    )\n    .map(dir => {\n      const translationFiles = fs\n        .readdirSync(join(dir, ...pathToTranslationsFolder))\n        .filter(\n          file => !file.includes('.js') && !file.includes('en.json') && !file.includes('test')\n        )\n        .map(file => join(dir, ...pathToTranslationsFolder, file));\n\n      return {\n        translationFiles,\n        mainTranslationFile: join(dir, 'admin', 'src', 'translations', 'en.json'),\n      };\n    });\n\n  await Promise.all(pluginsWithTranslationFiles.map(t => orderTrads(t)));\n}\n\nrun().catch(err => console.error(err));\n",
    "scripts/link.js": "'use strict';\n\nconst { join } = require('path');\nconst { promisify } = require('util');\nconst execa = require('execa');\nconst fs = require('fs-extra');\nconst glob = promisify(require('glob').glob);\n\nasync function run() {\n  const packageDirs = await glob('packages/*');\n\n  console.log('Linking all packages');\n\n  const packages = packageDirs.map(dir => ({\n    dir,\n    pkgJSON: fs.readJSONSync(join(dir, 'package.json')),\n  }));\n\n  await Promise.all(packages.map(({ dir }) => execa('yarn', ['link'], { cwd: dir })));\n\n  const packageNames = packages.map(p => p.pkgJSON.name).join(' ');\n  console.log(`Package names: \\n ${packageNames}\\n`);\n}\n\nrun().catch(err => console.error(err));\n",
    "scripts/open-api/serve.js": "'use strict';\n\nconst http = require('http');\nconst path = require('path');\nconst fse = require('fs-extra');\nconst getPort = require('get-port');\n\nconst config = {\n  port: parseInt(process.env.PORT, 10) || 1339,\n};\n\nconst args = process.argv.slice(2);\n\nif (!args[0]) {\n  console.error('Missing required parameter <package-name>');\n  process.exit(1);\n}\n\nasync function run() {\n  const openAPISpecPath = path.join(__dirname, '../../packages', args[0], 'oas.yml');\n  const indexPagePath = path.join(__dirname, 'public', 'index.html');\n\n  if (!(await fse.pathExists(openAPISpecPath))) {\n    throw new Error(`No OAS configuration found at ${openAPISpecPath}`);\n  }\n\n  const server = http.createServer((req, res) => {\n    if (req.url == '/spec.yml') {\n      return fse.createReadStream(openAPISpecPath).pipe(res);\n    }\n\n    return fse.createReadStream(indexPagePath).pipe(res);\n  });\n\n  const port = await getPort({ port: config.port });\n\n  server.listen(port, () => {\n    console.log(`Server available at http://localhost:${port}`);\n  });\n}\n\nrun().catch(error => {\n  console.log('Unexpected Error:', error);\n  process.exit(1);\n});\n",
    "scripts/unlink.js": "'use strict';\n\nconst { join } = require('path');\nconst { promisify } = require('util');\nconst execa = require('execa');\nconst fs = require('fs-extra');\nconst glob = promisify(require('glob').glob);\n\nasync function run() {\n  const packageDirs = await glob('packages/*');\n\n  console.log('Unlinking all packages');\n\n  const packages = packageDirs.map(dir => ({\n    dir,\n    pkgJSON: fs.readJSONSync(join(dir, 'package.json')),\n  }));\n\n  await Promise.all(packages.map(({ dir }) => execa('yarn', ['unlink'], { cwd: dir })));\n\n  const packageNames = packages.map(p => p.pkgJSON.name).join(' ');\n  console.log(`Package names: \\n ${packageNames}\\n`);\n}\n\nrun().catch(err => console.error(err));\n",
    "test/e2e.js": "'use strict';\n\nconst execa = require('execa');\nconst yargs = require('yargs');\nconst { cleanTestApp, generateTestApp } = require('./helpers/test-app-generator');\n\nconst appName = 'testApp';\n\nconst databases = {\n  mongo: {\n    client: 'mongo',\n    host: '127.0.0.1',\n    port: 27017,\n    database: 'strapi_test',\n    username: 'root',\n    password: 'strapi',\n  },\n  postgres: {\n    client: 'postgres',\n    host: '127.0.0.1',\n    port: 5432,\n    database: 'strapi_test',\n    username: 'strapi',\n    password: 'strapi',\n  },\n  mysql: {\n    client: 'mysql',\n    host: '127.0.0.1',\n    port: 3306,\n    database: 'strapi_test',\n    username: 'strapi',\n    password: 'strapi',\n  },\n  sqlite: {\n    client: 'sqlite',\n    filename: './tmp/data.db',\n  },\n};\n\nconst runAllTests = async args => {\n  return execa('yarn', ['-s', 'test:e2e', 'test/all.test.e2e.js'], {\n    stdio: 'inherit',\n    env: {\n      STRAPI_TEST_PATHS: args,\n      FORCE_COLOR: 1,\n    },\n  });\n};\n\nconst main = async (database, args) => {\n  try {\n    await cleanTestApp(appName);\n    await generateTestApp({ appName, database });\n\n    await runAllTests(args).catch(() => {\n      process.stdout.write('Tests failed\\n', () => {\n        process.exit(1);\n      });\n    });\n\n    process.exit(0);\n  } catch (error) {\n    process.stdout.write('Tests failed\\n', () => {\n      process.exit(1);\n    });\n  }\n};\n\nyargs\n  .command(\n    '$0',\n    'run end to end tests',\n    yargs => {\n      yargs.option('database', {\n        alias: 'db',\n        describe: 'choose a database',\n        choices: Object.keys(databases),\n        default: 'sqlite',\n      });\n    },\n    argv => {\n      const { database, _: args } = argv;\n\n      main(databases[database], args.join(' '));\n    }\n  )\n  .help().argv;\n",
    "test/helpers/agent.js": "'use strict';\n\nconst { clone, has, concat, isNil } = require('lodash/fp');\nconst qs = require('qs');\nconst request = require('supertest');\nconst { createUtils } = require('./utils');\n\nconst createAgent = (strapi, initialState = {}) => {\n  const state = clone(initialState);\n  const utils = createUtils(strapi);\n\n  const agent = options => {\n    const { method, url, body, formData, qs: queryString } = options;\n    const supertestAgent = request.agent(strapi.server);\n\n    if (has('token', state)) {\n      supertestAgent.auth(state.token, { type: 'bearer' });\n    }\n\n    const fullUrl = concat(state.urlPrefix, url).join('');\n\n    const rq = supertestAgent[method.toLowerCase()](fullUrl);\n\n    if (queryString) {\n      rq.query(qs.stringify(queryString));\n    }\n\n    if (body) {\n      rq.send(body);\n    }\n\n    if (formData) {\n      const attachFieldToRequest = field => rq.field(field, formData[field]);\n      Object.keys(formData).forEach(attachFieldToRequest);\n    }\n\n    if (isNil(formData)) {\n      rq.type('application/json');\n    }\n\n    return rq;\n  };\n\n  const createShorthandMethod = method => (url, options = {}) => {\n    return agent({ ...options, url, method });\n  };\n\n  Object.assign(agent, {\n    assignState(newState) {\n      Object.assign(state, newState);\n      return agent;\n    },\n\n    setURLPrefix(path) {\n      return this.assignState({ urlPrefix: path });\n    },\n\n    setToken(token) {\n      return this.assignState({ token });\n    },\n\n    setLoggedUser(loggedUser) {\n      return this.assignState({ loggedUser });\n    },\n\n    getLoggedUser() {\n      return state.loggedUser;\n    },\n\n    async login(userInfo) {\n      const { token, user } = await utils.login(userInfo);\n\n      this.setToken(token).setLoggedUser(user);\n\n      return agent;\n    },\n\n    async registerOrLogin(userCredentials) {\n      const { token, user } = await utils.registerOrLogin(userCredentials);\n\n      this.setToken(token).setLoggedUser(user);\n\n      return agent;\n    },\n\n    get: createShorthandMethod('GET'),\n    post: createShorthandMethod('POST'),\n    put: createShorthandMethod('PUT'),\n    delete: createShorthandMethod('DELETE'),\n  });\n\n  return agent;\n};\n\nmodule.exports = {\n  createAgent,\n};\n",
    "test/helpers/auth.js": "'use strict';\n\nconst { createRequest } = require('./request');\n\nconst auth = {\n  email: 'admin@strapi.io',\n  firstname: 'admin',\n  lastname: 'admin',\n  password: 'Password123',\n};\n\nconst rq = createRequest();\n\nconst register = async () => {\n  await rq({\n    url: '/admin/register-admin',\n    method: 'POST',\n    body: auth,\n  }).catch(err => {\n    console.error(err);\n    if (err.message === 'You cannot register a new super admin') return;\n    throw err;\n  });\n};\n\nconst login = async () => {\n  const { body } = await rq({\n    url: '/admin/login',\n    method: 'POST',\n    body: {\n      email: auth.email,\n      password: auth.password,\n    },\n  });\n\n  return body.data;\n};\n\nmodule.exports = {\n  async registerAndLogin() {\n    // register\n    await register();\n\n    // login\n    const res = await login();\n\n    return res && res.token;\n  },\n  async login() {\n    const res = await login();\n\n    return res && res.token;\n  },\n  async getUser() {\n    const res = await login();\n\n    return res.user;\n  },\n};\n",
    "test/helpers/builder/index.js": "'use strict';\n\nconst { get } = require('lodash/fp');\n\nconst _ = require('lodash');\nconst modelsUtils = require('../models');\nconst { sanitizeEntity } = require('../../../packages/strapi-utils');\nconst actionRegistry = require('./action-registry');\nconst { createContext } = require('./context');\n\nconst createTestBuilder = (options = {}) => {\n  const { initialState } = options;\n  const ctx = createContext(initialState);\n\n  return {\n    get models() {\n      return ctx.state.models;\n    },\n\n    get fixtures() {\n      return ctx.state.fixtures;\n    },\n\n    sanitizedFixtures(strapi) {\n      return _.mapValues(this.fixtures, (value, key) => this.sanitizedFixturesFor(key, strapi));\n    },\n\n    sanitizedFixturesFor(modelName, strapi) {\n      const model = strapi.getModel(modelName);\n      const fixtures = this.fixturesFor(modelName);\n\n      return sanitizeEntity(fixtures, { model });\n    },\n\n    fixturesFor(modelName) {\n      return this.fixtures[modelName];\n    },\n\n    addAction(code, ...params) {\n      const actionCreator = get(code, actionRegistry);\n\n      ctx.addAction(actionCreator(...params));\n\n      return this;\n    },\n\n    addContentType(contentType) {\n      return this.addAction('contentType.create', contentType);\n    },\n\n    addContentTypes(contentTypes, { batch = true } = {}) {\n      return this.addAction(\n        batch ? 'contentType.createBatch' : 'contentType.createMany',\n        contentTypes\n      );\n    },\n\n    addComponent(component) {\n      return this.addAction('component.create', component);\n    },\n\n    addFixtures(model, entries) {\n      return this.addAction('fixtures.create', model, entries, () => this.fixtures);\n    },\n\n    async build() {\n      for (const action of ctx.state.actions) {\n        await action.build(ctx);\n      }\n\n      return this;\n    },\n\n    async cleanup(options = {}) {\n      const { enableTestDataAutoCleanup = true } = options;\n      const { models, actions } = ctx.state;\n\n      if (enableTestDataAutoCleanup) {\n        for (const model of models.reverse()) {\n          await modelsUtils.cleanupModel(model.uid || model.modelName);\n        }\n      }\n\n      for (const action of actions.reverse()) {\n        await action.cleanup(ctx);\n      }\n\n      ctx.resetState();\n\n      return this;\n    },\n  };\n};\n\nmodule.exports = { createTestBuilder };\n",
    "test/helpers/models.js": "'use strict';\n\nconst { isFunction, isNil, prop } = require('lodash/fp');\nconst { createStrapiInstance } = require('./strapi');\n\nconst createHelpers = async ({ strapi: strapiInstance = null, ...options } = {}) => {\n  const strapi = strapiInstance || (await createStrapiInstance(options));\n  const contentTypeService = strapi.plugins['content-type-builder'].services.contenttypes;\n  const componentsService = strapi.plugins['content-type-builder'].services.components;\n\n  const cleanup = async () => {\n    if (isNil(strapiInstance)) {\n      await strapi.destroy();\n    }\n  };\n\n  return {\n    strapi,\n    contentTypeService,\n    componentsService,\n    cleanup,\n  };\n};\n\nconst createContentType = async (model, { strapi } = {}) => {\n  const { contentTypeService, cleanup } = await createHelpers({ strapi });\n\n  const contentType = await contentTypeService.createContentType({\n    contentType: {\n      connection: 'default',\n      ...model,\n    },\n  });\n\n  await cleanup();\n\n  return contentType;\n};\n\nconst createContentTypes = async (models, { strapi } = {}) => {\n  const { contentTypeService, cleanup } = await createHelpers({ strapi });\n\n  const contentTypes = await contentTypeService.createContentTypes(\n    models.map(model => ({\n      contentType: {\n        connection: 'default',\n        ...model,\n      },\n    }))\n  );\n\n  await cleanup();\n\n  return contentTypes;\n};\n\nconst createComponent = async (component, { strapi } = {}) => {\n  const { componentsService, cleanup } = await createHelpers({ strapi });\n\n  const createdComponent = await componentsService.createComponent({\n    component: {\n      category: 'default',\n      icon: 'default',\n      connection: 'default',\n      ...component,\n    },\n  });\n\n  await cleanup();\n\n  return createdComponent;\n};\n\nconst createComponents = async (components, { strapi } = {}) => {\n  const createdComponents = [];\n\n  for (const component of components) {\n    createdComponents.push(await createComponent(component, { strapi }));\n  }\n\n  return createdComponents;\n};\n\nconst deleteComponent = async (componentUID, { strapi } = {}) => {\n  const { componentsService, cleanup } = await createHelpers({ strapi });\n\n  const component = await componentsService.deleteComponent(componentUID);\n\n  await cleanup();\n\n  return component;\n};\n\nconst deleteComponents = async (componentsUID, { strapi } = {}) => {\n  const deletedComponents = [];\n\n  for (const componentUID of componentsUID) {\n    deletedComponents.push(await deleteComponent(componentUID, { strapi }));\n  }\n\n  return deletedComponents;\n};\n\nconst deleteContentType = async (modelName, { strapi } = {}) => {\n  const { contentTypeService, cleanup } = await createHelpers({ strapi });\n  const uid = `application::${modelName}.${modelName}`;\n\n  const contentType = await contentTypeService.deleteContentType(uid);\n\n  await cleanup();\n\n  return contentType;\n};\n\nconst deleteContentTypes = async (modelsName, { strapi } = {}) => {\n  const { contentTypeService, cleanup } = await createHelpers({ strapi });\n  const toUID = name => `application::${name}.${name}`;\n\n  const contentTypes = await contentTypeService.deleteContentTypes(modelsName.map(toUID));\n\n  await cleanup();\n\n  return contentTypes;\n};\n\nasync function cleanupModels(models, { strapi } = {}) {\n  for (const model of models) {\n    await cleanupModel(model, { strapi });\n  }\n}\n\nasync function cleanupModel(model, { strapi: strapiIst } = {}) {\n  const { strapi, cleanup } = await createHelpers({ strapi: strapiIst });\n\n  await strapi.query(model).delete();\n\n  await cleanup();\n}\n\nasync function createFixtures(dataMap, { strapi: strapiIst } = {}) {\n  const { strapi, cleanup } = await createHelpers({ strapi: strapiIst });\n  const models = Object.keys(dataMap);\n  const resultMap = {};\n\n  for (const model of models) {\n    const entries = [];\n\n    for (const data of dataMap[model]) {\n      entries.push(await strapi.query(model).create(data));\n    }\n\n    resultMap[model] = entries;\n  }\n\n  await cleanup();\n\n  return resultMap;\n}\n\nasync function createFixturesFor(model, entries, { strapi: strapiIst } = {}) {\n  const { strapi, cleanup } = await createHelpers({ strapi: strapiIst });\n  const results = [];\n\n  for (const entry of entries) {\n    const dataToCreate = isFunction(entry) ? entry(results) : entry;\n    results.push(await strapi.query(model).create(dataToCreate));\n  }\n\n  await cleanup();\n\n  return results;\n}\n\nasync function deleteFixturesFor(model, entries, { strapi: strapiIst } = {}) {\n  const { strapi, cleanup } = await createHelpers({ strapi: strapiIst });\n\n  await strapi.query(model).delete({ id_in: entries.map(prop('id')) });\n\n  await cleanup();\n}\n\nasync function modifyContentType(data, { strapi } = {}) {\n  const { contentTypeService, cleanup } = await createHelpers({ strapi });\n\n  const sanitizedData = { ...data };\n  delete sanitizedData.editable;\n  delete sanitizedData.restrictRelationsTo;\n\n  const uid = `application::${sanitizedData.name}.${sanitizedData.name}`;\n\n  const ct = await contentTypeService.editContentType(uid, {\n    contentType: {\n      connection: 'default',\n      ...sanitizedData,\n    },\n  });\n\n  await cleanup();\n\n  return ct;\n}\n\nasync function getContentTypeSchema(modelName, { strapi: strapiIst } = {}) {\n  const { strapi, contentTypeService, cleanup } = await createHelpers({ strapi: strapiIst });\n\n  const uid = `application::${modelName}.${modelName}`;\n  const ct = contentTypeService.formatContentType(strapi.contentTypes[uid]);\n\n  await cleanup();\n\n  return (ct || {}).schema;\n}\n\nmodule.exports = {\n  // Create Content-Types\n  createContentType,\n  createContentTypes,\n  // Delete Content-Types\n  deleteContentType,\n  deleteContentTypes,\n  // Cleanup Models\n  cleanupModel,\n  cleanupModels,\n  // Create Components\n  createComponent,\n  createComponents,\n  // Delete Components\n  deleteComponent,\n  deleteComponents,\n  // Fixtures\n  createFixtures,\n  createFixturesFor,\n  deleteFixturesFor,\n  // Update Content-Types\n  modifyContentType,\n  // Misc\n  getContentTypeSchema,\n};\n",
    "test/helpers/strapi.js": "'use strict';\n\nconst path = require('path');\nconst _ = require('lodash');\nconst strapi = require('../../packages/strapi/lib');\nconst { createUtils } = require('./utils');\n\nconst superAdminCredentials = {\n  email: 'admin@strapi.io',\n  firstname: 'admin',\n  lastname: 'admin',\n  password: 'Password123',\n};\n\nconst superAdminLoginInfo = _.pick(superAdminCredentials, ['email', 'password']);\n\nconst TEST_APP_URL = path.resolve(__dirname, '../../testApp');\n\nconst createStrapiInstance = async ({ ensureSuperAdmin = true, logLevel = 'fatal' } = {}) => {\n  const options = { dir: TEST_APP_URL };\n  const instance = strapi(options);\n\n  await instance.load();\n\n  instance.log.level = logLevel;\n\n  await instance.app\n    // Populate Koa routes\n    .use(instance.router.routes())\n    // Populate Koa methods\n    .use(instance.router.allowedMethods());\n\n  const utils = createUtils(instance);\n\n  if (ensureSuperAdmin) {\n    await utils.createUserIfNotExists(superAdminCredentials);\n  }\n\n  return instance;\n};\n\nmodule.exports = {\n  createStrapiInstance,\n  superAdmin: {\n    loginInfo: superAdminLoginInfo,\n    credentials: superAdminCredentials,\n  },\n};\n",
    "test/helpers/utils.js": "'use strict';\n\nconst _ = require('lodash');\n\nconst createUtils = strapi => {\n  const login = async userInfo => {\n    const sanitizedUserInfo = _.pick(userInfo, ['email', 'id']);\n    const user = await strapi.admin.services.user.findOne(sanitizedUserInfo);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    const token = strapi.admin.services.token.createJwtToken(user);\n\n    return { token, user };\n  };\n  const registerOrLogin = async userCredentials => {\n    await createUserIfNotExists(userCredentials);\n    return login(userCredentials);\n  };\n\n  const findUser = strapi.admin.services.user.findOne;\n  const userExists = strapi.admin.services.user.exists;\n  const createUser = async userInfo => {\n    const superAdminRole = await strapi.admin.services.role.getSuperAdminWithUsersCount();\n\n    if (superAdminRole.usersCount === 0) {\n      const userRoles = _.uniq((userInfo.roles || []).concat(superAdminRole.id));\n      Object.assign(userInfo, { roles: userRoles });\n    }\n\n    return strapi.admin.services.user.create({\n      registrationToken: null,\n      isActive: true,\n      ...userInfo,\n    });\n  };\n  const deleteUserById = strapi.admin.services.user.deleteById;\n  const deleteUsersById = strapi.admin.services.user.deleteByIds;\n  const createUserIfNotExists = async userInfo => {\n    const sanitizedUserInfo = _.pick(userInfo, ['email', 'id']);\n    const exists = await userExists(sanitizedUserInfo);\n\n    return !exists ? createUser(userInfo) : null;\n  };\n\n  const createRole = strapi.admin.services.role.create;\n  const getRole = strapi.admin.services.role.find;\n  const deleteRolesById = strapi.admin.services.role.deleteByIds;\n  const getSuperAdminRole = strapi.admin.services.role.getSuperAdmin;\n  const assignPermissionsToRole = strapi.admin.services.role.assignPermissions;\n\n  return {\n    // Auth\n    login,\n    registerOrLogin,\n    // Users\n    findUser,\n    createUser,\n    createUserIfNotExists,\n    userExists,\n    deleteUserById,\n    deleteUsersById,\n    // Roles\n    getRole,\n    getSuperAdminRole,\n    createRole,\n    deleteRolesById,\n    assignPermissionsToRole,\n  };\n};\n\nmodule.exports = { createUtils };\n"
  }
}