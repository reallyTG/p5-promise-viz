{
  "promises": {
    "0": {
      "source": "scripts/binary/move-binaries.ts:4:12:4:12",
      "startTime": "933376996476761",
      "endTime": "933377004695508",
      "elapsedTime": "8218747",
      "asyncId": 124,
      "triggerAsyncId": 123,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " __awaiter",
      "userCode": false,
      "line": "\nconst debug = require('debug')('cypress:binary')\nimport la from 'lazy-ass'\nimport is from 'check-more-types'\n// using \"arg\" module for parsing CLI arguments\n// because it plays really nicely with TypeScript\nimport arg from 'arg",
      "startLine": 4,
      "startCol": 12,
      "endLine": 4,
      "endCol": 12,
      "file": "scripts/binary/move-binaries.ts",
      "triggers": [
        128
      ],
      "uniqueid": 0
    },
    "1": {
      "source": "scripts/binary/move-binaries.ts:3:65:3:65",
      "startTime": "933376998808883",
      "endTime": "933377000414493",
      "elapsedTime": "1605610",
      "asyncId": 126,
      "triggerAsyncId": 123,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " adopt",
      "userCode": false,
      "line": "import { s3helpers } from './s3-api'\nconst debug = require('debug')('cypress:binary')\nimport la from 'lazy-ass'\nimport is from 'check-more-types'\n// using \"arg\" module for parsing CLI arguments\n// because it plays really nicely with TypeScript\nimport arg from 'arg'\nimport { prop, sortBy, last, equals } from 'ramda",
      "startLine": 3,
      "startCol": 65,
      "endLine": 3,
      "endCol": 65,
      "file": "scripts/binary/move-binaries.ts",
      "triggers": [
        127
      ],
      "uniqueid": 1
    },
    "2": {
      "source": "scripts/binary/move-binaries.ts:7:91:7:91",
      "startTime": "933376999234821",
      "endTime": "933377001334587",
      "elapsedTime": "2099766",
      "asyncId": 127,
      "triggerAsyncId": 126,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " step",
      "userCode": false,
      "triggers": [
        133,
        133
      ],
      "line": "\n// using \"arg\" module for parsing CLI arguments\n// because it plays really nicely with TypeScript\nimport arg from 'arg'\nimport { prop, sortBy, last, equals } from 'ramda'\nimport pluralize from 'pluralize'\n\n// inquirer-confirm is missing type definition\n// @ts-ignor",
      "startLine": 7,
      "startCol": 91,
      "endLine": 7,
      "endCol": 91,
      "file": "scripts/binary/move-binaries.ts",
      "uniqueid": 2
    },
    "3": {
      "source": "scripts/unit/binary/move-binaries-spec.js:152:25:152:25",
      "startTime": "933376999467868",
      "endTime": "933377005833761",
      "elapsedTime": "6365893",
      "asyncId": 128,
      "triggerAsyncId": 124,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "line": "\n      const args = [nodeName, scriptName, '--sha', sha, '--version', version]\n\n      return move(args).then((result) => {\n        la(is.object(result), 'expected a result', result)\n\n        snapshot('collected builds and copied desktop', result",
      "startLine": 152,
      "startCol": 25,
      "endLine": 152,
      "endCol": 25,
      "file": "scripts/unit/binary/move-binaries-spec.js",
      "triggers": [
        130
      ],
      "uniqueid": 3
    },
    "4": {
      "source": "node_modules/mocha/lib/runnable.js:352:10:352:10",
      "startTime": "933376999785984",
      "endTime": "933377006061929",
      "elapsedTime": "6275945",
      "asyncId": 130,
      "triggerAsyncId": 128,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " callFn",
      "userCode": false,
      "line": "\n      self.resetTimeout();\n      result\n        .then(function () {\n          done();\n          // Return null so libraries like bluebird do not warn about\n          // subsequently constructed Promises",
      "startLine": 352,
      "startCol": 10,
      "endLine": 352,
      "endCol": 10,
      "file": "node_modules/mocha/lib/runnable.js",
      "triggers": [],
      "uniqueid": 4
    },
    "5": {
      "source": "scripts/binary/move-binaries.ts:3:65:3:65",
      "startTime": "933377001093626",
      "endTime": "933377001478557",
      "elapsedTime": "384931",
      "asyncId": 133,
      "triggerAsyncId": 127,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " adopt",
      "userCode": false,
      "line": "import { s3helpers } from './s3-api'\nconst debug = require('debug')('cypress:binary')\nimport la from 'lazy-ass'\nimport is from 'check-more-types'\n// using \"arg\" module for parsing CLI arguments\n// because it plays really nicely with TypeScript\nimport arg from 'arg'\nimport { prop, sortBy, last, equals } from 'ramda",
      "startLine": 3,
      "startCol": 65,
      "endLine": 3,
      "endCol": 65,
      "file": "scripts/binary/move-binaries.ts",
      "triggers": [
        134
      ],
      "uniqueid": 5
    },
    "6": {
      "source": "scripts/binary/move-binaries.ts:7:91:7:91",
      "startTime": "933377001313899",
      "endTime": "933377003517900",
      "elapsedTime": "2204001",
      "asyncId": 134,
      "triggerAsyncId": 133,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " step",
      "userCode": false,
      "triggers": [
        137,
        137
      ],
      "line": "\n// using \"arg\" module for parsing CLI arguments\n// because it plays really nicely with TypeScript\nimport arg from 'arg'\nimport { prop, sortBy, last, equals } from 'ramda'\nimport pluralize from 'pluralize'\n\n// inquirer-confirm is missing type definition\n// @ts-ignor",
      "startLine": 7,
      "startCol": 91,
      "endLine": 7,
      "endCol": 91,
      "file": "scripts/binary/move-binaries.ts",
      "uniqueid": 6
    },
    "7": {
      "source": "scripts/binary/move-binaries.ts:3:65:3:65",
      "startTime": "933377003269915",
      "endTime": "933377003668462",
      "elapsedTime": "398547",
      "asyncId": 137,
      "triggerAsyncId": 134,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " adopt",
      "userCode": false,
      "line": "import { s3helpers } from './s3-api'\nconst debug = require('debug')('cypress:binary')\nimport la from 'lazy-ass'\nimport is from 'check-more-types'\n// using \"arg\" module for parsing CLI arguments\n// because it plays really nicely with TypeScript\nimport arg from 'arg'\nimport { prop, sortBy, last, equals } from 'ramda",
      "startLine": 3,
      "startCol": 65,
      "endLine": 3,
      "endCol": 65,
      "file": "scripts/binary/move-binaries.ts",
      "triggers": [
        138
      ],
      "uniqueid": 7
    },
    "8": {
      "source": "scripts/binary/move-binaries.ts:7:91:7:91",
      "startTime": "933377003494947",
      "endTime": "933377004490413",
      "elapsedTime": "995466",
      "asyncId": 138,
      "triggerAsyncId": 137,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " step",
      "userCode": false,
      "triggers": [
        141,
        141
      ],
      "line": "\n// using \"arg\" module for parsing CLI arguments\n// because it plays really nicely with TypeScript\nimport arg from 'arg'\nimport { prop, sortBy, last, equals } from 'ramda'\nimport pluralize from 'pluralize'\n\n// inquirer-confirm is missing type definition\n// @ts-ignor",
      "startLine": 7,
      "startCol": 91,
      "endLine": 7,
      "endCol": 91,
      "file": "scripts/binary/move-binaries.ts",
      "uniqueid": 8
    },
    "9": {
      "source": "scripts/binary/move-binaries.ts:3:65:3:65",
      "startTime": "933377004253449",
      "endTime": "933377004623974",
      "elapsedTime": "370525",
      "asyncId": 141,
      "triggerAsyncId": 138,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " adopt",
      "userCode": false,
      "line": "import { s3helpers } from './s3-api'\nconst debug = require('debug')('cypress:binary')\nimport la from 'lazy-ass'\nimport is from 'check-more-types'\n// using \"arg\" module for parsing CLI arguments\n// because it plays really nicely with TypeScript\nimport arg from 'arg'\nimport { prop, sortBy, last, equals } from 'ramda",
      "startLine": 3,
      "startCol": 65,
      "endLine": 3,
      "endCol": 65,
      "file": "scripts/binary/move-binaries.ts",
      "triggers": [
        142
      ],
      "uniqueid": 9
    },
    "10": {
      "source": "scripts/binary/move-binaries.ts:7:91:7:91",
      "startTime": "933377004471608",
      "endTime": "933377004739641",
      "elapsedTime": "268033",
      "asyncId": 142,
      "triggerAsyncId": 141,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " step",
      "userCode": false,
      "line": "\n// using \"arg\" module for parsing CLI arguments\n// because it plays really nicely with TypeScript\nimport arg from 'arg'\nimport { prop, sortBy, last, equals } from 'ramda'\nimport pluralize from 'pluralize'\n\n// inquirer-confirm is missing type definition\n// @ts-ignor",
      "startLine": 7,
      "startCol": 91,
      "endLine": 7,
      "endCol": 91,
      "file": "scripts/binary/move-binaries.ts",
      "triggers": [],
      "uniqueid": 10
    },
    "11": {
      "source": "scripts/unit/github-actions/update-browser-version-spec.js:269:46:269:46",
      "startTime": "933377204181413",
      "endTime": "933377204197733",
      "elapsedTime": "16320",
      "asyncId": 910,
      "triggerAsyncId": 908,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "line": "\n      const github = {\n        pulls: {\n          list: sinon.stub().returns(Promise.resolve(\n            {\n              data: [\n                { number: '123' }",
      "startLine": 269,
      "startCol": 46,
      "endLine": 269,
      "endCol": 46,
      "file": "scripts/unit/github-actions/update-browser-version-spec.js",
      "triggers": [
        912
      ],
      "uniqueid": 11
    },
    "12": {
      "source": "scripts/unit/github-actions/update-browser-version-spec.js:287:13:287:13",
      "startTime": "933377204641916",
      "endTime": "933377205716961",
      "elapsedTime": "1075045",
      "asyncId": 911,
      "triggerAsyncId": 908,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "triggers": [
        916,
        913
      ],
      "line": "\n      }\n\n      await updatePRTitle({\n        context,\n        github,\n        baseBranch: 'develop'",
      "startLine": 287,
      "startCol": 13,
      "endLine": 287,
      "endCol": 13,
      "file": "scripts/unit/github-actions/update-browser-version-spec.js",
      "uniqueid": 12
    },
    "13": {
      "source": "scripts/unit/github-actions/update-browser-version-spec.js:287:13:287:13",
      "startTime": "933377204904919",
      "endTime": "933377205680944",
      "elapsedTime": "776025",
      "asyncId": 912,
      "triggerAsyncId": 910,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "line": "\n      }\n\n      await updatePRTitle({\n        context,\n        github,\n        baseBranch: 'develop'",
      "startLine": 287,
      "startCol": 13,
      "endLine": 287,
      "endCol": 13,
      "file": "scripts/unit/github-actions/update-browser-version-spec.js",
      "triggers": [],
      "uniqueid": 13
    },
    "14": {
      "source": "node_modules/mocha/lib/runnable.js:348:21:348:21",
      "startTime": "933377205106116",
      "endTime": "933377206032322",
      "elapsedTime": "926206",
      "asyncId": 913,
      "triggerAsyncId": 911,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " callFn",
      "userCode": false,
      "line": "\n\n  function callFn (fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      resul",
      "startLine": 348,
      "startCol": 21,
      "endLine": 348,
      "endCol": 21,
      "file": "node_modules/mocha/lib/runnable.js",
      "triggers": [],
      "uniqueid": 14
    },
    "15": {
      "source": "scripts/unit/github-actions/update-browser-version-spec.js:287:7:287:7",
      "startTime": "933377205512287",
      "endTime": "933377205642011",
      "elapsedTime": "129724",
      "asyncId": 916,
      "triggerAsyncId": 911,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "line": "\n      }\n\n      await updatePRTitle({\n        context,\n        github,\n        baseBranch: 'develop'",
      "startLine": 287,
      "startCol": 7,
      "endLine": 287,
      "endCol": 7,
      "file": "scripts/unit/github-actions/update-browser-version-spec.js",
      "triggers": [
        917
      ],
      "uniqueid": 15
    },
    "16": {
      "source": "scripts/unit/github-actions/update-browser-version-spec.js:287:7:287:7",
      "startTime": "933377205627023",
      "endTime": "933377205757276",
      "elapsedTime": "130253",
      "asyncId": 917,
      "triggerAsyncId": 916,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "line": "\n      }\n\n      await updatePRTitle({\n        context,\n        github,\n        baseBranch: 'develop'",
      "startLine": 287,
      "startCol": 7,
      "endLine": 287,
      "endCol": 7,
      "file": "scripts/unit/github-actions/update-browser-version-spec.js",
      "triggers": [],
      "uniqueid": 16
    },
    "17": {
      "source": "scripts/unit/github-actions/update-browser-version-spec.js:313:46:313:46",
      "startTime": "933377207132565",
      "endTime": "933377207149226",
      "elapsedTime": "16661",
      "asyncId": 926,
      "triggerAsyncId": 924,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "line": "\n      const github = {\n        pulls: {\n          list: sinon.stub().returns(Promise.resolve(\n            {\n              data: [],\n            }",
      "startLine": 313,
      "startCol": 46,
      "endLine": 313,
      "endCol": 46,
      "file": "scripts/unit/github-actions/update-browser-version-spec.js",
      "triggers": [
        928
      ],
      "uniqueid": 17
    },
    "18": {
      "source": "scripts/unit/github-actions/update-browser-version-spec.js:331:13:331:13",
      "startTime": "933377207667798",
      "endTime": "933377208501060",
      "elapsedTime": "833262",
      "asyncId": 927,
      "triggerAsyncId": 924,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "line": "\n      sinon.spy(console, 'log')\n\n      await updatePRTitle({\n        context,\n        github,\n        baseBranch: 'develop'",
      "startLine": 331,
      "startCol": 13,
      "endLine": 331,
      "endCol": 13,
      "file": "scripts/unit/github-actions/update-browser-version-spec.js",
      "triggers": [
        929
      ],
      "uniqueid": 18
    },
    "19": {
      "source": "scripts/unit/github-actions/update-browser-version-spec.js:331:13:331:13",
      "startTime": "933377207906345",
      "endTime": "933377208537629",
      "elapsedTime": "631284",
      "asyncId": 928,
      "triggerAsyncId": 926,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "line": "\n      sinon.spy(console, 'log')\n\n      await updatePRTitle({\n        context,\n        github,\n        baseBranch: 'develop'",
      "startLine": 331,
      "startCol": 13,
      "endLine": 331,
      "endCol": 13,
      "file": "scripts/unit/github-actions/update-browser-version-spec.js",
      "triggers": [],
      "uniqueid": 19
    },
    "20": {
      "source": "node_modules/mocha/lib/runnable.js:348:21:348:21",
      "startTime": "933377208124775",
      "endTime": "933377208875131",
      "elapsedTime": "750356",
      "asyncId": 929,
      "triggerAsyncId": 927,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " callFn",
      "userCode": false,
      "line": "\n\n  function callFn (fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      resul",
      "startLine": 348,
      "startCol": 21,
      "endLine": 348,
      "endCol": 21,
      "file": "node_modules/mocha/lib/runnable.js",
      "triggers": [],
      "uniqueid": 20
    },
    "21": {
      "source": "scripts/unit/github-actions/update-browser-version-spec.js:356:48:356:48",
      "startTime": "933377210482244",
      "endTime": "933377210498384",
      "elapsedTime": "16140",
      "asyncId": 943,
      "triggerAsyncId": 941,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "line": "\n      const github = {\n        pulls: {\n          create: sinon.stub().returns(Promise.resolve()),\n        },\n      }",
      "startLine": 356,
      "startCol": 48,
      "endLine": 356,
      "endCol": 48,
      "file": "scripts/unit/github-actions/update-browser-version-spec.js",
      "triggers": [
        945
      ],
      "uniqueid": 21
    },
    "22": {
      "source": "scripts/unit/github-actions/update-browser-version-spec.js:367:13:367:13",
      "startTime": "933377210791754",
      "endTime": "933377211461429",
      "elapsedTime": "669675",
      "asyncId": 944,
      "triggerAsyncId": 941,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "line": "\n      }\n\n      await createPullRequest({\n        context,\n        github,\n        baseBranch: 'develop'",
      "startLine": 367,
      "startCol": 13,
      "endLine": 367,
      "endCol": 13,
      "file": "scripts/unit/github-actions/update-browser-version-spec.js",
      "triggers": [
        946
      ],
      "uniqueid": 22
    },
    "23": {
      "source": "scripts/unit/github-actions/update-browser-version-spec.js:367:13:367:13",
      "startTime": "933377211059376",
      "endTime": "933377211495664",
      "elapsedTime": "436288",
      "asyncId": 945,
      "triggerAsyncId": 943,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " Context.<anonymous>",
      "userCode": false,
      "line": "\n      }\n\n      await createPullRequest({\n        context,\n        github,\n        baseBranch: 'develop'",
      "startLine": 367,
      "startCol": 13,
      "endLine": 367,
      "endCol": 13,
      "file": "scripts/unit/github-actions/update-browser-version-spec.js",
      "triggers": [],
      "uniqueid": 23
    },
    "24": {
      "source": "node_modules/mocha/lib/runnable.js:348:21:348:21",
      "startTime": "933377211230787",
      "endTime": "933377211668588",
      "elapsedTime": "437801",
      "asyncId": 946,
      "triggerAsyncId": 944,
      "io": false,
      "createdIn": 1626209660466,
      "functionName": " callFn",
      "userCode": false,
      "line": "\n\n  function callFn (fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      resul",
      "startLine": 348,
      "startCol": 21,
      "endLine": 348,
      "endCol": 21,
      "file": "node_modules/mocha/lib/runnable.js",
      "triggers": [],
      "uniqueid": 24
    }
  },
  "antipatterns": {
    "0": {
      "patternID": "pattern2",
      "file": "npm/webpack-dev-server/src/index.ts",
      "startLine": "26",
      "startCol": "7",
      "endLine": "39",
      "endCol": "8"
    },
    "1": {
      "patternID": "pattern2",
      "file": "packages/driver/src/cypress/cy.js",
      "startLine": "634",
      "startCol": "15",
      "endLine": "636",
      "endCol": "17"
    },
    "2": {
      "patternID": "pattern2",
      "file": "packages/driver/src/cypress/source_map_utils.js",
      "startLine": "19",
      "startCol": "10",
      "endLine": "23",
      "endCol": "4"
    },
    "3": {
      "patternID": "pattern2",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/promises_spec.js",
      "startLine": "10",
      "startCol": "10",
      "endLine": "13",
      "endCol": "4"
    },
    "4": {
      "patternID": "pattern2",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/return_value_spec.js",
      "startLine": "22",
      "startCol": "10",
      "endLine": "24",
      "endCol": "4"
    },
    "5": {
      "patternID": "pattern2",
      "file": "packages/server/test/support/fixtures/projects/plugin-before-browser-launch-deprecation/cypress/plugins/index.js",
      "startLine": "97",
      "startCol": "18",
      "endLine": "101",
      "endCol": "12"
    },
    "6": {
      "patternID": "pattern2",
      "file": "scripts/binary/build.js",
      "startLine": "446",
      "startCol": "10",
      "endLine": "447",
      "endCol": "22"
    },
    "7": {
      "patternID": "pattern2",
      "file": "scripts/binary/util/packages.js",
      "startLine": "75",
      "startCol": "12",
      "endLine": "84",
      "endCol": "6"
    },
    "8": {
      "patternID": "pattern5",
      "file": "cli/lib/cli.js",
      "startLine": "298",
      "startCol": "19",
      "endLine": "330",
      "endCol": "3"
    },
    "9": {
      "patternID": "pattern5",
      "file": "cli/lib/exec/spawn.js",
      "startLine": "93",
      "startCol": "19",
      "endLine": "224",
      "endCol": "5"
    },
    "10": {
      "patternID": "pattern5",
      "file": "cli/lib/tasks/download.js",
      "startLine": "57",
      "startCol": "15",
      "endLine": "77",
      "endCol": "1"
    },
    "11": {
      "patternID": "pattern5",
      "file": "cli/lib/tasks/download.js",
      "startLine": "206",
      "startCol": "25",
      "endLine": "316",
      "endCol": "1"
    },
    "12": {
      "patternID": "pattern5",
      "file": "cli/lib/util.js",
      "startLine": "36",
      "startCol": "25",
      "endLine": "57",
      "endCol": "1"
    },
    "13": {
      "patternID": "pattern5",
      "file": "cli/test/lib/tasks/unzip_spec.js",
      "startLine": "79",
      "startCol": "63",
      "endLine": "84",
      "endCol": "7"
    },
    "14": {
      "patternID": "pattern5",
      "file": "cli/test/lib/tasks/unzip_spec.js",
      "startLine": "120",
      "startCol": "63",
      "endLine": "125",
      "endCol": "7"
    },
    "15": {
      "patternID": "pattern5",
      "file": "cli/test/lib/tasks/unzip_spec.js",
      "startLine": "172",
      "startCol": "63",
      "endLine": "177",
      "endCol": "7"
    },
    "16": {
      "patternID": "pattern5",
      "file": "npm/cypress-schematic/src/schematics/utility/index.ts",
      "startLine": "37",
      "startCol": "8",
      "endLine": "61",
      "endCol": "1"
    },
    "17": {
      "patternID": "pattern5",
      "file": "npm/react/cypress/component/advanced/lazy-loaded-suspense/LazyComponent.tsx",
      "startLine": "5",
      "startCol": "9",
      "endLine": "5",
      "endCol": "79"
    },
    "18": {
      "patternID": "pattern5",
      "file": "npm/vue/cypress/component/counter-vuex/store.js",
      "startLine": "39",
      "startCol": "18",
      "endLine": "46",
      "endCol": "3"
    },
    "19": {
      "patternID": "pattern5",
      "file": "npm/webpack-batteries-included-preprocessor/test/fixtures/export-es2015.js",
      "startLine": "10",
      "startCol": "24",
      "endLine": "14",
      "endCol": "1"
    },
    "20": {
      "patternID": "pattern5",
      "file": "npm/webpack-dev-server/src/index.ts",
      "startLine": "17",
      "startCol": "8",
      "endLine": "42",
      "endCol": "1"
    },
    "21": {
      "patternID": "pattern5",
      "file": "npm/webpack-dev-server/test/e2e.spec.ts",
      "startLine": "11",
      "startCol": "25",
      "endLine": "33",
      "endCol": "1"
    },
    "22": {
      "patternID": "pattern5",
      "file": "npm/webpack-dev-server/test/e2e.spec.ts",
      "startLine": "60",
      "startCol": "47",
      "endLine": "77",
      "endCol": "3"
    },
    "23": {
      "patternID": "pattern5",
      "file": "npm/webpack-dev-server/test/e2e.spec.ts",
      "startLine": "79",
      "startCol": "74",
      "endLine": "95",
      "endCol": "3"
    },
    "24": {
      "patternID": "pattern5",
      "file": "npm/webpack-dev-server/test/e2e.spec.ts",
      "startLine": "97",
      "startCol": "67",
      "endLine": "125",
      "endCol": "3"
    },
    "25": {
      "patternID": "pattern5",
      "file": "npm/webpack-dev-server/test/e2e.spec.ts",
      "startLine": "127",
      "startCol": "54",
      "endLine": "153",
      "endCol": "3"
    },
    "26": {
      "patternID": "pattern5",
      "file": "packages/desktop-gui/cypress/integration/global_mode_spec.js",
      "startLine": "54",
      "startCol": "11",
      "endLine": "62",
      "endCol": "5"
    },
    "27": {
      "patternID": "pattern5",
      "file": "packages/desktop-gui/src/lib/ipc-bus.js",
      "startLine": "89",
      "startCol": "10",
      "endLine": "106",
      "endCol": "5"
    },
    "28": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/connectors_spec.js",
      "startLine": "74",
      "startCol": "54",
      "endLine": "76",
      "endCol": "11"
    },
    "29": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/connectors_spec.js",
      "startLine": "160",
      "startCol": "15",
      "endLine": "166",
      "endCol": "9"
    },
    "30": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/connectors_spec.js",
      "startLine": "250",
      "startCol": "37",
      "endLine": "252",
      "endCol": "11"
    },
    "31": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/connectors_spec.js",
      "startLine": "1862",
      "startCol": "33",
      "endLine": "1870",
      "endCol": "9"
    },
    "32": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/connectors_spec.js",
      "startLine": "1966",
      "startCol": "29",
      "endLine": "1968",
      "endCol": "11"
    },
    "33": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/navigation_spec.js",
      "startLine": "2416",
      "startCol": "19",
      "endLine": "2422",
      "endCol": "11"
    },
    "34": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/navigation_spec.js",
      "startLine": "2486",
      "startCol": "19",
      "endLine": "2492",
      "endCol": "11"
    },
    "35": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1179",
      "startCol": "89",
      "endLine": "1183",
      "endCol": "7"
    },
    "36": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1183",
      "startCol": "138",
      "endLine": "1187",
      "endCol": "7"
    },
    "37": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1810",
      "startCol": "15",
      "endLine": "1814",
      "endCol": "9"
    },
    "38": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1822",
      "startCol": "15",
      "endLine": "1826",
      "endCol": "9"
    },
    "39": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1836",
      "startCol": "15",
      "endLine": "1840",
      "endCol": "9"
    },
    "40": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1850",
      "startCol": "15",
      "endLine": "1854",
      "endCol": "9"
    },
    "41": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "2632",
      "startCol": "15",
      "endLine": "2644",
      "endCol": "9"
    },
    "42": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "2703",
      "startCol": "29",
      "endLine": "2703",
      "endCol": "53"
    },
    "43": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "2726",
      "startCol": "29",
      "endLine": "2726",
      "endCol": "53"
    },
    "44": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "2773",
      "startCol": "29",
      "endLine": "2773",
      "endCol": "53"
    },
    "45": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "428",
      "startCol": "24",
      "endLine": "440",
      "endCol": "9"
    },
    "46": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "473",
      "startCol": "26",
      "endLine": "481",
      "endCol": "9"
    },
    "47": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "1035",
      "startCol": "26",
      "endLine": "1042",
      "endCol": "9"
    },
    "48": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "1060",
      "startCol": "24",
      "endLine": "1071",
      "endCol": "9"
    },
    "49": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "1540",
      "startCol": "24",
      "endLine": "1546",
      "endCol": "7"
    },
    "50": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "2199",
      "startCol": "24",
      "endLine": "2203",
      "endCol": "9"
    },
    "51": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "2214",
      "startCol": "24",
      "endLine": "2224",
      "endCol": "9"
    },
    "52": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "2427",
      "startCol": "24",
      "endLine": "2431",
      "endCol": "9"
    },
    "53": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "2446",
      "startCol": "24",
      "endLine": "2450",
      "endCol": "9"
    },
    "54": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "2487",
      "startCol": "24",
      "endLine": "2493",
      "endCol": "9"
    },
    "55": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "2617",
      "startCol": "13",
      "endLine": "2631",
      "endCol": "7"
    },
    "56": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "2680",
      "startCol": "22",
      "endLine": "2688",
      "endCol": "7"
    },
    "57": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "2691",
      "startCol": "22",
      "endLine": "2699",
      "endCol": "7"
    },
    "58": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/commands/xhr_spec.js",
      "startLine": "2721",
      "startCol": "22",
      "endLine": "2729",
      "endCol": "7"
    },
    "59": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/cy/snapshot_css_spec.js",
      "startLine": "10",
      "startCol": "19",
      "endLine": "14",
      "endCol": "1"
    },
    "60": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/e2e/focus_blur_spec.js",
      "startLine": "518",
      "startCol": "26",
      "endLine": "525",
      "endCol": "7"
    },
    "61": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/e2e/promises_spec.js",
      "startLine": "113",
      "startCol": "33",
      "endLine": "117",
      "endCol": "5"
    },
    "62": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/e2e/zonejs_spec.js",
      "startLine": "6",
      "startCol": "40",
      "endLine": "23",
      "endCol": "5"
    },
    "63": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/issues/2784_spec.js",
      "startLine": "5",
      "startCol": "24",
      "endLine": "13",
      "endCol": "5"
    },
    "64": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/issues/573_spec.js",
      "startLine": "3",
      "startCol": "29",
      "endLine": "14",
      "endCol": "3"
    },
    "65": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/issues/573_spec.js",
      "startLine": "18",
      "startCol": "38",
      "endLine": "35",
      "endCol": "3"
    },
    "66": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/issues/573_spec.js",
      "startLine": "36",
      "startCol": "29",
      "endLine": "54",
      "endCol": "3"
    },
    "67": {
      "patternID": "pattern5",
      "file": "packages/driver/cypress/integration/issues/761_2968_3973_spec.js",
      "startLine": "86",
      "startCol": "13",
      "endLine": "104",
      "endCol": "7"
    },
    "68": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cy/commands/actions/scroll.js",
      "startLine": "114",
      "startCol": "30",
      "endLine": "140",
      "endCol": "7"
    },
    "69": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cy/commands/actions/scroll.js",
      "startLine": "357",
      "startCol": "24",
      "endLine": "382",
      "endCol": "7"
    },
    "70": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cy/commands/navigation.js",
      "startLine": "110",
      "startCol": "20",
      "endLine": "116",
      "endCol": "1"
    },
    "71": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cy/commands/navigation.js",
      "startLine": "316",
      "startCol": "19",
      "endLine": "343",
      "endCol": "3"
    },
    "72": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cy/commands/navigation.js",
      "startLine": "513",
      "startCol": "22",
      "endLine": "544",
      "endCol": "7"
    },
    "73": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cy/commands/navigation.js",
      "startLine": "770",
      "startCol": "31",
      "endLine": "821",
      "endCol": "7"
    },
    "74": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cy/commands/screenshot.js",
      "startLine": "300",
      "startCol": "21",
      "endLine": "304",
      "endCol": "3"
    },
    "75": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cy/commands/window.js",
      "startLine": "53",
      "startCol": "37",
      "endLine": "76",
      "endCol": "3"
    },
    "76": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cy/stability.js",
      "startLine": "30",
      "startCol": "22",
      "endLine": "49",
      "endCol": "3"
    },
    "77": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cypress/network_utils.js",
      "startLine": "3",
      "startCol": "15",
      "endLine": "18",
      "endCol": "1"
    },
    "78": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cypress.js",
      "startLine": "531",
      "startCol": "11",
      "endLine": "556",
      "endCol": "3"
    },
    "79": {
      "patternID": "pattern5",
      "file": "packages/driver/src/cypress.js",
      "startLine": "558",
      "startCol": "14",
      "endLine": "577",
      "endCol": "3"
    },
    "80": {
      "patternID": "pattern5",
      "file": "packages/https-proxy/lib/server.js",
      "startLine": "228",
      "startCol": "22",
      "endLine": "252",
      "endCol": "3"
    },
    "81": {
      "patternID": "pattern5",
      "file": "packages/https-proxy/test/helpers/http_server.js",
      "startLine": "20",
      "startCol": "9",
      "endLine": "28",
      "endCol": "3"
    },
    "82": {
      "patternID": "pattern5",
      "file": "packages/https-proxy/test/helpers/http_server.js",
      "startLine": "30",
      "startCol": "8",
      "endLine": "34",
      "endCol": "3"
    },
    "83": {
      "patternID": "pattern5",
      "file": "packages/https-proxy/test/helpers/https_server.js",
      "startLine": "28",
      "startCol": "9",
      "endLine": "42",
      "endCol": "3"
    },
    "84": {
      "patternID": "pattern5",
      "file": "packages/https-proxy/test/helpers/https_server.js",
      "startLine": "45",
      "startCol": "18",
      "endLine": "49",
      "endCol": "5"
    },
    "85": {
      "patternID": "pattern5",
      "file": "packages/https-proxy/test/helpers/proxy.js",
      "startLine": "67",
      "startCol": "11",
      "endLine": "82",
      "endCol": "5"
    },
    "86": {
      "patternID": "pattern5",
      "file": "packages/https-proxy/test/integration/proxy_spec.js",
      "startLine": "101",
      "startCol": "11",
      "endLine": "116",
      "endCol": "5"
    },
    "87": {
      "patternID": "pattern5",
      "file": "packages/https-proxy/test/integration/proxy_spec.js",
      "startLine": "276",
      "startCol": "13",
      "endLine": "291",
      "endCol": "7"
    },
    "88": {
      "patternID": "pattern5",
      "file": "packages/net-stubbing/lib/server/middleware/request.ts",
      "startLine": "102",
      "startCol": "22",
      "endLine": "113",
      "endCol": "3"
    },
    "89": {
      "patternID": "pattern5",
      "file": "packages/rewriter/lib/html.ts",
      "startLine": "17",
      "startCol": "8",
      "endLine": "32",
      "endCol": "1"
    },
    "90": {
      "patternID": "pattern5",
      "file": "packages/runner/cypress/support/helpers.js",
      "startLine": "113",
      "startCol": "31",
      "endLine": "293",
      "endCol": "5"
    },
    "91": {
      "patternID": "pattern5",
      "file": "packages/runner/src/lib/event-manager.js",
      "startLine": "373",
      "startCol": "37",
      "endLine": "388",
      "endCol": "5"
    },
    "92": {
      "patternID": "pattern5",
      "file": "packages/runner/src/lib/event-manager.js",
      "startLine": "524",
      "startCol": "12",
      "endLine": "529",
      "endCol": "3"
    },
    "93": {
      "patternID": "pattern5",
      "file": "packages/runner-ct/src/lib/event-manager.js",
      "startLine": "306",
      "startCol": "37",
      "endLine": "314",
      "endCol": "5"
    },
    "94": {
      "patternID": "pattern5",
      "file": "packages/runner-ct/src/lib/event-manager.js",
      "startLine": "426",
      "startCol": "12",
      "endLine": "431",
      "endCol": "3"
    },
    "95": {
      "patternID": "pattern5",
      "file": "packages/runner-ct/src/lib/state.ts",
      "startLine": "334",
      "startCol": "27",
      "endLine": "334",
      "endCol": "85"
    },
    "96": {
      "patternID": "pattern5",
      "file": "packages/server/lib/browsers/index.js",
      "startLine": "14",
      "startCol": "14",
      "endLine": "43",
      "endCol": "1"
    },
    "97": {
      "patternID": "pattern5",
      "file": "packages/server/lib/cypress.js",
      "startLine": "72",
      "startCol": "24",
      "endLine": "111",
      "endCol": "5"
    },
    "98": {
      "patternID": "pattern5",
      "file": "packages/server/lib/file_server.js",
      "startLine": "52",
      "startCol": "10",
      "endLine": "80",
      "endCol": "3"
    },
    "99": {
      "patternID": "pattern5",
      "file": "packages/server/lib/logger.js",
      "startLine": "137",
      "startCol": "18",
      "endLine": "158",
      "endCol": "1"
    },
    "100": {
      "patternID": "pattern5",
      "file": "packages/server/lib/modes/run.js",
      "startLine": "984",
      "startCol": "23",
      "endLine": "1039",
      "endCol": "3"
    },
    "101": {
      "patternID": "pattern5",
      "file": "packages/server/lib/modes/run.js",
      "startLine": "1133",
      "startCol": "27",
      "endLine": "1153",
      "endCol": "3"
    },
    "102": {
      "patternID": "pattern5",
      "file": "packages/server/lib/plugins/index.js",
      "startLine": "40",
      "startCol": "14",
      "endLine": "201",
      "endCol": "1"
    },
    "103": {
      "patternID": "pattern5",
      "file": "packages/server/lib/plugins/util.js",
      "startLine": "60",
      "startCol": "21",
      "endLine": "87",
      "endCol": "3"
    },
    "104": {
      "patternID": "pattern5",
      "file": "packages/server/lib/video_capture.js",
      "startLine": "81",
      "startCol": "15",
      "endLine": "91",
      "endCol": "3"
    },
    "105": {
      "patternID": "pattern5",
      "file": "packages/server/lib/video_capture.js",
      "startLine": "186",
      "startCol": "28",
      "endLine": "242",
      "endCol": "5"
    },
    "106": {
      "patternID": "pattern5",
      "file": "packages/server/lib/video_capture.js",
      "startLine": "256",
      "startCol": "17",
      "endLine": "343",
      "endCol": "3"
    },
    "107": {
      "patternID": "pattern5",
      "file": "packages/server/test/e2e/4_browser_path_spec.js",
      "startLine": "8",
      "startCol": "17",
      "endLine": "22",
      "endCol": "1"
    },
    "108": {
      "patternID": "pattern5",
      "file": "packages/server/test/e2e/6_video_compression_spec.js",
      "startLine": "22",
      "startCol": "1",
      "endLine": "31",
      "endCol": "1"
    },
    "109": {
      "patternID": "pattern5",
      "file": "packages/server/test/performance/proxy_performance_spec.js",
      "startLine": "275",
      "startCol": "19",
      "endLine": "287",
      "endCol": "9"
    },
    "110": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/block_hosts_spec.js",
      "startLine": "6",
      "startCol": "22",
      "endLine": "15",
      "endCol": "5"
    },
    "111": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/block_hosts_spec.js",
      "startLine": "17",
      "startCol": "22",
      "endLine": "29",
      "endCol": "5"
    },
    "112": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/cache_clearing_spec.js",
      "startLine": "5",
      "startCol": "13",
      "endLine": "18",
      "endCol": "1"
    },
    "113": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/cache_spec.js",
      "startLine": "2",
      "startCol": "14",
      "endLine": "17",
      "endCol": "1"
    },
    "114": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/form_submission_multipart_spec.js",
      "startLine": "23",
      "startCol": "43",
      "endLine": "36",
      "endCol": "3"
    },
    "115": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/https_passthru_spec.js",
      "startLine": "2",
      "startCol": "49",
      "endLine": "14",
      "endCol": "3"
    },
    "116": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/https_passthru_spec.js",
      "startLine": "16",
      "startCol": "78",
      "endLine": "29",
      "endCol": "3"
    },
    "117": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/iframe_spec.js",
      "startLine": "80",
      "startCol": "22",
      "endLine": "91",
      "endCol": "5"
    },
    "118": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/images_spec.js",
      "startLine": "5",
      "startCol": "22",
      "endLine": "13",
      "endCol": "5"
    },
    "119": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/images_spec.js",
      "startLine": "18",
      "startCol": "22",
      "endLine": "26",
      "endCol": "5"
    },
    "120": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/js_error_handling_failing_spec.js",
      "startLine": "80",
      "startCol": "13",
      "endLine": "89",
      "endCol": "7"
    },
    "121": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/proxying_spec.js",
      "startLine": "6",
      "startCol": "11",
      "endLine": "22",
      "endCol": "5"
    },
    "122": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/server_sent_events_spec.js",
      "startLine": "2",
      "startCol": "19",
      "endLine": "16",
      "endCol": "1"
    },
    "123": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/server_sent_events_spec.js",
      "startLine": "33",
      "startCol": "11",
      "endLine": "51",
      "endCol": "5"
    },
    "124": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/server_sent_events_spec.js",
      "startLine": "60",
      "startCol": "11",
      "endLine": "70",
      "endCol": "5"
    },
    "125": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/subdomain_spec.js",
      "startLine": "35",
      "startCol": "22",
      "endLine": "45",
      "endCol": "5"
    },
    "126": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/subdomain_spec.js",
      "startLine": "66",
      "startCol": "22",
      "endLine": "77",
      "endCol": "5"
    },
    "127": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/uncaught_during_test_spec.js",
      "startLine": "63",
      "startCol": "33",
      "endLine": "69",
      "endCol": "3"
    },
    "128": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/websockets_spec.js",
      "startLine": "2",
      "startCol": "32",
      "endLine": "21",
      "endCol": "1"
    },
    "129": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/websockets_spec.js",
      "startLine": "38",
      "startCol": "11",
      "endLine": "54",
      "endCol": "5"
    },
    "130": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/xhr_spec.js",
      "startLine": "27",
      "startCol": "22",
      "endLine": "39",
      "endCol": "5"
    },
    "131": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/xhr_spec.js",
      "startLine": "53",
      "startCol": "22",
      "endLine": "65",
      "endCol": "5"
    },
    "132": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/e2e/cypress/integration/xhr_spec.js",
      "startLine": "75",
      "startCol": "22",
      "endLine": "87",
      "endCol": "5"
    },
    "133": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/plugins-async-error/cypress/plugins/index.js",
      "startLine": "2",
      "startCol": "27",
      "endLine": "8",
      "endCol": "3"
    },
    "134": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/fixtures/projects/remote-debugging-disconnect/cypress/plugins.js",
      "startLine": "14",
      "startCol": "23",
      "endLine": "49",
      "endCol": "1"
    },
    "135": {
      "patternID": "pattern5",
      "file": "packages/server/test/support/helpers/serverStub.ts",
      "startLine": "171",
      "startCol": "22",
      "endLine": "188",
      "endCol": "1"
    },
    "136": {
      "patternID": "pattern5",
      "file": "packages/server/test/unit/request_spec.js",
      "startLine": "1022",
      "startCol": "15",
      "endLine": "1030",
      "endCol": "9"
    },
    "137": {
      "patternID": "pattern5",
      "file": "packages/server/test/unit/stream_buffer_spec.js",
      "startLine": "10",
      "startCol": "1",
      "endLine": "16",
      "endCol": "1"
    },
    "138": {
      "patternID": "pattern5",
      "file": "scripts/binary/build.js",
      "startLine": "371",
      "startCol": "28",
      "endLine": "394",
      "endCol": "3"
    },
    "139": {
      "patternID": "pattern5",
      "file": "scripts/binary/s3-api.ts",
      "startLine": "26",
      "startCol": "3",
      "endLine": "47",
      "endCol": "3"
    },
    "140": {
      "patternID": "pattern5",
      "file": "scripts/binary/s3-api.ts",
      "startLine": "52",
      "startCol": "3",
      "endLine": "73",
      "endCol": "3"
    },
    "141": {
      "patternID": "pattern5",
      "file": "scripts/binary/s3-api.ts",
      "startLine": "80",
      "startCol": "3",
      "endLine": "106",
      "endCol": "3"
    },
    "142": {
      "patternID": "pattern5",
      "file": "scripts/binary/s3-api.ts",
      "startLine": "114",
      "startCol": "3",
      "endLine": "131",
      "endCol": "3"
    },
    "143": {
      "patternID": "pattern5",
      "file": "scripts/binary/s3-api.ts",
      "startLine": "137",
      "startCol": "3",
      "endLine": "165",
      "endCol": "3"
    },
    "144": {
      "patternID": "pattern5",
      "file": "scripts/binary/smoke.js",
      "startLine": "68",
      "startCol": "24",
      "endLine": "108",
      "endCol": "1"
    },
    "145": {
      "patternID": "pattern5",
      "file": "scripts/binary/smoke.js",
      "startLine": "129",
      "startCol": "17",
      "endLine": "156",
      "endCol": "3"
    },
    "146": {
      "patternID": "pattern5",
      "file": "scripts/binary/upload-npm-package.js",
      "startLine": "44",
      "startCol": "20",
      "endLine": "67",
      "endCol": "1"
    },
    "147": {
      "patternID": "pattern5",
      "file": "scripts/binary/upload-unique-binary.js",
      "startLine": "80",
      "startCol": "20",
      "endLine": "108",
      "endCol": "1"
    },
    "148": {
      "patternID": "pattern5",
      "file": "scripts/binary/upload.js",
      "startLine": "163",
      "startCol": "20",
      "endLine": "184",
      "endCol": "5"
    },
    "149": {
      "patternID": "pattern5",
      "file": "scripts/circle-cache.js",
      "startLine": "108",
      "startCol": "1",
      "endLine": "124",
      "endCol": "1"
    },
    "150": {
      "patternID": "pattern5",
      "file": "scripts/github-actions/update-browser-versions.js",
      "startLine": "4",
      "startCol": "30",
      "endLine": "31",
      "endCol": "1"
    },
    "151": {
      "patternID": "pattern3",
      "file": "cli/lib/tasks/get-folder-size.js",
      "startLine": "15",
      "startCol": "16",
      "endLine": "15",
      "endCol": "35"
    },
    "152": {
      "patternID": "pattern3",
      "file": "cli/lib/tasks/get-folder-size.js",
      "startLine": "18",
      "startCol": "18",
      "endLine": "18",
      "endCol": "39"
    },
    "153": {
      "patternID": "pattern3",
      "file": "cli/lib/tasks/get-folder-size.js",
      "startLine": "23",
      "startCol": "17",
      "endLine": "23",
      "endCol": "40"
    },
    "154": {
      "patternID": "pattern3",
      "file": "cli/test/lib/cypress_spec.js",
      "startLine": "198",
      "startCol": "25",
      "endLine": "198",
      "endCol": "65"
    },
    "155": {
      "patternID": "pattern3",
      "file": "cli/test/lib/cypress_spec.js",
      "startLine": "208",
      "startCol": "25",
      "endLine": "208",
      "endCol": "65"
    },
    "156": {
      "patternID": "pattern3",
      "file": "cli/test/lib/cypress_spec.js",
      "startLine": "220",
      "startCol": "25",
      "endLine": "220",
      "endCol": "65"
    },
    "157": {
      "patternID": "pattern3",
      "file": "cli/test/lib/cypress_spec.js",
      "startLine": "230",
      "startCol": "25",
      "endLine": "230",
      "endCol": "65"
    },
    "158": {
      "patternID": "pattern3",
      "file": "cli/test/lib/cypress_spec.js",
      "startLine": "239",
      "startCol": "25",
      "endLine": "239",
      "endCol": "65"
    },
    "159": {
      "patternID": "pattern3",
      "file": "cli/test/lib/cypress_spec.js",
      "startLine": "248",
      "startCol": "25",
      "endLine": "248",
      "endCol": "65"
    },
    "160": {
      "patternID": "pattern3",
      "file": "cli/test/lib/cypress_spec.js",
      "startLine": "257",
      "startCol": "25",
      "endLine": "257",
      "endCol": "65"
    },
    "161": {
      "patternID": "pattern3",
      "file": "cli/test/lib/cypress_spec.js",
      "startLine": "268",
      "startCol": "25",
      "endLine": "268",
      "endCol": "65"
    },
    "162": {
      "patternID": "pattern3",
      "file": "cli/test/lib/exec/info_spec.js",
      "startLine": "36",
      "startCol": "5",
      "endLine": "36",
      "endCol": "22"
    },
    "163": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "55",
      "startCol": "5",
      "endLine": "55",
      "endCol": "45"
    },
    "164": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "58",
      "startCol": "5",
      "endLine": "58",
      "endCol": "55"
    },
    "165": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "137",
      "startCol": "7",
      "endLine": "137",
      "endCol": "25"
    },
    "166": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "141",
      "startCol": "21",
      "endLine": "141",
      "endCol": "55"
    },
    "167": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "155",
      "startCol": "7",
      "endLine": "155",
      "endCol": "31"
    },
    "168": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "156",
      "startCol": "7",
      "endLine": "156",
      "endCol": "25"
    },
    "169": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "160",
      "startCol": "21",
      "endLine": "160",
      "endCol": "60"
    },
    "170": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "172",
      "startCol": "7",
      "endLine": "172",
      "endCol": "47"
    },
    "171": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "173",
      "startCol": "7",
      "endLine": "173",
      "endCol": "25"
    },
    "172": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "193",
      "startCol": "7",
      "endLine": "193",
      "endCol": "24"
    },
    "173": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "206",
      "startCol": "7",
      "endLine": "206",
      "endCol": "24"
    },
    "174": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "220",
      "startCol": "7",
      "endLine": "220",
      "endCol": "24"
    },
    "175": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "239",
      "startCol": "7",
      "endLine": "239",
      "endCol": "24"
    },
    "176": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "255",
      "startCol": "7",
      "endLine": "255",
      "endCol": "24"
    },
    "177": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/cache_spec.js",
      "startLine": "271",
      "startCol": "7",
      "endLine": "271",
      "endCol": "28"
    },
    "178": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/install_spec.js",
      "startLine": "476",
      "startCol": "14",
      "endLine": "476",
      "endCol": "63"
    },
    "179": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/install_spec.js",
      "startLine": "486",
      "startCol": "14",
      "endLine": "486",
      "endCol": "63"
    },
    "180": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/install_spec.js",
      "startLine": "502",
      "startCol": "14",
      "endLine": "502",
      "endCol": "63"
    },
    "181": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/install_spec.js",
      "startLine": "512",
      "startCol": "14",
      "endLine": "512",
      "endCol": "63"
    },
    "182": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/install_spec.js",
      "startLine": "522",
      "startCol": "14",
      "endLine": "522",
      "endCol": "63"
    },
    "183": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/install_spec.js",
      "startLine": "537",
      "startCol": "16",
      "endLine": "537",
      "endCol": "70"
    },
    "184": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/install_spec.js",
      "startLine": "553",
      "startCol": "16",
      "endLine": "553",
      "endCol": "70"
    },
    "185": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/install_spec.js",
      "startLine": "563",
      "startCol": "16",
      "endLine": "563",
      "endCol": "70"
    },
    "186": {
      "patternID": "pattern3",
      "file": "cli/test/lib/tasks/install_spec.js",
      "startLine": "573",
      "startCol": "16",
      "endLine": "573",
      "endCol": "70"
    },
    "187": {
      "patternID": "pattern3",
      "file": "npm/angular/src/app/routing/page-one/page-one.component.spec.ts",
      "startLine": "10",
      "startCol": "5",
      "endLine": "12",
      "endCol": "26"
    },
    "188": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/scripts/example.js",
      "startLine": "13",
      "startCol": "3",
      "endLine": "13",
      "endCol": "34"
    },
    "189": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/scripts/example.js",
      "startLine": "14",
      "startCol": "3",
      "endLine": "14",
      "endCol": "68"
    },
    "190": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/scripts/example.js",
      "startLine": "18",
      "startCol": "3",
      "endLine": "18",
      "endCol": "103"
    },
    "191": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/babel/babelTransform.ts",
      "startLine": "31",
      "startCol": "25",
      "endLine": "31",
      "endCol": "74"
    },
    "192": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/babel/babelTransform.ts",
      "startLine": "33",
      "startCol": "27",
      "endLine": "38",
      "endCol": "6"
    },
    "193": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/babel/babelTransform.ts",
      "startLine": "56",
      "startCol": "5",
      "endLine": "56",
      "endCol": "43"
    },
    "194": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/babel/babelTransform.ts",
      "startLine": "134",
      "startCol": "25",
      "endLine": "138",
      "endCol": "6"
    },
    "195": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/init-component-testing.test.ts",
      "startLine": "33",
      "startCol": "5",
      "endLine": "33",
      "endCol": "38"
    },
    "196": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/init-component-testing.test.ts",
      "startLine": "34",
      "startCol": "5",
      "endLine": "34",
      "endCol": "37"
    },
    "197": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/init-component-testing.test.ts",
      "startLine": "333",
      "startCol": "32",
      "endLine": "336",
      "endCol": "5"
    },
    "198": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/init-component-testing.ts",
      "startLine": "49",
      "startCol": "20",
      "endLine": "49",
      "endCol": "54"
    },
    "199": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/init-component-testing.ts",
      "startLine": "64",
      "startCol": "38",
      "endLine": "64",
      "endCol": "94"
    },
    "200": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/init-component-testing.ts",
      "startLine": "66",
      "startCol": "5",
      "endLine": "69",
      "endCol": "16"
    },
    "201": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/init-component-testing.ts",
      "startLine": "130",
      "startCol": "31",
      "endLine": "158",
      "endCol": "4"
    },
    "202": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/component-testing/installFrameworkAdapter.ts",
      "startLine": "35",
      "startCol": "25",
      "endLine": "42",
      "endCol": "4"
    },
    "203": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/initialTemplate.ts",
      "startLine": "8",
      "startCol": "5",
      "endLine": "8",
      "endCol": "65"
    },
    "204": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/installCypress.ts",
      "startLine": "18",
      "startCol": "3",
      "endLine": "18",
      "endCol": "74"
    },
    "205": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/installCypress.ts",
      "startLine": "19",
      "startCol": "3",
      "endLine": "22",
      "endCol": "3"
    },
    "206": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/installCypress.ts",
      "startLine": "26",
      "startCol": "3",
      "endLine": "32",
      "endCol": "3"
    },
    "207": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/installCypress.ts",
      "startLine": "35",
      "startCol": "5",
      "endLine": "35",
      "endCol": "101"
    },
    "208": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/installCypress.ts",
      "startLine": "49",
      "startCol": "5",
      "endLine": "49",
      "endCol": "113"
    },
    "209": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/installCypress.ts",
      "startLine": "57",
      "startCol": "25",
      "endLine": "57",
      "endCol": "52"
    },
    "210": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/installCypress.ts",
      "startLine": "63",
      "startCol": "23",
      "endLine": "63",
      "endCol": "50"
    },
    "211": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.test.ts",
      "startLine": "138",
      "startCol": "7",
      "endLine": "138",
      "endCol": "45"
    },
    "212": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.test.ts",
      "startLine": "139",
      "startCol": "7",
      "endLine": "139",
      "endCol": "44"
    },
    "213": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.test.ts",
      "startLine": "143",
      "startCol": "7",
      "endLine": "146",
      "endCol": "7"
    },
    "214": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.test.ts",
      "startLine": "150",
      "startCol": "14",
      "endLine": "150",
      "endCol": "104"
    },
    "215": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.test.ts",
      "startLine": "151",
      "startCol": "14",
      "endLine": "151",
      "endCol": "104"
    },
    "216": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.test.ts",
      "startLine": "152",
      "startCol": "14",
      "endLine": "152",
      "endCol": "107"
    },
    "217": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.test.ts",
      "startLine": "153",
      "startCol": "14",
      "endLine": "153",
      "endCol": "86"
    },
    "218": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.test.ts",
      "startLine": "157",
      "startCol": "7",
      "endLine": "163",
      "endCol": "7"
    },
    "219": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.test.ts",
      "startLine": "166",
      "startCol": "7",
      "endLine": "166",
      "endCol": "91"
    },
    "220": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.ts",
      "startLine": "22",
      "startCol": "22",
      "endLine": "22",
      "endCol": "62"
    },
    "221": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.ts",
      "startLine": "45",
      "startCol": "43",
      "endLine": "49",
      "endCol": "4"
    },
    "222": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/main.ts",
      "startLine": "73",
      "startCol": "31",
      "endLine": "73",
      "endCol": "58"
    },
    "223": {
      "patternID": "pattern3",
      "file": "npm/create-cypress-tests/src/utils.ts",
      "startLine": "53",
      "startCol": "5",
      "endLine": "53",
      "endCol": "33"
    },
    "224": {
      "patternID": "pattern3",
      "file": "npm/cypress-schematic/sandbox/e2e/src/app.e2e-spec.ts",
      "startLine": "18",
      "startCol": "18",
      "endLine": "18",
      "endCol": "72"
    },
    "225": {
      "patternID": "pattern3",
      "file": "npm/cypress-schematic/sandbox/src/app/app.component.spec.ts",
      "startLine": "7",
      "startCol": "5",
      "endLine": "14",
      "endCol": "26"
    },
    "226": {
      "patternID": "pattern3",
      "file": "npm/cypress-schematic/src/schematics/cypress/index_spec.ts",
      "startLine": "29",
      "startCol": "15",
      "endLine": "29",
      "endCol": "127"
    },
    "227": {
      "patternID": "pattern3",
      "file": "npm/cypress-schematic/src/schematics/cypress/index_spec.ts",
      "startLine": "30",
      "startCol": "15",
      "endLine": "30",
      "endCol": "132"
    },
    "228": {
      "patternID": "pattern3",
      "file": "npm/eslint-plugin-dev/lib/scripts/lint.spec.js",
      "startLine": "61",
      "startCol": "5",
      "endLine": "61",
      "endCol": "28"
    },
    "229": {
      "patternID": "pattern3",
      "file": "npm/eslint-plugin-dev/lib/scripts/lint.spec.js",
      "startLine": "68",
      "startCol": "5",
      "endLine": "68",
      "endCol": "28"
    },
    "230": {
      "patternID": "pattern3",
      "file": "npm/eslint-plugin-dev/lib/scripts/lint.spec.js",
      "startLine": "83",
      "startCol": "5",
      "endLine": "83",
      "endCol": "29"
    },
    "231": {
      "patternID": "pattern3",
      "file": "npm/eslint-plugin-dev/lib/scripts/lint.spec.js",
      "startLine": "92",
      "startCol": "5",
      "endLine": "92",
      "endCol": "29"
    },
    "232": {
      "patternID": "pattern3",
      "file": "npm/eslint-plugin-dev/lib/scripts/lint.spec.js",
      "startLine": "102",
      "startCol": "5",
      "endLine": "102",
      "endCol": "29"
    },
    "233": {
      "patternID": "pattern3",
      "file": "npm/eslint-plugin-dev/lib/scripts/lint.spec.js",
      "startLine": "113",
      "startCol": "5",
      "endLine": "113",
      "endCol": "29"
    },
    "234": {
      "patternID": "pattern3",
      "file": "npm/eslint-plugin-dev/lib/scripts/lint.spec.js",
      "startLine": "120",
      "startCol": "5",
      "endLine": "120",
      "endCol": "29"
    },
    "235": {
      "patternID": "pattern3",
      "file": "npm/eslint-plugin-dev/lib/scripts/lint.spec.js",
      "startLine": "133",
      "startCol": "5",
      "endLine": "133",
      "endCol": "31"
    },
    "236": {
      "patternID": "pattern3",
      "file": "npm/eslint-plugin-dev/lib/scripts/lint.spec.js",
      "startLine": "142",
      "startCol": "5",
      "endLine": "142",
      "endCol": "31"
    },
    "237": {
      "patternID": "pattern3",
      "file": "npm/react/plugins/next/findNextWebpackConfig.js",
      "startLine": "8",
      "startCol": "22",
      "endLine": "8",
      "endCol": "72"
    },
    "238": {
      "patternID": "pattern3",
      "file": "npm/react/plugins/next/findNextWebpackConfig.js",
      "startLine": "9",
      "startCol": "29",
      "endLine": "20",
      "endCol": "3"
    },
    "239": {
      "patternID": "pattern3",
      "file": "npm/vite-dev-server/src/index.ts",
      "startLine": "16",
      "startCol": "15",
      "endLine": "16",
      "endCol": "42"
    },
    "240": {
      "patternID": "pattern3",
      "file": "npm/vite-dev-server/src/makeCypressPlugin.ts",
      "startLine": "69",
      "startCol": "25",
      "endLine": "69",
      "endCol": "96"
    },
    "241": {
      "patternID": "pattern3",
      "file": "npm/vite-dev-server/src/makeCypressPlugin.ts",
      "startLine": "71",
      "startCol": "36",
      "endLine": "71",
      "endCol": "83"
    },
    "242": {
      "patternID": "pattern3",
      "file": "npm/vite-dev-server/src/startServer.ts",
      "startLine": "57",
      "startCol": "29",
      "endLine": "57",
      "endCol": "103"
    },
    "243": {
      "patternID": "pattern3",
      "file": "npm/vue/examples/nuxt/cypress/plugins/index.js",
      "startLine": "12",
      "startCol": "25",
      "endLine": "12",
      "endCol": "63"
    },
    "244": {
      "patternID": "pattern3",
      "file": "npm/webpack-batteries-included-preprocessor/test/e2e/features.spec.js",
      "startLine": "21",
      "startCol": "22",
      "endLine": "21",
      "endCol": "49"
    },
    "245": {
      "patternID": "pattern3",
      "file": "npm/webpack-batteries-included-preprocessor/test/e2e/features.spec.js",
      "startLine": "22",
      "startCol": "20",
      "endLine": "22",
      "endCol": "48"
    },
    "246": {
      "patternID": "pattern3",
      "file": "npm/webpack-batteries-included-preprocessor/test/e2e/features.spec.js",
      "startLine": "31",
      "startCol": "5",
      "endLine": "31",
      "endCol": "30"
    },
    "247": {
      "patternID": "pattern3",
      "file": "npm/webpack-batteries-included-preprocessor/test/e2e/features.spec.js",
      "startLine": "32",
      "startCol": "5",
      "endLine": "32",
      "endCol": "41"
    },
    "248": {
      "patternID": "pattern3",
      "file": "npm/webpack-batteries-included-preprocessor/test/e2e/features.spec.js",
      "startLine": "68",
      "startCol": "24",
      "endLine": "68",
      "endCol": "55"
    },
    "249": {
      "patternID": "pattern3",
      "file": "npm/webpack-batteries-included-preprocessor/test/e2e/features.spec.js",
      "startLine": "69",
      "startCol": "22",
      "endLine": "69",
      "endCol": "50"
    },
    "250": {
      "patternID": "pattern3",
      "file": "npm/webpack-batteries-included-preprocessor/test/fixtures/es_features_spec.js",
      "startLine": "25",
      "startCol": "17",
      "endLine": "25",
      "endCol": "31"
    },
    "251": {
      "patternID": "pattern3",
      "file": "npm/webpack-dev-server/test/e2e.spec.ts",
      "startLine": "61",
      "startCol": "29",
      "endLine": "68",
      "endCol": "6"
    },
    "252": {
      "patternID": "pattern3",
      "file": "npm/webpack-dev-server/test/e2e.spec.ts",
      "startLine": "81",
      "startCol": "23",
      "endLine": "88",
      "endCol": "6"
    },
    "253": {
      "patternID": "pattern3",
      "file": "npm/webpack-dev-server/test/e2e.spec.ts",
      "startLine": "102",
      "startCol": "23",
      "endLine": "115",
      "endCol": "22"
    },
    "254": {
      "patternID": "pattern3",
      "file": "npm/webpack-dev-server/test/e2e.spec.ts",
      "startLine": "129",
      "startCol": "23",
      "endLine": "136",
      "endCol": "6"
    },
    "255": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/compilation.spec.js",
      "startLine": "36",
      "startCol": "5",
      "endLine": "36",
      "endCol": "30"
    },
    "256": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/compilation.spec.js",
      "startLine": "37",
      "startCol": "5",
      "endLine": "37",
      "endCol": "41"
    },
    "257": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/compilation.spec.js",
      "startLine": "92",
      "startCol": "5",
      "endLine": "92",
      "endCol": "30"
    },
    "258": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/compilation.spec.js",
      "startLine": "93",
      "startCol": "5",
      "endLine": "93",
      "endCol": "43"
    },
    "259": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/compilation.spec.js",
      "startLine": "109",
      "startCol": "5",
      "endLine": "109",
      "endCol": "30"
    },
    "260": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/compilation.spec.js",
      "startLine": "113",
      "startCol": "5",
      "endLine": "113",
      "endCol": "43"
    },
    "261": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/compilation.spec.js",
      "startLine": "115",
      "startCol": "5",
      "endLine": "115",
      "endCol": "56"
    },
    "262": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/compilation.spec.js",
      "startLine": "122",
      "startCol": "5",
      "endLine": "122",
      "endCol": "30"
    },
    "263": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/compilation.spec.js",
      "startLine": "126",
      "startCol": "5",
      "endLine": "126",
      "endCol": "55"
    },
    "264": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/compilation.spec.js",
      "startLine": "128",
      "startCol": "5",
      "endLine": "128",
      "endCol": "56"
    },
    "265": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/helpers.js",
      "startLine": "47",
      "startCol": "22",
      "endLine": "47",
      "endCol": "52"
    },
    "266": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/helpers.js",
      "startLine": "147",
      "startCol": "23",
      "endLine": "176",
      "endCol": "4"
    },
    "267": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/helpers.js",
      "startLine": "195",
      "startCol": "7",
      "endLine": "195",
      "endCol": "34"
    },
    "268": {
      "patternID": "pattern3",
      "file": "npm/webpack-preprocessor/test/e2e/helpers.js",
      "startLine": "197",
      "startCol": "23",
      "endLine": "197",
      "endCol": "48"
    },
    "269": {
      "patternID": "pattern3",
      "file": "packages/driver/cypress/integration/commands/misc_spec.js",
      "startLine": "82",
      "startCol": "18",
      "endLine": "82",
      "endCol": "47"
    },
    "270": {
      "patternID": "pattern1",
      "file": "packages/driver/cypress/integration/commands/misc_spec.js",
      "startLine": "78",
      "startCol": "33",
      "endLine": "83",
      "endCol": "9"
    },
    "271": {
      "patternID": "pattern3",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1196",
      "startCol": "9",
      "endLine": "1196",
      "endCol": "38"
    },
    "272": {
      "patternID": "pattern3",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1197",
      "startCol": "16",
      "endLine": "1197",
      "endCol": "38"
    },
    "273": {
      "patternID": "pattern3",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1201",
      "startCol": "9",
      "endLine": "1201",
      "endCol": "43"
    },
    "274": {
      "patternID": "pattern3",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1202",
      "startCol": "16",
      "endLine": "1202",
      "endCol": "38"
    },
    "275": {
      "patternID": "pattern3",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1763",
      "startCol": "13",
      "endLine": "1770",
      "endCol": "25"
    },
    "276": {
      "patternID": "pattern3",
      "file": "packages/driver/cypress/integration/commands/net_stubbing_spec.ts",
      "startLine": "1775",
      "startCol": "13",
      "endLine": "1779",
      "endCol": "14"
    },
    "277": {
      "patternID": "pattern3",
      "file": "packages/driver/cypress/integration/cypress/script_utils_spec.js",
      "startLine": "56",
      "startCol": "22",
      "endLine": "56",
      "endCol": "73"
    },
    "278": {
      "patternID": "pattern3",
      "file": "packages/driver/src/cy/net-stubbing/events/after-response.ts",
      "startLine": "23",
      "startCol": "18",
      "endLine": "23",
      "endCol": "53"
    },
    "279": {
      "patternID": "pattern3",
      "file": "packages/driver/src/cy/net-stubbing/events/index.ts",
      "startLine": "121",
      "startCol": "22",
      "endLine": "126",
      "endCol": "8"
    },
    "280": {
      "patternID": "pattern3",
      "file": "packages/driver/src/cy/net-stubbing/events/network-error.ts",
      "startLine": "34",
      "startCol": "18",
      "endLine": "34",
      "endCol": "39"
    },
    "281": {
      "patternID": "pattern3",
      "file": "packages/launcher/test/unit/darwin_spec.ts",
      "startLine": "49",
      "startCol": "23",
      "endLine": "56",
      "endCol": "6"
    },
    "282": {
      "patternID": "pattern3",
      "file": "packages/launcher/test/unit/detect_spec.ts",
      "startLine": "140",
      "startCol": "14",
      "endLine": "140",
      "endCol": "48"
    },
    "283": {
      "patternID": "pattern3",
      "file": "packages/launcher/test/unit/detect_spec.ts",
      "startLine": "141",
      "startCol": "14",
      "endLine": "141",
      "endCol": "47"
    },
    "284": {
      "patternID": "pattern3",
      "file": "packages/launcher/test/unit/linux_spec.ts",
      "startLine": "103",
      "startCol": "13",
      "endLine": "103",
      "endCol": "39"
    },
    "285": {
      "patternID": "pattern3",
      "file": "packages/launcher/test/unit/linux_spec.ts",
      "startLine": "167",
      "startCol": "14",
      "endLine": "167",
      "endCol": "54"
    },
    "286": {
      "patternID": "pattern3",
      "file": "packages/launcher/test/unit/linux_spec.ts",
      "startLine": "175",
      "startCol": "7",
      "endLine": "175",
      "endCol": "79"
    },
    "287": {
      "patternID": "pattern3",
      "file": "packages/launcher/test/unit/windows_spec.ts",
      "startLine": "72",
      "startCol": "14",
      "endLine": "72",
      "endCol": "35"
    },
    "288": {
      "patternID": "pattern3",
      "file": "packages/launcher/test/unit/windows_spec.ts",
      "startLine": "98",
      "startCol": "14",
      "endLine": "98",
      "endCol": "36"
    },
    "289": {
      "patternID": "pattern3",
      "file": "packages/launcher/test/unit/windows_spec.ts",
      "startLine": "151",
      "startCol": "14",
      "endLine": "151",
      "endCol": "56"
    },
    "290": {
      "patternID": "pattern3",
      "file": "packages/launcher/test/unit/windows_spec.ts",
      "startLine": "161",
      "startCol": "7",
      "endLine": "161",
      "endCol": "81"
    },
    "291": {
      "patternID": "pattern3",
      "file": "packages/net-stubbing/lib/server/middleware/error.ts",
      "startLine": "22",
      "startCol": "3",
      "endLine": "28",
      "endCol": "4"
    },
    "292": {
      "patternID": "pattern3",
      "file": "packages/net-stubbing/lib/server/middleware/response.ts",
      "startLine": "47",
      "startCol": "33",
      "endLine": "56",
      "endCol": "4"
    },
    "293": {
      "patternID": "pattern3",
      "file": "packages/net-stubbing/lib/server/middleware/response.ts",
      "startLine": "73",
      "startCol": "23",
      "endLine": "77",
      "endCol": "4"
    },
    "294": {
      "patternID": "pattern3",
      "file": "packages/net-stubbing/lib/server/util.ts",
      "startLine": "140",
      "startCol": "16",
      "endLine": "140",
      "endCol": "91"
    },
    "295": {
      "patternID": "pattern3",
      "file": "packages/proxy/lib/http/util/rewriter.ts",
      "startLine": "45",
      "startCol": "24",
      "endLine": "45",
      "endCol": "67"
    },
    "296": {
      "patternID": "pattern3",
      "file": "packages/proxy/lib/http/util/rewriter.ts",
      "startLine": "50",
      "startCol": "12",
      "endLine": "50",
      "endCol": "91"
    },
    "297": {
      "patternID": "pattern3",
      "file": "packages/proxy/test/integration/net-stubbing.spec.ts",
      "startLine": "221",
      "startCol": "5",
      "endLine": "223",
      "endCol": "24"
    },
    "298": {
      "patternID": "pattern3",
      "file": "packages/proxy/test/integration/net-stubbing.spec.ts",
      "startLine": "254",
      "startCol": "5",
      "endLine": "256",
      "endCol": "24"
    },
    "299": {
      "patternID": "pattern3",
      "file": "packages/rewriter/lib/deferred-source-map-cache.ts",
      "startLine": "94",
      "startCol": "24",
      "endLine": "94",
      "endCol": "55"
    },
    "300": {
      "patternID": "pattern3",
      "file": "packages/rewriter/lib/threads/index.ts",
      "startLine": "169",
      "startCol": "16",
      "endLine": "206",
      "endCol": "4"
    },
    "301": {
      "patternID": "pattern3",
      "file": "packages/rewriter/test/unit/deferred-source-map-cache-spec.ts",
      "startLine": "62",
      "startCol": "7",
      "endLine": "62",
      "endCol": "98"
    },
    "302": {
      "patternID": "pattern3",
      "file": "packages/rewriter/test/unit/deferred-source-map-cache-spec.ts",
      "startLine": "71",
      "startCol": "7",
      "endLine": "71",
      "endCol": "78"
    },
    "303": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "279",
      "startCol": "3",
      "endLine": "281",
      "endCol": "4"
    },
    "304": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "297",
      "startCol": "3",
      "endLine": "297",
      "endCol": "40"
    },
    "305": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "298",
      "startCol": "3",
      "endLine": "298",
      "endCol": "45"
    },
    "306": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "302",
      "startCol": "3",
      "endLine": "302",
      "endCol": "34"
    },
    "307": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "330",
      "startCol": "3",
      "endLine": "333",
      "endCol": "4"
    },
    "308": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "377",
      "startCol": "17",
      "endLine": "377",
      "endCol": "87"
    },
    "309": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "382",
      "startCol": "5",
      "endLine": "382",
      "endCol": "61"
    },
    "310": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "383",
      "startCol": "5",
      "endLine": "383",
      "endCol": "45"
    },
    "311": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "450",
      "startCol": "33",
      "endLine": "453",
      "endCol": "6"
    },
    "312": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "462",
      "startCol": "39",
      "endLine": "467",
      "endCol": "6"
    },
    "313": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "473",
      "startCol": "23",
      "endLine": "481",
      "endCol": "6"
    },
    "314": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "497",
      "startCol": "29",
      "endLine": "497",
      "endCol": "70"
    },
    "315": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "504",
      "startCol": "23",
      "endLine": "504",
      "endCol": "87"
    },
    "316": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "508",
      "startCol": "5",
      "endLine": "514",
      "endCol": "6"
    },
    "317": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/chrome.ts",
      "startLine": "525",
      "startCol": "7",
      "endLine": "525",
      "endCol": "29"
    },
    "318": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/electron.js",
      "startLine": "57",
      "startCol": "7",
      "endLine": "57",
      "endCol": "47"
    },
    "319": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/electron.js",
      "startLine": "59",
      "startCol": "19",
      "endLine": "59",
      "endCol": "41"
    },
    "320": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/electron.js",
      "startLine": "61",
      "startCol": "7",
      "endLine": "61",
      "endCol": "46"
    },
    "321": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/electron.js",
      "startLine": "99",
      "startCol": "5",
      "endLine": "101",
      "endCol": "6"
    },
    "322": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/electron.js",
      "startLine": "412",
      "startCol": "9",
      "endLine": "412",
      "endCol": "72"
    },
    "323": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox-util.ts",
      "startLine": "173",
      "startCol": "5",
      "endLine": "177",
      "endCol": "6"
    },
    "324": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox-util.ts",
      "startLine": "179",
      "startCol": "23",
      "endLine": "179",
      "endCol": "63"
    },
    "325": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox-util.ts",
      "startLine": "238",
      "startCol": "5",
      "endLine": "242",
      "endCol": "6"
    },
    "326": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox-util.ts",
      "startLine": "268",
      "startCol": "5",
      "endLine": "269",
      "endCol": "33"
    },
    "327": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox-util.ts",
      "startLine": "271",
      "startCol": "5",
      "endLine": "300",
      "endCol": "6"
    },
    "328": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox.ts",
      "startLine": "411",
      "startCol": "7",
      "endLine": "411",
      "endCol": "48"
    },
    "329": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox.ts",
      "startLine": "422",
      "startCol": "7",
      "endLine": "426",
      "endCol": "4"
    },
    "330": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox.ts",
      "startLine": "445",
      "startCol": "8",
      "endLine": "445",
      "endCol": "40"
    },
    "331": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox.ts",
      "startLine": "451",
      "startCol": "5",
      "endLine": "451",
      "endCol": "146"
    },
    "332": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox.ts",
      "startLine": "466",
      "startCol": "8",
      "endLine": "466",
      "endCol": "68"
    },
    "333": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox.ts",
      "startLine": "468",
      "startCol": "7",
      "endLine": "468",
      "endCol": "33"
    },
    "334": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox.ts",
      "startLine": "484",
      "startCol": "5",
      "endLine": "484",
      "endCol": "82"
    },
    "335": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox.ts",
      "startLine": "494",
      "startCol": "27",
      "endLine": "499",
      "endCol": "4"
    },
    "336": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/firefox.ts",
      "startLine": "501",
      "startCol": "3",
      "endLine": "504",
      "endCol": "4"
    },
    "337": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/utils.ts",
      "startLine": "89",
      "startCol": "3",
      "endLine": "89",
      "endCol": "25"
    },
    "338": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/utils.ts",
      "startLine": "90",
      "startCol": "3",
      "endLine": "90",
      "endCol": "28"
    },
    "339": {
      "patternID": "pattern3",
      "file": "packages/server/lib/browsers/utils.ts",
      "startLine": "121",
      "startCol": "32",
      "endLine": "121",
      "endCol": "101"
    },
    "340": {
      "patternID": "pattern3",
      "file": "packages/server/lib/modes/info.js",
      "startLine": "61",
      "startCol": "29",
      "endLine": "61",
      "endCol": "59"
    },
    "341": {
      "patternID": "pattern3",
      "file": "packages/server/lib/modes/interactive-ct.js",
      "startLine": "21",
      "startCol": "29",
      "endLine": "21",
      "endCol": "47"
    },
    "342": {
      "patternID": "pattern3",
      "file": "packages/server/lib/modes/interactive-e2e.js",
      "startLine": "114",
      "startCol": "5",
      "endLine": "114",
      "endCol": "25"
    },
    "343": {
      "patternID": "pattern3",
      "file": "packages/server/lib/modes/record.js",
      "startLine": "777",
      "startCol": "26",
      "endLine": "791",
      "endCol": "10"
    },
    "344": {
      "patternID": "pattern3",
      "file": "packages/server/lib/modes/run.js",
      "startLine": "1201",
      "startCol": "9",
      "endLine": "1203",
      "endCol": "40"
    },
    "345": {
      "patternID": "pattern3",
      "file": "packages/server/lib/modes/run.js",
      "startLine": "1206",
      "startCol": "7",
      "endLine": "1206",
      "endCol": "66"
    },
    "346": {
      "patternID": "pattern3",
      "file": "packages/server/lib/modes/run.js",
      "startLine": "1208",
      "startCol": "39",
      "endLine": "1208",
      "endCol": "68"
    },
    "347": {
      "patternID": "pattern3",
      "file": "packages/server/lib/modes/run.js",
      "startLine": "1237",
      "startCol": "9",
      "endLine": "1237",
      "endCol": "40"
    },
    "348": {
      "patternID": "pattern3",
      "file": "packages/server/lib/modes/run.js",
      "startLine": "1243",
      "startCol": "9",
      "endLine": "1251",
      "endCol": "40"
    },
    "349": {
      "patternID": "pattern3",
      "file": "packages/server/lib/modes/run.js",
      "startLine": "1662",
      "startCol": "5",
      "endLine": "1662",
      "endCol": "25"
    },
    "350": {
      "patternID": "pattern3",
      "file": "packages/server/lib/project-base.ts",
      "startLine": "389",
      "startCol": "11",
      "endLine": "389",
      "endCol": "48"
    },
    "351": {
      "patternID": "pattern3",
      "file": "packages/server/lib/updater.js",
      "startLine": "31",
      "startCol": "16",
      "endLine": "31",
      "endCol": "32"
    },
    "352": {
      "patternID": "pattern3",
      "file": "packages/server/lib/updater.js",
      "startLine": "32",
      "startCol": "22",
      "endLine": "36",
      "endCol": "6"
    },
    "353": {
      "patternID": "pattern3",
      "file": "packages/server/lib/video_capture.js",
      "startLine": "268",
      "startCol": "29",
      "endLine": "268",
      "endCol": "57"
    },
    "354": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/0_max_listeners_spec.ts",
      "startLine": "25",
      "startCol": "7",
      "endLine": "25",
      "endCol": "38"
    },
    "355": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/0_max_listeners_spec.ts",
      "startLine": "26",
      "startCol": "7",
      "endLine": "28",
      "endCol": "7"
    },
    "356": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/0_max_listeners_spec.ts",
      "startLine": "30",
      "startCol": "26",
      "endLine": "30",
      "endCol": "37"
    },
    "357": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/1_firefox_spec.ts",
      "startLine": "60",
      "startCol": "26",
      "endLine": "65",
      "endCol": "8"
    },
    "358": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/3_testConfigOverrides_spec.ts",
      "startLine": "26",
      "startCol": "7",
      "endLine": "26",
      "endCol": "18"
    },
    "359": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/3_testConfigOverrides_spec.ts",
      "startLine": "27",
      "startCol": "23",
      "endLine": "27",
      "endCol": "51"
    },
    "360": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/4_downloads_spec.ts",
      "startLine": "32",
      "startCol": "7",
      "endLine": "32",
      "endCol": "18"
    },
    "361": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/4_downloads_spec.ts",
      "startLine": "34",
      "startCol": "14",
      "endLine": "34",
      "endCol": "44"
    },
    "362": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/4_downloads_spec.ts",
      "startLine": "35",
      "startCol": "14",
      "endLine": "35",
      "endCol": "42"
    },
    "363": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/4_downloads_spec.ts",
      "startLine": "36",
      "startCol": "14",
      "endLine": "36",
      "endCol": "44"
    },
    "364": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/4_downloads_spec.ts",
      "startLine": "41",
      "startCol": "5",
      "endLine": "44",
      "endCol": "6"
    },
    "365": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/4_downloads_spec.ts",
      "startLine": "47",
      "startCol": "5",
      "endLine": "50",
      "endCol": "6"
    },
    "366": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/4_downloads_spec.ts",
      "startLine": "53",
      "startCol": "20",
      "endLine": "53",
      "endCol": "48"
    },
    "367": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/4_downloads_spec.ts",
      "startLine": "59",
      "startCol": "5",
      "endLine": "62",
      "endCol": "6"
    },
    "368": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/4_downloads_spec.ts",
      "startLine": "65",
      "startCol": "5",
      "endLine": "71",
      "endCol": "6"
    },
    "369": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/4_downloads_spec.ts",
      "startLine": "74",
      "startCol": "20",
      "endLine": "74",
      "endCol": "48"
    },
    "370": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/4_form_submissions_spec.js",
      "startLine": "39",
      "startCol": "24",
      "endLine": "39",
      "endCol": "58"
    },
    "371": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/5_spec_isolation_spec.js",
      "startLine": "34",
      "startCol": "26",
      "endLine": "34",
      "endCol": "39"
    },
    "372": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/5_spec_isolation_spec.js",
      "startLine": "42",
      "startCol": "18",
      "endLine": "42",
      "endCol": "51"
    },
    "373": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/5_spec_isolation_spec.js",
      "startLine": "65",
      "startCol": "7",
      "endLine": "65",
      "endCol": "20"
    },
    "374": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/5_spec_isolation_spec.js",
      "startLine": "66",
      "startCol": "18",
      "endLine": "66",
      "endCol": "51"
    },
    "375": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/6_video_compression_spec.js",
      "startLine": "66",
      "startCol": "13",
      "endLine": "68",
      "endCol": "14"
    },
    "376": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/7_record_spec.js",
      "startLine": "37",
      "startCol": "26",
      "endLine": "44",
      "endCol": "8"
    },
    "377": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/7_record_spec.js",
      "startLine": "221",
      "startCol": "23",
      "endLine": "221",
      "endCol": "56"
    },
    "378": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/7_record_spec.js",
      "startLine": "436",
      "startCol": "7",
      "endLine": "442",
      "endCol": "8"
    },
    "379": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/7_record_spec.js",
      "startLine": "551",
      "startCol": "7",
      "endLine": "557",
      "endCol": "8"
    },
    "380": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/7_record_spec.js",
      "startLine": "606",
      "startCol": "9",
      "endLine": "611",
      "endCol": "10"
    },
    "381": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/7_record_spec.js",
      "startLine": "646",
      "startCol": "7",
      "endLine": "652",
      "endCol": "8"
    },
    "382": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/7_record_spec.js",
      "startLine": "673",
      "startCol": "7",
      "endLine": "682",
      "endCol": "8"
    },
    "383": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/7_record_spec.js",
      "startLine": "870",
      "startCol": "9",
      "endLine": "884",
      "endCol": "10"
    },
    "384": {
      "patternID": "pattern3",
      "file": "packages/server/test/e2e/7_record_spec.js",
      "startLine": "1216",
      "startCol": "9",
      "endLine": "1234",
      "endCol": "10"
    },
    "385": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/cypress_spec.js",
      "startLine": "174",
      "startCol": "7",
      "endLine": "174",
      "endCol": "31"
    },
    "386": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "142",
      "startCol": "15",
      "endLine": "142",
      "endCol": "75"
    },
    "387": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2479",
      "startCol": "27",
      "endLine": "2479",
      "endCol": "61"
    },
    "388": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2481",
      "startCol": "21",
      "endLine": "2486",
      "endCol": "10"
    },
    "389": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2500",
      "startCol": "27",
      "endLine": "2500",
      "endCol": "61"
    },
    "390": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2503",
      "startCol": "21",
      "endLine": "2508",
      "endCol": "10"
    },
    "391": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2762",
      "startCol": "9",
      "endLine": "2762",
      "endCol": "50"
    },
    "392": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2764",
      "startCol": "27",
      "endLine": "2764",
      "endCol": "61"
    },
    "393": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2766",
      "startCol": "21",
      "endLine": "2771",
      "endCol": "10"
    },
    "394": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2829",
      "startCol": "9",
      "endLine": "2829",
      "endCol": "55"
    },
    "395": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2832",
      "startCol": "27",
      "endLine": "2832",
      "endCol": "61"
    },
    "396": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2834",
      "startCol": "21",
      "endLine": "2839",
      "endCol": "10"
    },
    "397": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2847",
      "startCol": "9",
      "endLine": "2847",
      "endCol": "55"
    },
    "398": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2850",
      "startCol": "27",
      "endLine": "2850",
      "endCol": "61"
    },
    "399": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/http_requests_spec.js",
      "startLine": "2852",
      "startCol": "21",
      "endLine": "2857",
      "endCol": "10"
    },
    "400": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/server_spec.js",
      "startLine": "90",
      "startCol": "15",
      "endLine": "90",
      "endCol": "75"
    },
    "401": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/server_spec.js",
      "startLine": "481",
      "startCol": "21",
      "endLine": "481",
      "endCol": "103"
    },
    "402": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/server_spec.js",
      "startLine": "486",
      "startCol": "27",
      "endLine": "486",
      "endCol": "114"
    },
    "403": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/video_capture_spec.ts",
      "startLine": "8",
      "startCol": "17",
      "endLine": "8",
      "endCol": "50"
    },
    "404": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/video_capture_spec.ts",
      "startLine": "48",
      "startCol": "7",
      "endLine": "48",
      "endCol": "69"
    },
    "405": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/video_capture_spec.ts",
      "startLine": "62",
      "startCol": "7",
      "endLine": "62",
      "endCol": "69"
    },
    "406": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/video_capture_spec.ts",
      "startLine": "70",
      "startCol": "7",
      "endLine": "70",
      "endCol": "77"
    },
    "407": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/video_capture_spec.ts",
      "startLine": "83",
      "startCol": "7",
      "endLine": "83",
      "endCol": "73"
    },
    "408": {
      "patternID": "pattern3",
      "file": "packages/server/test/integration/websockets_spec.js",
      "startLine": "41",
      "startCol": "9",
      "endLine": "41",
      "endCol": "69"
    },
    "409": {
      "patternID": "pattern3",
      "file": "packages/server/test/support/fixtures/projects/ids/cypress/integration/es6.js",
      "startLine": "5",
      "startCol": "3",
      "endLine": "5",
      "endCol": "30"
    },
    "410": {
      "patternID": "pattern3",
      "file": "packages/server/test/support/helpers/e2e.ts",
      "startLine": "426",
      "startCol": "25",
      "endLine": "426",
      "endCol": "68"
    },
    "411": {
      "patternID": "pattern3",
      "file": "packages/server/test/support/helpers/e2e.ts",
      "startLine": "436",
      "startCol": "9",
      "endLine": "436",
      "endCol": "40"
    },
    "412": {
      "patternID": "pattern3",
      "file": "packages/server/test/support/helpers/e2e.ts",
      "startLine": "450",
      "startCol": "9",
      "endLine": "450",
      "endCol": "41"
    },
    "413": {
      "patternID": "pattern3",
      "file": "packages/server/test/support/helpers/fixtures.js",
      "startLine": "55",
      "startCol": "5",
      "endLine": "55",
      "endCol": "89"
    },
    "414": {
      "patternID": "pattern3",
      "file": "packages/server/test/support/helpers/fixtures.js",
      "startLine": "56",
      "startCol": "5",
      "endLine": "56",
      "endCol": "30"
    },
    "415": {
      "patternID": "pattern3",
      "file": "packages/server/test/support/helpers/fixtures.js",
      "startLine": "57",
      "startCol": "5",
      "endLine": "57",
      "endCol": "61"
    },
    "416": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/cri-client_spec.ts",
      "startLine": "44",
      "startCol": "22",
      "endLine": "44",
      "endCol": "38"
    },
    "417": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/cri-client_spec.ts",
      "startLine": "52",
      "startCol": "24",
      "endLine": "52",
      "endCol": "40"
    },
    "418": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/cri-client_spec.ts",
      "startLine": "62",
      "startCol": "24",
      "endLine": "62",
      "endCol": "40"
    },
    "419": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/cri-client_spec.ts",
      "startLine": "64",
      "startCol": "9",
      "endLine": "65",
      "endCol": "32"
    },
    "420": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/cri-client_spec.ts",
      "startLine": "80",
      "startCol": "28",
      "endLine": "80",
      "endCol": "44"
    },
    "421": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/cri-client_spec.ts",
      "startLine": "82",
      "startCol": "13",
      "endLine": "82",
      "endCol": "68"
    },
    "422": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/firefox_spec.ts",
      "startLine": "327",
      "startCol": "7",
      "endLine": "331",
      "endCol": "8"
    },
    "423": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/firefox_spec.ts",
      "startLine": "379",
      "startCol": "9",
      "endLine": "380",
      "endCol": "107"
    },
    "424": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/firefox_spec.ts",
      "startLine": "388",
      "startCol": "9",
      "endLine": "389",
      "endCol": "109"
    },
    "425": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/firefox_spec.ts",
      "startLine": "395",
      "startCol": "9",
      "endLine": "396",
      "endCol": "117"
    },
    "426": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/firefox_spec.ts",
      "startLine": "420",
      "startCol": "9",
      "endLine": "420",
      "endCol": "42"
    },
    "427": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/firefox_spec.ts",
      "startLine": "425",
      "startCol": "9",
      "endLine": "425",
      "endCol": "42"
    },
    "428": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/protocol_spec.ts",
      "startLine": "111",
      "startCol": "7",
      "endLine": "111",
      "endCol": "48"
    },
    "429": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/protocol_spec.ts",
      "startLine": "142",
      "startCol": "25",
      "endLine": "142",
      "endCol": "59"
    },
    "430": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/browsers/protocol_spec.ts",
      "startLine": "172",
      "startCol": "25",
      "endLine": "172",
      "endCol": "59"
    },
    "431": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/config_spec.js",
      "startLine": "1267",
      "startCol": "7",
      "endLine": "1269",
      "endCol": "8"
    },
    "432": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/config_spec.js",
      "startLine": "1277",
      "startCol": "7",
      "endLine": "1279",
      "endCol": "8"
    },
    "433": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/config_spec.js",
      "startLine": "1287",
      "startCol": "7",
      "endLine": "1289",
      "endCol": "8"
    },
    "434": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/config_spec.js",
      "startLine": "1298",
      "startCol": "7",
      "endLine": "1300",
      "endCol": "8"
    },
    "435": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/modes/info_spec.js",
      "startLine": "44",
      "startCol": "5",
      "endLine": "44",
      "endCol": "16"
    },
    "436": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/modes/interactive-ct_spec.js",
      "startLine": "16",
      "startCol": "20",
      "endLine": "16",
      "endCol": "90"
    },
    "437": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/modes/interactive-ct_spec.js",
      "startLine": "23",
      "startCol": "20",
      "endLine": "23",
      "endCol": "90"
    },
    "438": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/modes/interactive-ct_spec.js",
      "startLine": "31",
      "startCol": "20",
      "endLine": "31",
      "endCol": "90"
    },
    "439": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/modes/record_spec.js",
      "startLine": "421",
      "startCol": "7",
      "endLine": "427",
      "endCol": "24"
    },
    "440": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/modes/record_spec.js",
      "startLine": "455",
      "startCol": "7",
      "endLine": "458",
      "endCol": "24"
    },
    "441": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/modes/run_spec.js",
      "startLine": "516",
      "startCol": "7",
      "endLine": "524",
      "endCol": "8"
    },
    "442": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/modes/run_spec.js",
      "startLine": "538",
      "startCol": "7",
      "endLine": "546",
      "endCol": "8"
    },
    "443": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/screenshots_spec.js",
      "startLine": "627",
      "startCol": "24",
      "endLine": "636",
      "endCol": "93"
    },
    "444": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/screenshots_spec.js",
      "startLine": "650",
      "startCol": "24",
      "endLine": "653",
      "endCol": "23"
    },
    "445": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/screenshots_spec.js",
      "startLine": "665",
      "startCol": "7",
      "endLine": "668",
      "endCol": "48"
    },
    "446": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/updater_spec.js",
      "startLine": "59",
      "startCol": "7",
      "endLine": "59",
      "endCol": "43"
    },
    "447": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/updater_spec.js",
      "startLine": "68",
      "startCol": "7",
      "endLine": "68",
      "endCol": "45"
    },
    "448": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/updater_spec.js",
      "startLine": "77",
      "startCol": "7",
      "endLine": "77",
      "endCol": "45"
    },
    "449": {
      "patternID": "pattern3",
      "file": "packages/server/test/unit/updater_spec.js",
      "startLine": "86",
      "startCol": "7",
      "endLine": "86",
      "endCol": "45"
    },
    "450": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/App.spec.js",
      "startLine": "34",
      "startCol": "5",
      "endLine": "34",
      "endCol": "32"
    },
    "451": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/App.spec.js",
      "startLine": "48",
      "startCol": "5",
      "endLine": "48",
      "endCol": "32"
    },
    "452": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/App.spec.js",
      "startLine": "55",
      "startCol": "5",
      "endLine": "55",
      "endCol": "32"
    },
    "453": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/App.spec.js",
      "startLine": "67",
      "startCol": "5",
      "endLine": "67",
      "endCol": "32"
    },
    "454": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/App.spec.js",
      "startLine": "70",
      "startCol": "5",
      "endLine": "70",
      "endCol": "32"
    },
    "455": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/App.spec.js",
      "startLine": "75",
      "startCol": "5",
      "endLine": "75",
      "endCol": "32"
    },
    "456": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/App.spec.js",
      "startLine": "85",
      "startCol": "5",
      "endLine": "85",
      "endCol": "32"
    },
    "457": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/App.spec.js",
      "startLine": "91",
      "startCol": "5",
      "endLine": "91",
      "endCol": "32"
    },
    "458": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/CrosswordBoard.spec.js",
      "startLine": "23",
      "startCol": "7",
      "endLine": "23",
      "endCol": "34"
    },
    "459": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/CrosswordBoard.spec.js",
      "startLine": "72",
      "startCol": "25",
      "endLine": "74",
      "endCol": "10"
    },
    "460": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/CrosswordBoard.spec.js",
      "startLine": "76",
      "startCol": "9",
      "endLine": "76",
      "endCol": "36"
    },
    "461": {
      "patternID": "pattern3",
      "file": "packages/server-ct/crossword-example/unit/CrosswordBoard.spec.js",
      "startLine": "88",
      "startCol": "9",
      "endLine": "88",
      "endCol": "36"
    },
    "462": {
      "patternID": "pattern3",
      "file": "packages/server-ct/src/specs-store.ts",
      "startLine": "63",
      "startCol": "26",
      "endLine": "63",
      "endCol": "50"
    },
    "463": {
      "patternID": "pattern3",
      "file": "scripts/after-pack-hook.js",
      "startLine": "15",
      "startCol": "20",
      "endLine": "18",
      "endCol": "4"
    },
    "464": {
      "patternID": "pattern3",
      "file": "scripts/after-pack-hook.js",
      "startLine": "36",
      "startCol": "5",
      "endLine": "36",
      "endCol": "50"
    },
    "465": {
      "patternID": "pattern3",
      "file": "scripts/after-sign-hook.js",
      "startLine": "40",
      "startCol": "5",
      "endLine": "45",
      "endCol": "6"
    },
    "466": {
      "patternID": "pattern3",
      "file": "scripts/binary/move-binaries.ts",
      "startLine": "101",
      "startCol": "5",
      "endLine": "104",
      "endCol": "6"
    },
    "467": {
      "patternID": "pattern3",
      "file": "scripts/binary/util/testStaticAssets.js",
      "startLine": "14",
      "startCol": "3",
      "endLine": "65",
      "endCol": "4"
    },
    "468": {
      "patternID": "pattern3",
      "file": "scripts/binary/util/testStaticAssets.js",
      "startLine": "78",
      "startCol": "23",
      "endLine": "114",
      "endCol": "4"
    },
    "469": {
      "patternID": "pattern3",
      "file": "scripts/binary/util/testStaticAssets.js",
      "startLine": "80",
      "startCol": "22",
      "endLine": "80",
      "endCol": "44"
    },
    "470": {
      "patternID": "pattern3",
      "file": "scripts/binary/util/transform-requires.js",
      "startLine": "51",
      "startCol": "3",
      "endLine": "72",
      "endCol": "4"
    },
    "471": {
      "patternID": "pattern3",
      "file": "scripts/binary/util/transform-requires.js",
      "startLine": "54",
      "startCol": "18",
      "endLine": "54",
      "endCol": "44"
    },
    "472": {
      "patternID": "pattern3",
      "file": "scripts/binary/util/transform-requires.js",
      "startLine": "70",
      "startCol": "7",
      "endLine": "70",
      "endCol": "43"
    },
    "473": {
      "patternID": "pattern1",
      "file": "scripts/circle-cache.js",
      "startLine": "13",
      "startCol": "1",
      "endLine": "22",
      "endCol": "1"
    },
    "474": {
      "patternID": "pattern3",
      "file": "scripts/circle-cache.js",
      "startLine": "35",
      "startCol": "22",
      "endLine": "37",
      "endCol": "4"
    },
    "475": {
      "patternID": "pattern3",
      "file": "scripts/circle-cache.js",
      "startLine": "39",
      "startCol": "24",
      "endLine": "44",
      "endCol": "4"
    },
    "476": {
      "patternID": "pattern3",
      "file": "scripts/circle-cache.js",
      "startLine": "56",
      "startCol": "23",
      "endLine": "56",
      "endCol": "76"
    },
    "477": {
      "patternID": "pattern3",
      "file": "scripts/circle-cache.js",
      "startLine": "67",
      "startCol": "17",
      "endLine": "70",
      "endCol": "3"
    },
    "478": {
      "patternID": "pattern3",
      "file": "scripts/circle-cache.js",
      "startLine": "72",
      "startCol": "3",
      "endLine": "81",
      "endCol": "3"
    },
    "479": {
      "patternID": "pattern3",
      "file": "scripts/circle-cache.js",
      "startLine": "74",
      "startCol": "7",
      "endLine": "79",
      "endCol": "7"
    },
    "480": {
      "patternID": "pattern3",
      "file": "scripts/circle-cache.js",
      "startLine": "87",
      "startCol": "17",
      "endLine": "90",
      "endCol": "3"
    },
    "481": {
      "patternID": "pattern3",
      "file": "scripts/circle-cache.js",
      "startLine": "92",
      "startCol": "3",
      "endLine": "101",
      "endCol": "3"
    },
    "482": {
      "patternID": "pattern3",
      "file": "scripts/circle-cache.js",
      "startLine": "94",
      "startCol": "7",
      "endLine": "99",
      "endCol": "7"
    },
    "483": {
      "patternID": "pattern3",
      "file": "scripts/circle-cache.js",
      "startLine": "105",
      "startCol": "3",
      "endLine": "105",
      "endCol": "33"
    },
    "484": {
      "patternID": "pattern3",
      "file": "scripts/get-next-version.js",
      "startLine": "19",
      "startCol": "27",
      "endLine": "19",
      "endCol": "65"
    },
    "485": {
      "patternID": "pattern3",
      "file": "scripts/github-actions/update-browser-versions.js",
      "startLine": "90",
      "startCol": "20",
      "endLine": "95",
      "endCol": "4"
    },
    "486": {
      "patternID": "pattern3",
      "file": "scripts/github-actions/update-browser-versions.js",
      "startLine": "104",
      "startCol": "3",
      "endLine": "109",
      "endCol": "4"
    },
    "487": {
      "patternID": "pattern3",
      "file": "scripts/github-actions/update-browser-versions.js",
      "startLine": "113",
      "startCol": "3",
      "endLine": "121",
      "endCol": "4"
    },
    "488": {
      "patternID": "pattern3",
      "file": "scripts/npm-release.js",
      "startLine": "25",
      "startCol": "22",
      "endLine": "25",
      "endCol": "86"
    },
    "489": {
      "patternID": "pattern3",
      "file": "scripts/npm-release.js",
      "startLine": "31",
      "startCol": "28",
      "endLine": "31",
      "endCol": "79"
    },
    "490": {
      "patternID": "pattern3",
      "file": "scripts/npm-release.js",
      "startLine": "53",
      "startCol": "22",
      "endLine": "53",
      "endCol": "137"
    },
    "491": {
      "patternID": "pattern3",
      "file": "scripts/npm-release.js",
      "startLine": "145",
      "startCol": "24",
      "endLine": "145",
      "endCol": "126"
    },
    "492": {
      "patternID": "pattern3",
      "file": "scripts/npm-release.js",
      "startLine": "155",
      "startCol": "22",
      "endLine": "155",
      "endCol": "66"
    },
    "493": {
      "patternID": "pattern3",
      "file": "scripts/run-ct-examples.js",
      "startLine": "26",
      "startCol": "7",
      "endLine": "26",
      "endCol": "82"
    },
    "494": {
      "patternID": "pattern3",
      "file": "scripts/run-ct-examples.js",
      "startLine": "30",
      "startCol": "5",
      "endLine": "36",
      "endCol": "29"
    },
    "495": {
      "patternID": "pattern3",
      "file": "scripts/test-unit.js",
      "startLine": "16",
      "startCol": "3",
      "endLine": "16",
      "endCol": "26"
    },
    "496": {
      "patternID": "pattern3",
      "file": "scripts/unit/binary/util/packages-spec.js",
      "startLine": "62",
      "startCol": "5",
      "endLine": "62",
      "endCol": "51"
    },
    "497": {
      "patternID": "pattern3",
      "file": "scripts/unit/binary/util/packages-spec.js",
      "startLine": "137",
      "startCol": "5",
      "endLine": "137",
      "endCol": "66"
    },
    "498": {
      "patternID": "pattern3",
      "file": "scripts/unit/binary/util/packages-spec.js",
      "startLine": "188",
      "startCol": "5",
      "endLine": "188",
      "endCol": "38"
    },
    "499": {
      "patternID": "pattern3",
      "file": "scripts/unit/binary/util/packages-spec.js",
      "startLine": "216",
      "startCol": "5",
      "endLine": "219",
      "endCol": "89"
    },
    "500": {
      "patternID": "pattern3",
      "file": "scripts/unit/binary/util/packages-spec.js",
      "startLine": "233",
      "startCol": "5",
      "endLine": "237",
      "endCol": "54"
    },
    "501": {
      "patternID": "pattern3",
      "file": "scripts/unit/binary/util/packages-spec.js",
      "startLine": "257",
      "startCol": "5",
      "endLine": "261",
      "endCol": "44"
    },
    "502": {
      "patternID": "pattern3",
      "file": "scripts/unit/binary/util/packages-spec.js",
      "startLine": "279",
      "startCol": "5",
      "endLine": "283",
      "endCol": "47"
    },
    "503": {
      "patternID": "pattern3",
      "file": "scripts/unit/binary/util/packages-spec.js",
      "startLine": "302",
      "startCol": "5",
      "endLine": "308",
      "endCol": "47"
    },
    "504": {
      "patternID": "pattern3",
      "file": "scripts/utils.js",
      "startLine": "121",
      "startCol": "22",
      "endLine": "121",
      "endCol": "78"
    },
    "505": {
      "patternID": "pattern3",
      "file": "scripts/wait-on-circle-jobs.js",
      "startLine": "36",
      "startCol": "20",
      "endLine": "36",
      "endCol": "40"
    },
    "506": {
      "patternID": "pattern3",
      "file": "scripts/wait-on-circle-jobs.js",
      "startLine": "65",
      "startCol": "20",
      "endLine": "65",
      "endCol": "40"
    },
    "507": {
      "patternID": "pattern3",
      "file": "scripts/wait-on-circle-jobs.js",
      "startLine": "158",
      "startCol": "3",
      "endLine": "158",
      "endCol": "34"
    }
  },
  "files": {
    "scripts/binary/move-binaries.ts": "import { s3helpers } from './s3-api'\nconst debug = require('debug')('cypress:binary')\nimport la from 'lazy-ass'\nimport is from 'check-more-types'\n// using \"arg\" module for parsing CLI arguments\n// because it plays really nicely with TypeScript\nimport arg from 'arg'\nimport { prop, sortBy, last, equals } from 'ramda'\nimport pluralize from 'pluralize'\n\n// inquirer-confirm is missing type definition\n// @ts-ignore\nimport confirm from 'inquirer-confirm'\n\n// ignore TS errors - we are importing from CoffeeScript files\n// @ts-ignore\nimport uploadUtils from './util/upload'\n\n// @ts-ignore\nimport { getUploadDirForPlatform } from './upload-unique-binary'\n// @ts-ignore\nimport { zipName, getFullUploadName } from './upload'\n\n/**\n * 40 character full sha commit string\n */\ntype commit = string\n/**\n * semver string, like \"3.3.0\"\n */\ntype semver = string\n\n/**\n * Platform plus architecture string like \"darwin-x64\"\n */\ntype platformArch = 'darwin-x64' | 'linux-x64'| 'win32-ia32' | 'win32-x64'\n\ninterface ReleaseInformation {\n  commit: commit\n  version: semver\n}\n\ninterface CommitAndBuild {\n  commit: commit\n  build: number\n  s3path: string\n}\n\ninterface Desktop {\n  s3zipPath: string\n  platformArch: platformArch\n}\n\n/**\n * Parses a binary S3 path like\n * \"beta/binary/3.3.0/darwin-x64/circle-develop-47e98fa1d0b18867a74da91a719d0f1ae73fcbc7-100/\"\n * and returns object with SHA string and build number\n */\nexport const parseBuildPath = (s3path: string): CommitAndBuild | null => {\n  const shaAndBuild = /([0-9a-f]{40})-(\\d+)\\/?$/i\n  const found = s3path.match(shaAndBuild)\n\n  if (!found) {\n    return null\n  }\n\n  const [, commit, build] = found\n\n  return {\n    commit,\n    build: parseInt(build),\n    s3path,\n  }\n}\n\nexport const findBuildByCommit = (commit: commit, s3paths: string[]) => {\n  const matching = s3paths.filter((s) => s.includes(commit))\n\n  if (!matching.length) {\n    // could not find path with commit SHA\n    return null\n  }\n\n  if (matching.length === 1) {\n    return matching[0]\n  }\n\n  // each path includes commit SHA and build number, let's pick the last build\n  const parsedBuilds = matching.map(parseBuildPath)\n  const sortedBuilds = sortBy(prop('build'))(parsedBuilds)\n\n  return prop('s3path', last(sortedBuilds))\n}\n\n/**\n * An object of all confirm prompts to the user.\n * Useful to stubbing the confirmation prompts during testing.\n */\nexport const prompts = {\n  async shouldCopy () {\n    await confirm({\n      question: 'Would you like to proceed? This will overwrite existing files',\n      default: false,\n    })\n  },\n}\n\n/**\n * Moves binaries built for different platforms into a single\n * folder on S3 before officially releasing as a new version.\n */\nexport const moveBinaries = async (args = []) => {\n  debug('moveBinaries with args %o', args)\n  const options = arg({\n    '--commit': String,\n    '--version': String,\n    // optional, if passed, only the binary for that platform will be moved\n    '--platformArch': String,\n    // aliases\n    '--sha': '--commit',\n    '-v': '--version',\n  }, {\n    argv: args.slice(2),\n  })\n\n  debug('moveBinaries with options %o', options)\n\n  // @ts-ignore\n  la(is.commitId(options['--commit']), 'missing or invalid commit SHA', options)\n  // @ts-ignore\n  la(is.semver(options['--version']), 'missing version to collect', options)\n\n  const releaseOptions: ReleaseInformation = {\n    commit: options['--commit'],\n    version: options['--version'],\n  }\n\n  const aws = uploadUtils.getS3Credentials()\n  const s3 = s3helpers.makeS3(aws)\n\n  // found s3 paths with last build for same commit for all platforms\n  const lastBuilds: Desktop[] = []\n\n  let platforms: platformArch[] = uploadUtils.getValidPlatformArchs()\n\n  if (options['--platformArch']) {\n    const onlyPlatform = options['--platformArch']\n\n    console.log('only moving single platform %s', onlyPlatform)\n    la(uploadUtils.isValidPlatformArch(onlyPlatform), 'invalid platform-arch', onlyPlatform)\n    platforms = platforms.filter(equals(onlyPlatform))\n  }\n\n  la(platforms.length, 'no platforms to move', platforms)\n\n  for (const platformArch of platforms) {\n    la(uploadUtils.isValidPlatformArch(platformArch),\n      'invalid platform arch', platformArch)\n\n    const uploadDir = getUploadDirForPlatform({\n      version: releaseOptions.version,\n    }, platformArch)\n\n    console.log('finding binary for %s in %s', platformArch, uploadDir)\n\n    const list: string[] = await s3helpers.listS3Objects(uploadDir, aws.bucket, s3)\n\n    if (debug.enabled) {\n      console.log('all found subfolders')\n      console.log(list.join('\\n'))\n    }\n\n    const lastBuildPath = findBuildByCommit(releaseOptions.commit, list)\n\n    if (!lastBuildPath) {\n      throw new Error(`Cannot find build with commit ${releaseOptions.commit} for platform ${platformArch}`)\n    }\n\n    console.log('found %s for commit %s on platform %s',\n      lastBuildPath,\n      releaseOptions.commit, platformArch)\n\n    const s3zipPath = lastBuildPath + zipName\n\n    await s3helpers.verifyZipFileExists(s3zipPath, aws.bucket, s3)\n\n    lastBuilds.push({\n      platformArch,\n      s3zipPath,\n    })\n  }\n\n  console.log('Copying %s for commit %s',\n    pluralize('last build', lastBuilds.length, true), releaseOptions.commit)\n\n  console.log(lastBuilds.map(prop('s3zipPath')).join('\\n'))\n\n  try {\n    await prompts.shouldCopy()\n  } catch (e) {\n    console.log('Copying has been canceled')\n\n    return\n  }\n\n  console.log('Copying ...')\n\n  // final test runners that we have copied\n  const testRunners: Desktop[] = []\n\n  for (const lastBuild of lastBuilds) {\n    const options = {\n      folder: aws.folder,\n      version: releaseOptions.version,\n      platformArch: lastBuild.platformArch,\n      name: zipName,\n    }\n    const destinationPath = getFullUploadName(options)\n\n    console.log('copying test runner %s to %s', lastBuild.platformArch, destinationPath)\n\n    await s3helpers.copyS3(lastBuild.s3zipPath, destinationPath, aws.bucket,\n      'application/zip', 'public-read', s3)\n\n    testRunners.push({\n      platformArch: lastBuild.platformArch,\n      s3zipPath: destinationPath,\n    })\n  }\n\n  // return all available information\n  return { lastBuilds, testRunners }\n}\n",
    "scripts/unit/binary/move-binaries-spec.js": "const snapshot = require('snap-shot-it')\nconst la = require('lazy-ass')\nconst is = require('check-more-types')\nconst uploadUtils = require('../../binary/util/upload')\nconst s3helpers = require('../../binary/s3-api').s3helpers\n\n/* eslint-env mocha */\n/* global sinon */\ndescribe('move-binaries', () => {\n  const moveBinaries = require('../../binary/move-binaries')\n\n  context('parseBuildPath', () => {\n    const parseBuildPath = moveBinaries.parseBuildPath\n\n    it('parses into SHA and build', () => {\n      const path =\n        'beta/binary/3.3.0/darwin-x64/circle-develop-47e98fa1d0b18867a74da91a719d0f1ae73fcbc7-101843/'\n      const parsed = parseBuildPath(path)\n\n      la(is.commitId(parsed.commit), 'missing commit', parsed)\n      la(is.positive(parsed.build), 'missing build', parsed)\n\n      snapshot({\n        path,\n        parsed,\n      })\n    })\n  })\n\n  context('findBuildByCommit', () => {\n    const findBuildByCommit = moveBinaries.findBuildByCommit\n    const sha = '47e98fa1d0b18867a74da91a719d0f1ae73fcbc7'\n\n    it('is a function', () => {\n      la(is.fn(findBuildByCommit))\n    })\n\n    it('finds single matching path', () => {\n      const paths = [\n        'beta/binary/3.3.0/darwin-x64/circle-develop-47e98fa1d0b18867a74da91a719d0f1ae73fcbc7-101843/',\n      ]\n      const found = findBuildByCommit(sha, paths)\n\n      la(found === paths[0], 'expected to find the only path', found)\n    })\n\n    it('finds single matching path among several', () => {\n      const paths = [\n        'beta/binary/3.3.0/darwin-x64/circle-develop-47e98fa1d0b18867a74da91a719d0f1ae73fcbc7-101843/',\n        // these are not matching\n        'beta/binary/3.3.0/darwin-x64/circle-develop-ffff8fa1d0b18867a74da91a719d0f1ae73fcbc7-101843/',\n        'beta/binary/3.3.0/darwin-x64/circle-develop-aaaa8fa1d0b18867a74da91a719d0f1ae73fcbc7-101843/',\n      ]\n      const found = findBuildByCommit(sha, paths)\n\n      la(found === paths[0], 'expected to find the only path', found)\n    })\n\n    it('finds last matching build', () => {\n      const paths = [\n        // matching, but not the last one\n        'beta/binary/3.3.0/darwin-x64/circle-develop-47e98fa1d0b18867a74da91a719d0f1ae73fcbc7-50/',\n        // this is both matching and is the latest build (100)\n        'beta/binary/3.3.0/darwin-x64/circle-develop-47e98fa1d0b18867a74da91a719d0f1ae73fcbc7-100/',\n        // these are not matching\n        'beta/binary/3.3.0/darwin-x64/circle-develop-ffff8fa1d0b18867a74da91a719d0f1ae73fcbc7-101843/',\n        'beta/binary/3.3.0/darwin-x64/circle-develop-aaaa8fa1d0b18867a74da91a719d0f1ae73fcbc7-101843/',\n        // this one is matching, but not the latest one\n        'beta/binary/3.3.0/darwin-x64/circle-develop-47e98fa1d0b18867a74da91a719d0f1ae73fcbc7-2/',\n      ]\n      const found = findBuildByCommit(sha, paths)\n\n      la(found === paths[1], 'expected to find the only path', found)\n    })\n  })\n\n  context('moveBinaries', () => {\n    const move = moveBinaries.moveBinaries\n\n    it('is a function', () => {\n      la(is.fn(move))\n    })\n\n    it('finds and copies latest build for each platform', () => {\n      // realistic end-to-end test\n      // stubs S3 method calls\n      // and lets our \"moveBinaries\" function collect builds\n      // find latest build for each platform (for the same commit)\n      // then call S3 to copy the desktop zip file to the final destination folder\n\n      const sha = '455046b928c861d4457b2ec5426a51de1fda74fd'\n      const version = '3.3.0'\n\n      // limit ourselves to single platform\n      sinon.stub(uploadUtils, 'getValidPlatformArchs').returns(['darwin-x64'])\n\n      // Mac builds for several commits in the beta folder\n      // below is the latest build matching the commit\n      const latestMacBuild =\n        'beta/binary/3.3.0/darwin-x64/circle-develop-455046b928c861d4457b2ec5426a51de1fda74fd-102457/'\n      const darwinBuilds = [\n        'beta/binary/3.3.0/darwin-x64/circle-develop-167934f0e45a07f03f6b1c5ddd6d8f201b5bb708-102287/',\n        'beta/binary/3.3.0/darwin-x64/circle-develop-455046b928c861d4457b2ec5426a51de1fda74fd-102212/',\n        'beta/binary/3.3.0/darwin-x64/circle-develop-47e98fa1d0b18867a74da91a719d0f1ae73fcbc7-101843/',\n        latestMacBuild,\n        'beta/binary/3.3.0/darwin-x64/circle-develop-5015cbbe876687deca571c221dfbc90715ad6d00-101982/',\n        'beta/binary/3.3.0/darwin-x64/circle-develop-9372bc3f67a6a83bd5ec8a69d7350f5a9b52ddf9-102246/',\n        'beta/binary/3.3.0/darwin-x64/circle-develop-455046b928c861d4457b2ec5426a51de1fda74fd-102359/',\n        'beta/binary/3.3.0/darwin-x64/circle-develop-ec36bf013224942f6198bf831d62af64b9b16cf5-102729/',\n        'beta/binary/3.3.0/darwin-x64/circle-issue-3996-6d539513e709ddd5aad866f6bf653280db6622cd-98450/',\n      ]\n\n      // fake AWS config\n      const aws = {\n        bucket: 'cdn.cypress.io',\n        folder: 'desktop', // destination for test runner downloads\n      }\n\n      sinon.stub(uploadUtils, 'getS3Credentials').returns(aws)\n\n      // fake S3 api\n      const s3 = {}\n\n      sinon.stub(s3helpers, 'makeS3').returns(s3)\n      sinon\n      .stub(s3helpers, 'listS3Objects')\n      .withArgs('beta/binary/3.3.0/darwin-x64', aws.bucket)\n      .resolves(darwinBuilds)\n\n      sinon\n      .stub(s3helpers, 'verifyZipFileExists')\n      .withArgs(`${latestMacBuild}cypress.zip`, aws.bucket)\n      .resolves()\n\n      // our method will ask user to confirm copying\n      sinon.stub(moveBinaries.prompts, 'shouldCopy').resolves()\n\n      sinon\n      .stub(s3helpers, 'copyS3')\n      .withArgs(\n        `${latestMacBuild}cypress.zip`,\n        'desktop/3.3.0/darwin-x64/cypress.zip',\n        aws.bucket,\n      )\n      .resolves()\n\n      // first two arguments are sliced anyway\n      const nodeName = null\n      const scriptName = null\n      const args = [nodeName, scriptName, '--sha', sha, '--version', version]\n\n      return move(args).then((result) => {\n        la(is.object(result), 'expected a result', result)\n\n        snapshot('collected builds and copied desktop', result)\n      })\n    })\n  })\n})\n",
    "node_modules/mocha/lib/runnable.js": "'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar JSON = require('json3');\nvar Pending = require('./pending');\nvar debug = require('debug')('mocha:runnable');\nvar milliseconds = require('./ms');\nvar utils = require('./utils');\nvar create = require('lodash.create');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Object#toString().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Expose `Runnable`.\n */\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n * @param {string} title\n * @param {Function} fn\n */\nfunction Runnable (title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.body = (fn || '').toString();\n  this.async = fn && fn.length;\n  this.sync = !this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._enableTimeouts = true;\n  this.timedOut = false;\n  this._trace = new Error('done() called multiple times');\n  this._retries = -1;\n  this._currentRetry = 0;\n  this.pending = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\nRunnable.prototype = create(EventEmitter.prototype, {\n  constructor: Runnable\n});\n\n/**\n * Set & get timeout `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  // see #1652 for reasoning\n  if (ms === 0 || ms > Math.pow(2, 31)) {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = ms;\n  if (this.timer) {\n    this.resetTimeout();\n  }\n  return this;\n};\n\n/**\n * Set & get slow `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.slow = function (ms) {\n  if (typeof ms === 'undefined') {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set and get whether timeout is `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Runnable|boolean} enabled or Runnable instance.\n */\nRunnable.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @api public\n */\nRunnable.prototype.skip = function () {\n  throw new Pending('sync skip');\n};\n\n/**\n * Check if this runnable or its parent suite is marked as pending.\n *\n * @api private\n */\nRunnable.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Set number of retries.\n *\n * @api private\n */\nRunnable.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  this._retries = n;\n};\n\n/**\n * Get current retry\n *\n * @api private\n */\nRunnable.prototype.currentRetry = function (n) {\n  if (!arguments.length) {\n    return this._currentRetry;\n  }\n  this._currentRetry = n;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @api public\n * @return {string}\n */\nRunnable.prototype.fullTitle = function () {\n  return this.parent.fullTitle() + ' ' + this.title;\n};\n\n/**\n * Clear the timeout.\n *\n * @api private\n */\nRunnable.prototype.clearTimeout = function () {\n  clearTimeout(this.timer);\n};\n\n/**\n * Inspect the runnable void of private properties.\n *\n * @api private\n * @return {string}\n */\nRunnable.prototype.inspect = function () {\n  return JSON.stringify(this, function (key, val) {\n    if (key[0] === '_') {\n      return;\n    }\n    if (key === 'parent') {\n      return '#<Suite>';\n    }\n    if (key === 'ctx') {\n      return '#<Context>';\n    }\n    return val;\n  }, 2);\n};\n\n/**\n * Reset the timeout.\n *\n * @api private\n */\nRunnable.prototype.resetTimeout = function () {\n  var self = this;\n  var ms = this.timeout() || 1e9;\n\n  if (!this._enableTimeouts) {\n    return;\n  }\n  this.clearTimeout();\n  this.timer = setTimeout(function () {\n    if (!self._enableTimeouts) {\n      return;\n    }\n    self.callback(new Error('Timeout of ' + ms +\n      'ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.'));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Whitelist a list of globals for this test run.\n *\n * @api private\n * @param {string[]} globals\n */\nRunnable.prototype.globals = function (globals) {\n  if (!arguments.length) {\n    return this._allowedGlobals;\n  }\n  this._allowedGlobals = globals;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunnable.prototype.run = function (fn) {\n  var self = this;\n  var start = new Date();\n  var ctx = this.ctx;\n  var finished;\n  var emitted;\n\n  // Sometimes the ctx exists, but it is not runnable\n  if (ctx && ctx.runnable) {\n    ctx.runnable(this);\n  }\n\n  // called multiple times\n  function multiple (err) {\n    if (emitted) {\n      return;\n    }\n    emitted = true;\n    self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));\n  }\n\n  // finished\n  function done (err) {\n    var ms = self.timeout();\n    if (self.timedOut) {\n      return;\n    }\n    if (finished) {\n      return multiple(err || self._trace);\n    }\n\n    self.clearTimeout();\n    self.duration = new Date() - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) {\n      err = new Error('Timeout of ' + ms +\n      'ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.');\n    }\n    fn(err);\n  }\n\n  // for .resetTimeout()\n  this.callback = done;\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    // allows skip() to be used in an explicit async context\n    this.skip = function asyncSkip () {\n      done(new Pending('async skip call'));\n      // halt execution.  the Runnable will be marked pending\n      // by the previous call, and the uncaught handler will ignore\n      // the failure.\n      throw new Pending('async skip; aborting execution');\n    };\n\n    if (this.allowUncaught) {\n      return callFnAsync(this.fn);\n    }\n    try {\n      callFnAsync(this.fn);\n    } catch (err) {\n      emitted = true;\n      done(utils.getError(err));\n    }\n    return;\n  }\n\n  if (this.allowUncaught) {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n    return;\n  }\n\n  // sync or promise-returning\n  try {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n  } catch (err) {\n    emitted = true;\n    done(utils.getError(err));\n  }\n\n  function callFn (fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result\n        .then(function () {\n          done();\n          // Return null so libraries like bluebird do not warn about\n          // subsequently constructed Promises.\n          return null;\n        },\n        function (reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'));\n        });\n    } else {\n      if (self.asyncOnly) {\n        return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\n      }\n\n      done();\n    }\n  }\n\n  function callFnAsync (fn) {\n    var result = fn.call(ctx, function (err) {\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\n        return done(err);\n      }\n      if (err) {\n        if (Object.prototype.toString.call(err) === '[object Object]') {\n          return done(new Error('done() invoked with non-Error: ' +\n            JSON.stringify(err)));\n        }\n        return done(new Error('done() invoked with non-Error: ' + err));\n      }\n      if (result && utils.isPromise(result)) {\n        return done(new Error('Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'));\n      }\n\n      done();\n    });\n  }\n};\n",
    "scripts/unit/github-actions/update-browser-version-spec.js": "const chai = require('chai')\nconst fs = require('fs')\nconst mockfs = require('mock-fs')\nconst nock = require('nock')\nconst sinon = require('sinon')\n\nchai.use(require('sinon-chai'))\n\nconst { expect } = chai\n\nconst {\n  getVersions,\n  checkNeedForBranchUpdate,\n  updateBrowserVersionsFile,\n  updatePRTitle,\n  createPullRequest,\n} = require('../../github-actions/update-browser-versions')\n\nconst coreStub = () => {\n  return {\n    setOutput: sinon.stub(),\n  }\n}\n\nconst stubOmahaResult = (result) => {\n  nock('https://omahaproxy.appspot.com')\n  .get('/all.json')\n  .reply(200, result)\n}\n\nconst stubRepoVersions = ({ betaVersion, stableVersion }) => {\n  mockfs({\n    './browser-versions.json': JSON.stringify({\n      'chrome:beta': betaVersion,\n      'chrome:stable': stableVersion,\n    }),\n  })\n}\n\nconst stubOmahaVersions = ({ betaVersion, stableVersion }) => {\n  stubOmahaResult([\n    {\n      os: 'linux',\n      versions: [\n        {\n          channel: 'stable',\n          version: stableVersion,\n        },\n        {\n          channel: 'beta',\n          version: betaVersion,\n        },\n      ],\n    },\n  ])\n}\n\ndescribe('update browser version github action', () => {\n  beforeEach(() => {\n    sinon.restore()\n    mockfs.restore()\n    nock.cleanAll()\n  })\n\n  context('.getVersions', () => {\n    beforeEach(() => {\n      stubRepoVersions({\n        betaVersion: '1.1',\n        stableVersion: '1.0',\n      })\n    })\n\n    it('sets has_update: true when there is a stable update', async () => {\n      stubOmahaVersions({\n        betaVersion: '1.1',\n        stableVersion: '2.0',\n      })\n\n      const core = coreStub()\n\n      await getVersions({ core })\n\n      expect(core.setOutput).to.be.calledWith('has_update', 'true')\n    })\n\n    it('sets has_update: true when there is a beta update', async () => {\n      stubOmahaVersions({\n        betaVersion: '1.2',\n        stableVersion: '1.0',\n      })\n\n      const core = coreStub()\n\n      await getVersions({ core })\n\n      expect(core.setOutput).to.be.calledWith('has_update', 'true')\n    })\n\n    it('sets has_update: true when there is a stable update and a beta update', async () => {\n      stubOmahaVersions({\n        betaVersion: '2.1',\n        stableVersion: '2.0',\n      })\n\n      const core = coreStub()\n\n      await getVersions({ core })\n\n      expect(core.setOutput).to.be.calledWith('has_update', 'true')\n    })\n\n    it('sets has_update: false when there is not a stable update or a beta update', async () => {\n      stubOmahaVersions({\n        betaVersion: '1.1',\n        stableVersion: '1.0',\n      })\n\n      const core = coreStub()\n\n      await getVersions({ core })\n\n      expect(core.setOutput).to.be.calledWith('has_update', 'false')\n    })\n\n    it('sets has_update: false if there is a failure', async () => {\n      stubOmahaResult({})\n\n      const core = coreStub()\n\n      await getVersions({ core })\n\n      expect(core.setOutput).to.be.calledWith('has_update', 'false')\n    })\n\n    it('sets versions', async () => {\n      stubOmahaVersions({\n        betaVersion: '2.1',\n        stableVersion: '2.0',\n      })\n\n      const core = coreStub()\n\n      await getVersions({ core })\n\n      expect(core.setOutput).to.be.calledWith('current_stable_version', '1.0')\n      expect(core.setOutput).to.be.calledWith('latest_stable_version', '2.0')\n      expect(core.setOutput).to.be.calledWith('current_beta_version', '1.1')\n      expect(core.setOutput).to.be.calledWith('latest_beta_version', '2.1')\n    })\n\n    it('sets description correctly when there is a stable update', async () => {\n      stubOmahaVersions({\n        betaVersion: '1.1',\n        stableVersion: '2.0',\n      })\n\n      const core = coreStub()\n\n      await getVersions({ core })\n\n      expect(core.setOutput).to.be.calledWith('description', 'Update Chrome (stable) to 2.0')\n    })\n\n    it('sets description correctly when there is a beta update', async () => {\n      stubOmahaVersions({\n        betaVersion: '1.2',\n        stableVersion: '1.0',\n      })\n\n      const core = coreStub()\n\n      await getVersions({ core })\n\n      expect(core.setOutput).to.be.calledWith('description', 'Update Chrome (beta) to 1.2')\n    })\n\n    it('sets description correctly when there is a stable update and a beta update', async () => {\n      stubOmahaVersions({\n        betaVersion: '2.1',\n        stableVersion: '2.0',\n      })\n\n      const core = coreStub()\n\n      await getVersions({ core })\n\n      expect(core.setOutput).to.be.calledWith('description', 'Update Chrome (stable) to 2.0 and Chrome (beta) to 2.1')\n    })\n  })\n\n  context('.checkNeedForBranchUpdate', () => {\n    beforeEach(() => {\n      stubRepoVersions({\n        betaVersion: '1.1',\n        stableVersion: '1.0',\n      })\n    })\n\n    it('sets has_newer_update: true when there is a stable update', () => {\n      const core = coreStub()\n\n      checkNeedForBranchUpdate({\n        core,\n        latestBetaVersion: '1.1',\n        latestStableVersion: '2.0',\n      })\n\n      expect(core.setOutput).to.be.calledWith('has_newer_update', 'true')\n    })\n\n    it('sets has_newer_update: true when there is a beta update', () => {\n      const core = coreStub()\n\n      checkNeedForBranchUpdate({\n        core,\n        latestBetaVersion: '1.2',\n        latestStableVersion: '1.0',\n      })\n\n      expect(core.setOutput).to.be.calledWith('has_newer_update', 'true')\n    })\n\n    it('sets has_newer_update: true when there is a stable update and a beta update', () => {\n      const core = coreStub()\n\n      checkNeedForBranchUpdate({\n        core,\n        latestBetaVersion: '2.1',\n        latestStableVersion: '2.0',\n      })\n\n      expect(core.setOutput).to.be.calledWith('has_newer_update', 'true')\n    })\n\n    it('sets has_newer_update: false when there is not a stable update or a beta update', () => {\n      const core = coreStub()\n\n      checkNeedForBranchUpdate({\n        core,\n        latestBetaVersion: '1.1',\n        latestStableVersion: '1.0',\n      })\n\n      expect(core.setOutput).to.be.calledWith('has_newer_update', 'false')\n    })\n  })\n\n  context('.updateBrowserVersionsFile', () => {\n    it('updates browser-versions.json with specified versions', () => {\n      sinon.stub(fs, 'writeFileSync')\n\n      updateBrowserVersionsFile({\n        latestBetaVersion: '2.1',\n        latestStableVersion: '2.0',\n      })\n\n      expect(fs.writeFileSync).to.be.calledWith('./browser-versions.json', `{\n  \"chrome:beta\": \"2.1\",\n  \"chrome:stable\": \"2.0\"\n}\n`)\n    })\n  })\n\n  context('.updatePRTitle', () => {\n    it('updates pull request title', async () => {\n      const github = {\n        pulls: {\n          list: sinon.stub().returns(Promise.resolve(\n            {\n              data: [\n                { number: '123' },\n              ],\n            },\n          )),\n          update: sinon.stub(),\n        },\n      }\n\n      const context = {\n        repo: {\n          owner: 'cypress-io',\n          repo: 'cypress',\n        },\n      }\n\n      await updatePRTitle({\n        context,\n        github,\n        baseBranch: 'develop',\n        branchName: 'some-branch-name',\n        description: 'Update Chrome to newer version',\n      })\n\n      expect(github.pulls.list).to.be.calledWith({\n        owner: 'cypress-io',\n        repo: 'cypress',\n        base: 'develop',\n        head: 'cypress-io:some-branch-name',\n      })\n\n      expect(github.pulls.update).to.be.calledWith({\n        owner: 'cypress-io',\n        repo: 'cypress',\n        pull_number: '123',\n        title: 'chore: Update Chrome to newer version',\n      })\n    })\n\n    it('logs and does not attempt to update pull request title if PR cannot be found', async () => {\n      const github = {\n        pulls: {\n          list: sinon.stub().returns(Promise.resolve(\n            {\n              data: [],\n            },\n          )),\n          update: sinon.stub(),\n        },\n      }\n\n      const context = {\n        repo: {\n          owner: 'cypress-io',\n          repo: 'cypress',\n        },\n      }\n\n      sinon.spy(console, 'log')\n\n      await updatePRTitle({\n        context,\n        github,\n        baseBranch: 'develop',\n        branchName: 'some-branch-name',\n        description: 'Update Chrome to newer version',\n      })\n\n      expect(github.pulls.list).to.be.calledWith({\n        owner: 'cypress-io',\n        repo: 'cypress',\n        base: 'develop',\n        head: 'cypress-io:some-branch-name',\n      })\n\n      expect(github.pulls.update).not.to.be.called\n      // eslint-disable-next-line no-console\n      expect(console.log).to.be.calledWith('Could not find PR for branch:', 'some-branch-name')\n    })\n  })\n\n  context('.createPullRequest', () => {\n    it('creates pull request with correct properties', async () => {\n      const github = {\n        pulls: {\n          create: sinon.stub().returns(Promise.resolve()),\n        },\n      }\n\n      const context = {\n        repo: {\n          owner: 'cypress-io',\n          repo: 'cypress',\n        },\n      }\n\n      await createPullRequest({\n        context,\n        github,\n        baseBranch: 'develop',\n        branchName: 'some-branch-name',\n        description: 'Update Chrome',\n      })\n\n      expect(github.pulls.create).to.be.calledWith({\n        owner: 'cypress-io',\n        repo: 'cypress',\n        base: 'develop',\n        head: 'some-branch-name',\n        title: 'chore: Update Chrome',\n        body: 'This PR was auto-generated to update the version(s) of Chrome for driver tests',\n        maintainer_can_modify: true,\n      })\n    })\n  })\n})\n",
    "npm/webpack-dev-server/src/index.ts": "import { debug as debugFn } from 'debug'\nimport { AddressInfo } from 'net'\nimport { Server } from 'http'\nimport { start as createDevServer, StartDevServer } from './startServer'\n\nconst debug = debugFn('cypress:webpack-dev-server:webpack')\n\ntype DoneCallback = () => unknown\n\nexport interface ResolvedDevServerConfig {\n  port: number\n  close: (done?: DoneCallback) => void\n}\n\nexport { StartDevServer }\n\nexport async function startDevServer (startDevServerArgs: StartDevServer, exitProcess = process.exit) {\n  const webpackDevServer = await createDevServer(startDevServerArgs, exitProcess)\n\n  return new Promise<ResolvedDevServerConfig>((resolve) => {\n    const httpSvr = webpackDevServer.listen(0, '127.0.0.1', () => {\n      // webpack-dev-server v3 returns `http.Server`.\n      // v4 returns a Promise that resolves `http.Server`.\n      // use Promise.resolve to make sure we get the `http.Server`,\n      // regardless of webpack-dev-server version.\n      Promise.resolve(httpSvr).then((server: Server) => {\n        // FIXME: handle address returning a string\n        const port = (server.address() as AddressInfo).port\n\n        debug('Component testing webpack server started on port', port)\n\n        return resolve({\n          port,\n          close: (done?: DoneCallback) => {\n            httpSvr.close()\n            done?.()\n          },\n        })\n      })\n    })\n  })\n}\n",
    "packages/driver/src/cypress/cy.js": "/* eslint-disable prefer-rest-params */\nconst _ = require('lodash')\nconst $ = require('jquery')\nconst Promise = require('bluebird')\nconst debugErrors = require('debug')('cypress:driver:errors')\n\nconst $dom = require('../dom')\nconst $utils = require('./utils')\nconst $errUtils = require('./error_utils')\nconst $stackUtils = require('./stack_utils')\nconst $Chai = require('../cy/chai')\nconst $Xhrs = require('../cy/xhrs')\nconst $jQuery = require('../cy/jquery')\nconst $Aliases = require('../cy/aliases')\nconst $Events = require('./events')\nconst $Ensures = require('../cy/ensures')\nconst $Focused = require('../cy/focused')\nconst $Mouse = require('../cy/mouse')\nconst $Keyboard = require('../cy/keyboard')\nconst $Location = require('../cy/location')\nconst $Assertions = require('../cy/assertions')\nconst $Listeners = require('../cy/listeners')\nconst $Chainer = require('./chainer')\nconst $Timers = require('../cy/timers')\nconst $Timeouts = require('../cy/timeouts')\nconst $Retries = require('../cy/retries')\nconst $Stability = require('../cy/stability')\nconst $selection = require('../dom/selection')\nconst $Snapshots = require('../cy/snapshots')\nconst $CommandQueue = require('./command_queue')\nconst $VideoRecorder = require('../cy/video-recorder')\nconst $TestConfigOverrides = require('../cy/testConfigOverrides')\n\nconst { registerFetch } = require('unfetch')\n\nconst noArgsAreAFunction = (args) => {\n  return !_.some(args, _.isFunction)\n}\n\nconst isPromiseLike = (ret) => {\n  return ret && _.isFunction(ret.then)\n}\n\nconst returnedFalse = (result) => {\n  return result === false\n}\n\nconst getContentWindow = ($autIframe) => {\n  return $autIframe.prop('contentWindow')\n}\n\nconst setWindowDocumentProps = function (contentWindow, state) {\n  state('window', contentWindow)\n\n  return state('document', contentWindow.document)\n}\n\nconst setRemoteIframeProps = ($autIframe, state) => {\n  return state('$autIframe', $autIframe)\n}\n\nfunction __stackReplacementMarker (fn, ctx, args) {\n  return fn.apply(ctx, args)\n}\n\n// We only set top.onerror once since we make it configurable:false\n// but we update cy instance every run (page reload or rerun button)\nlet curCy = null\nconst setTopOnError = function (Cypress, cy) {\n  if (curCy) {\n    curCy = cy\n\n    return\n  }\n\n  curCy = cy\n\n  // prevent overriding top.onerror twice when loading more than one\n  // instance of test runner.\n  if (top.__alreadySetErrorHandlers__) {\n    return\n  }\n\n  // eslint-disable-next-line @cypress/dev/arrow-body-multiline-braces\n  const onTopError = (handlerType) => (event) => {\n    const { originalErr, err, promise } = $errUtils.errorFromUncaughtEvent(handlerType, event)\n\n    // in some callbacks like for cy.intercept, we catch the errors and then\n    // rethrow them, causing them to get caught by the top frame\n    // but they came from the spec, so we need to differentiate them\n    const isSpecError = $errUtils.isSpecError(Cypress.config('spec'), err)\n\n    const handled = curCy.onUncaughtException({\n      err,\n      promise,\n      handlerType,\n      frameType: isSpecError ? 'spec' : 'app',\n    })\n\n    debugErrors('uncaught top error: %o', originalErr)\n\n    $errUtils.logError(Cypress, handlerType, originalErr, handled)\n\n    // return undefined so the browser does its default\n    // uncaught exception behavior (logging to console)\n    return undefined\n  }\n\n  top.addEventListener('error', onTopError('error'))\n\n  // prevent Mocha from setting top.onerror\n  Object.defineProperty(top, 'onerror', {\n    set () {},\n    get () {},\n    configurable: false,\n    enumerable: true,\n  })\n\n  top.addEventListener('unhandledrejection', onTopError('unhandledrejection'))\n\n  top.__alreadySetErrorHandlers__ = true\n}\n\nconst commandRunningFailed = (Cypress, state, err) => {\n  // allow for our own custom onFail function\n  if (err.onFail) {\n    err.onFail(err)\n\n    // clean up this onFail callback after it's been called\n    delete err.onFail\n\n    return\n  }\n\n  const current = state('current')\n\n  return Cypress.log({\n    end: true,\n    snapshot: true,\n    error: err,\n    consoleProps () {\n      if (!current) return\n\n      const obj = {}\n      const prev = current.get('prev')\n\n      // if type isnt parent then we know its dual or child\n      // and we can add Applied To if there is a prev command\n      // and it is a parent\n      if (current.get('type') !== 'parent' && prev) {\n        const ret = $dom.isElement(prev.get('subject')) ?\n          $dom.getElements(prev.get('subject'))\n          :\n          prev.get('subject')\n\n        obj['Applied To'] = ret\n\n        return obj\n      }\n    },\n  })\n}\n\n// NOTE: this makes the cy object an instance\n// TODO: refactor the 'create' method below into this class\nclass $Cy {}\n\nconst create = function (specWindow, Cypress, Cookies, state, config, log) {\n  let cy = new $Cy()\n  let stopped = false\n  const commandFns = {}\n\n  const isStopped = () => {\n    return stopped\n  }\n\n  const onFinishAssertions = function () {\n    return assertions.finishAssertions.apply(window, arguments)\n  }\n\n  const warnMixingPromisesAndCommands = function () {\n    const title = state('runnable').fullTitle()\n\n    $errUtils.warnByPath('miscellaneous.mixing_promises_and_commands', {\n      args: { title },\n    })\n  }\n\n  const $$ = function (selector, context) {\n    if (context == null) {\n      context = state('document')\n    }\n\n    return $dom.query(selector, context)\n  }\n\n  const queue = $CommandQueue.create()\n\n  $VideoRecorder.create(Cypress)\n  const timeouts = $Timeouts.create(state)\n  const stability = $Stability.create(Cypress, state)\n  const retries = $Retries.create(Cypress, state, timeouts.timeout, timeouts.clearTimeout, stability.whenStable, onFinishAssertions)\n  const assertions = $Assertions.create(Cypress, cy)\n\n  const jquery = $jQuery.create(state)\n  const location = $Location.create(state)\n  const focused = $Focused.create(state)\n  const keyboard = $Keyboard.create(Cypress, state)\n  const mouse = $Mouse.create(state, keyboard, focused, Cypress)\n  const timers = $Timers.create(Cypress)\n\n  const { expect } = $Chai.create(specWindow, state, assertions.assert)\n\n  const xhrs = $Xhrs.create(state)\n  const aliases = $Aliases.create(cy)\n\n  const ensures = $Ensures.create(state, expect)\n\n  const snapshots = $Snapshots.create($$, state)\n  const testConfigOverrides = $TestConfigOverrides.create()\n\n  const isCy = (val) => {\n    return (val === cy) || $utils.isInstanceOf(val, $Chainer)\n  }\n\n  const runnableCtx = function (name) {\n    ensures.ensureRunnable(name)\n\n    return state('runnable').ctx\n  }\n\n  const urlNavigationEvent = (event) => {\n    return Cypress.action('app:navigation:changed', `page navigation event (${event})`)\n  }\n\n  const contentWindowListeners = function (contentWindow) {\n    $Listeners.bindTo(contentWindow, {\n      // eslint-disable-next-line @cypress/dev/arrow-body-multiline-braces\n      onError: (handlerType) => (event) => {\n        const { originalErr, err, promise } = $errUtils.errorFromUncaughtEvent(handlerType, event)\n        const handled = cy.onUncaughtException({\n          err,\n          promise,\n          handlerType,\n          frameType: 'app',\n        })\n\n        debugErrors('uncaught AUT error: %o', originalErr)\n\n        $errUtils.logError(Cypress, handlerType, originalErr, handled)\n\n        // return undefined so the browser does its default\n        // uncaught exception behavior (logging to console)\n        return undefined\n      },\n      onSubmit (e) {\n        return Cypress.action('app:form:submitted', e)\n      },\n      onBeforeUnload (e) {\n        stability.isStable(false, 'beforeunload')\n\n        Cookies.setInitial()\n\n        timers.reset()\n\n        Cypress.action('app:window:before:unload', e)\n\n        // return undefined so our beforeunload handler\n        // doesnt trigger a confirmation dialog\n        return undefined\n      },\n      onUnload (e) {\n        return Cypress.action('app:window:unload', e)\n      },\n      onNavigation (...args) {\n        return Cypress.action('app:navigation:changed', ...args)\n      },\n      onAlert (str) {\n        return Cypress.action('app:window:alert', str)\n      },\n      onConfirm (str) {\n        const results = Cypress.action('app:window:confirm', str)\n\n        // return false if ANY results are false\n        // else true\n        const ret = !_.some(results, returnedFalse)\n\n        Cypress.action('app:window:confirmed', str, ret)\n\n        return ret\n      },\n    })\n  }\n\n  const wrapNativeMethods = function (contentWindow) {\n    try {\n      // return null to trick contentWindow into thinking\n      // its not been iframed if modifyObstructiveCode is true\n      if (config('modifyObstructiveCode')) {\n        Object.defineProperty(contentWindow, 'frameElement', {\n          get () {\n            return null\n          },\n        })\n      }\n\n      contentWindow.HTMLElement.prototype.focus = function (focusOption) {\n        return focused.interceptFocus(this, contentWindow, focusOption)\n      }\n\n      contentWindow.HTMLElement.prototype.blur = function () {\n        return focused.interceptBlur(this)\n      }\n\n      contentWindow.SVGElement.prototype.focus = function (focusOption) {\n        return focused.interceptFocus(this, contentWindow, focusOption)\n      }\n\n      contentWindow.SVGElement.prototype.blur = function () {\n        return focused.interceptBlur(this)\n      }\n\n      contentWindow.HTMLInputElement.prototype.select = function () {\n        return $selection.interceptSelect.call(this)\n      }\n\n      contentWindow.document.hasFocus = function () {\n        return focused.documentHasFocus.call(this)\n      }\n\n      const cssModificationSpy = function (original, ...args) {\n        snapshots.onCssModified(this.href)\n\n        return original.apply(this, args)\n      }\n\n      const { insertRule } = contentWindow.CSSStyleSheet.prototype\n      const { deleteRule } = contentWindow.CSSStyleSheet.prototype\n\n      contentWindow.CSSStyleSheet.prototype.insertRule = _.wrap(insertRule, cssModificationSpy)\n      contentWindow.CSSStyleSheet.prototype.deleteRule = _.wrap(deleteRule, cssModificationSpy)\n\n      if (config('experimentalFetchPolyfill')) {\n        // drop \"fetch\" polyfill that replaces it with XMLHttpRequest\n        // from the app iframe that we wrap for network stubbing\n        contentWindow.fetch = registerFetch(contentWindow)\n        // flag the polyfill to test this experimental feature easier\n        state('fetchPolyfilled', true)\n      }\n    } catch (error) {} // eslint-disable-line no-empty\n  }\n\n  const enqueue = function (obj) {\n    // if we have a nestedIndex it means we're processing\n    // nested commands and need to splice them into the\n    // index past the current index as opposed to\n    // pushing them to the end we also dont want to\n    // reset the run defer because splicing means we're\n    // already in a run loop and dont want to create another!\n    // we also reset the .next property to properly reference\n    // our new obj\n\n    // we had a bug that would bomb on custom commands when it was the\n    // first command. this was due to nestedIndex being undefined at that\n    // time. so we have to ensure to check that its any kind of number (even 0)\n    // in order to know to splice into the existing array.\n    let nestedIndex = state('nestedIndex')\n\n    // if this is a number then we know\n    // we're about to splice this into our commands\n    // and need to reset next + increment the index\n    if (_.isNumber(nestedIndex)) {\n      state('nestedIndex', (nestedIndex += 1))\n    }\n\n    // we look at whether or not nestedIndex is a number, because if it\n    // is then we need to splice inside of our commands, else just push\n    // it onto the end of the queu\n    const index = _.isNumber(nestedIndex) ? nestedIndex : queue.length\n\n    queue.splice(index, 0, obj)\n\n    return Cypress.action('cy:command:enqueued', obj)\n  }\n\n  const getCommandsUntilFirstParentOrValidSubject = function (command, memo = []) {\n    if (!command) {\n      return null\n    }\n\n    // push these onto the beginning of the commands array\n    memo.unshift(command)\n\n    // break and return the memo\n    if ((command.get('type') === 'parent') || $dom.isAttached(command.get('subject'))) {\n      return memo\n    }\n\n    return getCommandsUntilFirstParentOrValidSubject(command.get('prev'), memo)\n  }\n\n  const runCommand = function (command) {\n    // bail here prior to creating a new promise\n    // because we could have stopped / canceled\n    // prior to ever making it through our first\n    // command\n    if (stopped) {\n      return\n    }\n\n    state('current', command)\n    state('chainerId', command.get('chainerId'))\n\n    return stability.whenStable(() => {\n      // TODO: handle this event\n      // @trigger \"invoke:start\", command\n\n      state('nestedIndex', state('index'))\n\n      return command.get('args')\n    })\n\n    .then((args) => {\n      // store this if we enqueue new commands\n      // to check for promise violations\n      let ret\n      let enqueuedCmd = null\n\n      const commandEnqueued = (obj) => {\n        return enqueuedCmd = obj\n      }\n\n      // only check for command enqueing when none\n      // of our args are functions else commands\n      // like cy.then or cy.each would always fail\n      // since they return promises and queue more\n      // new commands\n      if (noArgsAreAFunction(args)) {\n        Cypress.once('command:enqueued', commandEnqueued)\n      }\n\n      // run the command's fn with runnable's context\n      try {\n        ret = __stackReplacementMarker(command.get('fn'), state('ctx'), args)\n      } catch (err) {\n        throw err\n      } finally {\n        // always remove this listener\n        Cypress.removeListener('command:enqueued', commandEnqueued)\n      }\n\n      state('commandIntermediateValue', ret)\n\n      // we cannot pass our cypress instance or our chainer\n      // back into bluebird else it will create a thenable\n      // which is never resolved\n      if (isCy(ret)) {\n        return null\n      }\n\n      if (!(!enqueuedCmd || !isPromiseLike(ret))) {\n        return $errUtils.throwErrByPath(\n          'miscellaneous.command_returned_promise_and_commands', {\n            args: {\n              current: command.get('name'),\n              called: enqueuedCmd.name,\n            },\n          },\n        )\n      }\n\n      if (!(!enqueuedCmd || !!_.isUndefined(ret))) {\n        // TODO: clean this up in the utility function\n        // to conditionally stringify functions\n        ret = _.isFunction(ret) ?\n          ret.toString()\n          :\n          $utils.stringify(ret)\n\n        // if we got a return value and we enqueued\n        // a new command and we didn't return cy\n        // or an undefined value then throw\n        return $errUtils.throwErrByPath(\n          'miscellaneous.returned_value_and_commands_from_custom_command', {\n            args: {\n              current: command.get('name'),\n              returned: ret,\n            },\n          },\n        )\n      }\n\n      return ret\n    }).then((subject) => {\n      state('commandIntermediateValue', undefined)\n\n      // we may be given a regular array here so\n      // we need to re-wrap the array in jquery\n      // if that's the case if the first item\n      // in this subject is a jquery element.\n      // we want to do this because in 3.1.2 there\n      // was a regression when wrapping an array of elements\n      const firstSubject = $utils.unwrapFirst(subject)\n\n      // if ret is a DOM element and its not an instance of our own jQuery\n      if (subject && $dom.isElement(firstSubject) && !$utils.isInstanceOf(subject, $)) {\n        // set it back to our own jquery object\n        // to prevent it from being passed downstream\n        // TODO: enable turning this off\n        // wrapSubjectsInJquery: false\n        // which will just pass subjects downstream\n        // without modifying them\n        subject = $dom.wrap(subject)\n      }\n\n      command.set({ subject })\n\n      // end / snapshot our logs\n      // if they need it\n      command.finishLogs()\n\n      // reset the nestedIndex back to null\n      state('nestedIndex', null)\n\n      // also reset recentlyReady back to null\n      state('recentlyReady', null)\n\n      // we're finished with the current command\n      // so set it back to null\n      state('current', null)\n\n      state('subject', subject)\n\n      return subject\n    })\n  }\n\n  const run = function () {\n    const next = function () {\n      // bail if we've been told to abort in case\n      // an old command continues to run after\n      if (stopped) {\n        return\n      }\n\n      // start at 0 index if we dont have one\n      let index = state('index') || state('index', 0)\n\n      const command = queue.at(index)\n\n      // if the command should be skipped\n      // just bail and increment index\n      // and set the subject\n      // TODO DRY THIS LOGIC UP\n      if (command && command.get('skip')) {\n        // must set prev + next since other\n        // operations depend on this state being correct\n        command.set({ prev: queue.at(index - 1), next: queue.at(index + 1) })\n        state('index', index + 1)\n        state('subject', command.get('subject'))\n\n        return next()\n      }\n\n      // if we're at the very end\n      if (!command) {\n        // trigger queue is almost finished\n        Cypress.action('cy:command:queue:before:end')\n\n        // we need to wait after all commands have\n        // finished running if the application under\n        // test is no longer stable because we cannot\n        // move onto the next test until its finished\n        return stability.whenStable(() => {\n          Cypress.action('cy:command:queue:end')\n\n          return null\n        })\n      }\n\n      // store the previous timeout\n      const prevTimeout = timeouts.timeout()\n\n      // store the current runnable\n      const runnable = state('runnable')\n\n      Cypress.action('cy:command:start', command)\n\n      return runCommand(command)\n      .then(() => {\n        // each successful command invocation should\n        // always reset the timeout for the current runnable\n        // unless it already has a state.  if it has a state\n        // and we reset the timeout again, it will always\n        // cause a timeout later no matter what.  by this time\n        // mocha expects the test to be done\n        let fn\n\n        if (!runnable.state) {\n          timeouts.timeout(prevTimeout)\n        }\n\n        // mutate index by incrementing it\n        // this allows us to keep the proper index\n        // in between different hooks like before + beforeEach\n        // else run will be called again and index would start\n        // over at 0\n        state('index', (index += 1))\n\n        Cypress.action('cy:command:end', command)\n\n        fn = state('onPaused')\n\n        if (fn) {\n          return new Promise((resolve) => {\n            return fn(resolve)\n          }).then(next)\n        }\n\n        return next()\n      })\n    }\n\n    let inner = null\n\n    // this ends up being the parent promise wrapper\n    const promise = new Promise((resolve, reject) => {\n      // bubble out the inner promise\n      // we must use a resolve(null) here\n      // so the outer promise is first defined\n      // else this will kick off the 'next' call\n      // too soon and end up running commands prior\n      // to promise being defined\n      inner = Promise\n      .resolve(null)\n      .then(next)\n      .then(resolve)\n      .catch(reject)\n\n      // can't use onCancel argument here because\n      // its called asynchronously\n\n      // when we manually reject our outer promise we\n      // have to immediately cancel the inner one else\n      // it won't be notified and its callbacks will\n      // continue to be invoked\n      // normally we don't have to do this because rejections\n      // come from the inner promise and bubble out to our outer\n      //\n      // but when we manually reject the outer promise we\n      // have to go in the opposite direction from outer -> inner\n      const rejectOuterAndCancelInner = function (err) {\n        inner.cancel()\n\n        return reject(err)\n      }\n\n      state('resolve', resolve)\n      state('reject', rejectOuterAndCancelInner)\n    })\n    .catch((err) => {\n      debugErrors('caught error in promise chain: %o', err)\n\n      // since this failed this means that a\n      // specific command failed and we should\n      // highlight it in red or insert a new command\n      err.name = err.name || 'CypressError'\n      commandRunningFailed(Cypress, state, err)\n\n      return fail(err)\n    })\n    .finally(cleanup)\n\n    // cancel both promises\n    const cancel = function () {\n      promise.cancel()\n      inner.cancel()\n\n      // notify the world\n      return Cypress.action('cy:canceled')\n    }\n\n    state('cancel', cancel)\n    state('promise', promise)\n\n    // return this outer bluebird promise\n    return promise\n  }\n\n  const removeSubject = () => {\n    return state('subject', undefined)\n  }\n\n  const pushSubjectAndValidate = function (name, args, firstCall, prevSubject) {\n    if (firstCall) {\n      // if we have a prevSubject then error\n      // since we're invoking this improperly\n      let needle\n\n      if (prevSubject && ((needle = 'optional', ![].concat(prevSubject).includes(needle)))) {\n        const stringifiedArg = $utils.stringifyActual(args[0])\n\n        $errUtils.throwErrByPath('miscellaneous.invoking_child_without_parent', {\n          args: {\n            cmd: name,\n            args: _.isString(args[0]) ? `\\\"${stringifiedArg}\\\"` : stringifiedArg,\n          },\n        })\n      }\n\n      // else if this is the very first call\n      // on the chainer then make the first\n      // argument undefined (we have no subject)\n      removeSubject()\n    }\n\n    const subject = state('subject')\n\n    if (prevSubject) {\n      // make sure our current subject is valid for\n      // what we expect in this command\n      ensures.ensureSubjectByType(subject, prevSubject, name)\n    }\n\n    args.unshift(subject)\n\n    Cypress.action('cy:next:subject:prepared', subject, args, firstCall)\n\n    return args\n  }\n\n  const doneEarly = function () {\n    stopped = true\n\n    // we only need to worry about doneEarly when\n    // it comes from a manual event such as stopping\n    // Cypress or when we yield a (done) callback\n    // and could arbitrarily call it whenever we want\n    const p = state('promise')\n\n    // if our outer promise is pending\n    // then cancel outer and inner\n    // and set canceled to be true\n    if (p && p.isPending()) {\n      state('canceled', true)\n      state('cancel')()\n    }\n\n    return cleanup()\n  }\n\n  const cleanup = function () {\n    // cleanup could be called during a 'stop' event which\n    // could happen in between a runnable because they are async\n    if (state('runnable')) {\n      // make sure we reset the runnable's timeout now\n      state('runnable').resetTimeout()\n    }\n\n    // if a command fails then after each commands\n    // could also fail unless we clear this out\n    state('commandIntermediateValue', undefined)\n\n    // reset the nestedIndex back to null\n    state('nestedIndex', null)\n\n    // also reset recentlyReady back to null\n    state('recentlyReady', null)\n\n    // and forcibly move the index needle to the\n    // end in case we have after / afterEach hooks\n    // which need to run\n    return state('index', queue.length)\n  }\n\n  const getUserInvocationStack = (err) => {\n    const current = state('current')\n    const currentAssertionCommand = current?.get('currentAssertionCommand')\n    const withInvocationStack = currentAssertionCommand || current\n    // user assertion errors (expect().to, etc) get their invocation stack\n    // attached to the error thrown from chai\n    // command errors and command assertion errors (default assertion or cy.should)\n    // have the invocation stack attached to the current command\n    // prefer err.userInvocation stack if it's been set\n    let userInvocationStack = $errUtils.getUserInvocationStack(err) || state('currentAssertionUserInvocationStack')\n\n    // if there is no user invocation stack from an assertion or it is the default\n    // assertion, meaning it came from a command (e.g. cy.get), prefer the\n    // command's user invocation stack so the code frame points to the command.\n    // `should` callbacks are tricky because the `currentAssertionUserInvocationStack`\n    // points to the `cy.should`, but the error came from inside the callback,\n    // so we need to prefer that.\n    if (\n      !userInvocationStack\n      || err.isDefaultAssertionErr\n      || (currentAssertionCommand && !current?.get('followedByShouldCallback'))\n    ) {\n      userInvocationStack = withInvocationStack?.get('userInvocationStack')\n    }\n\n    if (!userInvocationStack) return\n\n    if (\n      $errUtils.isCypressErr(err)\n      || $errUtils.isAssertionErr(err)\n      || $errUtils.isChaiValidationErr(err)\n    ) {\n      return userInvocationStack\n    }\n  }\n\n  const fail = (err, options = {}) => {\n    // this means the error has already been through this handler and caught\n    // again. but we don't need to run it through again, so we can re-throw\n    // it and it will fail the test as-is\n    if (err && err.hasFailed) {\n      delete err.hasFailed\n\n      throw err\n    }\n\n    options = _.defaults(options, {\n      async: false,\n    })\n\n    let rets\n\n    stopped = true\n\n    if (typeof err === 'string') {\n      err = new Error(err)\n    }\n\n    err.stack = $stackUtils.normalizedStack(err)\n\n    err = $errUtils.enhanceStack({\n      err,\n      userInvocationStack: getUserInvocationStack(err),\n      projectRoot: config('projectRoot'),\n    })\n\n    err = $errUtils.processErr(err, config)\n\n    err.hasFailed = true\n\n    // store the error on state now\n    state('error', err)\n\n    const finish = function (err) {\n      // if the test has a (done) callback, we fail the test with that\n      const d = state('done')\n\n      if (d) {\n        return d(err)\n      }\n\n      // if this failure was asynchronously called (outside the promise chain)\n      // but the promise chain is still active, reject it. if we're inside\n      // the promise chain, this isn't necessary and will actually mess it up\n      const r = state('reject')\n\n      if (options.async && r) {\n        return r(err)\n      }\n\n      // we're in the promise chain, so throw the error and it will\n      // get caught by mocha and fail the test\n      throw err\n    }\n\n    // this means the error came from a 'fail' handler, so don't send\n    // 'cy:fail' action again, just finish up\n    if (err.isCyFailErr) {\n      delete err.isCyFailErr\n\n      return finish(err)\n    }\n\n    // if we have a \"fail\" handler\n    // 1. catch any errors it throws and fail the test\n    // 2. otherwise swallow any errors\n    // 3. but if the test is not ended with a done()\n    //    then it should fail\n    // 4. and tests without a done will pass\n\n    // if we dont have a \"fail\" handler\n    // 1. callback with state(\"done\") when async\n    // 2. throw the error for the promise chain\n    try {\n      // collect all of the callbacks for 'fail'\n      rets = Cypress.action('cy:fail', err, state('runnable'))\n    } catch (cyFailErr) {\n      // and if any of these throw synchronously immediately error\n      cyFailErr.isCyFailErr = true\n\n      return fail(cyFailErr)\n    }\n\n    // bail if we had callbacks attached\n    if (rets && rets.length) {\n      return\n    }\n\n    // else figure out how to finish this failure\n    return finish(err)\n  }\n\n  _.extend(cy, {\n    id: _.uniqueId('cy'),\n\n    // synchrounous querying\n    $$,\n\n    state,\n\n    // command queue instance\n    queue,\n\n    // errors sync methods\n    fail,\n\n    // chai expect sync methods\n    expect,\n\n    // is cy\n    isCy,\n\n    isStopped,\n\n    // timeout sync methods\n    timeout: timeouts.timeout,\n    clearTimeout: timeouts.clearTimeout,\n\n    // stability sync methods\n    isStable: stability.isStable,\n    whenStable: stability.whenStable,\n\n    // xhr sync methods\n    getRequestsByAlias: xhrs.getRequestsByAlias,\n    getIndexedXhrByAlias: xhrs.getIndexedXhrByAlias,\n\n    // alias sync methods\n    getAlias: aliases.getAlias,\n    addAlias: aliases.addAlias,\n    validateAlias: aliases.validateAlias,\n    getNextAlias: aliases.getNextAlias,\n    aliasNotFoundFor: aliases.aliasNotFoundFor,\n    getXhrTypeByAlias: aliases.getXhrTypeByAlias,\n\n    // location sync methods\n    getRemoteLocation: location.getRemoteLocation,\n\n    // jquery sync methods\n    getRemotejQueryInstance: jquery.getRemotejQueryInstance,\n\n    // focused sync methods\n    getFocused: focused.getFocused,\n    needsFocus: focused.needsFocus,\n    fireFocus: focused.fireFocus,\n    fireBlur: focused.fireBlur,\n\n    devices: {\n      mouse,\n      keyboard,\n    },\n\n    // timer sync methods\n    pauseTimers: timers.pauseTimers,\n\n    // snapshots sync methods\n    createSnapshot: snapshots.createSnapshot,\n\n    // retry sync methods\n    retry: retries.retry,\n\n    // assertions sync methods\n    assert: assertions.assert,\n    verifyUpcomingAssertions: assertions.verifyUpcomingAssertions,\n\n    // ensure sync methods\n    ensureWindow: ensures.ensureWindow,\n    ensureElement: ensures.ensureElement,\n    ensureDocument: ensures.ensureDocument,\n    ensureAttached: ensures.ensureAttached,\n    ensureExistence: ensures.ensureExistence,\n    ensureElExistence: ensures.ensureElExistence,\n    ensureElDoesNotHaveCSS: ensures.ensureElDoesNotHaveCSS,\n    ensureVisibility: ensures.ensureVisibility,\n    ensureDescendents: ensures.ensureDescendents,\n    ensureNotReadonly: ensures.ensureNotReadonly,\n    ensureNotDisabled: ensures.ensureNotDisabled,\n    ensureValidPosition: ensures.ensureValidPosition,\n    ensureScrollability: ensures.ensureScrollability,\n    ensureElementIsNotAnimating: ensures.ensureElementIsNotAnimating,\n\n    initialize ($autIframe) {\n      setRemoteIframeProps($autIframe, state)\n\n      // dont need to worry about a try/catch here\n      // because this is during initialize and its\n      // impossible something is wrong here\n      setWindowDocumentProps(getContentWindow($autIframe), state)\n\n      // initially set the content window listeners too\n      // so we can tap into all the normal flow of events\n      // like before:unload, navigation events, etc\n      contentWindowListeners(getContentWindow($autIframe))\n\n      // the load event comes from the autIframe anytime any window\n      // inside of it loads.\n      // when this happens we need to check for cross origin errors\n      // by trying to talk to the contentWindow document to see if\n      // its accessible.\n      // when we find ourselves in a cross origin situation, then our\n      // proxy has not injected Cypress.action('window:before:load')\n      // so Cypress.onBeforeAppWindowLoad() was never called\n      return $autIframe.on('load', () => {\n        // if setting these props failed\n        // then we know we're in a cross origin failure\n        let onpl; let r\n\n        try {\n          setWindowDocumentProps(getContentWindow($autIframe), state)\n\n          // we may need to update the url now\n          urlNavigationEvent('load')\n\n          // we normally DONT need to reapply contentWindow listeners\n          // because they would have been automatically applied during\n          // onBeforeAppWindowLoad, but in the case where we visited\n          // about:blank in a visit, we do need these\n          contentWindowListeners(getContentWindow($autIframe))\n\n          Cypress.action('app:window:load', state('window'))\n\n          // we are now stable again which is purposefully\n          // the last event we call here, to give our event\n          // listeners time to be invoked prior to moving on\n          return stability.isStable(true, 'load')\n        } catch (err) {\n          let e = err\n\n          // we failed setting the remote window props\n          // which means we're in a cross domain failure\n          // check first to see if you have a callback function\n          // defined and let the page load change the error\n          onpl = state('onPageLoadErr')\n\n          if (onpl) {\n            e = onpl(e)\n          }\n\n          // and now reject with it\n          r = state('reject')\n\n          if (r) {\n            return r(e)\n          }\n        }\n      })\n    },\n\n    stop () {\n      // don't do anything if we've already stopped\n      if (stopped) {\n        return\n      }\n\n      return doneEarly()\n    },\n\n    reset (attrs, test) {\n      stopped = false\n\n      const s = state()\n\n      const backup = {\n        window: s.window,\n        document: s.document,\n        $autIframe: s.$autIframe,\n      }\n\n      // reset state back to empty object\n      state.reset()\n\n      // and then restore these backed up props\n      state(backup)\n\n      queue.reset()\n      timers.reset()\n      testConfigOverrides.restoreAndSetTestConfigOverrides(test, Cypress.config, Cypress.env)\n\n      return cy.removeAllListeners()\n    },\n\n    addCommandSync (name, fn) {\n      cy[name] = function () {\n        return fn.apply(runnableCtx(name), arguments)\n      }\n    },\n\n    addChainer (name, fn) {\n      // add this function to our chainer class\n      return $Chainer.add(name, fn)\n    },\n\n    addCommand ({ name, fn, type, prevSubject }) {\n      // TODO: prob don't need this anymore\n      commandFns[name] = fn\n\n      const wrap = function (firstCall) {\n        fn = commandFns[name]\n        const wrapped = wrapByType(fn, firstCall)\n\n        wrapped.originalFn = fn\n\n        return wrapped\n      }\n\n      const wrapByType = function (fn, firstCall) {\n        if (type === 'parent') {\n          return fn\n        }\n\n        // child, dual, assertion, utility command\n        // pushes the previous subject into them\n        // after verifying its of the correct type\n        return function (...args) {\n          // push the subject into the args\n          args = pushSubjectAndValidate(name, args, firstCall, prevSubject)\n\n          return fn.apply(runnableCtx(name), args)\n        }\n      }\n\n      cy[name] = function (...args) {\n        const userInvocationStack = $stackUtils.captureUserInvocationStack(specWindow.Error)\n\n        let ret\n\n        ensures.ensureRunnable(name)\n\n        // this is the first call on cypress\n        // so create a new chainer instance\n        const chain = $Chainer.create(name, userInvocationStack, specWindow, args)\n\n        // store the chain so we can access it later\n        state('chain', chain)\n\n        // if we are in the middle of a command\n        // and its return value is a promise\n        // that means we are attempting to invoke\n        // a cypress command within another cypress\n        // command and we should error\n        ret = state('commandIntermediateValue')\n\n        if (ret) {\n          const current = state('current')\n\n          // if this is a custom promise\n          if (isPromiseLike(ret) && noArgsAreAFunction(current.get('args'))) {\n            $errUtils.throwErrByPath(\n              'miscellaneous.command_returned_promise_and_commands', {\n                args: {\n                  current: current.get('name'),\n                  called: name,\n                },\n              },\n            )\n          }\n        }\n\n        // if we're the first call onto a cy\n        // command, then kick off the run\n        if (!state('promise')) {\n          if (state('returnedCustomPromise')) {\n            warnMixingPromisesAndCommands()\n          }\n\n          run()\n        }\n\n        return chain\n      }\n\n      return cy.addChainer(name, (chainer, userInvocationStack, args) => {\n        const { firstCall, chainerId } = chainer\n\n        // dont enqueue / inject any new commands if\n        // onInjectCommand returns false\n        const onInjectCommand = state('onInjectCommand')\n        const injected = _.isFunction(onInjectCommand)\n\n        if (injected) {\n          if (onInjectCommand.call(cy, name, ...args) === false) {\n            return\n          }\n        }\n\n        enqueue({\n          name,\n          args,\n          type,\n          chainerId,\n          userInvocationStack,\n          injected,\n          fn: wrap(firstCall),\n        })\n\n        return true\n      })\n    },\n\n    now (name, ...args) {\n      return Promise.resolve(\n        commandFns[name].apply(cy, args),\n      )\n    },\n\n    replayCommandsFrom (current) {\n      // reset each chainerId to the\n      // current value\n      const chainerId = state('chainerId')\n\n      const insert = function (command) {\n        command.set('chainerId', chainerId)\n\n        // clone the command to prevent\n        // mutating its properties\n        return enqueue(command.clone())\n      }\n\n      // - starting with the aliased command\n      // - walk up to each prev command\n      // - until you reach a parent command\n      // - or until the subject is in the DOM\n      // - from that command walk down inserting\n      //   every command which changed the subject\n      // - coming upon an assertion should only be\n      //   inserted if the previous command should\n      //   be replayed\n\n      const commands = getCommandsUntilFirstParentOrValidSubject(current)\n\n      if (commands) {\n        let initialCommand = commands.shift()\n\n        const commandsToInsert = _.reduce(commands, (memo, command, index) => {\n          let needle\n          const push = () => {\n            return memo.push(command)\n          }\n\n          if (!(command.get('type') !== 'assertion')) {\n            // if we're an assertion and the prev command\n            // is in the memo, then push this one\n            if ((needle = command.get('prev'), memo.includes(needle))) {\n              push()\n            }\n          } else if (!(command.get('subject') === initialCommand.get('subject'))) {\n            // when our subjects dont match then\n            // reset the initialCommand to this command\n            // so the next commands can compare against\n            // this one to figure out the changing subjects\n            initialCommand = command\n\n            push()\n          }\n\n          return memo\n        }\n\n        , [initialCommand])\n\n        for (let c of commandsToInsert) {\n          insert(c)\n        }\n      }\n\n      // prevent loop comprehension\n      return null\n    },\n\n    onBeforeAppWindowLoad (contentWindow) {\n      // we set window / document props before the window load event\n      // so that we properly handle events coming from the application\n      // from the time that happens BEFORE the load event occurs\n      setWindowDocumentProps(contentWindow, state)\n\n      urlNavigationEvent('before:load')\n\n      contentWindowListeners(contentWindow)\n\n      wrapNativeMethods(contentWindow)\n\n      snapshots.onBeforeWindowLoad()\n    },\n\n    onUncaughtException ({ handlerType, frameType, err, promise }) {\n      err = $errUtils.createUncaughtException({\n        handlerType,\n        frameType,\n        state,\n        err,\n      })\n\n      const runnable = state('runnable')\n\n      // don't do anything if we don't have a current runnable\n      if (!runnable) return\n\n      // uncaught exceptions should be only be catchable in the AUT (app)\n      // or if in component testing mode, since then the spec frame and\n      // AUT frame are the same\n      if (frameType === 'app' || config('componentTesting')) {\n        try {\n          const results = Cypress.action('app:uncaught:exception', err, runnable, promise)\n\n          // dont do anything if any of our uncaught:exception\n          // listeners returned false\n          if (_.some(results, returnedFalse)) {\n            // return true to signal that the user handled this error\n            return true\n          }\n        } catch (uncaughtExceptionErr) {\n          err = $errUtils.createUncaughtException({\n            err: uncaughtExceptionErr,\n            handlerType: 'error',\n            frameType: 'spec',\n            state,\n          })\n        }\n      }\n\n      try {\n        fail(err)\n      } catch (failErr) {\n        const r = state('reject')\n\n        if (r) {\n          r(err)\n        }\n      }\n    },\n\n    detachDom (...args) {\n      return snapshots.detachDom(...args)\n    },\n\n    getStyles (...args) {\n      return snapshots.getStyles(...args)\n    },\n\n    setRunnable (runnable, hookId) {\n      // when we're setting a new runnable\n      // prepare to run again!\n      stopped = false\n\n      // reset the promise again\n      state('promise', undefined)\n\n      state('hookId', hookId)\n\n      state('runnable', runnable)\n\n      state('test', $utils.getTestFromRunnable(runnable))\n\n      state('ctx', runnable.ctx)\n\n      const { fn } = runnable\n\n      const restore = () => {\n        return runnable.fn = fn\n      }\n\n      runnable.fn = function () {\n        restore()\n\n        const timeout = config('defaultCommandTimeout')\n\n        // control timeouts on runnables ourselves\n        if (_.isFinite(timeout)) {\n          timeouts.timeout(timeout)\n        }\n\n        // store the current length of our queue\n        // before we invoke the runnable.fn\n        const currentLength = queue.length\n\n        try {\n          // if we have a fn.length that means we\n          // are accepting a done callback and need\n          // to change the semantics around how we\n          // attach the run queue\n          let done\n\n          if (fn.length) {\n            const originalDone = arguments[0]\n\n            arguments[0] = (done = function (err) {\n              // TODO: handle no longer error\n              // when ended early\n              doneEarly()\n\n              originalDone(err)\n\n              // return null else we there are situations\n              // where returning a regular bluebird promise\n              // results in a warning about promise being created\n              // in a handler but not returned\n              return null\n            })\n\n            // store this done property\n            // for async tests\n            state('done', done)\n          }\n\n          let ret = __stackReplacementMarker(fn, this, arguments)\n\n          // if we returned a value from fn\n          // and enqueued some new commands\n          // and the value isnt currently cy\n          // or a promise\n          if (ret &&\n            (queue.length > currentLength) &&\n              (!isCy(ret)) &&\n                (!isPromiseLike(ret))) {\n            // TODO: clean this up in the utility function\n            // to conditionally stringify functions\n            ret = _.isFunction(ret) ?\n              ret.toString()\n              :\n              $utils.stringify(ret)\n\n            $errUtils.throwErrByPath('miscellaneous.returned_value_and_commands', {\n              args: { returned: ret },\n            })\n          }\n\n          // if we attached a done callback\n          // and returned a promise then we\n          // need to automatically bind to\n          // .catch() and return done(err)\n          // TODO: this has gone away in mocha 3.x.x\n          // due to overspecifying a resolution.\n          // in those cases we need to remove\n          // returning a promise\n          if (fn.length && ret && ret.catch) {\n            ret = ret.catch(done)\n          }\n\n          // if we returned a promise like object\n          if ((!isCy(ret)) && isPromiseLike(ret)) {\n            // indicate we've returned a custom promise\n            state('returnedCustomPromise', true)\n\n            // this means we instantiated a promise\n            // and we've already invoked multiple\n            // commands and should warn\n            if (queue.length > currentLength) {\n              warnMixingPromisesAndCommands()\n            }\n\n            return ret\n          }\n\n          // if we're cy or we've enqueued commands\n          if (isCy(ret) || (queue.length > currentLength)) {\n            if (fn.length) {\n              // if user has passed done callback don't return anything\n              // so we don't get an 'overspecified' error from mocha\n              return\n            }\n\n            // otherwise, return the 'queue promise', so mocha awaits it\n            return state('promise')\n          }\n\n          // else just return ret\n          return ret\n        } catch (err) {\n          // if runnable.fn threw synchronously, then it didnt fail from\n          // a cypress command, but we should still teardown and handle\n          // the error\n          return fail(err)\n        }\n      }\n    },\n  })\n\n  setTopOnError(Cypress, cy)\n\n  // make cy global in the specWindow\n  specWindow.cy = cy\n\n  $Events.extend(cy)\n\n  return cy\n}\n\nmodule.exports = {\n  create,\n}\n",
    "packages/driver/src/cypress/source_map_utils.js": "const _ = require('lodash')\nconst { SourceMapConsumer } = require('source-map')\nconst Promise = require('bluebird')\n\nconst $utils = require('./utils')\n\nconst sourceMapExtractionRegex = /\\/\\/\\s*[@#]\\s*sourceMappingURL\\s*=\\s*(data:[^\\s]*)/g\nconst regexDataUrl = /data:[^;\\n]+(?:;charset=[^;\\n]+)?;base64,([a-zA-Z0-9+/]+={0,2})/ // matches data urls\n\nlet sourceMapConsumers = {}\n\nconst initializeSourceMapConsumer = (file, sourceMap) => {\n  if (!sourceMap) return Promise.resolve(null)\n\n  SourceMapConsumer.initialize({\n    'lib/mappings.wasm': require('source-map/lib/mappings.wasm'),\n  })\n\n  return Promise.resolve(new SourceMapConsumer(sourceMap)).then((consumer) => {\n    sourceMapConsumers[file.fullyQualifiedUrl] = consumer\n\n    return consumer\n  })\n}\n\nconst extractSourceMap = (file, fileContents) => {\n  let sourceMapMatch = fileContents.match(sourceMapExtractionRegex)\n\n  if (!sourceMapMatch) return null\n\n  const url = _.last(sourceMapMatch)\n  const dataUrlMatch = url.match(regexDataUrl)\n\n  if (!dataUrlMatch) return null\n\n  const sourceMapBase64 = dataUrlMatch[1]\n  const sourceMap = base64toJs(sourceMapBase64)\n\n  return sourceMap\n}\n\nconst getSourceContents = (filePath, sourceFile) => {\n  if (!sourceMapConsumers[filePath]) return null\n\n  try {\n    return sourceMapConsumers[filePath].sourceContentFor(sourceFile)\n  } catch (err) {\n    // ignore the sourceFile not being in the source map. there's nothing we\n    // can do about it and we don't want to thrown an exception\n    if (err && err.message.indexOf('not in the SourceMap') > -1) return\n\n    throw err\n  }\n}\n\nconst getSourcePosition = (filePath, position) => {\n  const sourceMapConsumer = sourceMapConsumers[filePath]\n\n  if (!sourceMapConsumer) return null\n\n  const sourcePosition = sourceMapConsumer.originalPositionFor(position)\n  const { source, line, column } = sourcePosition\n\n  if (!source || line == null || column == null) return\n\n  // if the file is outside of the projectRoot\n  // originalPositionFor will not provide the correct relative path\n  // https://github.com/cypress-io/cypress/issues/16255\n  const sourceIndex = sourceMapConsumer._absoluteSources.indexOf(source)\n  const file = sourceMapConsumer._sources.at(sourceIndex)\n\n  return {\n    file,\n    line,\n    column,\n  }\n}\n\nconst base64toJs = (base64) => {\n  const mapString = $utils.decodeBase64Unicode(base64)\n\n  try {\n    return JSON.parse(mapString)\n  } catch (err) {\n    return null\n  }\n}\n\nmodule.exports = {\n  extractSourceMap,\n  getSourceContents,\n  getSourcePosition,\n  initializeSourceMapConsumer,\n}\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/promises_spec.js": "/* eslint-disable\n    mocha/handle-done-callback,\n    mocha/no-global-tests,\n*/\nit('catches regular promise errors', () => {\n  return Promise.reject(new Error('bar'))\n})\n\nit('catches promise errors and calls done with err even when async', (done) => {\n  return Promise.resolve(null)\n  .then(() => {\n    throw new Error('foo')\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/return_value_spec.js": "/* eslint-disable\n    mocha/no-global-tests,\n    no-undef,\n*/\nit('errors when invoking commands and return a different value', () => {\n  cy.wrap(null)\n\n  return [{}, 1, 2, 'foo', (function () {})]\n})\n\nit('errors when invoking commands in custom command and returning different value', () => {\n  Cypress.Commands.add('foo', () => {\n    cy.wrap(null)\n\n    return 'bar'\n  })\n\n  return cy.foo()\n})\n\nit('errors when not invoking commands, invoking done callback, and returning a promise', (done) => {\n  return Promise.resolve(null).then(() => {\n    return done()\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/plugin-before-browser-launch-deprecation/cypress/plugins/index.js": "const _ = require('lodash')\nconst cp = require('bluebird').promisifyAll(require('child_process'))\nconst { expect } = require('chai')\n\nconst assertPsOutput = (strs) => {\n  if (!_.isArray(strs)) {\n    strs = [strs]\n  }\n\n  return () => {\n    return cp.execAsync('ps -fww')\n    .call('toString')\n    .then((psOutput) => {\n      _.forEach(strs, (str) => {\n        expect(psOutput, 'ps output').contain(str)\n      })\n\n      return null\n    })\n  }\n}\n\nconst getHandlersByType = (type) => {\n  switch (type) {\n    case 'return-array-mutation':\n      return {\n        onBeforeBrowserLaunch (browser, launchOptions) {\n          // this will emit a warning but only once\n          launchOptions = launchOptions.concat(['--foo'])\n          launchOptions.push('--foo=bar')\n          launchOptions.unshift('--load-extension=/foo/bar/baz.js')\n\n          return launchOptions\n        },\n        onTask: { assertPsOutput: assertPsOutput(['--foo', '--foo=bar']) },\n      }\n\n    case 'return-new-array-without-mutation':\n      return {\n        onBeforeBrowserLaunch (browser, launchOptions) {\n          // this will emit a warning\n          launchOptions = [...launchOptions, '--foo']\n\n          return launchOptions\n        },\n        onTask: { assertPsOutput: assertPsOutput('--foo') },\n      }\n\n    case 'return-launch-options-mutate-only-args-property':\n      return {\n        onBeforeBrowserLaunch (browser, launchOptions) {\n          // this will NOT emit a warning\n          launchOptions.args.push('--foo')\n          launchOptions.args.unshift('--bar')\n\n          return launchOptions\n        },\n        onTask: { assertPsOutput: assertPsOutput(['--foo', '--bar']) },\n      }\n\n    case 'return-undefined-mutate-array':\n      return {\n        onBeforeBrowserLaunch (browser, launchOptions) {\n          // this will emit a warning\n          launchOptions.push('--foo')\n          launchOptions.push('--bar')\n\n          return\n        },\n        onTask: { assertPsOutput: assertPsOutput([]) },\n      }\n\n    case 'return-unknown-properties':\n      return {\n        onBeforeBrowserLaunch (browser, launchOptions) {\n          // this will fail with an error\n          launchOptions.foo = 'foo'\n          launchOptions.width = 800\n          launchOptions.height = 600\n\n          return launchOptions\n        },\n        onTask: {},\n      }\n\n    case 'throw-explicit-error':\n      return {\n        onBeforeBrowserLaunch (browser, launchOptions) {\n          throw new Error('Error thrown from plugins handler')\n        },\n        onTask: {},\n      }\n\n    case 'reject-promise':\n      return {\n        onBeforeBrowserLaunch (browser, launchOptions) {\n          return Promise\n          .resolve(null)\n          .then(() => {\n            throw new Error('Promise rejected from plugins handler')\n          })\n        },\n        onTask: {},\n      }\n\n    default: () => {\n      throw new Error('config.env.BEFORE_BROWSER_LAUNCH_HANDLER must be set to a valid handler type')\n    }\n  }\n}\n\nmodule.exports = (on, config) => {\n  if (config.testingType !== 'e2e') {\n    throw Error(`This is an e2e testing project. testingType should be 'e2e'. Received ${config.testingType}`)\n  }\n\n  const beforeBrowserLaunchHandler = config.env.BEFORE_BROWSER_LAUNCH_HANDLER\n\n  if (!beforeBrowserLaunchHandler) {\n    throw new Error('config.env.BEFORE_BROWSER_LAUNCH_HANDLER must be set to a valid handler type')\n  }\n\n  const { onBeforeBrowserLaunch, onTask } = getHandlersByType(beforeBrowserLaunchHandler)\n\n  on('before:browser:launch', onBeforeBrowserLaunch)\n  on('task', onTask)\n}\n",
    "scripts/binary/build.js": "const _ = require('lodash')\nconst fse = require('fs-extra')\nconst os = require('os')\nconst del = require('del')\nconst path = require('path')\nconst cp = require('child_process')\nconst chalk = require('chalk')\nconst Promise = require('bluebird')\nconst pluralize = require('pluralize')\nconst execa = require('execa')\nconst electron = require('@packages/electron')\nconst debug = require('debug')('cypress:binary')\nconst R = require('ramda')\nconst la = require('lazy-ass')\nconst check = require('check-more-types')\n\nconst meta = require('./meta')\nconst smoke = require('./smoke')\nconst packages = require('./util/packages')\nconst xvfb = require('../../cli/lib/exec/xvfb')\nconst { transformRequires } = require('./util/transform-requires')\nconst { testStaticAssets } = require('./util/testStaticAssets')\nconst performanceTracking = require('../../packages/server/test/support/helpers/performance.js')\n\nconst rootPackage = require('@packages/root')\n\nconst fs = Promise.promisifyAll(fse)\n\nconst logger = function (msg, platform) {\n  const time = new Date()\n  const timeStamp = time.toLocaleTimeString()\n\n  return console.log(timeStamp, chalk.yellow(msg), chalk.blue(platform))\n}\n\nconst logBuiltAllPackages = () => {\n  return console.log('built all packages')\n}\n\n// can pass options to better control the build\n// for example\n//   skipClean - do not delete \"dist\" folder before build\nconst buildCypressApp = function (platform, version, options = {}) {\n  la(check.unemptyString(version), 'missing version to build', version)\n\n  const distDir = _.partial(meta.distDir, platform)\n  const buildDir = _.partial(meta.buildDir, platform)\n  const buildAppDir = _.partial(meta.buildAppDir, platform)\n\n  const log = _.partialRight(logger, platform)\n\n  const testVersion = (folderNameFn) => {\n    return (function () {\n      log('#testVersion')\n      const dir = folderNameFn()\n\n      la(check.unemptyString(dir), 'missing folder for platform', platform)\n      console.log('testing dist package version')\n      console.log('by calling: node index.js --version')\n      console.log('in the folder %s', dir)\n\n      return execa('node', ['index.js', '--version'], {\n        cwd: dir,\n      }).then((result) => {\n        la(check.unemptyString(result.stdout),\n          'missing output when getting built version', result)\n\n        console.log('app in %s', dir)\n        console.log('built app version', result.stdout)\n        la(result.stdout === version, 'different version reported',\n          result.stdout, 'from input version to build', version)\n\n        return console.log('✅ using node --version works')\n      })\n    })\n  }\n\n  const testBuiltStaticAssets = function () {\n    log('#testBuiltStaticAssets')\n\n    return testStaticAssets(distDir())\n  }\n\n  const checkPlatform = function () {\n    log('#checkPlatform')\n    if (platform === os.platform()) {\n      return\n    }\n\n    return Promise.reject(new Error('Build platform mismatch'))\n  }\n\n  const cleanupPlatform = function () {\n    log('#cleanupPlatform')\n\n    if (options.skipClean) {\n      log('skipClean')\n\n      return\n    }\n\n    const cleanup = function () {\n      const dir = distDir()\n\n      la(check.unemptyString(dir), 'empty dist dir', dir, 'for platform', platform)\n\n      return fs.removeAsync(distDir())\n    }\n\n    return cleanup()\n    .catch(cleanup)\n  }\n\n  const buildPackages = function () {\n    log('#buildPackages')\n\n    return packages.runAllBuild()\n    // Promise.resolve()\n    .then(R.tap(logBuiltAllPackages))\n  }\n\n  const copyPackages = function () {\n    log('#copyPackages')\n\n    return packages.copyAllToDist(distDir())\n  }\n\n  const replaceLocalNpmVersions = function () {\n    log('#replaceLocalNpmVersions')\n\n    return packages.replaceLocalNpmVersions(distDir())\n  }\n\n  const npmInstallPackages = function () {\n    log('#npmInstallPackages')\n\n    const pathToPackages = distDir('packages', '*')\n\n    return packages.npmInstallAll(pathToPackages)\n  }\n\n  const cleanLocalNpmPackages = function () {\n    log('#cleanLocalNpmPackages')\n\n    return fs.removeAsync(distDir('npm'))\n  }\n\n  /**\n   * Creates the package.json file that sits in the root of the output app\n   */\n  const createRootPackage = function () {\n    log(`#createRootPackage ${platform} ${version}`)\n\n    const electronVersion = electron.getElectronVersion()\n\n    la(electronVersion, 'missing Electron version', electronVersion)\n\n    return electron.getElectronNodeVersion()\n    .then((electronNodeVersion) => {\n      la(electronNodeVersion, 'missing Electron Node version', electronNodeVersion)\n\n      const json = {\n        name: 'cypress',\n        productName: 'Cypress',\n        description: rootPackage.description,\n        version, // Cypress version\n        electronVersion,\n        electronNodeVersion,\n        main: 'index.js',\n        scripts: {},\n        env: 'production',\n      }\n\n      const outputFilename = distDir('package.json')\n\n      debug('writing to %s json %o', outputFilename, json)\n\n      return fs.outputJsonAsync(outputFilename, json)\n      .then(() => {\n        const str = `\\\nprocess.env.CYPRESS_INTERNAL_ENV = process.env.CYPRESS_INTERNAL_ENV || 'production'\nrequire('./packages/server')\\\n`\n\n        return fs.outputFileAsync(distDir('index.js'), str)\n      })\n    })\n  }\n\n  const removeTypeScript = function () {\n    // remove the .ts files in our packages\n    log('#removeTypeScript')\n\n    return del([\n      // include ts files of packages\n      distDir('**', '*.ts'),\n\n      // except those in node_modules\n      `!${distDir('**', 'node_modules', '**', '*.ts')}`,\n    ])\n    .then((paths) => {\n      console.log(\n        'deleted %d TS %s',\n        paths.length,\n        pluralize('file', paths.length),\n      )\n\n      return console.log(paths)\n    })\n  }\n\n  const cleanJs = function () {\n    log('#cleanJs')\n\n    return packages.runAllCleanJs()\n  }\n\n  const transformSymlinkRequires = function () {\n    log('#transformSymlinkRequires')\n\n    return transformRequires(distDir())\n    .then((replaceCount) => {\n      return la(replaceCount > 5, 'expected to replace more than 5 symlink requires, but only replaced', replaceCount)\n    })\n  }\n\n  // we also don't need \".bin\" links inside Electron application\n  // thus we can go through dist/packages/*/node_modules and remove all \".bin\" folders\n  const removeBinFolders = function () {\n    log('#removeBinFolders')\n\n    const searchMask = distDir('packages', '*', 'node_modules', '.bin')\n\n    console.log('searching for', searchMask)\n\n    return del([searchMask])\n    .then((paths) => {\n      console.log(\n        'deleted %d .bin %s',\n        paths.length,\n        pluralize('folder', paths.length),\n      )\n\n      return console.log(paths)\n    })\n  }\n\n  const removeCyFolders = function () {\n    log('#removeCyFolders')\n\n    const searchMask = distDir('packages', 'server', '.cy')\n\n    console.log('searching', searchMask)\n\n    return del([searchMask])\n    .then((paths) => {\n      console.log(\n        'deleted %d .cy %s',\n        paths.length,\n        pluralize('file', paths.length),\n      )\n\n      return console.log(paths)\n    })\n  }\n\n  const getIconFilename = function (platform) {\n    const filenames = {\n      darwin: 'cypress.icns',\n      win32: 'cypress.ico',\n      linux: 'icon_512x512.png',\n    }\n    const iconFilename = electron.icons().getPathToIcon(filenames[platform])\n\n    console.log(`For platform ${platform} using icon ${iconFilename}`)\n\n    return iconFilename\n  }\n\n  const removeDevElectronApp = function () {\n    log('#removeDevElectronApp')\n    // when we copy packages/electron, we get the \"dist\" folder with\n    // empty Electron app, symlinked to our server folder\n    // in production build, we do not need this link, and it\n    // would not work anyway with code signing\n\n    // hint: you can see all symlinks in the build folder\n    // using \"find build/darwin/Cypress.app/ -type l -ls\"\n    console.log('platform', platform)\n    const electronDistFolder = distDir('packages', 'electron', 'dist')\n\n    la(check.unemptyString(electronDistFolder),\n      'empty electron dist folder for platform', platform)\n\n    console.log(`Removing unnecessary folder '${electronDistFolder}'`)\n\n    return fs.removeAsync(electronDistFolder) // .catch(_.noop) why are we ignoring an error here?!\n  }\n\n  const electronPackAndSign = function () {\n    log('#electronPackAndSign')\n\n    // See the internal wiki document \"Signing Test Runner on MacOS\"\n    // to learn how to get the right Mac certificate for signing and notarizing\n    // the built Test Runner application\n\n    const appFolder = distDir()\n    const outputFolder = meta.buildRootDir(platform)\n    const electronVersion = electron.getElectronVersion()\n\n    la(check.unemptyString(electronVersion), 'missing Electron version to pack', electronVersion)\n    const iconFilename = getIconFilename(platform)\n\n    console.log(`output folder: ${outputFolder}`)\n\n    const args = [\n      '--publish=never',\n      `--c.electronVersion=${electronVersion}`,\n      `--c.directories.app=${appFolder}`,\n      `--c.directories.output=${outputFolder}`,\n      `--c.icon=${iconFilename}`,\n      // for now we cannot pack source files in asar file\n      // because electron-builder does not copy nested folders\n      // from packages/*/node_modules\n      // see https://github.com/electron-userland/electron-builder/issues/3185\n      // so we will copy those folders later ourselves\n      '--c.asar=false',\n    ]\n    const opts = {\n      stdio: 'inherit',\n    }\n\n    console.log('electron-builder arguments:')\n    console.log(args.join(' '))\n\n    return execa('electron-builder', args, opts)\n  }\n\n  const lsDistFolder = function () {\n    log('#lsDistFolder')\n    const buildFolder = buildDir()\n\n    console.log('in build folder %s', buildFolder)\n\n    return execa('ls', ['-la', buildFolder])\n    .then(R.prop('stdout'))\n    .then(console.log)\n  }\n\n  const runSmokeTests = function () {\n    log('#runSmokeTests')\n\n    const run = function () {\n      // make sure to use a longer timeout - on Mac the first\n      // launch of a built application invokes gatekeeper check\n      // which takes a couple of seconds\n      const executablePath = meta.buildAppExecutable(platform)\n\n      return smoke.test(executablePath)\n    }\n\n    if (xvfb.isNeeded()) {\n      return xvfb.start()\n      .then(run)\n      .finally(xvfb.stop)\n    }\n\n    return run()\n  }\n\n  const verifyAppCanOpen = function () {\n    if (platform !== 'darwin') {\n      return Promise.resolve()\n    }\n\n    const appFolder = meta.zipDir(platform)\n\n    log(`#verifyAppCanOpen ${appFolder}`)\n\n    return new Promise((resolve, reject) => {\n      const args = ['-a', '-vvvv', appFolder]\n\n      debug(`cmd: spctl ${args.join(' ')}`)\n      const sp = cp.spawn('spctl', args, { stdio: 'inherit' })\n\n      return sp.on('exit', (code) => {\n        if (code === 0) {\n          return resolve()\n        }\n\n        return reject(new Error('Verifying App via GateKeeper failed'))\n      })\n    })\n  }\n\n  const printPackageSizes = function () {\n    const appFolder = meta.buildAppDir(platform, 'packages')\n\n    log(`#printPackageSizes ${appFolder}`)\n\n    if (platform === 'win32') {\n      return Promise.resolve()\n    }\n\n    // \"du\" - disk usage utility\n    // -d -1 depth of 1\n    // -h human readable sizes (K and M)\n    const args = ['-d', '1', appFolder]\n\n    const parseDiskUsage = function (result) {\n      const lines = result.stdout.split(os.EOL)\n      // will store {package name: package size}\n      const data = {}\n\n      lines.forEach((line) => {\n        const parts = line.split('\\t')\n        const packageSize = parseFloat(parts[0])\n        const folder = parts[1]\n\n        const packageName = path.basename(folder)\n\n        if (packageName === 'packages') {\n          return // root \"packages\" information\n        }\n\n        data[packageName] = packageSize\n      })\n\n      return data\n    }\n\n    const printDiskUsage = function (sizes) {\n      const bySize = R.sortBy(R.prop('1'))\n\n      return console.log(bySize(R.toPairs(sizes)))\n    }\n\n    return execa('du', args)\n    .then(parseDiskUsage)\n    .then(R.tap(printDiskUsage))\n    .then((sizes) => {\n      return performanceTracking.track('test runner size', sizes)\n    })\n  }\n\n  return Promise.resolve()\n  .then(checkPlatform)\n  .then(cleanupPlatform)\n  .then(buildPackages)\n  .then(copyPackages)\n  .then(replaceLocalNpmVersions)\n  .then(npmInstallPackages)\n  .then(cleanLocalNpmPackages)\n  .then(createRootPackage)\n  .then(removeTypeScript)\n  .then(cleanJs)\n  .then(transformSymlinkRequires)\n  .then(testVersion(distDir))\n  .then(testBuiltStaticAssets)\n  .then(removeBinFolders)\n  .then(removeCyFolders)\n  .then(removeDevElectronApp)\n  .then(electronPackAndSign)\n  .then(lsDistFolder)\n  .then(testVersion(buildAppDir))\n  .then(runSmokeTests)\n  .then(verifyAppCanOpen)\n  .then(printPackageSizes)\n  .return({\n    buildDir: buildDir(),\n  })\n}\n\nmodule.exports = buildCypressApp\n",
    "scripts/binary/util/packages.js": "const _ = require('lodash')\nlet fs = require('fs-extra')\nconst path = require('path')\n// we wrap glob to handle EMFILE error\nlet glob = require('glob')\nconst Promise = require('bluebird')\nconst retry = require('bluebird-retry')\nconst la = require('lazy-ass')\nconst check = require('check-more-types')\nconst execa = require('execa')\nconst R = require('ramda')\nconst prettyMs = require('pretty-ms')\nconst pluralize = require('pluralize')\nconst debug = require('debug')('cypress:binary')\nconst externalUtils = require('./3rd-party')\n\nfs = Promise.promisifyAll(fs)\nglob = Promise.promisify(glob)\n\nconst DEFAULT_PATHS = 'package.json'.split(' ')\n\nconst pathToPackageJson = function (packageFolder) {\n  la(check.unemptyString(packageFolder), 'expected package path', packageFolder)\n\n  return path.join(packageFolder, 'package.json')\n}\n\nconst createCLIExecutable = (command) => {\n  return (function (args, cwd, env = {}) {\n    const commandToExecute = `${command} ${args.join(' ')}`\n\n    console.log(commandToExecute)\n    if (cwd) {\n      console.log('in folder:', cwd)\n    }\n\n    la(check.maybe.string(cwd), 'invalid CWD string', cwd)\n\n    return execa(command, args, { stdio: 'inherit', cwd, env })\n    // if everything is ok, resolve with nothing\n    .then(R.always(undefined))\n    .catch((result) => {\n      const msg = `${commandToExecute} failed with exit code: ${result.code}`\n\n      throw new Error(msg)\n    })\n  })\n}\n\nconst yarn = createCLIExecutable('yarn')\nconst npx = createCLIExecutable('npx')\n\nconst runAllBuild = _.partial(npx, ['lerna', 'run', 'build-prod', '--ignore', 'cli'])\n\n// removes transpiled JS files in the original package folders\nconst runAllCleanJs = _.partial(npx, ['lerna', 'run', 'clean-js', '--ignore', 'cli'])\n\nconst copyAllToDist = function (distDir) {\n  const copyRelativePathToDist = function (relative) {\n    const dest = path.join(distDir, relative)\n\n    return retry(() => {\n      console.log(relative, '->', dest)\n\n      return fs.copyAsync(relative, dest)\n    })\n  }\n\n  const copyPackage = function (pkg) {\n    console.log('** copy package: %s **', pkg)\n\n    // copies the package to dist\n    // including the default paths\n    // and any specified in package.json files\n    return Promise.resolve(fs.readJsonAsync(pathToPackageJson(pkg)))\n    .then((json) => {\n      // grab all the files that match \"files\" wildcards\n      // but without all negated files (\"!src/**/*.spec.js\" for example)\n      // and default included paths\n      // and convert to relative paths\n      return DEFAULT_PATHS\n      .concat(json.files || [])\n      .concat(json.main || [])\n    }).then((pkgFileMasks) => {\n      debug('for pkg %s have the following file masks %o', pkg, pkgFileMasks)\n      const globOptions = {\n        cwd: pkg, // search in the package folder\n        absolute: false, // and return relative file paths\n        followSymbolicLinks: false, // do not follow symlinks\n      }\n\n      return externalUtils.globby(pkgFileMasks, globOptions)\n    }).map((foundFileRelativeToPackageFolder) => {\n      return path.join(pkg, foundFileRelativeToPackageFolder)\n    })\n    .tap(debug)\n    .map(copyRelativePathToDist, { concurrency: 1 })\n  }\n\n  // fs-extra concurrency tests (copyPackage / copyRelativePathToDist)\n  // 1/1  41688\n  // 1/5  42218\n  // 1/10 42566\n  // 2/1  45041\n  // 2/2  43589\n  // 3/3  51399\n\n  // cp -R concurrency tests\n  // 1/1 65811\n\n  const started = new Date()\n\n  return fs.ensureDirAsync(distDir)\n  .then(() => {\n    const globs = ['./packages/*', './npm/*']\n    const globOptions = {\n      onlyFiles: false,\n    }\n\n    return Promise.resolve(externalUtils.globby(globs, globOptions))\n    .map(copyPackage, { concurrency: 1 })\n  }).then(() => {\n    console.log('Finished Copying %dms', new Date() - started)\n\n    return console.log('')\n  })\n}\n\n// replaces local npm version 0.0.0-development\n// with the path to the package\n// we need to do this instead of just changing the symlink (like we do for require('@packages/...'))\n// so the packages actually get installed to node_modules and work with peer dependencies\nconst replaceLocalNpmVersions = function (basePath) {\n  const visited = []\n\n  const updateNpmPackage = function (pkg) {\n    if (!visited.includes(pkg)) {\n      visited.push(pkg)\n\n      return updatePackageJson(`./npm/${pkg}/package.json`)\n    }\n\n    return Promise.resolve()\n  }\n\n  const updatePackageJson = function (pattern) {\n    return Promise.resolve(glob(pattern, { cwd: basePath }))\n    .map((pkgPath) => {\n      const pkgJsonPath = path.join(basePath, pkgPath)\n\n      return fs.readJsonAsync(pkgJsonPath)\n      .then((json) => {\n        const { dependencies } = json\n        let shouldWriteFile = false\n\n        if (dependencies) {\n          return Promise.all(_.map(dependencies, (version, pkg) => {\n            const parsedPkg = /(@cypress\\/)(.*)/g.exec(pkg)\n\n            if (parsedPkg && parsedPkg.length === 3 && version === '0.0.0-development') {\n              const pkgName = parsedPkg[2]\n\n              json.dependencies[`@cypress/${pkgName}`] = `file:${path.join(basePath, 'npm', pkgName)}`\n              shouldWriteFile = true\n\n              return updateNpmPackage(pkgName)\n            }\n          }))\n          .then(() => {\n            if (shouldWriteFile) {\n              return fs.writeJsonAsync(pkgJsonPath, json, { spaces: 2 })\n            }\n          })\n        }\n\n        return Promise.resolve()\n      })\n    })\n  }\n\n  return updatePackageJson('./packages/*/package.json')\n}\n\nconst forceNpmInstall = function (packagePath, packageToInstall) {\n  console.log('Force installing %s', packageToInstall)\n  console.log('in %s', packagePath)\n  la(check.unemptyString(packageToInstall), 'missing package to install')\n\n  return yarn(['install', '--force', packageToInstall], packagePath)\n}\n\nconst removeDevDependencies = function (packageFolder) {\n  const packagePath = pathToPackageJson(packageFolder)\n\n  console.log('removing devDependencies from %s', packagePath)\n\n  return fs.readJsonAsync(packagePath)\n  .then((json) => {\n    delete json.devDependencies\n\n    return fs.writeJsonAsync(packagePath, json, { spaces: 2 })\n  })\n}\n\nconst retryGlobbing = function (pathToPackages, delay = 1000) {\n  const retryGlob = () => {\n    return glob(pathToPackages)\n    .catch({ code: 'EMFILE' }, () => {\n      // wait, then retry\n      return Promise\n      .delay(delay)\n      .then(retryGlob)\n    })\n  }\n\n  return retryGlob()\n}\n\n// installs all packages given a wildcard\n// pathToPackages would be something like \"C:\\projects\\cypress\\dist\\win32\\packages\\*\"\nconst npmInstallAll = function (pathToPackages) {\n  console.log(`npmInstallAll packages in ${pathToPackages}`)\n\n  const started = new Date()\n\n  const retryNpmInstall = function (pkg) {\n    console.log('installing %s', pkg)\n    console.log('NODE_ENV is %s', process.env.NODE_ENV)\n\n    // force installing only PRODUCTION dependencies\n    // https://docs.npmjs.com/cli/install\n    const npmInstall = _.partial(yarn, ['install', '--production'])\n\n    return npmInstall(pkg, { NODE_ENV: 'production' })\n    .catch({ code: 'EMFILE' }, () => {\n      return Promise\n      .delay(1000)\n      .then(() => {\n        return retryNpmInstall(pkg)\n      })\n    }).catch((err) => {\n      console.log(err, err.code)\n      throw err\n    })\n  }\n\n  const printFolders = (folders) => {\n    return console.log('found %s', pluralize('folder', folders.length, true))\n  }\n\n  // only installs production dependencies\n  return retryGlobbing(pathToPackages)\n  .tap(printFolders)\n  .mapSeries((packageFolder) => {\n    return removeDevDependencies(packageFolder)\n    .then(() => {\n      return retryNpmInstall(packageFolder)\n    })\n  }).then(() => {\n    const end = new Date()\n\n    return console.log('Finished NPM Installing', prettyMs(end - started))\n  })\n}\n\nmodule.exports = {\n  runAllBuild,\n\n  copyAllToDist,\n\n  npmInstallAll,\n\n  runAllCleanJs,\n\n  forceNpmInstall,\n\n  replaceLocalNpmVersions,\n}\n\nif (!module.parent) {\n  console.log('demo force install')\n  forceNpmInstall('packages/server', '@ffmpeg-installer/win32-x64')\n}\n",
    "cli/lib/cli.js": "// @ts-check\nconst _ = require('lodash')\nconst R = require('ramda')\nconst commander = require('commander')\nconst { stripIndent } = require('common-tags')\nconst logSymbols = require('log-symbols')\nconst debug = require('debug')('cypress:cli:cli')\nconst util = require('./util')\nconst logger = require('./logger')\nconst errors = require('./errors')\nconst cache = require('./tasks/cache')\n\n// patch \"commander\" method called when a user passed an unknown option\n// we want to print help for the current command and exit with an error\nfunction unknownOption (flag, type = 'option') {\n  if (this._allowUnknownOption) return\n\n  logger.error()\n  logger.error(`  error: unknown ${type}:`, flag)\n  logger.error()\n  this.outputHelp()\n  util.exit(1)\n}\ncommander.Command.prototype.unknownOption = unknownOption\n\nconst coerceFalseOrString = (arg) => {\n  return arg !== 'false' ? arg : false\n}\n\nconst coerceFalse = (arg) => {\n  return arg !== 'false'\n}\n\nconst coerceAnyStringToInt = (arg) => {\n  return typeof arg === 'string' ? parseInt(arg) : arg\n}\n\nconst spaceDelimitedArgsMsg = (flag, args) => {\n  let msg = `\n    ${logSymbols.warning} Warning: It looks like you're passing --${flag} a space-separated list of arguments:\n\n    \"${args.join(' ')}\"\n\n    This will work, but it's not recommended.\n\n    If you are trying to pass multiple arguments, separate them with commas instead:\n      cypress run --${flag} arg1,arg2,arg3\n  `\n\n  if (flag === 'spec') {\n    msg += `\n    The most common cause of this warning is using an unescaped glob pattern. If you are\n    trying to pass a glob pattern, escape it using quotes:\n      cypress run --spec \"**/*.spec.js\"\n    `\n  }\n\n  logger.log()\n  logger.warn(stripIndent(msg))\n  logger.log()\n}\n\nconst parseVariableOpts = (fnArgs, args) => {\n  const [opts, unknownArgs] = fnArgs\n\n  if ((unknownArgs && unknownArgs.length) && (opts.spec || opts.tag)) {\n    // this will capture space-delimited args after\n    // flags that could have possible multiple args\n    // but before the next option\n    // --spec spec1 spec2 or --tag foo bar\n\n    const multiArgFlags = _.compact([\n      opts.spec ? 'spec' : opts.spec,\n      opts.tag ? 'tag' : opts.tag,\n    ])\n\n    _.forEach(multiArgFlags, (flag) => {\n      const argIndex = _.indexOf(args, `--${flag}`) + 2\n      const nextOptOffset = _.findIndex(_.slice(args, argIndex), (arg) => {\n        return _.startsWith(arg, '--')\n      })\n      const endIndex = nextOptOffset !== -1 ? argIndex + nextOptOffset : args.length\n\n      const maybeArgs = _.slice(args, argIndex, endIndex)\n      const extraArgs = _.intersection(maybeArgs, unknownArgs)\n\n      if (extraArgs.length) {\n        opts[flag] = [opts[flag]].concat(extraArgs)\n        spaceDelimitedArgsMsg(flag, opts[flag])\n        opts[flag] = opts[flag].join(',')\n      }\n    })\n  }\n\n  debug('variable-length opts parsed %o', { args, opts })\n\n  return util.parseOpts(opts)\n}\n\nconst descriptions = {\n  browserOpenMode: 'path to a custom browser to be added to the list of available browsers in Cypress',\n  browserRunMode: 'runs Cypress in the browser with the given name. if a filesystem path is supplied, Cypress will attempt to use the browser at that path.',\n  cacheClear: 'delete all cached binaries',\n  cachePrune: 'deletes all cached binaries except for the version currently in use',\n  cacheList: 'list cached binary versions',\n  cachePath: 'print the path to the binary cache',\n  cacheSize: 'Used with the list command to show the sizes of the cached folders',\n  ciBuildId: 'the unique identifier for a run on your CI provider. typically a \"BUILD_ID\" env var. this value is automatically detected for most CI providers',\n  config: 'sets configuration values. separate multiple values with a comma. overrides any value in cypress.json.',\n  configFile: 'path to JSON file where configuration values are set. defaults to \"cypress.json\". pass \"false\" to disable.',\n  detached: 'runs Cypress application in detached mode',\n  dev: 'runs cypress in development and bypasses binary check',\n  env: 'sets environment variables. separate multiple values with a comma. overrides any value in cypress.json or cypress.env.json',\n  exit: 'keep the browser open after tests finish',\n  forceInstall: 'force install the Cypress binary',\n  global: 'force Cypress into global mode as if its globally installed',\n  group: 'a named group for recorded runs in the Cypress Dashboard',\n  headed: 'displays the browser instead of running headlessly (defaults to true for Firefox and Chromium-family browsers)',\n  headless: 'hide the browser instead of running headed (defaults to true for Electron)',\n  key: 'your secret Record Key. you can omit this if you set a CYPRESS_RECORD_KEY environment variable.',\n  parallel: 'enables concurrent runs and automatic load balancing of specs across multiple machines or processes',\n  port: 'runs Cypress on a specific port. overrides any value in cypress.json.',\n  project: 'path to the project',\n  quiet: 'run quietly, using only the configured reporter',\n  record: 'records the run. sends test results, screenshots and videos to your Cypress Dashboard.',\n  reporter: 'runs a specific mocha reporter. pass a path to use a custom reporter. defaults to \"spec\"',\n  reporterOptions: 'options for the mocha reporter. defaults to \"null\"',\n  spec: 'runs specific spec file(s). defaults to \"all\"',\n  tag: 'named tag(s) for recorded runs in the Cypress Dashboard',\n  version: 'prints Cypress version',\n}\n\nconst knownCommands = [\n  'cache',\n  'help',\n  '-h',\n  '--help',\n  'install',\n  'open',\n  'run',\n  'open-ct',\n  'run-ct',\n  'verify',\n  '-v',\n  '--version',\n  'version',\n  'info',\n]\n\nconst text = (description) => {\n  if (!descriptions[description]) {\n    throw new Error(`Could not find description for: ${description}`)\n  }\n\n  return descriptions[description]\n}\n\nfunction includesVersion (args) {\n  return (\n    _.includes(args, 'version') ||\n    _.includes(args, '--version') ||\n    _.includes(args, '-v')\n  )\n}\n\nfunction showVersions (args) {\n  debug('printing Cypress version')\n  debug('additional arguments %o', args)\n\n  const versionParser = commander.option(\n    '--component <package|binary|electron|node>', 'component to report version for',\n  )\n  .allowUnknownOption(true)\n  const parsed = versionParser.parse(args)\n  const parsedOptions = {\n    component: parsed.component,\n  }\n\n  debug('parsed version arguments %o', parsedOptions)\n\n  const reportAllVersions = (versions) => {\n    logger.always('Cypress package version:', versions.package)\n    logger.always('Cypress binary version:', versions.binary)\n    logger.always('Electron version:', versions.electronVersion)\n    logger.always('Bundled Node version:', versions.electronNodeVersion)\n  }\n\n  const reportComponentVersion = (componentName, versions) => {\n    const names = {\n      package: 'package',\n      binary: 'binary',\n      electron: 'electronVersion',\n      node: 'electronNodeVersion',\n    }\n\n    if (!names[componentName]) {\n      throw new Error(`Unknown component name \"${componentName}\"`)\n    }\n\n    const name = names[componentName]\n\n    if (!versions[name]) {\n      throw new Error(`Cannot find version for component \"${componentName}\" under property \"${name}\"`)\n    }\n\n    const version = versions[name]\n\n    logger.always(version)\n  }\n\n  const defaultVersions = {\n    package: undefined,\n    binary: undefined,\n    electronVersion: undefined,\n    electronNodeVersion: undefined,\n  }\n\n  return require('./exec/versions')\n  .getVersions()\n  .then((versions = defaultVersions) => {\n    if (parsedOptions.component) {\n      reportComponentVersion(parsedOptions.component, versions)\n    } else {\n      reportAllVersions(versions)\n    }\n\n    process.exit(0)\n  })\n  .catch(util.logErrorExit1)\n}\n\nconst createProgram = () => {\n  const program = new commander.Command()\n\n  // bug in commander not printing name\n  // in usage help docs\n  program._name = 'cypress'\n\n  program.usage('<command> [options]')\n\n  return program\n}\n\nconst addCypressRunCommand = (program) => {\n  return program\n  .command('run')\n  .usage('[options]')\n  .description('Runs Cypress tests from the CLI without the GUI')\n  .option('-b, --browser <browser-name-or-path>', text('browserRunMode'))\n  .option('--ci-build-id <id>', text('ciBuildId'))\n  .option('-c, --config <config>', text('config'))\n  .option('-C, --config-file <config-file>', text('configFile'))\n  .option('-e, --env <env>', text('env'))\n  .option('--group <name>', text('group'))\n  .option('-k, --key <record-key>', text('key'))\n  .option('--headed', text('headed'))\n  .option('--headless', text('headless'))\n  .option('--no-exit', text('exit'))\n  .option('--parallel', text('parallel'))\n  .option('-p, --port <port>', text('port'))\n  .option('-P, --project <project-path>', text('project'))\n  .option('-q, --quiet', text('quiet'))\n  .option('--record [bool]', text('record'), coerceFalse)\n  .option('-r, --reporter <reporter>', text('reporter'))\n  .option('-o, --reporter-options <reporter-options>', text('reporterOptions'))\n  .option('-s, --spec <spec>', text('spec'))\n  .option('-t, --tag <tag>', text('tag'))\n  .option('--dev', text('dev'), coerceFalse)\n}\n\n/**\n * Casts known command line options for \"cypress run\" to their intended type.\n * For example if the user passes \"--port 5005\" the \".port\" property should be\n * a number 5005 and not a string \"5005\".\n *\n * Returns a clone of the original object.\n */\nconst castCypressRunOptions = (opts) => {\n  // only properties that have type \"string | false\" in our TS definition\n  // require special handling, because CLI parsing takes care of purely\n  // boolean arguments\n  const result = R.evolve({\n    port: coerceAnyStringToInt,\n    configFile: coerceFalseOrString,\n  })(opts)\n\n  return result\n}\n\nmodule.exports = {\n  /**\n   * Parses `cypress run` command line option array into an object\n   * with options that you can feed into a `cypress.run()` module API call.\n   * @example\n   *  const options = parseRunCommand(['cypress', 'run', '--browser', 'chrome'])\n   *  // options is {browser: 'chrome'}\n   */\n  parseRunCommand (args) {\n    return new Promise((resolve, reject) => {\n      if (!Array.isArray(args)) {\n        return reject(new Error('Expected array of arguments'))\n      }\n\n      // make a copy of the input arguments array\n      // and add placeholders where \"node ...\" would usually be\n      // also remove \"cypress\" keyword at the start if present\n      const cliArgs = args[0] === 'cypress' ? [...args.slice(1)] : [...args]\n\n      cliArgs.unshift(null, null)\n\n      debug('creating program parser')\n      const program = createProgram()\n\n      addCypressRunCommand(program)\n      .action((...fnArgs) => {\n        debug('parsed Cypress run %o', fnArgs)\n        const options = parseVariableOpts(fnArgs, cliArgs)\n\n        debug('parsed options %o', options)\n\n        const casted = castCypressRunOptions(options)\n\n        debug('casted options %o', casted)\n        resolve(casted)\n      })\n\n      debug('parsing args: %o', cliArgs)\n      program.parse(cliArgs)\n    })\n  },\n\n  /**\n   * Parses the command line and kicks off Cypress process.\n   */\n  init (args) {\n    if (!args) {\n      args = process.argv\n    }\n\n    const { CYPRESS_INTERNAL_ENV } = process.env\n\n    if (!util.isValidCypressInternalEnvValue(CYPRESS_INTERNAL_ENV)) {\n      debug('invalid CYPRESS_INTERNAL_ENV value', CYPRESS_INTERNAL_ENV)\n\n      return errors.exitWithError(errors.errors.invalidCypressEnv)(\n        `CYPRESS_INTERNAL_ENV=${CYPRESS_INTERNAL_ENV}`,\n      )\n    }\n\n    if (util.isNonProductionCypressInternalEnvValue(CYPRESS_INTERNAL_ENV)) {\n      debug('non-production CYPRESS_INTERNAL_ENV value', CYPRESS_INTERNAL_ENV)\n\n      let msg = `\n        ${logSymbols.warning} Warning: It looks like you're passing CYPRESS_INTERNAL_ENV=${CYPRESS_INTERNAL_ENV}\n\n        The environment variable \"CYPRESS_INTERNAL_ENV\" is reserved and should only be used internally.\n\n        Unset the \"CYPRESS_INTERNAL_ENV\" environment variable and run Cypress again.\n      `\n\n      logger.log()\n      logger.warn(stripIndent(msg))\n      logger.log()\n    }\n\n    const program = createProgram()\n\n    program\n    .command('help')\n    .description('Shows CLI help and exits')\n    .action(() => {\n      program.help()\n    })\n\n    program\n    .option('-v, --version', text('version'))\n    .command('version')\n    .description(text('version'))\n    .action(() => {\n      showVersions(args)\n    })\n\n    program\n    .command('open')\n    .usage('[options]')\n    .description('Opens Cypress in the interactive GUI.')\n    .option('-b, --browser <browser-path>', text('browserOpenMode'))\n    .option('-c, --config <config>', text('config'))\n    .option('-C, --config-file <config-file>', text('configFile'))\n    .option('-d, --detached [bool]', text('detached'), coerceFalse)\n    .option('-e, --env <env>', text('env'))\n    .option('--global', text('global'))\n    .option('-p, --port <port>', text('port'))\n    .option('-P, --project <project-path>', text('project'))\n    .option('--dev', text('dev'), coerceFalse)\n    .action((opts) => {\n      debug('opening Cypress')\n      require('./exec/open')\n      .start(util.parseOpts(opts))\n      .catch(util.logErrorExit1)\n    })\n\n    addCypressRunCommand(program)\n    .action((...fnArgs) => {\n      debug('running Cypress with args %o', fnArgs)\n      require('./exec/run')\n      .start(parseVariableOpts(fnArgs, args))\n      .then(util.exit)\n      .catch(util.logErrorExit1)\n    })\n\n    program\n    .command('open-ct')\n    .usage('[options]')\n    .description('Opens Cypress component testing interactive mode.')\n    .option('-b, --browser <browser-path>', text('browserOpenMode'))\n    .option('-c, --config <config>', text('config'))\n    .option('-C, --config-file <config-file>', text('configFile'))\n    .option('-d, --detached [bool]', text('detached'), coerceFalse)\n    .option('-e, --env <env>', text('env'))\n    .option('--global', text('global'))\n    .option('-p, --port <port>', text('port'))\n    .option('-P, --project <project-path>', text('project'))\n    .option('--dev', text('dev'), coerceFalse)\n    .action((opts) => {\n      debug('opening Cypress')\n      require('./exec/open')\n      .start({ ...util.parseOpts(opts), testingType: 'component' })\n      .catch(util.logErrorExit1)\n    })\n\n    program\n    .command('run-ct')\n    .usage('[options]')\n    .description('Runs all Cypress Component Testing suites')\n    .option('-b, --browser <browser-name-or-path>', text('browserRunMode'))\n    .option('--ci-build-id <id>', text('ciBuildId'))\n    .option('-c, --config <config>', text('config'))\n    .option('-C, --config-file <config-file>', text('configFile'))\n    .option('-e, --env <env>', text('env'))\n    .option('--group <name>', text('group'))\n    .option('-k, --key <record-key>', text('key'))\n    .option('--headed', text('headed'))\n    .option('--headless', text('headless'))\n    .option('--no-exit', text('exit'))\n    .option('--parallel', text('parallel'))\n    .option('-p, --port <port>', text('port'))\n    .option('-P, --project <project-path>', text('project'))\n    .option('-q, --quiet', text('quiet'))\n    .option('--record [bool]', text('record'), coerceFalse)\n    .option('-r, --reporter <reporter>', text('reporter'))\n    .option('-o, --reporter-options <reporter-options>', text('reporterOptions'))\n    .option('-s, --spec <spec>', text('spec'))\n    .option('-t, --tag <tag>', text('tag'))\n    .option('--dev', text('dev'), coerceFalse)\n    .action((opts) => {\n      debug('running Cypress run-ct')\n      require('./exec/run')\n      .start({ ...util.parseOpts(opts), testingType: 'component' })\n      .then(util.exit)\n      .catch(util.logErrorExit1)\n    })\n\n    program\n    .command('install')\n    .usage('[options]')\n    .description(\n      'Installs the Cypress executable matching this package\\'s version',\n    )\n    .option('-f, --force', text('forceInstall'))\n    .action((opts) => {\n      require('./tasks/install')\n      .start(util.parseOpts(opts))\n      .catch(util.logErrorExit1)\n    })\n\n    program\n    .command('verify')\n    .usage('[options]')\n    .description(\n      'Verifies that Cypress is installed correctly and executable',\n    )\n    .option('--dev', text('dev'), coerceFalse)\n    .action((opts) => {\n      const defaultOpts = { force: true, welcomeMessage: false }\n      const parsedOpts = util.parseOpts(opts)\n      const options = _.extend(parsedOpts, defaultOpts)\n\n      require('./tasks/verify')\n      .start(options)\n      .catch(util.logErrorExit1)\n    })\n\n    program\n    .command('cache')\n    .usage('[command]')\n    .description('Manages the Cypress binary cache')\n    .option('list', text('cacheList'))\n    .option('path', text('cachePath'))\n    .option('clear', text('cacheClear'))\n    .option('prune', text('cachePrune'))\n    .option('--size', text('cacheSize'))\n    .action(function (opts, args) {\n      if (!args || !args.length) {\n        this.outputHelp()\n        util.exit(1)\n      }\n\n      const [command] = args\n\n      if (!_.includes(['list', 'path', 'clear', 'prune'], command)) {\n        unknownOption.call(this, `cache ${command}`, 'command')\n      }\n\n      if (command === 'list') {\n        debug('cache command %o', {\n          command,\n          size: opts.size,\n        })\n\n        return cache.list(opts.size)\n        .catch({ code: 'ENOENT' }, () => {\n          logger.always('No cached binary versions were found.')\n          process.exit(0)\n        })\n        .catch((e) => {\n          debug('cache list command failed with \"%s\"', e.message)\n\n          util.logErrorExit1(e)\n        })\n      }\n\n      cache[command]()\n    })\n\n    program\n    .command('info')\n    .usage('[command]')\n    .description('Prints Cypress and system information')\n    .option('--dev', text('dev'), coerceFalse)\n    .action((opts) => {\n      require('./exec/info')\n      .start(opts)\n      .then(util.exit)\n      .catch(util.logErrorExit1)\n    })\n\n    debug('cli starts with arguments %j', args)\n    util.printNodeOptions()\n\n    // if there are no arguments\n    if (args.length <= 2) {\n      debug('printing help')\n      program.help()\n      // exits\n    }\n\n    const firstCommand = args[2]\n\n    if (!_.includes(knownCommands, firstCommand)) {\n      debug('unknown command %s', firstCommand)\n      logger.error('Unknown command', `\"${firstCommand}\"`)\n      program.outputHelp()\n\n      return util.exit(1)\n    }\n\n    if (includesVersion(args)) {\n      // commander 2.11.0 changes behavior\n      // and now does not understand top level options\n      // .option('-v, --version').command('version')\n      // so we have to manually catch '-v, --version'\n      return showVersions(args)\n    }\n\n    debug('program parsing arguments')\n\n    return program.parse(args)\n  },\n}\n\n// @ts-ignore\nif (!module.parent) {\n  logger.error('This CLI module should be required from another Node module')\n  logger.error('and not executed directly')\n  process.exit(-1)\n}\n",
    "cli/lib/exec/spawn.js": "const _ = require('lodash')\nconst os = require('os')\nconst cp = require('child_process')\nconst path = require('path')\nconst Promise = require('bluebird')\nconst debug = require('debug')('cypress:cli')\nconst debugElectron = require('debug')('cypress:electron')\n\nconst util = require('../util')\nconst state = require('../tasks/state')\nconst xvfb = require('./xvfb')\nconst verify = require('../tasks/verify')\nconst errors = require('../errors')\n\nconst isXlibOrLibudevRe = /^(?:Xlib|libudev)/\nconst isHighSierraWarningRe = /\\*\\*\\* WARNING/\nconst isRenderWorkerRe = /\\.RenderWorker-/\n\nconst GARBAGE_WARNINGS = [isXlibOrLibudevRe, isHighSierraWarningRe, isRenderWorkerRe]\n\nconst isGarbageLineWarning = (str) => {\n  return _.some(GARBAGE_WARNINGS, (re) => {\n    return re.test(str)\n  })\n}\n\nfunction isPlatform (platform) {\n  return os.platform() === platform\n}\n\nfunction needsStderrPiped (needsXvfb) {\n  return _.some([\n    isPlatform('darwin'),\n\n    (needsXvfb && isPlatform('linux')),\n\n    util.isPossibleLinuxWithIncorrectDisplay(),\n  ])\n}\n\nfunction needsEverythingPipedDirectly () {\n  return isPlatform('win32')\n}\n\nfunction getStdio (needsXvfb) {\n  if (needsEverythingPipedDirectly()) {\n    return 'pipe'\n  }\n\n  // https://github.com/cypress-io/cypress/issues/921\n  // https://github.com/cypress-io/cypress/issues/1143\n  // https://github.com/cypress-io/cypress/issues/1745\n  if (needsStderrPiped(needsXvfb)) {\n    // returning pipe here so we can massage stderr\n    // and remove garbage from Xlib and libuv\n    // due to starting the Xvfb process on linux\n    return ['inherit', 'inherit', 'pipe']\n  }\n\n  return 'inherit'\n}\n\nmodule.exports = {\n  isGarbageLineWarning,\n\n  start (args, options = {}) {\n    const needsXvfb = xvfb.isNeeded()\n    let executable = state.getPathToExecutable(state.getBinaryDir())\n\n    if (util.getEnv('CYPRESS_RUN_BINARY')) {\n      executable = path.resolve(util.getEnv('CYPRESS_RUN_BINARY'))\n    }\n\n    debug('needs to start own Xvfb?', needsXvfb)\n\n    // 1. Start arguments with \"--\" so Electron knows these are OUR\n    // arguments and does not try to sanitize them. Otherwise on Windows\n    // an url in one of the arguments crashes it :(\n    // https://github.com/cypress-io/cypress/issues/5466\n\n    // 2. Always push cwd into the args\n    // which additionally acts as a signal to the\n    // binary that it was invoked through the NPM module\n    args = ['--'].concat(args, '--cwd', process.cwd())\n\n    _.defaults(options, {\n      dev: false,\n      env: process.env,\n      detached: false,\n      stdio: getStdio(needsXvfb),\n    })\n\n    const spawn = (overrides = {}) => {\n      return new Promise((resolve, reject) => {\n        _.defaults(overrides, {\n          onStderrData: false,\n          electronLogging: false,\n        })\n\n        if (options.dev) {\n          // if we're in dev then reset\n          // the launch cmd to be 'npm run dev'\n          executable = 'node'\n          args.unshift(\n            path.resolve(__dirname, '..', '..', '..', 'scripts', 'start.js'),\n          )\n\n          debug('in dev mode the args became %o', args)\n        }\n\n        const { onStderrData, electronLogging } = overrides\n        const envOverrides = util.getEnvOverrides(options)\n        const electronArgs = _.clone(args)\n        const node11WindowsFix = isPlatform('win32')\n\n        if (!options.dev && verify.needsSandbox()) {\n          // this is one of the Electron's command line switches\n          // thus it needs to be before \"--\" separator\n          electronArgs.unshift('--no-sandbox')\n        }\n\n        // strip dev out of child process options\n        let stdioOptions = _.pick(options, 'env', 'detached', 'stdio')\n\n        // figure out if we're going to be force enabling or disabling colors.\n        // also figure out whether we should force stdout and stderr into thinking\n        // it is a tty as opposed to a pipe.\n        stdioOptions.env = _.extend({}, stdioOptions.env, envOverrides)\n\n        if (node11WindowsFix) {\n          stdioOptions = _.extend({}, stdioOptions, { windowsHide: false })\n        }\n\n        if (electronLogging) {\n          stdioOptions.env.ELECTRON_ENABLE_LOGGING = true\n        }\n\n        if (util.isPossibleLinuxWithIncorrectDisplay()) {\n          // make sure we use the latest DISPLAY variable if any\n          debug('passing DISPLAY', process.env.DISPLAY)\n          stdioOptions.env.DISPLAY = process.env.DISPLAY\n        }\n\n        debug('spawning Cypress with executable: %s', executable)\n        debug('spawn args %o %o', electronArgs, _.omit(stdioOptions, 'env'))\n\n        const child = cp.spawn(executable, electronArgs, stdioOptions)\n\n        function resolveOn (event) {\n          return function (code, signal) {\n            debug('child event fired %o', { event, code, signal })\n\n            if (code === null) {\n              const errorObject = errors.errors.childProcessKilled(event, signal)\n\n              return errors.getError(errorObject).then(reject)\n            }\n\n            resolve(code)\n          }\n        }\n\n        child.on('close', resolveOn('close'))\n        child.on('exit', resolveOn('exit'))\n        child.on('error', reject)\n\n        // if stdio options is set to 'pipe', then\n        //   we should set up pipes:\n        //  process STDIN (read stream) => child STDIN (writeable)\n        //  child STDOUT => process STDOUT\n        //  child STDERR => process STDERR with additional filtering\n        if (child.stdin) {\n          debug('piping process STDIN into child STDIN')\n          process.stdin.pipe(child.stdin)\n        }\n\n        if (child.stdout) {\n          debug('piping child STDOUT to process STDOUT')\n          child.stdout.pipe(process.stdout)\n        }\n\n        // if this is defined then we are manually piping for linux\n        // to filter out the garbage\n        if (child.stderr) {\n          debug('piping child STDERR to process STDERR')\n          child.stderr.on('data', (data) => {\n            const str = data.toString()\n\n            // bail if this is warning line garbage\n            if (isGarbageLineWarning(str)) {\n              return\n            }\n\n            // if we have a callback and this explictly returns\n            // false then bail\n            if (onStderrData && onStderrData(str) === false) {\n              return\n            }\n\n            // else pass it along!\n            process.stderr.write(data)\n          })\n        }\n\n        // https://github.com/cypress-io/cypress/issues/1841\n        // https://github.com/cypress-io/cypress/issues/5241\n        // In some versions of node, it will throw on windows\n        // when you close the parent process after piping\n        // into the child process. unpiping does not seem\n        // to have any effect. so we're just catching the\n        // error here and not doing anything.\n        process.stdin.on('error', (err) => {\n          if (['EPIPE', 'ENOTCONN'].includes(err.code)) {\n            return\n          }\n\n          throw err\n        })\n\n        if (stdioOptions.detached) {\n          child.unref()\n        }\n      })\n    }\n\n    const spawnInXvfb = () => {\n      return xvfb\n      .start()\n      .then(userFriendlySpawn)\n      .finally(xvfb.stop)\n    }\n\n    const userFriendlySpawn = (linuxWithDisplayEnv) => {\n      debug('spawning, should retry on display problem?', Boolean(linuxWithDisplayEnv))\n\n      let brokenGtkDisplay\n\n      const overrides = {}\n\n      if (linuxWithDisplayEnv) {\n        _.extend(overrides, {\n          electronLogging: true,\n          onStderrData (str) {\n            // if we receive a broken pipe anywhere\n            // then we know that's why cypress exited early\n            if (util.isBrokenGtkDisplay(str)) {\n              brokenGtkDisplay = true\n            }\n\n            // we should attempt to always slurp up\n            // the stderr logs unless we've explicitly\n            // enabled the electron debug logging\n            if (!debugElectron.enabled) {\n              return false\n            }\n          },\n        })\n      }\n\n      return spawn(overrides)\n      .then((code) => {\n        if (code !== 0 && brokenGtkDisplay) {\n          util.logBrokenGtkDisplayWarning()\n\n          return spawnInXvfb()\n        }\n\n        return code\n      })\n      // we can format and handle an error message from the code above\n      // prevent wrapping error again by using \"known: undefined\" filter\n      .catch({ known: undefined }, errors.throwFormErrorText(errors.errors.unexpected))\n    }\n\n    if (needsXvfb) {\n      return spawnInXvfb()\n    }\n\n    // if we are on linux and there's already a DISPLAY\n    // set, then we may need to rerun cypress after\n    // spawning our own Xvfb server\n    const linuxWithDisplayEnv = util.isPossibleLinuxWithIncorrectDisplay()\n\n    return userFriendlySpawn(linuxWithDisplayEnv)\n  },\n}\n",
    "cli/lib/tasks/download.js": "const arch = require('arch')\nconst la = require('lazy-ass')\nconst is = require('check-more-types')\nconst os = require('os')\nconst url = require('url')\nconst path = require('path')\nconst debug = require('debug')('cypress:cli')\nconst request = require('@cypress/request')\nconst Promise = require('bluebird')\nconst requestProgress = require('request-progress')\nconst { stripIndent } = require('common-tags')\n\nconst { throwFormErrorText, errors } = require('../errors')\nconst fs = require('../fs')\nconst util = require('../util')\n\nconst defaultBaseUrl = 'https://download.cypress.io/'\n\nconst getProxyUrl = () => {\n  return process.env.HTTPS_PROXY ||\n    process.env.https_proxy ||\n    process.env.npm_config_https_proxy ||\n    process.env.HTTP_PROXY ||\n    process.env.http_proxy ||\n    process.env.npm_config_proxy ||\n    null\n}\n\nconst getRealOsArch = () => {\n  // os.arch() returns the arch for which this node was compiled\n  // we want the operating system's arch instead: x64 or x86\n\n  const osArch = arch()\n\n  if (osArch === 'x86') {\n    // match process.platform output\n    return 'ia32'\n  }\n\n  return osArch\n}\n\nconst getBaseUrl = () => {\n  if (util.getEnv('CYPRESS_DOWNLOAD_MIRROR')) {\n    let baseUrl = util.getEnv('CYPRESS_DOWNLOAD_MIRROR')\n\n    if (!baseUrl.endsWith('/')) {\n      baseUrl += '/'\n    }\n\n    return baseUrl\n  }\n\n  return defaultBaseUrl\n}\n\nconst getCA = () => {\n  return new Promise((resolve) => {\n    if (!util.getEnv('CYPRESS_DOWNLOAD_USE_CA')) {\n      resolve()\n    }\n\n    if (process.env.npm_config_ca) {\n      resolve(process.env.npm_config_ca)\n    } else if (process.env.npm_config_cafile) {\n      fs.readFile(process.env.npm_config_cafile, 'utf8')\n      .then((cafileContent) => {\n        resolve(cafileContent)\n      })\n      .catch(() => {\n        resolve()\n      })\n    } else {\n      resolve()\n    }\n  })\n}\n\nconst prepend = (urlPath) => {\n  const endpoint = url.resolve(getBaseUrl(), urlPath)\n  const platform = os.platform()\n  const arch = getRealOsArch()\n\n  return `${endpoint}?platform=${platform}&arch=${arch}`\n}\n\nconst getUrl = (version) => {\n  if (is.url(version)) {\n    debug('version is already an url', version)\n\n    return version\n  }\n\n  return version ? prepend(`desktop/${version}`) : prepend('desktop')\n}\n\nconst statusMessage = (err) => {\n  return (err.statusCode\n    ? [err.statusCode, err.statusMessage].join(' - ')\n    : err.toString())\n}\n\nconst prettyDownloadErr = (err, version) => {\n  const msg = stripIndent`\n    URL: ${getUrl(version)}\n    ${statusMessage(err)}\n  `\n\n  debug(msg)\n\n  return throwFormErrorText(errors.failedDownload)(msg)\n}\n\n/**\n * Checks checksum and file size for the given file. Allows both\n * values or just one of them to be checked.\n */\nconst verifyDownloadedFile = (filename, expectedSize, expectedChecksum) => {\n  if (expectedSize && expectedChecksum) {\n    debug('verifying checksum and file size')\n\n    return Promise.join(\n      util.getFileChecksum(filename),\n      util.getFileSize(filename),\n      (checksum, filesize) => {\n        if (checksum === expectedChecksum && filesize === expectedSize) {\n          debug('downloaded file has the expected checksum and size ✅')\n\n          return\n        }\n\n        debug('raising error: checksum or file size mismatch')\n        const text = stripIndent`\n          Corrupted download\n\n          Expected downloaded file to have checksum: ${expectedChecksum}\n          Computed checksum: ${checksum}\n\n          Expected downloaded file to have size: ${expectedSize}\n          Computed size: ${filesize}\n        `\n\n        debug(text)\n\n        throw new Error(text)\n      },\n    )\n  }\n\n  if (expectedChecksum) {\n    debug('only checking expected file checksum %d', expectedChecksum)\n\n    return util.getFileChecksum(filename)\n    .then((checksum) => {\n      if (checksum === expectedChecksum) {\n        debug('downloaded file has the expected checksum ✅')\n\n        return\n      }\n\n      debug('raising error: file checksum mismatch')\n      const text = stripIndent`\n        Corrupted download\n\n        Expected downloaded file to have checksum: ${expectedChecksum}\n        Computed checksum: ${checksum}\n      `\n\n      throw new Error(text)\n    })\n  }\n\n  if (expectedSize) {\n    // maybe we don't have a checksum, but at least CDN returns content length\n    // which we can check against the file size\n    debug('only checking expected file size %d', expectedSize)\n\n    return util.getFileSize(filename)\n    .then((filesize) => {\n      if (filesize === expectedSize) {\n        debug('downloaded file has the expected size ✅')\n\n        return\n      }\n\n      debug('raising error: file size mismatch')\n      const text = stripIndent`\n          Corrupted download\n\n          Expected downloaded file to have size: ${expectedSize}\n          Computed size: ${filesize}\n        `\n\n      throw new Error(text)\n    })\n  }\n\n  debug('downloaded file lacks checksum or size to verify')\n\n  return Promise.resolve()\n}\n\n// downloads from given url\n// return an object with\n// {filename: ..., downloaded: true}\nconst downloadFromUrl = ({ url, downloadDestination, progress, ca }) => {\n  return new Promise((resolve, reject) => {\n    const proxy = getProxyUrl()\n\n    debug('Downloading package', {\n      url,\n      proxy,\n      downloadDestination,\n    })\n\n    let redirectVersion\n\n    const reqOptions = {\n      url,\n      proxy,\n      followRedirect (response) {\n        const version = response.headers['x-version']\n\n        debug('redirect version:', version)\n        if (version) {\n          // set the version in options if we have one.\n          // this insulates us from potential redirect\n          // problems where version would be set to undefined.\n          redirectVersion = version\n        }\n\n        // yes redirect\n        return true\n      },\n    }\n\n    if (ca) {\n      debug('using custom CA details from npm config')\n      reqOptions.agentOptions = { ca }\n    }\n\n    const req = request(reqOptions)\n\n    // closure\n    let started = null\n    let expectedSize\n    let expectedChecksum\n\n    requestProgress(req, {\n      throttle: progress.throttle,\n    })\n    .on('response', (response) => {\n      // we have computed checksum and filesize during test runner binary build\n      // and have set it on the S3 object as user meta data, available via\n      // these custom headers \"x-amz-meta-...\"\n      // see https://github.com/cypress-io/cypress/pull/4092\n      expectedSize = response.headers['x-amz-meta-size'] ||\n        response.headers['content-length']\n\n      expectedChecksum = response.headers['x-amz-meta-checksum']\n\n      if (expectedChecksum) {\n        debug('expected checksum %s', expectedChecksum)\n      }\n\n      if (expectedSize) {\n        // convert from string (all Amazon custom headers are strings)\n        expectedSize = Number(expectedSize)\n        debug('expected file size %d', expectedSize)\n      }\n\n      // start counting now once we've gotten\n      // response headers\n      started = new Date()\n\n      // if our status code does not start with 200\n      if (!/^2/.test(response.statusCode)) {\n        debug('response code %d', response.statusCode)\n\n        const err = new Error(\n          stripIndent`\n          Failed downloading the Cypress binary.\n          Response code: ${response.statusCode}\n          Response message: ${response.statusMessage}\n        `,\n        )\n\n        reject(err)\n      }\n    })\n    .on('error', reject)\n    .on('progress', (state) => {\n      // total time we've elapsed\n      // starting on our first progress notification\n      const elapsed = new Date() - started\n\n      // request-progress sends a value between 0 and 1\n      const percentage = util.convertPercentToPercentage(state.percent)\n\n      const eta = util.calculateEta(percentage, elapsed)\n\n      // send up our percent and seconds remaining\n      progress.onProgress(percentage, util.secsRemaining(eta))\n    })\n    // save this download here\n    .pipe(fs.createWriteStream(downloadDestination))\n    .on('finish', () => {\n      debug('downloading finished')\n\n      verifyDownloadedFile(downloadDestination, expectedSize, expectedChecksum)\n      .then(() => {\n        return resolve(redirectVersion)\n      }, reject)\n    })\n  })\n}\n\n/**\n * Download Cypress.zip from external url to local file.\n * @param [string] version Could be \"3.3.0\" or full URL\n * @param [string] downloadDestination Local filename to save as\n */\nconst start = (opts) => {\n  let { version, downloadDestination, progress } = opts\n\n  if (!downloadDestination) {\n    la(is.unemptyString(downloadDestination), 'missing download dir', opts)\n  }\n\n  if (!progress) {\n    progress = { onProgress: () => {\n      return {}\n    } }\n  }\n\n  const url = getUrl(version)\n\n  progress.throttle = 100\n\n  debug('needed Cypress version: %s', version)\n  debug('source url %s', url)\n  debug(`downloading cypress.zip to \"${downloadDestination}\"`)\n\n  // ensure download dir exists\n  return fs.ensureDirAsync(path.dirname(downloadDestination))\n  .then(() => {\n    return getCA()\n  })\n  .then((ca) => {\n    return downloadFromUrl({ url, downloadDestination, progress, ca })\n  })\n  .catch((err) => {\n    return prettyDownloadErr(err, version)\n  })\n}\n\nmodule.exports = {\n  start,\n  getUrl,\n  getProxyUrl,\n  getCA,\n}\n",
    "cli/lib/util.js": "const _ = require('lodash')\nconst R = require('ramda')\nconst os = require('os')\nconst ospath = require('ospath')\nconst crypto = require('crypto')\nconst la = require('lazy-ass')\nconst is = require('check-more-types')\nconst tty = require('tty')\nconst path = require('path')\nconst isCi = require('is-ci')\nconst execa = require('execa')\nconst getos = require('getos')\nconst chalk = require('chalk')\nconst Promise = require('bluebird')\nconst cachedir = require('cachedir')\nconst logSymbols = require('log-symbols')\nconst executable = require('executable')\nconst { stripIndent } = require('common-tags')\nconst supportsColor = require('supports-color')\nconst isInstalledGlobally = require('is-installed-globally')\nconst pkg = require(path.join(__dirname, '..', 'package.json'))\nconst logger = require('./logger')\nconst debug = require('debug')('cypress:cli')\nconst fs = require('./fs')\n\nconst issuesUrl = 'https://github.com/cypress-io/cypress/issues'\n\nconst getosAsync = Promise.promisify(getos)\n\n/**\n * Returns SHA512 of a file\n *\n * Implementation lifted from https://github.com/sindresorhus/hasha\n * but without bringing that dependency (since hasha is Node v8+)\n */\nconst getFileChecksum = (filename) => {\n  la(is.unemptyString(filename), 'expected filename', filename)\n\n  const hashStream = () => {\n    const s = crypto.createHash('sha512')\n\n    s.setEncoding('hex')\n\n    return s\n  }\n\n  return new Promise((resolve, reject) => {\n    const stream = fs.createReadStream(filename)\n\n    stream.on('error', reject)\n    .pipe(hashStream())\n    .on('error', reject)\n    .on('finish', function () {\n      resolve(this.read())\n    })\n  })\n}\n\nconst getFileSize = (filename) => {\n  la(is.unemptyString(filename), 'expected filename', filename)\n\n  return fs.statAsync(filename).get('size')\n}\n\nconst isBrokenGtkDisplayRe = /Gtk: cannot open display/\n\nconst stringify = (val) => {\n  return _.isObject(val) ? JSON.stringify(val) : val\n}\n\nfunction normalizeModuleOptions (options = {}) {\n  return _.mapValues(options, stringify)\n}\n\n/**\n * Returns true if the platform is Linux. We do a lot of different\n * stuff on Linux (like Xvfb) and it helps to has readable code\n */\nconst isLinux = () => {\n  return os.platform() === 'linux'\n}\n\n/**\n   * If the DISPLAY variable is set incorrectly, when trying to spawn\n   * Cypress executable we get an error like this:\n  ```\n  [1005:0509/184205.663837:WARNING:browser_main_loop.cc(258)] Gtk: cannot open display: 99\n  ```\n   */\nconst isBrokenGtkDisplay = (str) => {\n  return isBrokenGtkDisplayRe.test(str)\n}\n\nconst isPossibleLinuxWithIncorrectDisplay = () => {\n  return isLinux() && process.env.DISPLAY\n}\n\nconst logBrokenGtkDisplayWarning = () => {\n  debug('Cypress exited due to a broken gtk display because of a potential invalid DISPLAY env... retrying after starting Xvfb')\n\n  // if we get this error, we are on Linux and DISPLAY is set\n  logger.warn(stripIndent`\n\n    ${logSymbols.warning} Warning: Cypress failed to start.\n\n    This is likely due to a misconfigured DISPLAY environment variable.\n\n    DISPLAY was set to: \"${process.env.DISPLAY}\"\n\n    Cypress will attempt to fix the problem and rerun.\n  `)\n\n  logger.warn()\n}\n\nfunction stdoutLineMatches (expectedLine, stdout) {\n  const lines = stdout.split('\\n').map(R.trim)\n  const lineMatches = R.equals(expectedLine)\n\n  return lines.some(lineMatches)\n}\n\n/**\n * Confirms if given value is a valid CYPRESS_INTERNAL_ENV value. Undefined values\n * are valid, because the system can set the default one.\n *\n * @param {string} value\n * @example util.isValidCypressInternalEnvValue(process.env.CYPRESS_INTERNAL_ENV)\n */\nfunction isValidCypressInternalEnvValue (value) {\n  if (_.isUndefined(value)) {\n    // will get default value\n    return true\n  }\n\n  // names of config environments, see \"packages/server/config/app.yml\"\n  const names = ['development', 'test', 'staging', 'production']\n\n  return _.includes(names, value)\n}\n\n/**\n * Confirms if given value is a non-production CYPRESS_INTERNAL_ENV value.\n * Undefined values are valid, because the system can set the default one.\n *\n * @param {string} value\n * @example util.isNonProductionCypressInternalEnvValue(process.env.CYPRESS_INTERNAL_ENV)\n */\nfunction isNonProductionCypressInternalEnvValue (value) {\n  return !_.isUndefined(value) && value !== 'production'\n}\n\n/**\n * Prints NODE_OPTIONS using debug() module, but only\n * if DEBUG=cypress... is set\n */\nfunction printNodeOptions (log = debug) {\n  if (!log.enabled) {\n    return\n  }\n\n  if (process.env.NODE_OPTIONS) {\n    log('NODE_OPTIONS=%s', process.env.NODE_OPTIONS)\n  } else {\n    log('NODE_OPTIONS is not set')\n  }\n}\n\n/**\n * Removes double quote characters\n * from the start and end of the given string IF they are both present\n *\n * @param {string} str Input string\n * @returns {string} Trimmed string or the original string if there are no double quotes around it.\n * @example\n  ```\n  dequote('\"foo\"')\n  // returns string 'foo'\n  dequote('foo')\n  // returns string 'foo'\n  ```\n */\nconst dequote = (str) => {\n  la(is.string(str), 'expected a string to remove double quotes', str)\n  if (str.length > 1 && str[0] === '\"' && str[str.length - 1] === '\"') {\n    return str.substr(1, str.length - 2)\n  }\n\n  return str\n}\n\nconst parseOpts = (opts) => {\n  opts = _.pick(opts,\n    'browser',\n    'cachePath',\n    'cacheList',\n    'cacheClear',\n    'cachePrune',\n    'ciBuildId',\n    'config',\n    'configFile',\n    'cypressVersion',\n    'destination',\n    'detached',\n    'dev',\n    'exit',\n    'env',\n    'force',\n    'global',\n    'group',\n    'headed',\n    'headless',\n    'key',\n    'path',\n    'parallel',\n    'port',\n    'project',\n    'quiet',\n    'reporter',\n    'reporterOptions',\n    'record',\n    'runProject',\n    'spec',\n    'tag')\n\n  if (opts.exit) {\n    opts = _.omit(opts, 'exit')\n  }\n\n  // some options might be quoted - which leads to unexpected results\n  // remove double quotes from certain options\n  const removeQuotes = {\n    group: dequote,\n    ciBuildId: dequote,\n  }\n  const cleanOpts = R.evolve(removeQuotes, opts)\n\n  debug('parsed cli options %o', cleanOpts)\n\n  return cleanOpts\n}\n\n/**\n * Copy of packages/server/lib/browsers/utils.ts\n * because we need same functionality in CLI to show the path :(\n */\nconst getApplicationDataFolder = (...paths) => {\n  const { env } = process\n\n  // allow overriding the app_data folder\n  const folder = env.CYPRESS_KONFIG_ENV || env.CYPRESS_INTERNAL_ENV || 'development'\n\n  const PRODUCT_NAME = pkg.productName || pkg.name\n  const OS_DATA_PATH = ospath.data()\n\n  const ELECTRON_APP_DATA_PATH = path.join(OS_DATA_PATH, PRODUCT_NAME)\n\n  const p = path.join(ELECTRON_APP_DATA_PATH, 'cy', folder, ...paths)\n\n  return p\n}\n\nconst util = {\n  normalizeModuleOptions,\n  parseOpts,\n  isValidCypressInternalEnvValue,\n  isNonProductionCypressInternalEnvValue,\n  printNodeOptions,\n\n  isCi () {\n    return isCi\n  },\n\n  getEnvOverrides (options = {}) {\n    return _\n    .chain({})\n    .extend(util.getEnvColors())\n    .extend(util.getForceTty())\n    .omitBy(_.isUndefined) // remove undefined values\n    .mapValues((value) => { // stringify to 1 or 0\n      return value ? '1' : '0'\n    })\n    .value()\n  },\n\n  getForceTty () {\n    return {\n      FORCE_STDIN_TTY: util.isTty(process.stdin.fd),\n      FORCE_STDOUT_TTY: util.isTty(process.stdout.fd),\n      FORCE_STDERR_TTY: util.isTty(process.stderr.fd),\n    }\n  },\n\n  getEnvColors () {\n    const sc = util.supportsColor()\n\n    return {\n      FORCE_COLOR: sc,\n      DEBUG_COLORS: sc,\n      MOCHA_COLORS: sc ? true : undefined,\n    }\n  },\n\n  isTty (fd) {\n    return tty.isatty(fd)\n  },\n\n  supportsColor () {\n    // if we've been explictly told not to support\n    // color then turn this off\n    if (process.env.NO_COLOR) {\n      return false\n    }\n\n    // https://github.com/cypress-io/cypress/issues/1747\n    // always return true in CI providers\n    if (process.env.CI) {\n      return true\n    }\n\n    // ensure that both stdout and stderr support color\n    return Boolean(supportsColor.stdout) && Boolean(supportsColor.stderr)\n  },\n\n  cwd () {\n    return process.cwd()\n  },\n\n  pkgVersion () {\n    return pkg.version\n  },\n\n  exit (code) {\n    process.exit(code)\n  },\n\n  logErrorExit1 (err) {\n    logger.error(err.message)\n\n    process.exit(1)\n  },\n\n  dequote,\n\n  titleize (...args) {\n    // prepend first arg with space\n    // and pad so that all messages line up\n    args[0] = _.padEnd(` ${args[0]}`, 24)\n\n    // get rid of any falsy values\n    args = _.compact(args)\n\n    return chalk.blue(...args)\n  },\n\n  calculateEta (percent, elapsed) {\n    // returns the number of seconds remaining\n\n    // if we're at 100% already just return 0\n    if (percent === 100) {\n      return 0\n    }\n\n    // take the percentage and divide by one\n    // and multiple that against elapsed\n    // subtracting what's already elapsed\n    return elapsed * (1 / (percent / 100)) - elapsed\n  },\n\n  convertPercentToPercentage (num) {\n    // convert a percent with values between 0 and 1\n    // with decimals, so that it is between 0 and 100\n    // and has no decimal places\n    return Math.round(_.isFinite(num) ? (num * 100) : 0)\n  },\n\n  secsRemaining (eta) {\n    // calculate the seconds reminaing with no decimal places\n    return (_.isFinite(eta) ? (eta / 1000) : 0).toFixed(0)\n  },\n\n  setTaskTitle (task, title, renderer) {\n    // only update the renderer title when not running in CI\n    if (renderer === 'default' && task.title !== title) {\n      task.title = title\n    }\n  },\n\n  isInstalledGlobally () {\n    return isInstalledGlobally\n  },\n\n  isSemver (str) {\n    return /^(\\d+\\.)?(\\d+\\.)?(\\*|\\d+)$/.test(str)\n  },\n\n  isExecutableAsync (filePath) {\n    return Promise.resolve(executable(filePath))\n  },\n\n  isLinux,\n\n  getOsVersionAsync () {\n    return Promise.try(() => {\n      if (isLinux()) {\n        return getosAsync()\n        .then((osInfo) => {\n          return [osInfo.dist, osInfo.release].join(' - ')\n        })\n        .catch(() => {\n          return os.release()\n        })\n      }\n\n      return os.release()\n    })\n  },\n\n  getPlatformInfo () {\n    return util.getOsVersionAsync().then((version) => {\n      return stripIndent`\n        Platform: ${os.platform()} (${version})\n        Cypress Version: ${util.pkgVersion()}\n      `\n    })\n  },\n\n  // attention:\n  // when passing relative path to NPM post install hook, the current working\n  // directory is set to the `node_modules/cypress` folder\n  // the user is probably passing relative path with respect to root package folder\n  formAbsolutePath (filename) {\n    if (path.isAbsolute(filename)) {\n      return filename\n    }\n\n    return path.join(process.cwd(), '..', '..', filename)\n  },\n\n  getEnv (varName, trim) {\n    la(is.unemptyString(varName), 'expected environment variable name, not', varName)\n\n    const configVarName = `npm_config_${varName}`\n    const packageConfigVarName = `npm_package_config_${varName}`\n\n    let result\n\n    if (process.env.hasOwnProperty(varName)) {\n      debug(`Using ${varName} from environment variable`)\n\n      result = process.env[varName]\n    } else if (process.env.hasOwnProperty(configVarName)) {\n      debug(`Using ${varName} from npm config`)\n\n      result = process.env[configVarName]\n    } else if (process.env.hasOwnProperty(packageConfigVarName)) {\n      debug(`Using ${varName} from package.json config`)\n\n      result = process.env[packageConfigVarName]\n    }\n\n    // environment variables are often set double quotes to escape characters\n    // and on Windows it can lead to weird things: for example\n    //  set FOO=\"C:\\foo.txt\" && node -e \"console.log('>>>%s<<<', process.env.FOO)\"\n    // will print\n    //    >>>\"C:\\foo.txt\" <<<\n    // see https://github.com/cypress-io/cypress/issues/4506#issuecomment-506029942\n    // so for sanity sake we should first trim whitespace characters and remove\n    // double quotes around environment strings if the caller is expected to\n    // use this environment string as a file path\n    return trim ? dequote(_.trim(result)) : result\n  },\n\n  getCacheDir () {\n    return cachedir('Cypress')\n  },\n\n  isPostInstall () {\n    return process.env.npm_lifecycle_event === 'postinstall'\n  },\n\n  exec: execa,\n\n  stdoutLineMatches,\n\n  issuesUrl,\n\n  isBrokenGtkDisplay,\n\n  logBrokenGtkDisplayWarning,\n\n  isPossibleLinuxWithIncorrectDisplay,\n\n  getGitHubIssueUrl (number) {\n    la(is.positive(number), 'github issue should be a positive number', number)\n    la(_.isInteger(number), 'github issue should be an integer', number)\n\n    return `${issuesUrl}/${number}`\n  },\n\n  getFileChecksum,\n\n  getFileSize,\n\n  getApplicationDataFolder,\n}\n\nmodule.exports = util\n",
    "cli/test/lib/tasks/unzip_spec.js": "require('../../spec_helper')\n\nconst events = require('events')\nconst os = require('os')\nconst path = require('path')\nconst snapshot = require('../../support/snapshot')\nconst cp = require('child_process')\nconst debug = require('debug')('test')\nconst readline = require('readline')\n\nconst fs = require(`${lib}/fs`)\nconst util = require(`${lib}/util`)\nconst logger = require(`${lib}/logger`)\nconst unzip = require(`${lib}/tasks/unzip`)\n\nconst stdout = require('../../support/stdout')\nconst normalize = require('../../support/normalize')\n\nconst version = '1.2.3'\nconst installDir = path.join(os.tmpdir(), 'Cypress', version)\n\ndescribe('lib/tasks/unzip', function () {\n  require('mocha-banner').register()\n  beforeEach(function () {\n    this.stdout = stdout.capture()\n\n    os.platform.returns('darwin')\n    sinon.stub(util, 'pkgVersion').returns(version)\n  })\n\n  afterEach(function () {\n    stdout.restore()\n\n    // return fs.removeAsync(installationDir)\n  })\n\n  it('throws when cannot unzip', function () {\n    const ctx = this\n\n    return unzip\n    .start({\n      zipFilePath: path.join('test', 'fixture', 'bad_example.zip'),\n      installDir,\n    })\n    .then(() => {\n      throw new Error('should have failed')\n    })\n    .catch((err) => {\n      logger.error(err)\n\n      snapshot('unzip error 1', normalize(ctx.stdout.toString()))\n    })\n  })\n\n  it('can really unzip', function () {\n    const onProgress = sinon.stub().returns(undefined)\n\n    return unzip\n    .start({\n      zipFilePath: path.join('test', 'fixture', 'example.zip'),\n      installDir,\n      progress: { onProgress },\n    })\n    .then(() => {\n      expect(onProgress).to.be.called\n\n      return fs.statAsync(installDir)\n    })\n  })\n\n  context('on linux', () => {\n    beforeEach(() => {\n      os.platform.returns('linux')\n    })\n\n    it('can try unzip first then fall back to node unzip', function (done) {\n      const zipFilePath = path.join('test', 'fixture', 'example.zip')\n\n      sinon.stub(unzip.utils.unzipTools, 'extract').callsFake((filePath, opts) => {\n        debug('unzip extract called with %s', filePath)\n        expect(filePath, 'zipfile is the same').to.equal(zipFilePath)\n\n        return new Promise((resolve) => resolve())\n      })\n\n      const unzipChildProcess = new events.EventEmitter()\n\n      unzipChildProcess.stdout = {\n        on () {},\n      }\n\n      unzipChildProcess.stderr = {\n        on () {},\n      }\n\n      sinon.stub(cp, 'spawn').withArgs('unzip').returns(unzipChildProcess)\n\n      setTimeout(() => {\n        debug('emitting unzip error')\n        unzipChildProcess.emit('error', new Error('unzip fails badly'))\n      }, 100)\n\n      unzip\n      .start({\n        zipFilePath,\n        installDir,\n      })\n      .then(() => {\n        debug('checking if unzip was called')\n        expect(cp.spawn, 'unzip spawn').to.have.been.calledWith('unzip')\n        expect(unzip.utils.unzipTools.extract, 'extract called').to.be.calledWith(zipFilePath)\n        expect(unzip.utils.unzipTools.extract, 'extract called once').to.be.calledOnce\n        done()\n      })\n    })\n\n    it('calls node unzip just once', function (done) {\n      const zipFilePath = path.join('test', 'fixture', 'example.zip')\n\n      sinon.stub(unzip.utils.unzipTools, 'extract').callsFake((filePath, opts) => {\n        debug('unzip extract called with %s', filePath)\n        expect(filePath, 'zipfile is the same').to.equal(zipFilePath)\n\n        return new Promise((resolve) => resolve())\n      })\n\n      const unzipChildProcess = new events.EventEmitter()\n\n      unzipChildProcess.stdout = {\n        on () {},\n      }\n\n      unzipChildProcess.stderr = {\n        on () {},\n      }\n\n      sinon.stub(cp, 'spawn').withArgs('unzip').returns(unzipChildProcess)\n\n      setTimeout(() => {\n        debug('emitting unzip error')\n        unzipChildProcess.emit('error', new Error('unzip fails badly'))\n      }, 100)\n\n      setTimeout(() => {\n        debug('emitting unzip close')\n        unzipChildProcess.emit('close', 1)\n      }, 110)\n\n      unzip\n      .start({\n        zipFilePath,\n        installDir,\n      })\n      .then(() => {\n        debug('checking if unzip was called')\n        expect(cp.spawn, 'unzip spawn').to.have.been.calledWith('unzip')\n        expect(unzip.utils.unzipTools.extract, 'extract called').to.be.calledWith(zipFilePath)\n        expect(unzip.utils.unzipTools.extract, 'extract called once').to.be.calledOnce\n        done()\n      })\n    })\n  })\n\n  context('on Mac', () => {\n    beforeEach(() => {\n      os.platform.returns('darwin')\n    })\n\n    it('calls node unzip just once', function (done) {\n      const zipFilePath = path.join('test', 'fixture', 'example.zip')\n\n      sinon.stub(unzip.utils.unzipTools, 'extract').callsFake((filePath, opts) => {\n        debug('unzip extract called with %s', filePath)\n        expect(filePath, 'zipfile is the same').to.equal(zipFilePath)\n\n        return new Promise((resolve) => resolve())\n      })\n\n      const unzipChildProcess = new events.EventEmitter()\n\n      unzipChildProcess.stdout = {\n        on () {},\n      }\n\n      unzipChildProcess.stderr = {\n        on () {},\n      }\n\n      sinon.stub(cp, 'spawn').withArgs('ditto').returns(unzipChildProcess)\n      sinon.stub(readline, 'createInterface').returns({\n        on: () => {},\n      })\n\n      setTimeout(() => {\n        debug('emitting ditto error')\n        unzipChildProcess.emit('error', new Error('ditto fails badly'))\n      }, 100)\n\n      setTimeout(() => {\n        debug('emitting ditto close')\n        unzipChildProcess.emit('close', 1)\n      }, 110)\n\n      unzip\n      .start({\n        zipFilePath,\n        installDir,\n      })\n      .then(() => {\n        debug('checking if unzip was called')\n        expect(cp.spawn, 'unzip spawn').to.have.been.calledWith('ditto')\n        expect(unzip.utils.unzipTools.extract, 'extract called').to.be.calledWith(zipFilePath)\n        expect(unzip.utils.unzipTools.extract, 'extract called once').to.be.calledOnce\n        done()\n      })\n    })\n  })\n})\n",
    "npm/cypress-schematic/src/schematics/utility/index.ts": "import { Tree } from '@angular-devkit/schematics'\nimport { get } from 'http'\n\nimport { getPackageJsonDependency } from './dependencies'\n\nexport interface NodePackage {\n    name: string\n    version: string\n  }\n\nexport enum Paths {\n    AngularJson = './angular.json',\n  }\n\nexport enum Configs {\n    JsonIndentLevel = 4,\n  }\n\nexport interface CypressOptions {\n    project?: string\n    __version__: number\n  }\n\nexport function getAngularVersion (tree: Tree): number {\n  const packageNode = getPackageJsonDependency(tree, '@angular/core')\n\n  const version = packageNode && packageNode.version.split('').find((char) => !!parseInt(char, 10))\n\n  return version ? +version : 0\n}\n\n/**\n   * Attempt to retrieve the latest package version from NPM\n   * Return an optional \"latest\" version in case of error\n   * @param packageName\n   */\nexport function getLatestNodeVersion (packageName: string): Promise<NodePackage> {\n  const DEFAULT_VERSION = 'latest'\n\n  return new Promise((resolve) => {\n    return get(`http://registry.npmjs.org/${packageName}`, (res) => {\n      let rawData = ''\n\n      res.on('data', (chunk) => (rawData += chunk))\n      res.on('end', () => {\n        try {\n          const response = JSON.parse(rawData)\n          const version = (response && response['dist-tags']) || {}\n\n          resolve(buildPackage(packageName, version.latest))\n        } catch (e) {\n          resolve(buildPackage(packageName))\n        }\n      })\n    }).on('error', () => resolve(buildPackage(packageName)))\n  })\n\n  function buildPackage (name: string, version: string = DEFAULT_VERSION): NodePackage {\n    return { name, version }\n  }\n}\n",
    "npm/react/cypress/component/advanced/lazy-loaded-suspense/LazyComponent.tsx": "import * as React from 'react'\n\nconst LazyDog = React.lazy(() => {\n  return import(/* webpackChunkName: \"Dog\" */ './Dog')\n  .then((comp) => new Promise((resolve) => setTimeout(() => resolve(comp), 10)))\n})\n\ninterface LazyComponentProps {}\n\nexport const LazyComponent: React.FC<LazyComponentProps> = () => {\n  return (\n    <div>\n      Loading a dog:\n      <React.Suspense fallback={'loading...'}>\n        <LazyDog />\n      </React.Suspense>\n    </div>\n  )\n}\n",
    "npm/vue/cypress/component/counter-vuex/store.js": "import Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\n// root state object.\n// each Vuex instance is just a single state tree.\nconst state = {\n  count: 0,\n}\n\n// mutations are operations that actually mutates the state.\n// each mutation handler gets the entire state tree as the\n// first argument, followed by additional payload arguments.\n// mutations must be synchronous and can be recorded by plugins\n// for debugging purposes.\nconst mutations = {\n  set (state, value) {\n    state.count = value\n  },\n  increment (state) {\n    state.count++\n  },\n  decrement (state) {\n    state.count--\n  },\n}\n\n// actions are functions that cause side effects and can involve\n// asynchronous operations.\nconst actions = {\n  increment: ({ commit }) => commit('increment'),\n  decrement: ({ commit }) => commit('decrement'),\n  incrementIfOdd ({ commit, state }) {\n    if ((state.count + 1) % 2 === 0) {\n      commit('increment')\n    }\n  },\n  incrementAsync ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('increment')\n        resolve()\n      }, 1000)\n    })\n  },\n}\n\n// getters are functions\nconst getters = {\n  evenOrOdd: (state) => (state.count % 2 === 0 ? 'even' : 'odd'),\n}\n\n// A Vuex instance is created by combining the state, mutations, actions,\n// and getters.\nexport default new Vuex.Store({\n  state,\n  getters,\n  actions,\n  mutations,\n})\n",
    "npm/webpack-batteries-included-preprocessor/test/fixtures/export-es2015.js": "const es2015Export = {\n  es2015Key: 'es2015Value',\n}\n\nclass SampleClass {\n  static staticProp = 'staticProp'\n  prop = 'prop'\n}\n\nconst returnsPromise = () => {\n  return new Promise((resolve) => {\n    resolve('value')\n  })\n}\n\nconst asyncFn = async () => {\n  const value = await returnsPromise()\n\n  return value\n}\n\nexport default {\n  es2015Export,\n  SampleClass,\n  asyncFn,\n}\n",
    "npm/webpack-dev-server/test/e2e.spec.ts": "import webpack from 'webpack'\nimport path from 'path'\nimport sinon from 'sinon'\nimport { expect } from 'chai'\nimport { EventEmitter } from 'events'\nimport http from 'http'\nimport fs from 'fs'\n\nimport { startDevServer } from '../'\n\nconst requestSpecFile = (port: number) => {\n  return new Promise((res) => {\n    const opts = {\n      host: 'localhost',\n      port,\n      path: '/test/fixtures/foo.spec.js',\n    }\n\n    const callback = (response: EventEmitter) => {\n      let str = ''\n\n      response.on('data', (chunk) => {\n        str += chunk\n      })\n\n      response.on('end', () => {\n        res(str)\n      })\n    }\n\n    http.request(opts, callback).end()\n  })\n}\n\nconst root = path.join(__dirname, '..')\n\nconst webpackConfig: webpack.Configuration = {\n  output: {\n    path: root,\n    publicPath: root,\n  },\n}\n\nconst specs: Cypress.Cypress['spec'][] = [\n  {\n    name: `${root}/test/fixtures/foo.spec.js`,\n    relative: `${root}/test/fixtures/foo.spec.js`,\n    absolute: `${root}/test/fixtures/foo.spec.js`,\n  },\n]\n\nconst config = {\n  projectRoot: root,\n  supportFile: '',\n  isTextTerminal: true,\n  devServerPublicPathRoute: root,\n} as any as Cypress.ResolvedConfigOptions & Cypress.RuntimeConfigOptions\n\ndescribe('#startDevServer', () => {\n  it('serves specs via a webpack dev server', async () => {\n    const { port, close } = await startDevServer({\n      webpackConfig,\n      options: {\n        config,\n        specs,\n        devServerEvents: new EventEmitter(),\n      },\n    })\n\n    const response = await requestSpecFile(port as number)\n\n    expect(response).to.eq('const foo = () => {}\\n')\n\n    return new Promise((res) => {\n      close(() => res())\n    })\n  })\n\n  it('emits dev-server:compile:success event on successful compilation', async () => {\n    const devServerEvents = new EventEmitter()\n    const { close } = await startDevServer({\n      webpackConfig,\n      options: {\n        config,\n        specs,\n        devServerEvents,\n      },\n    })\n\n    return new Promise((res) => {\n      devServerEvents.on('dev-server:compile:success', () => {\n        close(() => res())\n      })\n    })\n  })\n\n  it('emits dev-server:compile:error event on error compilation', async () => {\n    const devServerEvents = new EventEmitter()\n\n    const exitSpy = sinon.stub()\n\n    const { close } = await startDevServer({\n      webpackConfig,\n      options: {\n        config,\n        specs: [\n          {\n            name: `${root}/test/fixtures/compilation-fails.spec.js`,\n            relative: `${root}/test/fixtures/compilation-fails.spec.js`,\n            absolute: `${root}/test/fixtures/compilation-fails.spec.js`,\n          },\n        ],\n        devServerEvents,\n      },\n    }, exitSpy as any)\n\n    exitSpy()\n\n    return new Promise((res) => {\n      devServerEvents.on('dev-server:compile:error', () => {\n        expect(exitSpy.calledOnce).to.be.true\n        close(() => res())\n      })\n    })\n  })\n\n  it('touches browser.js when a spec file is added', async function () {\n    const devServerEvents = new EventEmitter()\n    const { close } = await startDevServer({\n      webpackConfig,\n      options: {\n        config,\n        specs,\n        devServerEvents,\n      },\n    })\n\n    const newSpec: Cypress.Cypress['spec'] = {\n      name: './some-newly-created-spec.js',\n      relative: './some-newly-created-spec.js',\n      absolute: '/some-newly-created-spec.js',\n    }\n\n    const oldmtime = fs.statSync('./dist/browser.js').mtimeMs\n\n    return new Promise((res) => {\n      devServerEvents.emit('dev-server:specs:changed', [newSpec])\n      const updatedmtime = fs.statSync('./dist/browser.js').mtimeMs\n\n      expect(oldmtime).to.not.equal(updatedmtime)\n      close(() => res())\n    })\n  })\n})\n",
    "packages/desktop-gui/cypress/integration/global_mode_spec.js": "describe('Global Mode', function () {\n  beforeEach(function () {\n    cy.fixture('user').as('user')\n    cy.fixture('projects').as('projects')\n    cy.fixture('projects_statuses').as('projectStatuses')\n    cy.fixture('config').as('config')\n    cy.fixture('specs').as('specs')\n\n    this.dropEvent = {\n      dataTransfer: {\n        files: [{ path: '/foo/bar' }],\n      },\n    }\n\n    this.getLocalStorageProjects = () => {\n      return JSON.parse(localStorage.projects || '[]')\n    }\n\n    this.setLocalStorageProjects = (projects) => {\n      return localStorage.projects = JSON.stringify(projects)\n    }\n\n    this.setup = (win) => {\n      ({ start: this.start, ipc: this.ipc } = win.App)\n\n      cy.stub(this.ipc, 'getOptions').resolves({})\n      cy.stub(this.ipc, 'getCurrentUser').resolves(this.user)\n      cy.stub(this.ipc, 'updaterCheck').resolves(false)\n      cy.stub(this.ipc, 'logOut').resolves({})\n      cy.stub(this.ipc, 'addProject').resolves(this.projects[0])\n      cy.stub(this.ipc, 'openProject').resolves(this.config)\n      cy.stub(this.ipc, 'getSpecs').yields(null, this.specs)\n      cy.stub(this.ipc, 'offOpenProject')\n      cy.stub(this.ipc, 'offGetSpecs')\n      cy.stub(this.ipc, 'offOnFocusTests')\n      cy.stub(this.ipc, 'closeProject')\n      cy.stub(this.ipc, 'externalOpen')\n\n      this.getProjects = this.util.deferred()\n      cy.stub(this.ipc, 'getProjects').returns(this.getProjects.promise)\n\n      this.getProjectStatuses = this.util.deferred()\n      cy.stub(this.ipc, 'getProjectStatuses').returns(this.getProjectStatuses.promise)\n\n      return this.start()\n    }\n\n    cy.visitIndex().then(this.setup)\n  })\n\n  it('shows cypress logo in nav', () => {\n    cy.get('.nav .logo img')\n    .should('have.attr', 'src', './img/cypress-inverse.png')\n    .then(($el) => {\n      return new Cypress.Promise((resolve, reject) => {\n        const img = new Image()\n\n        img.onerror = () => reject(new Error `img failed to load src: ${img.src}`)\n        img.onload = resolve\n        img.src = $el[0].src\n      })\n    })\n  })\n\n  it('shows notice about using Cypress locally', () => {\n    cy.contains('versioning Cypress per project')\n    cy.percySnapshot()\n  })\n\n  it('opens link to docs on click \\'installing...\\'', () => {\n    cy.contains('a', 'installing it via').click().then(function () {\n      expect(this.ipc.externalOpen).to.be.calledWith('https://on.cypress.io/installing-via-npm')\n    })\n  })\n\n  it('dismisses notice when close is clicked', function () {\n    cy.get('.local-install-notice .close').click()\n\n    cy.get('.local-install-notice').should('not.exist')\n  })\n\n  it('stores the dismissal state in local storage', () => {\n    cy.get('.local-install-notice .close').click().then(() => {\n      expect(localStorage['local-install-notice-dimissed']).to.equal('true')\n    })\n  })\n\n  it('does not show notice when dismissed state stored in local storage', function () {\n    cy.get('.local-install-notice .close').click()\n    cy.reload().then(this.setup)\n    cy.contains('To get started...')\n\n    cy.get('.local-install-notice').should('not.exist')\n  })\n\n  it('shows project drop area with button to select project', function () {\n    cy.get('.project-drop p:first').should('contain', 'Drag your project here')\n\n    cy.get('.project-drop a').should('have.text', 'select manually')\n  })\n\n  describe('dragging and dropping project', function () {\n    it('highlights/unhighlights drop area when dragging over it/leaving it', () => {\n      cy.get('.project-drop')\n      .trigger('dragover')\n      .should('have.class', 'is-dragging-over')\n      .trigger('dragleave')\n      .should('not.have.class', 'is-dragging-over')\n    })\n\n    it('handles drops of non-files gracefully', function (done) {\n      cy.window().then((win) => {\n        win.onerror = (message) => {\n          done(`Should not cause error but threw: ${message}`)\n        }\n      })\n\n      //# user could drag and drop a link or text, not a file\n      this.dropEvent.dataTransfer.files = []\n      cy.get('.project-drop').trigger('drop', this.dropEvent)\n\n      cy.wait(300).then(() => {\n        done()\n      })\n    })\n\n    it('unhighlights drop area when dropping a project on it', function () {\n      cy.get('.project-drop')\n      .trigger('dragover')\n      .should('have.class', 'is-dragging-over')\n      .trigger('drop', this.dropEvent)\n      .should('not.have.class', 'is-dragging-over')\n    })\n\n    it('adds project and opens it when dropped', function () {\n      cy.get('.project-drop').trigger('drop', this.dropEvent)\n\n      cy.shouldBeOnProjectSpecs()\n    })\n  })\n\n  describe('selecting project', function () {\n    it('adds project and opens it when selected', function () {\n      cy.stub(this.ipc, 'showDirectoryDialog').resolves('/foo/bar')\n\n      cy.get('.project-drop a').click().then(() => {\n        expect(this.ipc.showDirectoryDialog).to.be.called\n\n        cy.shouldBeOnProjectSpecs()\n      })\n    })\n\n    it('updates local storage', function () {\n      cy.stub(this.ipc, 'showDirectoryDialog').resolves('/foo/bar')\n\n      cy.get('.project-drop a').click().should(() => {\n        expect(this.getLocalStorageProjects()[0].id).to.equal(this.projects[0].id)\n      })\n    })\n\n    it('does nothing when user cancels', function () {\n      cy.stub(this.ipc, 'showDirectoryDialog').resolves()\n      cy.get('.project-drop a').click()\n\n      cy.shouldBeOnIntro()\n    })\n  })\n\n  describe('going to project', function () {\n    beforeEach(function () {\n      cy.get('.project-drop').trigger('drop', this.dropEvent)\n    })\n\n    it('displays Back button', () => {\n      cy.get('.main-nav .nav:first-child a').invoke('text').should('include', 'Back')\n    })\n\n    it('sets title to project name', () => {\n      cy.title().should('equal', 'bar')\n    })\n\n    describe('going back', function () {\n      beforeEach(() => {\n        cy.contains('Back').click()\n      })\n\n      it('returns to intro on click of back button', () => {\n        cy.shouldBeOnIntro()\n      })\n\n      it('removes project name from title', () => {\n        cy.title().should('equal', 'Cypress')\n      })\n\n      it('removes ipc listeners', function () {\n        expect(this.ipc.offOpenProject).to.be.called\n        expect(this.ipc.offGetSpecs).to.be.called\n\n        expect(this.ipc.offOnFocusTests).to.be.called\n      })\n\n      it('closes project', function () {\n        expect(this.ipc.closeProject).to.be.called\n      })\n    })\n  })\n})\n",
    "packages/desktop-gui/src/lib/ipc-bus.js": "import _ from 'lodash'\nimport Promise from 'bluebird'\n\nlet msgs = {}\n\nconst addMsg = (id, event, fn) => {\n  msgs[id] = {\n    event,\n    fn,\n  }\n}\n\nconst nullifyUnserializableValues = (obj) => {\n  // nullify values that cannot be cloned\n  // https://github.com/cypress-io/cypress/issues/6750\n  return _.cloneDeepWith(obj, (val) => {\n    if (_.isFunction(val) || _.isElement(val)) {\n      return null\n    }\n  })\n}\n\nconst removeMsgsByEvent = (event) => {\n  msgs = _.omitBy(msgs, (msg) => {\n    return msg.event === event\n  })\n}\n\nconst removeMsgById = (id) => {\n  msgs = _.omit(msgs, `${id}`)\n}\n\nconst createIpc = () => {\n  console.warn('Missing \"ipc\". Polyfilling in development mode.') // eslint-disable-line no-console\n\n  return {\n    on () {},\n    send () {},\n  }\n}\n\nconst ipc = window.ipc != null ? window.ipc : (window.ipc = createIpc())\n\nipc.on('response', (event, obj = {}) => {\n  const { id, __error, data } = obj\n  const msg = msgs[id]\n\n  // standard node callback implementation\n  if (msg) {\n    msg.fn(__error, data)\n  }\n})\n\nconst ipcBus = (...args) => {\n  if (args.length === 0) {\n    return msgs\n  }\n\n  // our ipc interface can either be a standard\n  // node callback or a promise interface\n  // we support both because oftentimes we want\n  // to our async request to be resolved with a\n  // singular value, and other times we want it\n  // to be called multiple times akin to a stream\n\n  // generate an id\n  const id = Math.random()\n\n  // first arg is the event\n  const event = args[0]\n\n  // get the last argument\n  const lastArg = args.pop()\n\n  let fn\n\n  // enable the last arg to be a function\n  // which changes this interface from being\n  // a promise to just calling the callback\n  // function directly\n  if (lastArg && _.isFunction(lastArg)) {\n    fn = () => {\n      return addMsg(id, event, lastArg)\n    }\n  } else {\n    // push it back onto the array\n    args.push(lastArg)\n\n    fn = () => {\n      // return a promise interface and at the\n      // same time store this callback function\n      // by id in msgs\n      return new Promise((resolve, reject) => {\n        addMsg(id, event, (err, data) => {\n          // cleanup messages using promise interface\n          // automatically\n          removeMsgById(id)\n\n          if (err) {\n            reject(err)\n          } else {\n            resolve(data)\n          }\n        })\n      })\n    }\n  }\n\n  args = nullifyUnserializableValues(args)\n\n  // pass in request, id, and remaining args\n  ipc.send(...['request', id].concat(args))\n\n  return fn()\n}\n\nipcBus.offById = removeMsgById\nipcBus.off = removeMsgsByEvent\n\nexport default ipcBus\n",
    "packages/driver/cypress/integration/commands/connectors_spec.js": "const { _, Promise, $ } = Cypress\n\ndescribe('src/cy/commands/connectors', () => {\n  describe('with jquery', () => {\n    before(() => {\n      cy\n      .visit('/fixtures/jquery.html')\n      .then(function (win) {\n        this.body = win.document.body.outerHTML\n      })\n    })\n\n    beforeEach(function () {\n      const doc = cy.state('document')\n\n      $(doc.body).empty().html(this.body)\n    })\n\n    context('#spread', () => {\n      it('spreads an array into individual arguments', () => {\n        cy.noop([1, 2, 3]).spread((one, two, three) => {\n          expect(one).to.eq(1)\n          expect(two).to.eq(2)\n          expect(three).to.eq(3)\n        })\n      })\n\n      it('spreads a jQuery wrapper into individual arguments', () => {\n        cy.noop($('div')).spread((first, second) => {\n          expect(first.tagName).to.eq('DIV')\n          expect(first.innerText).to.eq('div')\n          expect(second.tagName).to.eq('DIV')\n          expect(second.innerText).to.contain('Nested Find')\n        })\n      })\n\n      it('passes timeout option to spread', () => {\n        cy.timeout(50)\n\n        cy.noop([1, 2, 3]).spread({ timeout: 150 }, () => {\n          Promise.delay(100)\n        })\n      })\n\n      describe('errors', {\n        defaultCommandTimeout: 50,\n      }, () => {\n        it('throws when subject isn\\'t array-like', (done) => {\n          cy.on('fail', (err) => {\n            expect(err.message).to.eq('`cy.spread()` requires the existing subject be array-like.')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/spread')\n\n            done()\n          })\n\n          cy.noop({}).spread(() => {})\n        })\n\n        it('throws when promise timeout', (done) => {\n          const logs = []\n\n          cy.on('log:added', (attrs, log) => {\n            logs?.push(log)\n          })\n\n          cy.on('fail', (err) => {\n            expect(logs.length).to.eq(1)\n            expect(logs[0].get('error')).to.eq(err)\n            expect(err.message).to.include('`cy.spread()` timed out after waiting `20ms`.')\n\n            done()\n          })\n\n          cy.noop([1, 2, 3]).spread({ timeout: 20 }, () => {\n            return new Promise(() => {})\n          })\n        })\n      })\n    })\n\n    context('#then', () => {\n      it('converts raw DOM elements', () => {\n        const div = cy.$$('div:first').get(0)\n\n        cy.wrap(div).then(($div) => {\n          expect($div.get(0)).to.eq(div)\n        })\n      })\n\n      it('does not insert a mocha callback', () => {\n        cy.noop().then(() => {\n          expect(cy.queue.length).to.eq(2)\n        })\n      })\n\n      it('passes timeout option to then', () => {\n        cy.timeout(50)\n\n        return cy.then({ timeout: 150 }, () => {\n          return Promise.delay(100)\n        })\n      })\n\n      it('can resolve nested thens', () => {\n        cy.get('div:first').then(() => {\n          cy.get('div:first').then(() => {\n            cy.get('div:first')\n          })\n        })\n      })\n\n      it('can resolve cypress commands inside of a promise', () => {\n        let _then = false\n\n        cy.wrap(null).then(() => {\n          return Promise.delay(10).then(() => {\n            cy.then(() => {\n              _then = true\n            })\n          })\n        }).then(() => {\n          expect(_then).to.be.true\n        })\n      })\n\n      it('can resolve chained cypress commands inside of a promise', () => {\n        let _then = false\n\n        cy.wrap(null).then(() => {\n          return Promise.delay(10).then(() => {\n            cy.get('div:first').then(() => {\n              _then = true\n            })\n          })\n        }).then(() => {\n          expect(_then).to.be.true\n        })\n      })\n\n      it('can resolve cypress instance inside of a promise', () => {\n        cy.then(() => {\n          return Promise.delay(10).then(() => {\n            return cy\n          })\n        })\n      })\n\n      it('passes values to the next command', () => {\n        cy\n        .wrap({ foo: 'bar' }).then((obj) => {\n          return obj.foo\n        }).then((val) => {\n          expect(val).to.eq('bar')\n        })\n      })\n\n      it('does not throw when returning thenables with cy commands', () => {\n        cy\n        .wrap({ foo: 'bar' })\n        .then((obj) => {\n          return new Promise((resolve) => {\n            cy.wait(10)\n\n            resolve(obj.foo)\n          })\n        })\n      })\n\n      it('should pass the eventual resolved thenable value downstream', () => {\n        cy\n        .wrap({ foo: 'bar' })\n        .then((obj) => {\n          return cy\n          .wait(10)\n          .then(() => {\n            return obj.foo\n          }).then((value) => {\n            expect(value).to.eq('bar')\n\n            return value\n          })\n        })\n        .then((val) => {\n          expect(val).to.eq('bar')\n        })\n      })\n\n      it('should not pass the eventual resolve thenable value downstream because thens are not connected', () => {\n        cy\n        .wrap({ foo: 'bar' })\n        .then((obj) => {\n          cy\n          .wait(10)\n          .then(() => {\n            return obj.foo\n          })\n          .then((value) => {\n            expect(value).to.eq('bar')\n\n            return value\n          })\n        })\n\n        cy.then((val) => {\n          expect(val).to.be.undefined\n        })\n      })\n\n      it('passes the existing subject if ret is undefined', () => {\n        cy.wrap({ foo: 'bar' }).then((obj) => {\n          return undefined\n        }).then((obj) => {\n          expect(obj).to.deep.eq({ foo: 'bar' })\n        })\n      })\n\n      it('sets the subject to null when given null', () => {\n        cy.wrap({ foo: 'bar' }).then((obj) => {\n          return null\n        }).then((obj) => {\n          expect(obj).to.be.null\n        })\n      })\n\n      describe('errors', {\n        defaultCommandTimeout: 100,\n      }, () => {\n        beforeEach(function () {\n          this.logs = []\n\n          cy.on('log:added', (attrs, log) => {\n            this.lastLog = log\n            this.logs?.push(log)\n          })\n\n          return null\n        })\n\n        it('throws when promise timeout', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(this.logs.length).to.eq(1)\n            expect(lastLog.get('error')).to.eq(err)\n            expect(err.message).to.include('`cy.then()` timed out after waiting `150ms`.')\n\n            done()\n          })\n\n          cy.then({ timeout: 150 }, () => {\n            return new Promise(() => {})\n          })\n        })\n\n        it('throws when mixing up async + sync return values', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(this.logs.length).to.eq(1)\n            expect(lastLog.get('error')).to.eq(err)\n            expect(err.message).to.include('`cy.then()` failed because you are mixing up async and sync code.')\n\n            done()\n          })\n\n          cy.then(() => {\n            cy.wait(5000)\n\n            return 'foo'\n          })\n        })\n\n        it('unbinds command:enqueued in the case of an error thrown', function (done) {\n          const listeners = []\n\n          cy.on('fail', () => {\n            listeners.push(cy.listeners('command:enqueued').length)\n\n            expect(this.logs.length).to.eq(1)\n            expect(listeners).to.deep.eq([1, 0])\n\n            done()\n          })\n\n          cy.then(() => {\n            listeners.push(cy.listeners('command:enqueued').length)\n\n            throw new Error('foo')\n          })\n        })\n      })\n\n      describe('yields to remote jQuery subject', () => {\n        beforeEach(function () {\n          this.remoteWindow = cy.state('window')\n        })\n\n        it('calls the callback function with the remote jQuery subject', function () {\n          this.remoteWindow.$.fn.foo = () => {}\n\n          cy\n          .get('div:first').then(function ($div) {\n            expect($div).to.be.instanceof(this.remoteWindow.$)\n\n            return $div\n          })\n          .then(function ($div) {\n            expect($div).to.be.instanceof(this.remoteWindow.$)\n          })\n        })\n\n        it('does not store the remote jquery object as the subject', () => {\n          cy\n          .get('div:first').then(function ($div) {\n            expect($div).to.be.instanceof(this.remoteWindow.$)\n\n            return $div\n          })\n          .then(function () {\n            expect(cy.state('subject')).not.to.be.instanceof(this.remoteWindow.$)\n          })\n        })\n      })\n    })\n\n    context('#invoke', () => {\n      beforeEach(function () {\n        this.remoteWindow = cy.state('window')\n      })\n\n      describe('assertion verification', {\n        defaultCommandTimeout: 200,\n      }, () => {\n        beforeEach(function () {\n          delete this.remoteWindow.$.fn.foo\n\n          this.logs = []\n\n          cy.on('log:added', (attrs, log) => {\n            this.lastLog = log\n\n            return this.logs?.push(log)\n          })\n\n          return null\n        })\n\n        it('eventually passes the assertion', function () {\n          cy.on('command:retry', _.after(2, () => {\n            this.remoteWindow.$.fn.foo = () => {\n              return 'foo'\n            }\n          }))\n\n          cy.get('div:first').invoke('foo').should('eq', 'foo').then(function () {\n            const { lastLog } = this\n\n            expect(lastLog.get('name')).to.eq('assert')\n            expect(lastLog.get('state')).to.eq('passed')\n            expect(lastLog.get('ended')).to.be.true\n          })\n        })\n\n        it('eventually fails the assertion', function (done) {\n          cy.on('command:retry', _.after(2, () => {\n            this.remoteWindow.$.fn.foo = () => {\n              return 'foo'\n            }\n          }))\n\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include(lastLog.get('error').message)\n            expect(err.message).not.to.include('undefined')\n            expect(lastLog.get('name')).to.eq('assert')\n            expect(lastLog.get('state')).to.eq('failed')\n            expect(lastLog.get('error')).to.be.an.instanceof(chai.AssertionError)\n\n            done()\n          })\n\n          cy.get('div:first').invoke('foo').should('eq', 'bar')\n        })\n\n        it('can still fail on invoke', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include(lastLog.get('error').message)\n            expect(err.message).not.to.include('undefined')\n            expect(lastLog.get('name')).to.eq('invoke')\n            expect(lastLog.get('state')).to.eq('failed')\n\n            done()\n          })\n\n          cy.get('div:first').invoke('foobarbaz')\n        })\n\n        it('does not log an additional log on failure', function (done) {\n          this.remoteWindow.$.fn.foo = () => {\n            return 'foo'\n          }\n\n          cy.on('fail', () => {\n            expect(this.logs.length).to.eq(3)\n\n            done()\n          })\n\n          cy.get('div:first').invoke('foo').should('eq', 'bar')\n        })\n      })\n\n      describe('remote DOM subjects', () => {\n        it('is invoked on the remote DOM subject', function () {\n          this.remoteWindow.$.fn.foo = () => {\n            return 'foo'\n          }\n\n          cy.get('div:first').invoke('foo').then((str) => {\n            expect(str).to.eq('foo')\n          })\n        })\n\n        it('re-wraps the remote element if its returned', () => {\n          const parent = cy.$$('div:first').parent()\n\n          expect(parent).to.exist\n\n          cy.get('div:first').invoke('parent').then(function ($parent) {\n            expect($parent).to.be.instanceof(this.remoteWindow.$)\n            expect(cy.state('subject')).to.match(parent)\n          })\n        })\n      })\n\n      describe('function property', () => {\n        beforeEach(function () {\n          this.obj = {\n            foo () {\n              return 'foo'\n            },\n            bar (num1, num2) {\n              return num1 + num2\n            },\n            err () {\n              throw new Error('fn.err failed.')\n            },\n            baz: 10,\n          }\n        })\n\n        it('changes subject to function invocation', function () {\n          cy.noop(this.obj).invoke('foo').then((str) => {\n            expect(str).to.eq('foo')\n          })\n        })\n\n        it('works with numerical indexes', () => {\n          let i = 0\n          const fn = () => {\n            i++\n\n            return i === 5\n          }\n\n          cy.noop([_.noop, fn]).invoke(1).should('be.true')\n        })\n\n        it('works with 0 as a value if object has property 0', () => {\n          let i = 0\n          const fn = () => {\n            if (i++ === 0) {\n              return 'cy.noop is undocumented'\n            }\n\n            return 'and I don\\'t understand what it is'\n          }\n\n          cy.wrap([fn, 'bar']).invoke(0).should('eq', 'cy.noop is undocumented')\n          cy.wrap({ '0': fn }).invoke(0).should('eq', 'and I don\\'t understand what it is')\n        })\n\n        it('forwards any additional arguments', function () {\n          cy.noop(this.obj).invoke('bar', 1, 2).then((num) => {\n            expect(num).to.eq(3)\n          })\n\n          const obj = {\n            bar () {\n              return undefined\n            },\n          }\n\n          cy.noop(obj).invoke('bar').then((val) => {\n            expect(val).to.be.undefined\n          })\n        })\n\n        it('invokes reduced prop', () => {\n          const obj = {\n            foo: {\n              bar: {\n                baz () {\n                  return 'baz'\n                },\n              },\n            },\n          }\n\n          cy.wrap(obj).invoke('foo.bar.baz').should('eq', 'baz')\n        })\n\n        it('handles properties on the prototype', () => {\n          const num = new Number(10)\n\n          cy.noop(num).invoke('valueOf').then((num) => {\n            expect(num).to.eq(10)\n          })\n        })\n\n        it('retries until function exists on the subject', () => {\n          const obj = {}\n\n          cy.on('command:retry', _.after(3, () => {\n            obj.foo = () => {\n              return 'bar'\n            }\n          }))\n\n          cy.wrap(obj).invoke('foo').then((val) => {\n            expect(val).to.eq('bar')\n          })\n        })\n\n        it('retries until property is a function', () => {\n          const obj = {\n            foo: '',\n          }\n\n          cy.on('command:retry', _.after(3, () => {\n            obj.foo = () => {\n              return 'bar'\n            }\n          }))\n\n          cy.wrap(obj).invoke('foo').then((val) => {\n            expect(val).to.eq('bar')\n          })\n        })\n\n        it('retries until property is a function when initially undefined', () => {\n          const obj = {\n            foo: undefined,\n          }\n\n          cy.on('command:retry', _.after(3, () => {\n            obj.foo = () => {\n              return 'bar'\n            }\n          }))\n\n          cy.wrap(obj).invoke('foo').then((val) => {\n            expect(val).to.eq('bar')\n          })\n        })\n\n        it('retries until value matches assertions', () => {\n          const obj = {\n            foo () {\n              return 'foo'\n            },\n          }\n\n          cy.on('command:retry', _.after(3, () => {\n            obj.foo = () => {\n              return 'bar'\n            }\n          }))\n\n          cy.wrap(obj).invoke('foo').should('eq', 'bar')\n        });\n\n        [null, undefined].forEach((val) => {\n          it(`changes subject to '${val}' without throwing default assertion existence`, () => {\n            const obj = {\n              foo () {\n                return val\n              },\n            }\n\n            cy.wrap(obj).invoke('foo').then((val2) => {\n              expect(val2).to.eq(val)\n            })\n          })\n        })\n\n        describe('errors', {\n          defaultCommandTimeout: 100,\n        }, () => {\n          it('bubbles up automatically', function (done) {\n            cy.on('fail', (err) => {\n              expect(err.message).to.include('fn.err failed.')\n\n              done()\n            })\n\n            cy.noop(this.obj).invoke('err')\n          })\n\n          it('throws when prop is not a function', (done) => {\n            const obj = {\n              foo: /re/,\n            }\n\n            cy.on('fail', (err) => {\n              expect(err.message).to.include('Timed out retrying after 100ms: `cy.invoke()` errored because the property: `foo` returned a `regexp` value instead of a function. `cy.invoke()` can only be used on properties that return callable functions.')\n              expect(err.message).to.include('`cy.invoke()` waited for the specified property `foo` to return a function, but it never did.')\n              expect(err.message).to.include('If you want to assert on the property\\'s value, then switch to use `cy.its()` and add an assertion such as:')\n              expect(err.message).to.include('`cy.wrap({ foo: \\'bar\\' }).its(\\'foo\\').should(\\'eq\\', \\'bar\\')`')\n              expect(err.docsUrl).to.eq('https://on.cypress.io/invoke')\n\n              done()\n            })\n\n            cy.wrap(obj).invoke('foo')\n          })\n\n          it('throws when reduced prop is not a function', (done) => {\n            const obj = {\n              foo: {\n                bar: 'bar',\n              },\n            }\n\n            cy.on('fail', (err) => {\n              expect(err.message).to.include('Timed out retrying after 100ms: `cy.invoke()` errored because the property: `bar` returned a `string` value instead of a function. `cy.invoke()` can only be used on properties that return callable functions.')\n              expect(err.message).to.include('`cy.invoke()` waited for the specified property `bar` to return a function, but it never did.')\n              expect(err.message).to.include('If you want to assert on the property\\'s value, then switch to use `cy.its()` and add an assertion such as:')\n              expect(err.message).to.include('`cy.wrap({ foo: \\'bar\\' }).its(\\'foo\\').should(\\'eq\\', \\'bar\\')`')\n              expect(err.docsUrl).to.eq('https://on.cypress.io/invoke')\n\n              done()\n            })\n\n            cy.wrap(obj).invoke('foo.bar')\n          })\n        })\n      })\n\n      describe('accepts a options argument', () => {\n        it('changes subject to function invocation', () => {\n          cy.noop({ foo () {\n            return 'foo'\n          } }).invoke({ log: false }, 'foo').then((str) => {\n            expect(str).to.eq('foo')\n          })\n        })\n\n        it('forwards any additional arguments', () => {\n          cy.noop({ bar (num1, num2) {\n            return num1 + num2\n          } }).invoke({ log: false }, 'bar', 1, 2).then((num) => {\n            expect(num).to.eq(3)\n          })\n\n          cy.noop({ bar () {\n            return undefined\n          } }).invoke({ log: false }, 'bar').then((val) => {\n            expect(val).to.be.undefined\n          })\n        })\n\n        it('works with numerical indexes', () => {\n          let i = 0\n          const fn = () => {\n            i++\n\n            return i === 5\n          }\n\n          cy.noop([_.noop, fn]).invoke({}, 1).should('be.true')\n        })\n\n        describe('errors', {\n          defaultCommandTimeout: 100,\n        }, () => {\n          beforeEach(function () {\n            cy.on('log:added', (attrs, log) => {\n              this.lastLog = log\n            })\n\n            return null\n          })\n\n          it('throws when function name is missing', function (done) {\n            cy.on('fail', (err) => {\n              const { lastLog } = this\n\n              expect(err.message).to.include('`cy.invoke()` expects the functionName argument to have a value')\n              expect(lastLog.get('error').message).to.include(err.message)\n\n              done()\n            })\n\n            cy.wrap({ foo () {\n              return 'foo'\n            } }).invoke({})\n          })\n\n          it('throws when function name is not of type string but of type boolean', function (done) {\n            cy.on('fail', (err) => {\n              const { lastLog } = this\n\n              expect(err.message).to.include('`cy.invoke()` only accepts a string or a number as the functionName argument.')\n              expect(lastLog.get('error').message).to.include(err.message)\n\n              done()\n            })\n\n            cy.wrap({ foo () {\n              return 'foo'\n            } }).invoke({}, true)\n          })\n\n          it('throws when function name is not of type string but of type function', function (done) {\n            cy.on('fail', (err) => {\n              const { lastLog } = this\n\n              expect(err.message).to.include('`cy.invoke()` only accepts a string or a number as the functionName argument.')\n              expect(lastLog.get('error').message).to.include(err.message)\n\n              done()\n            })\n\n            cy.wrap({ foo () {\n              return 'foo'\n            } }).invoke(() => {\n              return {}\n            })\n          })\n\n          it('throws when first parameter is neither of type object nor of type string nor of type number', function (done) {\n            cy.on('fail', (err) => {\n              const { lastLog } = this\n\n              expect(err.message).to.include('`cy.invoke()` only accepts a string or a number as the functionName argument.')\n              expect(lastLog.get('error').message).to.include(err.message)\n\n              done()\n            })\n\n            cy.wrap({ foo () {\n              return 'foo'\n            } }).invoke(true, 'show')\n          })\n        })\n\n        describe('.log', () => {\n          beforeEach(function () {\n            this.obj = {\n              foo: 'foo bar baz',\n              num: 123,\n              bar () {\n                return 'bar'\n              },\n              attr (key, value) {\n                const obj = {}\n\n                obj[key] = value\n\n                return obj\n              },\n              sum (a, b) {\n                return a + b\n              },\n            }\n\n            cy.on('log:added', (attrs, log) => {\n              this.lastLog = log\n            })\n\n            return null\n          })\n\n          it('logs obj as a function', function () {\n            cy.noop(this.obj).invoke({ log: true }, 'bar').then(function () {\n              const obj = {\n                name: 'invoke',\n                message: '.bar()',\n              }\n\n              const { lastLog } = this\n\n              _.each(obj, (value, key) => {\n                expect(lastLog.get(key)).to.deep.eq(value)\n              })\n            })\n          })\n\n          it('logs obj with arguments', function () {\n            cy.noop(this.obj).invoke({ log: true }, 'attr', 'numbers', [1, 2, 3]).then(function () {\n              expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n                Command: 'invoke',\n                Function: '.attr(numbers, [1, 2, 3])',\n                'With Arguments': ['numbers', [1, 2, 3]],\n                Subject: this.obj,\n                Yielded: { numbers: [1, 2, 3] },\n              })\n            })\n          })\n\n          it('can be disabled', function () {\n            cy.noop(this.obj).invoke({ log: true }, 'sum', 1, 2).then(function () {\n              expect(this.lastLog.invoke('consoleProps')).to.have.property('Function', '.sum(1, 2)')\n              this.lastLog = undefined\n            })\n\n            cy.noop(this.obj).invoke({ log: false }, 'sum', 1, 2).then(function () {\n              expect(this.lastLog).to.be.undefined\n            })\n          })\n        })\n      })\n\n      describe('.log', () => {\n        beforeEach(function () {\n          this.obj = {\n            foo: 'foo bar baz',\n            num: 123,\n            bar () {\n              return 'bar'\n            },\n            attr (key, value) {\n              const obj = {}\n\n              obj[key] = value\n\n              return obj\n            },\n            sum (...args) {\n              return _.reduce(args, (memo, num) => {\n                return memo + num\n              }, 0)\n            },\n            math: {\n              sum: (...args) => {\n                return this.obj.sum(...args)\n              },\n            },\n          }\n\n          this.logs = []\n\n          cy.on('log:added', (attrs, log) => {\n            this.lastLog = log\n            this.logs?.push(log)\n          })\n\n          return null\n        })\n\n        it('logs $el if subject is element', () => {\n          cy.get('div:first').invoke('hide').then(function ($el) {\n            const { lastLog } = this\n\n            expect(lastLog.get('$el').get(0)).to.eq($el.get(0))\n          })\n        })\n\n        it('does not log $el if subject isnt element', function () {\n          cy.noop(this.obj).invoke('bar').then(function () {\n            const { lastLog } = this\n\n            expect(lastLog.get('$el')).not.to.exist\n          })\n        })\n\n        it('logs obj as a function', function () {\n          cy.noop(this.obj).invoke('bar').then(function () {\n            const obj = {\n              name: 'invoke',\n              message: '.bar()',\n            }\n\n            const { lastLog } = this\n\n            _.each(obj, (value, key) => {\n              expect(lastLog.get(key)).to.deep.eq(value)\n            })\n          })\n        })\n\n        it('logs obj with arguments', function () {\n          cy.noop(this.obj).invoke('attr', 'numbers', [1, 2, 3]).then(function () {\n            expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n              Command: 'invoke',\n              Function: '.attr(numbers, [1, 2, 3])',\n              'With Arguments': ['numbers', [1, 2, 3]],\n              Subject: this.obj,\n              Yielded: { numbers: [1, 2, 3] },\n            })\n          })\n        })\n\n        it('#consoleProps as a function property without args', function () {\n          cy.noop(this.obj).invoke('bar').then(function () {\n            expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n              Command: 'invoke',\n              Function: '.bar()',\n              Subject: this.obj,\n              Yielded: 'bar',\n            })\n          })\n        })\n\n        it('#consoleProps as a function property with args', function () {\n          cy.noop(this.obj).invoke('sum', 1, 2, 3).then(function () {\n            expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n              Command: 'invoke',\n              Function: '.sum(1, 2, 3)',\n              'With Arguments': [1, 2, 3],\n              Subject: this.obj,\n              Yielded: 6,\n            })\n          })\n        })\n\n        it('#consoleProps as a function reduced property with args', function () {\n          cy.noop(this.obj).invoke('math.sum', 1, 2, 3).then(function () {\n            expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n              Command: 'invoke',\n              Function: '.math.sum(1, 2, 3)',\n              'With Arguments': [1, 2, 3],\n              Subject: this.obj,\n              Yielded: 6,\n            })\n          })\n        })\n\n        it('#consoleProps as a function on DOM element', () => {\n          cy.get('div:first').invoke('hide').then(function ($btn) {\n            const consoleProps = this.lastLog.invoke('consoleProps')\n\n            expect(consoleProps).to.deep.eq({\n              Command: 'invoke',\n              Function: '.hide()',\n              Subject: $btn.get(0),\n              Yielded: $btn.get(0),\n            })\n          })\n        })\n      })\n\n      describe('errors', {\n        defaultCommandTimeout: 100,\n      }, () => {\n        beforeEach(function () {\n          this.logs = []\n\n          cy.on('log:added', (attrs, log) => {\n            this.lastLog = log\n            this.logs?.push(log)\n          })\n\n          return null\n        })\n\n        it('throws when property does not exist on the subject', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('Timed out retrying after 100ms: `cy.invoke()` errored because the property: `foo` does not exist on your subject.')\n            expect(err.message).to.include('`cy.invoke()` waited for the specified property `foo` to exist, but it never did.')\n            expect(err.message).to.include('If you do not expect the property `foo` to exist, then add an assertion such as:')\n            expect(err.message).to.include('`cy.wrap({ foo: \\'bar\\' }).its(\\'quux\\').should(\\'not.exist\\')`')\n            expect(lastLog.get('error').message).to.include(err.message)\n            expect(err.docsUrl).to.eq('https://on.cypress.io/invoke')\n\n            done()\n          })\n\n          cy.wrap({}).invoke('foo')\n        })\n\n        it('throws without a subject', (done) => {\n          cy.on('fail', (err) => {\n            expect(err.message).to.include('cy.invoke(\"queue\")')\n            expect(err.message).to.include('child command before running a parent command')\n\n            done()\n          })\n\n          cy.invoke('queue')\n        })\n\n        it('logs once when not dom subject', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(this.logs.length).to.eq(1)\n            expect(lastLog.get('error')).to.eq(err)\n\n            done()\n          })\n\n          cy.invoke({})\n        })\n\n        it('throws when failing assertions', function (done) {\n          const obj = {\n            foo () {\n              return 'foo'\n            },\n          }\n\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.eq('Timed out retrying after 100ms: expected \\'foo\\' to equal \\'bar\\'')\n\n            expect(lastLog.get('error').message).to.eq('Timed out retrying after 100ms: expected \\'foo\\' to equal \\'bar\\'')\n\n            done()\n          })\n\n          cy.wrap(obj).invoke('foo').should('eq', 'bar')\n        })\n\n        it('throws when initial subject is undefined', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('Timed out retrying after 100ms: `cy.invoke()` errored because your subject is: `undefined`. You cannot invoke any functions such as `foo` on a `undefined` value.')\n            expect(err.message).to.include('If you expect your subject to be `undefined`, then add an assertion such as:')\n            expect(err.message).to.include('`cy.wrap(undefined).should(\\'be.undefined\\')`')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/invoke')\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          cy.wrap(undefined).invoke('foo')\n        })\n\n        it('throws when property value is undefined', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('Timed out retrying after 100ms: `cy.invoke()` errored because the property: `foo` is not a function, and instead returned a `undefined` value.')\n            expect(err.message).to.include('`cy.invoke()` waited for the specified property `foo` to become a callable function, but it never did.')\n            expect(err.message).to.include('If you expect the property `foo` to be `undefined`, then switch to use `cy.its()` and add an assertion such as:')\n            expect(err.message).to.include('`cy.wrap({ foo: undefined }).its(\\'foo\\').should(\\'be.undefined\\')`')\n            expect(lastLog.get('error').message).to.include(err.message)\n            expect(err.docsUrl).to.eq('https://on.cypress.io/invoke')\n\n            done()\n          })\n\n          cy.wrap({ foo: undefined }).invoke('foo')\n        })\n\n        it('throws when nested property value is undefined', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('Timed out retrying after 100ms: `cy.invoke()` errored because the property: `baz` does not exist on your subject.')\n            expect(lastLog.get('error').message).to.include(err.message)\n            expect(err.docsUrl).to.eq('https://on.cypress.io/invoke')\n\n            done()\n          })\n\n          const obj = {\n            foo: {\n              bar: {},\n            },\n          }\n\n          cy.wrap(obj).invoke('foo.bar.baz.fizz')\n        })\n      })\n    })\n\n    context('#its', () => {\n      beforeEach(function () {\n        this.remoteWindow = cy.state('window')\n      })\n\n      it('proxies to #invokeFn', () => {\n        const fn = () => {\n          return 'bar'\n        }\n\n        cy.wrap({ foo: fn }).its('foo').should('eq', fn)\n      })\n\n      it('works with numerical indexes', () => {\n        cy.wrap(['foo', 'bar']).its(1).should('eq', 'bar')\n      })\n\n      it('works with 0 as a value if object has property 0', () => {\n        cy.wrap(['foo', 'bar']).its(0).should('eq', 'foo')\n        cy.wrap({ '0': 'whoa' }).its(0).should('eq', 'whoa')\n\n        // eslint-disable-next-line no-sparse-arrays\n        cy.wrap([/*empty*/, 'spooky']).its(0).should('not.exist')\n      })\n\n      it('reduces into dot separated values', () => {\n        const obj = {\n          foo: {\n            bar: {\n              baz: 'baz',\n            },\n          },\n        }\n\n        cy.wrap(obj).its('foo.bar.baz').should('eq', 'baz')\n      })\n\n      it('does not invoke a function and uses as a property', () => {\n        const fn = () => {\n          return 'fn'\n        }\n\n        fn.bar = 'bar'\n\n        cy.wrap(fn).its('bar').should('eq', 'bar')\n      })\n\n      it('does not invoke a function with multiple its', () => {\n        const fn = () => {\n          return 'fn'\n        }\n\n        fn.bar = () => {\n          return 'bar'\n        }\n\n        fn.bar.baz = 'baz'\n\n        cy.wrap(fn).its('bar').its('baz').should('eq', 'baz')\n      })\n\n      it('does not invoke a function and uses as a reduced property', () => {\n        const fn = () => {\n          return 'fn'\n        }\n\n        fn.bar = () => {\n          return 'bar'\n        }\n\n        fn.bar.baz = 'baz'\n\n        const obj = {\n          foo: fn,\n        }\n\n        cy.wrap(obj).its('foo.bar.baz').should('eq', 'baz')\n      })\n\n      it('does not invoke a function and can assert it throws', () => {\n        const err = new Error('nope cant access me')\n\n        const obj = {\n          foo () {\n            throw err\n          },\n        }\n\n        cy.wrap(obj).its('foo').should('throw', 'nope cant access me')\n      })\n\n      it('returns property', () => {\n        cy.noop({ baz: 'baz' }).its('baz').then((num) => {\n          expect(num).to.eq('baz')\n        })\n      })\n\n      it('returns property on remote subject', function () {\n        this.remoteWindow.$.fn.baz = 123\n\n        cy.get('div:first').its('baz').then((num) => {\n          expect(num).to.eq(123)\n        })\n      })\n\n      it('handles string subjects', () => {\n        const str = 'foobarbaz'\n\n        cy.noop(str).its('length').then((num) => {\n          expect(num).to.eq(str.length)\n        })\n      })\n\n      it('handles number subjects', () => {\n        const num = 12345\n\n        const { toFixed } = top.Number.prototype\n\n        cy.wrap(num).its('toFixed').should('eq', toFixed)\n      })\n\n      it('retries by default until property exists without an assertion', () => {\n        const obj = {}\n\n        cy.on('command:retry', _.after(3, () => {\n          return obj.foo = 'bar'\n        }))\n\n        cy.wrap(obj).its('foo').then((val) => {\n          expect(val).to.eq('bar')\n        })\n      })\n\n      it('retries until property is not undefined without an assertion', () => {\n        const obj = {\n          foo: undefined,\n        }\n\n        cy.on('command:retry', _.after(3, () => {\n          return obj.foo = 'bar'\n        }))\n\n        cy.wrap(obj).its('foo').then((val) => {\n          expect(val).to.eq('bar')\n        })\n      })\n\n      it('retries until property is not null without an assertion', () => {\n        const obj = {\n          foo: null,\n        }\n\n        cy.on('command:retry', _.after(3, () => {\n          return obj.foo = 'bar'\n        }))\n\n        cy.wrap(obj).its('foo').then((val) => {\n          expect(val).to.eq('bar')\n        })\n      })\n\n      it('retries when yielded undefined value and using assertion', () => {\n        const obj = { foo: '' }\n\n        cy.stub(obj, 'foo').get(\n          cy.stub()\n          .onCall(0).returns(undefined)\n          .onCall(1).returns(undefined)\n          .onCall(2).returns(true),\n        )\n\n        cy.wrap(obj).its('foo').should('eq', true)\n      })\n\n      it('retries until property does NOT exist with an assertion', () => {\n        const obj = {\n          foo: '',\n        }\n\n        cy.on('command:retry', _.after(3, () => {\n          return delete obj.foo\n        }))\n\n        cy.wrap(obj).its('foo').should('not.exist').then((val) => {\n          expect(val).to.be.undefined\n        })\n      })\n\n      it('passes when property does not exist on the subject with assertions', () => {\n        cy.wrap({}).its('foo').should('not.exist')\n        cy.wrap({}).its('foo').should('be.undefined')\n        cy.wrap({}).its('foo').should('not.be.ok')\n\n        // TODO: should these really pass here?\n        // isn't this the same situation as: cy.should('not.have.class', '...')\n        //\n        // when we use the 'eq' and 'not.eq' chainer aren't we effectively\n        // saying that it must *have* a value as opposed to the property not\n        // existing at all?\n        //\n        // does a tree falling in the forest really make a sound?\n        cy.wrap({}).its('foo').should('eq', undefined)\n        cy.wrap({}).its('foo').should('not.eq', 'bar')\n      })\n\n      it('passes when nested property does not exist on the subject with assertions', () => {\n        const obj = {\n          foo: {},\n        }\n\n        cy.wrap(obj).its('foo').should('not.have.property', 'bar')\n        cy.wrap(obj).its('foo.bar').should('not.exist')\n        cy.wrap(obj).its('foo.bar.baz').should('not.exist')\n      })\n\n      it('passes when property value is null with assertions', () => {\n        const obj = {\n          foo: null,\n        }\n\n        cy.wrap(obj).its('foo').should('be.null')\n        cy.wrap(obj).its('foo').should('eq', null)\n      })\n\n      it('passes when property value is undefined with assertions', () => {\n        const obj = {\n          foo: undefined,\n        }\n\n        cy.wrap(obj).its('foo').should('be.undefined')\n        cy.wrap(obj).its('foo').should('eq', undefined)\n      })\n\n      describe('accepts a options argument and works as without options argument', () => {\n        it('proxies to #invokeFn', () => {\n          const fn = () => {\n            return 'bar'\n          }\n\n          cy.wrap({ foo: fn }).its('foo', { log: false }).should('eq', fn)\n        })\n\n        it('does not invoke a function and uses as a property', () => {\n          const fn = () => {\n            return 'fn'\n          }\n\n          fn.bar = 'bar'\n\n          cy.wrap(fn).its('bar', { log: false }).should('eq', 'bar')\n        })\n\n        it('works with numerical indexes', () => {\n          cy.wrap(['foo', 'bar']).its(1, {}).should('eq', 'bar')\n        })\n\n        describe('.log', () => {\n          beforeEach(function () {\n            this.obj = {\n              foo: 'foo bar baz',\n              num: 123,\n            }\n\n            cy.on('log:added', (attrs, log) => {\n              this.lastLog = log\n            })\n\n            return null\n          })\n\n          it('logs obj as a property', function () {\n            cy.noop(this.obj).its('foo', { log: true }).then(function () {\n              const obj = {\n                name: 'its',\n                message: '.foo',\n              }\n\n              const { lastLog } = this\n\n              _.each(obj, (value, key) => {\n                expect(lastLog.get(key)).to.deep.eq(value)\n              })\n            })\n          })\n\n          it('#consoleProps as a regular property', function () {\n            cy.noop(this.obj).its('num', { log: true }).then(function () {\n              expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n                Command: 'its',\n                Property: '.num',\n                Subject: this.obj,\n                Yielded: 123,\n              })\n            })\n          })\n        })\n      })\n\n      describe('.log', () => {\n        beforeEach(function () {\n          this.obj = {\n            foo: 'foo bar baz',\n            num: 123,\n            bar () {\n              return 'bar'\n            },\n            attr (key, value) {\n              const obj = {}\n\n              obj[key] = value\n\n              return obj\n            },\n            sum (...args) {\n              return _.reduce(args, (memo, num) => {\n                return memo + num\n              }, 0)\n            },\n            baz () {},\n          }\n\n          this.obj.baz.quux = () => {\n            return 'quux'\n          }\n\n          this.obj.baz.lorem = 'ipsum'\n\n          this.logs = []\n\n          cy.on('log:added', (attrs, log) => {\n            this.lastLog = log\n            this.logs?.push(log)\n          })\n\n          return null\n        })\n\n        it('logs immediately before resolving', (done) => {\n          cy.on('log:added', (attrs, log) => {\n            if (log.get('name') === 'its') {\n              expect(log.get('state')).to.eq('pending')\n              expect(log.get('message')).to.eq('.foo')\n\n              done()\n            }\n          })\n\n          cy.noop({ foo: 'foo' }).its('foo')\n        })\n\n        it('snapshots after invoking', () => {\n          cy.noop({ foo: 'foo' }).its('foo').then(function () {\n            const { lastLog } = this\n\n            expect(lastLog.get('snapshots').length).to.eq(1)\n            expect(lastLog.get('snapshots')[0]).to.be.an('object')\n          })\n        })\n\n        it('ends', () => {\n          cy.noop({ foo: 'foo' }).its('foo').then(function () {\n            const { lastLog } = this\n\n            expect(lastLog.get('state')).to.eq('passed')\n            expect(lastLog.get('ended')).to.be.true\n          })\n        })\n\n        it('logs obj as a property', function () {\n          cy.noop(this.obj).its('foo').then(function () {\n            const obj = {\n              name: 'its',\n              message: '.foo',\n            }\n\n            const { lastLog } = this\n\n            _.each(obj, (value, key) => {\n              expect(lastLog.get(key)).to.deep.eq(value)\n            })\n          })\n        })\n\n        it('#consoleProps as a regular property', function () {\n          cy.noop(this.obj).its('num').then(function () {\n            expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n              Command: 'its',\n              Property: '.num',\n              Subject: this.obj,\n              Yielded: 123,\n            })\n          })\n        })\n\n        it('can be disabled', function () {\n          cy.noop(this.obj).its('num', { log: true }).then(function () {\n            expect(this.lastLog.invoke('consoleProps')).to.have.property('Property', '.num')\n            this.lastLog = undefined\n          })\n\n          cy.noop(this.obj).its('num', { log: false }).then(function () {\n            expect(this.lastLog).to.be.undefined\n          })\n        })\n      })\n\n      describe('errors', {\n        defaultCommandTimeout: 100,\n      }, () => {\n        beforeEach(function () {\n          this.logs = []\n\n          cy.on('log:added', (attrs, log) => {\n            if (attrs.name === 'its') {\n              this.lastLog = log\n            }\n\n            this.logs?.push(log)\n          })\n\n          return null\n        })\n\n        it('throws without a subject', (done) => {\n          cy.on('fail', (err) => {\n            expect(err.message).to.include('cy.its(\"wat\")')\n            expect(err.message).to.include('child command before running a parent command')\n\n            done()\n          })\n\n          return cy.its('wat')\n        })\n\n        it('throws when property does not exist', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('Timed out retrying after 100ms: `cy.its()` errored because the property: `foo` does not exist on your subject.')\n            expect(err.message).to.include('`cy.its()` waited for the specified property `foo` to exist, but it never did.')\n            expect(err.message).to.include('If you do not expect the property `foo` to exist, then add an assertion such as:')\n            expect(err.message).to.include('`cy.wrap({ foo: \\'bar\\' }).its(\\'quux\\').should(\\'not.exist\\')`')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/its')\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          cy.wrap({}).its('foo')\n        })\n\n        it('throws when property is undefined', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('Timed out retrying after 100ms: `cy.its()` errored because the property: `foo` returned a `undefined` value.')\n            expect(err.message).to.include('`cy.its()` waited for the specified property `foo` to become accessible, but it never did.')\n            expect(err.message).to.include('If you expect the property `foo` to be `undefined`, then add an assertion such as:')\n            expect(err.message).to.include('`cy.wrap({ foo: undefined }).its(\\'foo\\').should(\\'be.undefined\\')`')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/its')\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          cy.wrap({ foo: undefined }).its('foo')\n        })\n\n        it('throws when property is null', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('Timed out retrying after 100ms: `cy.its()` errored because the property: `foo` returned a `null` value.')\n            expect(err.message).to.include('`cy.its()` waited for the specified property `foo` to become accessible, but it never did.')\n            expect(err.message).to.include('If you expect the property `foo` to be `null`, then add an assertion such as:')\n            expect(err.message).to.include('`cy.wrap({ foo: null }).its(\\'foo\\').should(\\'be.null\\')`')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/its')\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          cy.wrap({ foo: null }).its('foo')\n        })\n\n        it('throws the traversalErr as precedence when property does not exist even if the additional assertions fail', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('Timed out retrying after 100ms: `cy.its()` errored because the property: `b` does not exist on your subject.')\n            expect(err.message).to.include('`cy.its()` waited for the specified property `b` to exist, but it never did.')\n            expect(err.message).to.include('If you do not expect the property `b` to exist, then add an assertion such as:')\n            expect(err.message).to.include('`cy.wrap({ foo: \\'bar\\' }).its(\\'quux\\').should(\\'not.exist\\')`')\n\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          cy.wrap({ a: 'a' }).its('b').should('be.true')\n        })\n\n        it('throws the traversalErr as precedence when property value is undefined even if the additional assertions fail', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('Timed out retrying after 100ms: `cy.its()` errored because the property: `a` returned a `undefined` value.')\n            expect(err.message).to.include('`cy.its()` waited for the specified property `a` to become accessible, but it never did.')\n            expect(err.message).to.include('If you expect the property `a` to be `undefined`, then add an assertion such as:')\n            expect(err.message).to.include('`cy.wrap({ foo: undefined }).its(\\'foo\\').should(\\'be.undefined\\')`')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/its')\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          cy.wrap({ a: undefined }).its('a').should('be.true')\n        })\n\n        it('does not display parenthesis on command', function (done) {\n          const obj = {\n            foo: {\n              bar () {},\n            },\n          }\n\n          obj.foo.bar.baz = () => {\n            return 'baz'\n          }\n\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(lastLog.get('error').message).to.include(err.message)\n            expect(lastLog.invoke('consoleProps').Property).to.eq('.foo.bar.baz')\n\n            done()\n          })\n\n          cy.wrap(obj).its('foo.bar.baz').should('eq', 'baz')\n        })\n\n        it('can handle getter that throws', (done) => {\n          const spy = cy.spy((err) => {\n            expect(err.message).to.eq('Timed out retrying after 100ms: some getter error')\n\n            done()\n          }).as('onFail')\n\n          cy.on('fail', spy)\n\n          const obj = {}\n\n          Object.defineProperty(obj, 'foo', {\n            get () {\n              throw new Error('some getter error')\n            },\n          })\n\n          cy.wrap(obj).its('foo')\n        })\n\n        it('throws when reduced property does not exist on the subject', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('Timed out retrying after 100ms: `cy.its()` errored because the property: `baz` does not exist on your subject.')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/its')\n            expect(lastLog.get('error').message).to.include(err.message)\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          const obj = {\n            foo: {\n              bar: {},\n            },\n          }\n\n          cy.wrap(obj).its('foo.bar.baz.fizz')\n        });\n\n        [null, undefined].forEach((val) => {\n          it(`throws on traversed '${val}' subject`, (done) => {\n            cy.on('fail', (err) => {\n              expect(err.message).to.include(`Timed out retrying after 100ms: \\`cy.its()\\` errored because the property: \\`a\\` returned a \\`${val}\\` value. The property: \\`b\\` does not exist on a \\`${val}\\` value.`)\n              expect(err.message).to.include('`cy.its()` waited for the specified property `b` to become accessible, but it never did.')\n              expect(err.message).to.include('If you do not expect the property `b` to exist, then add an assertion such as:')\n              expect(err.message).to.include(`\\`cy.wrap({ foo: ${val} }).its('foo.baz').should('not.exist')\\``)\n              expect(err.docsUrl).to.eq('https://on.cypress.io/its')\n\n              done()\n            })\n\n            cy.wrap({ a: val }).its('a.b.c')\n          })\n\n          it(`throws on initial '${val}' subject`, (done) => {\n            cy.on('fail', (err) => {\n              expect(err.message).to.include(`Timed out retrying after 100ms: \\`cy.its()\\` errored because your subject is: \\`${val}\\`. You cannot access any properties such as \\`foo\\` on a \\`${val}\\` value.`)\n              expect(err.message).to.include(`If you expect your subject to be \\`${val}\\`, then add an assertion such as:`)\n              expect(err.message).to.include(`\\`cy.wrap(${val}).should('be.${val}')\\``)\n              expect(err.docsUrl).to.eq('https://on.cypress.io/its')\n\n              done()\n            })\n\n            cy.wrap(val).its('foo')\n          })\n        })\n\n        it('throws does not accept additional arguments', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('`cy.its()` does not accept additional arguments.')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/its')\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          const fn = () => {\n            return 'fn'\n          }\n\n          fn.bar = () => {\n            return 'bar'\n          }\n\n          fn.bar.baz = 'baz'\n\n          cy.wrap(fn).its('bar', { log: false }, 'baz').should('eq', 'baz')\n        })\n\n        it('throws when options argument is not an object', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('`cy.its()` only accepts an object as the options argument.')\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          cy.wrap({ foo: 'string' }).its('foo', 'bar')\n        })\n\n        it('throws when property name is missing', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('`cy.its()` expects the propertyName argument to have a value')\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          cy.wrap({ foo: 'foo' }).its()\n        })\n\n        it('throws when property name is not of type string', function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('`cy.its()` only accepts a string or a number as the propertyName argument.')\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          cy.wrap({ foo: 'foo' }).its(true)\n        })\n\n        it('resets traversalErr and throws the right assertion', function (done) {\n          cy.timeout(200)\n\n          const obj = {}\n\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include('Timed out retrying after 200ms: expected \\'bar\\' to equal \\'baz\\'')\n            expect(lastLog.get('error').message).to.include(err.message)\n\n            done()\n          })\n\n          cy.on('command:retry', _.after(3, () => {\n            obj.foo = {\n              bar: 'bar',\n            }\n          }))\n\n          cy.noop(obj).its('foo.bar').should('eq', 'baz')\n        })\n\n        it('consoleProps subject', function (done) {\n          cy.on('fail', (err) => {\n            expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n              Command: 'its',\n              Property: '.fizz.buzz',\n              Error: this.lastLog.get('error').stack,\n              Subject: { foo: 'bar' },\n              Yielded: undefined,\n            })\n\n            done()\n          })\n\n          cy.noop({ foo: 'bar' }).its('fizz.buzz')\n        })\n      })\n    })\n  })\n\n  describe('without jquery', () => {\n    before(() => {\n      cy\n      .visit('/fixtures/dom.html')\n      .then(function (win) {\n        this.body = win.document.body.outerHTML\n      })\n    })\n\n    beforeEach(function () {\n      const doc = cy.state('document')\n\n      $(doc.body).empty().html(this.body)\n    })\n\n    context('#each', () => {\n      it('invokes callback function with runnable.ctx', function () {\n        const ctx = this\n\n        cy.wrap([1]).each(function () {\n          expect(ctx === this).to.be.true\n        })\n      })\n\n      it('can each a single element', () => {\n        let count = 0\n\n        cy.get('#dom').each(() => {\n          return count += 1\n        }).then(() => {\n          expect(count).to.eq(1)\n        })\n      })\n\n      it('passes the existing subject downstream without side effects', () => {\n        let count = 0\n\n        const $lis = cy.$$('#list li')\n\n        expect($lis).to.have.length(3)\n\n        cy.get('#list li').each(($li, i, arr) => {\n          expect(i).to.eq(count)\n          count += 1\n          expect(arr.length).to.eq(3)\n\n          cy.wrap($li).should('have.class', 'item')\n        }).then(($lis) => {\n          expect(count).to.eq(3)\n          expect($lis).to.have.length(3)\n        })\n      })\n\n      it('awaits promises returned', () => {\n        let count = 0\n\n        const start = new Date()\n\n        cy.get('#list li').each(($li, i, arr) => {\n          return new Promise((resolve, reject) => {\n            _.delay(() => {\n              count += 1\n\n              resolve()\n            }, 20)\n          })\n        }).then(($lis) => {\n          expect(count).to.eq(3)\n          expect(new Date() - start).to.be.gt(60)\n        })\n      })\n\n      it('supports array like structures', () => {\n        let count = 0\n        const arr = [1, 2, 3]\n\n        cy.wrap(arr).each((num, i, a) => {\n          expect(a).to.eq(arr)\n          expect(i).to.eq(count)\n          count += 1\n\n          expect(num).to.eq(count)\n        }).then((a) => {\n          expect(a).to.eq(arr)\n        })\n      })\n\n      it('ends early when returning false', () => {\n        const arr = [1, 2, 3]\n\n        // after 2 calls return false\n        // to end the loop early\n        let fn = _.after(2, () => {\n          return false\n        })\n\n        fn = cy.spy(fn)\n\n        cy.wrap(arr).each(fn)\n        .then((a) => {\n          expect(fn).to.be.calledTwice\n        })\n      })\n\n      it('works with nested eaches', () => {\n        let count = 0\n\n        cy.get('#list li').each(($li, i, arr) => {\n          cy.wrap($li).parent().siblings('#asdf').find('li').each(($li2, i2, arr2) => {\n            return count += 1\n          }).then(($lis) => {\n            expect($lis.first()).to.have.text('asdf 1')\n            expect($lis).to.have.length(3)\n          })\n        }).then(($lis) => {\n          expect($lis).to.have.length(3)\n          expect($lis.first()).to.have.text('li 0')\n          expect(count).to.eq(9)\n        })\n      })\n\n      it('can operate on a single element', () => {\n        let count = 0\n\n        cy.get('div:first').each(($div) => {\n          return count += 1\n        }).then(() => {\n          expect(count).to.eq(1)\n        })\n      })\n\n      // https://github.com/cypress-io/cypress/issues/4921\n      it('dual commands like contains() work after each()', () => {\n        cy.contains('New York')\n        cy.get('span').each(() => {})\n        cy.contains('New York')\n      })\n\n      describe('errors', {\n        defaultCommandTimeout: 100,\n      }, () => {\n        beforeEach(function () {\n          this.logs = []\n\n          cy.on('log:added', (attrs, log) => {\n            this.lastLog = log\n            this.logs?.push(log)\n          })\n\n          return null\n        })\n\n        it('can time out', function (done) {\n          cy.on('fail', (err) => {\n            // get + each\n            expect(this.logs.length).to.eq(2)\n            expect(err.message).to.include('`cy.each()` timed out after waiting `100ms`.\\n\\nYour callback function returned a promise that never resolved.')\n            expect(err.docsUrl).to.include('https://on.cypress.io/each')\n\n            done()\n          })\n\n          cy.get('ul').each(($ul) => {\n            return new Promise((resolve) => {})\n          })\n        })\n\n        it('throws when not passed a callback function', function (done) {\n          const logs = []\n\n          cy.on('log:added', (attrs, log) => {\n            logs?.push(log)\n          })\n\n          cy.on('fail', (err) => {\n            // get + each\n            expect(this.logs.length).to.eq(2)\n            expect(err.message).to.include('`cy.each()` must be passed a callback function.')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/each')\n\n            done()\n          })\n\n          cy.get('ul').each({})\n        })\n\n        it('throws when not passed a number', function (done) {\n          cy.on('fail', (err) => {\n            // get + each\n            expect(this.logs.length).to.eq(2)\n            expect(err.message).to.include('`cy.each()` can only operate on an array like subject. Your subject was: `100`')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/each')\n\n            done()\n          })\n\n          cy.wrap(100).each(() => {})\n        })\n\n        it('throws when not passed an array like structure', function (done) {\n          cy.on('fail', (err) => {\n            // get + each\n            expect(this.logs.length).to.eq(2)\n            expect(err.message).to.include('`cy.each()` can only operate on an array like subject. Your subject was: `{}`')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/each')\n\n            done()\n          })\n\n          cy.wrap({}).each(() => {})\n        })\n      })\n    })\n  })\n})\n",
    "packages/driver/cypress/integration/commands/navigation_spec.js": "const Cookie = require('js-cookie')\nconst { stripIndent } = require('common-tags')\nconst helpers = require('../../support/helpers')\n\nconst { _, Promise, $ } = Cypress\n\ndescribe('src/cy/commands/navigation', () => {\n  context('#reload', () => {\n    before(() => {\n      cy\n      .visit('/fixtures/generic.html')\n      .then(function (win) {\n        this.body = win.document.body.outerHTML\n      })\n    })\n\n    beforeEach(function () {\n      const doc = cy.state('document')\n\n      this.win = cy.state('window')\n\n      $(doc.body).empty().html(this.body)\n    })\n\n    afterEach(function () {\n      cy.state('window', this.win)\n    })\n\n    it('calls into window.location.reload', () => {\n      const locReload = cy.spy(Cypress.utils, 'locReload')\n\n      cy.reload().then(() => {\n        expect(locReload).to.be.calledWith(false)\n      })\n    })\n\n    it('can pass forceReload', () => {\n      const locReload = cy.spy(Cypress.utils, 'locReload')\n\n      cy.reload(true).then(() => {\n        expect(locReload).to.be.calledWith(true)\n      })\n    })\n\n    it('can pass forceReload + options', () => {\n      const locReload = cy.spy(Cypress.utils, 'locReload')\n\n      cy.reload(true, {}).then(() => {\n        expect(locReload).to.be.calledWith(true)\n      })\n    })\n\n    it('can pass just options', () => {\n      const locReload = cy.spy(Cypress.utils, 'locReload')\n\n      cy.reload({}).then(() => {\n        expect(locReload).to.be.calledWith(false)\n      })\n    })\n\n    it('returns the window object', () => {\n      cy\n      .window().then((oldWin) => {\n        oldWin.foo = 'bar'\n        expect(oldWin.foo).to.eq('bar')\n\n        cy.reload().then((win) => {\n          expect(win).not.to.be.undefined\n          expect(win.foo).to.be.undefined\n\n          expect(win).to.eq(cy.state('window'))\n        })\n      })\n    })\n\n    it('sdfsdfdsf', function () {\n      $('sd')\n    })\n\n    it('removes window:load listeners', () => {\n      const listeners = cy.listeners('window:load')\n\n      const winLoad = cy.spy(cy, 'once').withArgs('window:load')\n\n      cy.reload().then(() => {\n        expect(winLoad).to.be.calledOnce\n        expect(cy.listeners('window:load')).to.deep.eq(listeners)\n      })\n    })\n\n    // TODO: fix this\n    it.skip('(FLAKY) sets timeout to Cypress.config(pageLoadTimeout)', {\n      pageLoadTimeout: 4567,\n    }, () => {\n      const timeout = cy.spy(Promise.prototype, 'timeout')\n\n      cy.reload().then(() => {\n        expect(timeout).to.be.calledWith(4567, 'reload')\n      })\n    })\n\n    it('fires stability:changed and window events events', () => {\n      const stub1 = cy.stub()\n      const stub2 = cy.stub()\n      const stub3 = cy.stub()\n\n      cy.on('stability:changed', stub1)\n      cy.on('window:before:unload', stub2)\n      cy.on('window:unload', stub3)\n\n      cy.reload().then(() => {\n        expect(stub1.firstCall).to.be.calledWith(false, 'beforeunload')\n        expect(stub1.secondCall).to.be.calledWith(true, 'load')\n        expect(stub2).to.be.calledOnce\n        expect(stub3).to.be.calledOnce\n      })\n    })\n\n    it('removes listeners', () => {\n      const win = cy.state('window')\n\n      const rel = cy.stub(win, 'removeEventListener')\n\n      cy.reload().then(() => {\n        expect(rel).to.be.calledWith('beforeunload')\n        expect(rel).to.be.calledWith('unload')\n      })\n    })\n\n    describe('errors', {\n      defaultCommandTimeout: 100,\n    }, () => {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          this.lastLog = log\n          this.logs.push(log)\n        })\n\n        return null\n      })\n\n      it('logs once on failure', {\n        defaultCommandTimeout: 200,\n      }, function (done) {\n        cy.on('fail', (err) => {\n          expect(this.logs.length).to.eq(1)\n\n          done()\n        })\n\n        cy.reload(Infinity)\n      })\n\n      it('throws passing more than 2 args', {\n        defaultCommandTimeout: 1000,\n      }, (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.eq('`cy.reload()` can only accept a boolean or `options` as its arguments.')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/reload')\n\n          done()\n        })\n\n        cy.reload(1, 2, 3)\n      })\n\n      it('throws passing 2 invalid arguments', { defaultCommandTimeout: 200, retries: 1 }, (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.eq('`cy.reload()` can only accept a boolean or `options` as its arguments.')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/reload')\n\n          done()\n        })\n\n        cy.reload(true, 1)\n      })\n\n      it('throws passing 1 invalid argument', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.eq('`cy.reload()` can only accept a boolean or `options` as its arguments.')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/reload')\n\n          done()\n        })\n\n        cy.reload(1)\n      })\n\n      it('fully refreshes page', () => {\n        cy\n        .window().then((win) => {\n          win.foo = 'foo'\n        })\n        .reload()\n        .window().then((win) => {\n          expect(win.foo).to.be.undefined\n        })\n      })\n\n      it('throws when reload times out', (done) => {\n        cy.timeout(1000)\n        cy.spy(Cypress.utils, 'locReload')\n\n        cy\n        .visit('/timeout?ms=100').then(() => {\n          let expected = false\n\n          // wait until the window finishes loading first\n          // else we can potentially move onto the next test\n          // while we're still unstable, which will result in\n          // properties on the window being inaccessible\n          // since we only visit once at the beginning of these tests\n          cy.on('window:load', () => {\n            expect(expected).to.be.true\n\n            done()\n          })\n\n          cy.on('fail', (err) => {\n            expected = true\n\n            expect(err.message).to.include('Your page did not fire its `load` event within `1ms`.')\n          })\n        })\n        .reload({ timeout: 1 })\n      })\n    })\n\n    describe('.log', () => {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          if (attrs.name === 'reload') {\n            this.lastLog = log\n          }\n\n          this.logs.push(log)\n        })\n\n        return null\n      })\n\n      it('logs reload', () => {\n        cy.reload().then(function () {\n          expect(this.lastLog.get('name')).to.eq('reload')\n        })\n      })\n\n      it('can turn off logging', () => {\n        cy.reload({ log: false }).then(function () {\n          expect(this.lastLog).to.be.undefined\n        })\n      })\n\n      it('does not log \\'Page Load\\' events', () => {\n        cy.reload().then(function () {\n          this.logs.slice(0).forEach((log) => {\n            expect(log.get('name')).not.eq('page load')\n          })\n        })\n      })\n\n      it('logs before + after', () => {\n        let beforeunload = false\n\n        cy\n        .window().then(function () {\n          cy.on('window:before:unload', () => {\n            const { lastLog } = this\n\n            beforeunload = true\n            expect(lastLog.get('snapshots').length).to.eq(1)\n            expect(lastLog.get('snapshots')[0].name).to.eq('before')\n            expect(lastLog.get('snapshots')[0].body).to.be.an('object')\n\n            return undefined\n          })\n        }).reload().then(function () {\n          const { lastLog } = this\n\n          expect(beforeunload).to.be.true\n          expect(lastLog.get('snapshots').length).to.eq(2)\n          expect(lastLog.get('snapshots')[1].name).to.eq('after')\n\n          expect(lastLog.get('snapshots')[1].body).to.be.an('object')\n        })\n      })\n    })\n  })\n\n  context('#go', () => {\n    before(() => {\n      cy\n      .visit('/fixtures/generic.html')\n      .then(function (win) {\n        this.body = win.document.body.outerHTML\n      })\n    })\n\n    beforeEach(function () {\n      const doc = cy.state('document')\n\n      $(doc.body).empty().html(this.body)\n    })\n\n    // TODO: fix this\n    it.skip('(FLAKY) sets timeout to Cypress.config(pageLoadTimeout)', {\n      pageLoadTimeout: 4567,\n    }, () => {\n      const timeout = cy.spy(Promise.prototype, 'timeout')\n\n      cy\n      .visit('/fixtures/jquery.html')\n      .go('back').then(() => {\n        expect(timeout).to.be.calledWith(4567, 'go')\n      })\n    })\n\n    it('removes listeners', () => {\n      cy\n      .visit('/fixtures/generic.html')\n      .visit('/fixtures/jquery.html')\n      .then(() => {\n        const winLoadListeners = cy.listeners('window:load')\n        const beforeWinUnloadListeners = cy.listeners('window:before:unload')\n\n        const cyOn = cy.spy(cy, 'once')\n\n        const winLoad = cyOn.withArgs('window:load')\n        const beforeWinUnload = cyOn.withArgs('window:before:unload')\n\n        cy.go('back').then(() => {\n          expect(winLoad).to.be.calledOnce\n          expect(beforeWinUnload).to.be.calledOnce\n\n          expect(cy.listeners('window:load')).to.deep.eq(winLoadListeners)\n          expect(cy.listeners('window:before:unload')).to.deep.eq(beforeWinUnloadListeners)\n        })\n      })\n    })\n\n    it('fires stability:changed and window events events', () => {\n      const stub1 = cy.stub()\n      const stub2 = cy.stub()\n      const stub3 = cy.stub()\n\n      cy\n      .visit('/fixtures/generic.html')\n      .visit('/fixtures/jquery.html')\n      .then(() => {\n        cy.on('stability:changed', stub1)\n        cy.on('window:before:unload', stub2)\n        cy.on('window:unload', stub3)\n      })\n      .go('back').then(() => {\n        expect(stub1.firstCall).to.be.calledWith(false, 'beforeunload')\n        expect(stub1.secondCall).to.be.calledWith(true, 'load')\n        expect(stub2).to.be.calledOnce\n        expect(stub3).to.be.calledOnce\n      })\n    })\n\n    it('removes listeners from window', () => {\n      cy\n      .visit('/fixtures/generic.html')\n      .visit('/fixtures/jquery.html')\n      .then((win) => {\n        const rel = cy.stub(win, 'removeEventListener')\n\n        cy.go('back').then(() => {\n          expect(rel).to.be.calledWith('beforeunload')\n          expect(rel).to.be.calledWith('unload')\n        })\n      })\n    })\n\n    describe('errors', {\n      defaultCommandTimeout: 50,\n    }, () => {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          if (attrs.name === 'go') {\n            this.lastLog = log\n            this.logs.push(log)\n          }\n        })\n\n        return null\n      })\n\n      _.each([null, undefined, NaN, Infinity, {}, [], () => {}], (val) => {\n        it(`throws on: '${val}'`, (done) => {\n          cy.on('fail', (err) => {\n            expect(err.message).to.eq('`cy.go()` accepts only a string or number argument')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/go')\n\n            done()\n          })\n\n          cy.go(val)\n        })\n      })\n\n      it('throws on invalid string', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.eq('`cy.go()` accepts either `forward` or `back`. You passed: `foo`')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/go')\n\n          done()\n        })\n\n        cy.go('foo')\n      })\n\n      it('throws on zero', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.eq('`cy.go()` cannot accept `0`. The number must be greater or less than `0`.')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/go')\n\n          done()\n        })\n\n        cy.go(0)\n      })\n\n      it('throws when go times out', (done) => {\n        cy.timeout(1000)\n\n        cy\n        .visit('/timeout?ms=100')\n        .visit('/fixtures/jquery.html')\n        .then(() => {\n          let expected = false\n\n          // wait until the window finishes loading first\n          // else we can potentially move onto the next test\n          // while we're still unstable, which will result in\n          // properties on the window being inaccessible\n          // since we only visit once at the beginning of these tests\n          cy.on('window:load', () => {\n            expect(expected).to.be.true\n\n            done()\n          })\n\n          cy.on('fail', (err) => {\n            expected = true\n\n            expect(err.message).to.include('Your page did not fire its `load` event within `1ms`.')\n          })\n\n          cy.go('back', { timeout: 1 })\n        })\n      })\n\n      it('only logs once on error', function (done) {\n        cy.on('fail', (err) => {\n          expect(this.logs.length).to.eq(1)\n          expect(this.logs[0].get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy\n        .visit('/fixtures/jquery.html')\n        .go('back', { timeout: 1 })\n      })\n    })\n\n    describe('.log', () => {\n      beforeEach(() => {\n        cy.visit('/fixtures/generic.html').then(function () {\n          this.logs = []\n\n          cy.on('log:added', (attrs, log) => {\n            if (attrs.name === 'go') {\n              this.lastLog = log\n            }\n\n            this.logs.push(log)\n          })\n\n          return null\n        })\n      })\n\n      it('logs go', () => {\n        cy\n        .visit('/fixtures/jquery.html')\n        .go('back').then(function () {\n          const { lastLog } = this\n\n          expect(lastLog.get('name')).to.eq('go')\n          expect(lastLog.get('message')).to.eq('back')\n        })\n      })\n\n      it('can turn off logging', () => {\n        cy\n        .visit('/fixtures/jquery.html')\n        .go('back', { log: false }).then(function () {\n          expect(this.lastLog).to.be.undefined\n        })\n      })\n\n      it('does not log \\'Page Load\\' events', () => {\n        cy\n        .visit('/fixtures/jquery.html')\n        .go('back').then(function () {\n          this.logs.slice(0).forEach((log) => {\n            expect(log.get('name')).not.eq('page load')\n          })\n        })\n      })\n\n      it('logs before + after', () => {\n        let beforeunload = false\n\n        cy\n        .visit('/fixtures/jquery.html')\n        .window().then(function (win) {\n          cy.on('window:before:unload', () => {\n            const { lastLog } = this\n\n            beforeunload = true\n            expect(lastLog.get('snapshots').length).to.eq(1)\n            expect(lastLog.get('snapshots')[0].name).to.eq('before')\n            expect(lastLog.get('snapshots')[0].body).to.be.an('object')\n\n            return undefined\n          })\n\n          cy.go('back').then(function () {\n            const { lastLog } = this\n\n            expect(beforeunload).to.be.true\n            expect(lastLog.get('snapshots').length).to.eq(2)\n            expect(lastLog.get('snapshots')[1].name).to.eq('after')\n            expect(lastLog.get('snapshots')[1].body).to.be.an('object')\n          })\n        })\n      })\n    })\n  })\n\n  context('#visit', () => {\n    // TODO: fix this\n    it.skip('(FLAKY) sets timeout to Cypress.config(pageLoadTimeout)', {\n      pageLoadTimeout: 4567,\n    }, () => {\n      const timeout = cy.spy(Promise.prototype, 'timeout')\n\n      cy.visit('/fixtures/jquery.html').then(() => {\n        expect(timeout).to.be.calledWith(4567)\n      })\n    })\n\n    it('removes window:load listeners', () => {\n      const listeners = cy.listeners('window:load')\n\n      const winLoad = cy.spy(cy, 'once').withArgs('window:load')\n\n      cy.visit('/fixtures/generic.html').then(() => {\n        // once for about:blank, once for $iframe src\n        expect(winLoad).to.be.calledTwice\n        expect(cy.listeners('window:load')).to.deep.eq(listeners)\n      })\n    })\n\n    it('can visit pages on the same originPolicy', () => {\n      cy\n      .visit('http://localhost:3500/fixtures/jquery.html')\n      .visit('http://localhost:3500/fixtures/generic.html')\n      .visit('http://localhost:3500/fixtures/dimensions.html')\n    })\n\n    it('resolves the subject to the remote iframe window', () => {\n      cy.visit('/fixtures/jquery.html').then((win) => {\n        expect(win).to.eq(cy.state('$autIframe').prop('contentWindow'))\n      })\n    })\n\n    it('changes the src of the iframe to the initial src', () => {\n      cy.visit('/fixtures/jquery.html').then(() => {\n        const src = cy.state('$autIframe').attr('src')\n\n        expect(src).to.eq('http://localhost:3500/fixtures/jquery.html')\n      })\n    })\n\n    it('invokes onLoad callback', function (done) {\n      const ctx = this\n\n      cy.visit('/fixtures/jquery.html', {\n        onLoad (contentWindow) {\n          const thisValue = this === ctx\n\n          expect(thisValue).be.true\n          expect(!!contentWindow.Cypress).to.be.true\n\n          done()\n        },\n      })\n    })\n\n    it('invokes onBeforeLoad callback with cy context', function (done) {\n      const ctx = this\n\n      cy.visit('/fixtures/jquery.html', {\n        onBeforeLoad (contentWindow) {\n          const thisValue = this === ctx\n\n          expect(thisValue).be.true\n\n          expect(!!contentWindow.Cypress).to.be.true\n\n          done()\n        },\n      })\n    })\n\n    it('does not error without an onBeforeLoad callback', () => {\n      cy.visit('/fixtures/jquery.html').then(() => {\n        const prev = cy.state('current').get('prev')\n\n        expect(prev.get('args')).to.have.length(1)\n      })\n    })\n\n    it('calls resolve:url with http:// when localhost', () => {\n      const backend = cy.spy(Cypress, 'backend')\n\n      cy\n      .visit('localhost:3500/timeout')\n      .then(() => {\n        expect(backend).to.be.calledWith('resolve:url', 'http://localhost:3500/timeout')\n      })\n    })\n\n    it('prepends hostname when visiting locally', () => {\n      const prop = cy.spy(cy.state('$autIframe'), 'prop')\n\n      cy\n      .visit('fixtures/jquery.html')\n      .then(() => {\n        expect(prop).to.be.calledWith('src', 'http://localhost:3500/fixtures/jquery.html')\n      })\n    })\n\n    it('can visit relative pages on the same originPolicy', () => {\n      // as long as we are already on the localhost:3500\n      // domain this will work\n      cy\n      .visit('http://localhost:3500/fixtures/dimensions.html')\n      .visit('/fixtures/jquery.html')\n    })\n\n    it('can visit relative pages with domain like query params', () => {\n      cy\n      .visit('http://localhost:3500/fixtures/generic.html')\n      .visit('http://localhost:3500/fixtures/dimensions.html?email=briancypress.io')\n    })\n\n    it('can visit pages with non-2xx status codes when option failOnStatusCode is false', () => {\n      cy\n      .visit('localhost:3500/status-404', { failOnStatusCode: false })\n      .visit('localhost:3500/status-500', { failOnStatusCode: false })\n    })\n\n    it('strips username + password out of the url when provided', () => {\n      const backend = cy.spy(Cypress, 'backend')\n\n      cy\n      .visit('http://cypress:password123@localhost:3500/timeout')\n      .then(() => {\n        expect(backend).to.be.calledWith('resolve:url', 'http://localhost:3500/timeout')\n      })\n    })\n\n    it('passes auth options', () => {\n      const backend = cy.spy(Cypress, 'backend')\n\n      const auth = {\n        username: 'cypress',\n        password: 'password123',\n      }\n\n      cy\n      .visit('http://localhost:3500/timeout', { auth })\n      .then(() => {\n        expect(backend).to.be.calledWithMatch('resolve:url', 'http://localhost:3500/timeout', { auth })\n      })\n    })\n\n    it('does not support file:// protocol', {\n      baseUrl: '',\n    }, (done) => {\n      cy.on('fail', (err) => {\n        expect(err.message).to.contain('`cy.visit()` failed because the \\'file://...\\' protocol is not supported by Cypress.')\n\n        done()\n      })\n\n      cy.visit('file:///cypress/fixtures/generic.html')\n    })\n\n    // https://github.com/cypress-io/cypress/issues/1727\n    it('can visit a page with undefined content type and html-shaped body', () => {\n      cy.visit('http://localhost:3500/undefined-content-type')\n    })\n\n    // https://github.com/cypress-io/cypress/issues/14445\n    it('should eventually fail on assertion despite redirects', (done) => {\n      cy.on('fail', (err) => {\n        expect(err.message).to.contain('The application redirected to')\n\n        done()\n      })\n\n      cy.visit('fixtures/redirection-loop-a.html')\n      cy.get('div').should('contain', 'this should fail?')\n    })\n\n    describe('when only hashes are changing', () => {\n      it('short circuits the visit if the page will not refresh', () => {\n        let count = 0\n        const urls = []\n\n        cy.on('window:load', () => {\n          urls.push(cy.state('window').location.href)\n\n          count += 1\n        })\n\n        cy\n        // about:blank yes (1)\n        .visit('/fixtures/generic.html?foo#bar') // yes (2)\n        .visit('/fixtures/generic.html?foo#foo') // no (2)\n        .visit('/fixtures/generic.html?bar#bar') // yes (3)\n        .visit('/fixtures/dimensions.html?bar#bar') // yes (4)\n        .visit('/fixtures/dimensions.html?baz#bar') // yes (5)\n        .visit('/fixtures/dimensions.html#bar') // yes (6)\n        .visit('/fixtures/dimensions.html') // yes (7)\n        .visit('/fixtures/dimensions.html#baz') // no (7)\n        .visit('/fixtures/dimensions.html#') // no (7)\n        .then(() => {\n          expect(count).to.eq(7)\n\n          expect(urls).to.deep.eq([\n            'about:blank',\n            'http://localhost:3500/fixtures/generic.html?foo#bar',\n            'http://localhost:3500/fixtures/generic.html?bar#bar',\n            'http://localhost:3500/fixtures/dimensions.html?bar#bar',\n            'http://localhost:3500/fixtures/dimensions.html?baz#bar',\n            'http://localhost:3500/fixtures/dimensions.html#bar',\n            'http://localhost:3500/fixtures/dimensions.html',\n          ])\n        })\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/1311\n    it('window immediately resolves and doesn\\'t reload when visiting the same URL with hashes', () => {\n      const onLoad = cy.stub()\n\n      cy\n      .visit('http://localhost:3500/fixtures/generic.html#foo').then((win) => {\n        win.foo = 'bar'\n      })\n      .visit('http://localhost:3500/fixtures/generic.html#foo', {\n        onLoad,\n      })\n      .then((win) => {\n        expect(win.bar).to.not.exist\n        expect(onLoad).not.to.have.been.called\n      })\n    })\n\n    it('can send headers', () => {\n      cy.visit({\n        url: 'http://localhost:3500/dump-headers',\n        headers: {\n          'x-foo-baz': 'bar-quux',\n        },\n      })\n\n      cy.contains('\"x-foo-baz\":\"bar-quux\"')\n    })\n\n    it('can send user-agent header', () => {\n      cy.visit({\n        url: 'http://localhost:3500/dump-headers',\n        headers: {\n          'user-agent': 'something special',\n        },\n      })\n\n      cy.contains('\"user-agent\":\"something special\"')\n    })\n\n    it('can send querystring params', () => {\n      const qs = { 'foo bar': 'baz quux' }\n\n      cy\n      .visit('http://localhost:3500/dump-qs', { qs })\n      .then(() => {\n        cy.contains(JSON.stringify(qs))\n\n        cy.url().should('eq', 'http://localhost:3500/dump-qs?foo%20bar=baz%20quux')\n      })\n    })\n\n    describe('can send a POST request', () => {\n      it('automatically urlencoded using an object body', () => {\n        cy.visit('http://localhost:3500/post-only', {\n          method: 'POST',\n          body: {\n            bar: 'baz',\n          },\n        })\n\n        cy.contains('it worked!').contains('{\"bar\":\"baz\"}')\n      })\n\n      it('with any string body and headers', () => {\n        cy.visit('http://localhost:3500/post-only', {\n          method: 'POST',\n          headers: {\n            'content-type': 'application/json',\n          },\n          body: JSON.stringify({\n            bar: 'baz',\n          }),\n        })\n\n        cy.contains('it worked!').contains('{\"bar\":\"baz\"}')\n      })\n    })\n\n    describe('when origins don\\'t match', () => {\n      beforeEach(() => {\n        Cypress.emit('test:before:run', { id: 888 })\n\n        cy.stub(Cypress.runner, 'getEmissions').returns([])\n        cy.stub(Cypress.runner, 'getTestsState').returns([])\n        cy.stub(Cypress.runner, 'getStartTime').returns('12345')\n        cy.stub(Cypress.Log, 'countLogsByTests').withArgs([]).returns(1)\n        cy.stub(Cypress.runner, 'countByTestState')\n        .withArgs([], 'passed').returns(2)\n        .withArgs([], 'failed').returns(3)\n        .withArgs([], 'pending').returns(4)\n      })\n\n      it('emits preserve:run:state with title + fn', (done) => {\n        const obj = {\n          currentId: 888,\n          tests: [],\n          emissions: [],\n          startTime: '12345',\n          numLogs: 1,\n          passed: 2,\n          failed: 3,\n          pending: 4,\n        }\n\n        const fn = function (eventName, state) {\n          _.each(obj, (value, key) => {\n            expect(state[key]).to.deep.eq(value)\n          })\n\n          done()\n        }\n\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .resolves({\n          isOkStatusCode: true,\n          isHtml: true,\n          url: 'http://localhost:4200',\n        })\n        .withArgs('preserve:run:state')\n        .callsFake(fn)\n\n        cy.visit('http://localhost:4200')\n      })\n\n      it('replaces window.location when origins don\\'t match', (done) => {\n        const fn = function (str, win) {\n          const isEqual = win === top.window\n\n          expect(isEqual).to.be.true\n          expect(str).to.eq('http://localhost:4200/foo?bar=baz#/tests/integration/foo_spec.js')\n\n          done()\n        }\n\n        const fakeUrl = Cypress.Location.create('http://localhost:3500/foo?bar=baz#/tests/integration/foo_spec.js')\n\n        cy.stub(Cypress.utils, 'locExisting').returns(fakeUrl)\n        cy.stub(Cypress.utils, 'locHref')\n        .callThrough()\n        .withArgs('http://localhost:4200/foo?bar=baz#/tests/integration/foo_spec.js')\n        .callsFake(fn)\n\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .resolves({\n          isOkStatusCode: true,\n          isHtml: true,\n          url: 'http://localhost:4200',\n        })\n        .withArgs('preserve:run:state')\n        .resolves()\n\n        cy.visit('http://localhost:4200')\n      })\n    })\n\n    describe('location getter overrides', () => {\n      before(() => {\n        cy\n        .visit('/fixtures/jquery.html?foo=bar#dashboard?baz=quux')\n        .window().as('win').then((win) => {\n          // ensure href always returns the full path\n          // so our tests guarantee that in fact we are\n          // overriding the location getters\n          expect(win.location.href).to.include('/fixtures/jquery.html?foo=bar#dashboard?baz=quux')\n        })\n      })\n\n      beforeEach(function () {\n        this.win = cy.state('window')\n\n        this.eq = (attr, str) => {\n          expect(this.win.location[attr]).to.eq(str)\n        }\n      })\n\n      it('hash', function () {\n        this.eq('hash', '#dashboard?baz=quux')\n      })\n\n      it('hostname', function () {\n        this.eq('hostname', 'localhost')\n      })\n\n      it('origin', function () {\n        this.eq('origin', 'http://localhost:3500')\n      })\n\n      it('pathname', function () {\n        this.eq('pathname', '/fixtures/jquery.html')\n      })\n\n      it('port', function () {\n        this.eq('port', '3500')\n      })\n\n      it('protocol', function () {\n        this.eq('protocol', 'http:')\n      })\n\n      it('search', function () {\n        this.eq('search', '?foo=bar')\n      })\n    })\n\n    describe('.log', () => {\n      beforeEach(function () {\n        cy.stub(Cypress.runner, 'getEmissions').returns([])\n\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          if (attrs.name === 'visit') {\n            this.lastLog = log\n          }\n\n          this.logs.push(log)\n        })\n\n        return null\n      })\n\n      it('preserves url on subsequent visits', () => {\n        cy.visit('/fixtures/jquery.html').get('button').then(function () {\n          expect(this.lastLog.get('url')).to.eq('http://localhost:3500/fixtures/jquery.html')\n        })\n      })\n\n      it('does not log \\'Page Load\\' events', () => {\n        cy\n        .visit('/fixtures/generic.html')\n        .visit('/fixtures/jquery.html')\n        .then(function () {\n          this.logs.slice(0).forEach((log) => {\n            expect(log.get('name')).not.eq('page load')\n          })\n        })\n      })\n\n      it('logs immediately before resolving', () => {\n        let expected = false\n\n        cy.on('log:added', (attrs, log) => {\n          cy.removeAllListeners('log:added')\n\n          expect(log.pick('name', 'message')).to.deep.eq({\n            name: 'visit',\n            message: 'localhost:3500/fixtures/jquery.html#/hash',\n          })\n\n          expected = true\n        })\n\n        cy.visit('localhost:3500/fixtures/jquery.html#/hash').then(() => {\n          expect(expected).to.be.true\n        })\n      })\n\n      it('logs obj once complete', () => {\n        cy.visit('http://localhost:3500/fixtures/generic.html').then(function () {\n          const obj = {\n            state: 'passed',\n            name: 'visit',\n            message: 'http://localhost:3500/fixtures/generic.html',\n            url: 'http://localhost:3500/fixtures/generic.html',\n          }\n\n          const { lastLog } = this\n\n          _.each(obj, (value, key) => {\n            expect(lastLog.get(key)).deep.eq(value, `expected key: ${key} to eq value: ${value}`)\n          })\n        })\n      })\n\n      it('logs obj once complete when onLoad is not called', () => {\n        cy.visit('http://localhost:3500/fixtures/generic.html#foo')\n\n        cy.visit('http://localhost:3500/fixtures/generic.html#foo').then(function () {\n          const obj = {\n            state: 'passed',\n            name: 'visit',\n            message: 'http://localhost:3500/fixtures/generic.html#foo',\n            url: 'http://localhost:3500/fixtures/generic.html#foo',\n          }\n\n          const { lastLog } = this\n\n          _.each(obj, (value, key) => {\n            expect(lastLog.get(key)).deep.eq(value, `expected key: ${key} to eq value: ${value}`)\n          })\n        })\n      })\n\n      it('snapshots once', () => {\n        cy.visit('/fixtures/generic.html').then(function () {\n          const { lastLog } = this\n\n          expect(lastLog.get('snapshots').length).to.eq(1)\n          expect(lastLog.get('snapshots')[0]).to.be.an('object')\n        })\n      })\n\n      it('can turn off logging', () => {\n        cy.visit('/timeout?ms=0', { log: false }).then(function () {\n          expect(this.lastLog).not.to.exist\n        })\n      })\n\n      it('displays file attributes as consoleProps', () => {\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .resolves({\n          isOkStatusCode: true,\n          isHtml: true,\n          contentType: 'text/html',\n          url: 'http://localhost:3500/foo/bar',\n          filePath: '/path/to/foo/bar',\n          redirects: [1, 2],\n          cookies: [{}, {}],\n        })\n\n        cy.visit('/fixtures/jquery.html').then(function () {\n          expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n            'Command': 'visit',\n            'File Served': '/path/to/foo/bar',\n            'Resolved Url': 'http://localhost:3500/foo/bar',\n            'Redirects': [1, 2],\n            'Cookies Set': [{}, {}],\n          })\n        })\n      })\n\n      it('displays http attributes as consoleProps', () => {\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .resolves({\n          isOkStatusCode: true,\n          isHtml: true,\n          contentType: 'text/html',\n          url: 'http://localhost:3500/foo',\n          originalUrl: 'http://localhost:3500/foo',\n          redirects: [1, 2],\n          cookies: [{}, {}],\n        })\n\n        cy.visit('http://localhost:3500/foo').then(function () {\n          expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n            'Command': 'visit',\n            'Resolved Url': 'http://localhost:3500/foo',\n            'Redirects': [1, 2],\n            'Cookies Set': [{}, {}],\n          })\n        })\n      })\n\n      it('displays originalUrl http attributes as consoleProps', () => {\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .resolves({\n          isOkStatusCode: true,\n          isHtml: true,\n          contentType: 'text/html',\n          url: 'http://localhost:3500/foo/bar',\n          originalUrl: 'http://localhost:3500/foo',\n          redirects: [1, 2],\n          cookies: [{}, {}],\n        })\n\n        cy.visit('http://localhost:3500/foo').then(function () {\n          expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n            'Command': 'visit',\n            'Original Url': 'http://localhost:3500/foo',\n            'Resolved Url': 'http://localhost:3500/foo/bar',\n            'Redirects': [1, 2],\n            'Cookies Set': [{}, {}],\n          })\n        })\n      })\n\n      it('indicates redirects in the message', () => {\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .resolves({\n          isOkStatusCode: true,\n          isHtml: true,\n          contentType: 'text/html',\n          url: 'http://localhost:3500/foo/bar',\n          originalUrl: 'http://localhost:3500/foo',\n          redirects: [1, 2],\n          cookies: [{}, {}],\n        })\n\n        cy.visit('http://localhost:3500/foo').then(function () {\n          const { lastLog } = this\n\n          expect(lastLog.get('message')).to.eq(\n            'http://localhost:3500/foo -> 1 -> 2',\n          )\n        })\n      })\n\n      it('indicates POST in the message', () => {\n        cy.visit('http://localhost:3500/post-only', {\n          method: 'POST',\n        }).then(function () {\n          const { lastLog } = this\n\n          expect(lastLog.get('message')).to.eq(\n            'POST http://localhost:3500/post-only',\n          )\n        })\n      })\n\n      it('displays note in consoleProps when visiting the same page with a hash', () => {\n        cy.visit('http://localhost:3500/fixtures/generic.html#foo')\n        .visit('http://localhost:3500/fixtures/generic.html#foo')\n        .then(function () {\n          expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n            'Command': 'visit',\n            'Note': 'Because this visit was to the same hash, the page did not reload and the onBeforeLoad and onLoad callbacks did not fire.',\n          })\n        })\n      })\n\n      it('logs options if they are supplied', () => {\n        cy.visit({\n          url: 'http://localhost:3500/fixtures/generic.html',\n          headers: {\n            'foo': 'bar',\n          },\n          notReal: 'baz',\n        })\n        .then(function () {\n          expect(this.lastLog.invoke('consoleProps')['Options']).to.deep.eq({\n            url: 'http://localhost:3500/fixtures/generic.html',\n            headers: {\n              'foo': 'bar',\n            },\n          })\n        })\n      })\n\n      it('does not log options if they are not supplied', () => {\n        cy.visit('http://localhost:3500/fixtures/generic.html')\n        .then(function () {\n          expect(this.lastLog.invoke('consoleProps')['Options']).to.be.undefined\n        })\n      })\n    })\n\n    describe('errors', {\n      defaultCommandTimeout: 50,\n    }, () => {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          if (attrs.name === 'visit') {\n            this.lastLog = log\n            this.logs.push(log)\n          }\n        })\n\n        return null\n      })\n\n      it('sets error command state', function (done) {\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .rejects(new Error)\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(lastLog.get('state')).to.eq('failed')\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy.visit('/fixtures/generic.html')\n      })\n\n      it('logs once on error', function (done) {\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .rejects(new Error)\n\n        cy.on('fail', (err) => {\n          expect(this.logs.length).to.eq(1)\n\n          done()\n        })\n\n        cy.visit('/fixtures/generic.html')\n      })\n\n      it('logs once on timeout error', function (done) {\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(this.logs.length).to.eq(1)\n          expect(err.message).to.include('Your page did not fire its `load` event within `20ms`.')\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy.visit('/timeout?ms=5000', { timeout: 20 })\n      })\n\n      it('cancels resolve url promise on timeout', (done) => {\n        cy.on('collect:run:state', () => {\n          done(new Error('should not have tried to swap domains'))\n        })\n\n        const fn = () => {\n          // resolve after 100ms\n          return Promise.delay(100)\n          .then(() => {\n            done(new Error('should not have invoked this callback'))\n          })\n        }\n\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .callsFake(fn)\n\n        cy.on('fail', () => {\n          done()\n        })\n\n        cy.visit('/', { timeout: 20 })\n      })\n\n      it('throws when url isnt a string', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.eq('`cy.visit()` must be called with a `url` or an `options` object containing a `url` as its 1st argument')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/visit')\n\n          done()\n        })\n\n        cy.visit()\n      })\n\n      it('throws when url is specified twice', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.contain('`cy.visit()` must be called with only one `url`. You specified two urls')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/visit')\n\n          done()\n        })\n\n        cy.visit('http://foobarbaz', {\n          url: 'http://foobarbaz',\n        })\n      })\n\n      it('throws when method is unsupported', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.contain('`cy.visit()` was called with an invalid method: `FOO`')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/visit')\n\n          done()\n        })\n\n        cy.visit({\n          url: 'http://foobarbaz',\n          method: 'FOO',\n        })\n      })\n\n      it('throws when headers is not an object', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.contain('`cy.visit()` requires the `headers` option to be an object')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/visit')\n\n          done()\n        })\n\n        cy.visit({\n          url: 'http://foobarbaz',\n          headers: 'quux',\n        })\n      });\n\n      [\n        'foo',\n        null,\n        false,\n      ].forEach((qs) => {\n        const str = String(qs)\n\n        it(`throws when qs is ${str}`, (done) => {\n          cy.on('fail', (err) => {\n            expect(err.message).to.contain(`\\`cy.visit()\\` requires the \\`qs\\` option to be an object, but received: \\`${str}\\``)\n\n            done()\n          })\n\n          cy.visit({\n            url: 'http://foobarbaz',\n            qs,\n          })\n        })\n      })\n\n      it('throws when failOnStatusCode is false and retryOnStatusCodeFailure is true', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.contain('These options are incompatible with each other.')\n\n          done()\n        })\n\n        cy.visit({\n          url: 'http://foobarbaz',\n          failOnStatusCode: false,\n          retryOnStatusCodeFailure: true,\n        })\n      })\n\n      it('throws when attempting to visit a 2nd domain on different port', function (done) {\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(err.message).to.include('`cy.visit()` failed because you are attempting to visit a URL that is of a different origin.')\n          expect(err.message).to.include('The new URL is considered a different origin because the following parts of the URL are different:')\n          expect(err.message).to.include('> port')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/cannot-visit-different-origin-domain')\n          expect(this.logs.length).to.eq(2)\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy.visit('http://localhost:3500/fixtures/generic.html')\n\n        cy.visit('http://localhost:3501/fixtures/generic.html')\n      })\n\n      it('throws when attempting to visit a 2nd domain on different protocol', function (done) {\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(err.message).to.include('`cy.visit()` failed because you are attempting to visit a URL that is of a different origin.')\n          expect(err.message).to.include('The new URL is considered a different origin because the following parts of the URL are different:')\n          expect(err.message).to.include('> protocol')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/cannot-visit-different-origin-domain')\n          expect(this.logs.length).to.eq(2)\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy.visit('http://localhost:3500/fixtures/generic.html')\n        cy.visit('https://localhost:3500/fixtures/generic.html')\n      })\n\n      it('throws when attempting to visit a 2nd domain on different superdomain', function (done) {\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(err.message).to.include('`cy.visit()` failed because you are attempting to visit a URL that is of a different origin.')\n          expect(err.message).to.include('The new URL is considered a different origin because the following parts of the URL are different:')\n          expect(err.message).to.include('> superdomain')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/cannot-visit-different-origin-domain')\n          expect(this.logs.length).to.eq(2)\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy.visit('http://localhost:3500/fixtures/generic.html')\n        cy.visit('http://google.com:3500/fixtures/generic.html')\n      })\n\n      it('throws attemping to visit 2 unique ip addresses', function (done) {\n        const $autIframe = cy.state('$autIframe')\n\n        const load = () => {\n          return $autIframe.trigger('load')\n        }\n\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .resolves({\n          isOkStatusCode: true,\n          isHtml: true,\n          url: 'http://127.0.0.1:3500',\n        })\n\n        // whenever we're told to change the src\n        // just fire the load event directly on the $autIframe\n        cy.stub(Cypress.utils, 'iframeSrc').callsFake(load)\n\n        // make it seem like we're already on http://127.0.0.1:3500\n        const one = Cypress.Location.create('http://127.0.0.1:3500/fixtures/generic.html')\n\n        cy.stub(Cypress.utils, 'locExisting')\n        .returns(one)\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(err.message).to.include('`cy.visit()` failed because you are attempting to visit a URL that is of a different origin.')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/cannot-visit-different-origin-domain')\n          expect(this.logs.length).to.eq(2)\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy\n        .visit('http://127.0.0.1:3500/fixtures/generic.html')\n        .visit('http://126.0.0.1:3500/fixtures/generic.html')\n      })\n\n      it('does not call resolve:url when throws attemping to visit a 2nd domain', (done) => {\n        const backend = cy.spy(Cypress, 'backend')\n\n        cy.on('fail', (err) => {\n          expect(backend).to.be.calledWithMatch('resolve:url', 'http://localhost:3500/fixtures/generic.html')\n          expect(backend).not.to.be.calledWithMatch('resolve:url', 'http://google.com:3500/fixtures/generic.html')\n\n          done()\n        })\n\n        cy\n        .visit('http://localhost:3500/fixtures/generic.html')\n        .visit('http://google.com:3500/fixtures/generic.html')\n      })\n\n      it('displays loading_network_failed when _resolveUrl throws', function (done) {\n        const err1 = new Error('connect ECONNREFUSED 127.0.0.1:64646')\n\n        // dont log else we create an endless loop!\n        const emit = cy.spy(Cypress, 'emit').log(false)\n\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .rejects(err1)\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(err.message).to.include(stripIndent`\\\n            \\`cy.visit()\\` failed trying to load:\n\n            http://localhost:3500/foo.html\n\n            We attempted to make an http request to this URL but the request failed without a response.\n\n            We received this error at the network level:\n\n              > Error: connect ECONNREFUSED 127.0.0.1:64646\n\n            Common situations why this would fail:\n              - you don't have internet access\n              - you forgot to run / boot your web server\n              - your web server isn't accessible\n              - you have weird network configuration settings on your computer`)\n\n          expect(err1.url).to.include('/foo.html')\n          expect(emit).to.be.calledWith('visit:failed', err1)\n          expect(this.logs.length).to.eq(1)\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy.visit('/foo.html')\n      })\n\n      it('displays loading_file_failed when _resolveUrl resp is not ok', function (done) {\n        const obj = {\n          isOkStatusCode: false,\n          isHtml: true,\n          contentType: 'text/html',\n          originalUrl: '/foo.html',\n          filePath: '/path/to/foo.html',\n          status: 404,\n          statusText: 'Not Found',\n          redirects: [],\n        }\n\n        obj.url = obj.originalUrl\n\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .resolves(obj)\n\n        // dont log else we create an endless loop!\n        const emit = cy.spy(Cypress, 'emit').log(false)\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(err.message).to.include(stripIndent`\\\n            \\`cy.visit()\\` failed trying to load:\n\n            /foo.html\n\n            We failed looking for this file at the path:\n\n            /path/to/foo.html\n\n            The internal Cypress web server responded with:\n\n              > 404: Not Found`)\n\n          expect(emit).to.be.calledWithMatch('visit:failed', obj)\n          expect(this.logs.length).to.eq(1)\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy.visit('/foo.html')\n      })\n\n      it('displays loading_file_failed redirects when _resolveUrl resp is not ok', function (done) {\n        const obj = {\n          isOkStatusCode: false,\n          isHtml: true,\n          contentType: 'text/html',\n          originalUrl: '/bar',\n          filePath: '/path/to/bar/',\n          status: 404,\n          statusText: 'Not Found',\n          redirects: [\n            '301: http://localhost:3500/bar/',\n          ],\n        }\n\n        obj.url = obj.originalUrl\n\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url')\n        .resolves(obj)\n\n        // dont log else we create an endless loop!\n        const emit = cy.spy(Cypress, 'emit').log(false)\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(err.message).to.include(stripIndent`\\\n            \\`cy.visit()\\` failed trying to load:\n\n            /bar\n\n            We failed looking for this file at the path:\n\n            /path/to/bar/\n\n            The internal Cypress web server responded with:\n\n              > 404: Not Found\n\n            We were redirected '1' time to:\n\n              - 301: http://localhost:3500/bar/`)\n\n          expect(emit).to.be.calledWithMatch('visit:failed', obj)\n          expect(this.logs.length).to.eq(1)\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy.visit('/bar')\n      })\n\n      it('displays loading_http_failed when _resolveUrl resp is not ok', function (done) {\n        const obj = {\n          isOkStatusCode: false,\n          isHtml: true,\n          contentType: 'text/html',\n          originalUrl: 'https://google.com/foo',\n          status: 500,\n          statusText: 'Server Error',\n          redirects: [],\n        }\n\n        obj.url = obj.originalUrl\n\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url', 'https://google.com/foo')\n        .resolves(obj)\n\n        // dont log else we create an endless loop!\n        const emit = cy.spy(Cypress, 'emit').log(false)\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(err.message).to.include(stripIndent`\\\n            \\`cy.visit()\\` failed trying to load:\n\n            https://google.com/foo\n\n            The response we received from your web server was:\n\n              > 500: Server Error\n\n            This was considered a failure because the status code was not \\`2xx\\`.\n\n            If you do not want status codes to cause failures pass the option: \\`failOnStatusCode: false\\``)\n\n          expect(emit).to.be.calledWithMatch('visit:failed', obj)\n          expect(this.logs.length).to.eq(1)\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy.visit('https://google.com/foo')\n      })\n\n      it('displays loading_http_failed redirects when _resolveUrl resp is not ok', function (done) {\n        const obj = {\n          isOkStatusCode: false,\n          isHtml: true,\n          contentType: 'text/html',\n          originalUrl: 'https://google.com/foo',\n          status: 401,\n          statusText: 'Unauthorized',\n          redirects: [\n            '302: https://google.com/bar/',\n            '301: https://gmail.com/',\n          ],\n        }\n\n        obj.url = obj.originalUrl\n\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url', 'https://google.com/foo')\n        .resolves(obj)\n\n        // dont log else we create an endless loop!\n        const emit = cy.spy(Cypress, 'emit').log(false)\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(err.message).to.include(stripIndent`\\\n            \\`cy.visit()\\` failed trying to load:\n\n            https://google.com/foo\n\n            The response we received from your web server was:\n\n              > 401: Unauthorized\n\n            This was considered a failure because the status code was not \\`2xx\\`.\n\n            This http request was redirected '2' times to:\n\n              - 302: https://google.com/bar/\n              - 301: https://gmail.com/\n\n            If you do not want status codes to cause failures pass the option: \\`failOnStatusCode: false\\``)\n\n          expect(emit).to.be.calledWithMatch('visit:failed', obj)\n          expect(this.logs.length).to.eq(1)\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy.visit('https://google.com/foo')\n      })\n\n      // https://github.com/cypress-io/cypress/issues/8506\n      it('accepts text/html; + parameter as content-type', () => {\n        cy.visit('http://localhost:3500/html-content-type-with-charset-param')\n      });\n\n      // https://github.com/cypress-io/cypress/issues/3101\n      [{\n        contentType: 'application/json',\n        pathName: 'json-content-type',\n      }, {\n        contentType: 'text/image',\n        pathName: 'invalid-content-type',\n      }]\n      .forEach(({ contentType, pathName }) => {\n        it(`displays loading_invalid_content_type when content type is ${contentType} on http requests`, function (done) {\n          cy.on('fail', (err) => {\n            const { lastLog } = this\n\n            expect(err.message).to.include(stripIndent`\\\n              \\`cy.visit()\\` failed trying to load:\n\n              http://localhost:3500/${pathName}\n\n              The \\`content-type\\` of the response we received from your web server was:\n\n                > \\`${contentType}\\`\n\n              This was considered a failure because responses must have \\`content-type: 'text/html'\\`\n\n              However, you can likely use \\`cy.request()\\` instead of \\`cy.visit()\\`.\n\n              \\`cy.request()\\` will automatically get and set cookies and enable you to parse responses.`)\n\n            expect(this.logs.length).to.eq(1)\n            expect(lastLog.get('error')).to.eq(err)\n\n            done()\n          })\n\n          cy.visit(`http://localhost:3500/${pathName}`)\n        })\n      })\n\n      it('displays loading_invalid_content_type when isHtml is false on file requests', function (done) {\n        const obj = {\n          isOkStatusCode: true,\n          isHtml: false,\n          filePath: '/path/to/bar/',\n          contentType: 'application/json',\n          originalUrl: 'https://google.com/foo',\n          status: 200,\n          statusText: 'OK',\n        }\n\n        obj.url = obj.originalUrl\n\n        cy.stub(Cypress, 'backend')\n        .withArgs('resolve:url', 'https://google.com/foo')\n        .resolves(obj)\n\n        // dont log else we create an endless loop!\n        const emit = cy.spy(Cypress, 'emit').log(false)\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(err.message).to.include(stripIndent`\\\n            \\`cy.visit()\\` failed trying to load:\n\n            https://google.com/foo\n\n            The \\`content-type\\` of the response we received from this local file was:\n\n              > \\`application/json\\`\n\n            This was considered a failure because responses must have \\`content-type: 'text/html'\\`\n\n            However, you can likely use \\`cy.request()\\` instead of \\`cy.visit()\\`.\n\n            \\`cy.request()\\` will automatically get and set cookies and enable you to parse responses.`)\n\n          expect(emit).to.be.calledWithMatch('visit:failed', obj)\n          expect(this.logs.length).to.eq(1)\n          expect(lastLog.get('error')).to.eq(err)\n\n          done()\n        })\n\n        cy.visit('https://google.com/foo')\n      })\n\n      it('displays body_circular when body is circular', function (done) {\n        const foo = {\n          bar: {\n            baz: {},\n          },\n        }\n\n        foo.bar.baz.quux = foo\n\n        cy.visit({\n          method: 'POST',\n          url: 'http://foo.invalid/',\n          body: foo,\n        })\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(this.logs.length).to.eq(1)\n          expect(lastLog.get('error')).to.eq(err)\n          expect(lastLog.get('state')).to.eq('failed')\n          expect(err.message).to.eq(stripIndent`\\\n            The \\`body\\` parameter supplied to \\`cy.visit()\\` contained a circular reference at the path \"bar.baz.quux\".\n\n            \\`body\\` can only be a string or an object with no circular references.`)\n\n          expect(err.docsUrl).to.eq('https://on.cypress.io/visit')\n\n          done()\n        })\n      })\n    })\n  })\n\n  context('#page load', () => {\n    it('sets initial=true and then removes', () => {\n      Cookie.remove('__cypress.initial')\n\n      expect(Cookie.get('__cypress.initial')).to.be.undefined\n\n      let expected = false\n\n      cy.on('window:before:unload', () => {\n        expected = true\n\n        expect(Cookie.get('__cypress.initial')).to.eq('true')\n      })\n\n      // this navigates us to a new page so\n      // we should be setting the initial cookie\n      cy\n      .visit('/fixtures/form.html')\n      .then(() => {\n        cy.once('window:unload', () => {\n          expect(cy.state('onPageLoadErr')).to.be.a('function')\n        })\n\n        return null\n      })\n      .get('a:first').click().then(() => {\n        const listeners = cy.listeners('window:load')\n\n        // everything should have unbound properly\n        expect(listeners.length).to.eq(0)\n\n        expect(expected).to.be.true\n\n        expect(cy.state('onPageLoadErr')).to.be.null\n\n        expect(Cookie.get('__cypress.initial')).to.be.undefined\n      })\n    })\n\n    // TODO: broken - https://github.com/cypress-io/cypress/issues/4973 (chrome76+ and firefox)\n    it.skip('does not reset the timeout', (done) => {\n      cy.timeout(1000)\n\n      // previously loading would reset the timeout\n      // which could cause failures on the next test\n      // if there was logic after a test finished running\n      cy.window().then((win) => {\n        const timeout = cy.spy(cy, 'timeout')\n\n        // we are unstable at this point\n        cy.on('window:before:unload', () => {\n          cy.whenStable(() => {\n            expect(timeout).not.to.be.called\n\n            done()\n          })\n        })\n\n        win.location.href = 'about:blank'\n      })\n    })\n\n    it('does not time out current commands until stability is reached', () => {\n      // on the first retry cause a page load event synchronously\n      cy.on('command:retry', (options) => {\n        switch (options._retries) {\n          case 1: {\n            const win = cy.state('window')\n\n            // load a page which times out after 500ms\n            // to guarantee that url does not time out\n            const $a = win.$('<a href=\\'/timeout?ms=500\\'>jquery</a>')\n            .appendTo(win.document.body)\n\n            causeSynchronousBeforeUnload($a)\n\n            break\n          }\n          case 2: {\n            // on 2nd retry add the DOM element\n            const win = cy.state('window')\n\n            $('<div id=\\'does-not-exist\\'>does not exist<div>')\n            .appendTo(win.document.body)\n\n            break\n          }\n          case 3: {\n            // and on the 3rd retry add the class\n            cy.state('window')\n\n            $('#does-not-exist').addClass('foo')\n\n            break\n          }\n          default:\n            return\n        }\n      })\n\n      cy\n      .visit('/fixtures/jquery.html')\n\n      // make get timeout after 300ms\n      // but even though our page does not load for 500ms\n      // this does not time out\n      .get('#does-not-exist', { timeout: 300 }).should('have.class', 'foo')\n    })\n\n    describe('errors', () => {\n      helpers.registerCypressConfigBackupRestore()\n\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          this.lastLog = log\n          this.logs.push(log)\n        })\n\n        return null\n      })\n\n      it('can time out', function (done) {\n        let thenCalled = false\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          // visit, window, page loading\n          expect(this.logs.length).to.eq(3)\n          expect(err.message).to.include('Your page did not fire its `load` event within `50ms`.')\n          expect(lastLog.get('name')).to.eq('page load')\n          expect(lastLog.get('error')).to.eq(err)\n\n          return Promise\n          .delay(100)\n          .then(() => {\n            expect(cy.state('onPageLoadErr')).to.be.null\n            expect(cy.isStopped()).to.be.true // make sure we ran our cleanup routine\n            expect(thenCalled).to.be.false\n\n            done()\n          })\n        })\n\n        cy\n        .visit('/fixtures/jquery.html')\n        .window().then((win) => {\n          Cypress.config('pageLoadTimeout', 50)\n\n          const $a = win.$('<a href=\\'/timeout?ms=500\\'>jquery</a>')\n          .appendTo(win.document.body)\n\n          causeSynchronousBeforeUnload($a)\n\n          return null\n        }).wrap(null).then(() => {\n          thenCalled = true\n        })\n      })\n\n      it('does time out once stability is reached', function (done) {\n        const logByName = (name) => {\n          return _.find(this.logs, (log) => {\n            return log.get('name') === name\n          })\n        }\n\n        cy.on('fail', (err) => {\n          cy.on('command:retry', () => {\n            throw new Error('should not have retried twice')\n          })\n\n          expect(err.message).to.include('Expected to find element')\n\n          const get = logByName('get')\n\n          expect(get.get('error')).to.eq(err)\n\n          return Promise.delay(200)\n          .then(() => {\n            expect(cy.isStopped()).to.be.true\n\n            done()\n          })\n        })\n\n        let start = null\n\n        // on the first retry cause a page load event synchronously\n        cy.on('command:retry', (options) => {\n          switch (options._retries) {\n            case 1: {\n              // hold a ref to this\n              start = options._start\n\n              const win = cy.state('window')\n\n              // load a page which times out after 400ms\n              // to guarantee that url does not time out\n              const $a = win.$('<a href=\\'/timeout?ms=400\\'>jquery</a>')\n              .appendTo(win.document.body)\n\n              causeSynchronousBeforeUnload($a)\n\n              // immediately logs pending state\n              expect(logByName('page load').get('state')).to.eq('pending')\n            }\n              break\n            case 2: {\n              // it should have reset this because we became\n              // unstable\n              expect(start).not.to.eq(options._start)\n\n              // and by the time we retry for the 2nd time\n              // the page should be loaded\n              expect(logByName('page load').get('state')).to.eq('passed')\n            }\n              break\n            default:\n              return\n          }\n        })\n\n        cy\n        .visit('/fixtures/jquery.html')\n\n        // make get timeout after only 200ms\n        .get('#does-not-exist', { timeout: 200 }).should('have.class', 'foo')\n      })\n\n      it('captures cross origin failures', function (done) {\n        cy.once('fail', (err) => {\n          const { lastLog } = this\n\n          expect(this.logs.length).to.eq(2)\n          expect(err.message).to.include('Cypress detected a cross origin error happened on page load')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/cross-origin-violation')\n          expect(lastLog.get('name')).to.eq('page load')\n          expect(lastLog.get('state')).to.eq('failed')\n          expect(lastLog.get('error')).to.eq(err)\n          expect(cy.state('onPageLoadErr')).to.be.null\n\n          done()\n        })\n\n        cy\n        .visit('/fixtures/jquery.html')\n        .window({ log: false }).then((win) => {\n          const url = 'http://localhost:3501/fixtures/generic.html'\n\n          const $a = win.$(`<a href='${url}'>jquery</a>`)\n          .appendTo(win.document.body)\n\n          causeSynchronousBeforeUnload($a)\n        })\n      })\n\n      return null\n    })\n  })\n\n  // this tests isLoading spinner\n  // and page load event\n  context('#page loading', () => {\n    beforeEach(function () {\n      this.logs = []\n\n      cy.on('log:added', (attrs, log) => {\n        if (attrs.name === 'page load') {\n          this.lastLog = log\n          this.logs.push(log)\n        }\n      })\n\n      return null\n    })\n\n    it('emits \\'page:loading\\' before and after initial visit', () => {\n      const emit = cy.spy(Cypress, 'emit').log(false).withArgs('page:loading')\n\n      cy\n      .visit('/timeout?ms=10', {\n        onBeforeLoad () {\n          expect(emit).to.be.calledOnce\n          expect(emit.firstCall).to.be.calledWith('page:loading', true)\n        },\n      })\n      .then(() => {\n        expect(emit).to.be.calledTwice\n        expect(emit.secondCall).to.be.calledWith('page:loading', false)\n      })\n    })\n\n    it('emits during page navigation', () => {\n      const emit = cy.spy(Cypress, 'emit').log(false).withArgs('page:loading')\n      let expected = false\n\n      cy\n      .visit('/fixtures/generic.html')\n      .then(() => {\n        cy.once('window:unload', () => {\n          expected = true\n          expect(emit.callCount).to.eq(3)\n          expect(emit.thirdCall).to.be.calledWith('page:loading', true)\n        })\n      }).get('#dimensions').click()\n      .then(() => {\n        expect(expected).to.be.true\n        expect(emit.callCount).to.eq(4)\n        expect(emit.getCall(3)).to.be.calledWith('page:loading', false)\n      })\n    })\n\n    it('does not log during initial visit', () => {\n      cy.visit('/timeout?ms=10').then(function () {\n        expect(this.lastLog).not.to.exist\n      })\n    })\n\n    it('logs during page navigation', () => {\n      let expected = false\n\n      cy\n      .visit('/fixtures/generic.html')\n      .then(function () {\n        cy.once('window:before:unload', () => {\n          expected = true\n\n          expect(this.lastLog).to.exist\n          expect(this.lastLog.get('state')).to.eq('pending')\n          expect(this.lastLog.get('message')).to.eq('--waiting for new page to load--')\n          expect(this.lastLog.get('snapshots')).to.not.exist\n        })\n      }).get('#dimensions').click()\n      .then(function () {\n        expect(expected).to.be.true\n        expect(this.lastLog.get('state')).to.eq('passed')\n        expect(this.lastLog.get('message')).to.eq('--page loaded--')\n        expect(this.lastLog.get('snapshots')).to.have.length(1)\n      })\n    })\n\n    it('logs during form submission and yields stale element', () => {\n      let expected = false\n\n      const names = cy.queue.names()\n\n      cy\n      .visit('/fixtures/form.html')\n      .then(function () {\n        const $input = cy.$$('form#click-me input[type=submit]')\n\n        cy.once('window:before:unload', () => {\n          expected = true\n\n          expect(this.lastLog).to.exist\n          expect(this.lastLog.get('state')).to.eq('pending')\n          expect(this.lastLog.get('message')).to.eq('--waiting for new page to load--')\n          expect(this.lastLog.get('snapshots')).to.not.exist\n        })\n\n        cy\n        .get('form#click-me')\n        .find('input[type=submit]')\n        .click()\n        .then(function (subject) {\n          expect(expected).to.be.true\n\n          expect(this.lastLog.get('state')).to.eq('passed')\n          expect(this.lastLog.get('message')).to.eq('--page loaded--')\n          expect(this.lastLog.get('snapshots')).to.have.length(1)\n\n          expect(cy.queue.names()).to.deep.eq(names.concat([\n            'visit', 'then', 'get', 'find', 'click', 'then',\n          ]))\n\n          expect(Cypress.dom.isDetached(subject)).to.be.true\n          expect(subject.get(0)).to.eq($input.get(0))\n        })\n      })\n    })\n\n    it('waits for stability at the end of the command queue when not stable', (done) => {\n      cy\n      .visit('/fixtures/generic.html')\n      .then((win) => {\n        cy.on('window:load', () => {\n          cy.on('command:queue:end', () => {\n            done()\n          })\n        })\n\n        cy.on('command:queue:before:end', () => {\n        // force us to become unstable immediately\n        // else the beforeunload event fires at the end\n        // of the tick which is too late\n          cy.isStable(false, 'testing')\n\n          win.location.href = '/timeout?ms=100'\n        })\n\n        return null\n      })\n    })\n  })\n\n  context('#url:changed', () => {\n    beforeEach(function () {\n      this.logs = []\n\n      cy.on('log:added', (attrs, log) => {\n        if (attrs.name === 'new url') {\n          this.lastLog = log\n          this.logs.push(log)\n        }\n      })\n\n      return null\n    })\n\n    describe('page navigation', () => {\n      it('emits url:changed event on initial visit', () => {\n        const emit = cy.spy(Cypress, 'emit').log(false).withArgs('url:changed')\n\n        cy\n        .visit('/fixtures/generic.html')\n        .then(() => {\n          expect(emit).to.be.calledOnce\n          expect(emit).to.be.calledWith(\n            'url:changed',\n            'http://localhost:3500/fixtures/generic.html',\n          )\n        })\n      })\n\n      it('emits url:changed on 2nd visit to different page', () => {\n        const emit = cy.spy(Cypress, 'emit').log(false).withArgs('url:changed')\n\n        cy\n        .visit('/fixtures/generic.html')\n        .visit('/fixtures/jquery.html')\n        .then(() => {\n          expect(emit).to.be.calledTwice\n\n          expect(emit).to.be.calledWith(\n            'url:changed',\n            'http://localhost:3500/fixtures/generic.html',\n          )\n\n          expect(emit).to.be.calledWith(\n            'url:changed',\n            'http://localhost:3500/fixtures/jquery.html',\n          )\n        })\n      })\n\n      it('does not emit url:changed twice on visit to the same page', () => {\n        const emit = cy.spy(Cypress, 'emit').log(false).withArgs('url:changed')\n\n        cy\n        .visit('/fixtures/generic.html')\n        .visit('/fixtures/generic.html')\n        .then(() => {\n          expect(emit).to.be.calledOnce\n          expect(emit).to.be.calledWith(\n            'url:changed',\n            'http://localhost:3500/fixtures/generic.html',\n          )\n        })\n      })\n\n      it('does not log url:changed event on visit', () => {\n        cy\n        .visit('/fixtures/generic.html')\n        .then(function () {\n          expect(this.lastLog).not.to.exist\n        })\n      })\n\n      it('emits url:changed event on page navigation', () => {\n        const emit = cy.spy(Cypress, 'emit').log(false).withArgs('url:changed')\n\n        cy\n        .visit('/fixtures/generic.html')\n        .get('#dimensions').click()\n        .then(() => {\n          expect(emit).to.be.calledTwice\n\n          expect(emit).to.be.calledWith(\n            'url:changed',\n            'http://localhost:3500/fixtures/generic.html',\n          )\n\n          expect(emit).to.be.calledWith(\n            'url:changed',\n            'http://localhost:3500/fixtures/dimensions.html',\n          )\n        })\n      })\n\n      it('logs url:changed event on page navigation', () => {\n        cy\n        .visit('/fixtures/generic.html')\n        .get('#dimensions').click()\n        .then(function () {\n          expect(this.logs.length).to.eq(1)\n\n          expect(this.logs[0].get('message')).to.eq(\n            'http://localhost:3500/fixtures/dimensions.html',\n          )\n\n          expect(this.logs[0].invoke('consoleProps')).to.deep.eq({\n            'Event': 'new url',\n            'New Url': 'http://localhost:3500/fixtures/dimensions.html',\n            'Url Updated By': 'page navigation event (before:load)',\n          })\n        })\n      })\n    })\n\n    describe('hashchange events', () => {\n      it('emits url:changed event', () => {\n        const emit = cy.spy(Cypress, 'emit').log(false)\n\n        cy\n        .visit('/fixtures/generic.html')\n        .get('#hashchange').click()\n        .then(() => {\n          expect(emit).to.be.calledWith(\n            'url:changed',\n            'http://localhost:3500/fixtures/generic.html#hashchange',\n          )\n        })\n      })\n\n      it('emits url:changed event as navigation events occur', () => {\n        const emit = cy.spy(Cypress, 'emit').log(false).withArgs('url:changed')\n\n        cy\n        .visit('/fixtures/generic.html')\n        .get('#hashchange').click()\n        .window().then((win) => {\n          return new Promise((resolve) => {\n            cy.once('navigation:changed', resolve)\n\n            win.history.back()\n          }).then(() => {\n            return new Promise((resolve) => {\n              cy.once('navigation:changed', resolve)\n\n              win.history.forward()\n            })\n          }).then(() => {\n            expect(emit.callCount).to.eq(4)\n\n            expect(emit.firstCall).to.be.calledWith(\n              'url:changed',\n              'http://localhost:3500/fixtures/generic.html',\n            )\n\n            expect(emit.secondCall).to.be.calledWith(\n              'url:changed',\n              'http://localhost:3500/fixtures/generic.html#hashchange',\n            )\n\n            expect(emit.thirdCall).to.be.calledWith(\n              'url:changed',\n              'http://localhost:3500/fixtures/generic.html',\n            )\n\n            expect(emit.getCall(3)).to.be.calledWith(\n              'url:changed',\n              'http://localhost:3500/fixtures/generic.html#hashchange',\n            )\n          })\n        })\n      })\n\n      it('logs url changed event', () => {\n        cy\n        .visit('/fixtures/generic.html')\n        .window().then((win) => {\n          let ohc = null\n\n          win.onhashchange = (event) => {\n            ohc = event\n          }\n\n          cy\n          .get('#hashchange').click()\n          .then(function () {\n            const { lastLog } = this\n\n            expect(lastLog.get('message')).to.eq('http://localhost:3500/fixtures/generic.html#hashchange')\n            expect(lastLog.get('type')).to.eq('parent')\n            expect(lastLog.get('event')).to.be.true\n\n            expect(lastLog.invoke('consoleProps')).to.deep.eq({\n              'Event': 'new url',\n              'New Url': 'http://localhost:3500/fixtures/generic.html#hashchange',\n              'Url Updated By': 'hashchange',\n              'Args': ohc,\n            })\n          })\n        })\n      })\n\n      it('logs url:changed event as navigation events occur', () => {\n        cy\n        .visit('/fixtures/generic.html')\n        .get('#hashchange').click()\n        .window().then((win) => {\n          return new Promise((resolve) => {\n            cy.once('navigation:changed', resolve)\n\n            win.history.back()\n          }).then(() => {\n            return new Promise((resolve) => {\n              cy.once('navigation:changed', resolve)\n\n              win.history.forward()\n            })\n          })\n        }).then(function () {\n          expect(this.logs.length).to.eq(3)\n\n          expect(this.logs[0].get('message')).to.eq(\n            'http://localhost:3500/fixtures/generic.html#hashchange',\n          )\n\n          expect(this.logs[1].get('message')).to.eq(\n            'http://localhost:3500/fixtures/generic.html',\n          )\n\n          expect(this.logs[2].get('message')).to.eq(\n            'http://localhost:3500/fixtures/generic.html#hashchange',\n          )\n        })\n      })\n    })\n\n    describe('history.pushState', () => {\n      it('emits url:changed event', () => {\n        const emit = cy.spy(Cypress, 'emit').log(false)\n\n        cy\n        .visit('/fixtures/generic.html')\n        .window().then((win) => {\n          win.history.pushState({ foo: 'bar' }, null, 'pushState.html')\n\n          expect(emit).to.be.calledWith(\n            'url:changed',\n            'http://localhost:3500/fixtures/pushState.html',\n          )\n        })\n      })\n\n      it('logs url changed event', () => {\n        cy\n        .visit('/fixtures/generic.html')\n        .window().then(function (win) {\n          win.history.pushState({ foo: 'bar' }, null, 'pushState.html')\n\n          const { lastLog } = this\n\n          expect(lastLog.get('message')).to.eq('http://localhost:3500/fixtures/pushState.html')\n          expect(lastLog.get('type')).to.eq('parent')\n          expect(lastLog.get('event')).to.be.true\n          expect(lastLog.invoke('consoleProps')).to.deep.eq({\n            'Event': 'new url',\n            'New Url': 'http://localhost:3500/fixtures/pushState.html',\n            'Url Updated By': 'pushState',\n            'Args': [\n              { foo: 'bar' },\n              null,\n              'pushState.html',\n            ],\n          })\n        })\n      })\n    })\n\n    describe('history.replaceState', () => {\n      it('emits url:changed event', () => {\n        const emit = cy.spy(Cypress, 'emit').log(false)\n\n        cy\n        .visit('/fixtures/generic.html')\n        .window().then((win) => {\n          win.history.replaceState({ foo: 'bar' }, null, 'replaceState.html')\n\n          expect(emit).to.be.calledWith(\n            'url:changed',\n            'http://localhost:3500/fixtures/replaceState.html',\n          )\n        })\n      })\n\n      it('logs url changed event', () => {\n        cy\n        .visit('/fixtures/generic.html')\n        .window().then(function (win) {\n          win.history.replaceState({ foo: 'bar' }, null, 'replaceState.html')\n\n          const { lastLog } = this\n\n          expect(lastLog.get('message')).to.eq('http://localhost:3500/fixtures/replaceState.html')\n          expect(lastLog.get('type')).to.eq('parent')\n          expect(lastLog.get('event')).to.be.true\n          expect(lastLog.invoke('consoleProps')).to.deep.eq({\n            'Event': 'new url',\n            'New Url': 'http://localhost:3500/fixtures/replaceState.html',\n            'Url Updated By': 'replaceState',\n            'Args': [\n              { foo: 'bar' },\n              null,\n              'replaceState.html',\n            ],\n          })\n        })\n      })\n    })\n  })\n\n  context('#form sub', () => {\n    beforeEach(function () {\n      this.logs = []\n\n      cy.on('log:added', (attrs, log) => {\n        if (attrs.name === 'form sub') {\n          this.lastLog = log\n          this.logs.push(log)\n        }\n      })\n\n      return null\n    })\n\n    it('logs \\'form sub\\'', () => {\n      let event = null\n\n      cy\n      .visit('/fixtures/form.html')\n      .then(() => {\n        const $form = cy.$$('#click-me').on('submit', (e) => {\n          event = e.originalEvent\n        })\n\n        cy\n        .get('#click-me').find('input[type=submit]').click()\n        .then(function () {\n          expect(this.logs.length).to.eq(1)\n\n          expect(this.logs[0].get('message')).to.eq(\n            '--submitting form--',\n          )\n\n          expect(this.logs[0].invoke('consoleProps')).to.deep.eq({\n            'Event': 'form sub',\n            'Originated From': $form.get(0),\n            'Args': event,\n          })\n        })\n      })\n    })\n  })\n})\n\nconst causeSynchronousBeforeUnload = function ($a) {\n  // this causes a synchronous beforeunload event\n  // chrome & firefox behave differently\n  const win = $a[0].ownerDocument.defaultView\n\n  if (Cypress.isBrowser('firefox')) {\n    win.location.href = $a[0].href\n  } else {\n    return $a.get(0).click()\n  }\n}\n",
    "packages/driver/cypress/integration/commands/net_stubbing_spec.ts": "import { getDisplayUrlMatcher } from '@packages/driver/src/cy/net-stubbing/route-matcher-log'\nimport { RouteMatcherOptions } from '@packages/net-stubbing/lib/external-types'\n\nconst testFail = (cb, expectedDocsUrl = 'https://on.cypress.io/intercept') => {\n  cy.on('fail', (err) => {\n    // @ts-ignore\n    const docsUrl = Array.isArray(err.docsUrl) ? err.docsUrl[0] : err.docsUrl\n\n    expect(docsUrl).to.eq(expectedDocsUrl)\n    cb(err)\n  })\n}\n\ndescribe('network stubbing', { retries: { runMode: 2, openMode: 0 } }, function () {\n  const { $, _, sinon, state, Promise } = Cypress\n\n  beforeEach(function () {\n    cy.spy(Cypress.utils, 'warning')\n  })\n\n  context('cy.intercept()', function () {\n    context('emits as expected', function () {\n      beforeEach(function () {\n        // we don't use cy.spy() because it causes an infinite loop with logging events\n        this.sandbox = sinon.createSandbox()\n        this.emit = this.sandbox.spy(Cypress, 'emit').withArgs('backend:request', 'net', 'route:added')\n\n        this.testRoute = function (options, handler, expectedEvent, expectedRoute) {\n          cy.intercept(options, handler).then(function () {\n            const routeId = _.findKey(state('routes'), { handler })\n            const route = state('routes')[routeId!]\n\n            expectedEvent.routeId = routeId\n            expect(this.emit).to.be.calledWith('backend:request', 'net', 'route:added', expectedEvent)\n\n            expect(route.handler).to.deep.eq(expectedRoute.handler)\n            expect(route.options).to.deep.eq(expectedRoute.options)\n          })\n        }\n      })\n\n      afterEach(function () {\n        this.sandbox.restore()\n      })\n\n      it('url, body and stores Route', function () {\n        const handler = 'bar'\n        const url = 'http://foo.invalid'\n        const expectedEvent = {\n          routeMatcher: {\n            url: {\n              type: 'glob',\n              value: url,\n            },\n          },\n          staticResponse: {\n            body: 'bar',\n          },\n          hasInterceptor: false,\n        }\n\n        const expectedRoute = {\n          options: { url },\n          handler,\n        }\n\n        this.testRoute(url, handler, expectedEvent, expectedRoute)\n      })\n\n      it('url, HTTPController and stores Route', function () {\n        const handler = () => {\n          return {}\n        }\n\n        const url = 'http://foo.invalid'\n        const expectedEvent = {\n          routeMatcher: {\n            url: {\n              type: 'glob',\n              value: url,\n            },\n          },\n          hasInterceptor: true,\n        }\n\n        const expectedRoute = {\n          options: { url },\n          handler,\n        }\n\n        this.testRoute(url, handler, expectedEvent, expectedRoute)\n      })\n\n      it('regex values stringified and other values copied and stores Route', function () {\n        const handler = () => {\n          return {}\n        }\n\n        const options = {\n          auth: {\n            username: 'foo',\n            password: /.*/,\n          },\n          headers: {\n            'Accept-Language': /hylian/i,\n            'Content-Encoding': 'corrupted',\n          },\n          hostname: /any.com/,\n          https: true,\n          method: 'POST',\n          path: '/bing?foo',\n          pathname: '/bazz',\n          port: [1, 2, 3, 4, 5, 6],\n          query: {\n            bar: 'baz',\n            quuz: /(.*)quux/gi,\n          },\n          url: 'http://foo.invalid',\n        }\n\n        const expectedEvent = {\n          routeMatcher: {\n            auth: {\n              username: {\n                type: 'glob',\n                value: options.auth.username,\n              },\n              password: {\n                type: 'regex',\n                value: '/.*/',\n              },\n            },\n            headers: {\n              'accept-language': {\n                type: 'regex',\n                value: '/hylian/i',\n              },\n              'content-encoding': {\n                type: 'glob',\n                value: options.headers['Content-Encoding'],\n              },\n            },\n            hostname: {\n              type: 'regex',\n              value: '/any.com/',\n            },\n            https: options.https,\n            method: {\n              type: 'glob',\n              value: options.method,\n            },\n            path: {\n              type: 'glob',\n              value: options.path,\n            },\n            pathname: {\n              type: 'glob',\n              value: options.pathname,\n            },\n            port: options.port,\n            query: {\n              bar: {\n                type: 'glob',\n                value: options.query.bar,\n              },\n              quuz: {\n                type: 'regex',\n                value: '/(.*)quux/gi',\n              },\n            },\n            url: {\n              type: 'glob',\n              value: options.url,\n            },\n          },\n          hasInterceptor: true,\n        }\n\n        const expectedRoute = {\n          options,\n          handler,\n        }\n\n        this.testRoute(options, handler, expectedEvent, expectedRoute)\n      })\n\n      it('mergeRouteMatcher + string url works', function () {\n        const url = '/foo*'\n\n        const handler = (req) => {\n          // @ts-ignore\n          const routeId = _.findKey(state('routes'), { handler })\n          const route = state('routes')[routeId!]\n\n          // @ts-ignore\n          expectedEvent.routeId = routeId\n          expect(this.emit).to.be.calledWith('backend:request', 'net', 'route:added', expectedEvent)\n\n          expect(route.handler).to.deep.eq(expectedRoute.handler)\n          expect(route.options).to.deep.eq(expectedRoute.options)\n\n          req.reply('a')\n        }\n\n        const expectedRoute = {\n          options: { url, middleware: true },\n          handler,\n        }\n\n        const expectedEvent = {\n          routeMatcher: {\n            url: {\n              type: 'glob',\n              value: url,\n            },\n            middleware: true,\n          },\n          hasInterceptor: true,\n        }\n\n        cy.intercept(url, { middleware: true }, handler).as('get')\n        .then(() => {\n          return $.get('/foo')\n        })\n        .wait('@get')\n      })\n\n      // @see https://github.com/cypress-io/cypress/pull/16390\n      it('mergeRouteMatcher + regex url works', function () {\n        const url = /^\\/foo.*/\n\n        const handler = (req) => {\n          // @ts-ignore\n          const routeId = _.findKey(state('routes'), { handler })\n          const route = state('routes')[routeId!]\n\n          // @ts-ignore\n          expectedEvent.routeId = routeId\n          expect(this.emit).to.be.calledWith('backend:request', 'net', 'route:added', expectedEvent)\n\n          expect(route.handler).to.deep.eq(expectedRoute.handler)\n          expect(route.options).to.deep.eq(expectedRoute.options)\n\n          req.reply('a')\n        }\n\n        const expectedRoute = {\n          options: { url, middleware: true },\n          handler,\n        }\n\n        const expectedEvent = {\n          routeMatcher: {\n            url: {\n              type: 'regex',\n              value: String(url),\n            },\n            middleware: true,\n          },\n          hasInterceptor: true,\n        }\n\n        cy.intercept(url, { middleware: true }, handler).as('get')\n        .then(() => {\n          return $.get('/foo')\n        })\n        .wait('@get')\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/8729\n    it('resolve ambiguity between overloaded definitions', () => {\n      cy.intercept('POST', '/post-only').as('create')\n\n      cy.window().then((win) => {\n        win.eval(\n          `fetch(\"/post-only\", {\n            method: 'POST', // *GET, POST, PUT, DELETE, etc.\n          });`,\n        )\n      })\n\n      cy.wait('@create')\n    })\n\n    // https://github.com/cypress-io/cypress/issues/9313\n    it('lower-cased method works', () => {\n      cy.intercept({\n        method: 'post',\n        url: '/post-only',\n      }).as('create')\n\n      cy.window().then((win) => {\n        win.eval(\n          `fetch(\"/post-only\", {\n            method: 'post', // *GET, POST, PUT, DELETE, etc.\n          });`,\n        )\n      })\n\n      cy.wait('@create')\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/16117\n    it('can statically stub a url response with headers', () => {\n      cy.intercept('/url', { headers: { foo: 'bar' }, body: 'something' })\n    })\n\n    // TODO: implement warning in cy.intercept if appropriate\n    // https://github.com/cypress-io/cypress/issues/2372\n    it.skip('warns if a percent-encoded URL is used', function () {\n      cy.intercept('GET', '/foo%25bar').then(function () {\n        expect(Cypress.utils.warning).to.be.calledWith('A URL with percent-encoded characters was passed to cy.intercept(), but cy.intercept() expects a decoded URL.\\n\\nDid you mean to pass \"/foo%bar\"?')\n      })\n    })\n\n    // NOTE: see todo on 'warns if a percent-encoded URL is used'\n    it.skip('does not warn if an invalid percent-encoded URL is used', function () {\n      cy.intercept('GET', 'http://example.com/%E0%A4%A').then(function () {\n        expect(Cypress.utils.warning).to.not.be.called\n      })\n    })\n\n    context('overrides', function () {\n      it('chains middleware with string matcher as expected', function () {\n        const e: string[] = []\n\n        cy\n        .intercept('/dump-headers*', { middleware: true }, (req) => {\n          e.push('mware req handler')\n          req.on('before:response', (res) => {\n            e.push('mware before:response')\n          })\n\n          req.on('response', (res) => {\n            e.push('mware response')\n          })\n\n          req.on('after:response', (res) => {\n            e.push('mware after:response')\n          })\n        })\n        .intercept('/dump-headers*', (req) => {\n          e.push('normal req handler')\n          req.reply(() => {\n            e.push('normal res handler')\n          })\n        })\n        .then(() => {\n          return $.get('/dump-headers')\n        })\n        .wrap(e).should('have.all.members', [\n          'mware req handler',\n          'normal req handler',\n          'mware before:response',\n          'normal res handler',\n          'mware response',\n          'mware after:response',\n        ])\n      })\n\n      it('chains request handlers from bottom-up', function (done) {\n        cy.intercept('/dump-headers*', (req) => {\n          req.reply((res) => {\n            expect(res.body).to.include('\"x-foo\":\"bar\"')\n            done()\n          })\n        })\n        .intercept('/dump-headers*', (req) => req.headers['x-foo'] = 'bar')\n        .then(() => {\n          $.get('/dump-headers')\n        })\n      })\n\n      /**\n       * https://github.com/cypress-io/cypress/issues/9302\n       * https://github.com/cypress-io/cypress/discussions/9339\n       * https://github.com/cypress-io/cypress/issues/4460\n       */\n      it('can override a StaticResponse with another StaticResponse', function () {\n        cy.intercept('GET', '/items*', [])\n        .intercept('GET', '/items*', ['foo', 'bar'])\n        .then(() => {\n          return $.getJSON('/items')\n        })\n        .should('deep.eq', ['foo', 'bar'])\n      })\n\n      /**\n       * https://github.com/cypress-io/cypress/discussions/9587\n       */\n      it('can override an interceptor with another interceptor', function () {\n        cy.intercept('GET', '**/mydata?**', (req) => {\n          throw new Error('this should not be called')\n        })\n        .intercept('GET', '/mydata*', (req) => {\n          req.reply({ body: [1, 2, 3, 4, 5] })\n        }).as('mydata')\n        .then(() => {\n          return $.getJSON('/mydata?abc')\n        })\n        .should('deep.eq', [1, 2, 3, 4, 5])\n        .wait('@mydata')\n      })\n\n      it('sends a StaticResponse if the newest stub is a StaticResponse', function () {\n        cy.intercept('/foo*', () => {\n          throw new Error('this should not be called')\n        }).as('interceptor')\n        .intercept('/foo*', { body: 'something' }).as('staticresponse')\n        .intercept('/foo*').as('spy')\n        .then(() => {\n          return $.get('/foo')\n        })\n        .should('deep.eq', 'something')\n        .wait('@spy')\n        .wait('@staticresponse')\n        .get('@interceptor.all').should('have.length', 0)\n      })\n\n      it('sends a StaticResponse if a request handler does not supply a response', function () {\n        cy.intercept('/foo*', { body: 'something' }).as('staticresponse')\n        .intercept('/foo*', () => { }).as('interceptor')\n        .then(() => {\n          return $.get('/foo')\n        })\n        .should('deep.eq', 'something')\n        .wait('@interceptor')\n        .wait('@staticresponse')\n      })\n\n      context('request handler chaining', function () {\n        it('passes request through in reverse order', function () {\n          cy.intercept('/dump-method', function (req) {\n            expect(req.method).to.eq('PATCH')\n\n            req.reply()\n          }).intercept('/dump-method', function (req) {\n            expect(req.method).to.eq('POST')\n            req.method = 'PATCH'\n          }).intercept('/dump-method', function (req) {\n            expect(req.method).to.eq('GET')\n            req.method = 'POST'\n          }).visit('/dump-method').contains('PATCH')\n        })\n\n        it('stops passing request through once req.reply called', function () {\n          cy.intercept('/dump-method', function (req) {\n            throw new Error('this should not have been reached')\n          }).intercept('/dump-method', function (req) {\n            req.reply()\n          }).visit('/dump-method').contains('GET')\n        })\n      })\n\n      context('response handler chaining', function () {\n        it('passes response through in reverse order', function () {\n          cy.intercept('/dump-method', function (req) {\n            req.on('before:response', (res) => {\n              expect(res.body).to.contain('new body')\n            })\n          }).intercept('/dump-method', function (req) {\n            req.on('before:response', (res) => {\n              expect(res.body).to.contain('GET')\n              res.body = 'new body'\n            })\n          }).visit('/dump-method')\n          .contains('new body')\n        })\n\n        it('stops passing response through once res.send called', function () {\n          cy.intercept('/dump-method', function (req) {\n            req.on('before:response', (res) => {\n              throw new Error('this should not have been reached')\n            })\n          }).intercept('/dump-method', function (req) {\n            req.on('before:response', (res) => {\n              res.send()\n            })\n          }).visit('/dump-method').contains('GET')\n        })\n      })\n    })\n\n    context('logging', function () {\n      beforeEach(function () {\n        this.logs = []\n        cy.on('log:added', (attrs, log) => {\n          if (attrs.instrument === 'route') {\n            this.lastLog = log\n\n            this.logs.push(log)\n          }\n        })\n      })\n\n      it('has name of route', function () {\n        cy.intercept('/foo', {}).then(function () {\n          expect(this.lastLog.get('name')).to.eq('route')\n        })\n      })\n\n      it('uses the wildcard URL', function () {\n        cy.intercept('*', {}).then(function () {\n          expect(this.lastLog.get('url')).to.eq('*')\n        })\n      })\n\n      // @see https://github.com/cypress-io/cypress/issues/9403\n      // see getDisplayUrlMatcher unit tests for more test cases\n      it('stringifies complex matchers', function () {\n        cy.intercept({ hostname: 'foo.net', port: 1234 }).then(function () {\n          expect(this.lastLog.get('url')).to.eq('{hostname: foo.net, port: 1234}')\n          expect(this.lastLog.get('method')).to.eq('*')\n        })\n      })\n\n      it('has displayName req for spies', function () {\n        cy.intercept('/foo*').as('getFoo')\n        .then(() => {\n          $.get('/foo')\n        })\n        .wait('@getFoo')\n        .then(() => {\n          const log = _.last(cy.queue.logs()) as any\n\n          expect(log.get('displayName')).to.eq('req')\n        })\n      })\n\n      it('has displayName req stub for stubs', function () {\n        cy.intercept('/foo*', { body: 'foo' }).as('getFoo')\n        .then(() => {\n          $.get('/foo')\n        })\n        .wait('@getFoo')\n        .then(() => {\n          const log = _.last(cy.queue.logs()) as any\n\n          expect(log.get('displayName')).to.eq('req stub')\n        })\n      })\n\n      it('has displayName req fn for request handlers', function () {\n        cy.intercept('/foo*', () => {}).as('getFoo')\n        .then(() => {\n          $.get('/foo')\n        })\n        .wait('@getFoo')\n        .then(() => {\n          const log = _.last(cy.queue.logs()) as any\n\n          expect(log.get('displayName')).to.eq('req fn')\n        })\n      })\n\n      // TODO: implement log niceties\n      it.skip('#consoleProps', function () {\n        cy.intercept('*', {\n          foo: 'bar',\n        }).as('foo').then(function () {\n          expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n            Command: 'route',\n            Method: 'GET',\n            URL: '*',\n            Status: 200,\n            Response: {\n              foo: 'bar',\n            },\n            Alias: 'foo',\n          })\n        })\n      })\n\n      describe('numResponses', function () {\n        it('is initially 0', function () {\n          cy.intercept(/foo/, {}).then(() => {\n            let lastLog\n\n            lastLog = this.lastLog\n\n            expect(lastLog.get('numResponses')).to.eq(0)\n          })\n        })\n\n        it('is incremented to 2', function () {\n          cy.intercept(/foo/, {}).then(function () {\n            $.get('/foo')\n          }).wrap(this).invoke('lastLog.get', 'numResponses').should('eq', 1)\n        })\n\n        it('is incremented for each matching request', function () {\n          cy.intercept(/foo/, {}).then(function () {\n            return Promise.all([$.get('/foo'), $.get('/foo'), $.get('/foo')])\n          }).wrap(this).invoke('lastLog.get', 'numResponses').should('eq', 3)\n        })\n      })\n    })\n\n    context('errors', function () {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          // @ts-ignore\n          if (log.get('name') !== 'intercept') {\n            return\n          }\n\n          this.lastLog = log\n          this.logs.push(log)\n        })\n      })\n\n      it('url must be a string or regexp', function (done) {\n        testFail((err) => {\n          expect(err.message).to.include('`url` must be a string or a regular expression')\n\n          done()\n        })\n\n        // @ts-ignore: should fail\n        cy.intercept({\n          // @ts-ignore\n          url: {},\n        })\n      })\n\n      // TODO: not currently implemented\n      it.skip('fails when method is invalid', function (done) {\n        testFail((err) => {\n          expect(err.message).to.include('cy.intercept() was called with an invalid method: \\'POSTS\\'.')\n\n          done()\n        })\n\n        cy.intercept('post', '/foo', {})\n      })\n\n      it('requires a url when given a response', function (done) {\n        testFail((err) => {\n          expect(err.message).to.include('The RouteMatcher does not contain any keys. You must pass something to match on.')\n\n          done()\n        })\n\n        cy.intercept({})\n      })\n\n      it('requires arguments', function (done) {\n        testFail((err) => {\n          expect(err.message).to.include('An invalid RouteMatcher was supplied to `cy.intercept()`. The RouteMatcher does not contain any keys. You must pass something to match on.')\n\n          done()\n        })\n\n        // @ts-ignore - should fail\n        cy.intercept()\n      })\n\n      it('cannot merge url with url', function (done) {\n        testFail((err) => {\n          expect(err.message).to.include('When invoking \\`cy.intercept()\\` with a \\`RouteMatcher\\` as the second parameter, \\`url\\` can only be specified as the first parameter')\n\n          done()\n        })\n\n        // @ts-ignore - should fail\n        cy.intercept('/foo', { url: '/bar' }, () => {})\n      })\n\n      it('cannot pass RouteMatcherOptions in 2nd arg with no handler', function (done) {\n        testFail((err) => {\n          expect(err.message).to.include('When invoking \\`cy.intercept()\\` with a \\`RouteMatcher\\` as the second parameter, a handler (function or \\`StaticResponse\\`) must be specified as the third parameter.')\n\n          done()\n        })\n\n        // sadly this passes typecheck, but the runtime error will prevent this\n        cy.intercept('/foo', { middleware: true })\n      })\n\n      context('with invalid RouteMatcher', function () {\n        it('requires unique header names', function (done) {\n          testFail((err) => {\n            expect(err.message).to.include('`FOO` was specified more than once in `headers`. Header fields can only be matched once (HTTP header field names are case-insensitive).')\n\n            done()\n          })\n\n          cy.intercept({\n            headers: {\n              foo: 'bar',\n              FOO: 'bar',\n            },\n          })\n        })\n\n        it('requires StringMatcher header values', function (done) {\n          testFail((err) => {\n            expect(err.message).to.include('`headers.wrong` must be a string or a regular expression.')\n\n            done()\n          })\n\n          // @ts-ignore this is invalid on purpose\n          cy.intercept({\n            headers: {\n              good: 'string',\n              fine: /regexp/,\n              // @ts-ignore\n              wrong: 3,\n            },\n          })\n        })\n\n        it('errors on matchUrlAgainstPath usage', function (done) {\n          testFail((err) => {\n            expect(err.message).to.include('`matchUrlAgainstPath` was removed in Cypress 7.0.0')\n\n            done()\n          })\n\n          // @ts-ignore\n          cy.intercept({ matchUrlAgainstPath: true })\n        })\n\n        it('errors on unknown prop', function (done) {\n          testFail((err) => {\n            expect(err.message).to.include('An unknown \\`RouteMatcher\\` property was passed: `wrong`')\n\n            done()\n          })\n\n          // @ts-ignore\n          cy.intercept({ wrong: true })\n        })\n\n        it('times must be a positive integer', function (done) {\n          cy.on('fail', function (err) {\n            expect(err.message).to.include('`times` must be a positive integer.')\n            done()\n          })\n\n          cy\n          .intercept({ times: 9.75 })\n        })\n      })\n\n      context('with invalid handler', function () {\n        [false, null].forEach(function (handler) {\n          const name = String(handler)\n\n          it(`${name} fails`, function (done) {\n            testFail((err) => {\n              expect(err).to.eq(this.lastLog.get('error'))\n              expect(err.message).to.contain(`You passed: ${name}`)\n\n              done()\n            })\n\n            // @ts-ignore - this should error\n            cy.intercept('/', handler)\n          })\n        })\n      })\n\n      context('with invalid StaticResponse', function () {\n        [\n          [\n            'forceNetworkError set but not alone',\n            {\n              forceNetworkError: true,\n              body: 'aaa',\n            },\n            'must be the only option',\n          ],\n          [\n            'statusCode out of range',\n            {\n              statusCode: -1,\n            },\n            'must be a number',\n          ],\n        ].forEach(function ([name, handler, expectedErr]) {\n          it(`${name} fails`, function (done) {\n            testFail((err) => {\n              expect(err).to.eq(this.lastLog.get('error'))\n              expect(err.message).to.contain(expectedErr)\n              expect(err.message).to.contain(`You passed: ${JSON.stringify(handler, null, 2)}`)\n\n              done()\n            })\n\n            // @ts-ignore - this should error\n            cy.intercept('/', handler)\n          })\n        })\n      })\n    })\n  })\n\n  context('events', function () {\n    // @see https://github.com/cypress-io/cypress/issues/9170\n    it('gracefully handles request received without a known route', function () {\n      cy.intercept('/valid.json', (req) => {\n        req.reply({ bad: 'should not be received' })\n      })\n      .then(() => {\n        const routeIds = _.keys(state('routes'))\n\n        // delete the driver-side route - the server-side route will still exist and cause an event\n        // to be emitted to the driver\n        delete state('routes')[routeIds[0]]\n        expect(state('routes')).to.deep.eq({})\n\n        return $.get('/fixtures/valid.json')\n      })\n      .then((body) => {\n        expect(body).to.include({ foo: 1 })\n      })\n    })\n\n    it('gracefully handles response received without a known route', function () {\n      cy.intercept('/valid.json', (req) => {\n        state('routes', {})\n\n        req.reply((res) => {\n          res.send({ bad: 'should not be received' })\n        })\n      })\n      .then(() => {\n        return $.get('/fixtures/valid.json')\n      })\n      .then((body) => {\n        expect(body).to.include({ foo: 1 })\n      })\n    })\n\n    it('gracefully handles response completed without a known route', function () {\n      cy.intercept('/fixtures/valid.json*', (req) => {\n        req.reply((res) => {\n          state('routes', {})\n\n          res.send({ bar: 2 })\n        })\n      })\n      .then(() => {\n        return $.get('/fixtures/valid.json')\n      })\n      .then((body) => {\n        expect(body).to.include({ bar: 2 })\n      })\n    })\n  })\n\n  context('network handling', function () {\n    // @see https://github.com/cypress-io/cypress/issues/8497\n    it('can load transfer-encoding: chunked redirects', function () {\n      cy.intercept('*')\n      const url4 = 'http://localhost:3501/fixtures/generic.html'\n      const url3 = `http://localhost:3501/redirect?href=${encodeURIComponent(url4)}`\n      const url2 = `https://localhost:3502/redirect?chunked=1&href=${encodeURIComponent(url3)}`\n      const url1 = `https://localhost:3502/redirect?chunked=1&href=${encodeURIComponent(url2)}`\n\n      cy.visit(url1)\n      .location('href').should('eq', url4)\n    })\n\n    context('can intercept against any domain', function () {\n      beforeEach(function () {\n        // reset origin\n        cy.visit('http://localhost:3500/fixtures/generic.html')\n      })\n\n      it('different origin (HTTP)', function () {\n        cy.intercept('/foo*').as('foo')\n        .then(() => {\n          $.get('http://baz.foobar.com:3501/foo')\n        })\n        .wait('@foo')\n      })\n\n      it('different origin with response interception (HTTP)', function () {\n        cy.intercept('/fixtures/xhr.html*', (req) => {\n          req.reply((res) => {\n            expect(res.body).to.include('xhr fixture')\n            res.body = 'replaced the body'\n          })\n        }).as('foo')\n        .then(() => {\n          return $.get('http://baz.foobar.com:3501/fixtures/xhr.html')\n          .then((responseText) => {\n            expect(responseText).to.eq('replaced the body')\n          })\n        })\n        .wait('@foo').its('response.body').should('eq', 'replaced the body')\n      })\n\n      // @see https://github.com/cypress-io/cypress/issues/8487\n      it('different origin (HTTPS)', function () {\n        cy.intercept('/foo*', 'somethin').as('foo')\n        .then(() => {\n          $.get('https://bar.foobar.com.invalid:3502/foo')\n        })\n        .wait('@foo')\n      })\n\n      it('different origin with response interception (HTTPS)', function () {\n        cy.intercept('/fixtures/xhr.html*', (req) => {\n          req.reply((res) => {\n            expect(res.body).to.include('xhr fixture')\n            res.body = 'replaced the body'\n          })\n        }).as('foo')\n        .then(() => {\n          return $.get('https://bar.foobar.com:3502/fixtures/xhr.html')\n          .then((responseText) => {\n            expect(responseText).to.eq('replaced the body')\n          })\n        })\n        .wait('@foo').its('response.body').should('eq', 'replaced the body')\n      })\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/9599\n    context('cors preflight', function () {\n      // a different domain from the page own domain\n      // NOTE: this domain is redirected back to the local host test server\n      // using \"hosts\" setting in the \"cypress.json\" file\n      const corsUrl = 'http://diff.foobar.com:3501/no-cors'\n\n      before(() => {\n        cy.visit('http://127.0.0.1:3500/fixtures/dom.html')\n      })\n\n      it('responds to OPTIONS requests', function () {\n        // `/no-cors/` will respond with a 200, but missing valid preflight response\n        cy.request({ method: 'OPTIONS', url: corsUrl })\n        .then((res) => {\n          expect(res.headers).to.not.have.property('access-control-allow-origin')\n\n          // so this ajax request should fail due to CORS\n          return $.ajax({ method: 'DELETE', url: corsUrl })\n          .then(() => {\n            throw new Error('should not succeed')\n          })\n          .catch((res) => {\n            expect(res).to.include({ statusText: 'error' })\n          })\n        })\n        .intercept('/no-cors', (req) => {\n          req.reply(`intercepted ${req.method}`)\n        })\n        .then(() => {\n          // but now, the same ajax request succeeds, because the cy.intercept provides CORS\n          return $.ajax({ method: 'DELETE', url: corsUrl })\n          .then((res) => {\n            expect(res).to.eq('intercepted DELETE')\n          })\n        })\n      })\n\n      it('can be overwritten', function () {\n        cy.intercept('OPTIONS', '/no-cors', (req) => {\n          req.reply({\n            headers: {\n              'access-control-allow-origin': 'http://wrong.invalid',\n            },\n          })\n        })\n        .intercept('/no-cors', (req) => {\n          req.reply(`intercepted ${req.method}`)\n        })\n        .then(() => {\n          return $.ajax({ method: 'DELETE', url: corsUrl })\n          .then(() => {\n            throw new Error('should not succeed')\n          })\n          .catch((res) => {\n            expect(res).to.include({ statusText: 'error' })\n          })\n        })\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/15050\n    describe('cors expose header', () => {\n      // a different domain from the page own domain\n      const corsUrl = 'http://diff.foobar.com:3501/cors'\n\n      before(() => {\n        cy.visit('http://127.0.0.1:3500/fixtures/dom.html')\n      })\n\n      it('headers option is not set => no expose-header', () => {\n        cy\n        .intercept('/cors*', {})\n        .as('corsRequest')\n        .then(() => {\n          return $.get(corsUrl)\n        })\n\n        cy.wait('@corsRequest').then((res) => {\n          let headers = res.response?.headers\n\n          expect(headers).to.not.have.property('access-control-expose-headers')\n        })\n      })\n\n      it('headers option only has the accessible headers from the cors request => no expose-header', () => {\n        cy\n        .intercept('/cors*', {\n          body: { success: true },\n          headers: {\n            'cache-control': 'no-cache',\n            'content-language': 'en-US',\n            'content-type': 'text/html',\n            'Expires': 'Wed, 21 Oct 2015 07:28:00 GMT',\n            'Last-Modified': 'Wed, 21 Oct 2015 07:28:00 GMT',\n            'Pragma': 'no-cache',\n          },\n        })\n        .as('corsRequest')\n        .then(() => {\n          return $.get(corsUrl)\n        })\n\n        cy.wait('@corsRequest').then((res) => {\n          let headers = res.response?.headers\n\n          expect(headers).to.not.have.property('access-control-expose-headers')\n        })\n      })\n\n      it('headers option does not have the accessible header => include expose-header', () => {\n        cy\n        .intercept('/cors*', {\n          body: { success: true },\n          headers: {\n            'cache-control': 'no-cache',\n            'content-language': 'en-US',\n            'x-token': 'token',\n          },\n        })\n        .as('corsRequest')\n        .then(() => {\n          return $.get(corsUrl)\n        })\n\n        cy.wait('@corsRequest').then((res) => {\n          let headers = res.response?.headers\n\n          expect(headers!['access-control-expose-headers']).to.eq('*')\n          expect(headers!['x-token']).to.eq('token')\n        })\n      })\n\n      it('headers option has access-control-expose-headers => does not override', () => {\n        cy\n        .intercept('/cors*', {\n          body: { success: true },\n          headers: {\n            'access-control-expose-headers': 'x-token',\n            'x-token': 'token',\n          },\n        })\n        .as('corsRequest')\n        .then(() => {\n          return $.get(corsUrl)\n        })\n\n        cy.wait('@corsRequest').then((res) => {\n          let headers = res.response?.headers\n\n          expect(headers!['access-control-expose-headers']).to.eq('x-token')\n          expect(headers!['x-token']).to.eq('token')\n        })\n      })\n    })\n  })\n\n  context('stubbing with static responses', function () {\n    it('can stub a response with static body as string', function (done) {\n      cy.intercept({\n        url: '*',\n      }, 'hello world').then(() => {\n        $.get('/abc123').done((responseText, _, xhr) => {\n          expect(xhr.status).to.eq(200)\n          expect(responseText).to.eq('hello world')\n\n          done()\n        })\n      })\n    })\n\n    it('can stub a cy.visit with static body', function () {\n      cy.intercept('/foo', '<html>hello cruel world</html>').visit('/foo').document().should('contain.text', 'hello cruel world')\n    })\n\n    it('can stub a response with an empty StaticResponse', function (done) {\n      cy.intercept('/*', {}).then(() => {\n        $.get('/').done((responseText, _, xhr) => {\n          expect(xhr.status).to.eq(200)\n          expect(responseText).to.eq('')\n\n          done()\n        })\n      })\n    })\n\n    it('can stub a response with a network error', function (done) {\n      cy.intercept('/*', {\n        forceNetworkError: true,\n      }).then(() => {\n        $.get('/').fail((xhr) => {\n          expect(xhr.statusText).to.eq('error')\n          expect(xhr.status).to.eq(0)\n\n          done()\n        })\n      })\n    })\n\n    it('can use regular strings as response', function () {\n      cy.intercept('/foo*', 'foo bar baz').as('getFoo').then(function (win) {\n        $.get('/foo')\n      }).wait('@getFoo').then(function (res) {\n        expect(res.response!.body).to.eq('foo bar baz')\n      })\n    })\n\n    it('can stub requests with uncommon HTTP methods', function () {\n      cy.intercept('PROPFIND', '/foo', 'foo bar baz').as('getFoo').then(function (win) {\n        $.ajax({\n          url: '/foo',\n          method: 'PROPFIND',\n        })\n      }).wait('@getFoo').then(function (res) {\n        expect(res.response!.body).to.eq('foo bar baz')\n      })\n    })\n\n    it('can stub a response with an array', function (done) {\n      const response = ['foo', 'bar', { foo: 'baz' }]\n\n      cy.intercept({\n        url: '*',\n      }, response).then(() => {\n        $.get('/abc123').done((responseJson, _, xhr) => {\n          expect(xhr.status).to.eq(200)\n          expect(responseJson).to.deep.eq(response)\n          expect(xhr.getResponseHeader('content-type')).to.eq('application/json')\n\n          done()\n        })\n      })\n    })\n\n    it('does not drop falsy static responses', function (done) {\n      cy.intercept({\n        url: '*',\n      }, { body: false }).then(() => {\n        $.get('/abc123').done((responseText, _, xhr) => {\n          expect(xhr.status).to.eq(200)\n          expect(responseText).to.eq(false)\n          done()\n        })\n      })\n    })\n\n    // TODO: flaky - unable to reproduce outside of CI\n    it('still works after a cy.visit', { retries: 2 }, function () {\n      cy.intercept(/foo/, {\n        body: JSON.stringify({ foo: 'bar' }),\n        headers: {\n          'content-type': 'application/json',\n        },\n      }).as('getFoo').visit('http://localhost:3500/fixtures/jquery.html').window().then(function (win) {\n        return new Promise(function (resolve) {\n          $.get('/foo').done(_.ary(resolve, 0))\n        })\n      }).wait('@getFoo').its('request.url').should('include', '/foo').visit('http://localhost:3500/fixtures/generic.html').window().then(function (win) {\n        return new Promise(function (resolve) {\n          $.get('/foo').done(_.ary(resolve, 0))\n        })\n      }).wait('@getFoo').its('request.url').should('include', '/foo')\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/15841\n    it('prevents requests from reaching destination server', function () {\n      const v = String(Date.now())\n\n      // this test creates server-side state via /set-var to test if requests are being sent or not\n      cy.then(async () => {\n        await $.get(`/set-var?v=${v}`)\n        expect(await $.get('/get-var')).to.eq(v)\n      })\n      .intercept('/set-var*', { statusCode: 200, body: 'else' })\n      .then(async () => {\n        await $.get(`/set-var?v=something`)\n        expect(await $.get('/get-var')).to.eq(v)\n      })\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/8532\n    context('can stub a response with an empty array', function () {\n      const assertEmptyArray = (done) => {\n        return () => {\n          $.get('/abc123').done((responseJson, _, xhr) => {\n            expect(xhr.status).to.eq(200)\n            expect(responseJson).to.deep.eq([])\n            expect(xhr.getResponseHeader('content-type')).to.eq('application/json')\n\n            done()\n          })\n        }\n      }\n\n      it('with explicit StaticResponse', function (done) {\n        cy.intercept({\n          url: '*',\n        }, {\n          body: [],\n        }).then(assertEmptyArray(done))\n      })\n\n      it('with body shorthand', function (done) {\n        cy.intercept('*', []).then(assertEmptyArray(done))\n      })\n\n      it('with method, url, res shorthand', function (done) {\n        cy.intercept('GET', '*', []).then(assertEmptyArray(done))\n      })\n\n      it('in req.reply', function (done) {\n        cy.intercept('*', (req) => req.reply([])).then(assertEmptyArray(done))\n      })\n\n      it('in res.send', function (done) {\n        cy.intercept('*', (req) => req.reply((res) => res.send(200, []))).then(assertEmptyArray(done))\n      })\n    })\n\n    context('fixtures', function () {\n      it('can stub a response with a JSON object', function () {\n        cy.intercept({\n          method: 'POST',\n          url: '/test-xhr',\n        }, {\n          fixture: 'valid.json',\n        }).visit('/fixtures/xhr-triggered.html').get('#trigger-xhr').click()\n\n        cy.contains('#result', '{\"foo\":1,\"bar\":{\"baz\":\"cypress\"}}').should('be.visible')\n      })\n\n      it('works with content-type override', function () {\n        cy.intercept({\n          method: 'POST',\n          url: '/test-xhr',\n        }, {\n          headers: {\n            'content-type': 'text/plain',\n          },\n          fixture: 'valid.json',\n        }).visit('/fixtures/xhr-triggered.html').get('#trigger-xhr').click()\n\n        cy.contains('#result', '\"{\\\\\"foo\\\\\":1,\\\\\"bar\\\\\":{\\\\\"baz\\\\\":\\\\\"cypress\\\\\"}}\"').should('be.visible')\n      })\n\n      it('works if the JSON file has null content', function () {\n        cy.intercept({\n          method: 'POST',\n          url: '/test-xhr',\n        }, {\n          fixture: 'null.json',\n        }).visit('/fixtures/xhr-triggered.html').get('#trigger-xhr').click()\n\n        cy.contains('#result', '\"\"').should('be.visible')\n      })\n\n      // @see https://github.com/cypress-io/cypress/issues/8623\n      it('works with images', function () {\n        cy.visit('/fixtures/img-embed.html')\n        .contains('div', 'error loading image')\n        .intercept('non-existing-image.png', { fixture: 'media/cypress.png' })\n        .reload()\n        .contains('div', 'it loaded')\n      })\n\n      // @see https://github.com/cypress-io/cypress/issues/15898\n      // @see https://github.com/cypress-io/cypress/issues/16223\n      it('works when uploading a binary file', function () {\n        cy.fixture('media/cypress.png').as('image')\n        cy.intercept('POST', '/upload').as('upload')\n\n        cy.window().then((win) => {\n          const blob = Cypress.Blob.base64StringToBlob(this.image, 'image/png')\n          const xhr = new win.XMLHttpRequest()\n          const formData = new win.FormData()\n\n          formData.append('file', blob)\n          xhr.open('POST', '/upload', true)\n          xhr.send(formData)\n        })\n\n        cy.wait('@upload')\n      })\n    })\n  })\n\n  context('intercepting request', function () {\n    it('receives the original request in handler', function (done) {\n      cy.intercept('/def456*', function (req) {\n        req.reply({\n          statusCode: 404,\n        })\n\n        expect(req).to.include({\n          method: 'GET',\n          httpVersion: '1.1',\n        })\n\n        expect(req.url).to.match(/^http:\\/\\/localhost:3500\\/def456/)\n\n        done()\n      }).then(function () {\n        $.get('/def456')\n      })\n    })\n\n    it('receives the original request body in handler', function (done) {\n      cy.intercept('/aaa', function (req) {\n        expect(req.body).to.eq('foo-bar-baz')\n\n        done()\n      }).then(function () {\n        $.post('/aaa', 'foo-bar-baz')\n      })\n    })\n\n    it('can modify original request body and have it passed to next handler', function (done) {\n      cy.intercept('/post-only', function (req) {\n        expect(req.body).to.eq('quuz')\n        done()\n      }).intercept('/post-only', function (req) {\n        expect(req.body).to.eq('quux')\n        req.body = 'quuz'\n      }).intercept('/post-only', function (req) {\n        expect(req.body).to.eq('foo-bar-baz')\n        req.body = 'quux'\n      }).then(function () {\n        $.post('/post-only', 'foo-bar-baz')\n      })\n    })\n\n    it('can modify a cy.visit before it goes out', function () {\n      cy.intercept('/dump-headers', function (req) {\n        expect(req.headers['foo']).to.eq('bar')\n\n        req.headers['foo'] = 'quux'\n      }).then(function () {\n        cy.visit({\n          url: '/dump-headers',\n          headers: {\n            'foo': 'bar',\n          },\n        })\n\n        cy.get('body').should('contain.text', '\"foo\":\"quux\"')\n      })\n    })\n\n    it('can modify the request URL and headers', function (done) {\n      cy.intercept('/does-not-exist', function (req) {\n        expect(req.headers['foo']).to.eq('bar')\n        req.url = 'http://localhost:3500/dump-headers'\n\n        req.headers['foo'] = 'quux'\n      }).then(function () {\n        const xhr = new XMLHttpRequest()\n\n        xhr.open('GET', '/does-not-exist')\n        xhr.setRequestHeader('foo', 'bar')\n        xhr.send()\n\n        xhr.onload = () => {\n          expect(xhr.responseText).to.contain('\"foo\":\"quux\"')\n\n          done()\n        }\n      })\n    })\n\n    it('can delete a request header', function () {\n      cy.intercept('/dump-headers*', function (req) {\n        expect(req.headers).to.include({ 'foo': 'bar' })\n        delete req.headers['foo']\n      }).as('get')\n      .then(() => {\n        return $.get({\n          url: '/dump-headers',\n          headers: {\n            'foo': 'bar',\n          },\n        })\n      })\n      .should('not.include', 'foo')\n      .wait('@get')\n    })\n\n    it('can modify the request method', function (done) {\n      cy.intercept('/dump-method', function (req) {\n        expect(req.method).to.eq('POST')\n\n        req.method = 'PATCH'\n      }).then(function () {\n        $.post('/dump-method').done((responseText) => {\n          expect(responseText).to.contain('request method: PATCH')\n\n          done()\n        })\n      })\n    })\n\n    it('can modify the request body', function (done) {\n      const body = '{\"foo\":\"bar\"}'\n\n      cy.intercept('/post-only', function (req) {\n        expect(req.body).to.eq('quuz')\n        req.headers['content-type'] = 'application/json'\n\n        req.body = body\n      }).then(function () {\n        $.post('/post-only', 'quuz').done((responseText) => {\n          expect(responseText).to.contain(body)\n\n          done()\n        })\n      })\n    })\n\n    it('can add a body to a request that does not have one', function (done) {\n      const body = '{\"foo\":\"bar\"}'\n\n      cy.intercept('/post-only*', function (req) {\n        expect(req.body).to.eq('')\n        expect(req.method).to.eq('GET')\n        req.method = 'POST'\n        req.headers['content-type'] = 'application/json'\n\n        req.body = body\n      }).then(function () {\n        $.get('/post-only').done((responseText) => {\n          expect(responseText).to.contain(body)\n\n          done()\n        })\n      })\n    })\n\n    it('can reply with a JSON fixture', function () {\n      cy.intercept({\n        method: 'POST',\n        url: '/test-xhr',\n      }, (req) => {\n        req.reply({\n          fixture: 'valid.json',\n        })\n      }).visit('/fixtures/xhr-triggered.html').get('#trigger-xhr').click()\n\n      cy.contains('{\"foo\":1,\"bar\":{\"baz\":\"cypress\"}}')\n    })\n\n    it('can delay and throttle a StaticResponse', function (done) {\n      const payload = 'A'.repeat(10 * 1024)\n      const throttleKbps = 10\n      const delay = 250\n      const expectedSeconds = payload.length / (1024 * throttleKbps) + delay / 1000\n\n      cy.intercept('/timeout*', (req) => {\n        this.start = Date.now()\n\n        req.reply({\n          statusCode: 200,\n          body: payload,\n          throttleKbps,\n          delay,\n        })\n      }).then(() => {\n        return $.get('/timeout').then((responseText) => {\n          expect(Date.now() - this.start).to.be.closeTo(expectedSeconds * 1000 + 100, 100)\n          expect(responseText).to.eq(payload)\n\n          done()\n        })\n      })\n    })\n\n    it('can delay with deprecated delayMs param', function (done) {\n      const delayMs = 250\n\n      cy.intercept('/timeout*', (req) => {\n        this.start = Date.now()\n\n        req.reply({\n          delayMs,\n        })\n      }).then(() => {\n        return $.get('/timeout').then((responseText) => {\n          expect(Date.now() - this.start).to.be.closeTo(250 + 100, 100)\n\n          done()\n        })\n      })\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/14446\n    it('should delay the same amount on every response', () => {\n      const delay = 250\n\n      const testDelay = () => {\n        const start = Date.now()\n\n        return $.get('/timeout').then((responseText) => {\n          expect(Date.now() - start).to.be.closeTo(delay, 50)\n          expect(responseText).to.eq('foo')\n        })\n      }\n\n      cy.intercept('/timeout*', {\n        statusCode: 200,\n        body: 'foo',\n        delay,\n      }).as('get')\n      .then(() => testDelay()).wait('@get')\n      .then(() => testDelay()).wait('@get')\n      .then(() => testDelay()).wait('@get')\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/15901\n    it('can intercept utf-8 request bodies without crashing', function () {\n      cy.intercept('POST', 'http://localhost:5000/api/sample')\n      cy.visit('/fixtures/utf8-post.html')\n    })\n\n    context('request events', function () {\n      context('can end response', () => {\n        for (const eventName of ['before:response', 'response']) {\n          it(`in \\`${eventName}\\``, () => {\n            const expectBeforeResponse = eventName === 'response'\n            let beforeResponseCalled = false\n\n            cy.intercept('/foo*', (req) => {\n              req.on('response', (res) => {\n                throw new Error('response should not be reached')\n              })\n\n              req.on('before:response', (res) => {\n                beforeResponseCalled = true\n\n                if (!expectBeforeResponse) {\n                  throw new Error('before:response should not be reached')\n                }\n              })\n            }).as('first')\n            .intercept('/foo*', (req) => {\n              // @ts-ignore\n              req.on(eventName, (res) => {\n                res.send({\n                  statusCode: 200,\n                  fixture: 'valid.json',\n                })\n              })\n            }).as('second')\n            .then(() => {\n              return $.getJSON('/foo')\n            })\n            .should('include', { 'foo': 1 })\n            .wait('@first').wait('@second')\n            .then(() => {\n              expect(beforeResponseCalled).to.eq(expectBeforeResponse)\n            })\n          })\n        }\n      })\n\n      context('errors', function () {\n        it('when unknown eventName is passed', function (done) {\n          testFail((err) => {\n            expect(err.message).to.contain('An invalid event name was passed as the first parameter to \\`req.on()\\`.')\n            done()\n          })\n\n          cy.intercept('/foo', function (req) {\n            // @ts-ignore\n            req.on('totally-bad', _.noop)\n          }).visit('/foo')\n        })\n\n        it('when no function is passed', function (done) {\n          testFail((err) => {\n            expect(err.message).to.contain('\\`req.on()\\` requires the second parameter to be a function.')\n            done()\n          })\n\n          cy.intercept('/foo', function (req) {\n            // @ts-ignore\n            req.on('before:response', false)\n          }).visit('/foo')\n        })\n      })\n    })\n\n    context('body parsing', function () {\n      [\n        ['application/json', '{\"foo\":\"bar\"}'],\n        ['application/vnd.api+json', '{}'],\n      ].forEach(([contentType, expectedBody]) => {\n        it(`automatically parses ${contentType} request bodies`, function () {\n          const p = Promise.defer()\n\n          cy.intercept('/post-only', (req) => {\n            expect(req.headers['content-type']).to.eq(contentType)\n            expect(req.body).to.deep.eq({ foo: 'bar' })\n\n            p.resolve()\n          }).as('post')\n          .then(() => {\n            return $.ajax({\n              url: '/post-only',\n              method: 'POST',\n              contentType,\n              data: JSON.stringify({ foo: 'bar' }),\n            })\n          }).then((responseText) => {\n            expect(responseText).to.include(`request body:<br>${expectedBody}`)\n\n            return p\n          })\n          .wait('@post').its('request.body').should('deep.eq', { foo: 'bar' })\n        })\n      })\n\n      it('doesn\\'t automatically parse JSON request bodies if content-type is wrong', function () {\n        const p = Promise.defer()\n\n        cy.intercept('/post-only', (req) => {\n          expect(req.body).to.deep.eq(JSON.stringify({ foo: 'bar' }))\n\n          p.resolve()\n        }).as('post')\n        .then(() => {\n          return $.ajax({\n            url: '/post-only',\n            method: 'POST',\n            contentType: 'text/html',\n            data: JSON.stringify({ foo: 'bar' }),\n          })\n        }).wrap(p)\n        .wait('@post').its('request.body').should('eq', JSON.stringify({ foo: 'bar' }))\n      })\n\n      it('sets body to string if JSON is malformed', function () {\n        const p = Promise.defer()\n\n        cy.intercept('/post-only*', (req) => {\n          expect(req.body).to.deep.eq('{ foo::: }')\n\n          p.resolve()\n        }).as('post')\n        .then(() => {\n          return $.ajax({\n            url: '/post-only',\n            method: 'POST',\n            contentType: 'application/json',\n            // invalid JSON\n            data: '{ foo::: }',\n          }).catch(() => p)\n        })\n        .wait('@post').its('request.body').should('deep.eq', '{ foo::: }')\n      })\n    })\n\n    context('matches requests as expected', function () {\n      it('handles querystrings as expected', function () {\n        cy.intercept('*', 'it worked').as('final')\n        .intercept({\n          query: {\n            foo: 'b*r',\n            baz: /quu[x]/,\n          },\n        }).as('third')\n        .intercept({\n          path: '/abc?foo=bar&baz=qu*x*',\n        }).as('second')\n        .intercept({\n          pathname: '/abc',\n        }).as('first')\n        .then(() => {\n          return $.get('/abc?foo=bar&baz=quux')\n        })\n        .wait('@first')\n        .wait('@second')\n        .wait('@third')\n        .wait('@final')\n      })\n\n      // @see https://github.com/cypress-io/cypress/issues/8921\n      it('with case-insensitive header matching', function () {\n        cy.intercept({\n          headers: {\n            'X-some-Thing': 'foo',\n          },\n        })\n        .as('foo')\n        .then(() => {\n          $.get({\n            url: '/foo',\n            headers: {\n              'X-SOME-THING': 'foo',\n            },\n          })\n        })\n        .wait('@foo')\n      })\n\n      // @see https://github.com/cypress-io/cypress/issues/9379\n      context('falls back to matching by path if plain string is passed', function () {\n        it('matches globs against path', function (done) {\n          cy.intercept('/foo/*', (req) => {\n            expect(req.url).to.include('/foo/1')\n            done()\n          })\n          .then(() => {\n            $.ajax({ url: '/foo/1', cache: true })\n          })\n        })\n\n        it('matches nested globs against path', function (done) {\n          cy.intercept('/foo/*/bar', (req) => {\n            expect(req.url).to.match(/\\/foo\\/1\\/bar$/)\n            done()\n          })\n          .then(() => {\n            $.get({ url: '/foo/1/bar', cache: true })\n          })\n        })\n      })\n\n      context('with `times`', function () {\n        it('only uses each handler N times', function () {\n          const third = sinon.stub()\n\n          cy\n          .intercept({ url: '/foo*', times: 3 }, 'fourth').as('4')\n          .intercept({ url: '/foo*', times: 2 }, third).as('3')\n          .intercept({ url: '/foo*', times: 2 }, 'second').as('2')\n          .intercept({ url: '/foo*', times: 1 }, 'first').as('1')\n          .then(async () => {\n            const expectGet = (expected) => $.get('/foo').then((res) => expect(res).to.eq(expected))\n\n            await Promise.mapSeries([\n              'first',\n              'second',\n              'second',\n              'fourth',\n              'fourth',\n              'fourth',\n            ], expectGet)\n\n            expect(third).to.be.calledTwice\n\n            // now that matches are exhausted, it should fall through\n            await $.get('/foo').catch((xhr) => {\n              expect(xhr).to.include({\n                status: 404,\n              })\n            })\n          })\n          .get('@1.all').should('have.length', 1)\n          .get('@2.all').should('have.length', 2)\n          .get('@3.all').should('have.length', 2)\n          .get('@4.all').should('have.length', 3)\n        })\n      })\n    })\n\n    context('with StaticResponse shorthand', function () {\n      it('req.reply(body)', function () {\n        cy.intercept('/foo*', function (req) {\n          req.reply('baz')\n        })\n        .then(() => $.get('/foo'))\n        .should('eq', 'baz')\n      })\n\n      it('req.reply(json)', function () {\n        cy.intercept('/foo*', function (req) {\n          req.reply({ baz: 'quux' })\n        })\n        .then(() => $.getJSON('/foo'))\n        .should('deep.eq', { baz: 'quux' })\n      })\n\n      it('req.reply(status)', function () {\n        cy.intercept('/foo*', function (req) {\n          req.reply(777)\n        })\n        .then(() => {\n          return new Promise((resolve) => {\n            $.get('/foo').fail((x) => resolve(x.status))\n          })\n        })\n        .should('eq', 777)\n      })\n\n      it('req.reply(status, body)', function () {\n        cy.intercept('/foo*', function (req) {\n          req.reply(777, 'bar')\n        })\n        .then(() => {\n          return new Promise((resolve) => {\n            $.get('/foo').fail((xhr) => resolve(_.pick(xhr, 'status', 'responseText')))\n          })\n        }).should('include', {\n          status: 777,\n          responseText: 'bar',\n        })\n      })\n\n      it('req.reply(status, json)', function () {\n        cy.intercept('/foo*', function (req) {\n          req.reply(777, { bar: 'baz' })\n        })\n        .then(() => {\n          return new Promise((resolve) => {\n            $.get('/foo').fail((xhr) => resolve(_.pick(xhr, 'status', 'responseJSON')))\n          })\n        }).should('deep.include', {\n          status: 777,\n          responseJSON: { bar: 'baz' },\n        })\n      })\n\n      it('req.reply(status, json, headers)', function () {\n        cy.intercept('/foo*', function (req) {\n          req.reply(777, { bar: 'baz' }, { 'x-quux': 'quuz' })\n        })\n        .then(() => {\n          return new Promise((resolve) => {\n            $.get('/foo').fail((xhr) => resolve(_.pick(xhr, 'status', 'responseJSON', 'getAllResponseHeaders')))\n          })\n        }).should('deep.include', {\n          status: 777,\n          responseJSON: { bar: 'baz' },\n        }).invoke('getAllResponseHeaders')\n        .should('include', 'x-quux: quuz')\n        .and('include', 'content-type: application/json')\n      })\n\n      it('can forceNetworkError', function (done) {\n        cy.intercept('/foo*', function (req) {\n          req.reply({ forceNetworkError: true })\n        })\n        .then(() => {\n          $.get('/foo').fail((xhr) => {\n            expect(xhr).to.include({\n              status: 0,\n              statusText: 'error',\n              readyState: 0,\n            })\n\n            done()\n          })\n        })\n      })\n    })\n\n    context('request handler chaining', function () {\n      it('passes request through in reverse order', function () {\n        cy.intercept('/dump-method', function (req) {\n          expect(req.method).to.eq('PATCH')\n\n          req.reply()\n        }).intercept('/dump-method', function (req) {\n          expect(req.method).to.eq('POST')\n          req.method = 'PATCH'\n        }).intercept('/dump-method', function (req) {\n          expect(req.method).to.eq('GET')\n          req.method = 'POST'\n        }).visit('/dump-method').contains('PATCH')\n      })\n\n      it('stops passing request through once req.reply called', function () {\n        cy.intercept('/dump-method', function (req) {\n          throw new Error('this should not have been reached')\n        }).intercept('/dump-method', function (req) {\n          req.reply()\n        }).visit('/dump-method').contains('GET')\n      })\n    })\n\n    context('errors', function () {\n      it('fails test if req.reply is called twice in req handler', function (done) {\n        testFail((err) => {\n          expect(err.message).to.contain('`req.reply()` and/or `req.continue()` were called to signal request completion multiple times, but a request can only be completed once')\n          done()\n        })\n\n        cy.intercept('/dump-method', function (req) {\n          req.reply()\n\n          req.reply()\n        }).visit('/dump-method')\n      })\n\n      it('fails test if req.reply is called after req handler finishes', function (done) {\n        testFail((err) => {\n          expect(err.message).to.contain('> `req.reply()` was called after the request handler finished executing')\n          done()\n        })\n\n        cy.intercept('/dump-method', function (req) {\n          setTimeout(() => req.reply(), 50)\n        }).visit('/dump-method')\n      })\n\n      it('fails test if req.reply is called after req handler resolves', function (done) {\n        testFail((err) => {\n          expect(err.message).to.contain('> `req.reply()` was called after the request handler finished executing')\n          done()\n        })\n\n        cy.intercept('/dump-method', function (req) {\n          setTimeout(() => req.reply(), 50)\n\n          return Promise.resolve()\n        }).visit('/dump-method')\n      })\n\n      it('fails test if an exception is thrown in req handler', function (done) {\n        cy.on('fail', (err2) => {\n          expect(err2).to.eq(err)\n\n          done()\n        })\n\n        const err = new Error('bar')\n\n        cy.intercept('/foo', () => {\n          throw err\n        }).visit('/foo')\n      })\n\n      it('fails test if req.reply is called with an invalid StaticResponse', function (done) {\n        testFail((err) => {\n          expect(err.message).to.contain('must be a number between 100 and 999 (inclusive).')\n\n          done()\n        })\n\n        cy.intercept('/foo', (req) => {\n          req.reply({ statusCode: 1 })\n        }).visit('/foo')\n      })\n\n      it('can timeout in request handler', function (done) {\n        testFail((err) => {\n          Cypress.config('defaultCommandTimeout', 5000)\n          expect(err.message).to.match(/^A request callback passed to `cy.intercept\\(\\)` timed out after returning a Promise that took more than the `defaultCommandTimeout` of `50ms` to resolve\\./)\n\n          done()\n        })\n\n        Cypress.config('defaultCommandTimeout', 50)\n\n        cy.intercept('/foo', () => {\n          return Promise.delay(200)\n        }).visit('/foo')\n      })\n    })\n\n    context('correctly determines the content-length of an intercepted request', function () {\n      it('when body is empty', function (done) {\n        cy.intercept('/post-only', function (req) {\n          expect(req.headers['content-length']).to.eq('0')\n\n          done()\n        }).intercept('/post-only', function (req) {\n          req.body = ''\n        })\n        .then(() => {\n          $.post('/post-only', 'foo')\n        })\n      })\n\n      it('when body contains ascii', function (done) {\n        cy.intercept('/post-only', function (req) {\n          expect(req.headers['content-length']).to.eq('18')\n\n          done()\n        }).intercept('/post-only', function (req) {\n          req.body = 'this is only ascii'\n        })\n        .then(() => {\n          $.post('/post-only', 'bar')\n        })\n      })\n\n      it('when body contains unicode', function (done) {\n        cy.intercept('/post-only', function (req) {\n          expect(req.headers['content-length']).to.eq('8')\n\n          done()\n        }).intercept('/post-only', function (req) {\n          req.body = '🙃🤔'\n        })\n        .then(() => {\n          $.post('/post-only', 'baz')\n        })\n      })\n    })\n  })\n\n  context('intercepting response', function () {\n    it('receives the original response in handler', function (done) {\n      cy.intercept('/json-content-type*', function (req) {\n        req.reply(function (res) {\n          expect(res.body).to.deep.eq({})\n\n          done()\n        })\n\n        expect(req.url).to.match(/^http:\\/\\/localhost:3500\\/json-content-type/)\n      }).then(function () {\n        $.get('/json-content-type')\n      })\n    })\n\n    it('intercepts redirects as expected', function () {\n      const href = `/fixtures/generic.html?t=${Date.now()}`\n      const url = `/redirect?href=${encodeURIComponent(href)}`\n\n      cy.intercept('/redirect?href=*', (req) => {\n        req.reply((res) => {\n          expect(res.statusCode).to.eq(301)\n          expect(res.headers.location).to.eq(href)\n          res.send()\n        })\n      })\n      .as('redirect')\n      .intercept('/fixtures/generic.html?t=*').as('dest')\n      .then(() => fetch(url))\n      .wait('@redirect')\n      .wait('@dest')\n    })\n\n    it('can simply wait on redirects without intercepting', function () {\n      const href = `/fixtures/generic.html?t=${Date.now()}`\n      const url = `/redirect?href=${encodeURIComponent(href)}`\n\n      cy.intercept('/redirect*')\n      .as('redirect')\n      .intercept('/fixtures/generic.html*').as('dest')\n      .then(() => fetch(url))\n      .wait('@redirect')\n      .wait('@dest')\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/7967\n    it('can skip redirects via followRedirect', function () {\n      const href = `/fixtures/generic.html?t=${Date.now()}`\n      const url = `/redirect?href=${encodeURIComponent(href)}`\n\n      cy.intercept('/redirect', (req) => {\n        req.followRedirect = true\n        req.reply((res) => {\n          expect(res.body).to.include('Some generic content')\n          expect(res.statusCode).to.eq(200)\n          res.send()\n        })\n      })\n      .then(() => fetch(url))\n    })\n\n    it('intercepts cached responses as expected', {\n      browser: '!firefox', // TODO: why does firefox behave differently? transparently returns cached response\n    }, function () {\n      // use a queryparam to bust cache from previous runs of this test\n      const url = `/fixtures/generic.html?t=${Date.now()}`\n      let hits = 0\n\n      cy.intercept('/fixtures/generic.html*', (req) => {\n        req.reply((res) => {\n          // the second time the request is sent, headers should have been passed\n          // that result in Express serving a 304\n          // Cypress is not expected to understand cache mechanisms at this point -\n          // if the user wants to break caching, they can DIY by editing headers\n          const expectedStatusCode = [200, 304][hits]\n\n          expect(expectedStatusCode).to.exist\n          expect(res.statusCode).to.eq(expectedStatusCode)\n\n          hits++\n          res.send()\n        })\n      })\n      .as('foo')\n      .then(() => _.times(2, () => fetch(url)))\n      .wait('@foo')\n      .wait('@foo')\n      .then(() => {\n        expect(hits).to.eq(2)\n      })\n    })\n\n    it('can intercept a large proxy response', function (done) {\n      cy.intercept('/1mb', (req) => {\n        req.reply((res) => {\n          res.send()\n        })\n      }).then(() => {\n        $.get('/1mb').done((responseText) => {\n          // NOTE: the log from this when it fails is so long that it causes the browser to lock up :[\n          expect(responseText).to.eq('X'.repeat(1024 * 1024))\n\n          done()\n        })\n      })\n    })\n\n    it('can delay a proxy response using res.setDelay', function (done) {\n      cy.intercept('/timeout*', (req) => {\n        req.reply((res) => {\n          this.start = Date.now()\n\n          res.setDelay(1000).send('delay worked')\n        })\n      }).then(() => {\n        $.get('/timeout')\n        .done((responseText) => {\n          expect(Date.now() - this.start).to.be.closeTo(1100, 100)\n          expect(responseText).to.include('delay worked')\n\n          done()\n        })\n      })\n    })\n\n    it('can \\'delay\\' a proxy response using Promise.delay', function (done) {\n      cy.intercept('/timeout*', (req) => {\n        req.reply((res) => {\n          this.start = Date.now()\n\n          return Promise.delay(1000)\n          .then(() => {\n            res.send('Promise.delay worked')\n          })\n        })\n      }).then(() => {\n        $.get('/timeout').then((responseText) => {\n          expect(Date.now() - this.start).to.be.closeTo(1000, 100)\n          expect(responseText).to.eq('Promise.delay worked')\n\n          done()\n        })\n      })\n    })\n\n    it('can throttle a proxy response using res.setThrottle', function (done) {\n      cy.intercept('/1mb*', (req) => {\n        // don't let gzip make response smaller and throw off the timing\n        delete req.headers['accept-encoding']\n\n        req.reply((res) => {\n          this.start = Date.now()\n\n          res.setThrottle(1024).send()\n        })\n      }).then(() => {\n        $.get('/1mb').done((responseText) => {\n          // 1MB @ 1MB/s = ~1 second\n          expect(Date.now() - this.start).to.be.closeTo(1000, 250)\n          expect(responseText).to.eq('X'.repeat(1024 * 1024))\n\n          done()\n        })\n      })\n    })\n\n    it('can throttle a static response using res.setThrottle', function (done) {\n      const payload = 'A'.repeat(10 * 1024)\n      const kbps = 10\n      const expectedSeconds = payload.length / (1024 * kbps)\n\n      cy.intercept('/timeout*', (req) => {\n        req.reply((res) => {\n          this.start = Date.now()\n\n          res.setThrottle(kbps).send(payload)\n        })\n      }).then(() => {\n        $.get('/timeout').done((responseText) => {\n          expect(Date.now() - this.start).to.be.closeTo(expectedSeconds * 1000, 250)\n          expect(responseText).to.eq(payload)\n\n          done()\n        })\n      })\n    })\n\n    it('can delay and throttle a static response', function (done) {\n      const payload = 'A'.repeat(10 * 1024)\n      const kbps = 20\n      let expectedSeconds = payload.length / (1024 * kbps)\n      const delay = 500\n\n      expectedSeconds += delay / 1000\n\n      cy.intercept('/timeout*', (req) => {\n        req.reply((res) => {\n          this.start = Date.now()\n\n          res.setThrottle(kbps).setDelay(delay).send({\n            statusCode: 200,\n            body: payload,\n          })\n        })\n      }).then(() => {\n        $.get('/timeout').done((responseText) => {\n          expect(Date.now() - this.start).to.be.closeTo(expectedSeconds * 1000, 100)\n          expect(responseText).to.eq(payload)\n\n          done()\n        })\n      })\n    })\n\n    it('can reply with a JSON fixture', function () {\n      cy.intercept({\n        method: 'POST',\n        url: '/test-xhr',\n      }, (req) => {\n        req.url = '/timeout'\n        req.method = 'GET'\n        req.reply((res) => {\n          res.send({\n            headers: {\n              'content-type': 'application/json',\n            },\n            fixture: 'valid.json',\n          })\n        })\n      }).visit('/fixtures/xhr-triggered.html').get('#trigger-xhr').click()\n\n      cy.contains('{\"foo\":1,\"bar\":{\"baz\":\"cypress\"}}')\n    })\n\n    it('can delete a response header', function () {\n      cy\n      .then(() => {\n        const xhr = $.get('/json-content-type')\n\n        return xhr.then(() => {\n          return xhr.getAllResponseHeaders()\n        })\n      })\n      .should('include', 'content-type: application/json')\n      .intercept('/json-content-type*', function (req) {\n        req.reply((res) => {\n          delete res.headers['content-type']\n        })\n      }).as('get')\n      .then(() => {\n        const xhr = $.get('/json-content-type')\n\n        return xhr.then(() => {\n          return xhr.getAllResponseHeaders()\n        })\n      })\n      .should('not.include', 'content-type')\n      .wait('@get')\n    })\n\n    context('body parsing', function () {\n      [\n        'application/json',\n        'application/vnd.api+json',\n      ].forEach((contentType) => {\n        it(`automatically parses ${contentType} response bodies`, function () {\n          const p = Promise.defer()\n\n          cy.intercept(`/json-content-type*`, (req) => {\n            req.reply((res) => {\n              expect(res.headers['content-type']).to.eq(contentType)\n              expect(res.body).to.deep.eq({})\n              p.resolve()\n            })\n          }).as('get')\n          .then(() => {\n            return $.get(`/json-content-type?contentType=${encodeURIComponent(contentType)}`)\n          }).then((responseJson) => {\n            expect(responseJson).to.deep.eq({})\n\n            return p\n          })\n          .wait('@get').its('response.body').should('deep.eq', {})\n        })\n      })\n\n      it('doesn\\'t automatically parse JSON response bodies if content-type is wrong', function () {\n        const p = Promise.defer()\n\n        cy.intercept('/fixtures/json.txt*', (req) => {\n          req.reply((res) => {\n            expect(res.body).to.eq('{ \"foo\": \"bar\" }')\n            p.resolve()\n          })\n        }).as('get')\n        .then(() => {\n          return $.get('/fixtures/json.txt')\n        }).then((responseText) => {\n          expect(responseText).to.deep.eq('{ \"foo\": \"bar\" }')\n\n          return p\n        })\n        .wait('@get').its('response.body').should('deep.eq', '{ \"foo\": \"bar\" }')\n      })\n\n      it('sets body to string if JSON is malformed', function () {\n        const p = Promise.defer()\n\n        cy.intercept('/fixtures/invalid.json*', (req) => {\n          req.reply((res) => {\n            expect(res.headers['content-type']).to.match(/^application\\/json/)\n            expect(res.body).to.eq('{ foo:::: }')\n            p.resolve()\n          })\n        }).as('get')\n        .then(() => {\n          return $.get('/fixtures/invalid.json').catch(() => p)\n        })\n        .wait('@get').its('response.body').should('deep.eq', '{ foo:::: }')\n      })\n    })\n\n    context('with StaticResponse', function () {\n      it('res.send(body)', function () {\n        cy.intercept('/custom-headers*', function (req) {\n          req.reply((res) => {\n            res.send('baz')\n          })\n        })\n        .then(() => {\n          return $.get('/custom-headers')\n          .then((_a, _b, xhr) => {\n            expect(xhr.status).to.eq(200)\n            expect(xhr.responseText).to.eq('baz')\n            expect(xhr.getAllResponseHeaders())\n            .to.include('x-foo: bar')\n          })\n        })\n      })\n\n      it('res.send(json)', function () {\n        cy.intercept('/custom-headers*', function (req) {\n          req.reply((res) => {\n            res.send({ baz: 'quux' })\n          })\n        })\n        .then(() => {\n          return $.getJSON('/custom-headers')\n          .then((data, _b, xhr) => {\n            expect(xhr.status).to.eq(200)\n            expect(xhr.getAllResponseHeaders())\n            .to.include('x-foo: bar')\n            .and.include('content-type: application/json')\n\n            expect(data).to.deep.eq({ baz: 'quux' })\n          })\n        })\n      })\n\n      it('res.send(status)', function (done) {\n        cy.intercept('/custom-headers*', function (req) {\n          req.reply((res) => {\n            res.send(777)\n          })\n        })\n        .then(() => {\n          $.getJSON('/custom-headers')\n          .fail((xhr) => {\n            expect(xhr.status).to.eq(777)\n            expect(xhr.getAllResponseHeaders())\n            .to.include('x-foo: bar')\n\n            expect(xhr.responseText).to.include('hello there')\n\n            done()\n          })\n        })\n      })\n\n      it('res.send(status, body)', function (done) {\n        cy.intercept('/custom-headers*', function (req) {\n          req.reply((res) => {\n            res.send(777, 'bar')\n          })\n        })\n        .then(() => {\n          $.get('/custom-headers')\n          .fail((xhr) => {\n            expect(xhr.status).to.eq(777)\n            expect(xhr.responseText).to.eq('bar')\n            expect(xhr.getAllResponseHeaders())\n            .to.include('x-foo: bar')\n\n            done()\n          })\n        })\n      })\n\n      it('res.send(status, json)', function (done) {\n        cy.intercept('/custom-headers*', function (req) {\n          req.reply((res) => {\n            res.send(777, { bar: 'baz' })\n          })\n        })\n        .then(() => {\n          $.getJSON('/custom-headers')\n          .fail((xhr) => {\n            expect(xhr.status).to.eq(777)\n            expect(xhr.responseJSON).to.deep.eq({ bar: 'baz' })\n            expect(xhr.getAllResponseHeaders())\n            .to.include('x-foo: bar')\n            .and.include('content-type: application/json')\n\n            done()\n          })\n        })\n      })\n\n      it('res.send(status, json, headers)', function (done) {\n        cy.intercept('/custom-headers*', function (req) {\n          req.reply((res) => {\n            res.send(777, { bar: 'baz' }, { 'x-quux': 'quuz' })\n          })\n        })\n        .then(() => {\n          $.getJSON('/custom-headers')\n          .fail((xhr) => {\n            expect(xhr.status).to.eq(777)\n            expect(xhr.responseJSON).to.deep.eq({ bar: 'baz' })\n            expect(xhr.getAllResponseHeaders())\n            .to.include('x-foo: bar') // headers should be merged\n            .and.include('x-quux: quuz')\n            .and.include('content-type: application/json')\n\n            done()\n          })\n        })\n      })\n\n      it('res.send({ fixture })', function () {\n        cy.intercept('/foo*', function (req) {\n          req.reply((res) => {\n            res.send({\n              statusCode: 200,\n              fixture: 'valid.json',\n            })\n          })\n        })\n        .then(() => {\n          return $.getJSON('/foo')\n        })\n        .should('include', { foo: 1 })\n      })\n\n      it('can forceNetworkError', function (done) {\n        cy.intercept('/foo*', function (req) {\n          req.reply((res) => {\n            res.send({ forceNetworkError: true })\n          })\n        })\n        .then(() => {\n          $.get('/foo').fail((xhr) => {\n            expect(xhr).to.include({\n              status: 0,\n              statusText: 'error',\n              readyState: 0,\n            })\n\n            done()\n          })\n        })\n      })\n\n      it('can delay and throttle', function (done) {\n        const payload = 'A'.repeat(10 * 1024)\n        const throttleKbps = 50\n        const delay = 50\n        const expectedSeconds = payload.length / (1024 * throttleKbps) + delay / 1000\n\n        cy.intercept('/timeout*', (req) => {\n          req.reply((res) => {\n            this.start = Date.now()\n\n            // ensure .throttle and .delay are overridden\n            res.setThrottle(1e6).setDelay(1).send({\n              statusCode: 200,\n              body: payload,\n              throttleKbps,\n              delay,\n            })\n          })\n        }).then(() => {\n          return $.get('/timeout').then((responseText) => {\n            expect(Date.now() - this.start).to.be.closeTo(expectedSeconds * 1000 + 475, 500)\n            expect(responseText).to.eq(payload)\n\n            done()\n          })\n        })\n      })\n    })\n\n    context('response handler chaining', function () {\n      it('passes response through in reverse order', function () {\n        cy.intercept('/dump-method', function (req) {\n          req.reply((res) => {\n            expect(res.body).to.contain('new body')\n          })\n        }).intercept('/dump-method', function (req) {\n          req.reply((res) => {\n            expect(res.body).to.contain('GET')\n            res.body = 'new body'\n          })\n        }).visit('/dump-method')\n        .contains('new body')\n      })\n\n      it('stops passing response through once res.send called', function () {\n        cy.intercept('/dump-method', function (req) {\n          req.reply((res) => {\n            throw new Error('this should not have been reached')\n          })\n        }).intercept('/dump-method', function (req) {\n          req.reply((res) => {\n            res.send()\n          })\n        }).visit('/dump-method').contains('GET')\n      })\n    })\n\n    context('errors', function () {\n      it('fails test if res.send is called twice in req handler', function (done) {\n        testFail((err) => {\n          expect(err.message).to.contain('`res.send()` was called multiple times in a response handler, but the response can only be sent once.')\n          done()\n        })\n\n        cy.intercept('/dump-method', function (req) {\n          req.reply(function (res) {\n            res.send()\n\n            res.send()\n          })\n        }).visit('/dump-method')\n      })\n\n      it('fails test if an exception is thrown in res handler', function (done) {\n        cy.on('fail', (err2) => {\n          expect(err2).to.eq(err)\n          done()\n        })\n\n        const err = new Error('bar')\n\n        cy.intercept('/foo*', (req) => {\n          req.reply(() => {\n            throw err\n          })\n        })\n        .then(() => {\n          $.get('/foo')\n        })\n        .wait(1000)\n      })\n\n      it('fails test if res.send is called with an invalid StaticResponse', function (done) {\n        testFail((err) => {\n          expect(err.message).to.include('must be a number between 100 and 999 (inclusive).')\n\n          done()\n        })\n\n        cy.intercept('/foo*', (req) => {\n          req.reply((res) => {\n            res.send({ statusCode: 1 })\n          })\n        })\n        .then(() => {\n          $.get('/foo')\n        })\n      })\n\n      it('fails test if network error occurs retrieving response and response is intercepted', function (done) {\n        testFail((err) => {\n          expect(err.message)\n          .to.contain('A callback was provided to intercept the upstream response, but a network error occurred while making the request:')\n          .and.contain('Error: connect ECONNREFUSED 127.0.0.1:3333')\n\n          done()\n        })\n\n        cy.intercept('/should-err*', function (req) {\n          req.reply(() => {})\n        }).then(function () {\n          $.get('http://localhost:3333/should-err')\n        })\n      })\n\n      it('doesn\\'t fail test if network error occurs retrieving response and response is not intercepted', {\n        // TODO: for some reason, this test is busted in FF\n        browser: '!firefox',\n      }, function () {\n        cy.intercept('/should-err*', function (req) {\n          req.reply()\n        })\n        .as('err')\n        .then(function () {\n          return new Promise((resolve) => {\n            $.get('http://localhost:3333/should-err')\n            .fail((xhr) => {\n              expect(xhr).to.include({\n                status: 0,\n                statusText: 'error',\n              })\n\n              resolve()\n            })\n          })\n        })\n        .wait('@err', { timeout: 50 })\n      })\n\n      it('can timeout in req.reply handler', function (done) {\n        testFail((err) => {\n          Cypress.config('defaultCommandTimeout', 5000)\n          expect(err.message).to.match(/^A response handler timed out after returning a Promise that took more than the `defaultCommandTimeout` of `50ms` to resolve\\./)\n\n          done()\n        })\n\n        cy.intercept('/timeout', (req) => {\n          Cypress.config('defaultCommandTimeout', 50)\n\n          req.reply(() => {\n            return Promise.delay(200)\n          })\n        })\n        .visit('/timeout')\n      })\n\n      it('can timeout when retrieving upstream response', {\n        responseTimeout: 25,\n      }, function (done) {\n        cy.once('fail', (err) => {\n          expect(err.message).to.match(/^A callback was provided to intercept the upstream response, but the request timed out after the `responseTimeout` of `25ms`\\./)\n          .and.match(/ESOCKETTIMEDOUT|ETIMEDOUT/)\n\n          done()\n        })\n\n        cy.intercept('/timeout*', (req) => {\n          req.reply(_.noop)\n        }).then(() => {\n          $.get('/timeout?ms=50')\n        })\n      })\n    })\n  })\n\n  context('waiting and aliasing', function () {\n    const testFailWaiting = (cb) => testFail(cb, 'https://on.cypress.io/wait')\n\n    it('can wait on a single response using \"alias\"', function () {\n      cy.intercept('/foo*', 'bar')\n      .as('foo.bar')\n      .then(() => {\n        $.get('/foo')\n      })\n      .wait('@foo.bar')\n    })\n\n    it('can timeout waiting on a single response using \"alias\"', function (done) {\n      testFailWaiting((err) => {\n        expect(err.message).to.contain('No response ever occurred.')\n        done()\n      })\n\n      cy.intercept('/foo*', () => new Promise(_.noop))\n      .as('foo.bar')\n      .then(() => {\n        $.get('/foo')\n      })\n      .wait('@foo.bar', { timeout: 100 })\n    })\n\n    it('can wait on a single response using \"alias.response\"', function () {\n      cy.intercept('/foo*', 'bar')\n      .as('foo.bar')\n      .then(() => {\n        $.get('/foo')\n      })\n      .wait('@foo.bar.response')\n    })\n\n    it('can timeout waiting on a single response using \"alias.response\"', function (done) {\n      testFailWaiting((err) => {\n        expect(err.message).to.contain('No response ever occurred.')\n        done()\n      })\n\n      cy.intercept('/foo*', () => new Promise(_.noop))\n      .as('foo.bar')\n      .then(() => {\n        $.get('/foo')\n      })\n      .wait('@foo.bar.response', { timeout: 100 })\n    })\n\n    it('can wait on a single request using \"alias.request\"', function () {\n      cy.intercept('/foo*')\n      .as('foo.bar')\n      .then(() => {\n        $.get('/foo')\n      })\n      .wait('@foo.bar.request')\n    })\n\n    it('can timeout waiting on a single request using \"alias.request\"', function (done) {\n      testFailWaiting((err) => {\n        expect(err.message).to.contain('No request ever occurred.')\n        done()\n      })\n\n      cy.intercept('/foo*')\n      .as('foo.bar')\n      .wait('@foo.bar.request', { timeout: 100 })\n    })\n\n    it('can incrementally wait on responses', function () {\n      cy.intercept('/foo*', 'bar')\n      .as('foo.bar')\n      .then(() => {\n        $.get('/foo')\n      })\n      .wait('@foo.bar')\n      .then(() => {\n        $.get('/foo')\n      })\n      .wait('@foo.bar')\n    })\n\n    it('can timeout incrementally waiting on responses', function (done) {\n      testFailWaiting((err) => {\n        expect(err.message).to.contain('for the 1st response to the route')\n        done()\n      })\n\n      cy.intercept('/foo*', () => new Promise(_.noop))\n      .as('foo.bar')\n      .then(() => {\n        $.get('/foo')\n        $.get('/foo')\n      })\n      .wait('@foo.bar', { timeout: 100 })\n      .wait('@foo.bar', { timeout: 100 })\n    })\n\n    it('can incrementally wait on requests', function () {\n      cy.intercept('/foo*', (req) => {\n        req.reply(_.noop) // only request will be received, no response\n      })\n      .as('foo.bar')\n      .then(() => {\n        $.get('/foo')\n      })\n      .wait('@foo.bar.request')\n      .then(() => {\n        $.get('/foo')\n      })\n      .wait('@foo.bar.request')\n    })\n\n    it('can timeout incrementally waiting on requests', function (done) {\n      testFailWaiting((err) => {\n        expect(err.message).to.contain('for the 2nd request to the route')\n        done()\n      })\n\n      cy.intercept('/foo*', (req) => {\n        req.reply(_.noop) // only request will be received, no response\n      })\n      .as('foo.bar')\n      .then(() => {\n        $.get('/foo')\n      })\n      .wait('@foo.bar.request')\n      .wait('@foo.bar.request', { timeout: 100 })\n    })\n\n    it('can alias a route without stubbing it', function () {\n      cy.intercept(/fixtures\\/app/).as('getFoo').then(function () {\n        $.get('/fixtures/app.json')\n      }).wait('@getFoo').then(function (res) {\n        const log = cy.queue.logs({\n          displayName: 'req',\n        })[0]\n\n        expect(log.get('alias')).to.eq('getFoo')\n\n        expect(res.response!.body).to.deep.eq({\n          some: 'json',\n          foo: {\n            bar: 'baz',\n          },\n        })\n      })\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/8999\n    it('can spy on a 204 no body response', function () {\n      cy.intercept('/status-code*').as('status')\n      .then(() => {\n        $.get('/status-code?code=204')\n      })\n      .wait('@status').its('response.statusCode').should('eq', 204)\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/8934\n    it('can spy on a 304 not modified image response', function () {\n      const url = `/fixtures/media/cypress.png?i=${Date.now()}`\n\n      cy.intercept(url).as('image')\n      .then(() => {\n        $.get({ url, cache: true })\n      })\n      .then(() => {\n        if (Cypress.isBrowser('firefox')) {\n          // strangely, Firefox requires some time to be waited before the first image response will be cached\n          cy.wait(1000)\n        }\n      })\n      .then(() => {\n        $.get({ url, cache: true })\n      })\n      .wait('@image').its('response.statusCode').should('eq', 200)\n      .wait('@image').its('response.statusCode').should('eq', 304)\n    })\n\n    // https://github.com/cypress-io/cypress/issues/14522\n    it('different aliases are used for the same url', () => {\n      cy.intercept('/status-code*').as('status')\n      .then(() => {\n        $.get('/status-code?code=204')\n      })\n      .wait('@status').its('response.statusCode').should('eq', 204)\n\n      cy.intercept('/status-code*').as('status2')\n      .then(() => {\n        $.get('/status-code?code=301')\n      })\n      .wait('@status').its('response.statusCode').should('eq', 301)\n      .wait('@status2').its('response.statusCode').should('eq', 301)\n    })\n\n    // https://github.com/cypress-io/cypress/issues/9549\n    it('should handle aborted requests', () => {\n      cy.intercept('https://jsonplaceholder.cypress.io/todos/1').as('xhr')\n      cy.visit('fixtures/xhr-abort.html')\n      cy.get('#btn').click()\n      cy.get('pre').contains('delectus') // response body renders to page\n      cy.wait('@xhr')\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/9062\n    it('can spy on a request using forceNetworkError', function () {\n      cy.intercept('/foo*', { forceNetworkError: true })\n      .as('err')\n      .then(() => {\n        $.get('/foo')\n      })\n      .wait('@err').should('have.property', 'error')\n      .and('include', {\n        message: 'forceNetworkError called',\n        name: 'Error',\n      })\n      .get('@err').should('not.have.property', 'response')\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/15823\n    it('can override an alias using .as', function () {\n      cy.intercept('/users*').as('getUsers')\n      cy.intercept('/users*', { body: { data: 'fake data' }, statusCode: 200 }).as('getUsers')\n      .then(() => {\n        $.get('/users')\n      })\n      .wait('@getUsers')\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/16451\n    it('yields the expected interception when two requests are raced', function () {\n      cy.intercept('/foo*', { times: 1 }, { delay: 100, body: 'bar' }).as('a')\n      cy.intercept('/foo*', { times: 1 }, 'foo').as('a')\n      cy.then(() => {\n        $.get('/foo')\n        $.get('/foo')\n      })\n      .wait('@a').its('response.body').should('eq', 'foo')\n      .wait('@a').its('response.body').should('eq', 'bar')\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/9306\n    context('cy.get(alias)', function () {\n      it('gets the latest Interception by alias', function () {\n        cy.intercept('/foo*', { bar: 'baz' }).as('alias')\n        .then(() => {\n          $.get('/foo')\n          $.get('/foo')\n        })\n        .wait('@alias').wait('@alias').then((interception) => {\n          cy.get('@alias').then((interception2) => {\n            expect(interception).to.not.be.null\n            expect(interception).to.eq(interception2)\n          })\n        })\n      })\n\n      it('gets all aliased Interceptions by alias.all', function () {\n        cy.intercept('/foo*', { bar: 'baz' }).as('alias')\n        .then(() => {\n          $.get('/foo')\n          $.get('/foo')\n        })\n        .wait('@alias').wait('@alias')\n\n        cy.get('@alias.all').then((interceptions) => {\n          expect(interceptions).to.have.length(2)\n        })\n      })\n\n      it('gets indexed Interception by alias.number', function () {\n        let interception\n\n        cy.intercept('/foo*', { bar: 'baz' }).as('alias')\n        .then(() => {\n          $.get('/foo')\n          $.get('/foo')\n        })\n        .wait('@alias').then((_interception) => {\n          interception = _interception\n        }).wait('@alias')\n\n        cy.get('@alias.0').then((interception2) => {\n          expect(interception).to.not.be.null\n          expect(interception).to.eq(interception2)\n        })\n      })\n\n      it('gets per-request aliased Interceptions', function () {\n        cy.intercept('/foo*', (req) => {\n          req.alias = 'alias'\n          req.reply({ bar: 'baz' })\n        })\n        .then(() => {\n          $.get('/foo')\n        })\n        .wait('@alias').then((interception) => {\n          cy.get('@alias').then((interception2) => {\n            expect(interception).to.not.be.null\n            expect(interception).to.eq(interception2)\n          })\n        })\n      })\n\n      it('yields null when no requests have been made', function () {\n        cy.intercept('/foo').as('foo')\n        cy.get('@foo').should('be.null')\n      })\n    })\n\n    context('with an intercepted request', function () {\n      it('can dynamically alias the request', function () {\n        cy.intercept('/foo*', (req) => {\n          req.alias = 'fromInterceptor'\n        })\n        .then(() => {\n          $.get('/foo')\n        })\n        .wait('@fromInterceptor')\n      })\n\n      it('can time out on a dynamic alias', function (done) {\n        testFailWaiting((err) => {\n          expect(err.message).to.contain('for the 1st request to the route')\n          done()\n        })\n\n        cy.intercept('/foo', (req) => {\n          req.alias = 'fromInterceptor'\n        })\n        .wait('@fromInterceptor', { timeout: 100 })\n      })\n\n      it('dynamic aliases are fulfilled before route aliases', function (done) {\n        testFailWaiting((err) => {\n          expect(err.message).to.contain('for the 1st request to the route: `fromAs`')\n          done()\n        })\n\n        cy.intercept('/foo*', (req) => {\n          req.alias = 'fromInterceptor'\n        })\n        .as('fromAs')\n        .then(() => {\n          $.get('/foo')\n        })\n        .wait('@fromInterceptor')\n        // this will fail - dynamic aliasing maintains the existing wait semantics, including that each request can only be waited once\n        .wait('@fromAs', { timeout: 100 })\n      })\n\n      it('fulfills both dynamic aliases when two are defined', function () {\n        cy.intercept('/foo*', (req) => {\n          req.alias = 'fromInterceptor'\n        })\n        .intercept('/foo*', (req) => {\n          expect(req.alias).to.be.undefined\n          req.alias = 'fromInterceptor2'\n        })\n        .then(() => {\n          $.get('/foo')\n        })\n        .wait('@fromInterceptor')\n        .wait('@fromInterceptor2')\n      })\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/8695\n    context('yields request', function () {\n      it('when not intercepted', function () {\n        cy.intercept('/post-only').as('foo')\n        .then(() => {\n          $.post('/post-only', 'some body')\n        }).wait('@foo').its('request.body').should('eq', 'some body')\n      })\n\n      it('when intercepted', function () {\n        cy.intercept('/post-only', (req) => {\n          req.body = 'changed'\n        }).as('foo')\n        .then(() => {\n          $.post('/post-only', 'some body')\n        }).wait('@foo').its('request.body').should('eq', 'changed')\n      })\n\n      it('when static response body is provided', function () {\n        cy.intercept('/post-only', { static: 'response' }).as('foo')\n        .then(() => {\n          $.post('/post-only', 'some body')\n        }).wait('@foo').its('request.body').should('eq', 'some body')\n      })\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/8536\n    context('yields response', function () {\n      const testResponse = (expectedBody, done) => {\n        return () => {\n          $.get('/xml')\n\n          cy.wait('@foo').then((request) => {\n            expect(request.response!.body).to.eq(expectedBody)\n            done()\n          })\n        }\n      }\n\n      it('when not stubbed', function (done) {\n        cy.intercept('/xml*').as('foo')\n        .then(testResponse('<foo>bar</foo>', done))\n      })\n\n      it('when stubbed with StaticResponse', function (done) {\n        cy.intercept('/xml*', 'something different')\n        .as('foo')\n        .then(testResponse('something different', done))\n      })\n\n      it('when stubbed with req.reply', function (done) {\n        cy.intercept('/xml*', (req) => req.reply('something different'))\n        .as('foo')\n        .then(testResponse('something different', done))\n      })\n\n      it('when stubbed with res.send', function (done) {\n        cy.intercept('/xml*', (req) => req.reply((res) => res.send('something different')))\n        .as('foo')\n        .then(testResponse('something different', done))\n      })\n\n      context('when stubbed with fixture', function () {\n        it('with cy.intercept', function (done) {\n          cy.intercept('/xml*', { fixture: 'null.json' })\n          .as('foo')\n          .then(testResponse('', done))\n        })\n\n        it('with req.reply', function (done) {\n          cy.intercept('/xml*', (req) => req.reply({ fixture: 'null.json' }))\n          .as('foo')\n          .then(testResponse('', done))\n        })\n\n        it('with res.send', function (done) {\n          cy.intercept('/xml*', (req) => {\n            return req.continue((res) => {\n              return res.send({\n                fixture: 'null.json',\n                headers: {\n                  // since `res.headers['content-type'] is already 'application/xml' from origin,\n                  // we must explicitly set the content-type to JSON here.\n                  // luckily changing content-type like this is not a typical use case\n                  'content-type': 'application/json',\n                },\n              })\n            })\n          })\n          .as('foo')\n          .then(testResponse('', done))\n        })\n      })\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/9580\n    context('overwrite cy.intercept', () => {\n      it('works with an alias by default', () => {\n        // sanity test before testing it with the cy.intercept overwrite\n        cy.intercept('/foo*', 'my value').as('netAlias')\n        .then(() => {\n          return $.get('/foo')\n        })\n\n        cy.wait('@netAlias').its('response.body').should('equal', 'my value')\n      })\n\n      it('works with an alias and function', () => {\n        let myInterceptCalled\n\n        cy.spy(cy, 'log')\n\n        Cypress.Commands.overwrite('intercept', function (originalIntercept, ...args) {\n          return cy.log('intercept!').then(() => {\n            myInterceptCalled = true\n\n            return originalIntercept(...args)\n          })\n        })\n\n        cy.intercept('/foo*', 'my value').as('netAlias')\n        .then(() => {\n          return $.get('/foo')\n        })\n        .then(() => {\n          expect(myInterceptCalled, 'my intercept was called').to.be.true\n          expect(cy.log).to.have.been.calledWith('intercept!')\n        })\n\n        cy.wait('@netAlias').its('response.body').should('equal', 'my value')\n      })\n\n      it('works with an alias and arrow function', () => {\n        let myInterceptCalled\n\n        cy.spy(cy, 'log')\n\n        Cypress.Commands.overwrite('intercept', (originalIntercept, ...args) => {\n          return cy.log('intercept!').then(() => {\n            myInterceptCalled = true\n\n            return originalIntercept(...args)\n          })\n        })\n\n        cy.intercept('/foo*', 'my value').as('netAlias')\n        .then(() => {\n          return $.get('/foo')\n        })\n        .then(() => {\n          expect(myInterceptCalled, 'my intercept was called').to.be.true\n          expect(cy.log).to.have.been.calledWith('intercept!')\n        })\n\n        cy.wait('@netAlias').its('response.body').should('equal', 'my value')\n      })\n\n      it('works with dynamic alias', () => {\n        let myInterceptCalled\n\n        cy.spy(cy, 'log')\n\n        Cypress.Commands.overwrite('intercept', (originalIntercept, ...args) => {\n          return cy.log('intercept!').then(() => {\n            myInterceptCalled = true\n\n            return originalIntercept(...args)\n          })\n        })\n\n        cy.intercept('/foo*', (req) => {\n          req.alias = 'netAlias'\n          req.reply('my value')\n        })\n        .then(() => {\n          return $.get('/foo')\n        })\n        .then(() => {\n          expect(myInterceptCalled, 'my intercept was called').to.be.true\n          expect(cy.log).to.have.been.calledWith('intercept!')\n        })\n\n        cy.wait('@netAlias').its('response.body').should('equal', 'my value')\n      })\n\n      // https://github.com/cypress-io/cypress/issues/14444\n      it('can use dot in request alias', () => {\n        cy.intercept('/users', (req) => {\n          req.alias = 'get.url'\n          req.reply('foo')\n        })\n\n        cy.window().then((win) => {\n          const xhr = new win.XMLHttpRequest()\n\n          xhr.open('GET', '/users')\n          xhr.send()\n        })\n\n        cy.wait('@get.url')\n      })\n    })\n  })\n\n  context('unit tests', function () {\n    context('#getDisplayUrlMatcher', function () {\n      function testDisplayUrl (title: string, expectedDisplayUrl: string, matcher: Partial<RouteMatcherOptions>) {\n        return it(title, function () {\n          expect(getDisplayUrlMatcher(matcher)).to.eq(expectedDisplayUrl)\n        })\n      }\n\n      testDisplayUrl('with only url', 'http://google.net', { url: 'http://google.net' })\n      testDisplayUrl('with url + method', 'http://google.net', { method: 'GET', url: 'http://google.net' })\n      testDisplayUrl('with regex url', '/foo/', { url: /foo/ })\n      testDisplayUrl('with only path', '/foo', { path: '/foo' })\n      testDisplayUrl('with only pathname', '/foo', { pathname: '/foo' })\n      testDisplayUrl('with host + port', '{hostname: foo.net, port: 1234}', { hostname: 'foo.net', port: 1234 })\n      testDisplayUrl('with url and query', '{url: http://something, query: {a: b}}', { url: 'http://something', query: { a: 'b' } })\n    })\n  })\n})\n",
    "packages/driver/cypress/integration/commands/xhr_spec.js": "const { stripIndent } = require('common-tags')\nconst { _, $, Promise } = Cypress\n\ndescribe('src/cy/commands/xhr', () => {\n  before(() => {\n    cy\n    .visit('/fixtures/jquery.html')\n    .then(function (win) {\n      const h = $(win.document.head)\n\n      h.find('script').remove()\n\n      this.head = h.prop('outerHTML')\n      this.body = win.document.body.outerHTML\n    })\n  })\n\n  beforeEach(function () {\n    const doc = cy.state('document')\n\n    $(doc.head).empty().html(this.head)\n    $(doc.body).empty().html(this.body)\n  })\n\n  context('#startXhrServer', () => {\n    it('continues to be a defined properties', () => {\n      cy\n      .server()\n      .route({ url: /foo/ }).as('getFoo')\n      .window().then((win) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.open('GET', '/foo')\n        expect(xhr.onload).to.be.a('function')\n        expect(xhr.onerror).to.be.a('function')\n        expect(xhr.onreadystatechange).to.be.a('function')\n      })\n    })\n\n    it('prevents infinite recursion', () => {\n      let onloaded = false\n      let onreadystatechanged = false\n\n      cy\n      .server()\n      .route({ url: /foo/ }).as('getFoo')\n      .window().then((win) => {\n        const handlers = ['onload', 'onerror', 'onreadystatechange']\n\n        const wrap = () => {\n          handlers.forEach((handler) => {\n            const bak = xhr[handler]\n\n            xhr[handler] = (...args) => {\n              if (_.isFunction(bak)) {\n                bak.apply(xhr, args)\n              }\n            }\n          })\n        }\n\n        const xhr = new win.XMLHttpRequest\n\n        xhr.addEventListener('readystatechange', wrap, false)\n        xhr.onreadystatechange = function () {\n          throw new Error('NOOO')\n        }\n\n        xhr.onreadystatechange\n        xhr.onreadystatechange = () => {\n          onreadystatechanged = true\n        }\n\n        xhr.open('GET', '/foo')\n        xhr.onload = function () {\n          throw new Error('NOOO')\n        }\n\n        xhr.onload\n        xhr.onload = () => {\n          onloaded = true\n        }\n\n        xhr.send()\n\n        return null\n      })\n      .wait('@getFoo').then((xhr) => {\n        expect(onloaded).to.be.true\n        expect(onreadystatechanged).to.be.true\n\n        expect(xhr.status).to.eq(404)\n      })\n    })\n\n    // NOTE: flaky about 50% of the time in Firefox...\n    // temporarily skipping for now, but this needs\n    // to be reenabled after launch once we have time\n    // to look at the underlying failure cause\n    it.skip('allows multiple readystatechange calls', () => {\n      let responseStatuses = 0\n\n      cy\n      .server()\n      .route({ url: /longtext.txt/ }).as('getLongText')\n      .task('create:long:file')\n      .window().then((win) => {\n        const xhr = new win.XMLHttpRequest()\n\n        xhr.onreadystatechange = function () {\n          if (xhr.readyState === 3) {\n            return responseStatuses++\n          }\n        }\n\n        xhr.open('GET', `/_test-output/longtext.txt?${Cypress._.random(0, 1e6)}`)\n        xhr.send()\n\n        return null\n      })\n      .wait('@getLongText').then((xhr) => {\n        expect(responseStatuses).to.be.gt(1)\n\n        expect(xhr.status).to.eq(200)\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/5864\n    it('does not exceed max call stack', () => {\n      cy\n      .server()\n      .route({ url: /foo/ }).as('getFoo')\n      .window().then((win) => {\n        const xhr = new win.XMLHttpRequest()\n\n        xhr.open('GET', '/foo')\n\n        // This tests an old bug where calling onreadystatechange's getter would\n        // create nested wrapper functions and exceed the max stack depth when called.\n        // 20000 nested calls should be enough to break the stack in most implementations\n        xhr.onreadystatechange = () => {\n          return {}\n        }\n\n        for (let i = 0; i < 20000; i++) {\n          xhr.onreadystatechange()\n        }\n\n        xhr.send()\n\n        return null\n      })\n      .wait('@getFoo').then((xhr) => {\n        expect(xhr.status).to.eq(404)\n      })\n    })\n\n    it('works with jquery too', () => {\n      let failed = false\n      let onloaded = false\n\n      cy\n      .server()\n      .route({ url: /foo/ }).as('getFoo')\n      .window().then((win) => {\n        const handlers = ['onload', 'onerror', 'onreadystatechange']\n\n        const wrap = function () {\n          const xhr = this\n\n          handlers.forEach((handler) => {\n            const bak = xhr[handler]\n\n            xhr[handler] = (...args) => {\n              if (_.isFunction(bak)) {\n                bak.apply(xhr, args)\n              }\n            }\n          })\n        }\n\n        const { open } = win.XMLHttpRequest.prototype\n\n        win.XMLHttpRequest.prototype.open = function (...args) {\n          this.addEventListener('readystatechange', wrap, false)\n\n          open.apply(this, args)\n        }\n\n        win.$.get('/foo')\n        .fail(() => {\n          failed = true\n        })\n        .always(() => {\n          onloaded = true\n        })\n\n        return null\n      })\n      .wait('@getFoo').then((xhr) => {\n        expect(failed).to.be.true\n        expect(onloaded).to.be.true\n        expect(xhr.status).to.eq(404)\n      })\n    })\n\n    it('calls existing onload handlers', () => {\n      let onloaded = false\n\n      cy\n      .server()\n      .route({ url: /foo/ }).as('getFoo')\n      .window().then((win) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.onload = () => {\n          onloaded = true\n        }\n\n        xhr.open('GET', '/foo')\n        xhr.send()\n\n        return null\n      })\n      .wait('@getFoo').then((xhr) => {\n        expect(onloaded).to.be.true\n        expect(xhr.status).to.eq(404)\n      })\n    })\n\n    it('calls onload handlers attached after xhr#send', () => {\n      let onloaded = false\n\n      cy\n      .server()\n      .route({ url: /foo/ }).as('getFoo')\n      .window().then((win) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.open('GET', '/foo')\n        xhr.send()\n        xhr.onload = () => {\n          return onloaded = true\n        }\n\n        return null\n      })\n      .wait('@getFoo').then((xhr) => {\n        expect(onloaded).to.be.true\n        expect(xhr.status).to.eq(404)\n      })\n    })\n\n    it('calls onload handlers attached after xhr#send asynchronously', () => {\n      let onloaded = false\n\n      cy\n      .server()\n      .route({ url: /timeout/ }).as('getTimeout')\n      .window().then((win) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.open('GET', '/timeout?ms=100')\n        xhr.send()\n        _.delay(() => {\n          xhr.onload = () => {\n            onloaded = true\n          }\n        }, 20)\n\n        return null\n      })\n      .wait('@getTimeout').then((xhr) => {\n        expect(onloaded).to.be.true\n        expect(xhr.status).to.eq(200)\n      })\n    })\n\n    it('fallbacks even when onreadystatechange is overriden', () => {\n      let onloaded = false\n      let onreadystatechanged = false\n\n      cy\n      .server()\n      .route({ url: /timeout/ }).as('get.timeout')\n      .window().then((win) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.open('GET', '/timeout?ms=100')\n        xhr.send()\n        xhr.onreadystatechange = () => {\n          onreadystatechanged = true\n        }\n\n        xhr.onload = () => {\n          onloaded = true\n        }\n\n        return null\n      })\n      .wait('@get.timeout').then((xhr) => {\n        expect(onloaded).to.be.true\n        expect(onreadystatechanged).to.be.true\n        expect(xhr.status).to.eq(200)\n      })\n    })\n\n    describe('url rewriting', () => {\n      it('has a FQDN absolute-relative url', () => {\n        cy\n        .server()\n        .route({\n          url: /foo/,\n        }).as('getFoo')\n        .window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('/foo')\n\n          return null\n        }).wait('@getFoo').then(function (xhr) {\n          expect(xhr.url).to.eq('http://localhost:3500/foo')\n          expect(this.open).to.be.calledWith('GET', '/foo')\n        })\n      })\n\n      it('has a relative URL', () => {\n        cy\n        .server()\n        .route(/foo/).as('getFoo')\n        .window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('foo')\n\n          return null\n        }).wait('@getFoo').then(function (xhr) {\n          expect(xhr.url).to.eq('http://localhost:3500/fixtures/foo')\n          expect(this.open).to.be.calledWith('GET', 'foo')\n        })\n      })\n\n      it('resolves relative urls correctly when base tag is present', () => {\n        cy\n        .server()\n        .route({\n          url: /foo/,\n        }).as('getFoo')\n        .window().then(function (win) {\n          win.$('<base href=\\'/\\'>').appendTo(win.$('head'))\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('foo')\n\n          return null\n        }).wait('@getFoo').then(function (xhr) {\n          expect(xhr.url).to.eq('http://localhost:3500/foo')\n          expect(this.open).to.be.calledWith('GET', 'foo')\n        })\n      })\n\n      it('resolves relative urls correctly when base tag is present on nested routes', () => {\n        cy\n        .server()\n        .route({\n          url: /foo/,\n        }).as('getFoo')\n        .window().then(function (win) {\n          win.$('<base href=\\'/nested/route/path\\'>').appendTo(win.$('head'))\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('../foo')\n\n          return null\n        }).wait('@getFoo').then(function (xhr) {\n          expect(xhr.url).to.eq('http://localhost:3500/nested/foo')\n          expect(this.open).to.be.calledWith('GET', '../foo')\n        })\n      })\n\n      it('allows cross origin requests to go out as necessary', () => {\n        cy\n        .server()\n        .route(/foo/).as('getFoo')\n        .window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('http://localhost:3501/foo')\n\n          return null\n        }).wait('@getFoo').then(function (xhr) {\n          expect(xhr.url).to.eq('http://localhost:3501/foo')\n          expect(this.open).to.be.calledWith('GET', 'http://localhost:3501/foo')\n        })\n      })\n\n      it('rewrites FQDN url\\'s for stubs', () => {\n        cy\n        .server()\n        .route({\n          url: /foo/,\n          response: {},\n        }).as('getFoo')\n        .window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('http://localhost:9999/foo')\n\n          return null\n        }).wait('@getFoo').then(function (xhr) {\n          expect(xhr.url).to.eq('http://localhost:9999/foo')\n          expect(this.open).to.be.calledWith('GET', '/__cypress/xhrs/http://localhost:9999/foo')\n        })\n      })\n\n      it('rewrites absolute url\\'s for stubs', () => {\n        cy\n        .server()\n        .route(/foo/, {}).as('getFoo')\n        .window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('/foo')\n\n          return null\n        }).wait('@getFoo').then(function (xhr) {\n          expect(xhr.url).to.eq('http://localhost:3500/foo')\n          expect(this.open).to.be.calledWith('GET', '/__cypress/xhrs/http://localhost:3500/foo')\n        })\n      })\n\n      it('rewrites 404\\'s url\\'s for stubs', () => {\n        cy\n        .server({ force404: true })\n        .window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n\n          return new Promise((resolve) => {\n            win.$.ajax({\n              method: 'POST',\n              url: '/foo',\n              data: JSON.stringify({ foo: 'bar' }),\n            }).fail(() => {\n              resolve()\n            })\n          })\n        })\n        .then(function () {\n          const { xhr } = cy.state('responses')[0]\n\n          expect(xhr.url).to.eq('http://localhost:3500/foo')\n          expect(this.open).to.be.calledWith('POST', '/__cypress/xhrs/http://localhost:3500/foo')\n        })\n      })\n\n      it('rewrites urls with nested segments', () => {\n        cy\n        .server()\n        .route({\n          url: /phones/,\n          response: {},\n        })\n        .as('getPhones')\n        .window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('phones/phones.json')\n\n          return null\n        })\n        .wait('@getPhones')\n        .then(function () {\n          const { xhr } = cy.state('responses')[0]\n\n          expect(xhr.url).to.eq('http://localhost:3500/fixtures/phones/phones.json')\n          expect(this.open).to.be.calledWith('GET', '/__cypress/xhrs/http://localhost:3500/fixtures/phones/phones.json')\n        })\n      })\n\n      it('does not rewrite CORS', () => {\n        cy.window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n\n          return new Promise((resolve) => {\n            win.$.get('http://www.google.com/phones/phones.json').fail(() => {\n              resolve()\n            })\n          })\n        })\n        .then(function () {\n          const { xhr } = cy.state('requests')[0]\n\n          expect(xhr.url).to.eq('http://www.google.com/phones/phones.json')\n          expect(this.open).to.be.calledWith('GET', 'http://www.google.com/phones/phones.json')\n        })\n      })\n\n      it('can stub real CORS requests too', () => {\n        cy\n        .server()\n        .route({\n          url: /phones/,\n          response: {},\n        })\n        .as('getPhones')\n        .window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('http://www.google.com/phones/phones.json')\n\n          return null\n        })\n        .wait('@getPhones')\n        .then(function () {\n          const { xhr } = cy.state('responses')[0]\n\n          expect(xhr.url).to.eq('http://www.google.com/phones/phones.json')\n          expect(this.open).to.be.calledWith('GET', '/__cypress/xhrs/http://www.google.com/phones/phones.json')\n        })\n      })\n\n      it('can stub CORS string routes', () => {\n        cy\n        .server()\n        .route('http://localhost:3501/fixtures/app.json').as('getPhones')\n        .window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('http://localhost:3501/fixtures/app.json')\n\n          return null\n        })\n        .wait('@getPhones')\n        .then(function () {\n          const { xhr } = cy.state('responses')[0]\n\n          expect(xhr.url).to.eq('http://localhost:3501/fixtures/app.json')\n          expect(this.open).to.be.calledWith('GET', 'http://localhost:3501/fixtures/app.json')\n        })\n      })\n\n      it('sets display correctly when there is no remoteOrigin', () => {\n        // this is an example of having cypress act as your webserver\n        // when the remoteHost is <root>\n        cy\n        .server()\n        .route({\n          url: /foo/,\n          response: {},\n        })\n        .as('getFoo')\n        .window().then(function (win) {\n          // trick cypress into thinking the remoteOrigin is location:9999\n          cy.stub(cy, 'getRemoteLocation').withArgs('origin').returns('')\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('/foo')\n\n          return null\n        })\n        .wait('@getFoo').then(function (xhr) {\n          expect(xhr.url).to.eq('http://localhost:3500/foo')\n          expect(this.open).to.be.calledWith('GET', '/__cypress/xhrs/http://localhost:3500/foo')\n        })\n      })\n\n      it('decodes proxy urls', () => {\n        cy\n        .server()\n        .route({\n          url: /users/,\n          response: {},\n        })\n        .as('getUsers')\n        .window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('/users?q=(id eq 123)')\n\n          return null\n        })\n        .wait('@getUsers')\n        .then(function () {\n          const { xhr } = cy.state('responses')[0]\n\n          expect(xhr.url).to.eq('http://localhost:3500/users?q=(id eq 123)')\n\n          const url = encodeURI('users?q=(id eq 123)')\n\n          expect(this.open).to.be.calledWith('GET', `/__cypress/xhrs/http://localhost:3500/${url}`)\n        })\n      })\n\n      it('decodes proxy urls #2', () => {\n        cy\n        .server()\n        .route(/accounts/, {}).as('getAccounts')\n        .window().then(function (win) {\n          this.open = cy.spy(cy.state('server').options, 'onOpen')\n          win.$.get('/accounts?page=1&%24filter=(rowStatus+eq+1)&%24orderby=name+asc&includeOpenFoldersCount=true&includeStatusCount=true')\n\n          return null\n        })\n        .wait('@getAccounts')\n        .then(function () {\n          const { xhr } = cy.state('responses')[0]\n\n          expect(xhr.url).to.eq('http://localhost:3500/accounts?page=1&$filter=(rowStatus+eq+1)&$orderby=name+asc&includeOpenFoldersCount=true&includeStatusCount=true')\n\n          const url = 'accounts?page=1&%24filter=(rowStatus+eq+1)&%24orderby=name+asc&includeOpenFoldersCount=true&includeStatusCount=true'\n\n          expect(this.open).to.be.calledWith('GET', `/__cypress/xhrs/http://localhost:3500/${url}`)\n        })\n      })\n    })\n\n    describe('#onResponse', () => {\n      it('calls onResponse callback with cy context + proxy xhr', (done) => {\n        cy\n        .server()\n        .route({\n          url: /foo/,\n          response: { foo: 'bar' },\n          onResponse (xhr) {\n            expect(this).to.eq(cy)\n            expect(xhr.responseBody).to.deep.eq({ foo: 'bar' })\n\n            done()\n          },\n        })\n        .window().then((win) => {\n          win.$.get('/foo')\n\n          return null\n        })\n      })\n    })\n\n    describe('#onAbort', () => {\n      it('calls onAbort callback with cy context + proxy xhr', (done) => {\n        cy\n        .server()\n        .route({\n          url: /foo/,\n          response: {},\n          onAbort (xhr) {\n            expect(this).to.eq(cy)\n            expect(xhr.aborted).to.be.true\n\n            done()\n          },\n        })\n        .window().then((win) => {\n          const xhr = new win.XMLHttpRequest\n\n          xhr.open('GET', '/foo')\n          xhr.send()\n          xhr.abort()\n\n          return null\n        })\n      })\n    })\n\n    describe('request parsing', () => {\n      it('adds parses requestBody into JSON', (done) => {\n        cy\n        .server()\n        .route({\n          method: 'POST',\n          url: /foo/,\n          response: {},\n          onRequest (xhr) {\n            expect(this).to.eq(cy)\n            expect(xhr.requestBody).to.deep.eq({ foo: 'bar' })\n\n            done()\n          },\n        })\n        .window().then((win) => {\n          win.$.ajax({\n            type: 'POST',\n            url: '/foo',\n            data: JSON.stringify({ foo: 'bar' }),\n            dataType: 'json',\n          })\n\n          return null\n        })\n      })\n\n      // https://github.com/cypress-io/cypress/issues/65\n      it('provides the correct requestBody on multiple requests', () => {\n        const post = function (win, obj) {\n          win.$.ajax({\n            type: 'POST',\n            url: '/foo',\n            data: JSON.stringify(obj),\n            dataType: 'json',\n          })\n\n          return null\n        }\n\n        cy\n        .server()\n        .route('POST', /foo/, {}).as('getFoo')\n        .window().then((win) => {\n          return post(win, { foo: 'bar1' })\n        })\n        .wait('@getFoo').its('requestBody').should('deep.eq', { foo: 'bar1' })\n        .window().then((win) => {\n          return post(win, { foo: 'bar2' })\n        })\n        .wait('@getFoo').its('requestBody').should('deep.eq', { foo: 'bar2' })\n      })\n\n      it('handles arraybuffer', () => {\n        cy\n        .server()\n        .route('GET', /arraybuffer/).as('getBuffer')\n        .window().then((win) => {\n          const xhr = new win.XMLHttpRequest\n\n          xhr.responseType = 'arraybuffer'\n          xhr.open('GET', '/arraybuffer')\n          xhr.send()\n\n          return null\n        })\n        .wait('@getBuffer').then((xhr) => {\n          expect(xhr.status).eq(200)\n          expect(xhr.responseBody.byteLength).gt(0)\n          expect(xhr.responseBody.toString()).to.eq('[object ArrayBuffer]')\n        })\n      })\n\n      it('handles xml', () => {\n        cy\n        .server()\n        .route('GET', /xml/).as('getXML')\n        .window().then((win) => {\n          const xhr = new win.XMLHttpRequest\n\n          xhr.open('GET', '/xml')\n          xhr.send()\n\n          return null\n        })\n        .wait('@getXML').its('responseBody').should('eq', '<foo>bar</foo>')\n      })\n    })\n\n    describe('issue #84', () => {\n      it('does not incorrectly match options', () => {\n        cy\n        .server()\n        .route({\n          method: 'GET',\n          url: /answers/,\n          status: 503,\n          response: {},\n        })\n        .route(/forms/, []).as('getForm')\n        .window().then((win) => {\n          win.$.getJSON('/forms')\n\n          return null\n        })\n        .wait('@getForm').its('status').should('eq', 200)\n      })\n    })\n\n    describe('#issue #85', () => {\n      it('correctly returns the right XHR alias', () => {\n        cy\n        .server()\n        .route({\n          method: 'POST',\n          url: /foo/,\n          response: {},\n        })\n        .as('getFoo')\n        .route(/folders/, { foo: 'bar' }).as('getFolders')\n        .window().then((win) => {\n          win.$.getJSON('/folders')\n          win.$.post('/foo', {})\n\n          return null\n        })\n        .wait('@getFolders')\n        .wait('@getFoo')\n        .route(/folders/, { foo: 'baz' }).as('getFoldersWithSearch')\n        .window().then((win) => {\n          win.$.getJSON('/folders/123/activities?foo=bar')\n\n          return null\n        })\n        .wait('@getFoldersWithSearch').its('url')\n        .should('contain', '?foo=bar')\n      })\n    })\n\n    describe('.log', () => {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          if (attrs.name === 'xhr') {\n            this.lastLog = log\n            this.logs.push(log)\n          }\n        })\n\n        return null\n      })\n\n      context('requests', () => {\n        it('immediately logs xhr obj', () => {\n          cy\n          .server()\n          .route(/foo/, {}).as('getFoo')\n          .window().then((win) => {\n            win.$.get('foo')\n\n            return null\n          }).then(function () {\n            const { lastLog } = this\n\n            expect(lastLog.pick('name', 'displayName', 'event', 'alias', 'aliasType', 'state')).to.deep.eq({\n              name: 'xhr',\n              displayName: 'xhr stub',\n              event: true,\n              alias: 'getFoo',\n              aliasType: 'route',\n              state: 'pending',\n            })\n\n            const snapshots = lastLog.get('snapshots')\n\n            expect(snapshots.length).to.eq(1)\n            expect(snapshots[0].name).to.eq('request')\n            expect(snapshots[0].body).to.be.an('object')\n          })\n        })\n\n        // https://github.com/cypress-io/cypress/issues/8018\n        it('logs empty string response as stubbed', () => {\n          cy\n          .server()\n          .route(/foo/, '').as('getFoo')\n          .window().then((win) => {\n            win.$.get('foo')\n\n            return null\n          }).then(function () {\n            const { lastLog } = this\n\n            expect(lastLog.pick('name', 'displayName', 'event', 'alias', 'aliasType', 'state')).to.deep.eq({\n              name: 'xhr',\n              displayName: 'xhr stub',\n              event: true,\n              alias: 'getFoo',\n              aliasType: 'route',\n              state: 'pending',\n            })\n\n            const snapshots = lastLog.get('snapshots')\n\n            expect(snapshots.length).to.eq(1)\n            expect(snapshots[0].name).to.eq('request')\n          })\n        })\n\n        it('does not end xhr requests when the associated command ends', () => {\n          let logs = null\n\n          cy\n          .server()\n          .route({\n            url: /foo/,\n            response: {},\n            delay: 50,\n          }).as('getFoo')\n          .window().then((w) => {\n            w.$.getJSON('foo')\n            w.$.getJSON('foo')\n            w.$.getJSON('foo')\n\n            return null\n          })\n          .then(() => {\n            const cmd = cy.queue.find({ name: 'window' })\n\n            logs = cmd.get('next').get('logs')\n\n            expect(logs.length).to.eq(3)\n\n            _.each(logs, (log) => {\n              expect(log.get('name')).to.eq('xhr')\n              expect(log.get('end')).not.to.be.true\n            })\n          }).wait(['@getFoo', '@getFoo', '@getFoo']).then(() => {\n            _.each(logs, (log) => {\n              expect(log.get('name')).to.eq('xhr')\n              expect(log.get('ended')).to.be.true\n            })\n          })\n        })\n\n        it('updates log immediately whenever an xhr is aborted', () => {\n          let xhrs = null\n\n          cy\n          .server()\n          .route({\n            url: /foo/,\n            response: {},\n            delay: 50,\n          }).as('getFoo')\n          .window().then((win) => {\n            const xhr1 = win.$.getJSON('foo1')\n\n            win.$.getJSON('foo2')\n\n            xhr1.abort()\n\n            return null\n          }).then(() => {\n            xhrs = cy.queue.logs({ name: 'xhr' })\n\n            expect(xhrs[0].get('state')).to.eq('failed')\n            expect(xhrs[0].get('error').name).to.eq('AbortError')\n            expect(xhrs[0].get('snapshots').length).to.eq(2)\n            expect(xhrs[0].get('snapshots')[0].name).to.eq('request')\n            expect(xhrs[0].get('snapshots')[0].body).to.be.a('object')\n            expect(xhrs[0].get('snapshots')[1].name).to.eq('aborted')\n            expect(xhrs[0].get('snapshots')[1].body).to.be.a('object')\n\n            expect(cy.state('requests').length).to.eq(2)\n\n            // the abort should have set its response\n            expect(cy.state('responses').length).to.eq(1)\n          })\n          .wait(['@getFoo', '@getFoo']).then(() => {\n            // should not re-snapshot after the response\n            expect(xhrs[0].get('snapshots').length).to.eq(2)\n          })\n        })\n\n        it('can access requestHeaders', () => {\n          cy\n          .server()\n          .route(/foo/, {}).as('getFoo')\n          .window().then((win) => {\n            win.$.ajax({\n              method: 'GET',\n              url: '/foo',\n              headers: {\n                'x-token': '123',\n              },\n            })\n\n            return null\n          })\n          .wait('@getFoo').its('requestHeaders').should('have.property', 'x-token', '123')\n        })\n      })\n\n      context('responses', () => {\n        beforeEach(() => {\n          cy\n          .server()\n          .route(/foo/, {}).as('getFoo')\n          .window().then((win) => {\n            win.$.get('foo_bar')\n\n            return null\n          })\n          .wait('@getFoo')\n        })\n\n        it('logs obj', function () {\n          const obj = {\n            name: 'xhr',\n            displayName: 'xhr stub',\n            event: true,\n            message: '',\n            type: 'parent',\n            aliasType: 'route',\n            referencesAlias: undefined,\n            alias: 'getFoo',\n          }\n\n          const { lastLog } = this\n\n          _.each(obj, (value, key) => {\n            expect(lastLog.get(key)).to.deep.eq(value, `expected key: ${key} to eq value: ${value}`)\n          })\n        })\n\n        it('ends', function () {\n          const { lastLog } = this\n\n          expect(lastLog.get('state')).to.eq('passed')\n        })\n\n        it('snapshots again', function () {\n          const { lastLog } = this\n\n          expect(lastLog.get('snapshots').length).to.eq(2)\n          expect(lastLog.get('snapshots')[0].name).to.eq('request')\n          expect(lastLog.get('snapshots')[0].body).to.be.an('object')\n          expect(lastLog.get('snapshots')[1].name).to.eq('response')\n          expect(lastLog.get('snapshots')[1].body).to.be.an('object')\n        })\n      })\n    })\n\n    describe('errors', {\n      defaultCommandTimeout: 200,\n    }, () => {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          if (attrs.name === 'xhr') {\n            this.lastLog = log\n            this.logs.push(log)\n          }\n        })\n\n        return null\n      })\n\n      it('sets err on log when caused by code errors', function (done) {\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(this.logs.length).to.eq(1)\n          expect(lastLog.get('name')).to.eq('xhr')\n          expect(lastLog.get('error').message).contain('foo is not defined')\n\n          done()\n        })\n\n        cy.window().then((win) => {\n          return new Promise(() => {\n            win.$.get('http://www.google.com/foo.json')\n            .fail(() => {\n              foo.bar() // eslint-disable-line no-undef\n            })\n          })\n        })\n      })\n\n      it('causes errors caused by onreadystatechange callback function', function (done) {\n        const e = new Error('onreadystatechange caused this error')\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(this.logs.length).to.eq(1)\n          expect(lastLog.get('name')).to.eq('xhr')\n          expect(err.message).to.include(lastLog.get('error').message)\n          expect(err.message).to.include(e.message)\n\n          done()\n        })\n\n        cy\n        .window().then((win) => {\n          return new Promise((resolve) => {\n            const xhr = new win.XMLHttpRequest\n\n            xhr.open('GET', '/foo')\n            xhr.onreadystatechange = function () {\n              throw e\n            }\n\n            xhr.send()\n          })\n        })\n      })\n    })\n  })\n\n  context('#server', () => {\n    it('logs deprecation warning', () => {\n      cy.stub(Cypress.utils, 'warning')\n\n      cy.server()\n      .then(function () {\n        expect(Cypress.utils.warning).to.be.calledWithMatch(/^`cy\\.server\\(\\)` has been deprecated and will be moved to a plugin in a future release\\. Consider migrating to using `cy\\.intercept\\(\\)` instead\\./)\n      })\n    })\n\n    it('sets serverIsStubbed', () => {\n      cy.server().then(() => {\n        expect(cy.state('serverIsStubbed')).to.be.true\n      })\n    })\n\n    it('can disable serverIsStubbed', () => {\n      cy.server({ enable: false }).then(() => {\n        expect(cy.state('serverIsStubbed')).to.be.false\n      })\n    })\n\n    it('sends enable to server', () => {\n      const set = cy.spy(cy.state('server'), 'set')\n\n      cy.server().then(() => {\n        expect(set).to.be.calledWithExactly({ enable: true })\n      })\n    })\n\n    it('can disable the server after enabling it', () => {\n      const set = cy.spy(cy.state('server'), 'set')\n\n      cy\n      .server()\n      .route(/app/, {}).as('getJSON')\n      .window().then((win) => {\n        win.$.get('/fixtures/app.json')\n\n        return null\n      })\n      .wait('@getJSON').its('responseBody').should('deep.eq', {})\n      .server({ enable: false })\n      .then(() => {\n        expect(set).to.be.calledWithExactly({ enable: false })\n      })\n      .window().then((win) => {\n        win.$.get('/fixtures/app.json')\n\n        return null\n      })\n      .wait('@getJSON').its('responseBody').should('not.deep.eq', {})\n    })\n\n    it('sets delay at 0 by default', () => {\n      cy\n      .server()\n      .route('*', {})\n      .then(() => {\n        expect(cy.state('server').getRoutes()[0].delay).to.eq(0)\n      })\n    })\n\n    it('sets ignore as function by default', () => {\n      cy.server()\n      cy.route('*', {})\n      .then(() => {\n        expect(cy.state('server').getRoutes()[0].ignore).to.be.a('function')\n      })\n    })\n\n    it('passes down options.delay to routes', () => {\n      cy\n      .server({ delay: 100 })\n      .route('*', {})\n      .then(() => {\n        expect(cy.state('server').getRoutes()[0].delay).to.eq(100)\n      })\n    })\n\n    it('passes event argument to xhr.onreadystatechange', (done) => {\n      cy.window().then((win) => {\n        const xhr = new win.XMLHttpRequest()\n\n        xhr.onreadystatechange = function (e) {\n          expect(e).to.be.an.instanceof(win.Event)\n\n          done()\n        }\n\n        xhr.open('GET', 'http://localhost:3500/')\n      })\n    })\n\n    describe('errors', () => {\n      context('argument signature', () => {\n        _.each(['asdf', 123, null, undefined], (arg) => {\n          it(`throws on bad argument: ${arg}`, (done) => {\n            cy.on('fail', (err) => {\n              expect(err.message).to.include('`cy.server()` accepts only an object literal as its argument')\n              expect(err.docsUrl).to.eq('https://on.cypress.io/server')\n\n              done()\n            })\n\n            cy.server(arg)\n          })\n        })\n      })\n\n      it('after turning off server it throws attempting to route', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.eq('`cy.route()` cannot be invoked before starting the `cy.server()`')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/server')\n\n          done()\n        })\n\n        cy.server()\n        cy.route(/app/, {})\n        cy.server({ enable: false })\n\n        cy.route(/app/, {})\n      })\n\n      describe('.log', () => {\n        beforeEach(function () {\n          this.logs = []\n\n          cy.on('log:added', (attrs, log) => {\n            if (attrs.name === 'xhr') {\n              this.lastLog = log\n              this.logs.push(log)\n            }\n          })\n\n          return null\n        })\n\n        it('provides specific #onFail', function (done) {\n          cy.on('fail', (err) => {\n            const obj = {\n              name: 'xhr',\n              referencesAlias: undefined,\n              alias: 'getFoo',\n              aliasType: 'route',\n              type: 'parent',\n              instrument: 'command',\n              message: '',\n              event: true,\n            }\n\n            const { lastLog } = this\n\n            _.each(obj, (value, key) => {\n              expect(value).deep.eq(lastLog.get(key), `expected key: ${key} to eq value: ${value}`)\n            })\n\n            expect(err.message).to.include(lastLog.get('error').message)\n\n            done()\n          })\n\n          cy\n          .server()\n          .route(/foo/, {}).as('getFoo')\n          .window().then((win) => {\n            return win.$.get('/foo').done(() => {\n              throw new Error('specific ajax error')\n            })\n          })\n        })\n      })\n    })\n  })\n\n  context('#route', () => {\n    beforeEach(function () {\n      this.expectOptionsToBe = (opts) => {\n        const options = this.route.getCall(0).args[0]\n\n        _.each(opts, (value, key) => {\n          expect(options[key]).to.deep.eq(opts[key], `failed on property: (${key})`)\n        })\n      }\n\n      cy.server().then(function () {\n        this.route = cy.spy(cy.state('server'), 'route')\n      })\n    })\n\n    it('logs deprecation warning', () => {\n      cy.stub(Cypress.utils, 'warning')\n\n      cy.route('*')\n      .then(function () {\n        expect(Cypress.utils.warning).to.be.calledWithMatch(/^`cy\\.route\\(\\)` has been deprecated and will be moved to a plugin in a future release\\. Consider migrating to using `cy\\.intercept\\(\\)` instead\\./)\n      })\n    })\n\n    it('accepts url, response', () => {\n      cy.route('/foo', {}).then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          status: 200,\n          url: '/foo',\n          response: {},\n        })\n      })\n    })\n\n    it('accepts regex url, response', () => {\n      cy.route(/foo/, {}).then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          status: 200,\n          url: /foo/,\n          response: {},\n        })\n      })\n    })\n\n    it('does not mutate other routes when using shorthand', () => {\n      cy\n      .route('POST', /foo/, {}).as('getFoo')\n      .route(/bar/, {}).as('getBar')\n      .then(function () {\n        expect(this.route.firstCall.args[0].method).to.eq('POST')\n        expect(this.route.secondCall.args[0].method).to.eq('GET')\n      })\n    })\n\n    it('accepts url, response, onRequest', () => {\n      const onRequest = () => {}\n\n      cy.route({\n        url: '/foo',\n        response: {},\n        onRequest,\n      }).then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          status: 200,\n          url: '/foo',\n          response: {},\n          onRequest,\n          onResponse: undefined,\n        })\n      })\n    })\n\n    it('accepts url, response, onRequest, onResponse', () => {\n      const onRequest = () => {}\n      const onResponse = () => {}\n\n      cy.route({\n        url: '/foo',\n        response: {},\n        onRequest,\n        onResponse,\n      }).then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          status: 200,\n          url: '/foo',\n          response: {},\n          onRequest,\n          onResponse,\n        })\n      })\n    })\n\n    it('accepts method, url, response', () => {\n      cy.route('GET', '/foo', {}).then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          status: 200,\n          url: '/foo',\n          response: {},\n        })\n      })\n    })\n\n    it('accepts method, url, response, onRequest', () => {\n      const onRequest = () => {}\n\n      cy.route({\n        method: 'GET',\n        url: '/foo',\n        response: {},\n        onRequest,\n      }).then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          url: '/foo',\n          status: 200,\n          response: {},\n          onRequest,\n          onResponse: undefined,\n        })\n      })\n    })\n\n    it('accepts method, url, response, onRequest, onResponse', () => {\n      const onRequest = () => {}\n      const onResponse = () => {}\n\n      cy.route({\n        method: 'GET',\n        url: '/foo',\n        response: {},\n        onRequest,\n        onResponse,\n      }).then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          url: '/foo',\n          status: 200,\n          response: {},\n          onRequest,\n          onResponse,\n        })\n      })\n    })\n\n    it('uppercases method', () => {\n      cy.route('get', '/foo', {}).then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          status: 200,\n          url: '/foo',\n          response: {},\n        })\n      })\n    })\n\n    it('accepts string or regex as the url', () => {\n      cy.route('get', /.*/, {}).then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          status: 200,\n          url: /.*/,\n          response: {},\n        })\n      })\n    })\n\n    it('does not require response or method when not stubbing', () => {\n      cy\n      .server()\n      .route(/users/).as('getUsers')\n      .then(function () {\n        this.expectOptionsToBe({\n          status: 200,\n          method: 'GET',\n          url: /users/,\n        })\n      })\n    })\n\n    it('does not require response when not stubbing', () => {\n      cy\n      .server()\n      .route('POST', /users/).as('createUsers')\n      .then(function () {\n        this.expectOptionsToBe({\n          status: 200,\n          method: 'POST',\n          url: /users/,\n        })\n      })\n    })\n\n    it('accepts an object literal as options', () => {\n      const onRequest = () => {}\n      const onResponse = () => {}\n\n      const opts = {\n        method: 'PUT',\n        url: '/foo',\n        status: 200,\n        response: {},\n        onRequest,\n        onResponse,\n      }\n\n      cy.route(opts).then(function () {\n        this.expectOptionsToBe(opts)\n      })\n    })\n\n    it('can accept wildcard * as URL and converts to /.*/ regex', () => {\n      const opts = {\n        url: '*',\n        response: {},\n      }\n\n      cy.route(opts).then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          status: 200,\n          url: /.*/,\n          originalUrl: '*',\n          response: {},\n        })\n      })\n    })\n\n    // FIXME: I have no idea why this is skipped, this test is rly old\n    it.skip('can explicitly done() in onRequest function from options', (done) => {\n      cy\n      .server()\n      .route({\n        method: 'POST',\n        url: '/users',\n        response: {},\n        onRequest () {\n          done()\n        },\n      })\n      .then(() => {\n        cy.state('window').$.post('/users', 'name=brian')\n      })\n    })\n\n    it('can accept response as a function', () => {\n      const users = [{}, {}]\n      const getUsers = () => {\n        return users\n      }\n\n      cy.route(/users/, getUsers)\n      .then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          status: 200,\n          url: /users/,\n          response: users,\n        })\n      })\n    })\n\n    it('invokes response function with runnable.ctx', function () {\n      const ctx = this\n\n      const getUsers = function () {\n        expect(this === ctx).to.be.true\n      }\n\n      cy.route(/users/, getUsers)\n    })\n\n    it('passes options as argument', function () {\n      const getUsers = function (opts) {\n        expect(opts).to.be.an('object')\n        expect(opts.method).to.eq('GET')\n      }\n\n      cy.route(/users/, getUsers)\n    })\n\n    it('can accept response as a function which returns a promise', () => {\n      const users = [{}, {}]\n\n      const getUsers = () => {\n        return new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(users)\n          }, 10)\n        })\n      }\n\n      cy.route(/users/, getUsers)\n      .then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          status: 200,\n          url: /users/,\n          response: users,\n        })\n      })\n    })\n\n    it('can accept a function which returns options', () => {\n      const users = [{}, {}]\n\n      const getRoute = () => {\n        return {\n          method: 'GET',\n          url: /users/,\n          status: 201,\n          response () {\n            return Promise.resolve(users)\n          },\n        }\n      }\n\n      cy.route(getRoute)\n      .then(function () {\n        this.expectOptionsToBe({\n          method: 'GET',\n          status: 201,\n          url: /users/,\n          response: users,\n        })\n      })\n    })\n\n    it('invokes route function with runnable.ctx', function () {\n      const ctx = this\n\n      const getUsers = function () {\n        expect(this === ctx).to.be.true\n\n        return {\n          url: /foo/,\n        }\n      }\n\n      cy.route(getUsers)\n    })\n\n    // FIXME: I have no idea why this is skipped, this test is rly old\n    it.skip('adds multiple routes to the responses array', () => {\n      cy\n      .route('foo', {})\n      .route('bar', {})\n      .then(() => {\n        expect(cy.state('sandbox').server.responses).to.have.length(2)\n      })\n    })\n\n    it('can use regular strings as response', () => {\n      cy\n      .route('/foo', 'foo bar baz').as('getFoo')\n      .window().then((win) => {\n        win.$.get('/foo')\n\n        return null\n      })\n      .wait('@getFoo').then((xhr) => {\n        expect(xhr.responseBody).to.eq('foo bar baz')\n      })\n    })\n\n    it('can stub requests with uncommon HTTP methods', () => {\n      cy\n      .route('PROPFIND', '/foo', 'foo bar baz').as('getFoo')\n      .window().then((win) => {\n        win.$.ajax({\n          url: '/foo',\n          method: 'PROPFIND',\n        })\n\n        return null\n      })\n      .wait('@getFoo').then((xhr) => {\n        expect(xhr.responseBody).to.eq('foo bar baz')\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/2372\n    it('warns if a percent-encoded URL is used', () => {\n      cy.spy(Cypress.utils, 'warning')\n\n      cy.route('GET', '/foo%25bar')\n      .then(() => {\n        expect(Cypress.utils.warning).to.be.calledWith(stripIndent`\\\n          A \\`url\\` with percent-encoded characters was passed to \\`cy.route()\\`, but \\`cy.route()\\` expects a decoded \\`url\\`.\n\n          Did you mean to pass \"/foo%bar\"?\n\n          https://on.cypress.io/route`)\n      })\n    })\n\n    it('does not warn if an invalid percent-encoded URL is used', () => {\n      cy.spy(Cypress.utils, 'warning')\n\n      cy.route('GET', 'http://example.com/%E0%A4%A')\n      .then(() => {\n        expect(Cypress.utils.warning).to.not.be.calledWithMatch(/percent\\-encoded characters/)\n      })\n    })\n\n    // FIXME: I have no idea why this is skipped, this test is rly old\n    it.skip('does not error when response is null but respond is false', () => {\n      cy.route({\n        url: /foo/,\n        respond: false,\n      })\n    })\n\n    describe('matches pattern', () => {\n      const testMatchesPattern = (pattern, href, expectMatch) => {\n        return (done) => {\n          cy\n          .route(pattern).as('getFoo')\n          .window().then((win) => {\n            const xhr = new win.XMLHttpRequest\n\n            xhr.open('get', href)\n            xhr.send()\n          })\n\n          if (expectMatch) {\n            cy.wait('@getFoo').then(() => done())\n          } else {\n            cy.on('fail', (err) => {\n              expect(err.message).to.include('No request ever occurred.')\n              done()\n            })\n\n            cy.wait('@getFoo', { timeout: 50 })\n          }\n        }\n      }\n\n      it('without querystring', testMatchesPattern('/foo', '/foo', true))\n      it('does not match with querystring', testMatchesPattern('/foo', '/foo?abc', false))\n      it('with querystring and wildcard', testMatchesPattern('/foo*', '/foo?abc', true))\n    })\n\n    describe('request response alias', () => {\n      it('matches xhrs with lowercase methods', () => {\n        cy\n        .route(/foo/, {}).as('getFoo')\n        .window().then((win) => {\n          const xhr = new win.XMLHttpRequest\n\n          xhr.open('get', '/foo')\n          xhr.send()\n        }).wait('@getFoo')\n      })\n\n      it('can pass an alias reference to route', () => {\n        cy\n        .noop({ foo: 'bar' }).as('foo')\n        .route(/foo/, '@foo').as('getFoo')\n        .window().then((win) => {\n          win.$.getJSON('foo')\n\n          return null\n        })\n        .wait('@getFoo').then(function (xhr) {\n          expect(xhr.responseBody).to.deep.eq({ foo: 'bar' })\n          expect(xhr.responseBody).to.deep.eq(this.foo)\n        })\n      })\n\n      it('can pass an alias when using a response function', () => {\n        const getFoo = () => {\n          return Promise.resolve('@foo')\n        }\n\n        cy\n        .noop({ foo: 'bar' }).as('foo')\n        .route(/foo/, getFoo).as('getFoo')\n        .window().then((win) => {\n          win.$.getJSON('foo')\n\n          return null\n        })\n        .wait('@getFoo').then(function (xhr) {\n          expect(xhr.responseBody).to.deep.eq({ foo: 'bar' })\n          expect(xhr.responseBody).to.deep.eq(this.foo)\n        })\n      })\n\n      it('can alias a route without stubbing it', () => {\n        cy\n        .route(/fixtures\\/app/).as('getFoo')\n        .window().then((win) => {\n          win.$.get('/fixtures/app.json')\n\n          return null\n        })\n        .wait('@getFoo').then((xhr) => {\n          const log = cy.queue.logs({ name: 'xhr' })[0]\n\n          expect(log.get('displayName')).to.eq('xhr')\n          expect(log.get('alias')).to.eq('getFoo')\n          expect(xhr.responseBody).to.deep.eq({\n            some: 'json',\n            foo: {\n              bar: 'baz',\n            },\n          })\n        })\n      })\n    })\n\n    describe('response fixtures', () => {\n      it('works if the JSON file has an object', () => {\n        cy\n        .server()\n        .route({\n          method: 'POST',\n          url: '/test-xhr',\n          response: 'fixture:valid.json',\n        })\n        .visit('/fixtures/xhr-triggered.html')\n        .get('#trigger-xhr')\n        .click()\n\n        cy.contains('#result', '{\"foo\":1,\"bar\":{\"baz\":\"cypress\"}}').should('be.visible')\n      })\n\n      it('works if the JSON file has null content', () => {\n        cy\n        .server()\n        .route({\n          method: 'POST',\n          url: '/test-xhr',\n          response: 'fixture:null.json',\n        })\n        .visit('/fixtures/xhr-triggered.html')\n        .get('#trigger-xhr')\n        .click()\n\n        cy.contains('#result', '\"\"').should('be.visible')\n      })\n\n      it('works if the JSON file has number content', () => {\n        cy\n        .server()\n        .route({\n          method: 'POST',\n          url: '/test-xhr',\n          response: 'fixture:number.json',\n        })\n        .visit('/fixtures/xhr-triggered.html')\n        .get('#trigger-xhr')\n        .click()\n\n        cy.contains('#result', 14).should('be.visible')\n      })\n\n      it('works if the JSON file has boolean content', () => {\n        cy\n        .server()\n        .route({\n          method: 'POST',\n          url: '/test-xhr',\n          response: 'fixture:boolean.json',\n        })\n        .visit('/fixtures/xhr-triggered.html')\n        .get('#trigger-xhr')\n        .click()\n\n        cy.contains('#result', /true/).should('be.visible')\n      })\n    })\n\n    describe('errors', {\n      defaultCommandTimeout: 100,\n    }, () => {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          this.lastLog = log\n          this.logs.push(log)\n        })\n\n        return null\n      })\n\n      it('throws if cy.server() hasnt been invoked', (done) => {\n        cy.state('serverIsStubbed', false)\n\n        cy.on('fail', (err) => {\n          expect(err.message).to.include('`cy.route()` cannot be invoked before starting the `cy.server()`')\n\n          done()\n        })\n\n        cy.route()\n      })\n\n      it('throws on use of whitelist option', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.include('The `cy.server()` `whitelist` option has been renamed to `ignore`. Please rename `whitelist` to `ignore`.')\n\n          done()\n        })\n\n        cy.server({ whitelist: () => { } })\n      })\n\n      it('url must be a string or regexp', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.include('`cy.route()` was called with an invalid `url`. `url` must be either a string or regular expression.')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/route')\n\n          done()\n        })\n\n        cy.route({\n          url: {},\n        })\n      })\n\n      it('url must be a string or regexp when a function', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.include('`cy.route()` was called with an invalid `url`. `url` must be either a string or regular expression.')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/route')\n\n          done()\n        })\n\n        const getUrl = () => {\n          return Promise.resolve({ url: {} })\n        }\n\n        cy.route(getUrl)\n      })\n\n      it('fails when functions reject', (done) => {\n        const error = new Error\n\n        cy.on('fail', (err) => {\n          expect(err).to.eq(error)\n\n          done()\n        })\n\n        const getUrl = () => {\n          return Promise.reject(error)\n        }\n\n        cy.route(getUrl)\n      })\n\n      it('fails when method is invalid', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.include('`cy.route()` was called with an invalid method: `POSTS`.')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/route')\n\n          done()\n        })\n\n        cy.route('posts', '/foo', {})\n      })\n\n      it('requires a url when given a response', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.include('`cy.route()` must be called with a `url`. It can be a string or regular expression.')\n\n          done()\n        })\n\n        cy.route({})\n      })\n\n      _.each([null, undefined], (val) => {\n        it(`throws if response options was explicitly set to ${val}`, (done) => {\n          cy.on('fail', (err) => {\n            expect(err.message).to.include('`cy.route()` cannot accept an `undefined` or `null` response. It must be set to something, even an empty string will work.')\n            expect(err.docsUrl).to.eq('https://on.cypress.io/route')\n\n            done()\n          })\n\n          cy.route({ url: /foo/, response: val })\n        })\n\n        it(`throws if response argument was explicitly set to ${val}`, (done) => {\n          cy.on('fail', (err) => {\n            expect(err.message).to.include('`cy.route()` cannot accept an `undefined` or `null` response. It must be set to something, even an empty string will work.')\n\n            done()\n          })\n\n          cy.route(/foo/, val)\n        })\n      })\n\n      it('requires arguments', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.include('`cy.route()` was not provided any arguments. You must provide valid arguments.')\n          expect(err.docsUrl).to.eq('https://on.cypress.io/route')\n\n          done()\n        })\n\n        cy.route()\n      })\n\n      it('sets err on log when caused by the XHR response', function (done) {\n        // NOTE: sometimes the .then command will timeout before the request finishes\n        // so bump the timeout here. This does not increase test duration\n        Cypress.config('defaultCommandTimeout', 1000)\n        this.route.restore()\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          // route + window + xhr log === 3\n          expect(this.logs.length).to.eq(3)\n          expect(lastLog.get('name')).to.eq('xhr')\n          expect(err.message).to.include(lastLog.get('error').message)\n\n          done()\n        })\n\n        cy\n        .route(/foo/, {}).as('getFoo')\n        .window().then((win) => {\n          return win.$.get('foo_bar').done(() => {\n            foo.bar() // eslint-disable-line no-undef\n          })\n        })\n      })\n\n      // FIXME: I have no idea why this is skipped, this test is rly old\n      it.skip('explodes if response fixture signature errors', function (done) {\n        this.trigger = cy.stub(this.Cypress, 'trigger').withArgs('fixture').callsArgWithAsync(2, { __error: 'some error' })\n\n        const logs = []\n\n        const _this = this\n\n        // we have to restore the trigger when commandErr is called\n        // so that something logs out!\n        cy.commandErr = _.wrap(cy.commandErr, function (orig, err) {\n          _this.Cypress.trigger.restore()\n          orig.call(this, err)\n        })\n\n        cy.on('log:added', (attrs, log) => {\n          this.log = log\n          logs.push(this.log)\n        })\n\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(err.message).to.eq('some error')\n          expect(this.logs.length).to.eq(1)\n          expect(lastLog.get('name')).to.eq('route')\n          expect(lastLog.get('error')).to.eq(err)\n          expect(lastLog.get('message')).to.eq('/foo/, fixture:bar')\n\n          done()\n        })\n\n        cy.route(/foo/, 'fixture:bar')\n      })\n\n      // TODO: handle this uncaught exception failure\n      it.skip('does not retry (cancels existing promise) when xhr errors', (done) => {\n        const cancel = cy.spy(Promise.prototype, 'cancel')\n\n        cy.on('command:retry', () => {\n          if (cy.state('error')) {\n            done('should have canceled and not retried after failing')\n          }\n        })\n\n        cy.on('fail', (err) => {\n          const p = cy.state('promise')\n\n          _.delay(() => {\n            expect(cancel).to.be.calledOn(p)\n\n            done()\n          }, 100)\n        })\n\n        cy\n        .route({\n          url: /foo/,\n          response: {},\n          delay: 100,\n        })\n        .window().then((win) => {\n          win.$.getJSON('/foo').done(() => {\n            throw new Error('foo failed')\n          })\n\n          return null\n        })\n        .get('button').should('have.class', 'does-not-exist')\n      })\n\n      it('explodes if response alias cannot be found', function (done) {\n        cy.on('fail', (err) => {\n          const { lastLog } = this\n\n          expect(this.logs.length).to.eq(2)\n          expect(err.message).to.eq('`cy.route()` could not find a registered alias for: `@bar`.\\nAvailable aliases are: `foo`.')\n          expect(lastLog.get('name')).to.eq('route')\n          expect(lastLog.get('error')).to.eq(err)\n          expect(lastLog.get('message')).to.eq('/foo/, @bar')\n\n          done()\n        })\n\n        cy\n        .wrap({ foo: 'bar' }).as('foo')\n        .route(/foo/, '@bar')\n      })\n\n      // https://github.com/cypress-io/cypress/issues/7818\n      it('throws when fixture cannot be found', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.contains('A fixture file could not be found at any of the following paths:')\n          done()\n        })\n\n        cy.route(/foo/, 'fx:NOT_EXISTING_FILE_FIXTURE').as('stub')\n        cy.window().then((win) => {\n          win.$.get('/foo')\n        })\n\n        cy.wait('@stub')\n      })\n    })\n\n    describe('.log', () => {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          if (attrs.instrument === 'route') {\n            this.lastLog = log\n            this.logs.push(log)\n          }\n        })\n\n        return null\n      })\n\n      it('has name of route', () => {\n        cy.route('/foo', {}).then(function () {\n          const { lastLog } = this\n\n          expect(lastLog.get('name')).to.eq('route')\n        })\n      })\n\n      it('uses the wildcard URL', () => {\n        cy.route('*', {}).then(function () {\n          const { lastLog } = this\n\n          expect(lastLog.get('url')).to.eq('*')\n        })\n      })\n\n      it('#consoleProps', () => {\n        cy.route('*', { foo: 'bar' }).as('foo').then(function () {\n          expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n            Command: 'route',\n            Method: 'GET',\n            URL: '*',\n            Status: 200,\n            Response: { foo: 'bar' },\n            Alias: 'foo',\n            // Responded: 1 time\n            // \"-------\": \"\"\n            // Responses: []\n          })\n        })\n      })\n\n      describe('numResponses', () => {\n        it('is initially 0', function () {\n          cy.route(/foo/, {}).then(() => {\n            const { lastLog } = this\n\n            expect(lastLog.get('numResponses')).to.eq(0)\n          })\n        })\n\n        it('is incremented to 2', () => {\n          cy\n          .route(/foo/, {})\n          .window().then((win) => {\n            return win.$.get('/foo')\n          })\n          .then(function () {\n            expect(this.lastLog.get('numResponses')).to.eq(1)\n          })\n        })\n\n        it('is incremented for each matching request', () => {\n          cy\n          .route(/foo/, {})\n          .window().then((win) => {\n            return Promise.all([\n              win.$.get('/foo'),\n              win.$.get('/foo'),\n              win.$.get('/foo'),\n            ])\n          })\n          .then(function () {\n            expect(this.lastLog.get('numResponses')).to.eq(3)\n          })\n        })\n      })\n    })\n  })\n\n  context('consoleProps logs', () => {\n    beforeEach(function () {\n      this.logs = []\n\n      cy.on('log:added', (attrs, log) => {\n        if (attrs.name === 'xhr') {\n          this.lastLog = log\n          this.logs.push(log)\n        }\n      })\n\n      return null\n    })\n\n    describe('when stubbed', () => {\n      it('says Stubbed: Yes', () => {\n        cy\n        .server()\n        .route(/foo/, {}).as('getFoo')\n        .window().then((win) => {\n          return new Promise((resolve) => {\n            return win.$.get('/foo').done(resolve)\n          })\n        })\n        .then(function () {\n          expect(this.lastLog.invoke('consoleProps').Stubbed).to.eq('Yes')\n        })\n      })\n    })\n\n    describe('zero configuration / zero routes', () => {\n      beforeEach(() => {\n        cy\n        .server({ force404: true })\n        .window().then((win) => {\n          return new Promise((resolve) => {\n            win.$.ajax({\n              method: 'POST',\n              url: '/foo',\n              data: JSON.stringify({ foo: 'bar' }),\n            }).fail(() => {\n              resolve()\n            })\n          })\n        })\n      })\n\n      it('calculates duration', () => {\n        cy.then(function () {\n          const consoleProps = this.lastLog.invoke('consoleProps')\n\n          expect(consoleProps.Duration).to.be.a('number')\n          expect(consoleProps.Duration).to.be.gt(1)\n          expect(consoleProps.Duration).to.be.lt(1000)\n        })\n      })\n\n      it('sends back regular 404', () => {\n        cy.then(function () {\n          const { xhr } = cy.state('responses')[0]\n\n          const consoleProps = _.pick(this.lastLog.invoke('consoleProps'), 'Method', 'Status', 'URL', 'XHR')\n\n          expect(consoleProps).to.deep.eq({\n            Method: 'POST',\n            Status: '404 (Not Found)',\n            URL: 'http://localhost:3500/foo',\n            XHR: xhr.xhr,\n          })\n        })\n      })\n\n      it('says Stubbed: Yes when sent 404 back', function () {\n        expect(this.lastLog.invoke('consoleProps').Stubbed).to.eq('Yes')\n      })\n    })\n\n    describe('ignored routes', () => {\n      it('does not send back 404s on allowed routes', () => {\n        cy\n        .server()\n        .window().then((win) => {\n          return win.$.get('/fixtures/app.js')\n        })\n        .then((resp) => {\n          expect(resp).to.eq('{ \\'bar\\' }\\n')\n        })\n      })\n\n      // https://github.com/cypress-io/cypress/issues/7280\n      it('ignores query params when filtering routes', () => {\n        cy.server()\n        cy.route(/url-with-query-param/, { foo: 'bar' }).as('getQueryParam')\n        cy.window().then((win) => {\n          win.$.get('/url-with-query-param?resource=foo.js')\n\n          return null\n        })\n\n        cy.wait('@getQueryParam').its('response.body')\n        .should('deep.equal', { foo: 'bar' })\n      })\n\n      // https://github.com/cypress-io/cypress/issues/7280\n      it('ignores hashes when filtering routes', () => {\n        cy.server()\n        cy.route(/url-with-hash/, { foo: 'bar' }).as('getHash')\n        cy.window().then((win) => {\n          win.$.get('/url-with-hash#foo.js')\n\n          return null\n        })\n\n        cy.wait('@getHash').its('response.body')\n        .should('deep.equal', { foo: 'bar' })\n      })\n\n      it('overrides ignoring resources when passed as option', () => {\n        cy.server({ ignore: () => false })\n        cy.route('app.js', { foo: 'bar' }).as('getJSResource')\n        cy.route('index.html', '<html></html>').as('getHTMLResource')\n        cy.route('style.css', 'body: {color: red;}').as('getCSSResource')\n        cy.window().then((win) => {\n          win.$.get('/fixtures/app.js')\n          win.$.get('/fixtures/style.css')\n\n          return win.$.get('/fixtures/index.html')\n        })\n\n        // normally these resources would be ignored\n        // but overwriting ignore to return false allows all resources\n        cy.wait('@getJSResource').its('response.body')\n        .should('deep.equal', { foo: 'bar' })\n\n        cy.wait('@getHTMLResource').its('response.body')\n        .should('deep.equal', '<html></html>')\n\n        cy.wait('@getCSSResource').its('response.body')\n        .should('deep.equal', 'body: {color: red;}')\n      })\n    })\n\n    describe('route setup', () => {\n      beforeEach(() => {\n        cy\n        .server({ force404: true })\n        .route('/foo', {}).as('anyRequest')\n        .window().then((win) => {\n          win.$.get('/bar')\n\n          return null\n        })\n      })\n\n      it('sends back 404 when request doesnt match route', () => {\n        cy.then(function () {\n          const consoleProps = this.lastLog.invoke('consoleProps')\n\n          expect(consoleProps.Note).to.eq('This request did not match any of your routes. It was automatically sent back \\'404\\'. Setting cy.server({force404: false}) will turn off this behavior.')\n        })\n      })\n    })\n\n    describe('{force404: false}', () => {\n      beforeEach(() => {\n        cy\n        .server()\n        .window().then((win) => {\n          return win.$.getJSON('/fixtures/app.json')\n        })\n      })\n\n      it('says Stubbed: No when request isnt forced 404', function () {\n        expect(this.lastLog.invoke('consoleProps').Stubbed).to.eq('No')\n      })\n\n      it('logs request + response headers', () => {\n        cy.then(function () {\n          const consoleProps = this.lastLog.invoke('consoleProps')\n\n          expect(consoleProps.Request.headers).to.be.an('object')\n          expect(consoleProps.Response.headers).to.be.an('object')\n        })\n      })\n\n      it('logs Method, Status, URL, and XHR', () => {\n        cy.then(function () {\n          const { xhr } = cy.state('responses')[0]\n\n          const consoleProps = _.pick(this.lastLog.invoke('consoleProps'), 'Method', 'Status', 'URL', 'XHR')\n\n          expect(consoleProps).to.deep.eq({\n            Method: 'GET',\n            URL: 'http://localhost:3500/fixtures/app.json',\n            Status: '200 (OK)',\n            XHR: xhr.xhr,\n          })\n        })\n      })\n\n      it('logs response', () => {\n        cy.then(function () {\n          const consoleProps = this.lastLog.invoke('consoleProps')\n\n          expect(consoleProps.Response.body).to.deep.eq({\n            some: 'json',\n            foo: {\n              bar: 'baz',\n            },\n          })\n        })\n      })\n\n      it('sets groups Initiator', () => {\n        cy.then(function () {\n          const consoleProps = this.lastLog.invoke('consoleProps')\n\n          const group = consoleProps.groups()[0]\n\n          expect(group.name).to.eq('Initiator')\n          expect(group.label).to.be.false\n          expect(group.items[0]).to.be.a('string')\n          expect(group.items[0].split('\\n').length).to.gt(1)\n        })\n      })\n    })\n  })\n\n  context('renderProps', () => {\n    beforeEach(function () {\n      this.logs = []\n\n      cy.on('log:added', (attrs, log) => {\n        if (attrs.name === 'xhr') {\n          this.lastLog = log\n          this.logs.push(log)\n        }\n      })\n\n      return null\n    })\n\n    describe('in any case', () => {\n      beforeEach(() => {\n        cy\n        .server()\n        .route(/foo/, {})\n        .window().then((win) => {\n          return new Promise((resolve) => {\n            return win.$.get('/foo').done(resolve)\n          })\n        })\n      })\n\n      it('sends correct message', () => {\n        cy.then(function () {\n          expect(this.lastLog.invoke('renderProps').message).to.equal('GET 200 /foo')\n        })\n      })\n    })\n\n    describe('when response is successful', () => {\n      beforeEach(() => {\n        cy\n        .server()\n        .route(/foo/, {})\n        .window().then((win) => {\n          return new Promise((resolve) => {\n            return win.$.get('/foo').done(resolve)\n          })\n        })\n      })\n\n      it('sends correct indicator', () => {\n        cy.then(function () {\n          expect(this.lastLog.invoke('renderProps').indicator).to.equal('successful')\n        })\n      })\n    })\n\n    describe('when response is pending', () => {\n      beforeEach(() => {\n        cy\n        .server()\n        .route({ url: '/foo', delay: 500, response: {} })\n        .window().then((win) => {\n          win.$.get('/foo')\n\n          return null\n        })\n      })\n\n      // FAILING\n      it('sends correct message', function () {\n        expect(this.lastLog.invoke('renderProps').message).to.equal('GET --- /foo')\n      })\n\n      it('sends correct indicator', function () {\n        expect(this.lastLog.invoke('renderProps').indicator).to.equal('pending')\n      })\n    })\n\n    describe('when response is outside 200 range', () => {\n      beforeEach(() => {\n        cy\n        .server()\n        .route({ url: '/foo', status: 500, response: {} })\n        .window().then((win) => {\n          return new Promise((resolve) => {\n            return win.$.get('/foo').fail(() => {\n              resolve()\n            })\n          })\n        })\n      })\n\n      it('sends correct indicator', () => {\n        cy.then(function () {\n          expect(this.lastLog.invoke('renderProps').indicator).to.equal('bad')\n        })\n      })\n    })\n  })\n\n  context('abort', () => {\n    const xhrs = []\n\n    beforeEach(() => {\n      cy.visit('/fixtures/jquery.html')\n    })\n\n    it('does not abort xhr\\'s between tests', () => {\n      cy.window().then((win) => {\n        _.times(2, () => {\n          const xhr = new win.XMLHttpRequest\n\n          xhr.open('GET', '/timeout?ms=100')\n          xhr.send()\n          xhrs.push(xhr)\n        })\n      })\n    })\n\n    it('has not aborted the xhrs', () => {\n      _.each(xhrs, (xhr) => {\n        expect(xhr.aborted).not.to.be.false\n      })\n    })\n\n    it('aborts xhrs that haven\\'t been sent', () => {\n      cy\n      .window()\n      .then((win) => {\n        const xhr = new win.XMLHttpRequest()\n\n        xhr.open('GET', '/timeout?ms=0')\n        xhr.abort()\n\n        expect(xhr.aborted).to.be.true\n      })\n    })\n\n    it('aborts xhrs currently in flight', () => {\n      let log = null\n\n      cy.on('log:changed', (attrs, l) => {\n        if (attrs.name === 'xhr') {\n          if (!log) {\n            log = l\n          }\n        }\n      })\n\n      cy\n      .window()\n      .then((win) => {\n        const xhr = new win.XMLHttpRequest()\n\n        xhr.open('GET', '/timeout?ms=999')\n        xhr.send()\n        xhr.abort()\n\n        cy.wrap(null).should(() => {\n          expect(log.get('state')).to.eq('failed')\n          expect(log.invoke('renderProps')).to.deep.eq({\n            message: 'GET (aborted) /timeout?ms=999',\n            indicator: 'aborted',\n          })\n\n          expect(xhr.aborted).to.be.true\n        })\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/3008\n    it('aborts xhrs even when responseType  not \\'\\' or \\'text\\'', () => {\n      let log = null\n\n      cy.on('log:changed', (attrs, l) => {\n        if (attrs.name === 'xhr') {\n          if (!log) {\n            log = l\n          }\n        }\n      })\n\n      cy\n      .window()\n      .then((win) => {\n        const xhr = new win.XMLHttpRequest()\n\n        xhr.responseType = 'arraybuffer'\n        xhr.open('GET', '/timeout?ms=1000')\n        xhr.send()\n        xhr.abort()\n\n        cy.wrap(null).should(() => {\n          expect(log.get('state')).to.eq('failed')\n          expect(xhr.aborted).to.be.true\n        })\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/1652\n    it('does not set aborted on XHR\\'s that have completed by have had .abort() called', () => {\n      let log = null\n\n      cy.on('log:changed', (attrs, l) => {\n        if (attrs.name === 'xhr') {\n          if (!log) {\n            log = l\n          }\n        }\n      })\n\n      cy\n      .window()\n      .then((win) => {\n        return new Promise((resolve) => {\n          const xhr = new win.XMLHttpRequest()\n\n          xhr.open('GET', '/timeout?ms=0')\n          xhr.onload = function () {\n            xhr.abort()\n            xhr.foo = 'bar'\n\n            return resolve(xhr)\n          }\n\n          xhr.send()\n        })\n      })\n      .then((xhr) => {\n        cy\n        .wrap(null)\n        .should(() => {\n          // ensure this is set to prevent accidental\n          // race conditions down the road if something\n          // goes wrong\n          expect(xhr.foo).to.eq('bar')\n          expect(xhr.aborted).not.to.be.true\n          expect(log.get('state')).to.eq('passed')\n        })\n      })\n    })\n  })\n\n  context('Cypress.on(window:unload)', () => {\n    it('cancels all open XHR\\'s', () => {\n      const xhrs = []\n\n      cy\n      .window()\n      .then((win) => {\n        _.times(2, () => {\n          const xhr = new win.XMLHttpRequest\n\n          xhr.open('GET', '/timeout?ms=200')\n          xhr.send()\n          xhrs.push(xhr)\n        })\n      })\n      .reload()\n      .then(() => {\n        _.each(xhrs, (xhr) => {\n          expect(xhr.canceled).to.be.true\n        })\n      })\n    })\n  })\n\n  context('Cypress.on(window:before:load)', () => {\n    it('reapplies server + route automatically before window:load', () => {\n      // this tests that the server + routes are automatically reapplied\n      // after the 2nd visit - which is an example of the remote iframe\n      // causing an onBeforeLoad event\n      cy\n      .server()\n      .route(/foo/, { foo: 'bar' }).as('getFoo')\n      .visit('http://localhost:3500/fixtures/jquery.html')\n      .window().then((win) => {\n        return new Promise((resolve) => {\n          const xhr = new win.XMLHttpRequest\n\n          xhr.open('GET', '/foo')\n          xhr.send()\n          xhr.onload = resolve\n        })\n      })\n      .wait('@getFoo').its('url').should('include', '/foo')\n      .visit('http://localhost:3500/fixtures/generic.html')\n      .window().then((win) => {\n        return new Promise((resolve) => {\n          const xhr = new win.XMLHttpRequest\n\n          xhr.open('GET', '/foo')\n          xhr.send()\n          xhr.onload = resolve\n        })\n      })\n      .wait('@getFoo').its('url').should('include', '/foo')\n    })\n\n    it('reapplies server + route automatically during page transitions', () => {\n      // this tests that the server + routes are automatically reapplied\n      // after the 2nd visit - which is an example of the remote iframe\n      // causing an onBeforeLoad event\n      cy\n      .server()\n      .route(/foo/, { foo: 'bar' }).as('getFoo')\n      .visit('http://localhost:3500/fixtures/jquery.html')\n      .window().then((win) => {\n        const url = 'http://localhost:3500/fixtures/generic.html'\n\n        const $a = win.$(`<a href='${url}'>jquery</a>`)\n        .appendTo(win.document.body)\n\n        // synchronous beforeunload\n        return $a.get(0).click()\n      })\n      .url().should('include', '/generic.html')\n      .window().then((win) => {\n        return new Promise((resolve) => {\n          const xhr = new win.XMLHttpRequest\n\n          xhr.open('GET', '/foo')\n          xhr.send()\n          xhr.onload = resolve\n        })\n      })\n      .wait('@getFoo').its('url').should('include', '/foo')\n    })\n  })\n\n  // FIXME: I have no idea why this is skipped, this test is rly old\n  context.skip('#cancel', () => {\n    it('calls server#cancel', function (done) {\n      let cancel = null\n\n      this.Cypress.once('abort', () => {\n        expect(cancel).to.be.called\n\n        done()\n      })\n\n      cy.server().then(function () {\n        cancel = cy.spy(cy.state('server'), 'cancel')\n\n        this.Cypress.trigger('abort')\n      })\n    })\n  })\n\n  // FIXME: I have no idea why this is skipped, this test is rly old\n  context.skip('#respond', () => {\n    it('calls server#respond', () => {\n      let respond = null\n\n      cy\n      .server({ delay: 100 }).then((server) => {\n        respond = cy.spy(server, 'respond')\n      })\n      .window().then((win) => {\n        win.$.get('/users')\n\n        return null\n      })\n      .respond().then(() => {\n        expect(respond).to.be.calledOnce\n      })\n    })\n\n    describe('errors', () => {\n      beforeEach(function () {\n        this.allowErrors()\n      })\n\n      it('errors without a server', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.eq('cy.respond() cannot be invoked before starting the `cy.server()`')\n\n          done()\n        })\n\n        cy.respond()\n      })\n\n      it('errors with no pending requests', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.eq('cy.respond() did not find any pending requests to respond to')\n\n          done()\n        })\n\n        cy\n        .server()\n        .route(/users/, {})\n        .window().then((win) => {\n          // this is waited on to be resolved\n          // because of jquery promise thenable\n          return win.$.get('/users')\n        })\n        .respond()\n      })\n    })\n  })\n\n  context('options immutability', () => {\n    it('does not mutate options for cy.server()', () => {\n      const options = { enable: false }\n\n      cy\n      .server(options)\n      .window().then(() => {\n        expect(options).to.deep.eq({ enable: false })\n      })\n    })\n\n    it('does not mutate options for cy.route()', () => {\n      const options = {\n        url: /foo/,\n        respond: false,\n      }\n\n      cy\n      .server()\n      .route(options)\n      .window().then(() => {\n        expect(options).to.deep.eq({\n          url: /foo/,\n          respond: false,\n        })\n      })\n    })\n  })\n})\n",
    "packages/driver/cypress/integration/cy/snapshot_css_spec.js": "const { $ } = Cypress\nconst $SnapshotsCss = require('../../../src/cy/snapshots_css')\n\nconst normalizeStyles = (styles) => {\n  return styles\n  .replace(/\\s+/gm, '')\n  .replace(/['\"]/gm, '\\'')\n}\n\nconst addStyles = (styles, to) => {\n  return new Promise((resolve) => {\n    $(styles).on('load', resolve).appendTo(cy.$$(to))\n  })\n}\n\ndescribe('driver/src/cy/snapshots_css', () => {\n  let snapshotCss\n\n  beforeEach(() => {\n    snapshotCss = $SnapshotsCss.create(cy.$$, cy.state)\n\n    cy.viewport(400, 600)\n    cy.visit('/fixtures/generic.html').then(() => {\n      return Cypress.Promise.all([\n        addStyles('<link rel=\"stylesheet\" href=\"/fixtures/generic_styles.css\" />', 'head'),\n        addStyles('<style>p { color: blue; }</style>', 'head'),\n        addStyles('<link media=\"screen\" rel=\"stylesheet\" href=\"http://localhost:3501/fixtures/generic_styles.css\" />', 'head'),\n        addStyles('<link media=\"print\" rel=\"stylesheet\" href=\"/fixtures/generic_styles_print.css\" />', 'head'),\n        addStyles('<link media=\"all\" rel=\"stylesheet\" href=\"/fixtures/generic_styles_2.css\" />', 'body'),\n        addStyles('<link rel=\"stylesheet\" href=\"/fixtures/generic_styles_3.css\" />', 'body'),\n      ])\n    })\n  })\n\n  context('.getStyleIds', () => {\n    it('returns IDs for cached CSS contents', () => {\n      const { headStyleIds, bodyStyleIds } = snapshotCss.getStyleIds()\n      const another = snapshotCss.getStyleIds()\n\n      expect(headStyleIds).to.have.length(3)\n      expect(headStyleIds[0]).to.eql({ hrefId: 'http://localhost:3500/fixtures/generic_styles.css' })\n\n      expect(bodyStyleIds).to.have.length(2)\n      expect(bodyStyleIds).to.eql([{ hrefId: 'http://localhost:3500/fixtures/generic_styles_2.css' }, { hrefId: 'http://localhost:3500/fixtures/generic_styles_3.css' }])\n      // IDs for 2 of the same stylesheets should have referential equality\n      expect(headStyleIds[0]).to.equal(another.headStyleIds[0])\n    })\n\n    it('returns strings for inline stylesheets', () => {\n      const { headStyleIds } = snapshotCss.getStyleIds()\n\n      expect(headStyleIds[1]).to.equal('p { color: blue; }')\n    })\n\n    it('returns { href } object for cross-origin stylesheets', () => {\n      const { headStyleIds } = snapshotCss.getStyleIds()\n\n      expect(headStyleIds[2]).to.eql({ href: 'http://localhost:3501/fixtures/generic_styles.css' })\n    })\n\n    it('works for media-less stylesheets', () => {\n      const { headStyleIds } = snapshotCss.getStyleIds()\n\n      expect(headStyleIds[0]).to.eql({ hrefId: 'http://localhost:3500/fixtures/generic_styles.css' })\n    })\n\n    it('works for media=screen stylesheets', () => {\n      const { headStyleIds } = snapshotCss.getStyleIds()\n\n      expect(headStyleIds[2]).to.eql({ href: 'http://localhost:3501/fixtures/generic_styles.css' })\n    })\n\n    it('works for media=all stylesheets', () => {\n      const { bodyStyleIds } = snapshotCss.getStyleIds()\n\n      expect(bodyStyleIds[0]).to.eql({ hrefId: 'http://localhost:3500/fixtures/generic_styles_2.css' })\n    })\n\n    it('ignores other media stylesheets', () => {\n      const { headStyleIds } = snapshotCss.getStyleIds()\n\n      expect(headStyleIds).to.have.length(3)\n    })\n\n    it('returns new id if css has been modified', () => {\n      const idsBefore = snapshotCss.getStyleIds()\n\n      cy.state('document').styleSheets[0].insertRule('.qux { color: orange; }')\n      snapshotCss.onCssModified('http://localhost:3500/fixtures/generic_styles.css')\n      const idsAfter = snapshotCss.getStyleIds()\n\n      expect(idsBefore.headStyleIds).to.have.length(3)\n      expect(idsAfter.headStyleIds).to.have.length(3)\n      expect(idsAfter.headStyleIds[0]).to.eql({ hrefId: 'http://localhost:3500/fixtures/generic_styles.css' })\n      // same href, but id should be referentially NOT equal\n      expect(idsBefore.headStyleIds[0]).not.to.equal(idsAfter.headStyleIds[0])\n    })\n\n    it('returns same id after css has been modified until a new window', () => {\n      cy.state('document').styleSheets[0].insertRule('.qux { color: orange; }')\n      snapshotCss.onCssModified('http://localhost:3500/fixtures/generic_styles.css')\n      const ids1 = snapshotCss.getStyleIds()\n      const ids2 = snapshotCss.getStyleIds()\n      const ids3 = snapshotCss.getStyleIds()\n\n      expect(ids1.headStyleIds[0]).to.eql({ hrefId: 'http://localhost:3500/fixtures/generic_styles.css' })\n      expect(ids1.headStyleIds[0]).to.equal(ids2.headStyleIds[0])\n      expect(ids2.headStyleIds[0]).to.equal(ids3.headStyleIds[0])\n\n      cy.state('document').styleSheets[0].deleteRule(0) // need to change contents or they will map to same id\n      snapshotCss.onBeforeWindowLoad()\n      const ids4 = snapshotCss.getStyleIds()\n\n      expect(ids4.headStyleIds[0]).to.eql({ hrefId: 'http://localhost:3500/fixtures/generic_styles.css' })\n      expect(ids3.headStyleIds[0]).not.to.equal(ids4.headStyleIds[0])\n    })\n\n    it('returns same id if css has been modified but yields same contents', () => {\n      const ids1 = snapshotCss.getStyleIds()\n\n      cy.state('document').styleSheets[0].insertRule('.qux { color: orange; }')\n      snapshotCss.onCssModified('http://localhost:3500/fixtures/generic_styles.css')\n      cy.state('document').styleSheets[0].deleteRule(0)\n      snapshotCss.onCssModified('http://localhost:3500/fixtures/generic_styles.css')\n\n      const ids2 = snapshotCss.getStyleIds()\n\n      expect(ids2.headStyleIds[0]).to.eql({ hrefId: 'http://localhost:3500/fixtures/generic_styles.css' })\n      expect(ids1.headStyleIds[0]).to.equal(ids2.headStyleIds[0])\n    })\n  })\n\n  context('.getStylesByIds', () => {\n    let getStyles\n\n    beforeEach(() => {\n      getStyles = () => {\n        const { headStyleIds, bodyStyleIds } = snapshotCss.getStyleIds()\n        const headStyles = snapshotCss.getStylesByIds(headStyleIds)\n        const bodyStyles = snapshotCss.getStylesByIds(bodyStyleIds)\n\n        return { headStyles, bodyStyles }\n      }\n    })\n\n    it('returns array of css styles for given ids', () => {\n      const { headStyles, bodyStyles } = getStyles()\n\n      expect(headStyles[0]).to.equal('.foo { color: green; }')\n      expect(headStyles[1]).to.equal('p { color: blue; }')\n      expect(bodyStyles[0]).to.eql('.bar { color: red; }')\n      expect(bodyStyles[1]).to.eql('.baz { color: purple; }')\n    })\n\n    it('returns { href } object for cross-origin stylesheets', () => {\n      const { headStyles } = getStyles()\n\n      expect(headStyles[2]).to.eql({ href: 'http://localhost:3501/fixtures/generic_styles.css' })\n    })\n\n    it('includes rules injected by JavaScript', () => {\n      const styleEl = document.createElement('style')\n\n      $(styleEl).appendTo(cy.$$('head'))\n      styleEl.sheet.insertRule('.foo { color: red; }', 0)\n\n      const { headStyles } = getStyles()\n\n      expect(headStyles[3]).to.equal('.foo { color: red; }')\n    })\n\n    it('replaces CSS paths of style tags with absolute paths', () => {\n      const styles = `\n      <style>\n        @font-face {\n          font-family: 'Some Font';\n          src: url('../fonts/some-font.eot');\n          src: url('../fonts/some-font.eot?#iefix') format('embedded-opentype'), url('../fonts/some-font.woff2') format('woff2'), url('../fonts/some-font.woff') format('woff'), url('../fonts/some-font.ttf') format('truetype'), url('../fonts/some-font.svg#glyphicons_halflingsregular') format('svg');\n        }\n      </style>\n    `\n\n      $(styles).appendTo(cy.$$('head'))\n\n      const { headStyles } = getStyles()\n\n      expect(normalizeStyles(headStyles[3])).to.include(normalizeStyles(`\n        @font-face {\n          font-family: \"Some Font\";\n          src: url('http://localhost:3500/fonts/some-font.eot?#iefix') format(\"embedded-opentype\"), url('http://localhost:3500/fonts/some-font.woff2') format(\"woff2\"), url('http://localhost:3500/fonts/some-font.woff') format(\"woff\"), url('http://localhost:3500/fonts/some-font.ttf') format(\"truetype\"), url('http://localhost:3500/fonts/some-font.svg#glyphicons_halflingsregular') format(\"svg\");\n        }\n      `))\n    })\n\n    it('replaces CSS paths of local stylesheets with absolute paths', () => {\n      return addStyles('<link rel=\"stylesheet\" href=\"nested/with_paths.css\" />', 'head').then(() => {\n        const { headStyles } = getStyles()\n\n        expect(normalizeStyles(headStyles[3])).to.include(normalizeStyles(`\n          @font-face {\n            font-family: 'Some Font';\n            src: url('http://localhost:3500/fixtures/fonts/some-font.eot?#iefix') format('embedded-opentype'), url('http://localhost:3500/fixtures/fonts/some-font.woff2') format('woff2'), url('http://localhost:3500/fixtures/fonts/some-font.woff') format('woff'), url('http://localhost:3500/fixtures/fonts/some-font.ttf') format('truetype'), url('http://localhost:3500/fixtures/fonts/some-font.svg#glyphicons_halflingsregular') format('svg');\n          }\n        `))\n      })\n    })\n  })\n})\n",
    "packages/driver/cypress/integration/e2e/focus_blur_spec.js": "/* eslint arrow-body-style:'off' */\n\n/**\n  * in all browsers...\n  *\n  * activeElement is always programmatically respected and behaves identical whether window is in or out of focus\n  *\n  * browser: chrome...\n  *\n  * scenario 1: given '#one' is activeElement call programmatic el.focus() on '#two'\n  * - if window is in focus\n  *   - blur will fire on '#one'\n  *   - focus will fire on '#two'\n  * - if window is out of focus (the event wil be primed until the window receives focus again)\n  *   - by clicking anywhere on the <body> (not on the element)...\n  *     - focus on '#two' will fire first\n  *     - blur on '#two' will fire second\n  *     - activeElement will now be <body>\n  *   - by clicking on another element that is focusable\n  *     - focus on '#two' is first sent\n  *     - blur on '#two' is then sent\n  *     - focus is finally sent on the new focusable element we clicked\n  *   - if instead on clicking we programmatically call .focus() back to '#one'\n  *     - focus is fired on '#one'\n  *     - if we were to instead click directly on '#one' then no focus or blur events are fired\n  *     - if when clicking directly back to '#one' we prevent the 'mousedown' event\n  *       - the focus event will fire AND the element will still be activeElement\n  *       - had we not programmatically call .focus() ahead of time, then the focus event would\n  *         have been not fired, and our activeElement would not have changed\n  *\n  * scenario 2 : given '#one' is activeElement call programmatic el.blur() on '#one'\n  * - if window is in focus\n  *   - blur will fire on '#one'\n  * - if window is out of focus\n  *   - no events will ever fire even when regaining focus\n\n  * browser: firefox...\n  *   - no focus events are queued when programmatically calling element.focus() AND the window is out of focus. the events evaporate into the ether.\n  *   - however, if calling window.focus() programmatically prior to programmatic element.focus() calls will fire all events as if the window is natively in focus\n*/\nconst { _ } = Cypress\n\nconst chaiSubset = require('chai-subset')\n\nchai.use(chaiSubset)\n\nconst windowHasFocus = function () {\n  if (top.document.hasFocus()) return true\n\n  let hasFocus = false\n\n  window.addEventListener('focus', function () {\n    hasFocus = true\n  })\n\n  window.focus()\n\n  return hasFocus\n}\n\nconst requireWindowInFocus = () => {\n  let hasFocus = windowHasFocus()\n\n  if (!hasFocus) {\n    expect(hasFocus, 'this test requires the window to be in focus').ok\n  }\n}\n\nit('can intercept blur/focus events', () => {\n  // Browser must be in focus\n\n  const focus = cy.spy(window.top.HTMLElement.prototype, 'focus')\n  const blur = cy.spy(window.top.HTMLElement.prototype, 'blur')\n\n  const handleFocus = cy.stub().as('handleFocus')\n  const handleBlur = cy.stub().as('handleBlur')\n\n  const resetStubs = () => {\n    focus.resetHistory()\n    blur.resetHistory()\n    handleFocus.resetHistory()\n    handleBlur.resetHistory()\n  }\n\n  cy\n  .visit('http://localhost:3500/fixtures/active-elements.html')\n  .then(() => {\n    requireWindowInFocus()\n\n    expect(cy.getFocused()).to.be.null\n\n    // programmatically focus the first, then second input element\n\n    const one = cy.$$('#one')[0]\n    const two = cy.$$('#two')[0]\n\n    one.addEventListener('focus', handleFocus)\n    two.addEventListener('focus', handleFocus)\n    one.addEventListener('blur', handleBlur)\n    two.addEventListener('blur', handleBlur)\n\n    one.focus()\n\n    expect(focus).to.calledOnce\n    expect(handleFocus).calledOnce\n    expect(blur).not.called\n    expect(handleBlur).not.called\n\n    resetStubs()\n\n    one.focus()\n\n    expect(focus).to.calledOnce\n    expect(handleFocus).not.called\n    expect(blur).not.called\n    expect(handleBlur).not.called\n\n    resetStubs()\n\n    one.blur()\n\n    expect(blur).calledOnce\n    expect(handleBlur).calledOnce\n\n    resetStubs()\n\n    one.blur()\n\n    expect(blur).calledOnce\n    expect(handleBlur).not.called\n  })\n})\n\nit('blur the activeElement when clicking the body', () => {\n  cy\n  .visit('http://localhost:3500/fixtures/active-elements.html')\n  .then(() => {\n    const events = []\n\n    expect(cy.getFocused()).to.be.null\n\n    const doc = cy.state('document')\n\n    // programmatically focus the first, then second input element\n    const $body = cy.$$('body')\n    const $one = cy.$$('#one')\n    const $two = cy.$$('#two');\n\n    ['focus', 'blur'].forEach((evt) => {\n      $one.on(evt, (e) => {\n        events.push(e.originalEvent)\n      })\n\n      $two.on(evt, (e) => {\n        events.push(e.originalEvent)\n      })\n    })\n\n    $one.get(0).focus()\n    $two.get(0).focus()\n\n    cy.then(() => {\n      // if we currently have focus it means\n      // that the browser should fire the\n      // native event immediately\n      expect(events).to.have.length(3)\n\n      expect(_.toPlainObject(events[0])).to.include({\n        type: 'focus',\n        isTrusted: true,\n        target: $one.get(0),\n      })\n\n      expect(_.toPlainObject(events[1])).to.include({\n        type: 'blur',\n        isTrusted: true,\n        target: $one.get(0),\n      })\n\n      expect(_.toPlainObject(events[2])).to.include({\n        type: 'focus',\n        isTrusted: true,\n        target: $two.get(0),\n      })\n    })\n\n    cy\n    .get('body').click()\n    .then(() => {\n      expect(doc.activeElement).to.eq($body.get(0))\n    })\n\n    cy.then(() => {\n      // if we had focus then no additional\n      // focus event is necessary\n      expect(events).to.have.length(4)\n\n      expect(_.toPlainObject(events[3])).to.include({\n        type: 'blur',\n        isTrusted: true,\n        target: $two.get(0),\n      })\n    })\n  })\n})\n\ndescribe('polyfill programmatic blur events', () => {\n  // restore these props for the rest of the tests\n  let stubElementFocus\n  let stubElementBlur\n  let stubSVGFocus\n  let stubSVGBlur\n  let stubHasFocus\n  let oldActiveElement = null\n\n  const setActiveElement = (el) => {\n    Object.defineProperty(cy.state('document'), 'activeElement', {\n      get () {\n        return el\n      },\n      configurable: true,\n    })\n  }\n\n  beforeEach(() => {\n    oldActiveElement = Object.getOwnPropertyDescriptor(window.Document.prototype, 'activeElement')\n\n    // simulate window being out of focus by overwriting\n    // the focus/blur methods on HTMLElement\n    stubHasFocus = cy.stub(window.top.document, 'hasFocus').returns(false)\n\n    stubElementFocus = cy.stub(window.top.HTMLElement.prototype, 'focus')\n    stubElementBlur = cy.stub(window.top.HTMLElement.prototype, 'blur')\n    stubSVGFocus = cy.stub(window.top.SVGElement.prototype, 'focus')\n    stubSVGBlur = cy.stub(window.top.SVGElement.prototype, 'blur')\n  })\n\n  afterEach(() => {\n    Object.defineProperty(window.Document.prototype, 'activeElement', oldActiveElement)\n    stubHasFocus.restore()\n    stubElementFocus.restore()\n    stubElementBlur.restore()\n    stubSVGFocus.restore()\n    stubSVGBlur.restore()\n  })\n\n  // https://github.com/cypress-io/cypress/issues/1486\n  it('simulated events when window is out of focus when .focus called', () => {\n    cy\n    .visit('http://localhost:3500/fixtures/active-elements.html')\n    .then(() => {\n      // programmatically focus the first, then second input element\n      const $one = cy.$$('#one')\n      const $two = cy.$$('#two')\n\n      const stub = cy.stub().as('focus/blur event').callsFake(() => {\n        Cypress.log({})\n      });\n\n      ['focus', 'blur'].forEach((evt) => {\n        $one.on(evt, stub)\n\n        return $two.on(evt, stub)\n      })\n\n      $one.get(0).focus()\n      // a hack here becuase we nuked the real .focus\n      setActiveElement($one.get(0))\n\n      $two.get(0).focus()\n      // cy.get('#two').click()\n\n      const getEvent = (n) => {\n        return stub.getCall(n).args[0].originalEvent\n      }\n\n      cy.wrap(null).then(() => {\n        expect(stub).to.be.calledThrice\n\n        expect(getEvent(0)).to.containSubset({\n          type: 'focus',\n          target: $one.get(0),\n          isTrusted: false,\n        })\n\n        expect(getEvent(1)).to.containSubset({\n          type: 'blur',\n          target: $one.get(0),\n          isTrusted: false,\n        })\n\n        expect(getEvent(2)).to.containSubset({\n          type: 'focus',\n          target: $two.get(0),\n          isTrusted: false,\n        })\n      })\n      .then(() => {\n        stub.resetHistory()\n\n        setActiveElement($two.get(0))\n\n        $two.get(0).focus()\n\n        expect(stub, 'should not send focus if already focused el').not.called\n      })\n    })\n  })\n\n  // https://github.com/cypress-io/cypress/issues/1176\n  it('simulated events when window is out of focus when .blur called', () => {\n    cy\n    .visit('http://localhost:3500/fixtures/active-elements.html')\n    .then(() => {\n      // programmatically focus the first, then second input element\n      const $one = cy.$$('#one')\n      const $two = cy.$$('#two')\n\n      const stub = cy.stub().as('focus/blur event');\n\n      ['focus', 'blur'].forEach((evt) => {\n        $one.on(evt, stub)\n\n        $two.on(evt, stub)\n      })\n\n      $one.get(0).focus()\n\n      // a hack here becuase we nuked the real .focus\n      setActiveElement($one.get(0))\n\n      $one.get(0).blur()\n\n      cy.then(() => {\n        expect(stub).calledTwice\n\n        expect(_.toPlainObject(stub.getCall(0).args[0].originalEvent)).to.containSubset({\n          type: 'focus',\n          target: $one.get(0),\n          isTrusted: false,\n        })\n\n        expect(_.toPlainObject(stub.getCall(1).args[0].originalEvent)).to.containSubset({\n          type: 'blur',\n          target: $one.get(0),\n          isTrusted: false,\n        })\n      })\n\n      .then(() => {\n        stub.resetHistory()\n\n        setActiveElement(cy.$$('body').get(0))\n\n        $one.get(0).blur()\n\n        expect(stub, 'should not send blur if not focused el').not.called\n      })\n    })\n  })\n\n  // https://github.com/cypress-io/cypress/issues/1486\n  it('SVGElement simulated events when window is out of focus when .focus called', () => {\n    cy\n    .visit('http://localhost:3500/fixtures/active-elements.html')\n    .then(() => {\n      // programmatically focus the first, then second input element\n\n      const $one = cy.$$(`<svg id=\"svg-one\" tabindex width=\"100\" height=\"100\">\n      <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"green\" stroke-width=\"4\" fill=\"yellow\" />\n    </svg>`).appendTo(cy.$$('body'))\n      const $two = cy.$$(`<svg id=\"svg-two\" tabindex width=\"100\" height=\"100\">\n      <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"green\" stroke-width=\"4\" fill=\"yellow\" />\n    </svg>`).appendTo(cy.$$('body'))\n\n      const stub = cy.stub().as('focus/blur event').callsFake(() => {\n        Cypress.log({})\n      });\n\n      ['focus', 'blur'].forEach((evt) => {\n        $one.on(evt, stub)\n\n        return $two.on(evt, stub)\n      })\n\n      $one.get(0).focus()\n      // a hack here becuase we nuked the real .focus\n      setActiveElement($one.get(0))\n\n      $two.get(0).focus()\n      // cy.get('#two').click()\n\n      const getEvent = (n) => {\n        return stub.getCall(n).args[0].originalEvent\n      }\n\n      cy.wrap(null).then(() => {\n        expect(stub).to.be.calledThrice\n\n        expect(getEvent(0)).to.containSubset({\n          type: 'focus',\n          target: $one.get(0),\n          isTrusted: false,\n        })\n\n        expect(getEvent(1)).to.containSubset({\n          type: 'blur',\n          target: $one.get(0),\n          isTrusted: false,\n        })\n\n        expect(getEvent(2)).to.containSubset({\n          type: 'focus',\n          target: $two.get(0),\n          isTrusted: false,\n        })\n      })\n      .then(() => {\n        stub.resetHistory()\n\n        setActiveElement($two.get(0))\n\n        $two.get(0).focus()\n\n        expect(stub, 'should not send focus if already focused el').not.called\n      })\n    })\n  })\n\n  // https://github.com/cypress-io/cypress/issues/1176\n  it('SVGElement simulated events when window is out of focus when .blur called', () => {\n    cy\n    .visit('http://localhost:3500/fixtures/active-elements.html')\n    .then(() => {\n      // programmatically focus the first, then second input element\n\n      const $one = cy.$$(`<svg id=\"svg-one\" tabindex width=\"100\" height=\"100\">\n      <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"green\" stroke-width=\"4\" fill=\"yellow\" />\n    </svg>`).appendTo(cy.$$('body'))\n      const $two = cy.$$(`<svg id=\"svg-two\" tabindex width=\"100\" height=\"100\">\n      <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"green\" stroke-width=\"4\" fill=\"yellow\" />\n    </svg>`).appendTo(cy.$$('body'))\n      const stub = cy.stub().as('focus/blur event');\n\n      ['focus', 'blur'].forEach((evt) => {\n        $one.on(evt, stub)\n\n        $two.on(evt, stub)\n      })\n\n      $one.get(0).focus()\n\n      // a hack here becuase we nuked the real .focus\n      setActiveElement($one.get(0))\n\n      $one.get(0).blur()\n\n      cy.then(() => {\n        expect(stub).calledTwice\n\n        expect(_.toPlainObject(stub.getCall(0).args[0].originalEvent)).to.containSubset({\n          type: 'focus',\n          target: $one.get(0),\n          isTrusted: false,\n        })\n\n        expect(_.toPlainObject(stub.getCall(1).args[0].originalEvent)).to.containSubset({\n          type: 'blur',\n          target: $one.get(0),\n          isTrusted: false,\n        })\n      })\n\n      .then(() => {\n        stub.resetHistory()\n\n        setActiveElement(cy.$$('body').get(0))\n\n        $one.get(0).blur()\n\n        expect(stub, 'should not send blur if not focused el').not.called\n      })\n    })\n  })\n\n  it('document.hasFocus() always returns true', () => {\n    cy.visit('http://localhost:3500/fixtures/active-elements.html')\n    cy.document().then((doc) => {\n      expect(doc.hasFocus(), 'hasFocus returns true').eq(true)\n    })\n  })\n\n  it('does not send focus events for non-focusable elements', () => {\n    cy.visit('http://localhost:3500/fixtures/active-elements.html')\n    .then(() => {\n      cy.$$('<div id=\"no-focus\">clearly not a focusable element</div>')\n      .appendTo(cy.$$('body'))\n\n      const stub = cy.stub()\n      const el1 = cy.$$('#no-focus')\n      const win = cy.$$(cy.state('window'))\n\n      win.on('focus', stub)\n      el1.on('focus', stub)\n      el1[0].focus()\n\n      expect(stub).not.called\n    })\n  })\n})\n\ndescribe('intercept blur methods correctly', () => {\n  beforeEach(() => {\n    cy.visit('http://localhost:3500/fixtures/active-elements.html').then(() => {\n      top.focus()\n\n      cy.$$('input:first')[0].focus()\n      cy.document().then((doc) => {\n        // we need to wait for initial selectionchange event on input:first\n        // which sets up the state for the tests\n        // NOTE: initial selectionchange event does not fire in firefox\n        if (!Cypress.isBrowser({ family: 'firefox' })) {\n          return new Promise((resolve) => doc.onselectionchange = resolve)\n        }\n      })\n\n      cy.document().then((doc) => {\n        doc.onselectionchange = cy.stub()\n        .as('selectionchange')\n      })\n    })\n  })\n\n  it('focus  <a>', () => {\n    const $el = cy.$$('<a href=\"#\">foo</a>')\n\n    $el.appendTo(cy.$$('body'))\n\n    cy.wrap($el[0]).focus()\n    .should('have.focus')\n\n    if (Cypress.isBrowser('firefox')) {\n      cy.wait(0).get('@selectionchange').should('be.called')\n\n      return\n    }\n\n    cy.wait(10).get('@selectionchange').should('not.be.called')\n  })\n\n  it('focus <select>', () => {\n    const $el = cy.$$('<select>')\n\n    $el.appendTo(cy.$$('body'))\n    $el[0].focus()\n    cy.wrap($el[0]).focus()\n    .should('have.focus')\n\n    if (Cypress.isBrowser('firefox')) {\n      cy.wait(0).get('@selectionchange').should('be.called')\n\n      return\n    }\n\n    cy.wait(10).get('@selectionchange').should('not.be.called')\n  })\n\n  it('focus <button>', () => {\n    const $el = cy.$$('<button/>')\n\n    $el.appendTo(cy.$$('body'))\n    $el[0].focus()\n    cy.wrap($el[0]).focus()\n    .should('have.focus')\n\n    if (Cypress.isBrowser('firefox')) {\n      cy.wait(0).get('@selectionchange').should('be.called')\n\n      return\n    }\n\n    cy.wait(10).get('@selectionchange').should('not.be.called')\n  })\n\n  it('focus <iframe>', () => {\n    const $el = cy.$$('<iframe src=\"\" />')\n\n    $el.appendTo(cy.$$('body'))\n    $el[0].focus()\n    cy.wrap($el[0]).focus()\n    .should('have.focus')\n\n    cy.wait(0).get('@selectionchange').should('not.be.called')\n  })\n\n  it('focus [tabindex]', () => {\n    const $el = cy.$$('<div tabindex=\"1\">tabindex</div>')\n\n    $el.appendTo(cy.$$('body'))\n    $el[0].focus()\n\n    if (Cypress.isBrowser('firefox')) {\n      cy.wait(0).get('@selectionchange').should('be.called')\n\n      return\n    }\n\n    cy.wait(0).get('@selectionchange').should('not.be.called')\n  })\n\n  it('focus <textarea>', () => {\n    const $el = cy.$$('<textarea/>')\n\n    $el.appendTo(cy.$$('body'))\n    $el[0].focus()\n    cy.wrap($el[0]).focus()\n    .should('have.focus')\n\n    cy.get('@selectionchange').should('be.called')\n  })\n\n  it('focus [contenteditable]', () => {\n    const $el = cy.$$('<div contenteditable>contenteditable</div>')\n\n    $el.appendTo(cy.$$('body'))\n    $el[0].focus()\n\n    cy.get('@selectionchange').should('be.called')\n  })\n\n  it('cannot focus a [contenteditable] child', () => {\n    const outer = cy.$$('<div contenteditable>contenteditable</div>').appendTo(cy.$$('body'))\n    const inner = cy.$$('<div>first inner contenteditable</div>').appendTo(outer)\n\n    cy.$$('<div>second inner contenteditable</div>').appendTo(outer)\n\n    cy.get('input:first').focus()\n    .wait(0)\n    .get('@selectionchange').then((stub) => stub.resetHistory())\n\n    cy.wrap(inner).should(($el) => $el.focus)\n    .wait(0)\n\n    cy.get('input:first').should('have.focus')\n\n    cy.get('@selectionchange').should('not.be.called')\n  })\n\n  it('focus svg', () => {\n    const $svg = cy.$$(`<svg tabindex=\"1\" width=\"900px\" height=\"500px\" viewBox=\"0 0 95 50\" style=\"border: solid red 1px;\"\n      xmlns=\"http://www.w3.org/2000/svg\">\n     <g data-Name=\"group\" stroke=\"green\" fill=\"white\" stroke-width=\"5\" data-tabindex=\"0\" >\n       <a xlink:href=\"#\">\n         <circle cx=\"20\" cy=\"25\" r=\"5\" data-Name=\"shape 1\"  data-tabindex=\"0\" />\n       </a>\n       <a xlink:href=\"#\">\n         <circle cx=\"40\" cy=\"25\" r=\"5\" data-Name=\"shape 2\"  data-tabindex=\"0\" />\n       </a>\n       <a xlink:href=\"#\">\n         <circle cx=\"60\" cy=\"25\" r=\"5\" data-Name=\"shape 3\" data-tabindex=\"0\" />\n       </a>\n       <a xlink:href=\"#\">\n         <circle cx=\"80\" cy=\"25\" r=\"5\" data-Name=\"shape 4\" data-tabindex=\"0\" />\n       </a>\n     </g>\n  </svg>`).appendTo(cy.$$('body'))\n\n    cy.wrap($svg).focus().should('have.focus')\n  })\n\n  it('focus area', () => {\n    cy.visit('http://localhost:3500/fixtures/active-elements.html').then(() => {\n      cy.$$(`\n      <map name=\"map\">\n      <area shape=\"circle\" coords=\"0,0,100\"\n      href=\"#\"\n      target=\"_blank\" alt=\"area\" />\n      </map>\n      <img usemap=\"#map\" src=\"/__cypress/static/favicon.ico\" alt=\"image\" />\n      `).appendTo(cy.$$('body'))\n\n      cy.get('area')\n\n      // make sure the element can receive focus then reset activeElement with blur\n      // without this firefox can fail due to <area> not being ready to receive focus\n      // seems unrelated to 'load' state\n      .should(($el) => {\n        $el.focus()\n        expect($el).be.focused\n        $el.blur()\n      })\n\n      // do the actual test now\n      .focus()\n      .should('have.focus')\n    })\n  })\n\n  // W3C Hidden @see html.spec.whatwg.org/multipage/interaction.html#focusable-area\n  // fix https://github.com/cypress-io/cypress/issues/4898\n  it('does not send focus events for focusable elements that are w3c hidden', () => {\n    cy.visit('http://localhost:3500/fixtures/active-elements.html')\n    .then(() => {\n      cy.$$('<input style=\"visibility:hidden\" id=\"no-focus-1\"/>')\n      .appendTo(cy.$$('body'))\n\n      cy.$$('<input style=\"display:none\" id=\"no-focus-2\"/>')\n      .appendTo(cy.$$('body'))\n\n      cy.$$('<div style=\"visibility:hidden\"><input id=\"no-focus-3\"/></div>')\n      .appendTo(cy.$$('body'))\n\n      cy.$$('<div style=\"display:none\"><input id=\"no-focus-4\"/></div>')\n      .appendTo(cy.$$('body'))\n\n      const stub = cy.stub().as('focus')\n\n      cy.$$('#no-focus-1').on('focus', stub).get(0).focus()\n      cy.$$('#no-focus-2').on('focus', stub).get(0).focus()\n      cy.$$('#no-focus-3').on('focus', stub).get(0).focus()\n      cy.$$('#no-focus-4').on('focus', stub).get(0).focus()\n\n      expect(stub).not.called\n\n      cy.get('#no-focus-1').should('not.be.visible')\n      cy.get('#no-focus-2').should('not.be.visible')\n      cy.get('#no-focus-3').should('not.be.visible')\n      cy.get('#no-focus-4').should('not.be.visible')\n    })\n  })\n\n  // W3C Hidden @see html.spec.whatwg.org/multipage/interaction.html#focusable-area\n  // fix https://github.com/cypress-io/cypress/issues/4898\n  it('does send focus events for focusable elements that are 0x0 size', () => {\n    cy.visit('http://localhost:3500/fixtures/active-elements.html')\n    .then(() => {\n      cy.$$('<input style=\"width:0;height:0;padding:0;margin:0;border:0;outline:0\" id=\"focus-1\"/>')\n      .appendTo(cy.$$('body'))\n\n      const stub = cy.stub()\n\n      cy.$$('#focus-1')\n      .on('focus', stub)\n      .get(0).focus()\n\n      expect(stub).calledOnce\n\n      cy.get('#focus-1').should('not.be.visible')\n    })\n  })\n})\n",
    "packages/driver/cypress/integration/e2e/promises_spec.js": "describe('promises', () => {\n  beforeEach(function () {\n    this.warn = cy.spy(Cypress.Promise.prototype, '_warn')\n  })\n\n  afterEach(function () {\n    expect(this.warn).not.to.be.calledOnce\n  })\n\n  it('warns when returning a promise and calling cypress commands', () => {\n    cy.spy(top.console, 'warn')\n\n    const title = cy.state('runnable').fullTitle()\n\n    return Cypress.Promise.delay(10)\n    .then(() => {\n      cy.wrap({})\n      cy.wrap([])\n\n      return cy.wrap('lol')\n      .then(() => {\n        const msg = top.console.warn.firstCall.args[0]\n\n        expect(msg).to.include('Cypress detected that you returned a promise in a test, but also invoked one or more cy commands inside of that promise.')\n        expect(msg).to.include(title)\n        expect(msg).to.include('https://on.cypress.io/returning-promise-and-commands-in-test')\n\n        expect(top.console.warn).to.be.calledOnce\n      })\n    })\n  })\n\n  it('warns when instantiating a promise and calling cypress commands', () => {\n    cy.spy(top.console, 'warn')\n\n    const title = cy.state('runnable').fullTitle()\n\n    return new Cypress.Promise((resolve) => {\n      cy.wrap({})\n      cy.wrap([])\n\n      return cy.wrap('lol')\n      .then(resolve)\n    }).then(() => {\n      const msg = top.console.warn.firstCall.args[0]\n\n      expect(msg).to.include('Cypress detected that you returned a promise in a test, but also invoked one or more cy commands inside of that promise.')\n      expect(msg).to.include(title)\n      expect(msg).to.include('https://on.cypress.io/returning-promise-and-commands-in-test')\n\n      expect(top.console.warn).to.be.calledOnce\n    })\n  })\n\n  it('throws when returning a promise from a custom command', function (done) {\n    const logs = []\n\n    cy.on('log:added', (attrs, log) => {\n      this.lastLog = log\n\n      return logs.push(log)\n    })\n\n    cy.on('fail', (err) => {\n      const { lastLog } = this\n\n      expect(logs.length).to.eq(1)\n      expect(lastLog.get('name')).to.eq('foo')\n      expect(lastLog.get('error')).to.eq(err)\n\n      expect(err.message).to.include('Cypress detected that you returned a promise from a command while also invoking one or more cy commands in that promise.')\n      expect(err.message).to.include('> `cy.foo()`')\n      expect(err.message).to.include('> `cy.wrap()`')\n      expect(err.docsUrl).to.eq('https://on.cypress.io/returning-promise-and-commands-in-another-command')\n\n      return done()\n    })\n\n    Cypress.Commands.add('foo', () => {\n      return Cypress.Promise\n      .delay(10)\n      .then(() => {\n        return cy.wrap({})\n      })\n    })\n\n    return cy.foo()\n  })\n\n  it('throws when instantiating a promise from a custom command', function (done) {\n    const logs = []\n\n    cy.on('log:added', (attrs, log) => {\n      this.lastLog = log\n\n      return logs.push(log)\n    })\n\n    cy.on('fail', (err) => {\n      const { lastLog } = this\n\n      expect(logs.length).to.eq(1)\n      expect(lastLog.get('name')).to.eq('foo')\n      expect(lastLog.get('error')).to.eq(err)\n\n      expect(err.message).to.include('Cypress detected that you returned a promise from a command while also invoking one or more cy commands in that promise.')\n      expect(err.message).to.include('> `cy.foo()`')\n      expect(err.message).to.include('> `cy.wrap()`')\n\n      return done()\n    })\n\n    Cypress.Commands.add('foo', () => {\n      return new Cypress.Promise((resolve) => {\n        return cy.wrap({}).then(resolve)\n      })\n    })\n\n    return cy.foo()\n  })\n\n  it('is okay to return promises from custom commands with no cy commands', () => {\n    Cypress.Commands.add('foo', () => {\n      return Cypress.Promise\n      .delay(10)\n    })\n\n    return cy.foo()\n  })\n\n  it('can return a promise that throws on its own without warning', () => {\n    return Cypress.Promise\n    .delay(10)\n    .then(() => {\n      return cy.wrap({}).should('deep.eq', {})\n    }).then((obj) => {\n      expect(obj).to.deep.eq({})\n\n      throw new Error('foo')\n    }).catch(() => {})\n  })\n\n  it('can still fail cypress commands', (done) => {\n    cy.on('fail', (err) => {\n      expect(err.message).to.eq('foo')\n\n      return done()\n    })\n\n    Cypress.Promise\n    .delay(10)\n    .then(() => {\n      return cy.wrap({}).then(() => {\n        throw new Error('foo')\n      })\n    })\n  })\n})\n",
    "packages/driver/cypress/integration/e2e/zonejs_spec.js": "// https://github.com/cypress-io/cypress/issues/741\ndescribe('zone.js', () => {\n  it('can serialize XHRs without blowing out the stack', () => {\n    cy\n    .visit('/fixtures/zonejs.html')\n    .window().then({ timeout: 30000 }, (win) => {\n      return new Promise((resolve, reject) => {\n        const xhr = new win.XMLHttpRequest()\n\n        xhr.open('HEAD', '/')\n        xhr.send()\n\n        xhr.onload = () => {\n          try {\n            Cypress.Log.toSerializedJSON(xhr)\n\n            resolve()\n          } catch (err) {\n            reject(err)\n          }\n        }\n      })\n    })\n  })\n})\n",
    "packages/driver/cypress/integration/issues/2784_spec.js": "// https://github.com/cypress-io/cypress/issues/2784\ndescribe('issue #2784', () => {\n  it('does not throw when embedding a cross origin iframe', () => {\n    cy.visit('/fixtures/generic.html')\n    cy.document().then((doc) => {\n      return new Cypress.Promise((resolve) => {\n        const iframe = doc.createElement('iframe')\n\n        iframe.onload = resolve\n        iframe.src = 'http://localhost:3501/fixtures/generic.html'\n        doc.body.appendChild(iframe)\n      })\n    })\n\n    // change the subject to be <window>\n    cy.window()\n    cy.get('a').should('be.visible')\n  })\n})\n",
    "packages/driver/cypress/integration/issues/573_spec.js": "const run = () => {\n  cy.window()\n  .then({ timeout: 60000 }, (win) => {\n    return new Cypress.Promise((resolve) => {\n      const i = win.document.createElement('iframe')\n\n      i.onload = resolve\n      // ?foo is necessary for firefox b/c it won't load a nested\n      // iframe with an identical url\n      i.src = '/basic_auth?foo'\n\n      return win.document.body.appendChild(i)\n    })\n  })\n  .get('iframe').should(($iframe) => {\n    expect($iframe.contents().text()).to.include('basic auth worked')\n  })\n  .window().then({ timeout: 60000 }, (win) => {\n    return new Cypress.Promise(((resolve, reject) => {\n      const xhr = new win.XMLHttpRequest()\n\n      xhr.open('GET', '/basic_auth')\n      xhr.onload = function () {\n        try {\n          expect(this.responseText).to.include('basic auth worked')\n\n          return resolve(win)\n        } catch (err) {\n          return reject(err)\n        }\n      }\n\n      return xhr.send()\n    }))\n  })\n  .then({ timeout: 60000 }, (win) => {\n    return new Cypress.Promise(((resolve, reject) => {\n      // ensure other origins do not have auth headers attached\n      const xhr = new win.XMLHttpRequest()\n\n      xhr.open('GET', 'http://localhost:3501/basic_auth')\n      xhr.onload = function () {\n        try {\n          expect(this.status).to.eq(401)\n\n          return resolve(win)\n        } catch (err) {\n          return reject(err)\n        }\n      }\n\n      return xhr.send()\n    }))\n  })\n}\n\n// cy.visit(\"http://admin:admin@the-internet.herokuapp.com/basic_auth\")\n\ndescribe('basic auth', () => {\n  it('can visit with username/pw in url', () => {\n    cy.visit('http://cypress:password123@localhost:3500/basic_auth')\n\n    run()\n  })\n\n  it('can visit with auth options', () => {\n    cy.visit('http://localhost:3500/basic_auth', {\n      auth: {\n        username: 'cypress',\n        password: 'password123',\n      },\n    })\n\n    run()\n  })\n})\n",
    "packages/driver/cypress/integration/issues/761_2968_3973_spec.js": "// https://github.com/cypress-io/cypress/issues/761\ndescribe('issue #761 - aborted XHRs from previous tests', () => {\n  context('aborted when complete', () => {\n    it('test 1 dispatches xhr, but completes in test 2', () => {\n      cy.window().then((win) => {\n        const xhr = new win.XMLHttpRequest()\n\n        xhr.open('GET', '/timeout?ms=1000')\n        xhr.onload = () => {\n          // we are in test 2 at this point\n          // and should not throw\n          xhr.abort()\n        }\n\n        xhr.send()\n      })\n    })\n\n    it('test 2 aborts the completed XHR', () => {\n      cy.wait(2000)\n    })\n  })\n\n  context('aborted before complete', () => {\n    let xhr = null\n\n    // TODO: we lose a reference here to the xhr in test 2\n    // so it shows up as \"pending\" forever because we reset\n    // the proxied XHR's as references when the next test starts\n    it('test 1 dispatches xhr, but completes in test 2', () => {\n      cy.window().then((win) => {\n        xhr = new win.XMLHttpRequest()\n\n        xhr.open('GET', '/timeout?ms=1000')\n        xhr.send()\n      })\n    })\n\n    it('test 2 aborts the incomplete XHR which is currently in flight', () => {\n      // we are in test 2 at this point\n      // and should not throw when we\n      // abort the incomplete xhr\n      expect(xhr.aborted).not.to.be.true\n\n      xhr.abort()\n    })\n  })\n})\n\n// as of chrome 71, chrome no longer fires\n// readyState or abort events synchronously\n// when the document unloads. instead we must\n// assume they are aborting the request and\n// simply check to ensure the XHR has been\n// canceled internally by Cypress\n// https://github.com/cypress-io/cypress/issues/3973\nif (Cypress.isBrowser('chrome')) {\n  describe('issue #3973 - unloaded xhrs do not fire readystatechange event in chrome >= 71', () => {\n    it('cancels pending requests that are incomplete', () => {\n      const logs = []\n\n      const xhrs = []\n      const stub = cy.stub()\n\n      cy.on('log:added', (attrs, log) => {\n        if (attrs.name === 'xhr') {\n          logs.push(log)\n        }\n      })\n\n      cy\n      .server()\n      .route('GET', /timeout/).as('getTimeout')\n      .visit('http://localhost:3500/fixtures/generic.html')\n      .window()\n      .then((win) => {\n        const xhr = new win.XMLHttpRequest()\n\n        xhrs.push(xhr)\n\n        xhr.open('GET', '/timeout?ms=100')\n        xhr.send()\n      })\n      .wait('@getTimeout')\n      .window()\n      .then((win) => {\n        return new Promise((resolve) => {\n          cy.on('window:unload', resolve)\n\n          const xhr = new win.XMLHttpRequest()\n\n          xhrs.push(xhr)\n\n          xhr.open('GET', '/timeout?ms=2000')\n\n          xhr.abort = stub // this should not get called\n          xhr.onerror = stub // this should not fire\n          xhr.onload = stub // this should not fire\n\n          xhr.send()\n\n          win.location.reload()\n        })\n      })\n      .wait('@getTimeout')\n      .then((xhrProxy) => {\n      // after we unload we should cancel the\n      // pending XHR's and receive it here\n      // after waiting on it\n        expect(xhrProxy.canceled).to.be.true\n\n        const [firstXhr, secondXhr] = xhrs\n        const [firstLog, secondLog] = logs\n\n        // should be the same XHR here as the proxy's XHR\n        expect(secondXhr === xhrProxy.xhr).to.be.true\n\n        expect(firstXhr.canceled).not.to.be.true\n        expect(firstXhr.aborted).not.to.be.true\n        expect(firstXhr.readyState).to.eq(4)\n        expect(firstLog.get('state')).to.eq('passed')\n\n        // since we've canceled the underlying XHR\n        // ensure that our abort code did not run\n        // and that the underlying XHR was never\n        // completed with a status or response\n        expect(secondXhr.canceled).to.be.true\n        expect(secondXhr.aborted).not.to.be.true\n        expect(secondXhr.status).to.eq(0)\n        expect(secondXhr.responseText).to.eq('')\n\n        expect(stub).not.to.be.called\n        expect(secondLog.get('state')).to.eq('failed')\n        expect(secondLog.invoke('renderProps')).to.deep.eq({\n          message: 'GET (canceled) /timeout?ms=2000',\n          indicator: 'aborted',\n        })\n      })\n    })\n  })\n}\n",
    "packages/driver/src/cy/commands/actions/scroll.js": "const _ = require('lodash')\nconst $ = require('jquery')\nconst Promise = require('bluebird')\n\nconst $dom = require('../../../dom')\nconst $utils = require('../../../cypress/utils')\nconst $errUtils = require('../../../cypress/error_utils')\n\nconst findScrollableParent = ($el, win) => {\n  const $parent = $dom.getParent($el)\n\n  // if we're at the body, we just want to pass in\n  // window into jQuery scrollTo\n  if ($parent.is('body,html') || $dom.isDocument($parent)) {\n    return win\n  }\n\n  if ($dom.isScrollable($parent)) {\n    return $parent\n  }\n\n  return findScrollableParent($parent, win)\n}\n\nconst isNaNOrInfinity = (item) => {\n  const num = Number.parseFloat(item)\n\n  return _.isNaN(num) || !_.isFinite(num)\n}\n\nmodule.exports = (Commands, Cypress, cy, state) => {\n  Commands.addAll({ prevSubject: 'element' }, {\n    scrollIntoView (subject, options = {}) {\n      const userOptions = options\n\n      if (!_.isObject(userOptions)) {\n        $errUtils.throwErrByPath('scrollIntoView.invalid_argument', { args: { arg: userOptions } })\n      }\n\n      // ensure the subject is not window itself\n      // cause how are you gonna scroll the window into view...\n      if (subject === state('window')) {\n        $errUtils.throwErrByPath('scrollIntoView.subject_is_window')\n      }\n\n      // throw if we're trying to scroll to multiple elements\n      if (subject.length > 1) {\n        $errUtils.throwErrByPath('scrollIntoView.multiple_elements', { args: { num: subject.length } })\n      }\n\n      options = _.defaults({}, userOptions, {\n        $el: subject,\n        $parent: state('window'),\n        log: true,\n        duration: 0,\n        easing: 'swing',\n        axis: 'xy',\n      })\n\n      // figure out the options which actually change the behavior of clicks\n      let deltaOptions = $utils.filterOutOptions(options)\n\n      // here we want to figure out what has to actually\n      // be scrolled to get to this element, cause we need\n      // to scrollTo passing in that element.\n      options.$parent = findScrollableParent(options.$el, state('window'))\n\n      let parentIsWin = false\n\n      if (options.$parent === state('window')) {\n        parentIsWin = true\n        // jQuery scrollTo looks for the prop contentWindow\n        // otherwise it'll use the wrong window to scroll :(\n        options.$parent.contentWindow = options.$parent\n      }\n\n      // if we cannot parse an integer out of duration\n      // which could be 500 or \"500\", then it's NaN...throw\n      if (isNaNOrInfinity(options.duration)) {\n        $errUtils.throwErrByPath('scrollIntoView.invalid_duration', { args: { duration: options.duration } })\n      }\n\n      if (!((options.easing === 'swing') || (options.easing === 'linear'))) {\n        $errUtils.throwErrByPath('scrollIntoView.invalid_easing', { args: { easing: options.easing } })\n      }\n\n      if (options.log) {\n        deltaOptions = $utils.filterOutOptions(options, { duration: 0, easing: 'swing', offset: { left: 0, top: 0 } })\n\n        const log = {\n          $el: options.$el,\n          message: deltaOptions,\n          timeout: options.timeout,\n          consoleProps () {\n            const obj = {\n              // merge into consoleProps without mutating it\n              'Applied To': $dom.getElements(options.$el),\n              'Scrolled Element': $dom.getElements(options.$el),\n            }\n\n            return obj\n          },\n        }\n\n        options._log = Cypress.log(log)\n      }\n\n      if (!parentIsWin) {\n        // scroll the parent into view first\n        // before attemp\n        options.$parent[0].scrollIntoView()\n      }\n\n      const scrollIntoView = () => {\n        return new Promise((resolve, reject) => {\n          // scroll our axes\n          return $(options.$parent).scrollTo(options.$el, {\n            axis: options.axis,\n            easing: options.easing,\n            duration: options.duration,\n            offset: options.offset,\n            done () {\n              return resolve(options.$el)\n            },\n            fail () {\n              // its Promise object is rejected\n              try {\n                return $errUtils.throwErrByPath('scrollTo.animation_failed')\n              } catch (err) {\n                return reject(err)\n              }\n            },\n            always () {\n              if (parentIsWin) {\n                return delete options.$parent.contentWindow\n              }\n            },\n          })\n        })\n      }\n\n      return scrollIntoView()\n      .then(() => {\n        const verifyAssertions = () => {\n          return cy.verifyUpcomingAssertions(options.$el, options, {\n            onRetry: verifyAssertions,\n          })\n        }\n\n        return verifyAssertions()\n      })\n    },\n  })\n\n  Commands.addAll({ prevSubject: ['optional', 'element', 'window'] }, {\n    scrollTo (subject, xOrPosition, yOrOptions, options = {}) {\n      let x; let y\n      let userOptions = options\n\n      // check for undefined or null values\n      if (xOrPosition === undefined || xOrPosition === null) {\n        $errUtils.throwErrByPath('scrollTo.invalid_target', { args: { x } })\n      }\n\n      if (_.isObject(yOrOptions)) {\n        userOptions = yOrOptions\n      } else {\n        y = yOrOptions\n      }\n\n      let position = null\n\n      // we may be '50%' or 'bottomCenter'\n      if (_.isString(xOrPosition)) {\n        // if there's a number in our string, then\n        // don't check for positions and just set x\n        // this will check for NaN, etc - we need to explicitly\n        // include '0%' as a use case\n        if (Number.parseFloat(xOrPosition) || (Number.parseFloat(xOrPosition) === 0)) {\n          x = xOrPosition\n        } else {\n          position = xOrPosition\n          // make sure it's one of the valid position strings\n          cy.ensureValidPosition(position)\n        }\n      } else {\n        x = xOrPosition\n      }\n\n      switch (position) {\n        case 'topLeft':\n          x = 0 // y = 0\n          break\n        case 'top':\n          x = '50%' // y = 0\n          break\n        case 'topRight':\n          x = '100%' // y = 0\n          break\n        case 'left':\n          x = 0\n          y = '50%'\n          break\n        case 'center':\n          x = '50%'\n          y = '50%'\n          break\n        case 'right':\n          x = '100%'\n          y = '50%'\n          break\n        case 'bottomLeft':\n          x = 0\n          y = '100%'\n          break\n        case 'bottom':\n          x = '50%'\n          y = '100%'\n          break\n        case 'bottomRight':\n          x = '100%'\n          y = '100%'\n          break\n        default:\n          break\n      }\n\n      if (y == null) {\n        y = 0\n      }\n\n      if (x == null) {\n        x = 0\n      }\n\n      let $container\n      let isWin\n\n      // if our subject is window let it fall through\n      if (subject && !$dom.isWindow(subject)) {\n        // if they passed something here, its a DOM element\n        $container = subject\n      } else {\n        isWin = true\n        // if we don't have a subject, then we are a parent command\n        // assume they want to scroll the entire window.\n        $container = state('window')\n\n        // jQuery scrollTo looks for the prop contentWindow\n        // otherwise it'll use the wrong window to scroll :(\n        $container.contentWindow = $container\n      }\n\n      // throw if we're trying to scroll multiple containers\n      if (!isWin && $container.length > 1) {\n        $errUtils.throwErrByPath('scrollTo.multiple_containers', { args: { num: $container.length } })\n      }\n\n      options = _.defaults({}, userOptions, {\n        $el: $container,\n        log: true,\n        duration: 0,\n        easing: 'swing',\n        axis: 'xy',\n        ensureScrollable: true,\n        x,\n        y,\n      })\n\n      // if we cannot parse an integer out of duration\n      // which could be 500 or \"500\", then it's NaN...throw\n      if (isNaNOrInfinity(options.duration)) {\n        $errUtils.throwErrByPath('scrollTo.invalid_duration', { args: { duration: options.duration } })\n      }\n\n      if (!((options.easing === 'swing') || (options.easing === 'linear'))) {\n        $errUtils.throwErrByPath('scrollTo.invalid_easing', { args: { easing: options.easing } })\n      }\n\n      if (!_.isBoolean(options.ensureScrollable)) {\n        $errUtils.throwErrByPath('scrollTo.invalid_ensureScrollable', { args: { ensureScrollable: options.ensureScrollable } })\n      }\n\n      // if we cannot parse an integer out of y or x\n      // which could be 50 or \"50px\" or \"50%\" then\n      // it's NaN/Infinity...throw\n      if (isNaNOrInfinity(options.y) || isNaNOrInfinity(options.x)) {\n        $errUtils.throwErrByPath('scrollTo.invalid_target', { args: { x, y } })\n      }\n\n      if (options.log) {\n        const deltaOptions = $utils.stringify(\n          $utils.filterOutOptions(options, { duration: 0, easing: 'swing' }),\n        )\n\n        const messageArgs = []\n\n        if (position) {\n          messageArgs.push(position)\n        } else {\n          messageArgs.push(x)\n          messageArgs.push(y)\n        }\n\n        if (deltaOptions) {\n          messageArgs.push(deltaOptions)\n        }\n\n        const log = {\n          message: messageArgs.join(', '),\n          timeout: options.timeout,\n          consoleProps () {\n            // merge into consoleProps without mutating it\n            const obj = {}\n\n            if (position) {\n              obj.Position = position\n            } else {\n              obj.X = x\n              obj.Y = y\n            }\n\n            if (deltaOptions) {\n              obj.Options = deltaOptions\n            }\n\n            obj['Scrolled Element'] = $dom.getElements(options.$el)\n\n            return obj\n          },\n        }\n\n        if (!isWin) {\n          log.$el = options.$el\n        }\n\n        options._log = Cypress.log(log)\n      }\n\n      const ensureScrollability = () => {\n        // Some elements are not scrollable, user may opt out of error checking\n        // https://github.com/cypress-io/cypress/issues/1924\n        if (!options.ensureScrollable) {\n          return\n        }\n\n        try {\n          // make sure our container can even be scrolled\n          return cy.ensureScrollability($container, 'scrollTo')\n        } catch (err) {\n          options.error = err\n\n          return cy.retry(ensureScrollability, options)\n        }\n      }\n\n      const scrollTo = () => {\n        return new Promise((resolve, reject) => {\n          // scroll our axis'\n          $(options.$el).scrollTo({ left: x, top: y }, {\n            axis: options.axis,\n            easing: options.easing,\n            duration: options.duration,\n            ensureScrollable: options.ensureScrollable,\n            done () {\n              return resolve(options.$el)\n            },\n            fail () {\n              // its Promise object is rejected\n              try {\n                return $errUtils.throwErrByPath('scrollTo.animation_failed')\n              } catch (err) {\n                return reject(err)\n              }\n            },\n          })\n\n          if (isWin) {\n            return delete options.$el.contentWindow\n          }\n        })\n      }\n\n      return Promise\n      .try(ensureScrollability)\n      .then(scrollTo)\n      .then(() => {\n        const verifyAssertions = () => {\n          return cy.verifyUpcomingAssertions(options.$el, options, {\n            onRetry: verifyAssertions,\n          })\n        }\n\n        return verifyAssertions()\n      })\n    },\n  })\n}\n",
    "packages/driver/src/cy/commands/navigation.js": "/* global cy, Cypress */\nconst _ = require('lodash')\nconst whatIsCircular = require('@cypress/what-is-circular')\nconst UrlParse = require('url-parse')\nconst Promise = require('bluebird')\n\nconst $utils = require('../../cypress/utils')\nconst $errUtils = require('../../cypress/error_utils')\nconst $Log = require('../../cypress/log')\nconst $Location = require('../../cypress/location')\n\nconst debug = require('debug')('cypress:driver:navigation')\n\nlet id = null\nlet previousDomainVisited = null\nlet hasVisitedAboutBlank = null\nlet currentlyVisitingAboutBlank = null\nlet knownCommandCausedInstability = null\n\nconst REQUEST_URL_OPTS = 'auth failOnStatusCode retryOnNetworkFailure retryOnStatusCodeFailure method body headers'\n.split(' ')\n\nconst VISIT_OPTS = 'url log onBeforeLoad onLoad timeout requestTimeout'\n.split(' ')\n.concat(REQUEST_URL_OPTS)\n\nconst reset = (test = {}) => {\n  knownCommandCausedInstability = false\n\n  // continuously reset this\n  // before each test run!\n  previousDomainVisited = false\n\n  // make sure we reset that we haven't\n  // visited about blank again\n  hasVisitedAboutBlank = false\n\n  currentlyVisitingAboutBlank = false\n\n  id = test.id\n}\n\nconst VALID_VISIT_METHODS = ['GET', 'POST']\n\nconst isValidVisitMethod = (method) => {\n  return _.includes(VALID_VISIT_METHODS, method)\n}\n\nconst timedOutWaitingForPageLoad = (ms, log) => {\n  debug('timedOutWaitingForPageLoad')\n\n  $errUtils.throwErrByPath('navigation.timed_out', {\n    args: {\n      configFile: Cypress.config('configFile'),\n      ms,\n    },\n    onFail: log,\n  })\n}\n\nconst bothUrlsMatchAndRemoteHasHash = (current, remote) => {\n  // the remote has a hash\n  // or the last char of href\n  // is a hash\n  return (remote.hash || remote.href.slice(-1) === '#') &&\n  // both must have the same origin\n  current.origin === remote.origin &&\n    // both must have the same pathname\n    current.pathname === remote.pathname &&\n      // both must have the same query params\n      current.search === remote.search\n}\n\nconst cannotVisitDifferentOrigin = (origin, previousUrlVisited, remoteUrl, existingUrl, log) => {\n  const differences = []\n\n  if (remoteUrl.protocol !== existingUrl.protocol) {\n    differences.push('protocol')\n  }\n\n  if (remoteUrl.port !== existingUrl.port) {\n    differences.push('port')\n  }\n\n  if (remoteUrl.superDomain !== existingUrl.superDomain) {\n    differences.push('superdomain')\n  }\n\n  const errOpts = {\n    onFail: log,\n    args: {\n      differences: differences.join(', '),\n      previousUrl: previousUrlVisited,\n      attemptedUrl: origin,\n    },\n  }\n\n  $errUtils.throwErrByPath('visit.cannot_visit_different_origin', errOpts)\n}\n\nconst specifyFileByRelativePath = (url, log) => {\n  $errUtils.throwErrByPath('visit.specify_file_by_relative_path', {\n    onFail: log,\n    args: {\n      attemptedUrl: url,\n    },\n  })\n}\n\nconst aboutBlank = (cy, win) => {\n  return new Promise((resolve) => {\n    cy.once('window:load', resolve)\n\n    return $utils.locHref('about:blank', win)\n  })\n}\n\nconst navigationChanged = (Cypress, cy, state, source, arg) => {\n  // get the current url of our remote application\n  const url = cy.getRemoteLocation('href')\n\n  debug('navigation changed:', url)\n\n  // dont trigger for empty url's or about:blank\n  if (_.isEmpty(url) || (url === 'about:blank')) {\n    return\n  }\n\n  // start storing the history entries\n  const urls = state('urls') || []\n\n  const previousUrl = _.last(urls)\n\n  // ensure our new url doesnt match whatever\n  // the previous was. this prevents logging\n  // additionally when the url didnt actually change\n  if (url === previousUrl) {\n    return\n  }\n\n  // else notify the world and log this event\n  Cypress.action('cy:url:changed', url)\n\n  urls.push(url)\n\n  state('urls', urls)\n\n  state('url', url)\n\n  // don't output a command log for 'load' or 'before:load' events\n  // return if source in command\n  if (knownCommandCausedInstability) {\n    return\n  }\n\n  // ensure our new url doesnt match whatever\n  // the previous was. this prevents logging\n  // additionally when the url didnt actually change\n  Cypress.log({\n    name: 'new url',\n    message: url,\n    event: true,\n    type: 'parent',\n    end: true,\n    snapshot: true,\n    consoleProps () {\n      const obj = {\n        'New Url': url,\n      }\n\n      if (source) {\n        obj['Url Updated By'] = source\n      }\n\n      if (arg) {\n        obj.Args = arg\n      }\n\n      return obj\n    },\n  })\n}\n\nconst formSubmitted = (Cypress, e) => {\n  Cypress.log({\n    type: 'parent',\n    name: 'form sub',\n    message: '--submitting form--',\n    event: true,\n    end: true,\n    snapshot: true,\n    consoleProps () {\n      return {\n        'Originated From': e.target,\n        'Args': e,\n      }\n    },\n  })\n}\n\nconst pageLoading = (bool, Cypress, state) => {\n  if (state('pageLoading') === bool) {\n    return\n  }\n\n  state('pageLoading', bool)\n\n  Cypress.action('app:page:loading', bool)\n}\n\nconst stabilityChanged = (Cypress, state, config, stable) => {\n  debug('stabilityChanged:', stable)\n  if (currentlyVisitingAboutBlank) {\n    if (stable === false) {\n      // if we're currently visiting about blank\n      // and becoming unstable for the first time\n      // notifiy that we're page loading\n      pageLoading(true, Cypress, state)\n\n      return\n    }\n\n    // else wait until after we finish visiting\n    // about blank\n    return\n  }\n\n  // let the world know that the app is page:loading\n  pageLoading(!stable, Cypress, state)\n\n  // if we aren't becoming unstable\n  // then just return now\n  if (stable !== false) {\n    return\n  }\n\n  // if we purposefully just caused the page to load\n  // (and thus instability) don't log this out\n  if (knownCommandCausedInstability) {\n    return\n  }\n\n  // bail if we dont have a runnable\n  // because beforeunload can happen at any time\n  // we may no longer be testing and thus dont\n  // want to fire a new loading event\n  // TODO\n  // this may change in the future since we want\n  // to add debuggability in the chrome console\n  // which at that point we may keep runnable around\n  if (!state('runnable')) {\n    return\n  }\n\n  const options = {}\n\n  _.defaults(options, {\n    timeout: config('pageLoadTimeout'),\n  })\n\n  options._log = Cypress.log({\n    type: 'parent',\n    name: 'page load',\n    message: '--waiting for new page to load--',\n    event: true,\n    timeout: options.timeout,\n    consoleProps () {\n      return {\n        Note: 'This event initially fires when your application fires its \\'beforeunload\\' event and completes when your application fires its \\'load\\' event after the next page loads.',\n      }\n    },\n  })\n\n  cy.clearTimeout('page load')\n\n  const onPageLoadErr = (err) => {\n    state('onPageLoadErr', null)\n\n    const { originPolicy } = $Location.create(window.location.href)\n\n    try {\n      $errUtils.throwErrByPath('navigation.cross_origin', {\n        onFail: options._log,\n        args: {\n          configFile: Cypress.config('configFile'),\n          message: err.message,\n          originPolicy,\n        },\n      })\n    } catch (error) {\n      err = error\n\n      return err\n    }\n  }\n\n  state('onPageLoadErr', onPageLoadErr)\n\n  const getRedirectionCount = (href) => {\n    // object updated at test:before:run:async\n    const count = state('redirectionCount')\n\n    if (count[href] === undefined) {\n      count[href] = 0\n    }\n\n    return count[href]\n  }\n\n  const updateRedirectionCount = (href) => {\n    const count = state('redirectionCount')\n\n    count[href]++\n  }\n\n  const loading = () => {\n    const href = state('window').location.href\n    const count = getRedirectionCount(href)\n    const limit = config('redirectionLimit')\n\n    if (count === limit) {\n      $errUtils.throwErrByPath('navigation.reached_redirection_limit', {\n        args: {\n          href,\n          limit,\n        },\n      })\n    }\n\n    updateRedirectionCount(href)\n\n    debug('waiting for window:load')\n\n    return new Promise((resolve) => {\n      return cy.once('window:load', () => {\n        cy.state('onPageLoadErr', null)\n\n        options._log.set('message', '--page loaded--').snapshot().end()\n\n        return resolve()\n      })\n    })\n  }\n\n  const reject = (err) => {\n    const r = state('reject')\n\n    if (r) {\n      return r(err)\n    }\n  }\n\n  try {\n    return loading()\n    .timeout(options.timeout, 'page load')\n    .catch(Promise.TimeoutError, () => {\n      // clean this up\n      cy.state('onPageLoadErr', null)\n\n      try {\n        return timedOutWaitingForPageLoad(options.timeout, options._log)\n      } catch (err) {\n        return reject(err)\n      }\n    })\n  } catch (e) {\n    return reject(e)\n  }\n}\n\n// there are really two timeout values - pageLoadTimeout\n// and the underlying responseTimeout. for the purposes\n// of resolving resolving the url, we only care about\n// responseTimeout - since pageLoadTimeout is a driver\n// and browser concern. therefore we normalize the options\n// object and send 'responseTimeout' as options.timeout\n// for the backend.\nconst normalizeTimeoutOptions = (options) => {\n  return _\n  .chain(options)\n  .pick(REQUEST_URL_OPTS)\n  .extend({ timeout: options.responseTimeout })\n  .value()\n}\n\nmodule.exports = (Commands, Cypress, cy, state, config) => {\n  reset()\n\n  Cypress.on('test:before:run:async', () => {\n    state('redirectionCount', {})\n\n    // reset any state on the backend\n    // TODO: this is a bug in e2e it needs to be returned\n    return Cypress.backend('reset:server:state')\n  })\n\n  Cypress.on('test:before:run', reset)\n\n  Cypress.on('stability:changed', (bool, event) => {\n    // only send up page loading events when we're\n    // not stable!\n    stabilityChanged(Cypress, state, config, bool, event)\n  })\n\n  Cypress.on('navigation:changed', (source, arg) => {\n    navigationChanged(Cypress, cy, state, source, arg)\n  })\n\n  Cypress.on('form:submitted', (e) => {\n    formSubmitted(Cypress, e)\n  })\n\n  const visitFailedByErr = (err, url, fn) => {\n    err.url = url\n\n    Cypress.action('cy:visit:failed', err)\n\n    return fn()\n  }\n\n  const requestUrl = (url, options = {}) => {\n    return Cypress.backend(\n      'resolve:url',\n      url,\n      normalizeTimeoutOptions(options),\n    )\n    .then((resp = {}) => {\n      if (!resp.isOkStatusCode) {\n        // if we didn't even get an OK response\n        // then immediately die\n        const err = new Error\n\n        err.gotResponse = true\n        _.extend(err, resp)\n\n        throw err\n      }\n\n      if (!resp.isHtml) {\n        // throw invalid contentType error\n        const err = new Error\n\n        err.invalidContentType = true\n        _.extend(err, resp)\n\n        throw err\n      }\n\n      return resp\n    })\n  }\n\n  Cypress.on('window:before:load', (contentWindow) => {\n    // if a user-loaded script redefines document.querySelectorAll and\n    // numTestsKeptInMemory is 0 (no snapshotting), jQuery thinks\n    // that document.querySelectorAll is not available (it tests to see that\n    // it's the native definition for some reason) and doesn't use it,\n    // which can fail with a weird error if querying shadow dom.\n    // this ensures that jQuery determines support for document.querySelectorAll\n    // before user scripts are executed.\n    // (when snapshotting is enabled, it can achieve the same thing if an XHR\n    // causes it to snapshot before the user script is executed, but that's\n    // not guaranteed to happen.)\n    // https://github.com/cypress-io/cypress/issues/7676\n    // this shouldn't error, but we wrap it to ignore potential errors\n    // out of an abundance of caution\n    try {\n      cy.$$('body', contentWindow.document)\n    } catch (e) {} // eslint-disable-line no-empty\n  })\n\n  Commands.addAll({\n    reload (...args) {\n      let forceReload\n      let userOptions\n      const throwArgsErr = () => {\n        $errUtils.throwErrByPath('reload.invalid_arguments')\n      }\n\n      switch (args.length) {\n        case 0:\n          forceReload = false\n          userOptions = {}\n          break\n\n        case 1:\n          if (_.isObject(args[0])) {\n            userOptions = args[0]\n          } else {\n            forceReload = args[0]\n          }\n\n          break\n\n        case 2:\n          forceReload = args[0]\n          userOptions = args[1]\n          break\n\n        default:\n          throwArgsErr()\n      }\n\n      // clear the current timeout\n      cy.clearTimeout('reload')\n\n      let cleanup = null\n      const options = _.defaults({}, userOptions, {\n        log: true,\n        timeout: config('pageLoadTimeout'),\n      })\n\n      const reload = () => {\n        return new Promise((resolve) => {\n          forceReload = forceReload || false\n          userOptions = userOptions || {}\n\n          if (!_.isObject(userOptions)) {\n            throwArgsErr()\n          }\n\n          if (!_.isBoolean(forceReload)) {\n            throwArgsErr()\n          }\n\n          if (options.log) {\n            options._log = Cypress.log({ timeout: options.timeout })\n\n            options._log.snapshot('before', { next: 'after' })\n          }\n\n          cleanup = () => {\n            knownCommandCausedInstability = false\n\n            return cy.removeListener('window:load', resolve)\n          }\n\n          knownCommandCausedInstability = true\n\n          cy.once('window:load', resolve)\n\n          return $utils.locReload(forceReload, state('window'))\n        })\n      }\n\n      return reload()\n      .timeout(options.timeout, 'reload')\n      .catch(Promise.TimeoutError, () => {\n        return timedOutWaitingForPageLoad(options.timeout, options._log)\n      })\n      .finally(() => {\n        if (typeof cleanup === 'function') {\n          cleanup()\n        }\n\n        return null\n      })\n    },\n\n    go (numberOrString, options = {}) {\n      const userOptions = options\n\n      options = _.defaults({}, userOptions, {\n        log: true,\n        timeout: config('pageLoadTimeout'),\n      })\n\n      if (options.log) {\n        options._log = Cypress.log({ timeout: options.timeout })\n      }\n\n      const win = state('window')\n\n      const goNumber = (num) => {\n        if (num === 0) {\n          $errUtils.throwErrByPath('go.invalid_number', { onFail: options._log })\n        }\n\n        let cleanup = null\n\n        if (options._log) {\n          options._log.snapshot('before', { next: 'after' })\n        }\n\n        const go = () => {\n          return Promise.try(() => {\n            let didUnload = false\n\n            const beforeUnload = () => {\n              didUnload = true\n            }\n\n            // clear the current timeout\n            cy.clearTimeout()\n\n            cy.once('window:before:unload', beforeUnload)\n\n            const didLoad = new Promise((resolve) => {\n              cleanup = function () {\n                cy.removeListener('window:load', resolve)\n\n                return cy.removeListener('window:before:unload', beforeUnload)\n              }\n\n              return cy.once('window:load', resolve)\n            })\n\n            knownCommandCausedInstability = true\n\n            win.history.go(num)\n\n            // need to set the attributes of 'go'\n            // consoleProps here with win\n            // make sure we resolve our go function\n            // with the remove window (just like cy.visit)\n            const retWin = () => state('window')\n\n            return Promise\n            .delay(100)\n            .then(() => {\n              knownCommandCausedInstability = false\n\n              // if we've didUnload then we know we're\n              // doing a full page refresh and we need\n              // to wait until\n              if (didUnload) {\n                return didLoad.then(retWin)\n              }\n\n              return retWin()\n            })\n          })\n        }\n\n        return go()\n        .timeout(options.timeout, 'go')\n        .catch(Promise.TimeoutError, () => {\n          return timedOutWaitingForPageLoad(options.timeout, options._log)\n        }).finally(() => {\n          if (typeof cleanup === 'function') {\n            cleanup()\n          }\n\n          return null\n        })\n      }\n\n      const goString = (str) => {\n        switch (str) {\n          case 'forward': return goNumber(1)\n          case 'back': return goNumber(-1)\n          default:\n            $errUtils.throwErrByPath('go.invalid_direction', {\n              onFail: options._log,\n              args: { str },\n            })\n        }\n      }\n\n      if (_.isFinite(numberOrString)) {\n        return goNumber(numberOrString)\n      }\n\n      if (_.isString(numberOrString)) {\n        return goString(numberOrString)\n      }\n\n      $errUtils.throwErrByPath('go.invalid_argument', { onFail: options._log })\n    },\n\n    visit (url, options = {}) {\n      if (options.url && url) {\n        $errUtils.throwErrByPath('visit.no_duplicate_url', { args: { optionsUrl: options.url, url } })\n      }\n\n      let userOptions = options\n\n      if (_.isObject(url) && _.isEqual(userOptions, {})) {\n        // options specified as only argument\n        userOptions = url\n        url = userOptions.url\n      }\n\n      if (!_.isString(url)) {\n        $errUtils.throwErrByPath('visit.invalid_1st_arg')\n      }\n\n      const consoleProps = {}\n\n      if (!_.isEmpty(userOptions)) {\n        consoleProps['Options'] = _.pick(userOptions, VISIT_OPTS)\n      }\n\n      options = _.defaults({}, userOptions, {\n        auth: null,\n        failOnStatusCode: true,\n        retryOnNetworkFailure: true,\n        retryOnStatusCodeFailure: false,\n        method: 'GET',\n        body: null,\n        headers: {},\n        log: true,\n        responseTimeout: config('responseTimeout'),\n        timeout: config('pageLoadTimeout'),\n        onBeforeLoad () {},\n        onLoad () {},\n      })\n\n      if (!_.isUndefined(options.qs) && !_.isObject(options.qs)) {\n        $errUtils.throwErrByPath('visit.invalid_qs', { args: { qs: String(options.qs) } })\n      }\n\n      if (options.retryOnStatusCodeFailure && !options.failOnStatusCode) {\n        $errUtils.throwErrByPath('visit.status_code_flags_invalid')\n      }\n\n      if (!isValidVisitMethod(options.method)) {\n        $errUtils.throwErrByPath('visit.invalid_method', { args: { method: options.method } })\n      }\n\n      if (!_.isObject(options.headers)) {\n        $errUtils.throwErrByPath('visit.invalid_headers')\n      }\n\n      const path = whatIsCircular(options.body)\n\n      if (_.isObject(options.body) && path) {\n        $errUtils.throwErrByPath('visit.body_circular', { args: { path } })\n      }\n\n      if (options.log) {\n        let message = url\n\n        if (options.method !== 'GET') {\n          message = `${options.method} ${message}`\n        }\n\n        options._log = Cypress.log({\n          message,\n          timeout: options.timeout,\n          consoleProps () {\n            return consoleProps\n          },\n        })\n      }\n\n      url = $Location.normalize(url)\n\n      const baseUrl = config('baseUrl')\n\n      if (baseUrl) {\n        url = $Location.qualifyWithBaseUrl(baseUrl, url)\n      }\n\n      const qs = options.qs\n\n      if (qs) {\n        url = $Location.mergeUrlWithParams(url, qs)\n      }\n\n      let cleanup = null\n\n      // clear the current timeout\n      cy.clearTimeout('visit')\n\n      let win = state('window')\n      const $autIframe = state('$autIframe')\n      const runnable = state('runnable')\n\n      const changeIframeSrc = (url, event) => {\n        return new Promise((resolve, reject) => {\n          let onBeforeLoadError\n\n          const onBeforeLoad = (contentWindow) => {\n            try {\n              options.onBeforeLoad?.call(runnable.ctx, contentWindow)\n            } catch (err) {\n              err.isCallbackError = true\n              onBeforeLoadError = err\n            }\n          }\n\n          const onEvent = (contentWindow) => {\n            if (onBeforeLoadError) {\n              reject(onBeforeLoadError)\n            } else {\n              resolve(contentWindow)\n            }\n          }\n\n          // hashchange events fire too fast, so we use a different strategy.\n          // they even resolve asynchronously before the application's\n          // hashchange events have even fired\n          // @see https://github.com/cypress-io/cypress/issues/652\n          // also, the page doesn't fully reload on hashchange, so we\n          // can't and don't wait for before:window:load\n          if (event === 'hashchange') {\n            win.addEventListener('hashchange', resolve)\n          } else {\n            // listen for window:before:load and reject if it errors\n            // otherwise, resolve once this event fires\n            cy.once(event, onEvent)\n            cy.once('window:before:load', onBeforeLoad)\n          }\n\n          cleanup = () => {\n            if (event === 'hashchange') {\n              win.removeEventListener('hashchange', resolve)\n            } else {\n              cy.removeListener(event, onEvent)\n              cy.removeListener('window:before:load', onBeforeLoad)\n            }\n\n            knownCommandCausedInstability = false\n          }\n\n          knownCommandCausedInstability = true\n\n          return $utils.iframeSrc($autIframe, url)\n        })\n      }\n\n      const onLoad = ({ runOnLoadCallback, totalTime }) => {\n        // reset window on load\n        win = state('window')\n\n        // the onLoad callback should only be skipped if specified\n        if (runOnLoadCallback !== false) {\n          try {\n            options.onLoad?.call(runnable.ctx, win)\n          } catch (err) {\n            // mark these as user callback errors, so they're treated differently\n            // than Node.js errors when caught below\n            err.isCallbackError = true\n            throw err\n          }\n        }\n\n        if (options._log) {\n          options._log.set({\n            url,\n            totalTime,\n          })\n        }\n\n        return Promise.resolve(win)\n      }\n\n      const go = () => {\n        // hold onto our existing url\n        const existing = $utils.locExisting()\n\n        // TODO: $Location.resolve(existing.origin, url)\n\n        if ($Location.isLocalFileUrl(url)) {\n          return specifyFileByRelativePath(url, options._log)\n        }\n\n        let remoteUrl\n\n        // in the case we are visiting a relative url\n        // then prepend the existing origin to it\n        // so we get the right remote url\n        if (!$Location.isFullyQualifiedUrl(url)) {\n          remoteUrl = $Location.fullyQualifyUrl(url)\n        }\n\n        let remote = $Location.create(remoteUrl || url)\n\n        // reset auth options if we have them\n        const a = remote.authObj\n\n        if (a) {\n          options.auth = a\n        }\n\n        // store the existing hash now since\n        // we'll need to apply it later\n        const existingHash = remote.hash || ''\n        const existingAuth = remote.auth || ''\n\n        if (previousDomainVisited && (remote.originPolicy !== existing.originPolicy)) {\n          // if we've already visited a new superDomain\n          // then die else we'd be in a terrible endless loop\n          // we also need to disable retries to prevent the endless loop\n          $utils.getTestFromRunnable(state('runnable'))._retries = 0\n\n          return cannotVisitDifferentOrigin(remote.origin, previousDomainVisited, remote, existing, options._log)\n        }\n\n        const current = $Location.create(win.location.href)\n\n        // if all that is changing is the hash then we know\n        // the browser won't actually make a new http request\n        // for this, and so we need to resolve onLoad immediately\n        // and bypass the actual visit resolution stuff\n        if (bothUrlsMatchAndRemoteHasHash(current, remote)) {\n          // https://github.com/cypress-io/cypress/issues/1311\n          if (current.hash === remote.hash) {\n            consoleProps['Note'] = 'Because this visit was to the same hash, the page did not reload and the onBeforeLoad and onLoad callbacks did not fire.'\n\n            return onLoad({ runOnLoadCallback: false })\n          }\n\n          return changeIframeSrc(remote.href, 'hashchange')\n          .then(onLoad)\n        }\n\n        if (existingHash) {\n          // strip out the existing hash if we have one\n          // before telling our backend to resolve this url\n          url = url.replace(existingHash, '')\n        }\n\n        if (existingAuth) {\n          // strip out the existing url if we have one\n          url = url.replace(`${existingAuth}@`, '')\n        }\n\n        return requestUrl(url, options)\n        .then((resp = {}) => {\n          let { url, originalUrl, cookies, redirects, filePath } = resp\n\n          // reapply the existing hash\n          url += existingHash\n          originalUrl += existingHash\n\n          if (filePath) {\n            consoleProps['File Served'] = filePath\n          } else {\n            if (url !== originalUrl) {\n              consoleProps['Original Url'] = originalUrl\n            }\n          }\n\n          if (options.log) {\n            let message = options._log.get('message')\n\n            if (redirects && redirects.length) {\n              message = [message].concat(redirects).join(' -> ')\n            }\n\n            options._log.set({ message })\n          }\n\n          consoleProps['Resolved Url'] = url\n          consoleProps['Redirects'] = redirects\n          consoleProps['Cookies Set'] = cookies\n\n          remote = $Location.create(url)\n\n          // if the origin currently matches\n          // then go ahead and change the iframe's src\n          // and we're good to go\n          // if origin is existing.origin\n          if (remote.originPolicy === existing.originPolicy) {\n            previousDomainVisited = remote.origin\n\n            url = $Location.fullyQualifyUrl(url)\n\n            return changeIframeSrc(url, 'window:load')\n            .then(() => {\n              return onLoad(resp)\n            })\n          }\n\n          // if we've already visited a new origin\n          // then die else we'd be in a terrible endless loop\n          if (previousDomainVisited) {\n            return cannotVisitDifferentOrigin(remote.origin, previousDomainVisited, remote, existing, options._log)\n          }\n\n          // tell our backend we're changing domains\n          // TODO: add in other things we want to preserve\n          // state for like scrollTop\n          let s = {\n            currentId: id,\n            tests: Cypress.runner.getTestsState(),\n            startTime: Cypress.runner.getStartTime(),\n            emissions: Cypress.runner.getEmissions(),\n          }\n\n          s.passed = Cypress.runner.countByTestState(s.tests, 'passed')\n          s.failed = Cypress.runner.countByTestState(s.tests, 'failed')\n          s.pending = Cypress.runner.countByTestState(s.tests, 'pending')\n          s.numLogs = $Log.countLogsByTests(s.tests)\n\n          return Cypress.action('cy:collect:run:state')\n          .then((a = []) => {\n            // merge all the states together holla'\n            s = _.reduce(a, (memo, obj) => {\n              return _.extend(memo, obj)\n            }, s)\n\n            return Cypress.backend('preserve:run:state', s)\n          })\n          .then(() => {\n            // and now we must change the url to be the new\n            // origin but include the test that we're currently on\n            const newUri = new UrlParse(remote.origin)\n\n            newUri\n            .set('pathname', existing.pathname)\n            .set('query', existing.search)\n            .set('hash', existing.hash)\n\n            // replace is broken in electron so switching\n            // to href for now\n            // $utils.locReplace(window, newUri.toString())\n            $utils.locHref(newUri.toString(), window)\n\n            // we are returning a Promise which never resolves\n            // because we're changing top to be a brand new URL\n            // and want to block the rest of our commands\n            return Promise.delay(1e9)\n          })\n        })\n        .catch((err) => {\n          if (err.gotResponse || err.invalidContentType) {\n            visitFailedByErr(err, err.originalUrl, () => {\n              const args = {\n                url: err.originalUrl,\n                path: err.filePath,\n                status: err.status,\n                statusText: err.statusText,\n                redirects: err.redirects,\n                contentType: err.contentType,\n              }\n\n              let msg = ''\n\n              if (err.gotResponse) {\n                const type = err.filePath ? 'file' : 'http'\n\n                msg = `visit.loading_${type}_failed`\n              }\n\n              if (err.invalidContentType) {\n                msg = 'visit.loading_invalid_content_type'\n              }\n\n              $errUtils.throwErrByPath(msg, {\n                onFail: options._log,\n                args,\n              })\n            })\n\n            return\n          }\n\n          // if it came from the user's onBeforeLoad or onLoad callback, it's\n          // not a network failure, and we should throw the original error\n          if (err.isCallbackError) {\n            delete err.isCallbackError\n            throw err\n          }\n\n          visitFailedByErr(err, url, () => {\n            $errUtils.throwErrByPath('visit.loading_network_failed', {\n              onFail: options._log,\n              args: {\n                url,\n                error: err,\n              },\n              errProps: {\n                appendToStack: {\n                  title: 'From Node.js Internals',\n                  content: err.stack,\n                },\n              },\n            })\n          })\n        })\n      }\n\n      const visit = () => {\n        // if we've visiting for the first time during\n        // a test then we want to first visit about:blank\n        // so that we nuke the previous state. subsequent\n        // visits will not navigate to about:blank so that\n        // our history entries are intact\n        if (!hasVisitedAboutBlank) {\n          hasVisitedAboutBlank = true\n          currentlyVisitingAboutBlank = true\n\n          return aboutBlank(cy, win)\n          .then(() => {\n            currentlyVisitingAboutBlank = false\n\n            return go()\n          })\n        }\n\n        return go()\n      }\n\n      return visit()\n      .timeout(options.timeout, 'visit')\n      .catch(Promise.TimeoutError, () => {\n        return timedOutWaitingForPageLoad(options.timeout, options._log)\n      }).finally(() => {\n        if (typeof cleanup === 'function') {\n          cleanup()\n        }\n\n        return null\n      })\n    },\n  })\n}\n",
    "packages/driver/src/cy/commands/screenshot.js": "/* global Cypress, cy */\nconst _ = require('lodash')\nconst $ = require('jquery')\nconst bytes = require('bytes')\nconst Promise = require('bluebird')\n\nconst $Screenshot = require('../../cypress/screenshot')\nconst $dom = require('../../dom')\nconst $errUtils = require('../../cypress/error_utils')\nconst $utils = require('../../cypress/utils')\n\nconst getViewportHeight = (state) => {\n  // TODO this doesn't seem correct\n  return Math.min(state('viewportHeight'), window.innerHeight)\n}\n\nconst getViewportWidth = (state) => {\n  return Math.min(state('viewportWidth'), window.innerWidth)\n}\n\nconst automateScreenshot = (state, options = {}) => {\n  const { runnable, timeout } = options\n\n  const titles = []\n\n  // if this a hook then push both the current test title\n  // and our own hook title\n  if (runnable.type === 'hook') {\n    let ct = runnable.ctx.currentTest\n\n    if (runnable.ctx && ct) {\n      titles.push(ct.title, runnable.title)\n    }\n  } else {\n    titles.push(runnable.title)\n  }\n\n  const getParentTitle = (runnable) => {\n    const p = runnable.parent\n\n    if (p) {\n      const t = p.title\n\n      if (t) {\n        titles.unshift(t)\n      }\n\n      return getParentTitle(p)\n    }\n  }\n\n  getParentTitle(runnable)\n\n  const props = _.extend({\n    titles,\n    testId: runnable.id,\n    takenPaths: state('screenshotPaths'),\n    testAttemptIndex: $utils.getTestFromRunnable(runnable)._currentRetry,\n  }, _.omit(options, 'runnable', 'timeout', 'log', 'subject'))\n\n  const automate = () => {\n    return Cypress.automation('take:screenshot', props)\n  }\n\n  if (!timeout) {\n    return automate()\n  }\n\n  // need to remove the current timeout\n  // because we're handling timeouts ourselves\n  cy.clearTimeout('take:screenshot')\n\n  return automate()\n  .timeout(timeout)\n  .catch((err) => {\n    return $errUtils.throwErr(err, { onFail: options.log })\n  })\n  .catch(Promise.TimeoutError, () => {\n    return $errUtils.throwErrByPath('screenshot.timed_out', {\n      onFail: options.log,\n      args: { timeout },\n    })\n  })\n}\n\nconst scrollOverrides = (win, doc) => {\n  const originalOverflow = doc.documentElement.style.overflow\n  const originalBodyOverflowY = doc.body.style.overflowY\n  const originalX = win.scrollX\n  const originalY = win.scrollY\n\n  // overflow-y: scroll can break `window.scrollTo`\n  if (doc.body) {\n    doc.body.style.overflowY = 'visible'\n  }\n\n  // hide scrollbars\n  doc.documentElement.style.overflow = 'hidden'\n\n  // in the case that an element might change size on scroll\n  // we trigger a scroll event to ensure that all elements are\n  // at their final size before we calculate the total height\n  // since we scroll down the page in takeScrollingScreenshots\n  // and don't want the page size to change once we start\n  // https://github.com/cypress-io/cypress/issues/6099\n  win.dispatchEvent(new win.Event('scroll'))\n\n  return () => {\n    doc.documentElement.style.overflow = originalOverflow\n    if (doc.body) {\n      doc.body.style.overflowY = originalBodyOverflowY\n    }\n\n    return win.scrollTo(originalX, originalY)\n  }\n}\n\nconst validateNumScreenshots = (numScreenshots, automationOptions) => {\n  if (numScreenshots < 1) {\n    $errUtils.throwErrByPath('screenshot.invalid_height', {\n      log: automationOptions.log,\n    })\n  }\n}\n\nconst takeScrollingScreenshots = (scrolls, win, state, automationOptions) => {\n  const scrollAndTake = ({ y, clip, afterScroll }, index) => {\n    win.scrollTo(0, y)\n    if (afterScroll) {\n      clip = afterScroll()\n    }\n\n    const options = _.extend({}, automationOptions, {\n      current: index + 1,\n      total: scrolls.length,\n      clip,\n    })\n\n    return automateScreenshot(state, options)\n  }\n\n  return Promise\n  .mapSeries(scrolls, scrollAndTake)\n  .then(_.last)\n}\n\nconst takeFullPageScreenshot = (state, automationOptions) => {\n  const win = state('window')\n  const doc = state('document')\n\n  const resetScrollOverrides = scrollOverrides(win, doc)\n\n  const docHeight = $(doc).height()\n  const viewportHeight = getViewportHeight(state)\n  const numScreenshots = Math.ceil(docHeight / viewportHeight)\n\n  validateNumScreenshots(numScreenshots, automationOptions)\n\n  const scrolls = _.map(_.times(numScreenshots), (index) => {\n    const y = viewportHeight * index\n    let clip\n\n    if ((index + 1) === numScreenshots) {\n      const heightLeft = docHeight - (viewportHeight * index)\n\n      clip = {\n        x: automationOptions.clip.x,\n        y: viewportHeight - heightLeft,\n        width: automationOptions.clip.width,\n        height: heightLeft,\n      }\n    } else {\n      clip = automationOptions.clip\n    }\n\n    return { y, clip }\n  })\n\n  return takeScrollingScreenshots(scrolls, win, state, automationOptions)\n  .finally(resetScrollOverrides)\n}\n\nconst applyPaddingToElementPositioning = (elPosition, automationOptions) => {\n  if (!automationOptions.padding) {\n    return elPosition\n  }\n\n  const [paddingTop, paddingRight, paddingBottom, paddingLeft] = automationOptions.padding\n\n  return {\n    width: elPosition.width + paddingLeft + paddingRight,\n    height: elPosition.height + paddingTop + paddingBottom,\n    fromElViewport: {\n      top: elPosition.fromElViewport.top - paddingTop,\n      left: elPosition.fromElViewport.left - paddingLeft,\n      bottom: elPosition.fromElViewport.bottom + paddingBottom,\n    },\n    fromElWindow: {\n      top: elPosition.fromElWindow.top - paddingTop,\n    },\n  }\n}\n\nconst takeElementScreenshot = ($el, state, automationOptions) => {\n  const win = state('window')\n  const doc = state('document')\n\n  const resetScrollOverrides = scrollOverrides(win, doc)\n\n  let elPosition = applyPaddingToElementPositioning(\n    $dom.getElementPositioning($el),\n    automationOptions,\n  )\n  const viewportHeight = getViewportHeight(state)\n  const viewportWidth = getViewportWidth(state)\n  const numScreenshots = Math.ceil(elPosition.height / viewportHeight)\n\n  validateNumScreenshots(numScreenshots, automationOptions)\n\n  const scrolls = _.map(_.times(numScreenshots), (index) => {\n    const y = elPosition.fromElWindow.top + (viewportHeight * index)\n\n    const afterScroll = () => {\n      elPosition = applyPaddingToElementPositioning(\n        $dom.getElementPositioning($el),\n        automationOptions,\n      )\n\n      const x = Math.min(viewportWidth, elPosition.fromElViewport.left)\n      const width = Math.min(viewportWidth - x, elPosition.width)\n\n      if (numScreenshots === 1) {\n        return {\n          x,\n          y: elPosition.fromElViewport.top,\n          width,\n          height: elPosition.height,\n        }\n      }\n\n      if ((index + 1) === numScreenshots) {\n        const overlap = ((numScreenshots - 1) * viewportHeight) + elPosition.fromElViewport.top\n        const heightLeft = elPosition.fromElViewport.bottom - overlap\n\n        return {\n          x,\n          y: overlap,\n          width,\n          height: heightLeft,\n        }\n      }\n\n      return {\n        x,\n        y: Math.max(0, elPosition.fromElViewport.top),\n        width,\n        // TODO: try simplifying to just 'viewportHeight'\n        height: Math.min(viewportHeight, elPosition.fromElViewport.top + elPosition.height),\n      }\n    }\n\n    return { y, afterScroll }\n  })\n\n  return takeScrollingScreenshots(scrolls, win, state, automationOptions)\n  .finally(resetScrollOverrides)\n}\n\n// \"app only\" means we're hiding the runner UI\nconst isAppOnly = ({ capture }) => {\n  return (capture === 'viewport') || (capture === 'fullPage')\n}\n\nconst getShouldScale = ({ capture, scale }) => {\n  return isAppOnly({ capture }) ? scale : true\n}\n\nconst getBlackout = ({ capture, blackout }) => {\n  return isAppOnly({ capture }) ? blackout : []\n}\n\nconst takeScreenshot = (Cypress, state, screenshotConfig, options = {}) => {\n  const {\n    capture,\n    padding,\n    clip,\n    disableTimersAndAnimations,\n    onBeforeScreenshot,\n    onAfterScreenshot,\n  } = screenshotConfig\n\n  const { subject, runnable } = options\n\n  const startTime = new Date()\n\n  const send = (event, props, resolve) => {\n    Cypress.action(`cy:${event}`, props, resolve)\n  }\n\n  const sendAsync = (event, props) => {\n    return new Promise((resolve) => {\n      return send(event, props, resolve)\n    })\n  }\n\n  const getOptions = (isOpen) => {\n    return {\n      id: runnable.id,\n      testAttemptIndex: $utils.getTestFromRunnable(runnable)._currentRetry,\n      isOpen,\n      appOnly: isAppOnly(screenshotConfig),\n      scale: getShouldScale(screenshotConfig),\n      waitForCommandSynchronization: !isAppOnly(screenshotConfig),\n      disableTimersAndAnimations,\n      blackout: getBlackout(screenshotConfig),\n    }\n  }\n\n  const before = () => {\n    return Promise.try(() => {\n      if (disableTimersAndAnimations) {\n        return cy.pauseTimers(true)\n      }\n    })\n    .then(() => {\n      return sendAsync('before:screenshot', getOptions(true))\n    })\n  }\n\n  const after = () => {\n    send('after:screenshot', getOptions(false))\n\n    return Promise.try(() => {\n      if (disableTimersAndAnimations) {\n        return cy.pauseTimers(false)\n      }\n    })\n  }\n\n  const automationOptions = _.extend({}, options, {\n    capture,\n    clip: {\n      x: 0,\n      y: 0,\n      width: getViewportWidth(state),\n      height: getViewportHeight(state),\n    },\n    padding,\n    userClip: clip,\n    viewport: {\n      width: window.innerWidth,\n      height: window.innerHeight,\n    },\n    scaled: getShouldScale(screenshotConfig),\n    blackout: getBlackout(screenshotConfig),\n    startTime: startTime.toISOString(),\n  })\n\n  // use the subject as $el or yield the wrapped documentElement\n  const $el = $dom.isElement(subject)\n    ? subject\n    : $dom.wrap(state('document').documentElement)\n\n  return before()\n  .then(() => {\n    if (onBeforeScreenshot) {\n      onBeforeScreenshot.call(state('ctx'), $el)\n    }\n\n    $Screenshot.onBeforeScreenshot($el)\n\n    if ($dom.isElement(subject)) {\n      return takeElementScreenshot($el, state, automationOptions)\n    }\n\n    if (capture === 'fullPage') {\n      return takeFullPageScreenshot(state, automationOptions)\n    }\n\n    return automateScreenshot(state, automationOptions)\n  })\n  .then((props) => {\n    if (onAfterScreenshot) {\n      onAfterScreenshot.call(state('ctx'), $el, props)\n    }\n\n    $Screenshot.onAfterScreenshot($el, props)\n\n    return props\n  })\n  .finally(after)\n}\n\nmodule.exports = function (Commands, Cypress, cy, state, config) {\n  // failure screenshot when not interactive\n  Cypress.on('runnable:after:run:async', (test, runnable) => {\n    const screenshotConfig = $Screenshot.getConfig()\n\n    if (\n      !test.err\n      || !screenshotConfig.screenshotOnRunFailure\n      || config('isInteractive')\n      || test.err.isPending\n      || !config('screenshotOnRunFailure')\n    ) {\n      return\n    }\n\n    // if a screenshot has not been taken (by cy.screenshot()) in the test\n    // that failed, we can bypass UI-changing and pixel-checking (simple: true)\n    // otheriwse, we need to do all the standard checks\n    // to make sure the UI is in the right place (simple: false)\n    screenshotConfig.capture = 'runner'\n\n    return takeScreenshot(Cypress, state, screenshotConfig, {\n      runnable,\n      simple: !state('screenshotTaken'),\n      testFailure: true,\n      timeout: config('responseTimeout'),\n    })\n  })\n\n  Commands.addAll({ prevSubject: ['optional', 'element', 'window', 'document'] }, {\n    screenshot (subject, name, options = {}) {\n      let userOptions = options\n\n      if (_.isObject(name)) {\n        userOptions = name\n        name = null\n      }\n\n      // make sure when we capture the entire test runner\n      // we are not limited to \"within\" subject\n      // https://github.com/cypress-io/cypress/issues/14253\n      if (options.capture !== 'runner') {\n        const withinSubject = state('withinSubject')\n\n        if (withinSubject && $dom.isElement(withinSubject)) {\n          subject = withinSubject\n        }\n      }\n\n      // TODO: handle hook titles\n      const runnable = state('runnable')\n\n      options = _.defaults({}, userOptions, {\n        log: true,\n        timeout: config('responseTimeout'),\n      })\n\n      const isWin = $dom.isWindow(subject)\n\n      let screenshotConfig = _.pick(options, 'capture', 'scale', 'disableTimersAndAnimations', 'blackout', 'waitForCommandSynchronization', 'padding', 'clip', 'onBeforeScreenshot', 'onAfterScreenshot')\n\n      screenshotConfig = $Screenshot.validate(screenshotConfig, 'screenshot', options._log)\n      screenshotConfig = _.extend($Screenshot.getConfig(), screenshotConfig)\n\n      // set this regardless of options.log b/c its used by the\n      // yielded value below\n      let consoleProps = _.omit(screenshotConfig, 'scale', 'screenshotOnRunFailure')\n\n      consoleProps = _.extend(consoleProps, {\n        scaled: getShouldScale(screenshotConfig),\n        blackout: getBlackout(screenshotConfig),\n      })\n\n      if (name) {\n        consoleProps.name = name\n      }\n\n      if (options.log) {\n        options._log = Cypress.log({\n          message: name,\n          timeout: options.timeout,\n          consoleProps () {\n            return consoleProps\n          },\n        })\n      }\n\n      if (!isWin && subject && subject.length > 1) {\n        $errUtils.throwErrByPath('screenshot.multiple_elements', {\n          log: options._log,\n          args: { numElements: subject.length },\n        })\n      }\n\n      if ($dom.isElement(subject)) {\n        screenshotConfig.capture = 'viewport'\n      }\n\n      state('screenshotTaken', true)\n\n      return takeScreenshot(Cypress, state, screenshotConfig, {\n        name,\n        subject,\n        runnable,\n        log: options._log,\n        timeout: options.timeout,\n      })\n      .then((props) => {\n        const { duration, path, size } = props\n        const { width, height } = props.dimensions\n\n        const takenPaths = state('screenshotPaths') || []\n\n        state('screenshotPaths', takenPaths.concat([path]))\n\n        _.extend(consoleProps, props, {\n          size: bytes(size, { unitSeparator: ' ' }),\n          duration: `${duration}ms`,\n          dimensions: `${width}px x ${height}px`,\n        })\n\n        if (subject) {\n          consoleProps.subject = subject\n        }\n\n        return subject\n      })\n    },\n  })\n}\n",
    "packages/driver/src/cy/commands/window.js": "const _ = require('lodash')\nconst Promise = require('bluebird')\n\nconst $errUtils = require('../../cypress/error_utils')\n\nconst viewports = {\n  'macbook-16': '1536x960',\n  'macbook-15': '1440x900',\n  'macbook-13': '1280x800',\n  'macbook-11': '1366x768',\n  'ipad-2': '768x1024',\n  'ipad-mini': '768x1024',\n  'iphone-xr': '414x896',\n  'iphone-x': '375x812',\n  'iphone-6+': '414x736',\n  'iphone-se2': '375x667',\n  'iphone-8': '375x667',\n  'iphone-7': '375x667',\n  'iphone-6': '375x667',\n  'iphone-5': '320x568',\n  'iphone-4': '320x480',\n  'iphone-3': '320x480',\n  'samsung-s10': '360x760',\n  'samsung-note9': '414x846',\n}\n\nconst validOrientations = ['landscape', 'portrait']\n\n// NOTE: this is outside the function because its 'global' state to the\n// cypress application and not local to the specific run. the last\n// viewport set is always the 'current' viewport as opposed to the\n// config. there was a bug where re-running tests without a hard\n// refresh would cause viewport to hang\nlet currentViewport = null\n\nmodule.exports = (Commands, Cypress, cy, state) => {\n  const defaultViewport = _.pick(Cypress.config(), 'viewportWidth', 'viewportHeight')\n\n  // currentViewport could already be set due to previous runs\n  currentViewport = currentViewport || defaultViewport\n\n  Cypress.on('test:before:run:async', () => {\n    // if we have viewportDefaults it means\n    // something has changed the default and we\n    // need to restore prior to running the next test\n    // after which we simply null and wait for the\n    // next viewport change\n    const configDefaultViewport = _.pick(Cypress.config(), 'viewportWidth', 'viewportHeight')\n\n    setViewportAndSynchronize(configDefaultViewport.viewportWidth, configDefaultViewport.viewportHeight)\n  })\n\n  const setViewportAndSynchronize = (width, height) => {\n    const viewport = { viewportWidth: width, viewportHeight: height }\n\n    // store viewport on the state for logs\n    state(viewport)\n\n    return new Promise((resolve) => {\n      if (currentViewport.viewportWidth === width && currentViewport.viewportHeight === height) {\n        // noop if viewport won't change\n        return resolve(currentViewport)\n      }\n\n      currentViewport = {\n        viewportWidth: width,\n        viewportHeight: height,\n      }\n\n      // force our UI to change to the viewport and wait for it\n      // to be updated\n      return Cypress.action('cy:viewport:changed', viewport, () => {\n        return resolve(viewport)\n      })\n    })\n  }\n\n  Commands.addAll({\n    title (options = {}) {\n      const userOptions = options\n\n      options = _.defaults({}, userOptions, { log: true })\n\n      if (options.log) {\n        options._log = Cypress.log({ timeout: options.timeout })\n      }\n\n      const resolveTitle = () => {\n        const doc = state('document')\n\n        const title = (doc && doc.title) || ''\n\n        return cy.verifyUpcomingAssertions(title, options, {\n          onRetry: resolveTitle,\n        })\n      }\n\n      return resolveTitle()\n    },\n\n    window (options = {}) {\n      const userOptions = options\n\n      options = _.defaults({}, userOptions, { log: true })\n\n      if (options.log) {\n        options._log = Cypress.log({ timeout: options.timeout })\n      }\n\n      const getWindow = () => {\n        const window = state('window')\n\n        if (!window) {\n          $errUtils.throwErrByPath('window.iframe_undefined', { onFail: options._log })\n        }\n\n        return window\n      }\n\n      // wrap retrying into its own\n      // separate function\n      const retryWindow = () => {\n        return Promise\n        .try(getWindow)\n        .catch((err) => {\n          options.error = err\n\n          return cy.retry(retryWindow, options)\n        })\n      }\n\n      const verifyAssertions = () => {\n        return Promise.try(retryWindow).then((win) => {\n          return cy.verifyUpcomingAssertions(win, options, {\n            onRetry: verifyAssertions,\n          })\n        })\n      }\n\n      return verifyAssertions()\n    },\n\n    document (options = {}) {\n      const userOptions = options\n\n      options = _.defaults({}, userOptions, { log: true })\n\n      if (options.log) {\n        options._log = Cypress.log({ timeout: options.timeout })\n      }\n\n      const getDocument = () => {\n        const win = state('window')\n\n        // TODO: add failing test around logging twice\n        if (!win?.document) {\n          $errUtils.throwErrByPath('window.iframe_doc_undefined')\n        }\n\n        return win.document\n      }\n\n      // wrap retrying into its own\n      // separate function\n      const retryDocument = () => {\n        return Promise\n        .try(getDocument)\n        .catch((err) => {\n          options.error = err\n\n          return cy.retry(retryDocument, options)\n        })\n      }\n\n      const verifyAssertions = () => {\n        return Promise.try(retryDocument).then((doc) => {\n          return cy.verifyUpcomingAssertions(doc, options, {\n            onRetry: verifyAssertions,\n          })\n        })\n      }\n\n      return verifyAssertions()\n    },\n\n    viewport (presetOrWidth, heightOrOrientation, options = {}) {\n      const userOptions = options\n\n      if (_.isObject(heightOrOrientation)) {\n        options = heightOrOrientation\n      }\n\n      options = _.defaults({}, userOptions, { log: true })\n\n      let height\n      let width\n\n      if (options.log) {\n        // The type of presetOrWidth is either string or number\n        // When preset => string\n        // When width => number\n        const isPreset = typeof presetOrWidth === 'string'\n\n        options._log = Cypress.log({\n          timeout: options.timeout,\n          consoleProps () {\n            const obj = {}\n\n            if (isPreset) {\n              obj.Preset = presetOrWidth\n            }\n\n            obj.Width = width\n            obj.Height = height\n\n            return obj\n          },\n        })\n      }\n\n      const throwErrBadArgs = () => {\n        return $errUtils.throwErrByPath('viewport.bad_args', { onFail: options._log })\n      }\n\n      const widthAndHeightAreValidNumbers = (width, height) => {\n        return _.every([width, height], (val) => {\n          return _.isNumber(val) && _.isFinite(val)\n        })\n      }\n\n      const widthAndHeightAreWithinBounds = (width, height) => {\n        return _.every([width, height], (val) => {\n          return val >= 0\n        })\n      }\n\n      if (_.isString(presetOrWidth) && _.isBlank(presetOrWidth)) {\n        $errUtils.throwErrByPath('viewport.empty_string', { onFail: options._log })\n      } else if (_.isString(presetOrWidth)) {\n        const getPresetDimensions = (preset) => {\n          try {\n            return _.map(viewports[presetOrWidth].split('x'), Number)\n          } catch (e) {\n            const presets = _.keys(viewports).join(', ')\n\n            return $errUtils.throwErrByPath('viewport.missing_preset', {\n              onFail: options._log,\n              args: { preset, presets },\n            })\n          }\n        }\n\n        const orientationIsValidAndLandscape = (orientation) => {\n          if (!validOrientations.includes(orientation)) {\n            const all = validOrientations.join('` or `')\n\n            $errUtils.throwErrByPath('viewport.invalid_orientation', {\n              onFail: options._log,\n              args: { all, orientation },\n            })\n          }\n\n          return orientation === 'landscape'\n        }\n\n        const preset = presetOrWidth\n        const orientation = heightOrOrientation\n\n        // get preset, split by x, convert to a number\n        const dimensions = getPresetDimensions(preset)\n\n        if (_.isString(orientation)) {\n          if (orientationIsValidAndLandscape(orientation)) {\n            dimensions.reverse()\n          }\n        }\n\n        [width, height] = dimensions\n      } else if (widthAndHeightAreValidNumbers(presetOrWidth, heightOrOrientation)) {\n        width = presetOrWidth\n        height = heightOrOrientation\n\n        if (!widthAndHeightAreWithinBounds(width, height)) {\n          $errUtils.throwErrByPath('viewport.dimensions_out_of_range', { onFail: options._log })\n        }\n      } else {\n        throwErrBadArgs()\n      }\n\n      return setViewportAndSynchronize(width, height)\n      .then((viewport) => {\n        if (options._log) {\n          options._log.set(viewport)\n        }\n\n        return null\n      })\n    },\n\n  })\n}\n",
    "packages/driver/src/cy/stability.js": "const Promise = require('bluebird')\n\nconst tryFn = (fn) => {\n  // promisify this function\n  return Promise.try(fn)\n}\n\nconst create = (Cypress, state) => {\n  const isStable = (stable = true, event) => {\n    if (state('isStable') === stable) {\n      return\n    }\n\n    const whenStable = state('whenStable')\n\n    // if we are going back to stable and we have\n    // a whenStable callback\n    if (stable && whenStable) {\n      // invoke it\n      whenStable()\n    }\n\n    state('isStable', stable)\n\n    // we notify the outside world because this is what the runner uses to\n    // show the 'loading spinner' during an app page loading transition event\n    return Cypress.action('cy:stability:changed', stable, event)\n  }\n\n  const whenStable = (fn) => {\n    // if we are not stable\n    if (state('isStable') === false) {\n      return new Promise((resolve, reject) => {\n        // then when we become stable\n        return state('whenStable', () => {\n          // reset this callback function\n          state('whenStable', null)\n\n          // and invoke the original function\n          return tryFn(fn)\n          .then(resolve)\n          .catch(reject)\n        })\n      })\n    }\n\n    // else invoke it right now\n    return tryFn(fn)\n  }\n\n  return {\n    isStable,\n\n    whenStable,\n  }\n}\n\nmodule.exports = {\n  create,\n}\n",
    "packages/driver/src/cypress/network_utils.js": "const Promise = require('bluebird')\n\nconst fetch = (resourceUrl, win = window) => {\n  return new Promise((resolve, reject) => {\n    const xhr = new win.XMLHttpRequest()\n\n    xhr.onload = function () {\n      resolve(this.responseText)\n    }\n\n    xhr.onerror = function () {\n      reject(new Error(`Fetching resource at '${resourceUrl}' failed`))\n    }\n\n    xhr.open('GET', resourceUrl)\n    xhr.send()\n  })\n}\n\nmodule.exports = {\n  fetch,\n}\n",
    "packages/driver/src/cypress.js": "const _ = require('lodash')\nconst $ = require('jquery')\nconst blobUtil = require('blob-util')\nconst minimatch = require('minimatch')\nconst Promise = require('bluebird')\nconst sinon = require('sinon')\nconst fakeTimers = require('@sinonjs/fake-timers')\n\nconst $dom = require('./dom')\nconst $errorMessages = require('./cypress/error_messages')\nconst $Chainer = require('./cypress/chainer')\nconst $Command = require('./cypress/command')\nconst $Commands = require('./cypress/commands')\nconst $Cookies = require('./cypress/cookies')\nconst $Cy = require('./cypress/cy')\nconst $Events = require('./cypress/events')\nconst $FirefoxForcedGc = require('./util/firefox_forced_gc')\nconst $Keyboard = require('./cy/keyboard')\nconst $SetterGetter = require('./cypress/setter_getter')\nconst $Log = require('./cypress/log')\nconst $Location = require('./cypress/location')\nconst $LocalStorage = require('./cypress/local_storage')\nconst $Mocha = require('./cypress/mocha')\nconst $Mouse = require('./cy/mouse')\nconst $Runner = require('./cypress/runner')\nconst $Downloads = require('./cypress/downloads')\nconst $Server = require('./cypress/server')\nconst $Screenshot = require('./cypress/screenshot')\nconst $SelectorPlayground = require('./cypress/selector_playground')\nconst $utils = require('./cypress/utils')\nconst $errUtils = require('./cypress/error_utils')\nconst $scriptUtils = require('./cypress/script_utils')\nconst browserInfo = require('./cypress/browser')\nconst resolvers = require('./cypress/resolvers')\nconst debug = require('debug')('cypress:driver:cypress')\n\nconst jqueryProxyFn = function (...args) {\n  if (!this.cy) {\n    $errUtils.throwErrByPath('miscellaneous.no_cy')\n  }\n\n  return this.cy.$$.apply(this.cy, args)\n}\n\nconst throwPrivateCommandInterface = (method) => {\n  $errUtils.throwErrByPath('miscellaneous.private_custom_command_interface', {\n    args: { method },\n  })\n}\n\nclass $Cypress {\n  constructor (config = {}) {\n    this.cy = null\n    this.chai = null\n    this.mocha = null\n    this.runner = null\n    this.downloads = null\n    this.Commands = null\n    this.$autIframe = null\n    this.onSpecReady = null\n\n    this.events = $Events.extend(this)\n    this.$ = jqueryProxyFn.bind(this)\n\n    _.extend(this.$, $)\n\n    this.setConfig(config)\n  }\n\n  setConfig (config = {}) {\n    // config.remote\n    // {\n    //   origin: \"http://localhost:2020\"\n    //   domainName: \"localhost\"\n    //   props: null\n    //   strategy: \"file\"\n    // }\n\n    // -- or --\n\n    // {\n    //   origin: \"https://foo.google.com\"\n    //   domainName: \"google.com\"\n    //   strategy: \"http\"\n    //   props: {\n    //     port: 443\n    //     tld: \"com\"\n    //     domain: \"google\"\n    //   }\n    // }\n\n    let d = config.remote ? config.remote.domainName : undefined\n\n    // set domainName but allow us to turn\n    // off this feature in testing\n    if (d) {\n      document.domain = d\n    }\n\n    // a few static props for the host OS, browser\n    // and the current version of Cypress\n    this.arch = config.arch\n    this.spec = config.spec\n    this.version = config.version\n    this.browser = config.browser\n    this.platform = config.platform\n    this.testingType = config.testingType\n\n    // normalize this into boolean\n    config.isTextTerminal = !!config.isTextTerminal\n\n    // we asumme we're interactive based on whether or\n    // not we're in a text terminal, but we keep this\n    // as a separate property so we can potentially\n    // slice up the behavior\n    config.isInteractive = !config.isTextTerminal\n\n    // enable long stack traces when\n    // we not are running headlessly\n    // for debuggability but disable\n    // them when running headlessly for\n    // performance since users cannot\n    // interact with the stack traces\n    Promise.config({\n      longStackTraces: config.isInteractive,\n    })\n\n    // TODO: env is unintentionally preserved between soft reruns unlike config.\n    // change this in the NEXT_BREAKING\n    const { env } = config\n\n    config = _.omit(config, 'env', 'remote', 'resolved', 'scaffoldedFiles', 'javascripts', 'state', 'testingType')\n\n    _.extend(this, browserInfo(config))\n\n    this.state = $SetterGetter.create({})\n    this.originalConfig = _.cloneDeep(config)\n    this.config = $SetterGetter.create(config)\n    this.env = $SetterGetter.create(env)\n    this.getFirefoxGcInterval = $FirefoxForcedGc.createIntervalGetter(this)\n    this.getTestRetries = function () {\n      const testRetries = this.config('retries')\n\n      if (_.isNumber(testRetries)) {\n        return testRetries\n      }\n\n      if (_.isObject(testRetries)) {\n        return testRetries[this.config('isInteractive') ? 'openMode' : 'runMode']\n      }\n\n      return null\n    }\n\n    this.Cookies = $Cookies.create(config.namespace, d)\n\n    return this.action('cypress:config', config)\n  }\n\n  initialize ({ $autIframe, onSpecReady }) {\n    this.$autIframe = $autIframe\n    this.onSpecReady = onSpecReady\n    if (this._onInitialize) {\n      this._onInitialize()\n      this._onInitialize = undefined\n    }\n  }\n\n  run (fn) {\n    if (!this.runner) {\n      $errUtils.throwErrByPath('miscellaneous.no_runner')\n    }\n\n    return this.runner.run(fn)\n  }\n\n  // Method to manually re-execute Runner (usually within $autIframe)\n  // used mainly by Component Testing\n  restartRunner () {\n    if (!window.top.Cypress) {\n      throw Error('Cannot re-run spec without Cypress')\n    }\n\n    // MobX state is only available on the Runner instance\n    // which is attached to the top level `window`\n    // We avoid infinite restart loop by checking if not in a loading state.\n    if (!window.top.Runner.state.isLoading) {\n      window.top.Runner.emit('restart')\n    }\n  }\n\n  // onSpecWindow is called as the spec window\n  // is being served but BEFORE any of the actual\n  // specs or support files have been downloaded\n  // or parsed. we have not received any custom commands\n  // at this point\n  onSpecWindow (specWindow, scripts) {\n    const logFn = (...args) => {\n      return this.log.apply(this, args)\n    }\n\n    // create cy and expose globally\n    this.cy = $Cy.create(specWindow, this, this.Cookies, this.state, this.config, logFn)\n    window.cy = this.cy\n    this.isCy = this.cy.isCy\n    this.log = $Log.create(this, this.cy, this.state, this.config)\n    this.mocha = $Mocha.create(specWindow, this, this.config)\n    this.runner = $Runner.create(specWindow, this.mocha, this, this.cy, this.state)\n    this.downloads = $Downloads.create(this)\n\n    // wire up command create to cy\n    this.Commands = $Commands.create(this, this.cy, this.state, this.config)\n\n    this.events.proxyTo(this.cy)\n\n    $FirefoxForcedGc.install(this)\n\n    $scriptUtils.runScripts(specWindow, scripts)\n    .catch((error) => {\n      this.runner.onSpecError('error')({ error })\n    })\n    .then(() => {\n      return (new Promise((resolve) => {\n        if (this.$autIframe) {\n          resolve()\n        } else {\n          // block initialization if the iframe has not been created yet\n          // Used in CT when async chunks for plugins take their time to download/parse\n          this._onInitialize = resolve\n        }\n      }))\n    })\n    .then(() => {\n      this.cy.initialize(this.$autIframe)\n\n      this.onSpecReady()\n    })\n  }\n\n  action (eventName, ...args) {\n    // normalizes all the various ways\n    // other objects communicate intent\n    // and 'action' to Cypress\n    debug(eventName)\n    switch (eventName) {\n      case 'recorder:frame':\n        return this.emit('recorder:frame', args[0])\n\n      case 'cypress:stop':\n        return this.emit('stop')\n\n      case 'cypress:config':\n        return this.emit('config', args[0])\n\n      case 'runner:start':\n        // mocha runner has begun running the tests\n        this.emit('run:start')\n\n        if (this.runner.getResumedAtTestIndex() !== null) {\n          return\n        }\n\n        if (this.config('isTextTerminal')) {\n          return this.emit('mocha', 'start', args[0])\n        }\n\n        break\n\n      case 'runner:end':\n        // mocha runner has finished running the tests\n\n        // end may have been caused by an uncaught error\n        // that happened inside of a hook.\n        //\n        // when this happens mocha aborts the entire run\n        // and does not do the usual cleanup so that means\n        // we have to fire the test:after:hooks and\n        // test:after:run events ourselves\n        this.emit('run:end')\n\n        if (this.config('isTextTerminal')) {\n          return this.emit('mocha', 'end', args[0])\n        }\n\n        break\n\n      case 'runner:suite:start':\n        // mocha runner started processing a suite\n        if (this.config('isTextTerminal')) {\n          return this.emit('mocha', 'suite', ...args)\n        }\n\n        break\n\n      case 'runner:suite:end':\n        // mocha runner finished processing a suite\n        if (this.config('isTextTerminal')) {\n          return this.emit('mocha', 'suite end', ...args)\n        }\n\n        break\n\n      case 'runner:hook:start':\n        // mocha runner started processing a hook\n        if (this.config('isTextTerminal')) {\n          return this.emit('mocha', 'hook', ...args)\n        }\n\n        break\n\n      case 'runner:hook:end':\n        // mocha runner finished processing a hook\n        if (this.config('isTextTerminal')) {\n          return this.emit('mocha', 'hook end', ...args)\n        }\n\n        break\n\n      case 'runner:test:start':\n        // mocha runner started processing a hook\n        if (this.config('isTextTerminal')) {\n          return this.emit('mocha', 'test', ...args)\n        }\n\n        break\n\n      case 'runner:test:end':\n        if (this.config('isTextTerminal')) {\n          return this.emit('mocha', 'test end', ...args)\n        }\n\n        break\n\n      case 'runner:pass':\n        // mocha runner calculated a pass\n        // this is delayed from when mocha would normally fire it\n        // since we fire it after all afterEach hooks have ran\n        if (this.config('isTextTerminal')) {\n          return this.emit('mocha', 'pass', ...args)\n        }\n\n        break\n\n      case 'runner:pending':\n        // mocha runner calculated a pending test\n        if (this.config('isTextTerminal')) {\n          return this.emit('mocha', 'pending', ...args)\n        }\n\n        break\n\n      case 'runner:fail': {\n        if (this.config('isTextTerminal')) {\n          return this.emit('mocha', 'fail', ...args)\n        }\n\n        break\n      }\n      // retry event only fired in mocha version 6+\n      // https://github.com/mochajs/mocha/commit/2a76dd7589e4a1ed14dd2a33ab89f182e4c4a050\n      case 'runner:retry': {\n        // mocha runner calculated a pass\n        if (this.config('isTextTerminal')) {\n          this.emit('mocha', 'retry', ...args)\n        }\n\n        break\n      }\n\n      case 'mocha:runnable:run':\n        return this.runner.onRunnableRun(...args)\n\n      case 'runner:test:before:run':\n        // get back to a clean slate\n        this.cy.reset(...args)\n\n        if (this.config('isTextTerminal')) {\n          // needed for handling test retries\n          this.emit('mocha', 'test:before:run', args[0])\n        }\n\n        this.emit('test:before:run', ...args)\n\n        break\n\n      case 'runner:test:before:run:async':\n        // TODO: handle timeouts here? or in the runner?\n        return this.emitThen('test:before:run:async', ...args)\n\n      case 'runner:runnable:after:run:async':\n        return this.emitThen('runnable:after:run:async', ...args)\n\n      case 'runner:test:after:run':\n        this.runner.cleanupQueue(this.config('numTestsKeptInMemory'))\n\n        // this event is how the reporter knows how to display\n        // stats and runnable properties such as errors\n        this.emit('test:after:run', ...args)\n\n        if (this.config('isTextTerminal')) {\n          // needed for calculating wallClockDuration\n          // and the timings of after + afterEach hooks\n          return this.emit('mocha', 'test:after:run', args[0])\n        }\n\n        break\n\n      case 'cy:before:all:screenshots':\n        return this.emit('before:all:screenshots', ...args)\n\n      case 'cy:before:screenshot':\n        return this.emit('before:screenshot', ...args)\n\n      case 'cy:after:screenshot':\n        return this.emit('after:screenshot', ...args)\n\n      case 'cy:after:all:screenshots':\n        return this.emit('after:all:screenshots', ...args)\n\n      case 'command:log:added':\n        this.runner.addLog(args[0], this.config('isInteractive'))\n\n        return this.emit('log:added', ...args)\n\n      case 'command:log:changed':\n        this.runner.addLog(args[0], this.config('isInteractive'))\n\n        return this.emit('log:changed', ...args)\n\n      case 'cy:fail':\n        // comes from cypress errors fail()\n        return this.emitMap('fail', ...args)\n\n      case 'cy:stability:changed':\n        return this.emit('stability:changed', ...args)\n\n      case 'cy:paused':\n        return this.emit('paused', ...args)\n\n      case 'cy:canceled':\n        return this.emit('canceled')\n\n      case 'cy:visit:failed':\n        return this.emit('visit:failed', args[0])\n\n      case 'cy:viewport:changed':\n        return this.emit('viewport:changed', ...args)\n\n      case 'cy:command:start':\n        return this.emit('command:start', ...args)\n\n      case 'cy:command:end':\n        return this.emit('command:end', ...args)\n\n      case 'cy:command:retry':\n        return this.emit('command:retry', ...args)\n\n      case 'cy:command:enqueued':\n        return this.emit('command:enqueued', args[0])\n\n      case 'cy:command:queue:before:end':\n        return this.emit('command:queue:before:end')\n\n      case 'cy:command:queue:end':\n        return this.emit('command:queue:end')\n\n      case 'cy:url:changed':\n        return this.emit('url:changed', args[0])\n\n      case 'cy:next:subject:prepared':\n        return this.emit('next:subject:prepared', ...args)\n\n      case 'cy:collect:run:state':\n        return this.emitThen('collect:run:state')\n\n      case 'cy:scrolled':\n        return this.emit('scrolled', ...args)\n\n      case 'app:uncaught:exception':\n        return this.emitMap('uncaught:exception', ...args)\n\n      case 'app:window:alert':\n        return this.emit('window:alert', args[0])\n\n      case 'app:window:confirm':\n        return this.emitMap('window:confirm', args[0])\n\n      case 'app:window:confirmed':\n        return this.emit('window:confirmed', ...args)\n\n      case 'app:page:loading':\n        return this.emit('page:loading', args[0])\n\n      case 'app:window:before:load':\n        this.cy.onBeforeAppWindowLoad(args[0])\n\n        return this.emit('window:before:load', args[0])\n\n      case 'app:navigation:changed':\n        return this.emit('navigation:changed', ...args)\n\n      case 'app:form:submitted':\n        return this.emit('form:submitted', args[0])\n\n      case 'app:window:load':\n        return this.emit('window:load', args[0])\n\n      case 'app:window:before:unload':\n        return this.emit('window:before:unload', args[0])\n\n      case 'app:window:unload':\n        return this.emit('window:unload', args[0])\n\n      case 'app:timers:reset':\n        return this.emitThen('app:timers:reset', ...args)\n\n      case 'app:timers:pause':\n        return this.emitThen('app:timers:pause', ...args)\n\n      case 'app:css:modified':\n        return this.emit('css:modified', args[0])\n\n      case 'spec:script:error':\n        return this.emit('script:error', ...args)\n\n      default:\n        return\n    }\n  }\n\n  backend (eventName, ...args) {\n    return new Promise((resolve, reject) => {\n      const fn = function (reply) {\n        const e = reply.error\n\n        if (e) {\n          // clone the error object\n          // and set stack cleaned\n          // to prevent bluebird from\n          // attaching long stace traces\n          // which otherwise make this err\n          // unusably long\n          const err = $errUtils.makeErrFromObj(e)\n\n          err.__stackCleaned__ = true\n          err.backend = true\n\n          return reject(err)\n        }\n\n        return resolve(reply.response)\n      }\n\n      return this.emit('backend:request', eventName, ...args, fn)\n    })\n  }\n\n  automation (eventName, ...args) {\n    // wrap action in promise\n    return new Promise((resolve, reject) => {\n      const fn = function (reply) {\n        const e = reply.error\n\n        if (e) {\n          const err = $errUtils.makeErrFromObj(e)\n\n          err.automation = true\n\n          return reject(err)\n        }\n\n        return resolve(reply.response)\n      }\n\n      return this.emit('automation:request', eventName, ...args, fn)\n    })\n  }\n\n  stop () {\n    if (!this.runner) {\n      // the tests have been reloaded\n      return\n    }\n\n    this.runner.stop()\n    this.cy.stop()\n\n    return this.action('cypress:stop')\n  }\n\n  addAssertionCommand () {\n    return throwPrivateCommandInterface('addAssertionCommand')\n  }\n\n  addUtilityCommand () {\n    return throwPrivateCommandInterface('addUtilityCommand')\n  }\n\n  static create (config) {\n    return new $Cypress(config)\n  }\n}\n\n// attach to $Cypress to access\n// all of the constructors\n// to enable users to monkeypatch\n$Cypress.prototype.$Cypress = $Cypress\n$Cypress.prototype.Cy = $Cy\n$Cypress.prototype.Chainer = $Chainer\n$Cypress.prototype.Cookies = $Cookies\n$Cypress.prototype.Command = $Command\n$Cypress.prototype.Commands = $Commands\n$Cypress.prototype.dom = $dom\n$Cypress.prototype.errorMessages = $errorMessages\n$Cypress.prototype.Keyboard = $Keyboard\n$Cypress.prototype.Location = $Location\n$Cypress.prototype.Log = $Log\n$Cypress.prototype.LocalStorage = $LocalStorage\n$Cypress.prototype.Mocha = $Mocha\n$Cypress.prototype.resolveWindowReference = resolvers.resolveWindowReference\n$Cypress.prototype.resolveLocationReference = resolvers.resolveLocationReference\n$Cypress.prototype.Mouse = $Mouse\n$Cypress.prototype.Runner = $Runner\n$Cypress.prototype.Server = $Server\n$Cypress.prototype.Screenshot = $Screenshot\n$Cypress.prototype.SelectorPlayground = $SelectorPlayground\n$Cypress.prototype.utils = $utils\n$Cypress.prototype._ = _\n$Cypress.prototype.Blob = blobUtil\n$Cypress.prototype.Promise = Promise\n$Cypress.prototype.minimatch = minimatch\n$Cypress.prototype.sinon = sinon\n$Cypress.prototype.lolex = fakeTimers\n\n// attaching these so they are accessible\n// via the runner + integration spec helper\n$Cypress.$ = $\n$Cypress.utils = $utils\n\nmodule.exports = $Cypress\n",
    "packages/https-proxy/lib/server.js": "const _ = require('lodash')\nconst { allowDestroy, connect, httpUtils } = require('@packages/network')\nconst debug = require('debug')('cypress:https-proxy')\nconst https = require('https')\nconst net = require('net')\nconst parse = require('./util/parse')\nconst Promise = require('bluebird')\nconst semaphore = require('semaphore')\nconst url = require('url')\n\nlet sslServers = {}\nlet sslIpServers = {}\nconst sslSemaphores = {}\n\n// https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_record\nconst SSL_RECORD_TYPES = [\n  22, // Handshake\n  128, 0, // TODO: what do these unknown types mean?\n]\n\nlet onError = (err) => {\n  // these need to be caught to avoid crashing but do not affect anything\n  return debug('server error %o', { err })\n}\n\nclass Server {\n  constructor (_ca, _port, _options) {\n    this._getServerPortForIp = this._getServerPortForIp.bind(this)\n    this._ca = _ca\n    this._port = _port\n    this._options = _options\n    this._onError = null\n    this._ipServers = sslIpServers\n  }\n\n  connect (req, browserSocket, head, options = {}) {\n    // don't buffer writes - thanks a lot, Nagle\n    // https://github.com/cypress-io/cypress/issues/3192\n    browserSocket.setNoDelay(true)\n\n    debug('Writing browserSocket connection headers %o', { url: req.url, headLength: _.get(head, 'length'), headers: req.headers })\n\n    browserSocket.on('error', (err) => {\n      // TODO: shouldn't we destroy the upstream socket here?\n      // and also vise versa if the upstream socket throws?\n      // we may get this \"for free\" though because piping will\n      // automatically forward the TCP errors...?\n\n      // nothing to do except catch here, the browser has d/c'd\n      return debug('received error on client browserSocket %o', {\n        err, url: req.url,\n      })\n    })\n\n    browserSocket.write('HTTP/1.1 200 OK\\r\\n')\n\n    if (req.headers['proxy-connection'] === 'keep-alive') {\n      browserSocket.write('Proxy-Connection: keep-alive\\r\\n')\n      browserSocket.write('Connection: keep-alive\\r\\n')\n    }\n\n    browserSocket.write('\\r\\n')\n\n    // if we somehow already have the head here\n    if (_.get(head, 'length')) {\n      // then immediately make up the connection\n      return this._onFirstHeadBytes(req, browserSocket, head, options)\n    }\n\n    // else once we get it make the connection later\n    return browserSocket.once('data', (data) => {\n      return this._onFirstHeadBytes(req, browserSocket, data, options)\n    })\n  }\n\n  _onFirstHeadBytes (req, browserSocket, head) {\n    debug('Got first head bytes %o', { url: req.url, head: _.chain(head).invoke('toString').slice(0, 64).join('').value() })\n\n    browserSocket.pause()\n\n    return this._onServerConnectData(req, browserSocket, head)\n  }\n\n  _onUpgrade (fn, req, browserSocket, head) {\n    debug('upgrade', req.url)\n    if (fn) {\n      return fn.call(this, req, browserSocket, head)\n    }\n  }\n\n  _onRequest (fn, req, res) {\n    const hostPort = parse.hostAndPort(req.url, req.headers, 443)\n\n    req.url = url.format({\n      protocol: 'https:',\n      hostname: hostPort.host,\n      port: hostPort.port,\n    }) + req.url\n\n    if (fn) {\n      return fn.call(this, req, res)\n    }\n  }\n\n  _makeConnection (browserSocket, head, port, hostname) {\n    const onSocket = (err, upstreamSocket) => {\n      debug('received upstreamSocket callback for request %o', { port, hostname, err })\n\n      onError = (err) => {\n        browserSocket.destroy(err)\n\n        if (this._onError) {\n          return this._onError(err, browserSocket, head, port)\n        }\n      }\n\n      if (err) {\n        return onError(err)\n      }\n\n      upstreamSocket.setNoDelay(true)\n      upstreamSocket.on('error', onError)\n\n      browserSocket.emit('upstream-connected', upstreamSocket)\n\n      browserSocket.pipe(upstreamSocket)\n      upstreamSocket.pipe(browserSocket)\n      upstreamSocket.write(head)\n\n      return browserSocket.resume()\n    }\n\n    if (!port) {\n      port = '443'\n    }\n\n    return connect.createRetryingSocket({ port, host: hostname }, onSocket)\n  }\n\n  _onServerConnectData (req, browserSocket, head) {\n    let sem; let sslServer\n    const firstBytes = head[0]\n\n    const makeConnection = (port) => {\n      debug('Making intercepted connection to %s', port)\n\n      return this._makeConnection(browserSocket, head, port, 'localhost')\n    }\n\n    if (!SSL_RECORD_TYPES.includes(firstBytes)) {\n      // if this isn't an SSL request then go\n      // ahead and make the connection now\n      return makeConnection(this._port)\n    }\n\n    // else spin up the SNI server\n    const { hostname } = url.parse(`https://${req.url}`)\n\n    sslServer = sslServers[hostname]\n\n    if (sslServer) {\n      return makeConnection(sslServer.port)\n    }\n\n    // only be creating one SSL server per hostname at once\n    if (!(sem = sslSemaphores[hostname])) {\n      sem = (sslSemaphores[hostname] = semaphore(1))\n    }\n\n    return sem.take(() => {\n      const leave = () => {\n        return process.nextTick(() => {\n          return sem.leave()\n        })\n      }\n\n      sslServer = sslServers[hostname]\n\n      if (sslServer) {\n        leave()\n\n        return makeConnection(sslServer.port)\n      }\n\n      return this._getPortFor(hostname)\n      .then((port) => {\n        sslServers[hostname] = { port }\n\n        leave()\n\n        return makeConnection(port)\n      })\n    })\n  }\n\n  _normalizeKeyAndCert (certPem, privateKeyPem) {\n    return {\n      key: privateKeyPem,\n      cert: certPem,\n    }\n  }\n\n  _getCertificatePathsFor (hostname) {\n    return this._ca.getCertificateKeysForHostname(hostname)\n    .spread(this._normalizeKeyAndCert)\n  }\n\n  _generateMissingCertificates (hostname) {\n    return this._ca.generateServerCertificateKeys(hostname)\n    .spread(this._normalizeKeyAndCert)\n  }\n\n  _getPortFor (hostname) {\n    return this._getCertificatePathsFor(hostname)\n    .catch((err) => {\n      return this._generateMissingCertificates(hostname)\n    }).then((data = {}) => {\n      if (net.isIP(hostname)) {\n        return this._getServerPortForIp(hostname, data)\n      }\n\n      this._sniServer.addContext(hostname, data)\n\n      return this._sniPort\n    })\n  }\n\n  _listenHttpsServer (data) {\n    return new Promise((resolve, reject) => {\n      const server = https.createServer({\n        ...data,\n        ...httpUtils.lenientOptions,\n      })\n\n      allowDestroy(server)\n\n      server.once('error', reject)\n      server.on('upgrade', this._onUpgrade.bind(this, this._options.onUpgrade))\n      server.on('request', this._onRequest.bind(this, this._options.onRequest))\n\n      return server.listen(0, '127.0.0.1', () => {\n        const {\n          port,\n        } = server.address()\n\n        server.removeListener('error', reject)\n        server.on('error', onError)\n\n        return resolve({ server, port })\n      })\n    })\n  }\n\n  // browsers will not do SNI for an IP address\n  // so we need to serve 1 HTTPS server per IP\n  // https://github.com/cypress-io/cypress/issues/771\n  _getServerPortForIp (ip, data) {\n    let server\n\n    server = sslIpServers[ip]\n\n    if (server) {\n      return server.address().port\n    }\n\n    return this._listenHttpsServer(data)\n    .then(({ server, port }) => {\n      sslIpServers[ip] = server\n\n      debug('Created IP HTTPS Proxy Server', { port, ip })\n\n      return port\n    })\n  }\n\n  listen () {\n    this._onError = this._options.onError\n\n    return this._listenHttpsServer({})\n    .tap(({ server, port }) => {\n      this._sniPort = port\n      this._sniServer = server\n\n      return debug('Created SNI HTTPS Proxy Server', { port })\n    })\n  }\n\n  close () {\n    const close = () => {\n      const servers = _.values(sslIpServers).concat(this._sniServer)\n\n      return Promise.map(servers, (server) => {\n        return Promise.fromCallback(server.destroy)\n        .catch(onError)\n      })\n    }\n\n    return close()\n    .finally(module.exports.reset)\n  }\n}\n\nmodule.exports = {\n  reset () {\n    sslServers = {}\n    sslIpServers = {}\n  },\n\n  create (ca, port, options = {}) {\n    const srv = new Server(ca, port, options)\n\n    return srv\n    .listen()\n    .return(srv)\n  },\n}\n",
    "packages/https-proxy/test/helpers/http_server.js": "/* eslint-disable\n    no-console,\n*/\nconst http = require('http')\nconst Promise = require('bluebird')\n\nconst srv = http.createServer((req, res) => {\n  console.log('HTTP SERVER REQUEST URL:', req.url)\n  console.log('HTTP SERVER REQUEST HEADERS:', req.headers)\n\n  res.setHeader('Content-Type', 'text/html')\n  res.writeHead(200)\n\n  res.end('<html><body>http server</body></html>')\n})\n\nmodule.exports = {\n  srv,\n\n  start () {\n    return new Promise((resolve) => {\n      srv.listen(8080, () => {\n        console.log('server listening on port: 8080')\n\n        resolve(srv)\n      })\n    })\n  },\n\n  stop () {\n    return new Promise((resolve) => {\n      srv.close(resolve)\n    })\n  },\n}\n",
    "packages/https-proxy/test/helpers/https_server.js": "/* eslint-disable\n    no-console,\n*/\nconst https = require('https')\nconst Promise = require('bluebird')\nconst { allowDestroy } = require('@packages/network')\nconst certs = require('./certs')\n\nconst defaultOnRequest = function (req, res) {\n  console.log('HTTPS SERVER REQUEST URL:', req.url)\n  console.log('HTTPS SERVER REQUEST HEADERS:', req.headers)\n\n  res.setHeader('Content-Type', 'text/html')\n  res.writeHead(200)\n\n  res.end('<html><head></head><body>https server</body></html>')\n}\n\nlet servers = []\n\nconst create = (onRequest) => {\n  return https.createServer(certs, onRequest != null ? onRequest : defaultOnRequest)\n}\n\nmodule.exports = {\n  create,\n\n  start (port, onRequest) {\n    return new Promise((resolve) => {\n      const srv = create(onRequest)\n\n      allowDestroy(srv)\n\n      servers.push(srv)\n\n      srv.listen(port, () => {\n        console.log(`server listening on port: ${port}`)\n\n        resolve(srv)\n      })\n    })\n  },\n\n  stop () {\n    const stop = (srv) => {\n      return new Promise((resolve) => {\n        srv.destroy(resolve)\n      })\n    }\n\n    return Promise.map(servers, stop)\n    .then(() => {\n      servers = []\n    })\n  },\n}\n",
    "packages/https-proxy/test/helpers/proxy.js": "/* eslint-disable no-console */\nconst { request } = require('../spec_helper')\nconst { allowDestroy } = require('@packages/network')\nconst http = require('http')\nconst path = require('path')\nconst httpsProxy = require('../../lib/proxy')\n\nlet prx = null\n\nconst pipe = (req, res) => {\n  return req.pipe(request(req.url))\n  .on('error', () => {\n    console.log('**ERROR**', req.url)\n    req.statusCode = 500\n\n    res.end()\n  }).pipe(res)\n}\n\nconst onConnect = (req, socket, head, proxy) => {\n  return proxy.connect(req, socket, head, {\n    onDirectConnection (req, socket, head) {\n      return ['localhost:8444', 'localhost:12344'].includes(req.url)\n    },\n  })\n}\n\nconst onRequest = (req, res) => {\n  return pipe(req, res)\n}\n\nmodule.exports = {\n  reset () {\n    return httpsProxy.reset()\n  },\n\n  start (port) {\n    prx = http.createServer()\n\n    allowDestroy(prx)\n\n    const dir = path.join(process.cwd(), 'ca')\n\n    return httpsProxy.create(dir, port, {\n      onUpgrade (req, socket, head) {},\n\n      onRequest (req, res) {\n        console.log('ON REQUEST FROM OUTER PROXY', req.url, req.headers, req.method)\n\n        if (req.url.includes('replace')) {\n          const {\n            write,\n          } = res\n\n          res.write = function (chunk) {\n            chunk = Buffer.from(chunk.toString().replace('https server', 'replaced content'))\n\n            return write.call(this, chunk)\n          }\n\n          return pipe(req, res)\n        }\n\n        return pipe(req, res)\n      },\n    })\n    .then((proxy) => {\n      prx.on('request', onRequest)\n\n      prx.on('connect', (req, socket, head) => {\n        return onConnect(req, socket, head, proxy)\n      })\n\n      return new Promise((resolve) => {\n        prx.listen(port, () => {\n          prx.proxy = proxy\n          console.log(`server listening on port: ${port}`)\n\n          resolve(proxy)\n        })\n      })\n    })\n  },\n\n  stop () {\n    return new Promise((resolve) => {\n      return prx.destroy(resolve)\n    }).then(() => {\n      return prx.proxy.close()\n    })\n  },\n}\n",
    "packages/https-proxy/test/integration/proxy_spec.js": "process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'\n\nconst { request, expect } = require('../spec_helper')\nconst DebugProxy = require('@cypress/debugging-proxy')\nconst https = require('https')\nconst net = require('net')\nconst network = require('@packages/network')\nconst Promise = require('bluebird')\nconst proxy = require('../helpers/proxy')\nconst httpServer = require('../helpers/http_server')\nconst httpsServer = require('../helpers/https_server')\n\ndescribe('Proxy', () => {\n  beforeEach(function () {\n    return Promise.join(\n      httpServer.start(),\n\n      httpsServer.start(8443),\n\n      httpsServer.start(8444),\n\n      proxy.start(3333)\n      .then((proxy1) => {\n        this.proxy = proxy1\n      }),\n    )\n  })\n\n  afterEach(() => {\n    return Promise.join(\n      httpServer.stop(),\n      httpsServer.stop(),\n      proxy.stop(),\n    )\n  })\n\n  it('can request the googles', function () {\n    // give some padding to external\n    // network request\n    this.timeout(10000)\n\n    return Promise.all([\n      request({\n        strictSSL: false,\n        proxy: 'http://localhost:3333',\n        url: 'https://www.google.com',\n      }),\n\n      request({\n        strictSSL: false,\n        proxy: 'http://localhost:3333',\n        url: 'https://mail.google.com',\n      }),\n\n      request({\n        strictSSL: false,\n        proxy: 'http://localhost:3333',\n        url: 'https://google.com',\n      }),\n    ])\n  })\n\n  it('can call the httpsDirectly without a proxy', () => {\n    return request({\n      strictSSL: false,\n      url: 'https://localhost:8443',\n    })\n  })\n\n  it('can boot the httpsServer', () => {\n    return request({\n      strictSSL: false,\n      url: 'https://localhost:8443/',\n      proxy: 'http://localhost:3333',\n    })\n    .then((html) => {\n      expect(html).to.include('https server')\n    })\n  })\n\n  it('yields the onRequest callback', () => {\n    return request({\n      strictSSL: false,\n      url: 'https://localhost:8443/replace',\n      proxy: 'http://localhost:3333',\n    })\n    .then((html) => {\n      expect(html).to.include('replaced content')\n    })\n  })\n\n  it('closes outgoing connections when client disconnects', function () {\n    this.sandbox.spy(net, 'connect')\n\n    return request({\n      strictSSL: false,\n      url: 'https://localhost:8444/replace',\n      proxy: 'http://localhost:3333',\n      resolveWithFullResponse: true,\n    })\n    .then((res) => {\n      // ensure client has disconnected\n      expect(res.socket.destroyed).to.be.true\n      // ensure the outgoing socket created for this connection was destroyed\n      expect(net.connect).calledOnce\n\n      const socket = net.connect.getCalls()[0].returnValue\n\n      return new Promise((resolve) => {\n        socket.on('close', () => {\n          expect(socket.destroyed).to.be.true\n\n          resolve()\n        })\n      })\n    })\n  })\n\n  it('can boot the httpServer', () => {\n    return request({\n      strictSSL: false,\n      url: 'http://localhost:8080/',\n      proxy: 'http://localhost:3333',\n    })\n\n    .then((html) => {\n      expect(html).to.include('http server')\n    })\n  })\n\n  context('generating certificates', () => {\n    it('reuses existing certificates', function () {\n      return request({\n        strictSSL: false,\n        url: 'https://localhost:8443/',\n        proxy: 'http://localhost:3333',\n      })\n      .then(() => {\n        proxy.reset()\n\n        // force this to reject if its called\n        this.sandbox.stub(this.proxy, '_generateMissingCertificates').rejects(new Error('should not call'))\n\n        return request({\n          strictSSL: false,\n          url: 'https://localhost:8443/',\n          proxy: 'http://localhost:3333',\n        })\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/771\n    it('generates certs and can proxy requests for HTTPS requests to IPs', function () {\n      this.sandbox.spy(this.proxy, '_generateMissingCertificates')\n      this.sandbox.spy(this.proxy, '_getServerPortForIp')\n\n      return Promise.all([\n        httpsServer.start(8445),\n        this.proxy._ca.removeAll(),\n      ])\n      .then(() => {\n        return request({\n          strictSSL: false,\n          url: 'https://127.0.0.1:8445/',\n          proxy: 'http://localhost:3333',\n        })\n      }).then(() => {\n        // this should not stand up its own https server\n        return request({\n          strictSSL: false,\n          url: 'https://localhost:8443/',\n          proxy: 'http://localhost:3333',\n        })\n      }).then(() => {\n        expect(this.proxy._ipServers['127.0.0.1']).to.be.an.instanceOf(https.Server)\n        expect(this.proxy._getServerPortForIp).to.be.calledWith('127.0.0.1').and.be.calledOnce\n\n        expect(this.proxy._generateMissingCertificates).to.be.calledTwice\n      })\n    })\n  })\n\n  context('closing', () => {\n    it('resets sslServers and can reopen', function () {\n      return request({\n        strictSSL: false,\n        url: 'https://localhost:8443/',\n        proxy: 'http://localhost:3333',\n      })\n      .then(() => {\n        return proxy.stop()\n      }).then(() => {\n        return proxy.start(3333)\n      }).then(() => {\n      // force this to reject if its called\n        this.sandbox.stub(this.proxy, '_generateMissingCertificates').rejects(new Error('should not call'))\n\n        return request({\n          strictSSL: false,\n          url: 'https://localhost:8443/',\n          proxy: 'http://localhost:3333',\n        })\n      })\n    })\n  })\n\n  // TODO\n  context('with an upstream proxy', () => {\n    beforeEach(function () {\n      // PROXY vars should override npm_config vars, so set them to cause failures if they are used\n      // @see https://github.com/cypress-io/cypress/pull/8295\n      process.env.npm_config_proxy = process.env.npm_config_https_proxy = 'http://erroneously-used-npm-proxy.invalid'\n      process.env.npm_config_noproxy = 'just,some,nonsense'\n\n      process.env.NO_PROXY = ''\n      process.env.HTTP_PROXY = process.env.HTTPS_PROXY = 'http://localhost:9001'\n\n      this.upstream = new DebugProxy({\n        keepRequests: true,\n      })\n\n      return this.upstream.start(9001)\n    })\n\n    it('passes a request to an https server through the upstream', function () {\n      this.upstream._onConnect = function (domain, port) {\n        expect(domain).to.eq('localhost')\n        expect(port).to.eq('8444')\n\n        return true\n      }\n\n      return request({\n        strictSSL: false,\n        url: 'https://localhost:8444/',\n        proxy: 'http://localhost:3333',\n      }).then((res) => {\n        expect(res).to.contain('https server')\n      })\n    })\n\n    it('uses HTTP basic auth when provided', function () {\n      this.upstream.setAuth({\n        username: 'foo',\n        password: 'bar',\n      })\n\n      this.upstream._onConnect = function (domain, port) {\n        expect(domain).to.eq('localhost')\n        expect(port).to.eq('8444')\n\n        return true\n      }\n\n      process.env.HTTP_PROXY = (process.env.HTTPS_PROXY = 'http://foo:bar@localhost:9001')\n\n      return request({\n        strictSSL: false,\n        url: 'https://localhost:8444/',\n        proxy: 'http://localhost:3333',\n      }).then((res) => {\n        expect(res).to.contain('https server')\n      })\n    })\n\n    it('closes outgoing connections when client disconnects', function () {\n      this.sandbox.spy(net, 'connect')\n\n      return request({\n        strictSSL: false,\n        url: 'https://localhost:8444/replace',\n        proxy: 'http://localhost:3333',\n        resolveWithFullResponse: true,\n        forever: false,\n      })\n      .then((res) => {\n        // ensure client has disconnected\n        expect(res.socket.destroyed).to.be.true\n\n        // ensure the outgoing socket created for this connection was destroyed\n        expect(net.connect).calledOnce\n        const socket = net.connect.getCalls()[0].returnValue\n\n        return new Promise((resolve) => {\n          return socket.on('close', () => {\n            expect(socket.destroyed).to.be.true\n\n            resolve()\n          })\n        })\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/4257\n    it('passes through to SNI when it is intercepted and not through proxy', function () {\n      const createSocket = this.sandbox.stub(network.connect, 'createRetryingSocket').callsArgWith(1, new Error('stub'))\n      const createProxyConn = this.sandbox.spy(network.agent.httpsAgent, 'createUpstreamProxyConnection')\n\n      return request({\n        strictSSL: false,\n        url: 'https://localhost:8443',\n        proxy: 'http://localhost:3333',\n        resolveWithFullResponse: true,\n        forever: false,\n      })\n      .then(() => {\n        throw new Error('should not succeed')\n      }).catch({ message: 'Error: Client network socket disconnected before secure TLS connection was established' }, () => {\n        expect(createProxyConn).to.not.be.called\n\n        expect(createSocket).to.be.calledWith({\n          port: this.proxy._sniPort,\n          host: 'localhost',\n        })\n      })\n    })\n\n    return afterEach(function () {\n      this.upstream.stop()\n      delete process.env.HTTP_PROXY\n      delete process.env.HTTPS_PROXY\n\n      delete process.env.NO_PROXY\n    })\n  })\n})\n",
    "packages/net-stubbing/lib/server/middleware/request.ts": "import _ from 'lodash'\nimport { concatStream } from '@packages/network'\nimport Debug from 'debug'\nimport url from 'url'\n\nimport {\n  RequestMiddleware,\n} from '@packages/proxy'\nimport {\n  CyHttpMessages,\n  SERIALIZABLE_REQ_PROPS,\n} from '../../types'\nimport { getRouteForRequest, matchesRoutePreflight } from '../route-matching'\nimport {\n  sendStaticResponse,\n  setDefaultHeaders,\n  mergeDeletedHeaders,\n  getBodyEncoding,\n} from '../util'\nimport { InterceptedRequest } from '../intercepted-request'\nimport { BackendRoute } from '../types'\n\nconst debug = Debug('cypress:net-stubbing:server:intercept-request')\n\n/**\n * Called when a new request is received in the proxy layer.\n */\nexport const InterceptRequest: RequestMiddleware = async function () {\n  if (matchesRoutePreflight(this.netStubbingState.routes, this.req)) {\n    // send positive CORS preflight response\n    return sendStaticResponse(this, {\n      statusCode: 204,\n      headers: {\n        'access-control-max-age': '-1',\n        'access-control-allow-credentials': 'true',\n        'access-control-allow-origin': this.req.headers.origin || '*',\n        'access-control-allow-methods': this.req.headers['access-control-request-method'] || '*',\n        'access-control-allow-headers': this.req.headers['access-control-request-headers'] || '*',\n      },\n    })\n  }\n\n  const matchingRoutes: BackendRoute[] = []\n\n  const populateMatchingRoutes = (prevRoute?) => {\n    const route = getRouteForRequest(this.netStubbingState.routes, this.req, prevRoute)\n\n    if (!route) {\n      return\n    }\n\n    matchingRoutes.push(route)\n\n    populateMatchingRoutes(route)\n  }\n\n  populateMatchingRoutes()\n\n  if (!matchingRoutes.length) {\n    // not intercepted, carry on normally...\n    return this.next()\n  }\n\n  const request = new InterceptedRequest({\n    continueRequest: this.next,\n    onError: this.onError,\n    onResponse: (incomingRes, resStream) => {\n      setDefaultHeaders(this.req, incomingRes)\n      this.onResponse(incomingRes, resStream)\n    },\n    req: this.req,\n    res: this.res,\n    socket: this.socket,\n    state: this.netStubbingState,\n    matchingRoutes,\n  })\n\n  debug('intercepting request %o', { requestId: request.id, req: _.pick(this.req, 'url') })\n\n  // attach requestId to the original req object for later use\n  this.req.requestId = request.id\n\n  this.netStubbingState.requests[request.id] = request\n\n  const req = _.extend(_.pick(request.req, SERIALIZABLE_REQ_PROPS), {\n    url: request.req.proxiedUrl,\n  }) as CyHttpMessages.IncomingRequest\n\n  request.res.once('finish', async () => {\n    request.handleSubscriptions<CyHttpMessages.ResponseComplete>({\n      eventName: 'after:response',\n      data: request.includeBodyInAfterResponse ? {\n        finalResBody: request.res.body!,\n      } : {},\n      mergeChanges: _.noop,\n    })\n\n    debug('request/response finished, cleaning up %o', { requestId: request.id })\n    delete this.netStubbingState.requests[request.id]\n  })\n\n  const ensureBody = () => {\n    return new Promise<void>((resolve) => {\n      if (req.body) {\n        return resolve()\n      }\n\n      request.req.pipe(concatStream((reqBody) => {\n        req.body = reqBody\n        resolve()\n      }))\n    })\n  }\n\n  await ensureBody()\n\n  if (!_.isString(req.body) && !_.isBuffer(req.body)) {\n    throw new Error('req.body must be a string or a Buffer')\n  }\n\n  const bodyEncoding = getBodyEncoding(req)\n  const bodyIsBinary = bodyEncoding === 'binary'\n\n  if (bodyIsBinary) {\n    debug('req.body contained non-utf8 characters, treating as binary content %o', { requestId: request.id, req: _.pick(this.req, 'url') })\n  }\n\n  // leave the requests that send a binary buffer unchanged\n  // but we can work with the \"normal\" string requests\n  if (!bodyIsBinary) {\n    req.body = req.body.toString('utf8')\n  }\n\n  request.req.body = req.body\n\n  const mergeChanges = (before: CyHttpMessages.IncomingRequest, after: CyHttpMessages.IncomingRequest) => {\n    if (before.headers['content-length'] === after.headers['content-length']) {\n      // user did not purposely override content-length, let's set it\n      after.headers['content-length'] = String(Buffer.from(after.body).byteLength)\n    }\n\n    // resolve and propagate any changes to the URL\n    request.req.proxiedUrl = after.url = url.resolve(request.req.proxiedUrl, after.url)\n\n    // if the body is binary, don't recursively merge it or it will get\n    // incorrectly converted from a Buffer into an array\n    // @see https://github.com/cypress-io/cypress/issues/15898\n    const serializableProps = _.without(SERIALIZABLE_REQ_PROPS, 'body')\n\n    _.merge(before, _.pick(after, serializableProps))\n\n    if (bodyIsBinary) {\n      before.body = after.body\n    } else {\n      _.merge(before, { body: after.body })\n    }\n\n    mergeDeletedHeaders(before, after)\n  }\n\n  const modifiedReq = await request.handleSubscriptions<CyHttpMessages.IncomingRequest>({\n    eventName: 'before:request',\n    data: req,\n    mergeChanges,\n  })\n\n  mergeChanges(req, modifiedReq)\n  // @ts-ignore\n  mergeChanges(request.req, req)\n\n  if (request.responseSent) {\n    // request has been fulfilled with a response already, do not send the request outgoing\n    // @see https://github.com/cypress-io/cypress/issues/15841\n    return this.end()\n  }\n\n  return request.continueRequest()\n}\n",
    "packages/rewriter/lib/html.ts": "import RewritingStream from 'parse5-html-rewriting-stream'\nimport * as htmlRules from './html-rules'\nimport stream from 'stream'\nimport { DeferSourceMapRewriteFn } from './js'\n\n// the HTML rewriter passes inline JS to the JS rewriter, hence\n// the lack of basic `rewriteHtml` or `HtmlRewriter` exports here\n\nexport function HtmlJsRewriter (url: string, deferSourceMapRewrite?: DeferSourceMapRewriteFn): stream.Transform {\n  const rewriter = new RewritingStream()\n\n  htmlRules.install(url, rewriter, deferSourceMapRewrite)\n\n  return rewriter\n}\n\nexport function rewriteHtmlJs (url: string, html: string, deferSourceMapRewrite?: DeferSourceMapRewriteFn): Promise<string> {\n  let out = ''\n  const rewriter = HtmlJsRewriter(url, deferSourceMapRewrite)\n\n  rewriter.on('data', (chunk) => {\n    out += chunk\n  })\n\n  rewriter.end(html)\n\n  return new Promise<string>((resolve) => {\n    rewriter.on('end', () => {\n      resolve(out)\n    })\n  })\n}\n",
    "packages/runner/cypress/support/helpers.js": "/* eslint prefer-rest-params: \"off\", no-console: \"off\", arrow-body-style: \"off\"*/\n\nconst { _ } = Cypress\nconst debug = require('debug')('spec')\nconst snapshotCommand = require('../plugins/snapshot/snapshotCommand')\n\n/**\n * @type {sinon.SinonMatch}\n */\nconst match = Cypress.sinon.match\n\nconst { stringifyShort } = snapshotCommand\n\nconst eventCleanseMap = {\n  snapshots: stringifyShort,\n  parent: stringifyShort,\n  tests: stringifyShort,\n  commands: stringifyShort,\n  invocationDetails: stringifyShort,\n  body: '[body]',\n  wallClockStartedAt: match.date,\n  lifecycle: match.number,\n  fnDuration: match.number,\n  duration: match.number,\n  afterFnDuration: match.number,\n  wallClockDuration: match.number,\n  stack: match.string,\n  message: '[error message]',\n  sourceMappedStack: match.string,\n  parsedStack: match.array,\n}\n\nconst mochaEventCleanseMap = {\n  ...eventCleanseMap,\n  start: match.date,\n  end: match.date,\n}\n\nconst cleanseRunStateMap = {\n  ...eventCleanseMap,\n  'err.stack': '[err stack]',\n  wallClockStartedAt: new Date(0),\n  wallClockDuration: 1,\n  fnDuration: 1,\n  afterFnDuration: 1,\n  lifecycle: 1,\n  duration: 1,\n  startTime: new Date(0),\n}\n\nconst spyOn = (obj, prop, fn) => {\n  const _fn = obj[prop]\n\n  obj[prop] = function () {\n    fn.apply(this, arguments)\n\n    const ret = _fn.apply(this, arguments)\n\n    return ret\n  }\n}\n\nfunction createCypress (defaultOptions = {}) {\n  /**\n   * @type {sinon.SinonStub}\n   */\n  let allStubs\n  /**\n     * @type {sinon.SinonStub}\n     */\n  let mochaStubs\n  /**\n     * @type {sinon.SinonStub}\n     */\n  let setRunnablesStub\n\n  const enableStubSnapshots = false\n  // const enableStubSnapshots = true\n\n  let autCypress\n\n  const getAutCypress = () => autCypress\n\n  const snapshotMochaEvents = () => {\n    expect(mochaStubs.args).to.matchSnapshot(mochaEventCleanseMap, name.mocha)\n  }\n\n  snapshotCommand.registerInCypress()\n\n  const backupCy = window.cy\n  const backupCypress = window.Cypress\n\n  beforeEach(() => {\n    window.cy = backupCy\n    window.Cypress = backupCypress\n  })\n\n  /**\n   * Spawns an isolated Cypress runner as the AUT, with provided spec/fixture and optional state/config\n   * @param {string | ()=>void | {[key:string]: any}} mochaTestsOrFile\n   * @param {{state?: any, config?: any}} opts\n   */\n  const runIsolatedCypress = (mochaTestsOrFile, opts = {}) => {\n    opts = _.defaultsDeep(opts, defaultOptions, {\n      state: {},\n      config: { video: false },\n      onBeforeRun () {},\n      visitUrl: 'http://localhost:3500/fixtures/dom.html',\n      visitSuccess: true,\n    })\n\n    return cy.visit('/fixtures/isolated-runner.html#/tests/cypress/fixtures/empty_spec.js')\n    .then({ timeout: 60000 }, (win) => {\n      win.runnerWs.destroy()\n\n      allStubs = cy.stub().snapshot(enableStubSnapshots).log(false)\n      mochaStubs = cy.stub().snapshot(enableStubSnapshots).log(false)\n      setRunnablesStub = cy.stub().snapshot(enableStubSnapshots).log(false)\n\n      return new Promise((resolve) => {\n        const runIsolatedCypress = () => {\n          autCypress.run.restore()\n\n          const emit = autCypress.emit\n          const emitMap = autCypress.emitMap\n          const emitThen = autCypress.emitThen\n\n          cy.stub(autCypress, 'automation').log(false).snapshot(enableStubSnapshots)\n          .callThrough()\n          .withArgs('clear:cookies')\n          .resolves({\n            foo: 'bar',\n          })\n          .withArgs('take:screenshot')\n          .resolves({\n            path: '/path/to/screenshot',\n            size: 12,\n            dimensions: { width: 20, height: 20 },\n            multipart: false,\n            pixelRatio: 1,\n            takenAt: new Date().toISOString(),\n            name: 'name',\n            blackout: ['.foo'],\n            duration: 100,\n          })\n\n          cy.stub(autCypress, 'emit').snapshot(enableStubSnapshots).log(false)\n          .callsFake(function () {\n            const noLog = _.includes([\n              'navigation:changed',\n              'stability:changed',\n              'window:load',\n              'url:changed',\n              'log:added',\n              'page:loading',\n              'window:unload',\n              'newListener',\n            ], arguments[0])\n            const noCall = _.includes(['window:before:unload', 'mocha'], arguments[0])\n            const isMocha = _.includes(['mocha'], arguments[0])\n\n            if (isMocha) {\n              mochaStubs.apply(this, arguments)\n            }\n\n            noLog || allStubs.apply(this, ['emit'].concat([].slice.call(arguments)))\n\n            return noCall || emit.apply(this, arguments)\n          })\n\n          cy.stub(autCypress, 'emitMap').snapshot(enableStubSnapshots).log(false)\n          .callsFake(function () {\n            allStubs.apply(this, ['emitMap'].concat([].slice.call(arguments)))\n\n            return emitMap.apply(this, arguments)\n          })\n\n          cy.stub(autCypress, 'emitThen').snapshot(enableStubSnapshots).log(false)\n          .callsFake(function () {\n            allStubs.apply(this, ['emitThen'].concat([].slice.call(arguments)))\n\n            return emitThen.apply(this, arguments)\n          })\n\n          spyOn(autCypress.mocha.getRunner(), 'fail', (...args) => {\n            Cypress.log({\n              name: 'Runner (fail event)',\n              ended: true,\n              event: true,\n              message: `${args[1]}`,\n              state: 'failed',\n              consoleProps: () => {\n                return {\n                  Error: args[1],\n                }\n              },\n            })\n          })\n\n          // TODO: clean this up, sinon doesn't like wrapping things multiple times\n          // and this catches that error\n          try {\n            cy.spy(cy.state('window').console, 'log').as('console_log').log(false)\n            cy.spy(cy.state('window').console, 'error').as('console_error').log(false)\n          } catch (_e) {\n            // console was already wrapped, noop\n          }\n\n          autCypress.run((failed) => {\n            resolve({ failed, mochaStubs, autCypress, win })\n          })\n        }\n\n        cy.spy(win.eventManager.reporterBus, 'emit').snapshot(enableStubSnapshots).log(false).as('reporterBus')\n        cy.spy(win.eventManager.localBus, 'emit').snapshot(enableStubSnapshots).log(false).as('localBus')\n\n        cy.stub(win.runnerWs, 'emit').snapshot(enableStubSnapshots).log(false)\n        .withArgs('watch:test:file')\n        .callsFake(() => {\n          autCypress = win.Cypress\n\n          cy.stub(autCypress, 'onSpecWindow').snapshot(enableStubSnapshots).log(false).callsFake((specWindow) => {\n            autCypress.onSpecWindow.restore()\n\n            opts.onBeforeRun({ specWindow, win, autCypress })\n\n            const testsInOwnFile = _.isString(mochaTestsOrFile)\n            const relativeFile = testsInOwnFile ? mochaTestsOrFile : 'cypress/fixtures/empty_spec.js'\n\n            autCypress.onSpecWindow(specWindow, [\n              {\n                absolute: relativeFile,\n                relative: relativeFile,\n                relativeUrl: `/__cypress/tests?p=${relativeFile}`,\n              },\n            ])\n\n            if (testsInOwnFile) return\n\n            generateMochaTestsForWin(specWindow, mochaTestsOrFile)\n          })\n\n          cy.stub(autCypress, 'run').snapshot(enableStubSnapshots).log(false).callsFake(runIsolatedCypress)\n        })\n        .withArgs('is:automation:client:connected')\n        .yieldsAsync(true)\n\n        .withArgs('get:existing:run:state')\n        .callsFake((evt, cb) => {\n          cb(opts.state)\n        })\n\n        .withArgs('backend:request', 'net')\n        .yieldsAsync({})\n\n        .withArgs('backend:request', 'reset:server:state')\n        .yieldsAsync({})\n\n        .withArgs('backend:request', 'resolve:url')\n        .yieldsAsync({ response: {\n          isOkStatusCode: opts.visitSuccess,\n          isHtml: true,\n          url: opts.visitUrl,\n        } })\n\n        .withArgs('set:runnables:and:maybe:record:tests')\n        .callsFake((...args) => {\n          setRunnablesStub(...args)\n          _.last(args)()\n        })\n\n        // .withArgs('preserve:run:state')\n        // .callsFake()\n\n        .withArgs('automation:request')\n        .yieldsAsync({ response: {} })\n\n        const c = _.extend({}, Cypress.config(), {\n          isTextTerminal: false,\n          spec: {\n            relative: 'relative/path/to/spec.js',\n            absolute: '/absolute/path/to/spec.js',\n            name: 'empty_spec.js',\n          },\n        }, opts.config)\n\n        c.state = {}\n\n        cy.stub(win.runnerWs, 'on').snapshot(enableStubSnapshots).log(false)\n\n        win.Runner.start(win.document.getElementById('app'), window.btoa(JSON.stringify(c)))\n      })\n    })\n  }\n\n  return {\n    runIsolatedCypress,\n    snapshotMochaEvents,\n    getAutCypress,\n  }\n}\n\nconst createHooks = (win, hooks = []) => {\n  _.each(hooks, (hook) => {\n    if (_.isString(hook)) {\n      hook = { type: hook }\n    }\n\n    let { type, fail, fn, agents } = hook\n\n    if (fn) {\n      if (hook.eval) {\n        const fnStr = fn.toString()\n\n        const newFn = function () {\n          return win.eval(`(${fnStr})`).call(this)\n        }\n\n        Object.defineProperty(newFn, 'length', { value: fn.length })\n        fn = newFn\n      }\n\n      return win[type](fn)\n    }\n\n    if (fail) {\n      const numFailures = fail\n\n      return win[type](function () {\n        const message = `${type} - ${this._runnable.parent.title || 'root'}`\n\n        if (agents) {\n          registerAgents(win)\n        }\n\n        if (_.isNumber(fail) && fail-- <= 0) {\n          debug(`hook pass after (${numFailures}) failures: ${type}`)\n          win.assert(true, message)\n\n          return\n        }\n\n        if (agents) {\n          failCypressCommand(win, type)\n        } else {\n          debug(`hook fail: ${type}`)\n\n          win.assert(false, message)\n\n          throw new Error(`hook failed: ${type}`)\n        }\n      })\n    }\n\n    return win[type](function () {\n      win.assert(true, `${type} - ${this._runnable.parent.title || 'root'}`)\n      debug(`hook pass: ${type}`)\n    })\n  })\n}\n\nconst createTests = (win, tests = []) => {\n  _.each(tests, (test) => {\n    if (_.isString(test)) {\n      test = { name: test }\n    }\n\n    let { name, pending, fail, fn, only, agents } = test\n\n    let it = win.it\n\n    if (only) {\n      it = it['only']\n    }\n\n    if (fn) {\n      if (test.eval) {\n        const fnStr = fn.toString()\n\n        const newFn = function () {\n          return win.eval(`(${fnStr})`).call(this)\n        }\n\n        Object.defineProperty(newFn, 'length', { value: fn.length })\n        fn = newFn\n      }\n\n      return it(name, fn)\n    }\n\n    if (pending) {\n      return it(name)\n    }\n\n    if (fail) {\n      return it(name, () => {\n        if (agents) {\n          registerAgents(win)\n        }\n\n        if (_.isNumber(fail) && fail-- === 0) {\n          debug(`test pass after retry: ${name}`)\n          win.assert(true, name)\n\n          return\n        }\n\n        if (agents) {\n          failCypressCommand(win, name)\n        } else {\n          debug(`test fail: ${name}`)\n          win.assert(false, name)\n\n          throw new Error(`test fail: ${name}`)\n        }\n      })\n    }\n\n    return it(name, () => {\n      debug(`test pass: ${name}`)\n      win.assert(true, name)\n    })\n  })\n}\n\nconst failCypressCommand = (win, name) => win.cy.wrap(name).then(() => win.assert(false, name))\nconst registerAgents = (win) => {\n  const obj = { foo: 'bar' }\n\n  win.cy.stub(obj, 'foo')\n  win.cy.wrap(obj).should('exist')\n  win.cy.server()\n  win.cy.route('https://example.com')\n}\n\nconst createSuites = (win, suites = {}) => {\n  _.each(suites, (obj, suiteName) => {\n    let fn = () => {\n      createHooks(win, obj.hooks)\n      createTests(win, obj.tests)\n      createSuites(win, obj.suites)\n    }\n\n    if (_.isFunction(obj)) {\n      fn = evalFn(win, obj)\n    }\n\n    win.describe(suiteName, fn)\n  })\n}\n\nconst generateMochaTestsForWin = (win, obj) => {\n  if (typeof obj === 'function') {\n    win.eval(`( ${obj.toString()})()`)\n\n    return\n  }\n\n  createHooks(win, obj.hooks)\n  createTests(win, obj.tests)\n  createSuites(win, obj.suites)\n}\n\nconst evalFn = (win, fn) => {\n  return function () {\n    return win.eval(`(${fn.toString()})`).call(this)\n  }\n}\n\nconst shouldHaveTestResults = (expPassed, expFailed, expPending) => {\n  return () => {\n    expPassed = expPassed || '--'\n    expFailed = expFailed || '--'\n    cy.get('header .passed .num').should('have.text', `${expPassed}`)\n    cy.get('header .failed .num').should('have.text', `${expFailed}`)\n    if (expPending) cy.get('header .pending .num').should('have.text', `${expPending}`)\n  }\n}\n\nconst containText = (text) => {\n  return (($el) => {\n    expect($el[0]).property('innerText').contain(text)\n  })\n}\n\nconst getRunState = (Cypress) => {\n  const currentRunnable = Cypress.cy.state('runnable')\n  const currentId = currentRunnable && currentRunnable.id\n\n  const s = {\n    currentId,\n    tests: Cypress.runner.getTestsState(),\n    startTime: Cypress.runner.getStartTime(),\n    emissions: Cypress.runner.getEmissions(),\n  }\n\n  s.passed = Cypress.runner.countByTestState(s.tests, 'passed')\n  s.failed = Cypress.runner.countByTestState(s.tests, 'failed')\n  s.pending = Cypress.runner.countByTestState(s.tests, 'pending')\n  s.numLogs = Cypress.Log.countLogsByTests(s.tests)\n\n  return _.cloneDeep(s)\n}\n\nmodule.exports = {\n  generateMochaTestsForWin,\n  createCypress,\n  containText,\n  cleanseRunStateMap,\n  shouldHaveTestResults,\n  getRunState,\n}\n",
    "packages/runner/src/lib/event-manager.js": "import _ from 'lodash'\nimport { EventEmitter } from 'events'\nimport Promise from 'bluebird'\nimport { action } from 'mobx'\n\nimport { client } from '@packages/socket'\n\nimport automation from './automation'\nimport logger from './logger'\nimport studioRecorder from '../studio/studio-recorder'\nimport selectorPlaygroundModel from '../selector-playground/selector-playground-model'\n\nimport $Cypress, { $ } from '@packages/driver'\n\nconst ws = client.connect({\n  path: '/__socket.io',\n  transports: ['websocket'],\n})\n\nws.on('connect', () => {\n  ws.emit('runner:connected')\n})\n\nconst driverToReporterEvents = 'paused before:firefox:force:gc after:firefox:force:gc'.split(' ')\nconst driverToLocalAndReporterEvents = 'run:start run:end'.split(' ')\nconst driverToSocketEvents = 'backend:request automation:request mocha recorder:frame'.split(' ')\nconst driverTestEvents = 'test:before:run:async test:after:run'.split(' ')\nconst driverToLocalEvents = 'viewport:changed config stop url:changed page:loading visit:failed'.split(' ')\nconst socketRerunEvents = 'runner:restart'.split(' ')\nconst socketToDriverEvents = 'net:event script:error'.split(' ')\nconst localToReporterEvents = 'reporter:log:add reporter:log:state:changed reporter:log:remove'.split(' ')\n\nconst localBus = new EventEmitter()\nconst reporterBus = new EventEmitter()\n\n// NOTE: this is exposed for testing, ideally we should only expose this if a test flag is set\nwindow.runnerWs = ws\n\n// NOTE: this is for testing Cypress-in-Cypress, window.Cypress is undefined here\n// unless Cypress has been loaded into the AUT frame\nif (window.Cypress) {\n  window.eventManager = { reporterBus, localBus }\n}\n\n/**\n * @type {Cypress.Cypress}\n */\nlet Cypress\n\nconst eventManager = {\n  reporterBus,\n\n  getCypress () {\n    return Cypress\n  },\n\n  addGlobalListeners (state, connectionInfo) {\n    const rerun = () => {\n      if (!this) {\n        // if the tests have been reloaded\n        // then nothing to rerun\n        return\n      }\n\n      return this._reRun(state)\n    }\n\n    ws.emit('is:automation:client:connected', connectionInfo, action('automationEnsured', (isConnected) => {\n      state.automation = isConnected ? automation.CONNECTED : automation.MISSING\n      ws.on('automation:disconnected', action('automationDisconnected', () => {\n        state.automation = automation.DISCONNECTED\n      }))\n    }))\n\n    ws.on('change:to:url', (url) => {\n      window.location.href = url\n    })\n\n    ws.on('automation:push:message', (msg, data = {}) => {\n      if (!Cypress) return\n\n      switch (msg) {\n        case 'change:cookie':\n          Cypress.Cookies.log(data.message, data.cookie, data.removed)\n          break\n        case 'create:download':\n          Cypress.downloads.start(data)\n          break\n        case 'complete:download':\n          Cypress.downloads.end(data)\n          break\n        default:\n          break\n      }\n    })\n\n    ws.on('watched:file:changed', () => {\n      studioRecorder.cancel()\n      rerun()\n    })\n\n    _.each(socketRerunEvents, (event) => {\n      ws.on(event, rerun)\n    })\n\n    _.each(socketToDriverEvents, (event) => {\n      ws.on(event, (...args) => {\n        Cypress.emit(event, ...args)\n      })\n    })\n\n    _.each(localToReporterEvents, (event) => {\n      localBus.on(event, (...args) => {\n        reporterBus.emit(event, ...args)\n      })\n    })\n\n    const logCommand = (logId) => {\n      const consoleProps = Cypress.runner.getConsolePropsForLogById(logId)\n\n      logger.logFormatted(consoleProps)\n    }\n\n    reporterBus.on('runner:console:error', ({ err, commandId }) => {\n      if (!Cypress) return\n\n      if (commandId || err) logger.clearLog()\n\n      if (commandId) logCommand(commandId)\n\n      if (err) logger.logError(err.stack)\n    })\n\n    reporterBus.on('runner:console:log', (logId) => {\n      if (!Cypress) return\n\n      logger.clearLog()\n      logCommand(logId)\n    })\n\n    reporterBus.on('focus:tests', this.focusTests)\n\n    reporterBus.on('get:user:editor', (cb) => {\n      ws.emit('get:user:editor', cb)\n    })\n\n    reporterBus.on('set:user:editor', (editor) => {\n      ws.emit('set:user:editor', editor)\n    })\n\n    reporterBus.on('runner:restart', rerun)\n\n    function sendEventIfSnapshotProps (logId, event) {\n      if (!Cypress) return\n\n      const snapshotProps = Cypress.runner.getSnapshotPropsForLogById(logId)\n\n      if (snapshotProps) {\n        localBus.emit(event, snapshotProps)\n      }\n    }\n\n    reporterBus.on('runner:show:snapshot', (logId) => {\n      sendEventIfSnapshotProps(logId, 'show:snapshot')\n    })\n\n    reporterBus.on('runner:hide:snapshot', this._hideSnapshot.bind(this))\n\n    reporterBus.on('runner:pin:snapshot', (logId) => {\n      sendEventIfSnapshotProps(logId, 'pin:snapshot')\n    })\n\n    reporterBus.on('runner:unpin:snapshot', this._unpinSnapshot.bind(this))\n\n    reporterBus.on('runner:resume', () => {\n      if (!Cypress) return\n\n      Cypress.emit('resume:all')\n    })\n\n    reporterBus.on('runner:next', () => {\n      if (!Cypress) return\n\n      Cypress.emit('resume:next')\n    })\n\n    reporterBus.on('runner:stop', () => {\n      if (!Cypress) return\n\n      Cypress.stop()\n    })\n\n    reporterBus.on('save:state', (state) => {\n      this.saveState(state)\n    })\n\n    reporterBus.on('external:open', (url) => {\n      ws.emit('external:open', url)\n    })\n\n    reporterBus.on('open:file', (url) => {\n      ws.emit('open:file', url)\n    })\n\n    const studioInit = () => {\n      ws.emit('studio:init', (showedStudioModal) => {\n        if (!showedStudioModal) {\n          studioRecorder.showInitModal()\n        } else {\n          rerun()\n        }\n      })\n    }\n\n    reporterBus.on('studio:init:test', (testId) => {\n      studioRecorder.setTestId(testId)\n\n      studioInit()\n    })\n\n    reporterBus.on('studio:init:suite', (suiteId) => {\n      studioRecorder.setSuiteId(suiteId)\n\n      studioInit()\n    })\n\n    reporterBus.on('studio:cancel', () => {\n      studioRecorder.cancel()\n      rerun()\n    })\n\n    reporterBus.on('studio:remove:command', (commandId) => {\n      studioRecorder.removeLog(commandId)\n    })\n\n    reporterBus.on('studio:save', () => {\n      studioRecorder.startSave()\n    })\n\n    localBus.on('studio:start', () => {\n      studioRecorder.closeInitModal()\n      rerun()\n    })\n\n    localBus.on('studio:save', (saveInfo) => {\n      ws.emit('studio:save', saveInfo, (err) => {\n        if (err) {\n          reporterBus.emit('test:set:state', studioRecorder.saveError(err), _.noop)\n        }\n      })\n    })\n\n    localBus.on('studio:cancel', () => {\n      studioRecorder.cancel()\n      rerun()\n    })\n\n    const $window = $(window)\n\n    $window.on('hashchange', rerun)\n\n    // when we actually unload then\n    // nuke all of the cookies again\n    // so we clear out unload\n    $window.on('unload', () => {\n      this._clearAllCookies()\n    })\n\n    // when our window triggers beforeunload\n    // we know we've change the URL and we need\n    // to clear our cookies\n    // additionally we set unload to true so\n    // that Cypress knows not to set any more\n    // cookies\n    $window.on('beforeunload', () => {\n      reporterBus.emit('reporter:restart:test:run')\n\n      this._clearAllCookies()\n      this._setUnload()\n    })\n  },\n\n  start (config) {\n    if (config.socketId) {\n      ws.emit('app:connect', config.socketId)\n    }\n  },\n\n  setup (config) {\n    Cypress = this.Cypress = $Cypress.create(config)\n\n    // expose Cypress globally\n    window.Cypress = Cypress\n\n    this._addListeners()\n\n    ws.emit('watch:test:file', config.spec)\n  },\n\n  isBrowser (browserName) {\n    if (!this.Cypress) return false\n\n    return this.Cypress.isBrowser(browserName)\n  },\n\n  initialize ($autIframe, config) {\n    performance.mark('initialize-start')\n\n    return Cypress.initialize({\n      $autIframe,\n      onSpecReady: () => {\n        // get the current runnable in case we reran mid-test due to a visit\n        // to a new domain\n        ws.emit('get:existing:run:state', (state = {}) => {\n          if (!Cypress.runner) {\n            // the tests have been reloaded\n            return\n          }\n\n          this._restoreStudioFromState(state)\n\n          this._initializeStudio(config)\n\n          const runnables = Cypress.runner.normalizeAll(state.tests)\n\n          const run = () => {\n            performance.mark('initialize-end')\n            performance.measure('initialize', 'initialize-start', 'initialize-end')\n\n            this._runDriver(state)\n          }\n\n          reporterBus.emit('runnables:ready', runnables)\n\n          if (state.numLogs) {\n            Cypress.runner.setNumLogs(state.numLogs)\n          }\n\n          if (state.startTime) {\n            Cypress.runner.setStartTime(state.startTime)\n          }\n\n          if (config.isTextTerminal && !state.currentId) {\n            // we are in run mode and it's the first load\n            // store runnables in backend and maybe send to dashboard\n            return ws.emit('set:runnables:and:maybe:record:tests', runnables, run)\n          }\n\n          if (state.currentId) {\n            // if we have a currentId it means\n            // we need to tell the Cypress to skip\n            // ahead to that test\n            Cypress.runner.resumeAtTest(state.currentId, state.emissions)\n          }\n\n          run()\n        })\n      },\n    })\n  },\n\n  _addListeners () {\n    Cypress.on('message', (msg, data, cb) => {\n      ws.emit('client:request', msg, data, cb)\n    })\n\n    _.each(driverToSocketEvents, (event) => {\n      Cypress.on(event, (...args) => {\n        return ws.emit(event, ...args)\n      })\n    })\n\n    Cypress.on('collect:run:state', () => {\n      if (Cypress.env('NO_COMMAND_LOG')) {\n        return Promise.resolve()\n      }\n\n      return new Promise((resolve) => {\n        reporterBus.emit('reporter:collect:run:state', (reporterState) => {\n          resolve({\n            ...reporterState,\n            studioTestId: studioRecorder.testId,\n            studioSuiteId: studioRecorder.suiteId,\n            studioUrl: studioRecorder.url,\n          })\n        })\n      })\n    })\n\n    Cypress.on('log:added', (log) => {\n      const displayProps = Cypress.runner.getDisplayPropsForLog(log)\n\n      this._interceptStudio(displayProps)\n\n      reporterBus.emit('reporter:log:add', displayProps)\n    })\n\n    Cypress.on('log:changed', (log) => {\n      const displayProps = Cypress.runner.getDisplayPropsForLog(log)\n\n      this._interceptStudio(displayProps)\n\n      reporterBus.emit('reporter:log:state:changed', displayProps)\n    })\n\n    Cypress.on('before:screenshot', (config, cb) => {\n      const beforeThenCb = () => {\n        localBus.emit('before:screenshot', config)\n        cb()\n      }\n\n      if (Cypress.env('NO_COMMAND_LOG')) {\n        return beforeThenCb()\n      }\n\n      const wait = !config.appOnly && config.waitForCommandSynchronization\n\n      if (!config.appOnly) {\n        reporterBus.emit('test:set:state', _.pick(config, 'id', 'isOpen'), wait ? beforeThenCb : undefined)\n      }\n\n      if (!wait) beforeThenCb()\n    })\n\n    Cypress.on('after:screenshot', (config) => {\n      localBus.emit('after:screenshot', config)\n    })\n\n    _.each(driverToReporterEvents, (event) => {\n      Cypress.on(event, (...args) => {\n        reporterBus.emit(event, ...args)\n      })\n    })\n\n    _.each(driverTestEvents, (event) => {\n      Cypress.on(event, (test, cb) => {\n        reporterBus.emit(event, test, cb)\n      })\n    })\n\n    _.each(driverToLocalAndReporterEvents, (event) => {\n      Cypress.on(event, (...args) => {\n        localBus.emit(event, ...args)\n        reporterBus.emit(event, ...args)\n      })\n    })\n\n    _.each(driverToLocalEvents, (event) => {\n      Cypress.on(event, (...args) => {\n        return localBus.emit(event, ...args)\n      })\n    })\n\n    Cypress.on('script:error', (err) => {\n      Cypress.stop()\n      localBus.emit('script:error', err)\n    })\n\n    Cypress.on('test:before:run:async', (test) => {\n      if (studioRecorder.suiteId) {\n        studioRecorder.setTestId(test.id)\n      }\n\n      if (studioRecorder.hasRunnableId && test.invocationDetails) {\n        studioRecorder.setFileDetails(test.invocationDetails)\n      }\n    })\n\n    Cypress.on('test:after:run', (test) => {\n      if (studioRecorder.isOpen && test.state !== 'passed') {\n        studioRecorder.testFailed()\n      }\n    })\n  },\n\n  _runDriver (state) {\n    performance.mark('run-s')\n    Cypress.run(() => {\n      performance.mark('run-e')\n      performance.measure('run', 'run-s', 'run-e')\n    })\n\n    reporterBus.emit('reporter:start', {\n      firefoxGcInterval: Cypress.getFirefoxGcInterval(),\n      startTime: Cypress.runner.getStartTime(),\n      numPassed: state.passed,\n      numFailed: state.failed,\n      numPending: state.pending,\n      autoScrollingEnabled: state.autoScrollingEnabled,\n      scrollTop: state.scrollTop,\n      studioActive: studioRecorder.hasRunnableId,\n    })\n  },\n\n  stop () {\n    localBus.removeAllListeners()\n    ws.off()\n  },\n\n  _reRun (state) {\n    if (!Cypress) return\n\n    state.setIsLoading(true)\n\n    // when we are re-running we first\n    // need to stop cypress always\n    Cypress.stop()\n\n    studioRecorder.setInactive()\n    selectorPlaygroundModel.setOpen(false)\n\n    return this._restart()\n    .then(() => {\n      // this probably isn't 100% necessary\n      // since Cypress will fall out of scope\n      // but we want to be aggressive here\n      // and force GC early and often\n      Cypress.removeAllListeners()\n\n      localBus.emit('restart')\n    })\n  },\n\n  _restart () {\n    return new Promise((resolve) => {\n      reporterBus.once('reporter:restarted', resolve)\n      reporterBus.emit('reporter:restart:test:run')\n    })\n  },\n\n  _restoreStudioFromState (state) {\n    if (state.studioTestId) {\n      studioRecorder.setTestId(state.studioTestId)\n    }\n\n    if (state.studioSuiteId) {\n      studioRecorder.setSuiteId(state.studioSuiteId)\n    }\n\n    if (state.studioUrl) {\n      studioRecorder.setUrl(state.studioUrl)\n    }\n  },\n\n  _initializeStudio (config) {\n    if (studioRecorder.hasRunnableId) {\n      studioRecorder.startLoading()\n\n      if (studioRecorder.suiteId) {\n        Cypress.runner.setOnlySuiteId(studioRecorder.suiteId)\n\n        // root runnable always has id of r1\n        // and does not have invocationDetails so we must set manually from config\n        if (studioRecorder.suiteId === 'r1') {\n          studioRecorder.setFileDetails({\n            absoluteFile: config.spec.absolute,\n            line: null,\n            column: null,\n          })\n        }\n      } else if (studioRecorder.testId) {\n        Cypress.runner.setOnlyTestId(studioRecorder.testId)\n      }\n    }\n  },\n\n  _interceptStudio (displayProps) {\n    if (studioRecorder.isActive) {\n      displayProps.hookId = studioRecorder.hookId\n\n      if (displayProps.name === 'visit' && displayProps.state === 'failed') {\n        studioRecorder.testFailed()\n        reporterBus.emit('test:set:state', studioRecorder.testError, _.noop)\n      }\n    }\n\n    return displayProps\n  },\n\n  emit (event, ...args) {\n    localBus.emit(event, ...args)\n  },\n\n  on (event, ...args) {\n    localBus.on(event, ...args)\n  },\n\n  notifyRunningSpec (specFile) {\n    ws.emit('spec:changed', specFile)\n  },\n\n  focusTests () {\n    ws.emit('focus:tests')\n  },\n\n  snapshotUnpinned () {\n    this._unpinSnapshot()\n    this._hideSnapshot()\n    reporterBus.emit('reporter:snapshot:unpinned')\n  },\n\n  _unpinSnapshot () {\n    localBus.emit('unpin:snapshot')\n  },\n\n  _hideSnapshot () {\n    localBus.emit('hide:snapshot')\n  },\n\n  launchBrowser (browser) {\n    ws.emit('reload:browser', window.location.toString(), browser && browser.name)\n  },\n\n  // clear all the cypress specific cookies\n  // whenever our app starts\n  // and additional when we stop running our tests\n  _clearAllCookies () {\n    if (!Cypress) return\n\n    Cypress.Cookies.clearCypressCookies()\n  },\n\n  _setUnload () {\n    if (!Cypress) return\n\n    Cypress.Cookies.setCy('unload', true)\n  },\n\n  saveState (state) {\n    ws.emit('save:app:state', state)\n  },\n}\n\nexport default eventManager\n",
    "packages/runner-ct/src/lib/event-manager.js": "import _ from 'lodash'\nimport { EventEmitter } from 'events'\nimport Promise from 'bluebird'\nimport { action } from 'mobx'\n\nimport { client } from '@packages/socket'\n\nimport automation from './automation'\nimport logger from './logger'\n\nimport $Cypress, { $ } from '@packages/driver'\n\nconst ws = client.connect({\n  path: '/__socket.io',\n  transports: ['websocket'],\n})\n\nws.on('connect', () => {\n  ws.emit('runner:connected')\n})\n\nconst driverToReporterEvents = 'paused before:firefox:force:gc after:firefox:force:gc'.split(' ')\nconst driverToLocalAndReporterEvents = 'run:start run:end'.split(' ')\nconst driverToSocketEvents = 'backend:request automation:request mocha recorder:frame'.split(' ')\nconst driverTestEvents = 'test:before:run:async test:after:run'.split(' ')\nconst driverToLocalEvents = 'viewport:changed config stop url:changed page:loading visit:failed'.split(' ')\nconst socketRerunEvents = 'runner:restart watched:file:changed'.split(' ')\nconst socketToDriverEvents = 'net:event script:error'.split(' ')\n\nconst localBus = new EventEmitter()\nconst reporterBus = new EventEmitter()\n\n// NOTE: this is exposed for testing, ideally we should only expose this if a test flag is set\nwindow.runnerWs = ws\n\n// NOTE: this is for testing Cypress-in-Cypress, window.Cypress is undefined here\n// unless Cypress has been loaded into the AUT frame\nif (window.Cypress) {\n  window.eventManager = { reporterBus, localBus }\n}\n\n/**\n * @type {Cypress.Cypress}\n */\nlet Cypress\n\nconst eventManager = {\n  reporterBus,\n\n  getCypress () {\n    return Cypress\n  },\n\n  addGlobalListeners (state, connectionInfo) {\n    const rerun = () => {\n      if (!this) {\n        // if the tests have been reloaded\n        // then nothing to rerun\n        return\n      }\n\n      return this._reRun(state)\n    }\n\n    ws.emit('is:automation:client:connected', connectionInfo, action('automationEnsured', (isConnected) => {\n      state.automation = isConnected ? automation.CONNECTED : automation.MISSING\n      ws.on('automation:disconnected', action('automationDisconnected', () => {\n        state.automation = automation.DISCONNECTED\n      }))\n    }))\n\n    ws.on('change:to:url', (url) => {\n      window.location.href = url\n    })\n\n    ws.on('automation:push:message', (msg, data = {}) => {\n      if (!Cypress) return\n\n      switch (msg) {\n        case 'change:cookie':\n          Cypress.Cookies.log(data.message, data.cookie, data.removed)\n          break\n        default:\n          break\n      }\n    })\n\n    ws.on('component:specs:changed', (specs) => {\n      state.setSpecs(specs)\n    })\n\n    ws.on('dev-server:hmr:error', (error) => {\n      Cypress.stop()\n      localBus.emit('script:error', error)\n    })\n\n    _.each(socketRerunEvents, (event) => {\n      ws.on(event, rerun)\n    })\n\n    _.each(socketToDriverEvents, (event) => {\n      ws.on(event, (...args) => {\n        Cypress.emit(event, ...args)\n      })\n    })\n\n    const logCommand = (logId) => {\n      const consoleProps = Cypress.runner.getConsolePropsForLogById(logId)\n\n      logger.logFormatted(consoleProps)\n    }\n\n    reporterBus.on('runner:console:error', ({ err, commandId }) => {\n      if (!Cypress) return\n\n      if (commandId || err) logger.clearLog()\n\n      if (commandId) logCommand(commandId)\n\n      if (err) logger.logError(err.stack)\n    })\n\n    reporterBus.on('runner:console:log', (logId) => {\n      if (!Cypress) return\n\n      logger.clearLog()\n      logCommand(logId)\n    })\n\n    reporterBus.on('focus:tests', this.focusTests)\n\n    reporterBus.on('get:user:editor', (cb) => {\n      ws.emit('get:user:editor', cb)\n    })\n\n    reporterBus.on('set:user:editor', (editor) => {\n      ws.emit('set:user:editor', editor)\n    })\n\n    reporterBus.on('runner:restart', rerun)\n\n    function sendEventIfSnapshotProps (logId, event) {\n      if (!Cypress) return\n\n      const snapshotProps = Cypress.runner.getSnapshotPropsForLogById(logId)\n\n      if (snapshotProps) {\n        localBus.emit(event, snapshotProps)\n      }\n    }\n\n    reporterBus.on('runner:show:snapshot', (logId) => {\n      sendEventIfSnapshotProps(logId, 'show:snapshot')\n    })\n\n    reporterBus.on('runner:hide:snapshot', this._hideSnapshot.bind(this))\n\n    reporterBus.on('runner:pin:snapshot', (logId) => {\n      sendEventIfSnapshotProps(logId, 'pin:snapshot')\n    })\n\n    reporterBus.on('runner:unpin:snapshot', this._unpinSnapshot.bind(this))\n\n    reporterBus.on('runner:resume', () => {\n      if (!Cypress) return\n\n      Cypress.emit('resume:all')\n    })\n\n    reporterBus.on('runner:next', () => {\n      if (!Cypress) return\n\n      Cypress.emit('resume:next')\n    })\n\n    reporterBus.on('runner:stop', () => {\n      if (!Cypress) return\n\n      Cypress.stop()\n    })\n\n    reporterBus.on('save:state', (state) => {\n      this.saveState(state)\n    })\n\n    reporterBus.on('external:open', (url) => {\n      ws.emit('external:open', url)\n    })\n\n    reporterBus.on('open:file', (url) => {\n      ws.emit('open:file', url)\n    })\n\n    const $window = $(window)\n\n    // when we actually unload then\n    // nuke all of the cookies again\n    // so we clear out unload\n    $window.on('unload', () => {\n      this._clearAllCookies()\n    })\n\n    // when our window triggers beforeunload\n    // we know we've change the URL and we need\n    // to clear our cookies\n    // additionally we set unload to true so\n    // that Cypress knows not to set any more\n    // cookies\n    $window.on('beforeunload', () => {\n      reporterBus.emit('reporter:restart:test:run')\n\n      this._clearAllCookies()\n      this._setUnload()\n    })\n  },\n\n  start (config) {\n    if (config.socketId) {\n      ws.emit('app:connect', config.socketId)\n    }\n  },\n\n  setup (config) {\n    Cypress = this.Cypress = $Cypress.create(config)\n\n    // expose Cypress globally\n    // since CT AUT shares the window with the spec, we don't want to overwrite\n    // our spec Cypress instance with the component's Cypress instance\n    if (window.top === window) {\n      window.Cypress = Cypress\n    }\n\n    this._addCypressListeners(Cypress)\n\n    ws.emit('watch:test:file', config.spec)\n  },\n\n  isBrowser (browserName) {\n    if (!this.Cypress) return false\n\n    return this.Cypress.isBrowser(browserName)\n  },\n\n  initialize ($autIframe, config) {\n    performance.mark('initialize-start')\n\n    return Cypress.initialize({\n      $autIframe,\n      onSpecReady: () => {\n        // get the current runnable in case we reran mid-test due to a visit\n        // to a new domain\n        ws.emit('get:existing:run:state', (state = {}) => {\n          if (!Cypress.runner) {\n            // the tests have been reloaded\n            return\n          }\n\n          const runnables = Cypress.runner.normalizeAll(state.tests)\n          const run = () => {\n            performance.mark('initialize-end')\n            performance.measure('initialize', 'initialize-start', 'initialize-end')\n\n            this._runDriver(state)\n          }\n\n          reporterBus.emit('runnables:ready', runnables)\n\n          if (state.numLogs) {\n            Cypress.runner.setNumLogs(state.numLogs)\n          }\n\n          if (state.startTime) {\n            Cypress.runner.setStartTime(state.startTime)\n          }\n\n          if (config.isTextTerminal && !state.currentId) {\n            // we are in run mode and it's the first load\n            // store runnables in backend and maybe send to dashboard\n            return ws.emit('set:runnables:and:maybe:record:tests', runnables, run)\n          }\n\n          if (state.currentId) {\n            // if we have a currentId it means\n            // we need to tell the Cypress to skip\n            // ahead to that test\n            Cypress.runner.resumeAtTest(state.currentId, state.emissions)\n          }\n\n          run()\n        })\n      },\n    })\n  },\n\n  _addCypressListeners (Cypress) {\n    Cypress.on('message', (msg, data, cb) => {\n      ws.emit('client:request', msg, data, cb)\n    })\n\n    _.each(driverToSocketEvents, (event) => {\n      Cypress.on(event, (...args) => {\n        return ws.emit(event, ...args)\n      })\n    })\n\n    Cypress.on('collect:run:state', () => {\n      if (Cypress.env('NO_COMMAND_LOG')) {\n        return Promise.resolve()\n      }\n\n      return new Promise((resolve) => {\n        reporterBus.emit('reporter:collect:run:state', resolve)\n      })\n    })\n\n    Cypress.on('log:added', (log) => {\n      const displayProps = Cypress.runner.getDisplayPropsForLog(log)\n\n      reporterBus.emit('reporter:log:add', displayProps)\n    })\n\n    Cypress.on('log:changed', (log) => {\n      const displayProps = Cypress.runner.getDisplayPropsForLog(log)\n\n      reporterBus.emit('reporter:log:state:changed', displayProps)\n    })\n\n    Cypress.on('before:screenshot', (config, cb) => {\n      const beforeThenCb = () => {\n        localBus.emit('before:screenshot', config)\n        cb()\n      }\n\n      if (Cypress.env('NO_COMMAND_LOG')) {\n        return beforeThenCb()\n      }\n\n      const wait = !config.appOnly && config.waitForCommandSynchronization\n\n      if (!config.appOnly) {\n        reporterBus.emit('test:set:state', _.pick(config, 'id', 'isOpen'), wait ? beforeThenCb : undefined)\n      }\n\n      if (!wait) beforeThenCb()\n    })\n\n    Cypress.on('after:screenshot', (config) => {\n      localBus.emit('after:screenshot', config)\n    })\n\n    _.each(driverToReporterEvents, (event) => {\n      Cypress.on(event, (...args) => {\n        reporterBus.emit(event, ...args)\n      })\n    })\n\n    _.each(driverTestEvents, (event) => {\n      Cypress.on(event, (test, cb) => {\n        reporterBus.emit(event, test, cb)\n      })\n    })\n\n    _.each(driverToLocalAndReporterEvents, (event) => {\n      Cypress.on(event, (...args) => {\n        localBus.emit(event, ...args)\n        reporterBus.emit(event, ...args)\n      })\n    })\n\n    _.each(driverToLocalEvents, (event) => {\n      Cypress.on(event, (...args) => {\n        return localBus.emit(event, ...args)\n      })\n    })\n\n    Cypress.on('script:error', (err) => {\n      Cypress.stop()\n      localBus.emit('script:error', err)\n    })\n  },\n\n  _runDriver (state) {\n    performance.mark('run-s')\n    Cypress.run(() => {\n      performance.mark('run-e')\n      performance.measure('run', 'run-s', 'run-e')\n    })\n\n    reporterBus.emit('reporter:start', {\n      firefoxGcInterval: Cypress.getFirefoxGcInterval(),\n      startTime: Cypress.runner.getStartTime(),\n      numPassed: state.passed,\n      numFailed: state.failed,\n      numPending: state.pending,\n      autoScrollingEnabled: state.autoScrollingEnabled,\n      scrollTop: state.scrollTop,\n    })\n  },\n\n  stop () {\n    localBus.removeAllListeners()\n    ws.off()\n  },\n\n  _reRun (state) {\n    if (!Cypress) return\n\n    state.setIsLoading(true)\n\n    // when we are re-running we first\n    // need to stop cypress always\n    Cypress.stop()\n\n    return this._restart()\n    .then(() => {\n      // this probably isn't 100% necessary\n      // since Cypress will fall out of scope\n      // but we want to be aggressive here\n      // and force GC early and often\n      Cypress.removeAllListeners()\n\n      localBus.emit('restart')\n    })\n  },\n\n  _restart () {\n    return new Promise((resolve) => {\n      reporterBus.once('reporter:restarted', resolve)\n      reporterBus.emit('reporter:restart:test:run')\n    })\n  },\n\n  emit (event, ...args) {\n    localBus.emit(event, ...args)\n  },\n\n  on (event, ...args) {\n    localBus.on(event, ...args)\n  },\n\n  off (event, ...args) {\n    localBus.off(event, ...args)\n  },\n\n  notifyRunningSpec (specFile) {\n    ws.emit('spec:changed', specFile)\n  },\n\n  focusTests () {\n    ws.emit('focus:tests')\n  },\n\n  snapshotUnpinned () {\n    this._unpinSnapshot()\n    this._hideSnapshot()\n    reporterBus.emit('reporter:snapshot:unpinned')\n  },\n\n  _unpinSnapshot () {\n    localBus.emit('unpin:snapshot')\n  },\n\n  _hideSnapshot () {\n    localBus.emit('hide:snapshot')\n  },\n\n  launchBrowser (browser) {\n    ws.emit('reload:browser', window.location.toString(), browser && browser.name)\n  },\n\n  // clear all the cypress specific cookies\n  // whenever our app starts\n  // and additional when we stop running our tests\n  _clearAllCookies () {\n    if (!Cypress) return\n\n    Cypress.Cookies.clearCypressCookies()\n  },\n\n  _setUnload () {\n    if (!Cypress) return\n\n    Cypress.Cookies.setCy('unload', true)\n  },\n\n  saveState (state) {\n    ws.emit('save:app:state', state)\n  },\n}\n\nexport default eventManager\n",
    "packages/runner-ct/src/lib/state.ts": "import { action, computed, observable } from 'mobx'\nimport _ from 'lodash'\nimport automation from './automation'\nimport { UIPlugin } from '../plugins/UIPlugin'\nimport { nanoid } from 'nanoid'\nimport {\n  DEFAULT_REPORTER_WIDTH,\n  LEFT_NAV_WIDTH,\n  DEFAULT_LIST_WIDTH,\n  AUT_IFRAME_MARGIN,\n  PLUGIN_BAR_HEIGHT,\n  HEADER_HEIGHT,\n  DEFAULT_PLUGINS_HEIGHT,\n} from '../app/RunnerCt'\n\nexport type RunMode = 'single' | 'multi'\n\ninterface Defaults {\n  messageTitle: string | null\n  messageDescription: string | null\n  messageType: string\n  messageControls: unknown\n\n  width: number\n  height: number\n\n  reporterWidth: number | null\n  pluginsHeight: number | null\n  specListWidth: number | null\n  isSpecsListOpen: boolean\n\n  viewportHeight: number\n  viewportWidth: number\n\n  url: string\n  highlightUrl: boolean\n  isLoadingUrl: boolean\n\n  spec: Cypress.Cypress['spec'] | null\n  specs: Cypress.Cypress['spec'][]\n\n  callbackAfterUpdate: ((...args: unknown[]) => void) | null\n}\n\nconst _defaults: Defaults = {\n  messageTitle: null,\n  messageDescription: null,\n  messageType: '',\n  messageControls: null,\n\n  width: 500,\n  height: 500,\n\n  viewportHeight: 500,\n  viewportWidth: 500,\n\n  pluginsHeight: PLUGIN_BAR_HEIGHT,\n\n  reporterWidth: null,\n  specListWidth: DEFAULT_LIST_WIDTH,\n  isSpecsListOpen: true,\n\n  url: '',\n  highlightUrl: false,\n  isLoadingUrl: false,\n\n  spec: null,\n  specs: [],\n\n  callbackAfterUpdate: null,\n}\n\nexport default class State {\n  defaults = _defaults\n\n  @observable isLoading = true\n  @observable isRunning = false\n  @observable waitingForInitialBuild = false\n\n  @observable messageTitle = _defaults.messageTitle\n  @observable messageDescription = _defaults.messageDescription\n  @observable messageType = _defaults.messageType\n  @observable callbackAfterUpdate = _defaults.callbackAfterUpdate\n  @observable.ref messageControls = _defaults.messageControls\n\n  @observable snapshot = {\n    showingHighlights: true,\n    stateIndex: 0,\n  }\n\n  @observable url = _defaults.url\n  @observable highlightUrl = _defaults.highlightUrl\n  @observable isLoadingUrl = _defaults.isLoadingUrl\n\n  @observable width = _defaults.width\n  @observable height = _defaults.height\n\n  @observable screenshotting = false\n\n  // if null, the default CSS handles it\n  // if non-null, the user has set it by resizing\n  @observable reporterWidth = _defaults.reporterWidth\n  @observable pluginsHeight = _defaults.pluginsHeight\n  @observable specListWidth = _defaults.specListWidth\n  @observable isSpecsListOpen = _defaults.isSpecsListOpen\n\n  // what the dom reports, always in pixels\n  @observable absoluteReporterWidth = 0\n  @observable headerHeight = 0\n\n  @observable windowWidth = 0\n  @observable windowHeight = 0\n\n  @observable viewportWidth = _defaults.viewportWidth\n  @observable viewportHeight = _defaults.viewportHeight\n\n  @observable automation = automation.CONNECTING\n\n  @observable.ref scriptError = null\n\n  @observable spec = _defaults.spec\n  @observable specs = _defaults.specs\n  @observable specRunId: string | null = null\n  /** @type {\"single\" | \"multi\"} */\n  @observable runMode: RunMode = 'single'\n  @observable multiSpecs: Cypress.Cypress['spec'][] = [];\n\n  @observable readyToRunTests = false\n  @observable activePlugin: string | null = null\n  @observable plugins: UIPlugin[] = []\n\n  constructor ({\n    spec = _defaults.spec,\n    specs = _defaults.specs,\n    runMode = 'single' as RunMode,\n    multiSpecs = [],\n    reporterWidth = DEFAULT_REPORTER_WIDTH,\n    specListWidth = DEFAULT_LIST_WIDTH,\n    isSpecsListOpen = true,\n  }, config: Cypress.RuntimeConfigOptions) {\n    this.reporterWidth = reporterWidth\n    this.isSpecsListOpen = isSpecsListOpen\n    this.spec = spec\n    this.specs = specs\n    this.specListWidth = specListWidth\n    this.runMode = runMode\n    this.multiSpecs = multiSpecs\n\n    // TODO: Refactor so `config` is only needed in MobX, not passed separately to arbitrary components\n    if (config.isTextTerminal) {\n      this.isSpecsListOpen = false\n    }\n\n    // TODO: receive chosen spec from state and set it here\n  }\n\n  @computed get scale () {\n    // the width of the AUT area can be determined by subtracting the\n    // width of the other parts of the UI from the window.innerWidth\n    // we also need to consider the margin around the aut iframe\n    // window.innerWidth - leftNav - specList - reporter - aut-iframe-margin\n    const autAreaWidth = this.windowWidth\n      - LEFT_NAV_WIDTH\n      - (this.isSpecsListOpen ? this.specListWidth : 0) // if spec list is closed, don't need to consider it.\n      - this.reporterWidth\n      - (AUT_IFRAME_MARGIN.X * 2)\n\n    // same for the height.\n    // height - pluginsHeight (0 if no plugins are open) - plugin-bar-height - header-height - margin\n    const autAreaHeight = this.windowHeight - this.pluginsHeight - PLUGIN_BAR_HEIGHT - HEADER_HEIGHT - (AUT_IFRAME_MARGIN.Y * 2)\n\n    // defensively return scale 1 if either height is negative.\n    // this should not happen in general.\n    if (autAreaWidth < 0 || autAreaHeight < 0) {\n      return 1\n    }\n\n    if (autAreaWidth < this.viewportWidth || autAreaHeight < this.viewportHeight) {\n      return Math.min(\n        autAreaWidth / this.viewportWidth,\n        autAreaHeight / this.viewportHeight,\n      )\n    }\n\n    return 1\n  }\n\n  @computed get _containerWidth () {\n    return this.windowWidth - this.absoluteReporterWidth\n  }\n\n  @computed get _containerHeight () {\n    return this.windowHeight - this.headerHeight\n  }\n\n  @computed get displayScale () {\n    return Math.floor(this.scale * 100)\n  }\n\n  @computed.struct get messageStyles () {\n    const actualHeight = this.height * this.scale\n    const messageHeight = 33\n    const nudge = 10\n\n    if ((actualHeight + messageHeight + (nudge * 2)) >= this._containerHeight) {\n      return { state: 'stationary' }\n    }\n\n    return {\n      state: 'attached',\n      styles: {\n        top: (actualHeight + this.headerHeight + nudge),\n      },\n    }\n  }\n\n  @action setScreenshotting (screenshotting: boolean) {\n    this.screenshotting = screenshotting\n  }\n\n  @action updateAutViewportDimensions (dimensions: { viewportWidth: number, viewportHeight: number }) {\n    this.viewportHeight = dimensions.viewportHeight\n    this.viewportWidth = dimensions.viewportWidth\n  }\n\n  @action toggleIsSpecsListOpen () {\n    this.isSpecsListOpen = !this.isSpecsListOpen\n\n    return this.isSpecsListOpen\n  }\n\n  @action setIsSpecsListOpen (open: boolean) {\n    this.isSpecsListOpen = open\n  }\n\n  @action setIsLoading (isLoading) {\n    this.isLoading = isLoading\n  }\n\n  @action updateReporterWidth (width: number) {\n    this.reporterWidth = width\n  }\n\n  @action updatePluginsHeight (height: number) {\n    this.pluginsHeight = height\n  }\n\n  @action updateSpecListWidth (width: number) {\n    this.specListWidth = width\n  }\n\n  @action updateWindowDimensions ({ windowWidth, windowHeight }: { windowWidth?: number, windowHeight?: number }) {\n    if (windowWidth) {\n      this.windowWidth = windowWidth\n    }\n\n    if (windowHeight) {\n      this.windowHeight = windowHeight\n    }\n  }\n\n  @action clearMessage () {\n    this.messageTitle = _defaults.messageTitle\n    this.messageDescription = _defaults.messageDescription\n    this.messageType = _defaults.messageType\n  }\n\n  setCallbackAfterUpdate (cb) {\n    this.callbackAfterUpdate = () => {\n      this.setCallbackAfterUpdateToNull()\n\n      cb()\n    }\n  }\n\n  @action setCallbackAfterUpdateToNull () {\n    this.callbackAfterUpdate = null\n  }\n\n  @action resetUrl () {\n    this.url = _defaults.url\n    this.highlightUrl = _defaults.highlightUrl\n    this.isLoadingUrl = _defaults.isLoadingUrl\n  }\n\n  @action setSpec (spec: Cypress.Cypress['spec'] | null) {\n    this.spec = spec\n    this.specRunId = nanoid()\n  }\n\n  @action setSpecs (specs) {\n    this.specs = specs\n  }\n\n  @action updateSpecByUrl (specUrl) {\n    const foundSpec = _.find(this.specs, { name: decodeURI(specUrl) })\n\n    if (foundSpec) {\n      this.spec = foundSpec\n    }\n  }\n\n  @action setSingleSpec (spec: Cypress.Cypress['spec'] | undefined) {\n    if (this.runMode === 'multi') {\n      this.runMode = 'single'\n      this.multiSpecs = []\n    }\n\n    this.setSpec(spec)\n  }\n\n  @action addSpecToMultiMode (newSpec: Cypress.Cypress['spec']) {\n    const isAlreadyRunningNewSpec = this.multiSpecs.some(\n      (existingSpec) => existingSpec.relative === newSpec.relative,\n    )\n\n    if (isAlreadyRunningNewSpec) {\n      this.multiSpecs = this.multiSpecs.filter((existingSpec) => existingSpec.relative !== newSpec.relative)\n    } else if (this.runMode === 'single' && this.spec) {\n      // when the new\n      this.multiSpecs = [this.spec, newSpec]\n    } else {\n      this.multiSpecs = [...this.multiSpecs, newSpec]\n    }\n\n    this.runMode = 'multi'\n    this.runMultiMode().catch((e) => {\n      throw e\n    })\n  }\n\n  runMultiMode = async () => {\n    const eventManager = require('./event-manager').default\n    const waitForRunEnd = () => new Promise((res) => eventManager.on('run:end', res))\n\n    this.setSpec(null)\n    for (const spec of this.multiSpecs) {\n      this.setSpec(spec)\n      await waitForRunEnd()\n    }\n  }\n\n  loadReactDevTools = () => {\n    return import(/* webpackChunkName: \"ctChunk-reactdevtools\" */ '../plugins/ReactDevtools')\n    .then(action((ReactDevTools) => {\n      this.plugins = [\n        ReactDevTools.create(),\n      ]\n    }))\n  }\n\n  @action\n  initializePlugins = (config: Cypress.RuntimeConfigOptions & Cypress.ResolvedConfigOptions) => {\n    if (config.env.reactDevtools && !config.isTextTerminal) {\n      this.loadReactDevTools()\n      .then(action(() => {\n        this.readyToRunTests = true\n      }))\n      .catch((e) => {\n        this.readyToRunTests = true\n        // eslint-disable-next-line\n        console.error('Can not load react-devtools.', e)\n      })\n    } else {\n      this.readyToRunTests = true\n    }\n  }\n\n  @action\n  registerDevtools = (contentWindow: Window) => {\n    this.plugins.forEach((plugin) => {\n      if (plugin.type === 'devtools') {\n        plugin.initialize(contentWindow)\n      }\n    })\n  }\n\n  @action\n  setActivePlugin = (newPlugin: string) => {\n    this.activePlugin = newPlugin\n  }\n\n  @action\n  toggleDevtoolsPlugin = (plugin: UIPlugin, domElement: HTMLElement) => {\n    if (this.activePlugin === plugin.name) {\n      plugin.unmount()\n      this.setActivePlugin(null)\n      // set this back to default to force the AUT to resize vertically\n      // if the aspect ratio is very long on the Y axis.\n      this.pluginsHeight = PLUGIN_BAR_HEIGHT\n    } else {\n      this.setActivePlugin(plugin.name)\n      // set this to force the AUT to resize vertically if the aspect ratio is very long\n      // on the Y axis.\n      this.pluginsHeight = DEFAULT_PLUGINS_HEIGHT\n      plugin.mount(domElement)\n    }\n  }\n\n  @computed\n  get isAnyDevtoolsPluginOpen () {\n    return this.activePlugin !== null\n  }\n\n  @computed\n  get isAnyPluginToShow () {\n    return Boolean(this.plugins.length > 0 && this.spec)\n  }\n}\n",
    "packages/server/lib/browsers/index.js": "const _ = require('lodash')\nconst path = require('path')\nconst Promise = require('bluebird')\nconst debug = require('debug')('cypress:server:browsers')\nconst utils = require('./utils')\nconst errors = require('../errors')\nconst check = require('check-more-types')\n\n// returns true if the passed string is a known browser family name\nconst isBrowserFamily = check.oneOf(['chromium', 'firefox'])\n\nlet instance = null\n\nconst kill = function (unbind, isProcessExit) {\n  // Clean up the instance when the browser is closed\n  if (!instance) {\n    debug('browsers.kill called with no active instance')\n\n    return Promise.resolve()\n  }\n\n  const _instance = instance\n\n  instance = null\n\n  if (unbind) {\n    _instance.removeAllListeners()\n  }\n\n  return new Promise((resolve) => {\n    _instance.once('exit', () => {\n      debug('browser process killed')\n\n      resolve()\n    })\n\n    debug('killing browser process')\n\n    _instance.isProcessExit = isProcessExit\n\n    _instance.kill()\n  })\n}\n\nconst getBrowserLauncher = function (browser) {\n  debug('getBrowserLauncher %o', { browser })\n  if (!isBrowserFamily(browser.family)) {\n    debug('unknown browser family', browser.family)\n  }\n\n  if (browser.name === 'electron') {\n    return require('./electron')\n  }\n\n  if (browser.family === 'chromium') {\n    return require('./chrome')\n  }\n\n  if (browser.family === 'firefox') {\n    return require('./firefox')\n  }\n}\n\nconst isValidPathToBrowser = (str) => {\n  return path.basename(str) !== str\n}\n\nconst parseBrowserOption = (opt) => {\n  // it's a name or a path\n  if (!_.isString(opt) || !opt.includes(':')) {\n    return {\n      name: opt,\n      channel: 'stable',\n    }\n  }\n\n  // it's in name:channel format\n  const split = opt.indexOf(':')\n\n  return {\n    name: opt.slice(0, split),\n    channel: opt.slice(split + 1),\n  }\n}\n\nconst ensureAndGetByNameOrPath = function (nameOrPath, returnAll = false, browsers = null) {\n  const findBrowsers = Array.isArray(browsers) ? Promise.resolve(browsers) : utils.getBrowsers()\n\n  return findBrowsers\n  .then((browsers = []) => {\n    const filter = parseBrowserOption(nameOrPath)\n\n    debug('searching for browser %o', { nameOrPath, filter, knownBrowsers: browsers })\n\n    // try to find the browser by name with the highest version property\n    const sortedBrowsers = _.sortBy(browsers, ['version'])\n\n    const browser = _.findLast(sortedBrowsers, filter)\n\n    if (browser) {\n      // short circuit if found\n      if (returnAll) {\n        return browsers\n      }\n\n      return browser\n    }\n\n    // did the user give a bad name, or is this actually a path?\n    if (isValidPathToBrowser(nameOrPath)) {\n      // looks like a path - try to resolve it to a FoundBrowser\n      return utils.getBrowserByPath(nameOrPath)\n      .then((browser) => {\n        if (returnAll) {\n          return [browser].concat(browsers)\n        }\n\n        return browser\n      }).catch((err) => {\n        return errors.throw('BROWSER_NOT_FOUND_BY_PATH', nameOrPath, err.message)\n      })\n    }\n\n    // not a path, not found by name\n    return throwBrowserNotFound(nameOrPath, browsers)\n  })\n}\n\nconst formatBrowsersToOptions = (browsers) => {\n  return browsers.map((browser) => {\n    if (browser.channel !== 'stable') {\n      return [browser.name, browser.channel].join(':')\n    }\n\n    return browser.name\n  })\n}\n\nconst throwBrowserNotFound = function (browserName, browsers = []) {\n  const names = `- ${formatBrowsersToOptions(browsers).join('\\n- ')}`\n\n  return errors.throw('BROWSER_NOT_FOUND_BY_NAME', browserName, names)\n}\n\nprocess.once('exit', () => kill(true, true))\n\nmodule.exports = {\n  ensureAndGetByNameOrPath,\n\n  isBrowserFamily,\n\n  removeOldProfiles: utils.removeOldProfiles,\n\n  get: utils.getBrowsers,\n\n  close: kill,\n\n  _setInstance (_instance) {\n    // for testing\n    instance = _instance\n  },\n\n  // note: does not guarantee that `browser` is still running\n  // note: electron will return a list of pids for each webContent\n  getBrowserInstance () {\n    return instance\n  },\n\n  getAllBrowsersWith (nameOrPath) {\n    debug('getAllBrowsersWith %o', { nameOrPath })\n    if (nameOrPath) {\n      return ensureAndGetByNameOrPath(nameOrPath, true)\n    }\n\n    return utils.getBrowsers()\n  },\n\n  open (browser, options = {}, automation) {\n    return kill(true)\n    .then(() => {\n      let browserLauncher; let url\n\n      _.defaults(options, {\n        onBrowserOpen () {},\n        onBrowserClose () {},\n      })\n\n      if (!(browserLauncher = getBrowserLauncher(browser))) {\n        return throwBrowserNotFound(browser.name, options.browsers)\n      }\n\n      if (!(url = options.url)) {\n        throw new Error('options.url must be provided when opening a browser. You passed:', options)\n      }\n\n      debug('opening browser %o', browser)\n\n      return browserLauncher.open(browser, url, options, automation)\n      .then((i) => {\n        debug('browser opened')\n        // TODO: bind to process.exit here\n        // or move this functionality into cypress-core-launder\n\n        i.browser = browser\n\n        instance = i\n\n        // TODO: normalizing opening and closing / exiting\n        // so that there is a default for each browser but\n        // enable the browser to configure the interface\n        instance.once('exit', () => {\n          options.onBrowserClose()\n          instance = null\n        })\n\n        // TODO: instead of waiting an arbitrary\n        // amount of time here we could instead\n        // wait for the socket.io connect event\n        // which would mean that our browser is\n        // completely rendered and open. that would\n        // mean moving this code out of here and\n        // into the project itself\n        // (just like headless code)\n        // ----------------------------\n        // give a little padding around\n        // the browser opening\n        return Promise.delay(1000)\n        .then(() => {\n          options.onBrowserOpen()\n\n          return instance\n        })\n      })\n    })\n  },\n}\n",
    "packages/server/lib/cypress.js": "require('./environment')\n\n// we are not requiring everything up front\n// to optimize how quickly electron boots while\n// in dev or linux production. the reasoning is\n// that we likely may need to spawn a new child process\n// and its a huge waste of time (about 1.5secs) of\n// synchronous requires the first go around just to\n// essentially do it all again when we boot the correct\n// mode.\n\nconst R = require('ramda')\nconst Promise = require('bluebird')\nconst debug = require('debug')('cypress:server:cypress')\nconst argsUtils = require('./util/args')\nconst chalk = require('chalk')\n\nconst warning = (code, args) => {\n  return require('./errors').warning(code, args)\n}\n\nconst exit = (code = 0) => {\n  // TODO: we shouldn't have to do this\n  // but cannot figure out how null is\n  // being passed into exit\n  debug('about to exit with code', code)\n\n  return process.exit(code)\n}\n\nconst showWarningForInvalidConfig = (options) => {\n  const invalidConfigOptions = require('lodash').keys(options.config).reduce((invalid, option) => {\n    if (!require('./config').getConfigKeys().find((configKey) => configKey === option)) {\n      invalid.push(option)\n    }\n\n    return invalid\n  }, [])\n\n  if (invalidConfigOptions.length && options.invokedFromCli) {\n    return warning('INVALID_CONFIG_OPTION', invalidConfigOptions)\n  }\n}\n\nconst exit0 = () => {\n  return exit(0)\n}\n\nconst exitErr = (err) => {\n  // log errors to the console\n  // and potentially raygun\n  // and exit with 1\n  debug('exiting with err', err)\n\n  return require('./errors').logException(err)\n  .then(() => {\n    debug('calling exit 1')\n\n    return exit(1)\n  })\n}\n\nmodule.exports = {\n  isCurrentlyRunningElectron () {\n    return require('./util/electron-app').isRunning()\n  },\n\n  runElectron (mode, options) {\n    // wrap all of this in a promise to force the\n    // promise interface - even if it doesn't matter\n    // in dev mode due to cp.spawn\n    return Promise.try(() => {\n      // if we have the electron property on versions\n      // that means we're already running in electron\n      // like in production and we shouldn't spawn a new\n      // process\n      if (this.isCurrentlyRunningElectron()) {\n        // if we weren't invoked from the CLI\n        // then display a warning to the user\n        if (!options.invokedFromCli) {\n          warning('INVOKED_BINARY_OUTSIDE_NPM_MODULE')\n        }\n\n        debug('running Electron currently')\n\n        return require('./modes')(mode, options)\n      }\n\n      return new Promise((resolve) => {\n        debug('starting Electron')\n        const cypressElectron = require('@packages/electron')\n\n        const fn = (code) => {\n          // juggle up the totalFailed since our outer\n          // promise is expecting this object structure\n          debug('electron finished with', code)\n\n          if (mode === 'smokeTest') {\n            return resolve(code)\n          }\n\n          return resolve({ totalFailed: code })\n        }\n\n        const args = require('./util/args').toArray(options)\n\n        debug('electron open arguments %o', args)\n\n        return cypressElectron.open('.', args, fn)\n      })\n    })\n  },\n\n  openProject (options) {\n    // this code actually starts a project\n    // and is spawned from nodemon\n    return require('./open_project').open(options.project, options)\n  },\n\n  start (argv = []) {\n    debug('starting cypress with argv %o', argv)\n\n    // if the CLI passed \"--\" somewhere, we need to remove it\n    // for https://github.com/cypress-io/cypress/issues/5466\n    argv = R.without('--', argv)\n\n    let options\n\n    try {\n      options = argsUtils.toObject(argv)\n\n      showWarningForInvalidConfig(options)\n    } catch (argumentsError) {\n      debug('could not parse CLI arguments: %o', argv)\n\n      // note - this is promise-returned call\n      return exitErr(argumentsError)\n    }\n\n    debug('from argv %o got options %o', argv, options)\n\n    if (options.headless) {\n      // --headless is same as --headed false\n      if (options.headed) {\n        throw new Error('Impossible options: both headless and headed are true')\n      }\n\n      options.headed = false\n    }\n\n    if (options.runProject && !options.headed) {\n      debug('scaling electron app in headless mode')\n      // scale the electron browser window\n      // to force retina screens to not\n      // upsample their images when offscreen\n      // rendering\n      require('./util/electron-app').scale()\n    }\n\n    // make sure we have the appData folder\n    return require('./util/app_data').ensure()\n    .then(() => {\n      // else determine the mode by\n      // the passed in arguments / options\n      // and normalize this mode\n      let mode = options.mode || 'interactive'\n\n      if (options.version) {\n        mode = 'version'\n      } else if (options.smokeTest) {\n        mode = 'smokeTest'\n      } else if (options.returnPkg) {\n        mode = 'returnPkg'\n      } else if (options.logs) {\n        mode = 'logs'\n      } else if (options.clearLogs) {\n        mode = 'clearLogs'\n      } else if (options.getKey) {\n        mode = 'getKey'\n      } else if (options.generateKey) {\n        mode = 'generateKey'\n      } else if (!(options.exitWithCode == null)) {\n        mode = 'exitWithCode'\n      } else if (options.runProject) {\n        // go into headless mode when running\n        // until completion + exit\n        mode = 'run'\n      }\n\n      return this.startInMode(mode, options)\n    })\n  },\n\n  startInMode (mode, options) {\n    debug('starting in mode %s with options %o', mode, options)\n\n    switch (mode) {\n      case 'version':\n        return require('./modes/pkg')(options)\n        .get('version')\n        .then((version) => {\n          return console.log(version) // eslint-disable-line no-console\n        }).then(exit0)\n        .catch(exitErr)\n\n      case 'info':\n        return require('./modes/info')(options)\n        .then(exit0)\n        .catch(exitErr)\n\n      case 'smokeTest':\n        return this.runElectron(mode, options)\n        .then((pong) => {\n          if (!this.isCurrentlyRunningElectron()) {\n            return pong\n          }\n\n          if (pong === options.ping) {\n            return 0\n          }\n\n          return 1\n        }).then(exit)\n        .catch(exitErr)\n\n      case 'returnPkg':\n        return require('./modes/pkg')(options)\n        .then((pkg) => {\n          return console.log(JSON.stringify(pkg)) // eslint-disable-line no-console\n        }).then(exit0)\n        .catch(exitErr)\n\n      case 'logs':\n        // print the logs + exit\n        return require('./gui/logs').print()\n        .then(exit0)\n        .catch(exitErr)\n\n      case 'clearLogs':\n        // clear the logs + exit\n        return require('./gui/logs').clear()\n        .then(exit0)\n        .catch(exitErr)\n\n      case 'getKey':\n        // print the key + exit\n        return require('./project-base').ProjectBase\n        .getSecretKeyByPath(options.projectRoot)\n        .then((key) => {\n          return console.log(key) // eslint-disable-line no-console\n        }).then(exit0)\n        .catch(exitErr)\n\n      case 'generateKey':\n        // generate + print the key + exit\n        return require('./project-base').ProjectBase\n        .generateSecretKeyByPath(options.projectRoot)\n        .then((key) => {\n          return console.log(key) // eslint-disable-line no-console\n        }).then(exit0)\n        .catch(exitErr)\n\n      case 'exitWithCode':\n        return require('./modes/exit')(options)\n        .then(exit)\n        .catch(exitErr)\n\n      case 'run':\n        // run headlessly and exit\n        // with num of totalFailed\n        return this.runElectron(mode, options)\n        .then((results) => {\n          if (results.runs) {\n            const isCanceled = results.runs.filter((run) => run.skippedSpec).length\n\n            if (isCanceled) {\n              // eslint-disable-next-line no-console\n              console.log(chalk.magenta('\\n  Exiting with non-zero exit code because the run was canceled.'))\n\n              return 1\n            }\n          }\n\n          return results.totalFailed\n        })\n        .then(exit)\n        .catch(exitErr)\n\n      case 'interactive':\n        return this.runElectron(mode, options)\n\n      case 'openProject':\n        // open + start the project\n        return this.openProject(options)\n\n      default:\n        throw new Error(`Cannot start. Invalid mode: '${mode}'`)\n    }\n  },\n}\n",
    "packages/server/lib/file_server.js": "// TODO: move this to packages/core-file-server\n\nconst _ = require('lodash')\nconst debug = require('debug')('cypress:server:file_server')\nconst url = require('url')\nconst http = require('http')\nconst path = require('path')\nconst send = require('send')\nconst { httpUtils } = require('@packages/network')\nconst { allowDestroy } = require('./util/server_destroy')\nconst random = require('./util/random')\nconst networkFailures = require('./util/network_failures')\n\nconst onRequest = function (req, res, expectedToken, fileServerFolder) {\n  const token = req.headers['x-cypress-authorization']\n\n  if (token !== expectedToken) {\n    debug('authorization failed on file_server request %o', { reqUrl: req.url, expectedToken, token })\n    res.statusCode = 401\n    res.end()\n\n    return\n  }\n\n  const args = _.compact([\n    fileServerFolder,\n    req.url,\n  ])\n\n  // strip off any query params from our req's url\n  // since we're pulling this from the file system\n  // it does not understand query params\n  // and make sure we decode the uri which swaps out\n  // %20 with white space\n  const file = decodeURI(url.parse(path.join(...args)).pathname)\n\n  res.setHeader('x-cypress-file-path', file)\n\n  return send(req, url.parse(req.url).pathname, {\n    root: path.resolve(fileServerFolder),\n  })\n  .on('error', (err) => {\n    res.setHeader('x-cypress-file-server-error', true)\n    res.setHeader('content-type', 'text/html')\n    res.statusCode = err.status\n\n    return res.end(networkFailures.get(file, err.status))\n  }).pipe(res)\n}\n\nmodule.exports = {\n  create (fileServerFolder) {\n    return new Promise(((resolve) => {\n      const token = random.id(64)\n\n      const srv = http.createServer(httpUtils.lenientOptions, (req, res) => {\n        return onRequest(req, res, token, fileServerFolder)\n      })\n\n      allowDestroy(srv)\n\n      return srv.listen(0, '127.0.0.1', () => {\n        return resolve({\n          token,\n\n          port () {\n            return srv.address().port\n          },\n\n          address () {\n            return `http://localhost:${this.port()}`\n          },\n\n          close () {\n            return srv.destroyAsync()\n          },\n        })\n      })\n    }))\n  },\n}\n",
    "packages/server/lib/logger.js": "/* eslint-disable no-console */\nconst path = require('path')\nconst _ = require('lodash')\nconst Promise = require('bluebird')\nconst winston = require('winston')\nconst { fs } = require('./util/fs')\nconst appData = require('./util/app_data')\n\nconst folder = appData.path()\n\nconst getName = (name) => {\n  return `${name}.log`\n}\n\nconst getPathToLog = (name) => {\n  return path.join(folder, getName(name))\n}\n\nconst createFile = function (name, level, opts = {}) {\n  const file = getPathToLog(name)\n\n  // ensure that the containing dir exists\n  fs.ensureDirSync(path.dirname(file))\n\n  const obj = {\n    name,\n    filename: file,\n    colorize: true,\n    tailable: true,\n    maxsize: 1000000, // 1mb\n  }\n\n  if (level) {\n    obj.level = level\n  }\n\n  _.extend(obj, opts)\n\n  return new (winston.transports.File)(obj)\n}\n\nconst transports = [createFile('all', null, { handleExceptions: true })]\n\nif (process.env.CYPRESS_DEBUG) {\n  transports.push(new (winston.transports.Console)())\n}\n\nconst logger = new (winston.Logger)({\n  transports,\n\n  exitOnError (err) {\n    // cannot use a reference here since\n    // defaultErrorHandler does not exist yet\n    return logger.defaultErrorHandler(err)\n  },\n\n})\n\nlogger.createException = (err) => {\n  return require('./exception').create(err, logger.getSettings())\n}\n\nlogger.defaultErrorHandler = function (err) {\n  logger.info('caught error', { error: err.message, stack: err.stack })\n\n  const exit = () => {\n    return process.exit(1)\n  }\n\n  const handleErr = function () {\n    let e\n\n    e = logger.errorHandler\n\n    if (e) {\n      const ret = e(err)\n\n      if (ret === true) {\n        return exit()\n      }\n    } else {\n      // instead of console'ing these we should\n      // think about chalking them so they are\n      // formatted and displayed\n      console.log(err)\n      console.log(err.stack)\n\n      return exit()\n    }\n  }\n\n  logger.createException(err).then(handleErr).catch(handleErr)\n\n  // do not exit on error, let us\n  // handle it manually\n  // why are we returning false here?\n  // we need to return false only from\n  // exitOnError\n  return false\n}\n\nlogger.setSettings = (obj) => {\n  return logger._settings = obj\n}\n\nlogger.getSettings = () => {\n  return logger._settings\n}\n\nlogger.unsetSettings = () => {\n  return delete logger._settings\n}\n\nlogger.setErrorHandler = (fn) => {\n  return logger.errorHandler = fn\n}\n\nlogger.getData = function (obj) {\n  const keys = ['level', 'message', 'timestamp', 'type']\n\n  return _.reduce(obj, (memo, value, key) => {\n    if (!keys.includes(key)) {\n      memo.data[key] = value\n    } else {\n      memo[key] = value\n    }\n\n    return memo\n  }\n  , { data: {} })\n}\n\nlogger.normalize = (logs = []) => {\n  return _.map(logs, logger.getData)\n}\n\nlogger.getLogs = function () {\n  const transport = 'all'\n\n  return new Promise((resolve, reject) => {\n    const opts = {\n      limit: 500,\n      order: 'desc',\n    }\n\n    const t = logger.transports[transport] != null ? logger.transports[transport] : (() => {\n      throw new Error(`Log transport: '${transport}' does not exist!`)\n    })()\n\n    return t.query(opts, (err, results) => {\n      if (err) {\n        return reject(err)\n      }\n\n      return resolve(logger.normalize(results))\n    })\n  })\n}\n\nlogger.off = () => {\n  return logger.removeAllListeners('logging')\n}\n\nlogger.onLog = function (fn) {\n  const name = 'all'\n\n  logger.off()\n\n  return logger.on('logging', (transport, level, msg, data) => {\n    if (transport.name === name) {\n      const obj = { level, message: msg }\n\n      obj.type = data.type\n      obj.data = _.omit(data, 'type')\n      obj.timestamp = new Date\n\n      return fn(obj)\n    }\n  })\n}\n\nlogger.clearLogs = function () {\n  const files = _.map(logger.transports, (value, key) => {\n    return fs.outputFileAsync(getPathToLog(key), '')\n  })\n\n  return Promise.all(files)\n}\n\nlogger.log = _.wrap(logger.log, function (orig, ...args) {\n  const last = _.last(args)\n\n  // should be cloning this last object\n  // and not mutating it directly!\n  if (_.isObject(last)) {\n    _.defaults(last,\n      { type: 'server' })\n  }\n\n  return orig.apply(this, args)\n})\n\nprocess.removeAllListeners('unhandledRejection')\nprocess.on('unhandledRejection', (err, promise) => {\n  logger.defaultErrorHandler(err)\n\n  return false\n})\n\nmodule.exports = logger\n",
    "packages/server/lib/modes/run.js": "/* eslint-disable no-console, @cypress/dev/arrow-body-multiline-braces  */\nconst _ = require('lodash')\nconst { app } = require('electron')\nconst la = require('lazy-ass')\nconst pkg = require('@packages/root')\nconst path = require('path')\nconst chalk = require('chalk')\nconst human = require('human-interval')\nconst debug = require('debug')('cypress:server:run')\nconst Promise = require('bluebird')\nconst logSymbols = require('log-symbols')\n\nconst recordMode = require('./record')\nconst errors = require('../errors')\nconst { ProjectBase } = require('../project-base')\nconst Reporter = require('../reporter')\nconst browserUtils = require('../browsers')\nconst openProject = require('../open_project')\nconst videoCapture = require('../video_capture')\nconst { fs } = require('../util/fs')\nconst runEvents = require('../plugins/run_events')\nconst env = require('../util/env')\nconst trash = require('../util/trash')\nconst random = require('../util/random')\nconst system = require('../util/system')\nconst duration = require('../util/duration')\nconst newlines = require('../util/newlines')\nconst terminal = require('../util/terminal')\nconst specsUtil = require('../util/specs')\nconst humanTime = require('../util/human_time')\nconst settings = require('../util/settings')\nconst chromePolicyCheck = require('../util/chrome_policy_check')\nconst experiments = require('../experiments')\nconst objUtils = require('../util/obj_utils')\n\nconst DELAY_TO_LET_VIDEO_FINISH_MS = 1000\n\nconst color = (val, c) => {\n  return chalk[c](val)\n}\n\nconst gray = (val) => {\n  return color(val, 'gray')\n}\n\nconst colorIf = function (val, c) {\n  if (val === 0 || val == null) {\n    val = '-'\n    c = 'gray'\n  }\n\n  return color(val, c)\n}\n\nconst getSymbol = function (num) {\n  if (num) {\n    return logSymbols.error\n  }\n\n  return logSymbols.success\n}\n\nconst getWidth = (table, index) => {\n  // get the true width of a table's column,\n  // based off of calculated table options for that column\n  const columnWidth = table.options.colWidths[index]\n\n  if (columnWidth) {\n    return columnWidth - (table.options.style['padding-left'] + table.options.style['padding-right'])\n  }\n}\n\nconst formatBrowser = (browser) => {\n  // TODO: finish browser\n  return _.compact([\n    browser.displayName,\n    browser.majorVersion,\n    browser.isHeadless && gray('(headless)'),\n  ]).join(' ')\n}\n\nconst formatFooterSummary = (results) => {\n  const { totalFailed, runs } = results\n\n  const isCanceled = _.some(results.runs, { skippedSpec: true })\n\n  // pass or fail color\n  const c = isCanceled ? 'magenta' : totalFailed ? 'red' : 'green'\n\n  const phrase = (() => {\n    if (isCanceled) {\n      return 'The run was canceled'\n    }\n\n    // if we have any specs failing...\n    if (!totalFailed) {\n      return 'All specs passed!'\n    }\n\n    // number of specs\n    const total = runs.length\n    const failingRuns = _.filter(runs, 'stats.failures').length\n    const percent = Math.round((failingRuns / total) * 100)\n\n    return `${failingRuns} of ${total} failed (${percent}%)`\n  })()\n\n  return [\n    isCanceled ? '-' : formatSymbolSummary(totalFailed),\n    color(phrase, c),\n    gray(duration.format(results.totalDuration)),\n    colorIf(results.totalTests, 'reset'),\n    colorIf(results.totalPassed, 'green'),\n    colorIf(totalFailed, 'red'),\n    colorIf(results.totalPending, 'cyan'),\n    colorIf(results.totalSkipped, 'blue'),\n  ]\n}\n\nconst formatSymbolSummary = (failures) => {\n  return getSymbol(failures)\n}\n\nconst formatPath = (name, n, colour = 'reset') => {\n  if (!name) return ''\n\n  const fakeCwdPath = env.get('FAKE_CWD_PATH')\n\n  if (fakeCwdPath && env.get('CYPRESS_INTERNAL_ENV') === 'test') {\n    // if we're testing within Cypress, we want to strip out\n    // the current working directory before calculating the stdout tables\n    // this will keep our snapshots consistent everytime we run\n    const cwdPath = process.cwd()\n\n    name = name\n    .split(cwdPath)\n    .join(fakeCwdPath)\n  }\n\n  // add newLines at each n char and colorize the path\n  if (n) {\n    let nameWithNewLines = newlines.addNewlineAtEveryNChar(name, n)\n\n    return `${color(nameWithNewLines, colour)}`\n  }\n\n  return `${color(name, colour)}`\n}\n\nconst formatNodeVersion = ({ resolvedNodeVersion, resolvedNodePath }, width) => {\n  debug('formatting Node version. %o', { version: resolvedNodeVersion, path: resolvedNodePath })\n\n  if (resolvedNodePath) {\n    return formatPath(`v${resolvedNodeVersion} (${resolvedNodePath})`, width)\n  }\n}\n\nconst formatRecordParams = function (runUrl, parallel, group, tag) {\n  if (runUrl) {\n    if (!group) {\n      group = false\n    }\n\n    if (!tag) {\n      tag = false\n    }\n\n    return `Tag: ${tag}, Group: ${group}, Parallel: ${Boolean(parallel)}`\n  }\n}\n\nconst displayRunStarting = function (options = {}) {\n  const { browser, config, group, parallel, runUrl, specPattern, specs, tag } = options\n\n  console.log('')\n\n  terminal.divider('=')\n\n  console.log('')\n\n  terminal.header('Run Starting', {\n    color: ['reset'],\n  })\n\n  console.log('')\n\n  const experimental = experiments.getExperimentsFromResolved(config.resolved)\n  const enabledExperiments = _.pickBy(experimental, _.property('enabled'))\n  const hasExperiments = !_.isEmpty(enabledExperiments)\n\n  // if we show Node Version, then increase 1st column width\n  // to include wider 'Node Version:'.\n  // Without Node version, need to account for possible \"Experiments\" label\n  const colWidths = config.resolvedNodePath ? [16, 84] : (\n    hasExperiments ? [14, 86] : [12, 88]\n  )\n\n  const table = terminal.table({\n    colWidths,\n    type: 'outsideBorder',\n  })\n\n  const formatSpecPattern = () => {\n    // foo.spec.js, bar.spec.js, baz.spec.js\n    // also inserts newlines at col width\n    if (specPattern) {\n      return formatPath(specPattern.join(', '), getWidth(table, 1))\n    }\n  }\n\n  const formatSpecs = (specs) => {\n    // 25 found: (foo.spec.js, bar.spec.js, baz.spec.js)\n    const names = _.map(specs, 'name')\n    const specsTruncated = _.truncate(names.join(', '), { length: 250 })\n\n    const stringifiedSpecs = [\n      `${names.length} found `,\n      '(',\n      specsTruncated,\n      ')',\n    ]\n    .join('')\n\n    return formatPath(stringifiedSpecs, getWidth(table, 1))\n  }\n\n  const data = _\n  .chain([\n    [gray('Cypress:'), pkg.version],\n    [gray('Browser:'), formatBrowser(browser)],\n    [gray('Node Version:'), formatNodeVersion(config, getWidth(table, 1))],\n    [gray('Specs:'), formatSpecs(specs)],\n    [gray('Searched:'), formatSpecPattern(specPattern)],\n    [gray('Params:'), formatRecordParams(runUrl, parallel, group, tag)],\n    [gray('Run URL:'), runUrl ? formatPath(runUrl, getWidth(table, 1)) : ''],\n    [gray('Experiments:'), hasExperiments ? experiments.formatExperiments(enabledExperiments) : ''],\n  ])\n  .filter(_.property(1))\n  .value()\n\n  table.push(...data)\n\n  const heading = table.toString()\n\n  console.log(heading)\n\n  console.log('')\n\n  return heading\n}\n\nconst displaySpecHeader = function (name, curr, total, estimated) {\n  console.log('')\n\n  const PADDING = 2\n\n  const table = terminal.table({\n    colWidths: [10, 70, 20],\n    colAligns: ['left', 'left', 'right'],\n    type: 'pageDivider',\n    style: {\n      'padding-left': PADDING,\n      'padding-right': 0,\n    },\n  })\n\n  table.push(['', ''])\n  table.push([\n    'Running:',\n    `${formatPath(name, getWidth(table, 1), 'gray')}`,\n    gray(`(${curr} of ${total})`),\n  ])\n\n  console.log(table.toString())\n\n  if (estimated) {\n    const estimatedLabel = `${' '.repeat(PADDING)}Estimated:`\n\n    return console.log(estimatedLabel, gray(humanTime.long(estimated)))\n  }\n}\n\nconst collectTestResults = (obj = {}, estimated) => {\n  return {\n    name: _.get(obj, 'spec.name'),\n    tests: _.get(obj, 'stats.tests'),\n    passes: _.get(obj, 'stats.passes'),\n    pending: _.get(obj, 'stats.pending'),\n    failures: _.get(obj, 'stats.failures'),\n    skipped: _.get(obj, 'stats.skipped'),\n    duration: humanTime.long(_.get(obj, 'stats.wallClockDuration')),\n    estimated: estimated && humanTime.long(estimated),\n    screenshots: obj.screenshots && obj.screenshots.length,\n    video: Boolean(obj.video),\n  }\n}\n\nconst renderSummaryTable = (runUrl) => {\n  return function (results) {\n    const { runs } = results\n\n    console.log('')\n\n    terminal.divider('=')\n\n    console.log('')\n\n    terminal.header('Run Finished', {\n      color: ['reset'],\n    })\n\n    if (runs && runs.length) {\n      const colAligns = ['left', 'left', 'right', 'right', 'right', 'right', 'right', 'right']\n      const colWidths = [3, 41, 11, 9, 9, 9, 9, 9]\n\n      const table1 = terminal.table({\n        colAligns,\n        colWidths,\n        type: 'noBorder',\n        head: [\n          '',\n          gray('Spec'),\n          '',\n          gray('Tests'),\n          gray('Passing'),\n          gray('Failing'),\n          gray('Pending'),\n          gray('Skipped'),\n        ],\n      })\n\n      const table2 = terminal.table({\n        colAligns,\n        colWidths,\n        type: 'border',\n      })\n\n      const table3 = terminal.table({\n        colAligns,\n        colWidths,\n        type: 'noBorder',\n        head: formatFooterSummary(results),\n      })\n\n      _.each(runs, (run) => {\n        const { spec, stats } = run\n\n        const ms = duration.format(stats.wallClockDuration || 0)\n\n        const formattedSpec = formatPath(spec.name, getWidth(table2, 1))\n\n        if (run.skippedSpec) {\n          return table2.push([\n            '-',\n            formattedSpec, color('SKIPPED', 'gray'),\n            '-', '-', '-', '-', '-',\n          ])\n        }\n\n        return table2.push([\n          formatSymbolSummary(stats.failures),\n          formattedSpec,\n          color(ms, 'gray'),\n          colorIf(stats.tests, 'reset'),\n          colorIf(stats.passes, 'green'),\n          colorIf(stats.failures, 'red'),\n          colorIf(stats.pending, 'cyan'),\n          colorIf(stats.skipped, 'blue'),\n        ])\n      })\n\n      console.log('')\n      console.log('')\n      console.log(terminal.renderTables(table1, table2, table3))\n      console.log('')\n\n      if (runUrl) {\n        console.log('')\n\n        const table4 = terminal.table({\n          colWidths: [100],\n          type: 'pageDivider',\n          style: {\n            'padding-left': 2,\n          },\n        })\n\n        table4.push(['', ''])\n        table4.push([`Recorded Run: ${formatPath(runUrl, getWidth(table4, 0), 'gray')}`])\n\n        console.log(terminal.renderTables(table4))\n\n        console.log('')\n      }\n    }\n  }\n}\n\nconst iterateThroughSpecs = function (options = {}) {\n  const { specs, runEachSpec, beforeSpecRun, afterSpecRun, config } = options\n\n  const serial = () => {\n    return Promise.mapSeries(specs, runEachSpec)\n  }\n\n  const ranSpecs = []\n  const parallelAndSerialWithRecord = (runs) => {\n    return beforeSpecRun()\n    .then(({ spec, claimedInstances, totalInstances, estimated, shouldFallbackToOfflineOrder }) => {\n      // if (!parallel) {\n      //   // NOTE: if we receive the old API which always sends {spec: null},\n      //   // that would instantly end the run with a 0 exit code if we act like parallel mode.\n      //   // so instead we check length of ran specs just to make sure we have run all the specs.\n      //   // However, this means the api can't end a run early for us without some other logic being added.\n\n      //   if (shouldFallbackToOfflineOrder) {\n      //     spec = _.without(specs, ...ranSpecs)[0]?.relative\n      //   }\n      // }\n\n      // no more specs to run?\n      if (!spec) {\n        // then we're done!\n        return runs\n      }\n\n      // find the actual spec object amongst\n      // our specs array since the API sends us\n      // the relative name\n      spec = _.find(specs, { relative: spec })\n      ranSpecs.push(spec)\n\n      return runEachSpec(\n        spec,\n        claimedInstances - 1,\n        totalInstances,\n        estimated,\n      )\n      .tap((results) => {\n        runs.push(results)\n\n        return afterSpecRun(spec, results, config)\n      })\n      .then(() => {\n        // // no need to make an extra request if we know we've run all the specs\n        // if (!parallel && ranSpecs.length === specs.length) {\n        //   return runs\n        // }\n\n        // recurse\n        return parallelAndSerialWithRecord(runs)\n      })\n    })\n  }\n\n  if (beforeSpecRun) {\n    // if we are running in parallel\n    // then ask the server for the next spec\n    return parallelAndSerialWithRecord([])\n  }\n\n  // else iterate in serial\n  return serial()\n}\n\nconst getProjectId = Promise.method((project, id) => {\n  if (id == null) {\n    id = env.get('CYPRESS_PROJECT_ID')\n  }\n\n  // if we have an ID just use it\n  if (id) {\n    return id\n  }\n\n  return project.getProjectId()\n  .catch(() => {\n    // no id no problem\n    return null\n  })\n})\n\nconst getDefaultBrowserOptsByFamily = (browser, project, writeVideoFrame, onError) => {\n  la(browserUtils.isBrowserFamily(browser.family), 'invalid browser family in', browser)\n\n  if (browser.name === 'electron') {\n    return getElectronProps(browser.isHeaded, writeVideoFrame, onError)\n  }\n\n  if (browser.family === 'chromium') {\n    return getChromeProps(writeVideoFrame)\n  }\n\n  if (browser.family === 'firefox') {\n    return getFirefoxProps(project, writeVideoFrame)\n  }\n\n  return {}\n}\n\nconst getFirefoxProps = (project, writeVideoFrame) => {\n  debug('setting Firefox properties')\n\n  return _\n  .chain({})\n  .tap((props) => {\n    if (writeVideoFrame) {\n      const onScreencastFrame = (data) => {\n        writeVideoFrame(data)\n      }\n\n      project.on('capture:video:frames', onScreencastFrame)\n\n      props.onScreencastFrame = true\n    }\n  })\n  .value()\n}\n\nconst getCdpVideoPropSetter = (writeVideoFrame) => {\n  if (!writeVideoFrame) {\n    return _.noop\n  }\n\n  return (props) => {\n    props.onScreencastFrame = (e) => {\n      // https://chromedevtools.github.io/devtools-protocol/tot/Page#event-screencastFrame\n      writeVideoFrame(Buffer.from(e.data, 'base64'))\n    }\n  }\n}\n\nconst getChromeProps = (writeVideoFrame) => {\n  const shouldWriteVideo = Boolean(writeVideoFrame)\n\n  debug('setting Chrome properties %o', { shouldWriteVideo })\n\n  return _\n  .chain({})\n  .tap(getCdpVideoPropSetter(writeVideoFrame))\n  .value()\n}\n\nconst getElectronProps = (isHeaded, writeVideoFrame, onError) => {\n  return _\n  .chain({\n    width: 1920,\n    height: 1080,\n    show: isHeaded,\n    onCrashed () {\n      const err = errors.get('RENDERER_CRASHED')\n\n      errors.log(err)\n\n      onError(err)\n    },\n    onNewWindow (e, url, frameName, disposition, options) {\n      // force new windows to automatically open with show: false\n      // this prevents window.open inside of javascript client code\n      // to cause a new BrowserWindow instance to open\n      // https://github.com/cypress-io/cypress/issues/123\n      options.show = false\n    },\n  })\n  .tap(getCdpVideoPropSetter(writeVideoFrame))\n  .value()\n}\n\nconst sumByProp = (runs, prop) => {\n  return _.sumBy(runs, prop) || 0\n}\n\nconst getRun = (run, prop) => {\n  return _.get(run, prop)\n}\n\nconst writeOutput = (outputPath, results) => {\n  return Promise.try(() => {\n    if (!outputPath) {\n      return\n    }\n\n    debug('saving output results %o', { outputPath })\n\n    return fs.outputJsonAsync(outputPath, results)\n  })\n}\n\nconst onWarning = (err) => {\n  console.log(chalk.yellow(err.message))\n}\n\nconst openProjectCreate = (projectRoot, socketId, args) => {\n  // now open the project to boot the server\n  // putting our web client app in headless mode\n  // - NO  display server logs (via morgan)\n  // - YES display reporter results (via mocha reporter)\n  const options = {\n    socketId,\n    morgan: false,\n    report: true,\n    isTextTerminal: args.isTextTerminal,\n    // pass the list of browsers we have detected when opening a project\n    // to give user's plugins file a chance to change it\n    browsers: args.browsers,\n    onWarning,\n    onError: args.onError,\n  }\n\n  return openProject\n  .create(projectRoot, args, options)\n  .catch({ portInUse: true }, (err) => {\n    // TODO: this needs to move to call exitEarly\n    // so we record the failure in CI\n    return errors.throw('PORT_IN_USE_LONG', err.port)\n  })\n}\n\nconst createAndOpenProject = function (socketId, options) {\n  const { projectRoot, projectId } = options\n\n  return ProjectBase\n  .ensureExists(projectRoot, options)\n  .then(() => {\n    // open this project without\n    // adding it to the global cache\n    return openProjectCreate(projectRoot, socketId, options)\n  })\n  .call('getProject')\n  .then((project) => {\n    return Promise.props({\n      project,\n      config: project.getConfig(),\n      projectId: getProjectId(project, projectId),\n    })\n  })\n}\n\nconst removeOldProfiles = (browser) => {\n  return browserUtils.removeOldProfiles(browser)\n  .catch((err) => {\n    // dont make removing old browsers profiles break the build\n    return errors.warning('CANNOT_REMOVE_OLD_BROWSER_PROFILES', err.stack)\n  })\n}\n\nconst trashAssets = Promise.method((config = {}) => {\n  if (config.trashAssetsBeforeRuns !== true) {\n    return\n  }\n\n  return Promise.all([\n    trash.folder(config.videosFolder),\n    trash.folder(config.screenshotsFolder),\n    trash.folder(config.downloadsFolder),\n  ])\n  .catch((err) => {\n    // dont make trashing assets fail the build\n    return errors.warning('CANNOT_TRASH_ASSETS', err.stack)\n  })\n})\n\nconst createVideoRecording = function (videoName, options = {}) {\n  const outputDir = path.dirname(videoName)\n\n  const onError = _.once((err) => {\n    // catch video recording failures and log them out\n    // but don't let this affect the run at all\n    return errors.warning('VIDEO_RECORDING_FAILED', err.stack)\n  })\n\n  return fs\n  .ensureDirAsync(outputDir)\n  .catch(onError)\n  .then(() => {\n    return videoCapture\n    .start(videoName, _.extend({}, options, { onError }))\n  })\n}\n\nconst getVideoRecordingDelay = function (startedVideoCapture) {\n  if (startedVideoCapture) {\n    return DELAY_TO_LET_VIDEO_FINISH_MS\n  }\n\n  return 0\n}\n\nconst maybeStartVideoRecording = Promise.method(function (options = {}) {\n  const { spec, browser, video, videosFolder } = options\n\n  debug(`video recording has been ${video ? 'enabled' : 'disabled'}. video: %s`, video)\n  // bail if we've been told not to capture\n  // a video recording\n  if (!video) {\n    return\n  }\n\n  // make sure we have a videosFolder\n  if (!videosFolder) {\n    throw new Error('Missing videoFolder for recording')\n  }\n\n  const videoPath = (suffix) => {\n    return path.join(videosFolder, spec.name + suffix)\n  }\n\n  const videoName = videoPath('.mp4')\n  const compressedVideoName = videoPath('-compressed.mp4')\n\n  return this.createVideoRecording(videoName, { webmInput: browser.family === 'firefox' })\n  .then((props = {}) => {\n    return {\n      videoName,\n      compressedVideoName,\n      endVideoCapture: props.endVideoCapture,\n      writeVideoFrame: props.writeVideoFrame,\n      startedVideoCapture: props.startedVideoCapture,\n    }\n  })\n})\n\nconst warnVideoRecordingFailed = (err) => {\n  // log that post processing was attempted\n  // but failed and dont let this change the run exit code\n  errors.warning('VIDEO_POST_PROCESSING_FAILED', err.stack)\n}\n\nmodule.exports = {\n  collectTestResults,\n\n  getProjectId,\n\n  writeOutput,\n\n  openProjectCreate,\n\n  createVideoRecording,\n\n  getVideoRecordingDelay,\n\n  maybeStartVideoRecording,\n\n  getChromeProps,\n\n  getElectronProps,\n\n  displayRunStarting,\n\n  exitEarly (err) {\n    debug('set early exit error: %s', err.stack)\n\n    this.earlyExitErr = err\n  },\n\n  displayResults (obj = {}, estimated) {\n    const results = collectTestResults(obj, estimated)\n\n    const c = results.failures ? 'red' : 'green'\n\n    console.log('')\n\n    terminal.header('Results', {\n      color: [c],\n    })\n\n    const table = terminal.table({\n      colWidths: [14, 86],\n      type: 'outsideBorder',\n    })\n\n    const data = _.chain([\n      ['Tests:', results.tests],\n      ['Passing:', results.passes],\n      ['Failing:', results.failures],\n      ['Pending:', results.pending],\n      ['Skipped:', results.skipped],\n      ['Screenshots:', results.screenshots],\n      ['Video:', results.video],\n      ['Duration:', results.duration],\n      estimated ? ['Estimated:', results.estimated] : undefined,\n      ['Spec Ran:', formatPath(results.name, getWidth(table, 1), c)],\n    ])\n    .compact()\n    .map((arr) => {\n      const [key, val] = arr\n\n      return [color(key, 'gray'), color(val, c)]\n    })\n    .value()\n\n    table.push(...data)\n\n    console.log('')\n    console.log(table.toString())\n    console.log('')\n  },\n\n  displayScreenshots (screenshots = []) {\n    console.log('')\n\n    terminal.header('Screenshots', { color: ['yellow'] })\n\n    console.log('')\n\n    const table = terminal.table({\n      colWidths: [3, 82, 15],\n      colAligns: ['left', 'left', 'right'],\n      type: 'noBorder',\n      style: {\n        'padding-right': 0,\n      },\n      chars: {\n        'left': ' ',\n        'right': '',\n      },\n    })\n\n    screenshots.forEach((screenshot) => {\n      const dimensions = gray(`(${screenshot.width}x${screenshot.height})`)\n\n      table.push([\n        '-',\n        formatPath(`${screenshot.path}`, getWidth(table, 1)),\n        gray(dimensions),\n      ])\n    })\n\n    console.log(table.toString())\n\n    console.log('')\n  },\n\n  async postProcessRecording (name, cname, videoCompression, shouldUploadVideo, quiet, ffmpegChaptersConfig) {\n    debug('ending the video recording %o', { name, videoCompression, shouldUploadVideo })\n\n    // once this ended promises resolves\n    // then begin processing the file\n    // dont process anything if videoCompress is off\n    // or we've been told not to upload the video\n    if (videoCompression === false || shouldUploadVideo === false) {\n      return\n    }\n\n    function continueProcessing (onProgress = undefined) {\n      return videoCapture.process(name, cname, videoCompression, ffmpegChaptersConfig, onProgress)\n    }\n\n    if (quiet) {\n      return continueProcessing()\n    }\n\n    console.log('')\n\n    terminal.header('Video', {\n      color: ['cyan'],\n    })\n\n    console.log('')\n\n    const table = terminal.table({\n      colWidths: [3, 21, 76],\n      colAligns: ['left', 'left', 'left'],\n      type: 'noBorder',\n      style: {\n        'padding-right': 0,\n      },\n      chars: {\n        'left': ' ',\n        'right': '',\n      },\n    })\n\n    table.push([\n      gray('-'),\n      gray('Started processing:'),\n      chalk.cyan(`Compressing to ${videoCompression} CRF`),\n    ])\n\n    console.log(table.toString())\n\n    const started = Date.now()\n    let progress = Date.now()\n    const throttle = env.get('VIDEO_COMPRESSION_THROTTLE') || human('10 seconds')\n\n    const onProgress = function (float) {\n      if (float === 1) {\n        const finished = Date.now() - started\n        const dur = `(${humanTime.long(finished)})`\n\n        const table = terminal.table({\n          colWidths: [3, 21, 61, 15],\n          colAligns: ['left', 'left', 'left', 'right'],\n          type: 'noBorder',\n          style: {\n            'padding-right': 0,\n          },\n          chars: {\n            'left': ' ',\n            'right': '',\n          },\n        })\n\n        table.push([\n          gray('-'),\n          gray('Finished processing:'),\n          `${formatPath(name, getWidth(table, 2), 'cyan')}`,\n          gray(dur),\n        ])\n\n        console.log(table.toString())\n\n        console.log('')\n      }\n\n      if (Date.now() - progress > throttle) {\n        // bump up the progress so we dont\n        // continuously get notifications\n        progress += throttle\n        const percentage = `${Math.ceil(float * 100)}%`\n\n        console.log('    Compression progress: ', chalk.cyan(percentage))\n      }\n    }\n\n    return continueProcessing(onProgress)\n  },\n\n  launchBrowser (options = {}) {\n    const { browser, spec, writeVideoFrame, setScreenshotMetadata, project, screenshots, projectRoot, onError } = options\n\n    const browserOpts = getDefaultBrowserOptsByFamily(browser, project, writeVideoFrame, onError)\n\n    browserOpts.automationMiddleware = {\n      onBeforeRequest (message, data) {\n        if (message === 'take:screenshot') {\n          return setScreenshotMetadata(data)\n        }\n      },\n      onAfterResponse: (message, data, resp) => {\n        if (message === 'take:screenshot' && resp) {\n          const existingScreenshot = _.findIndex(screenshots, { path: resp.path })\n\n          if (existingScreenshot !== -1) {\n            // NOTE: saving screenshots to the same path will overwrite the previous one\n            // so we shouldn't report more screenshots than exist on disk.\n            // this happens when cy.screenshot is used in a retried test\n            screenshots.splice(existingScreenshot, 1, this.screenshotMetadata(data, resp))\n          } else {\n            screenshots.push(this.screenshotMetadata(data, resp))\n          }\n        }\n\n        return resp\n      },\n    }\n\n    const warnings = {}\n\n    browserOpts.projectRoot = projectRoot\n\n    browserOpts.onWarning = (err) => {\n      const { message } = err\n\n      // if this warning has already been\n      // seen for this browser launch then\n      // suppress it\n      if (warnings[message]) {\n        return\n      }\n\n      warnings[message] = err\n\n      return project.onWarning\n    }\n\n    return openProject.launch(browser, spec, browserOpts)\n  },\n\n  navigateToNextSpec (spec) {\n    return openProject.changeUrlToSpec(spec)\n  },\n\n  listenForProjectEnd (project, exit) {\n    return new Promise((resolve, reject) => {\n      if (exit === false) {\n        resolve = () => {\n          console.log('not exiting due to options.exit being false')\n        }\n      }\n\n      const onEarlyExit = function (err) {\n        if (err.isFatalApiErr) {\n          return reject(err)\n        }\n\n        console.log('')\n        errors.log(err)\n\n        // probably should say we ended\n        // early too: (Ended Early: true)\n        // in the stats\n        const obj = {\n          error: errors.stripAnsi(err.message),\n          stats: {\n            failures: 1,\n            tests: 0,\n            passes: 0,\n            pending: 0,\n            suites: 0,\n            skipped: 0,\n            wallClockDuration: 0,\n            wallClockStartedAt: new Date().toJSON(),\n            wallClockEndedAt: new Date().toJSON(),\n          },\n        }\n\n        return resolve(obj)\n      }\n\n      const onEnd = (obj) => {\n        return resolve(obj)\n      }\n\n      // when our project fires its end event\n      // resolve the promise\n      project.once('end', onEnd)\n\n      // if we already received a reason to exit early, go ahead and do it\n      if (this.earlyExitErr) {\n        return onEarlyExit(this.earlyExitErr)\n      }\n\n      // otherwise override exitEarly so we exit as soon as there is a reason\n      this.exitEarly = (err) => {\n        onEarlyExit(err)\n      }\n    })\n  },\n\n  /**\n   * In CT mode, browser do not relaunch.\n   * In browser laucnh is where we wire the new video\n   * recording callback.\n   * This has the effect of always hitting the first specs\n   * video callback.\n   *\n   * This allows us, if we need to, to call a different callback\n   * in the same browser\n   */\n  writeVideoFrameCallback () {\n    return this.currentWriteVideoFrameCallback(...arguments)\n  },\n\n  waitForBrowserToConnect (options = {}, shouldLaunchBrowser = true) {\n    const { project, socketId, timeout, onError, writeVideoFrame, spec } = options\n    const browserTimeout = process.env.CYPRESS_INTERNAL_BROWSER_CONNECT_TIMEOUT || timeout || 60000\n    let attempts = 0\n\n    // short circuit current browser callback so that we\n    // can rewire it without relaunching the browser\n    if (writeVideoFrame) {\n      this.currentWriteVideoFrameCallback = writeVideoFrame\n      options.writeVideoFrame = this.writeVideoFrameCallback.bind(this)\n    }\n\n    // without this the run mode is only setting new spec\n    // path for next spec in launch browser.\n    // we need it to run on every spec even in single browser mode\n    this.currentSetScreenshotMetadata = (data) => {\n      data.specName = spec.name\n\n      return data\n    }\n\n    options.setScreenshotMetadata = (data) => {\n      return this.currentSetScreenshotMetadata(data)\n    }\n\n    const wait = () => {\n      debug('waiting for socket to connect and browser to launch...')\n\n      if (!shouldLaunchBrowser) {\n        // If we do not launch the browser,\n        // we tell it that we are ready\n        // to receive the next spec\n        return this.navigateToNextSpec(options.spec)\n        .tap(() => {\n          debug('navigated to next spec')\n        })\n      }\n\n      return Promise.join(\n        this.waitForSocketConnection(project, socketId)\n        .tap(() => {\n          debug('socket connected', { socketId })\n        }),\n        this.launchBrowser(options)\n        .tap(() => {\n          debug('browser launched')\n        }),\n      )\n      .timeout(browserTimeout)\n      .catch(Promise.TimeoutError, (err) => {\n        attempts += 1\n\n        console.log('')\n\n        // always first close the open browsers\n        // before retrying or dieing\n        return openProject.closeBrowser()\n        .then(() => {\n          if (attempts === 1 || attempts === 2) {\n            // try again up to 3 attempts\n            const word = attempts === 1 ? 'Retrying...' : 'Retrying again...'\n\n            errors.warning('TESTS_DID_NOT_START_RETRYING', word)\n\n            return wait()\n          }\n\n          err = errors.get('TESTS_DID_NOT_START_FAILED')\n          errors.log(err)\n\n          onError(err)\n        })\n      })\n    }\n\n    return wait()\n  },\n\n  waitForSocketConnection (project, id) {\n    debug('waiting for socket connection... %o', { id })\n\n    return new Promise((resolve, reject) => {\n      const fn = function (socketId) {\n        debug('got socket connection %o', { id: socketId })\n\n        if (socketId === id) {\n          // remove the event listener if we've connected\n          project.removeListener('socket:connected', fn)\n\n          // resolve the promise\n          return resolve()\n        }\n      }\n\n      // when a socket connects verify this\n      // is the one that matches our id!\n      return project.on('socket:connected', fn)\n    })\n  },\n\n  waitForTestsToFinishRunning (options = {}) {\n    const { project, screenshots, startedVideoCapture, endVideoCapture, videoName, compressedVideoName, videoCompression, videoUploadOnPasses, exit, spec, estimated, quiet, config, testingType } = options\n\n    // https://github.com/cypress-io/cypress/issues/2370\n    // delay 1 second if we're recording a video to give\n    // the browser padding to render the final frames\n    // to avoid chopping off the end of the video\n    const delay = this.getVideoRecordingDelay(startedVideoCapture)\n\n    return this.listenForProjectEnd(project, exit)\n    .delay(delay)\n    .then(async (results) => {\n      _.defaults(results, {\n        error: null,\n        hooks: null,\n        tests: null,\n        video: null,\n        screenshots: null,\n        reporterStats: null,\n      })\n\n      // dashboard told us to skip this spec\n      const skippedSpec = results.skippedSpec\n\n      if (startedVideoCapture) {\n        results.video = videoName\n      }\n\n      if (screenshots) {\n        results.screenshots = screenshots\n      }\n\n      results.spec = spec\n\n      const { tests, stats } = results\n      const attempts = _.flatMap(tests, (test) => test.attempts)\n\n      // if we have a video recording\n      if (startedVideoCapture && tests && tests.length) {\n        // always set the video timestamp on tests\n        Reporter.setVideoTimestamp(startedVideoCapture, attempts)\n      }\n\n      let videoCaptureFailed = false\n\n      if (endVideoCapture) {\n        await endVideoCapture()\n        .tapCatch(() => videoCaptureFailed = true)\n        .catch(warnVideoRecordingFailed)\n      }\n\n      await runEvents.execute('after:spec', config, spec, results)\n\n      const videoExists = videoName ? await fs.pathExists(videoName) : false\n\n      if (startedVideoCapture && !videoExists) {\n        // the video file no longer exists at the path where we expect it,\n        // likely because the user deleted it in the after:spec event\n        debug(`No video found after spec ran - skipping processing. Video path: ${videoName}`)\n\n        results.video = null\n      }\n\n      const hasFailingTests = _.get(stats, 'failures') > 0\n      // we should upload the video if we upload on passes (by default)\n      // or if we have any failures and have started the video\n      const shouldUploadVideo = !skippedSpec && videoUploadOnPasses === true || Boolean((startedVideoCapture && hasFailingTests))\n\n      results.shouldUploadVideo = shouldUploadVideo\n\n      if (!quiet && !skippedSpec) {\n        this.displayResults(results, estimated)\n        if (screenshots && screenshots.length) {\n          this.displayScreenshots(screenshots)\n        }\n      }\n\n      if (testingType === 'e2e') {\n        // always close the browser now as opposed to letting\n        // it exit naturally with the parent process due to\n        // electron bug in windows\n        debug('attempting to close the browser')\n        await openProject.closeBrowser()\n      }\n\n      if (videoExists && !skippedSpec && endVideoCapture && !videoCaptureFailed) {\n        const ffmpegChaptersConfig = videoCapture.generateFfmpegChaptersConfig(results.tests)\n\n        await this.postProcessRecording(\n          videoName,\n          compressedVideoName,\n          videoCompression,\n          shouldUploadVideo,\n          quiet,\n          ffmpegChaptersConfig,\n        )\n        .catch(warnVideoRecordingFailed)\n      }\n\n      return results\n    })\n  },\n\n  screenshotMetadata (data, resp) {\n    return {\n      screenshotId: random.id(),\n      name: data.name || null,\n      testId: data.testId,\n      testAttemptIndex: data.testAttemptIndex,\n      takenAt: resp.takenAt,\n      path: resp.path,\n      height: resp.dimensions.height,\n      width: resp.dimensions.width,\n    }\n  },\n\n  runSpecs (options = {}) {\n    _.defaults(options, {\n      // only non-Electron browsers run headed by default\n      headed: options.browser.name !== 'electron',\n    })\n\n    const { config, browser, sys, headed, outputPath, specs, specPattern, beforeSpecRun, afterSpecRun, runUrl, parallel, group, tag, testingType } = options\n\n    const isHeadless = !headed\n\n    browser.isHeadless = isHeadless\n    browser.isHeaded = !isHeadless\n\n    const results = {\n      startedTestsAt: null,\n      endedTestsAt: null,\n      totalDuration: null,\n      totalSuites: null,\n      totalTests: null,\n      totalFailed: null,\n      totalPassed: null,\n      totalPending: null,\n      totalSkipped: null,\n      runs: null,\n      browserPath: browser.path,\n      browserName: browser.name,\n      browserVersion: browser.version,\n      osName: sys.osName,\n      osVersion: sys.osVersion,\n      cypressVersion: pkg.version,\n      runUrl,\n      config,\n    }\n\n    if (!options.quiet) {\n      displayRunStarting({\n        config,\n        specs,\n        group,\n        tag,\n        runUrl,\n        browser,\n        parallel,\n        specPattern,\n      })\n    }\n\n    let firstSpec = true\n\n    const runEachSpec = (spec, index, length, estimated) => {\n      if (!options.quiet) {\n        displaySpecHeader(spec.name, index + 1, length, estimated)\n      }\n\n      return this.runSpec(config, spec, options, estimated, firstSpec)\n      .tap(() => {\n        firstSpec = false\n      })\n      .get('results')\n      .tap((results) => {\n        return debug('spec results %o', results)\n      })\n    }\n\n    const beforeRunDetails = {\n      browser,\n      config,\n      cypressVersion: pkg.version,\n      group,\n      parallel,\n      runUrl,\n      specs,\n      specPattern,\n      system: _.pick(sys, 'osName', 'osVersion'),\n      tag,\n    }\n\n    return runEvents.execute('before:run', config, beforeRunDetails)\n    .then(() => {\n      return iterateThroughSpecs({\n        specs,\n        config,\n        parallel,\n        runEachSpec,\n        afterSpecRun,\n        beforeSpecRun,\n      })\n    })\n    .then((runs = []) => {\n      results.status = 'finished'\n      results.startedTestsAt = getRun(_.first(runs), 'stats.wallClockStartedAt')\n      results.endedTestsAt = getRun(_.last(runs), 'stats.wallClockEndedAt')\n      results.totalDuration = sumByProp(runs, 'stats.wallClockDuration')\n      results.totalSuites = sumByProp(runs, 'stats.suites')\n      results.totalTests = sumByProp(runs, 'stats.tests')\n      results.totalPassed = sumByProp(runs, 'stats.passes')\n      results.totalPending = sumByProp(runs, 'stats.pending')\n      results.totalFailed = sumByProp(runs, 'stats.failures')\n      results.totalSkipped = sumByProp(runs, 'stats.skipped')\n      results.runs = runs\n\n      debug('final results of all runs: %o', results)\n\n      const { each, remapKeys, remove, renameKey, setValue } = objUtils\n\n      // Remap results for module API/after:run to remove private props and\n      // rename props to make more user-friendly\n      const moduleAPIResults = remapKeys(results, {\n        runs: each((run) => ({\n          tests: each((test) => ({\n            attempts: each((attempt, i) => ({\n              timings: remove,\n              failedFromHookId: remove,\n              wallClockDuration: renameKey('duration'),\n              wallClockStartedAt: renameKey('startedAt'),\n              wallClockEndedAt: renameKey('endedAt'),\n              screenshots: setValue(\n                _(run.screenshots)\n                .filter({ testId: test.testId, testAttemptIndex: i })\n                .map((screenshot) => _.omit(screenshot,\n                  ['screenshotId', 'testId', 'testAttemptIndex']))\n                .value(),\n              ),\n            })),\n            testId: remove,\n          })),\n          hooks: each({\n            hookId: remove,\n          }),\n          stats: {\n            wallClockDuration: renameKey('duration'),\n            wallClockStartedAt: renameKey('startedAt'),\n            wallClockEndedAt: renameKey('endedAt'),\n          },\n          screenshots: remove,\n        })),\n      })\n\n      return Promise.try(() => {\n        return testingType === 'component' &&\n              openProject.closeBrowser()\n      })\n      .then(() => {\n        return runEvents.execute('after:run', config, moduleAPIResults)\n      })\n      .then(() => {\n        return writeOutput(outputPath, moduleAPIResults)\n      })\n      .return(results)\n    })\n  },\n\n  runSpec (config, spec = {}, options = {}, estimated, firstSpec) {\n    const { project, browser, onError } = options\n\n    const { isHeadless } = browser\n\n    debug('about to run spec %o', {\n      spec,\n      isHeadless,\n      browser,\n    })\n\n    if (browser.family !== 'chromium' && !options.config.chromeWebSecurity) {\n      console.log()\n      errors.warning('CHROME_WEB_SECURITY_NOT_SUPPORTED', browser.family)\n    }\n\n    const screenshots = []\n\n    return runEvents.execute('before:spec', config, spec)\n    .then(() => {\n    // we know we're done running headlessly\n    // when the renderer has connected and\n    // finishes running all of the tests.\n    // we're using an event emitter interface\n    // to gracefully handle this in promise land\n      return this.maybeStartVideoRecording({\n        spec,\n        browser,\n        video: options.video,\n        videosFolder: options.videosFolder,\n      })\n    })\n    .then((videoRecordProps = {}) => {\n      return Promise.props({\n        results: this.waitForTestsToFinishRunning({\n          spec,\n          config,\n          project,\n          estimated,\n          screenshots,\n          videoName: videoRecordProps.videoName,\n          compressedVideoName: videoRecordProps.compressedVideoName,\n          endVideoCapture: videoRecordProps.endVideoCapture,\n          startedVideoCapture: videoRecordProps.startedVideoCapture,\n          exit: options.exit,\n          videoCompression: options.videoCompression,\n          videoUploadOnPasses: options.videoUploadOnPasses,\n          quiet: options.quiet,\n          testingType: options.testingType,\n        }),\n\n        connection: this.waitForBrowserToConnect({\n          spec,\n          project,\n          browser,\n          screenshots,\n          onError,\n          writeVideoFrame: videoRecordProps.writeVideoFrame,\n          socketId: options.socketId,\n          webSecurity: options.webSecurity,\n          projectRoot: options.projectRoot,\n        }, options.testingType === 'e2e' || firstSpec),\n      })\n    })\n  },\n\n  findSpecs (config, specPattern) {\n    return specsUtil\n    .find(config, specPattern)\n    .tap((specs = []) => {\n      if (debug.enabled) {\n        const names = _.map(specs, 'name')\n\n        return debug(\n          'found \\'%d\\' specs using spec pattern \\'%s\\': %o',\n          names.length,\n          specPattern,\n          names,\n        )\n      }\n    })\n  },\n\n  ready (options = {}) {\n    debug('run mode ready with options %o', options)\n\n    _.defaults(options, {\n      isTextTerminal: true,\n      browser: 'electron',\n      quiet: false,\n    })\n\n    const socketId = random.id()\n    const { projectRoot, record, key, ciBuildId, parallel, group, browser: browserName, tag, testingType } = options\n\n    // this needs to be a closure over `this.exitEarly` and not a reference\n    // because `this.exitEarly` gets overwritten in `this.listenForProjectEnd`\n    const onError = options.onError = (err) => {\n      this.exitEarly(err)\n    }\n\n    // alias and coerce to null\n    let specPattern = options.spec || null\n\n    // ensure the project exists\n    // and open up the project\n    return browserUtils.getAllBrowsersWith()\n    .then((browsers) => {\n      debug('found all system browsers %o', browsers)\n      options.browsers = browsers\n\n      return createAndOpenProject(socketId, options)\n      .then(({ project, projectId, config }) => {\n        debug('project created and opened with config %o', config)\n\n        // if we have a project id and a key but record hasnt been given\n        recordMode.warnIfProjectIdButNoRecordOption(projectId, options)\n        recordMode.throwIfRecordParamsWithoutRecording(record, ciBuildId, parallel, group, tag)\n\n        if (record) {\n          recordMode.throwIfNoProjectId(projectId, settings.configFile(options))\n          recordMode.throwIfIncorrectCiBuildIdUsage(ciBuildId, parallel, group)\n          recordMode.throwIfIndeterminateCiBuildId(ciBuildId, parallel, group)\n        }\n\n        // user code might have modified list of allowed browsers\n        // but be defensive about it\n        const userBrowsers = _.get(config, 'resolved.browsers.value', browsers)\n\n        // all these operations are independent and should be run in parallel to\n        // speed the initial booting time\n        return Promise.all([\n          system.info(),\n          browserUtils.ensureAndGetByNameOrPath(browserName, false, userBrowsers).tap(removeOldProfiles),\n          this.findSpecs(config, specPattern),\n          trashAssets(config),\n        ])\n        .spread((sys = {}, browser = {}, specs = []) => {\n        // return only what is return to the specPattern\n          if (specPattern) {\n            specPattern = specsUtil.getPatternRelativeToProjectRoot(specPattern, projectRoot)\n          }\n\n          if (!specs.length) {\n            // did we use the spec pattern?\n            if (specPattern) {\n              errors.throw('NO_SPECS_FOUND', projectRoot, specPattern)\n            } else {\n              // else we looked in the integration folder\n              errors.throw('NO_SPECS_FOUND', config.integrationFolder, specPattern)\n            }\n          }\n\n          if (browser.family === 'chromium') {\n            chromePolicyCheck.run(onWarning)\n          }\n\n          if (options.testingType === 'component') {\n            specs = specs.filter((spec) => {\n              return spec.specType === 'component'\n            })\n          }\n\n          const runAllSpecs = ({ beforeSpecRun, afterSpecRun, runUrl, parallel }) => {\n            return this.runSpecs({\n              beforeSpecRun,\n              afterSpecRun,\n              projectRoot,\n              specPattern,\n              socketId,\n              parallel,\n              onError,\n              browser,\n              project,\n              runUrl,\n              group,\n              config,\n              specs,\n              sys,\n              tag,\n              videosFolder: config.videosFolder,\n              video: config.video,\n              videoCompression: config.videoCompression,\n              videoUploadOnPasses: config.videoUploadOnPasses,\n              exit: options.exit,\n              headed: options.headed,\n              quiet: options.quiet,\n              outputPath: options.outputPath,\n              testingType: options.testingType,\n            })\n            .tap((runSpecs) => {\n              if (!options.quiet) {\n                renderSummaryTable(runUrl)(runSpecs)\n              }\n            })\n          }\n\n          if (record) {\n            const { projectName } = config\n\n            return recordMode.createRunAndRecordSpecs({\n              tag,\n              key,\n              sys,\n              specs,\n              group,\n              config,\n              browser,\n              parallel,\n              ciBuildId,\n              testingType,\n              project,\n              projectId,\n              projectRoot,\n              projectName,\n              specPattern,\n              runAllSpecs,\n              onError,\n              quiet: options.quiet,\n            })\n          }\n\n          // not recording, can't be parallel\n          return runAllSpecs({\n            parallel: false,\n          })\n        })\n      })\n    })\n  },\n\n  async run (options) {\n    // electron >= 5.0.0 will exit the app if all browserwindows are closed,\n    // this is obviously undesirable in run mode\n    // https://github.com/cypress-io/cypress/pull/4720#issuecomment-514316695\n    app.on('window-all-closed', () => {\n      debug('all BrowserWindows closed, not exiting')\n    })\n\n    await app.whenReady()\n\n    return this.ready(options)\n  },\n}\n",
    "packages/server/lib/plugins/index.js": "const _ = require('lodash')\nconst cp = require('child_process')\nconst path = require('path')\nconst debug = require('debug')('cypress:server:plugins')\nconst resolve = require('resolve')\nconst Promise = require('bluebird')\nconst inspector = require('inspector')\nconst errors = require('../errors')\nconst util = require('./util')\nconst pkg = require('@packages/root')\n\nlet pluginsProcess = null\nlet registeredEvents = {}\nlet handlers = []\n\nconst register = (event, callback) => {\n  debug(`register event '${event}'`)\n\n  if (!_.isString(event)) {\n    throw new Error(`The plugin register function must be called with an event as its 1st argument. You passed '${event}'.`)\n  }\n\n  if (!_.isFunction(callback)) {\n    throw new Error(`The plugin register function must be called with a callback function as its 2nd argument. You passed '${callback}'.`)\n  }\n\n  registeredEvents[event] = callback\n}\n\nconst getPluginPid = () => {\n  if (pluginsProcess) {\n    return pluginsProcess.pid\n  }\n}\n\nconst registerHandler = (handler) => {\n  handlers.push(handler)\n}\n\nconst init = (config, options) => {\n  debug('plugins.init', config.pluginsFile)\n\n  // test and warn for incompatible plugin\n  try {\n    const retriesPluginPath = path.dirname(resolve.sync('cypress-plugin-retries', {\n      basedir: options.projectRoot,\n    }))\n\n    options.onWarning(errors.get('INCOMPATIBLE_PLUGIN_RETRIES', path.relative(options.projectRoot, retriesPluginPath)))\n  } catch (e) {\n    // noop, incompatible plugin not installed\n  }\n\n  return new Promise((_resolve, _reject) => {\n    // provide a safety net for fulfilling the promise because the\n    // 'handleError' function below can potentially be triggered\n    // before or after the promise is already fulfilled\n    let fulfilled = false\n\n    // eslint-disable-next-line @cypress/dev/arrow-body-multiline-braces\n    const fulfill = (_fulfill) => (value) => {\n      if (fulfilled) return\n\n      fulfilled = true\n      _fulfill(value)\n    }\n\n    const resolve = fulfill(_resolve)\n    const reject = fulfill(_reject)\n\n    if (!config.pluginsFile) {\n      debug('no user plugins file')\n    }\n\n    if (pluginsProcess) {\n      debug('kill existing plugins process')\n      pluginsProcess.kill()\n    }\n\n    registeredEvents = {}\n\n    const pluginsFile = config.pluginsFile || path.join(__dirname, 'child', 'default_plugins_file.js')\n    const childIndexFilename = path.join(__dirname, 'child', 'index.js')\n    const childArguments = ['--file', pluginsFile, '--projectRoot', options.projectRoot]\n    const childOptions = {\n      stdio: 'inherit',\n    }\n\n    if (config.resolvedNodePath) {\n      debug('launching using custom node version %o', _.pick(config, ['resolvedNodePath', 'resolvedNodeVersion']))\n      childOptions.execPath = config.resolvedNodePath\n    }\n\n    debug('forking to run %s', childIndexFilename)\n\n    if (inspector.url()) {\n      childOptions.execArgv = _.chain(process.execArgv.slice(0))\n      .remove('--inspect-brk')\n      .push(`--inspect=${process.debugPort + 1}`)\n      .value()\n    }\n\n    pluginsProcess = cp.fork(childIndexFilename, childArguments, childOptions)\n    const ipc = util.wrapIpc(pluginsProcess)\n\n    for (let handler of handlers) {\n      handler(ipc)\n    }\n\n    _.extend(config, {\n      projectRoot: options.projectRoot,\n      configFile: options.configFile,\n      version: pkg.version,\n      testingType: options.testingType,\n    })\n\n    // alphabetize config by keys\n    let orderedConfig = {}\n\n    Object.keys(config).sort().forEach((key) => orderedConfig[key] = config[key])\n    config = orderedConfig\n\n    ipc.send('load', config)\n\n    ipc.on('loaded', (newCfg, registrations) => {\n      _.omit(config, 'projectRoot', 'configFile')\n\n      _.each(registrations, (registration) => {\n        debug('register plugins process event', registration.event, 'with id', registration.eventId)\n\n        register(registration.event, (...args) => {\n          return util.wrapParentPromise(ipc, registration.eventId, (invocationId) => {\n            debug('call event', registration.event, 'for invocation id', invocationId)\n            const ids = {\n              eventId: registration.eventId,\n              invocationId,\n            }\n\n            // no argument is passed for cy.task()\n            // This is necessary because undefined becomes null when it is sent through ipc.\n            if (registration.event === 'task' && args[1] === undefined) {\n              args[1] = {\n                __cypress_task_no_argument__: true,\n              }\n            }\n\n            ipc.send('execute', registration.event, ids, args)\n          })\n        })\n      })\n\n      debug('resolving with new config %o', newCfg)\n\n      resolve(newCfg)\n    })\n\n    ipc.on('load:error', (type, ...args) => {\n      debug('load:error %s, rejecting', type)\n\n      reject(errors.get(type, ...args))\n    })\n\n    const killPluginsProcess = () => {\n      pluginsProcess && pluginsProcess.kill()\n      pluginsProcess = null\n    }\n\n    const handleError = (err) => {\n      debug('plugins process error:', err.stack)\n\n      if (!pluginsProcess) return // prevent repeating this in case of multiple errors\n\n      killPluginsProcess()\n\n      err = errors.get('PLUGINS_UNEXPECTED_ERROR', config.pluginsFile, err.annotated || err.stack || err.message)\n      err.title = 'Error running plugin'\n\n      // this can sometimes trigger before the promise is fulfilled and\n      // sometimes after, so we need to handle each case differently\n      if (fulfilled) {\n        options.onError(err)\n      } else {\n        reject(err)\n      }\n    }\n\n    const handleWarning = (warningErr) => {\n      debug('plugins process warning:', warningErr.stack)\n      if (!pluginsProcess) return // prevent repeating this in case of multiple warnings\n\n      return options.onWarning(warningErr)\n    }\n\n    pluginsProcess.on('error', handleError)\n    ipc.on('error', handleError)\n    ipc.on('warning', handleWarning)\n\n    // see timers/parent.js line #93 for why this is necessary\n    process.on('exit', killPluginsProcess)\n  })\n}\n\nconst has = (event) => {\n  const isRegistered = !!registeredEvents[event]\n\n  debug('plugin event registered? %o', {\n    event,\n    isRegistered,\n  })\n\n  return isRegistered\n}\n\nconst execute = (event, ...args) => {\n  debug(`execute plugin event '${event}' Node '${process.version}' with args: %o %o %o`, ...args)\n\n  return registeredEvents[event](...args)\n}\n\nconst _reset = () => {\n  registeredEvents = {}\n  handlers = []\n}\n\nconst _setPluginsProcess = (_pluginsProcess) => {\n  pluginsProcess = _pluginsProcess\n}\n\nmodule.exports = {\n  getPluginPid,\n  execute,\n  has,\n  init,\n  register,\n  registerHandler,\n\n  // for testing purposes\n  _reset,\n  _setPluginsProcess,\n}\n",
    "packages/server/lib/plugins/util.js": "const _ = require('lodash')\nconst EE = require('events')\nconst debug = require('debug')('cypress:server:plugins')\nconst Promise = require('bluebird')\n\nconst UNDEFINED_SERIALIZED = '__cypress_undefined__'\n\nconst serializeError = (err) => {\n  return _.pick(err, 'name', 'message', 'stack', 'code', 'annotated', 'type')\n}\n\nmodule.exports = {\n  serializeError,\n\n  wrapIpc (aProcess) {\n    const emitter = new EE()\n\n    aProcess.on('message', (message) => {\n      return emitter.emit(message.event, ...message.args)\n    })\n\n    // prevent max listeners warning on ipc\n    // @see https://github.com/cypress-io/cypress/issues/1305#issuecomment-780895569\n    emitter.setMaxListeners(Infinity)\n\n    return {\n      send (event, ...args) {\n        if (aProcess.killed) {\n          return\n        }\n\n        return aProcess.send({\n          event,\n          args,\n        })\n      },\n\n      on: emitter.on.bind(emitter),\n      removeListener: emitter.removeListener.bind(emitter),\n    }\n  },\n\n  wrapChildPromise (ipc, invoke, ids, args = []) {\n    return Promise.try(() => {\n      return invoke(ids.eventId, args)\n    })\n    .then((value) => {\n      // undefined is coerced into null when sent over ipc, but we need\n      // to differentiate between them for 'task' event\n      if (value === undefined) {\n        value = UNDEFINED_SERIALIZED\n      }\n\n      return ipc.send(`promise:fulfilled:${ids.invocationId}`, null, value)\n    }).catch((err) => {\n      return ipc.send(`promise:fulfilled:${ids.invocationId}`, serializeError(err))\n    })\n  },\n\n  wrapParentPromise (ipc, eventId, callback) {\n    const invocationId = _.uniqueId('inv')\n\n    return new Promise((resolve, reject) => {\n      const handler = function (err, value) {\n        ipc.removeListener(`promise:fulfilled:${invocationId}`, handler)\n\n        if (err) {\n          debug('promise rejected for id %s %o', invocationId, ':', err.stack)\n          reject(_.extend(new Error(err.message), err))\n\n          return\n        }\n\n        if (value === UNDEFINED_SERIALIZED) {\n          value = undefined\n        }\n\n        debug(`promise resolved for id '${invocationId}' with value`, value)\n\n        return resolve(value)\n      }\n\n      ipc.on(`promise:fulfilled:${invocationId}`, handler)\n\n      return callback(invocationId)\n    })\n  },\n}\n",
    "packages/server/lib/video_capture.js": "const _ = require('lodash')\nconst utils = require('fluent-ffmpeg/lib/utils')\nconst debug = require('debug')('cypress:server:video')\nconst ffmpeg = require('fluent-ffmpeg')\nconst stream = require('stream')\nconst Promise = require('bluebird')\nconst ffmpegPath = require('@ffmpeg-installer/ffmpeg').path\nconst BlackHoleStream = require('black-hole-stream')\nconst { fs } = require('./util/fs')\n\n// extra verbose logs for logging individual frames\nconst debugFrames = require('debug')('cypress-verbose:server:video:frames')\n\ndebug('using ffmpeg from %s', ffmpegPath)\n\nffmpeg.setFfmpegPath(ffmpegPath)\n\nconst deferredPromise = function () {\n  let reject\n  let resolve = (reject = null)\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  })\n\n  return { promise, resolve, reject }\n}\n\nmodule.exports = {\n  generateFfmpegChaptersConfig (tests) {\n    if (!tests) {\n      return null\n    }\n\n    const configString = tests.map((test) => {\n      return test.attempts.map((attempt, i) => {\n        const { videoTimestamp, wallClockDuration } = attempt\n        let title = test.title ? test.title.join(' ') : ''\n\n        if (i > 0) {\n          title += `attempt ${i}`\n        }\n\n        return [\n          '[CHAPTER]',\n          'TIMEBASE=1/1000',\n          `START=${videoTimestamp - wallClockDuration}`,\n          `END=${videoTimestamp}`,\n          `title=${title}`,\n        ].join('\\n')\n      }).join('\\n')\n    }).join('\\n')\n\n    return `;FFMETADATA1\\n${configString}`\n  },\n\n  getMsFromDuration (duration) {\n    return utils.timemarkToSeconds(duration) * 1000\n  },\n\n  getCodecData (src) {\n    return new Promise((resolve, reject) => {\n      return ffmpeg()\n      .on('stderr', (stderr) => {\n        return debug('get codecData stderr log %o', { message: stderr })\n      }).on('codecData', resolve)\n      .input(src)\n      .format('null')\n      .output(new BlackHoleStream())\n      .run()\n    }).tap((data) => {\n      return debug('codecData %o', {\n        src,\n        data,\n      })\n    }).tapCatch((err) => {\n      return debug('getting codecData failed', { err })\n    })\n  },\n\n  getChapters (fileName) {\n    return new Promise((resolve, reject) => {\n      ffmpeg.ffprobe(fileName, ['-show_chapters'], (err, metadata) => {\n        if (err) {\n          return reject(err)\n        }\n\n        resolve(metadata)\n      })\n    })\n  },\n\n  copy (src, dest) {\n    debug('copying from %s to %s', src, dest)\n\n    return fs\n    .copyAsync(src, dest, { overwrite: true })\n    .catch({ code: 'ENOENT' }, () => {})\n  },\n  // dont yell about ENOENT errors\n\n  start (name, options = {}) {\n    const pt = stream.PassThrough()\n    const ended = deferredPromise()\n    let done = false\n    let wantsWrite = true\n    let skippedChunksCount = 0\n    let writtenChunksCount = 0\n\n    _.defaults(options, {\n      onError () {},\n    })\n\n    const endVideoCapture = function (waitForMoreChunksTimeout = 3000) {\n      debugFrames('frames written:', writtenChunksCount)\n\n      // in some cases (webm) ffmpeg will crash if fewer than 2 buffers are\n      // written to the stream, so we don't end capture until we get at least 2\n      if (writtenChunksCount < 2) {\n        return new Promise((resolve) => {\n          pt.once('data', resolve)\n        })\n        .then(endVideoCapture)\n        .timeout(waitForMoreChunksTimeout)\n      }\n\n      done = true\n\n      pt.end()\n\n      // return the ended promise which will eventually\n      // get resolve or rejected\n      return ended.promise\n    }\n\n    const lengths = {}\n\n    const writeVideoFrame = function (data) {\n      // make sure we haven't ended\n      // our stream yet because paint\n      // events can linger beyond\n      // finishing the actual video\n      if (done) {\n        return\n      }\n\n      // when `data` is empty, it is sent as an empty Buffer (`<Buffer >`)\n      // which can crash the process. this can happen if there are\n      // errors in the video capture process, which are handled later\n      // on, so just skip empty frames here.\n      // @see https://github.com/cypress-io/cypress/pull/6818\n      if (_.isEmpty(data)) {\n        debugFrames('empty chunk received %o', data)\n\n        return\n      }\n\n      if (lengths[data.length]) {\n        // this prevents multiple chunks of webm metadata from being written to the stream\n        // which would crash ffmpeg\n        debugFrames('duplicate length frame received:', data.length)\n\n        return\n      }\n\n      writtenChunksCount++\n\n      debugFrames('writing video frame')\n      lengths[data.length] = true\n\n      if (wantsWrite) {\n        if (!(wantsWrite = pt.write(data))) {\n          return pt.once('drain', () => {\n            debugFrames('video stream drained')\n\n            wantsWrite = true\n          })\n        }\n      } else {\n        skippedChunksCount += 1\n\n        return debugFrames('skipping video frame %o', { skipped: skippedChunksCount })\n      }\n    }\n\n    const startCapturing = () => {\n      return new Promise((resolve) => {\n        const cmd = ffmpeg({\n          source: pt,\n          priority: 20,\n        })\n        .videoCodec('libx264')\n        .outputOptions('-preset ultrafast')\n        .on('start', (command) => {\n          debug('capture started %o', { command })\n\n          return resolve({\n            cmd,\n            startedVideoCapture: new Date,\n          })\n        }).on('codecData', (data) => {\n          return debug('capture codec data: %o', data)\n        }).on('stderr', (stderr) => {\n          return debug('capture stderr log %o', { message: stderr })\n        }).on('error', (err, stdout, stderr) => {\n          debug('capture errored: %o', { error: err.message, stdout, stderr })\n\n          // bubble errors up\n          options.onError(err, stdout, stderr)\n\n          // reject the ended promise\n          return ended.reject(err)\n        }).on('end', () => {\n          debug('capture ended')\n\n          return ended.resolve()\n        })\n\n        // this is to prevent the error \"invalid data input\" error\n        // when input frames have an odd resolution\n        .videoFilters(`crop='floor(in_w/2)*2:floor(in_h/2)*2'`)\n\n        if (options.webmInput) {\n          cmd\n          .inputFormat('webm')\n\n          // assume 18 fps. This number comes from manual measurement of avg fps coming from firefox.\n          // TODO: replace this with the 'vfr' option below when dropped frames issue is fixed.\n          .inputFPS(18)\n\n          // 'vsync vfr' (variable framerate) works perfectly but fails on top page navigation\n          // since video timestamp resets to 0, timestamps already written will be dropped\n          // .outputOption('-vsync vfr')\n        } else {\n          cmd\n          .inputFormat('image2pipe')\n          .inputOptions('-use_wallclock_as_timestamps 1')\n        }\n\n        return cmd.save(name)\n      })\n    }\n\n    return startCapturing()\n    .then(({ cmd, startedVideoCapture }) => {\n      return {\n        _pt: pt,\n        cmd,\n        endVideoCapture,\n        writeVideoFrame,\n        startedVideoCapture,\n      }\n    })\n  },\n\n  async process (name, cname, videoCompression, ffmpegchaptersConfig, onProgress = function () {}) {\n    const metaFileName = `${name}.meta`\n\n    const maybeGenerateMetaFile = Promise.method(() => {\n      if (!ffmpegchaptersConfig) {\n        return false\n      }\n\n      // Writing the metadata to filesystem is necessary because fluent-ffmpeg is just a wrapper of ffmpeg command.\n      return fs.writeFile(metaFileName, ffmpegchaptersConfig).then(() => true)\n    })\n\n    const addChaptersMeta = await maybeGenerateMetaFile()\n\n    let total = null\n\n    return new Promise((resolve, reject) => {\n      debug('processing video from %s to %s video compression %o',\n        name, cname, videoCompression)\n\n      const command = ffmpeg()\n      const outputOptions = [\n        '-preset fast',\n        `-crf ${videoCompression}`,\n      ]\n\n      if (addChaptersMeta) {\n        command.input(metaFileName)\n        outputOptions.push('-map_metadata 1')\n      }\n\n      command.input(name)\n      .videoCodec('libx264')\n      .outputOptions(outputOptions)\n      // .videoFilters(\"crop='floor(in_w/2)*2:floor(in_h/2)*2'\")\n      .on('start', (command) => {\n        debug('compression started %o', { command })\n      })\n      .on('codecData', (data) => {\n        debug('compression codec data: %o', data)\n\n        total = utils.timemarkToSeconds(data.duration)\n      })\n      .on('stderr', (stderr) => {\n        debug('compression stderr log %o', { message: stderr })\n      })\n      .on('progress', (progress) => {\n        // bail if we dont have total yet\n        if (!total) {\n          return\n        }\n\n        debug('compression progress: %o', progress)\n\n        const progressed = utils.timemarkToSeconds(progress.timemark)\n\n        const percent = progressed / total\n\n        if (percent < 1) {\n          return onProgress(percent)\n        }\n      })\n      .on('error', (err, stdout, stderr) => {\n        debug('compression errored: %o', { error: err.message, stdout, stderr })\n\n        return reject(err)\n      })\n      .on('end', () => {\n        debug('compression ended')\n\n        // we are done progressing\n        onProgress(1)\n\n        // rename and obliterate the original\n        return fs.moveAsync(cname, name, {\n          overwrite: true,\n        })\n        .then(() => {\n          if (addChaptersMeta) {\n            return fs.unlink(metaFileName)\n          }\n        })\n        .then(() => {\n          return resolve()\n        })\n      }).save(cname)\n    })\n  },\n\n}\n",
    "packages/server/test/e2e/4_browser_path_spec.js": "const path = require('path')\nconst { exec } = require('child_process')\n\nconst e2e = require('../support/helpers/e2e').default\nconst Fixtures = require('../support/helpers/fixtures')\nconst launcher = require('@packages/launcher')\n\nconst absPath = (pathStr) => {\n  return new Promise((resolve, reject) => {\n    if (path.basename(pathStr) !== pathStr) {\n      return resolve(pathStr)\n    }\n\n    return exec(`which ${pathStr}`, (err, stdout) => {\n      if (err) {\n        return reject(err)\n      }\n\n      return resolve(stdout.trim())\n    })\n  })\n}\n\ndescribe('e2e launching browsers by path', () => {\n  e2e.setup()\n\n  it('fails with bad browser path', function () {\n    return e2e.exec(this, {\n      project: Fixtures.projectPath('e2e'),\n      spec: 'simple_spec.js',\n      browser: '/this/aint/gonna/be/found',\n      expectedExitCode: 1,\n    })\n    .then((res) => {\n      expect(res.stdout).to.contain('We could not identify a known browser at the path you provided: `/this/aint/gonna/be/found`')\n\n      expect(res.code).to.eq(1)\n    })\n  })\n\n  it('works with an installed browser path', function () {\n    return launcher.detect().then((browsers) => {\n      return browsers.find((browser) => {\n        return browser.family === 'chromium'\n      })\n    }).tap((browser) => {\n      if (!browser) {\n        throw new Error('A \\'chromium\\' family browser must be installed for this test')\n      }\n    }).get('path')\n    // turn binary browser names (\"google-chrome\") into their absolute paths\n    // so that server recognizes them as a path, not as a browser name\n    .then((absPath))\n    .then((foundPath) => {\n      return e2e.exec(this, {\n        project: Fixtures.projectPath('e2e'),\n        spec: 'simple_spec.js',\n        browser: foundPath,\n        snapshot: true,\n      })\n    })\n  })\n})\n",
    "packages/server/test/e2e/6_video_compression_spec.js": "// ffprobe is necessary to extract chapters data from mp4 files.\n// ffprobe is usually installed with ffmpeg.\n// But in our CI, it doesn't. That's why we're installing ffprobe here.\nconst ffprobePath = require('@ffprobe-installer/ffprobe').path\nconst ffmpeg = require('fluent-ffmpeg')\n\nffmpeg.setFfprobePath(ffprobePath)\n\nconst path = require('path')\nconst fs = require('fs-extra')\nconst humanInterval = require('human-interval')\nconst e2e = require('../support/helpers/e2e').default\nconst glob = require('../../lib/util/glob')\nconst videoCapture = require('../../lib/video_capture')\nconst Fixtures = require('../support/helpers/fixtures')\n\nconst NUM_TESTS = 40\nconst MS_PER_TEST = 500\nconst EXPECTED_DURATION_MS = NUM_TESTS * MS_PER_TEST\n\n// ffmpeg command that extracts the final frame as a jpg\nfunction outputFinalFrameAsJpg (inputFile, outputFile) {\n  return new Promise((resolve, reject) => {\n    return ffmpeg(inputFile)\n    .inputOption('-sseof -3')\n    .outputOptions(['-vsync 2', '-update 1'])\n    .on('end', resolve)\n    .on('error', reject)\n    .save(outputFile)\n  })\n}\n\ndescribe('e2e video compression', () => {\n  e2e.setup()\n\n  return [\n    true,\n    false,\n  ].forEach((headed) => {\n    e2e.it(`passes (head${headed ? 'ed' : 'less'})`, {\n      spec: 'video_compression_spec.js',\n      snapshot: false,\n      headed,\n      config: {\n        env: {\n          NUM_TESTS,\n          MS_PER_TEST,\n        },\n      },\n      onRun (exec) {\n        process.env.VIDEO_COMPRESSION_THROTTLE = 10\n\n        return exec()\n        .tap(() => {\n          const videosPath = Fixtures.projectPath('e2e/cypress/videos/*')\n\n          return glob(videosPath)\n          .tap(async (files) => {\n            expect(files).to.have.length(1, `globbed for videos and found: ${files.length}. Expected to find 1 video. Search in videosPath: ${videosPath}.`)\n\n            const lastFrameFile = path.join(path.dirname(files[0]), 'lastFrame.jpg')\n\n            await outputFinalFrameAsJpg(files[0], lastFrameFile)\n            // https://github.com/cypress-io/cypress/issues/9265\n            // if video is seekable and not just one frozen frame, this file should exist\n            await fs.stat(lastFrameFile).catch((err) => {\n              throw new Error(`Expected video to have seekable ending frame, but it did not. The video may be corrupted.`)\n            })\n\n            return videoCapture.getCodecData(files[0])\n            .then(({ duration }) => {\n              const durationMs = videoCapture.getMsFromDuration(duration)\n\n              expect(durationMs).to.be.ok\n\n              expect(durationMs).to.be.closeTo(EXPECTED_DURATION_MS, humanInterval('15 seconds'))\n            })\n          })\n          .then((files) => {\n            return videoCapture.getChapters(files[0])\n            .then(({ chapters }) => {\n              // There are 40 chapters but we test only the first one\n              // because what we want to check is if chapters are added properly.\n              // In a chapter object, there are properties like 'end' and 'end_time'.\n              // We don't check them here because they return the test time in milliseconds.\n              // They cannot be guessed correctly and they can cause flakiness.\n              expect(chapters[0].id).to.eq(0)\n              expect(chapters[0].start).to.eq(0)\n              expect(chapters[0].start_time).to.eq(0)\n              expect(chapters[0]['TAG:title']).to.eq('num: 1 makes some long tests')\n              expect(chapters[0].time_base).to.eq('1/1000')\n              expect(chapters[0].end).to.be.a('number')\n              expect(Number.isNaN(chapters[0].end)).to.be.false\n              expect(chapters[0].end_time).to.be.a('number')\n              expect(Number.isNaN(chapters[0].end_time)).to.be.false\n            })\n          })\n        }).get('stdout')\n        .then((stdout) => {\n          expect(stdout).to.match(/Compression progress:\\s+\\d{1,3}%/)\n        })\n      },\n    })\n  })\n})\n",
    "packages/server/test/performance/proxy_performance_spec.js": "require('../spec_helper')\n\nconst cp = require('child_process')\nconst fse = require('fs-extra')\nconst os = require('os')\nconst path = require('path')\nconst _ = require('lodash')\nconst { expect } = require('chai')\nconst debug = require('debug')('test:proxy-performance')\nconst DebuggingProxy = require('@cypress/debugging-proxy')\nconst HarCapturer = require('chrome-har-capturer')\nconst performance = require('../support/helpers/performance')\nconst Promise = require('bluebird')\nconst sanitizeFilename = require('sanitize-filename')\n\nprocess.env.CYPRESS_INTERNAL_ENV = 'development'\n\nconst CA = require('@packages/https-proxy').CA\nconst Config = require('../../lib/config')\nconst { ServerE2E } = require('../../lib/server-e2e')\nconst { _getArgs } = require('../../lib/browsers/chrome')\n\nconst CHROME_PATH = 'google-chrome'\nconst URLS_UNDER_TEST = [\n  'https://test-page-speed.cypress.io/index1000.html',\n  'http://test-page-speed.cypress.io/index1000.html',\n]\n\nconst start = (new Date()) / 1000\n\nconst PROXY_PORT = process.env.PROXY_PORT || 45678\nconst HTTPS_PROXY_PORT = process.env.HTTPS_PROXY_PORT || 45681\nconst CDP_PORT = 45679 /** port range starts here, not the actual port */\nconst CY_PROXY_PORT = 45680\n\nconst TEST_CASES = [\n  // these first 4 cases don't involve Cypress, don't need to run every time\n  // {\n  //   name: 'Chrome w/o HTTP/2',\n  //   disableHttp2: true,\n  // },\n  // {\n  //   name: 'Chrome',\n  // },\n  // {\n  //   name: 'With proxy',\n  //   upstreamProxy: true,\n  // },\n  // {\n  //   name: 'With HTTPS proxy',\n  //   httpsUpstreamProxy: true,\n  // },\n  // baseline test that all other tests are compared to\n  {\n    name: 'Chrome w/ proxy w/o HTTP/2 (baseline)',\n    disableHttp2: true,\n    upstreamProxy: true,\n  },\n  {\n    name: 'With Cypress proxy, Intercepted',\n    cyProxy: true,\n    cyIntercept: true,\n  },\n  {\n    name: 'With Cypress proxy, Not Intercepted',\n    cyProxy: true,\n  },\n  {\n    name: 'With Cypress proxy w/o HTTP/2, Not Intercepted',\n    cyProxy: true,\n    disableHttp2: true,\n  },\n  {\n    name: 'With Cypress proxy and upstream, Intercepted',\n    cyProxy: true,\n    upstreamProxy: true,\n    cyIntercept: true,\n  },\n  {\n    name: 'With Cypress proxy and HTTPS upstream, Intercepted',\n    cyProxy: true,\n    httpsUpstreamProxy: true,\n    cyIntercept: true,\n  },\n  {\n    name: 'With Cypress proxy and upstream, Not Intercepted',\n    cyProxy: true,\n    upstreamProxy: true,\n  },\n  {\n    name: 'With Cypress proxy and HTTPS upstream, Not Intercepted',\n    cyProxy: true,\n    httpsUpstreamProxy: true,\n  },\n].map((v) => {\n  // fill in all the fields so the keys are in the correct order for readability\n  return _.defaults(v, {\n    disableHttp2: false,\n    upstreamProxy: false,\n    httpsUpstreamProxy: false,\n    cyProxy: false,\n    cyIntercept: false,\n  })\n})\n\nconst average = (arr) => {\n  return _.sum(arr) / arr.length\n}\n\nconst percentile = (sortedArr, p) => {\n  const i = Math.floor(p / 100 * (sortedArr.length - 1))\n\n  return Math.round(sortedArr[i])\n}\n\nconst getResultsFromHar = (har) => {\n  // HAR 1.2 Spec: http://www.softwareishard.com/blog/har-12-spec/\n  const { entries } = har.log\n  const results = {}\n\n  const first = entries[0]\n  const last = entries[entries.length - 1]\n  const elapsed = Number(new Date(last.startedDateTime)) + last.time - Number(new Date(first.startedDateTime))\n\n  results['Total'] = Math.round(elapsed)\n\n  let mins = {}\n  let maxes = {}\n\n  const timings = {\n    'receive': [],\n    'wait': [],\n    'send': [],\n    'total': [],\n  }\n\n  entries.forEach((entry) => {\n    const blockedTime = _.get(entry.timings, 'blocked', -1) === -1 ? 0 : entry.timings.blocked\n    const totalTime = entry.time - blockedTime\n\n    timings.total.push(totalTime)\n\n    Object.keys(entry.timings).forEach((timingKey) => {\n      if (entry.timings[timingKey] === -1 || !entry.timings[timingKey]) return\n\n      const ms = Math.round(entry.timings[timingKey])\n\n      if (timings[timingKey]) timings[timingKey].push(ms)\n    })\n  })\n\n  for (const key in timings) {\n    const arr = timings[key]\n\n    arr.sort((a, b) => {\n      return a - b\n    })\n\n    mins[key] = Math.round(arr[0])\n    maxes[key] = Math.round(arr[arr.length - 1])\n\n    _.merge(results, {\n      [`Avg ${_.upperFirst(key)}`]: Math.round(average(arr)),\n    })\n  }\n\n  results['Min'] = mins.total\n\n  expect(timings.total.length).to.be.at.least(1000)\n\n  ;[1, 5, 25, 50, 75, 95, 99, 99.7].forEach((p) => {\n    results[`${p}% <=`] = percentile(timings.total, p)\n  })\n\n  results['Max'] = maxes.total\n\n  return results\n}\n\nconst runBrowserTest = (urlUnderTest, testCase) => {\n  const cdpPort = CDP_PORT + Math.round(Math.random() * 10000)\n\n  const browser = {\n    isHeadless: true,\n  }\n\n  const options = {}\n\n  const args = _getArgs(browser, options, cdpPort).concat([\n    // additionally...\n    '--disable-background-networking',\n    '--no-sandbox', // allows us to run as root, for CI\n    `--user-data-dir=${fse.mkdtempSync(path.join(os.tmpdir(), 'cy-perf-'))}`,\n  ])\n\n  if (testCase.disableHttp2) {\n    args.push('--disable-http2')\n  }\n\n  if (testCase.cyProxy) {\n    args.push(`--proxy-server=http://localhost:${CY_PROXY_PORT}`)\n  }\n\n  if (testCase.upstreamProxy && !testCase.cyProxy) {\n    args.push(`--proxy-server=http://localhost:${PROXY_PORT}`)\n  } else if (testCase.httpsUpstreamProxy && !testCase.cyProxy) {\n    args.push(`--proxy-server=https://localhost:${HTTPS_PROXY_PORT}`)\n  }\n\n  if (testCase.upstreamProxy && testCase.cyProxy) {\n    process.env.HTTP_PROXY = process.env.HTTPS_PROXY = `http://localhost:${PROXY_PORT}`\n  } else if (testCase.httpsUpstreamProxy && testCase.cyProxy) {\n    process.env.HTTP_PROXY = process.env.HTTPS_PROXY = `https://localhost:${HTTPS_PROXY_PORT}`\n  } else {\n    delete process.env.HTTPS_PROXY\n    delete process.env.HTTP_PROXY\n  }\n\n  if (testCase.cyIntercept) {\n    cyServer._onDomainSet(urlUnderTest)\n  } else {\n    cyServer._onDomainSet('<root>')\n  }\n\n  let cmd = CHROME_PATH\n\n  debug('Launching Chrome: ', cmd, args.join(' '))\n\n  const proc = cp.spawn(cmd, args, {\n    stdio: 'ignore',\n  })\n\n  const storeHar = Promise.method((name, har) => {\n    const artifacts = process.env.CIRCLE_ARTIFACTS\n\n    if (artifacts) {\n      return fse.ensureDir(artifacts)\n      .then(() => {\n        const pathToFile = path.join(artifacts, sanitizeFilename(`${name}.har`))\n\n        debug('saving har to path:', pathToFile)\n\n        return fse.writeJson(pathToFile, har)\n      })\n    }\n  })\n\n  const runHar = () => {\n    // wait for Chrome to open, then start capturing\n    return Promise.delay(500).then(() => {\n      debug('Trying to connect to Chrome...')\n\n      const harCapturer = HarCapturer.run([\n        urlUnderTest,\n      ], {\n        port: cdpPort,\n        // disable SSL verification on older Chrome versions, copied from the HAR CLI\n        // https://github.com/cyrus-and/chrome-har-capturer/blob/587550508bddc23b7f4b4328c158322be4749298/bin/cli.js#L60\n        preHook: (_, cdp) => {\n          const { Security } = cdp\n\n          return Security.enable().then(() => {\n            return Security.setOverrideCertificateErrors({ override: true })\n          })\n          .then(() => {\n            return Security.certificateError(({ eventId }) => {\n              debug('EVENT ID', eventId)\n\n              return Security.handleCertificateError({ eventId, action: 'continue' })\n            })\n          })\n        },\n        // wait til all data is done before finishing\n        // https://github.com/cyrus-and/chrome-har-capturer/issues/59\n        postHook: (_, cdp) => {\n          let timeout\n\n          return new Promise((resolve) => {\n            cdp.on('event', (message) => {\n              if (message.method === 'Network.dataReceived') {\n                // reset timer\n                clearTimeout(timeout)\n                timeout = setTimeout(resolve, 1000)\n              }\n            })\n          })\n        },\n      })\n\n      return new Promise((resolve, reject) => {\n        harCapturer.on('fail', (_, err) => {\n          return reject(err)\n        })\n\n        harCapturer.on('har', resolve)\n      })\n      .then((har) => {\n        proc.kill(9)\n        debug('Received HAR from Chrome')\n        const results = getResultsFromHar(har)\n\n        _.merge(testCase, results)\n\n        return storeHar(testCase.name, har)\n        .return(results)\n      })\n      .catch({ code: 'ECONNREFUSED' }, (err) => {\n        // sometimes chrome takes surprisingly long, just reconn\n        debug('Chrome connection failed: ', err)\n\n        return runHar()\n      })\n    })\n  }\n\n  return runHar()\n}\n\nlet cyServer\n\ndescribe('Proxy Performance', function () {\n  this.timeout(60 * 1000)\n  this.retries(3)\n\n  beforeEach(function () {\n    process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'\n    nock.enableNetConnect()\n  })\n\n  before(function () {\n    return CA.create()\n    .then((ca) => {\n      return ca.generateServerCertificateKeys('localhost')\n    })\n    .spread((cert, key) => {\n      return Promise.join(\n        new DebuggingProxy().start(PROXY_PORT),\n\n        new DebuggingProxy({\n          https: { cert, key },\n        }).start(HTTPS_PROXY_PORT),\n\n        Config.set({\n          projectRoot: '/tmp/a',\n        }).then((config) => {\n          config.port = CY_PROXY_PORT\n\n          // turn off morgan\n          config.morgan = false\n\n          cyServer = new ServerE2E()\n\n          return cyServer.open(config)\n        }),\n      )\n    })\n  })\n\n  URLS_UNDER_TEST.map((urlUnderTest) => {\n    describe(urlUnderTest, function () {\n      let baseline\n      const testCases = _.cloneDeep(TEST_CASES)\n\n      before(function () {\n        // run baseline test\n        return runBrowserTest(urlUnderTest, testCases[0])\n        .then((runtime) => {\n          debug('baseline runtime is: ', runtime)\n\n          baseline = runtime\n        })\n      })\n\n      // slice(1) since first test is used as baseline above\n      testCases.slice(1).map((testCase) => {\n        let multiplier = 3\n\n        if (testCase.httpsUpstreamProxy) {\n          // there is extra slowdown when the HTTPS upstream is used, so slightly increase the multiplier\n          // maybe from higher CPU utilization with debugging-proxy and HTTPS\n          multiplier *= 1.5\n        }\n\n        it(`${testCase.name} loads 1000 images less than ${multiplier}x as slowly as Chrome`, function () {\n          debug('Current test: ', testCase.name)\n\n          return runBrowserTest(urlUnderTest, testCase)\n          .then((results) => {\n            expect(results['Total']).to.be.lessThan(multiplier * baseline['Total'])\n          })\n        })\n      })\n\n      after(() => {\n        debug(`Done in ${Math.round((new Date() / 1000) - start)}s`)\n        process.stdout.write('Note: All times are in milliseconds.\\n')\n\n        console.table(testCases)\n\n        return Promise.map(testCases, (testCase) => {\n          testCase['URL'] = urlUnderTest\n\n          return performance.track('Proxy Performance', testCase)\n        })\n      })\n    })\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/block_hosts_spec.js": "/* eslint-disable no-undef */\ndescribe('block hosts', () => {\n  it('forces blocked hosts to return 503', () => {\n    cy.visit('http://localhost:3232')\n\n    cy.window().then((win) => {\n      return new Promise((resolve) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.open('GET', 'http://localhost:3232/req')\n        xhr.setRequestHeader('Content-Type', 'text/plain')\n        xhr.send()\n        xhr.onload = () => resolve(xhr)\n      })\n    }).its('status').should('eq', 200)\n\n    cy.window().then((win) => {\n      return new Promise((resolve) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.open('GET', 'http://localhost:3131/req')\n        xhr.setRequestHeader('Content-Type', 'text/plain')\n        xhr.send()\n\n        // cross origin requests which return 503\n        // result in a zero status code\n        xhr.onerror = () => resolve(xhr)\n      })\n    }).its('status').should('eq', 0)\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/cache_clearing_spec.js": "/* eslint-disable\n    mocha/no-global-tests,\n    no-undef\n*/\nconst req = (win) => {\n  return new Promise((resolve, reject) => {\n    const xhr = new win.XMLHttpRequest()\n\n    xhr.open('GET', 'http://localhost:1515/cached/')\n    xhr.onload = () => {\n      return resolve(win)\n    }\n\n    xhr.onerror = reject\n\n    return xhr.send()\n  })\n}\n\nit('makes cached request', () => {\n  cy.visit('http://localhost:1515')\n  .then(req) // this creates the disk cache\n  .then(req)\n}) // this should not hit our server\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/cache_spec.js": "/* eslint-disable no-undef */\nconst send = (win) => {\n  return new Cypress.Promise((resolve) => {\n    const xhr = new win.XMLHttpRequest\n\n    xhr.open('GET', '/static/foo.js')\n    xhr.send()\n\n    xhr.onload = () => {\n      return resolve({\n        body: xhr.response,\n        etag: xhr.getResponseHeader('etag'),\n        cacheControl: xhr.getResponseHeader('cache-control'),\n      })\n    }\n  })\n}\n\ndescribe('caching', () => {\n  it('does not cache cy.visit file server requests', () => {\n    cy.request('POST', 'http://localhost:1515/write/hi')\n    cy.visit('/index.html?local')\n    cy.get('h1').should('contain', 'hi')\n    cy.request('POST', 'http://localhost:1515/write/hello')\n    cy.visit('/index.html?local')\n    cy.get('h1').should('contain', 'hello')\n  })\n\n  it('sets etags on file assets, but no cache-control', () => {\n    cy.writeFile('static/foo.js', 'alert(\\'hi\\')')\n    cy.visit('/index.html?local')\n    cy.window().then((win) => {\n      return send(win)\n    }).then((resp1) => {\n    // make sure our file server is not telling the browser\n    // to cache anything\n      expect(resp1.cacheControl).to.eq('public, max-age=0')\n\n      cy.window().then((win) => {\n        return send(win)\n      }).then((resp2) => {\n      // these responses should be identical\n        expect(resp1).to.deep.eq(resp2)\n\n        // now change our static files' content\n        cy.writeFile('static/foo.js', 'console.log(\\'bar\\')')\n        cy.window().then((win) => {\n          return send(win)\n        }).then((resp3) => {\n        // etags should now no longer match!\n          expect(resp1.etag).not.to.eq(resp3.etag)\n\n          // nor should bodies match\n          expect(resp1.body).not.to.eq(resp3.body)\n\n          // but cache control should\n          expect(resp1.cacheControl).to.eq(resp3.cacheControl)\n        })\n      })\n    })\n  })\n\n  it('does not cache cy.visit http server requests', () => {\n    // even though our server sends down cache headers\n    // we are explicitly turning them off in the proxy\n    // whenever we have to inject new content into the page\n    cy.request('POST', 'http://localhost:1515/write/hi')\n    cy.visit('http://localhost:1515/index.html?http')\n    cy.get('h1').should('contain', 'hi')\n    cy.request('POST', 'http://localhost:1515/write/foo')\n    cy.visit('http://localhost:1515/index.html?http')\n    cy.get('h1').should('contain', 'foo')\n  })\n\n  it('respects cache control headers from 3rd party http servers', () => {\n    cy.writeFile('static/foo.js', 'alert(\\'hi\\')')\n    cy.visit('http://localhost:1515/index.html?http')\n    cy.window().then((win) => {\n      return send(win)\n    }).then((resp1) => {\n    // we've set express.static to cache assets\n      expect(resp1.cacheControl).to.eq('public, max-age=3600')\n\n      cy.window().then((win) => {\n        return send(win)\n      }).then((resp2) => {\n        // these responses should be identical\n        expect(resp1).to.deep.eq(resp2)\n\n        // now change our static files' content\n        cy.writeFile('static/foo.js', 'console.log(\\'bar\\')')\n        cy.window().then((win) => {\n          return send(win)\n        }).then((resp3) => {\n          // but because of the cache-control headers\n          // our browser should NOT have made a\n          // new http request and therefore all of\n          // these should still match\n          expect(resp1).to.deep.eq(resp3)\n        })\n      })\n    })\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/form_submission_multipart_spec.js": "/* eslint-disable no-undef */\nconst { Blob, _ } = Cypress\n\nCypress.Commands.add('setFile', { prevSubject: 'element' }, (element, filePath) => {\n  const mimeTypes = {\n    jpeg: 'image/jpeg',\n    jpg: 'image/jpeg',\n    png: 'image/png',\n    pdf: 'application/pdf',\n  }\n\n  const filePathSplitted = filePath.split('.').pop()\n  const mimeType = mimeTypes[filePathSplitted] !== undefined ? mimeTypes[filePathSplitted] : null\n\n  const fixtureOrReadFile = function (filePath) {\n    if (_.startsWith(filePath, '/')) {\n      return cy.readFile(filePath, 'base64')\n    }\n\n    return cy.fixture(filePath, 'base64')\n  }\n\n  return fixtureOrReadFile(filePath).then((image) => {\n    return new Promise((resolve) => {\n      const blob = Blob.base64StringToBlob(image)\n      const elementNode = element[0]\n      const file = new File([blob], filePath, { type: mimeType })\n      const dataTransfer = new DataTransfer\n\n      dataTransfer.items.add(file)\n      elementNode.files = dataTransfer.files\n      const result = elementNode.dispatchEvent(new Event('change', { bubbles: true }))\n\n      return resolve(result)\n    })\n  })\n})\n\ndescribe('<form> submissions', () => {\n  it('can submit a form correctly', () => {\n    cy.visit('/')\n    cy.get('input[type=text]')\n    .type('hello world')\n\n    cy.get('input[type=submit]')\n    .click()\n\n    cy.document()\n    .contains('hello+world')\n  })\n\n  it('can submit a multipart/form-data form correctly', () => {\n    cy.visit('/multipart-form-data')\n    cy.get('input[type=text]')\n    .type('hello world')\n\n    cy.get('input[type=submit]')\n    .click()\n\n    cy.document()\n    .contains('hello world')\n  })\n\n  context('can submit a multipart/form-data form with attachments', () => {\n    const testUpload = (fixturePath, containsOpts = {}) => {\n      cy.visit(`/multipart-with-attachment?fixturePath=${fixturePath}`)\n      cy.get('input[type=file]')\n      .setFile(fixturePath)\n\n      cy.get('input[type=submit]')\n      .click()\n\n      cy.document()\n      .contains('files match', containsOpts)\n    }\n\n    it('image/png', () => {\n      testUpload('../../static/javascript-logo.png')\n    })\n\n    it('application/pdf', () => {\n      testUpload('sample.pdf')\n    })\n\n    it('image/jpeg', () => {\n      testUpload('sample.jpg')\n    })\n\n    // https://github.com/cypress-io/cypress/issues/4253\n    it('large application/pdf', () => {\n      testUpload('bigger-sample.pdf')\n    })\n\n    // https://github.com/cypress-io/cypress/issues/4240\n    it('large image/jpeg', () => {\n      testUpload(Cypress.env('PATH_TO_LARGE_IMAGE'), {\n        timeout: 120000,\n      })\n    })\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/https_passthru_spec.js": "describe('https passthru retries', () => {\n  it('retries when visiting a non-test domain', () => {\n    // cy.timeout(1e9)\n\n    return new Cypress.Promise((resolve, reject) => {\n      const img = new Image()\n\n      img.src = 'https://localhost:13372/javascript-logo.png'\n      img.onload = resolve\n      img.onerror = () => {\n        reject(new Error('onerror event fired, but should not have. expected onload to fire.'))\n      }\n    })\n  })\n\n  it('passes through the network error when it cannot connect to the proxy', () => {\n    // cy.timeout(1e9)\n\n    return new Cypress.Promise((resolve, reject) => {\n      const img = new Image()\n\n      img.src = 'https://localhost:13373/expected-network-error'\n      img.onload = () => {\n        reject(new Error('onload event fired, but should not have. expected onerror to fire.'))\n      }\n\n      img.onerror = resolve\n    })\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/iframe_spec.js": "/* eslint-disable no-undef */\nlet count = 0\nconst { action } = Cypress\n\nCypress.action = function (str) {\n  if (str === 'app:window:before:load') {\n    count += 1\n  }\n\n  return action.apply(this, arguments)\n}\n\nconst ensureWeCanTalkToTheIframe = function ($iframe) {\n  const h1 = $iframe.contents().find('h1')\n\n  expect(h1.length).to.eq(1)\n\n  expect($iframe.get(0).contentWindow.foo).to.eq('bar')\n\n  // onBeforeLoad should only be called once\n  // on the initial visit and not for the iframe\n  //\n  // the reason this number is still 1 instead of 2\n  // is that when we visit back to <root> cypress will\n  // reload this spec thus nuking the state\n  expect(count).to.eq(1)\n}\n\ndescribe('iframes', () => {\n  it('can snapshot iframes which arent loaded', () => {\n    // snapshotting after the click should insert\n    // an iframe which isnt yet loaded so when we\n    // snapshot the h1 we ensure it doesnt fail\n    cy.visit('http://www.foo.com:1616/insert_iframe')\n    cy.get('button').click()\n    cy.get('iframe')\n  })\n\n  it('can access nested iframes over http server', () => {\n    cy.visit('http://localhost:1616')\n    cy.get('iframe').then(ensureWeCanTalkToTheIframe)\n  })\n\n  it('can access iframes over file server', () => {\n    cy.visit('/outer.html')\n    cy.get('iframe').then(ensureWeCanTalkToTheIframe)\n  })\n\n  it('does not throw on cross origin iframes', () => {\n    cy.visit('http://www.foo.com:1616/cross')\n    cy.get('iframe')\n  })\n\n  it('continues to inject even on 5xx responses', () => {\n    cy.visit('http://localhost:1616/500')\n    cy.get('iframe').then(ensureWeCanTalkToTheIframe)\n  })\n\n  it('injects on file server 4xx errors', () => {\n    cy.visit('/outer_404.html')\n    cy.get('iframe').then(($iframe) => {\n      const br = $iframe.contents().find('br')\n\n      expect(br.length).to.eq(4)\n\n      expect(count).to.eq(1)\n    })\n\n    cy.get('a').click()\n    cy.get('body').then(($body) => {\n      expect($body).to.contain('Cypress errored trying to serve this file')\n      expect($body).to.contain('page/does-not-exist')\n\n      expect($body).to.contain('The file was not found.')\n    })\n  })\n\n  it('does not inject into xhrs', () => {\n    cy.visit('http://localhost:1616/')\n    cy.window().then((win) => {\n      return new Cypress.Promise((resolve) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.open('GET', '/iframe')\n        xhr.onload = () => {\n          return resolve(xhr.responseText)\n        }\n\n        return xhr.send()\n      })\n    }).then((response) => {\n      expect(response).not.to.include('document.domain')\n    })\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/images_spec.js": "/* eslint-disable no-undef */\ndescribe('images', () => {\n  it('can correctly load images when served from http server', () => {\n    cy.visit('http://localhost:3636')\n    cy.window().then((win) => {\n      return new Cypress.Promise((resolve, reject) => {\n        const img = new win.Image\n\n        img.onload = resolve\n        img.onerror = reject\n        img.src = '/static/javascript-logo.png'\n      })\n    })\n  })\n\n  it('can correctly load image when served from file system', () => {\n    cy.visit('/')\n    cy.window().then((win) => {\n      return new Cypress.Promise((resolve, reject) => {\n        const img = new win.Image\n\n        img.onload = resolve\n        img.onerror = reject\n        img.src = '/static/javascript-logo.png'\n      })\n    })\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/js_error_handling_failing_spec.js": "/* eslint-disable no-undef */\ndescribe('s1', () => {\n  context('without an afterEach hook', () => {\n    beforeEach(() => {\n      cy.server()\n      cy.visit('/js_errors.html')\n      cy.get('body')\n    })\n\n    // fail\n    it('t1', () => {\n      cy.get('.ref')\n      .click()\n      .should('have.class', 'active')\n    })\n\n    // fail\n    it('t2', () => {\n      cy.route(/foo/, 'foo html').as('getFoo')\n      cy.get('.xhr').click()\n      cy.wait('@getFoo')\n      cy.get('.xhr').should('have.class', 'active')\n    })\n\n    // pass\n    it('t3', () => {\n      cy.get('body')\n    })\n  })\n\n  context('with an afterEach hook', () => {\n    const runs = []\n\n    beforeEach(() => {\n      cy.server()\n      cy.visit('/js_errors.html')\n      cy.get('body')\n    })\n\n    afterEach(() => {\n      cy.wrap({}).then(() => {\n        runs.push(true)\n      })\n    })\n\n    // fail\n    it('t4', () => {\n      cy.get('.ref')\n      .click()\n      .should('have.class', 'active')\n    })\n\n    // fail\n    it('t5', () => {\n      cy.then(() => {\n        throw new Error('baz')\n      })\n    })\n\n    // pass\n    it('t6', () => {\n      // should have runs two afterEach's\n      expect(runs).to.have.length(2)\n    })\n  })\n\n  context('cross origin script errors', () => {\n    // fail\n    it('explains where script errored', () => {\n      cy.visit('/cross_origin_script.html')\n      .then(() => {\n        throw new Error('should have failed but did not')\n      })\n    })\n  })\n\n  context('bad gzipped content', () => {\n    it('destroys the request socket', () => {\n      cy.visit('http://localhost:1123/index.html')\n      .then((win) => {\n        return new Cypress.Promise((resolve) => {\n          const script = win.document.createElement('script')\n\n          script.src = '/gzip-bad.js'\n          script.onerror = resolve\n\n          return win.document.body.appendChild(script)\n        })\n      })\n    })\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/proxying_spec.js": "describe('proxying', () => {\n  // load a script that has obstructive code and would otherwise be modified by the proxy\n  // https://github.com/cypress-io/cypress/issues/8983\n  it('does not fail integrity check for cross-origin scripts', () => {\n    cy.visit('/index.html')\n    .then((win) => {\n      /**\n       * @type {Document}\n       */\n      const document = win.document\n      const script = document.createElement('script')\n\n      script.src = 'https://localhost:7878/static/simple_obstructive_code.js'\n      script.integrity = 'sha256-iVKZPZrzbe7YNdMKYWJ1+f74j5lD3gRFvGjqtLyji6A='\n      script.crossOrigin = 'anonymous'\n      document.head.append(script)\n\n      return new Promise((resolve, reject) => {\n        script.onload = resolve\n        script.onerror = () => reject(new Error('script failed to load, check the console. Possibly a failed integrity check'))\n      })\n    })\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/server_sent_events_spec.js": "/* eslint-disable no-undef */\nconst urlErrors = (win, url) => {\n  return new Promise((resolve, reject) => {\n    const es = new win.EventSource(url)\n\n    es.onerror = function (err) {\n      es.close()\n\n      return resolve()\n    }\n\n    es.onopen = (evt) => {\n      return reject(`event source connection should not have opened for url: ${url}`)\n    }\n  })\n}\n\ndescribe('server sent events', () => {\n  beforeEach(() => {\n    cy.visit('http://localhost:3038/foo')\n  })\n\n  it('does not crash', () => {\n    cy.window().then({ timeout: 15000 }, (win) => {\n      return Cypress.Promise.all([\n        urlErrors(win, 'http://localhost:3038/sse'),\n        urlErrors(win, 'https://localhost:3040/sse'),\n      ])\n    })\n\n    cy.log('should be able to receive server sent events')\n    cy.window()\n    .then((win) => {\n      return new Promise((resolve, reject) => {\n        const received = []\n\n        const es = new win.EventSource('http://127.0.0.1:3039/sse')\n\n        es.onmessage = function (evt) {\n          received.push(evt.data)\n\n          if (evt.data === '5') {\n            es.close()\n\n            return resolve(received)\n          }\n        }\n\n        es.onerror = reject\n      })\n    }).should('deep.eq', ['1', '2', '3', '4', '5'])\n  })\n\n  it('aborts proxied connections to prevent client connection buildup', () => {\n    // there shouldn't be any leftover connections either\n    cy.request('http://localhost:3038/clients')\n    .its('body').should('deep.eq', { clients: 0 })\n\n    cy.window()\n    .then((win) => {\n      return new Promise((resolve, reject) => {\n        const es = new win.EventSource('http://127.0.0.1:3039/sse')\n\n        es.onopen = (evt) => {\n          return resolve(es)\n        }\n\n        es.onerror = reject\n      })\n    }).then((es) => {\n      cy.request('http://localhost:3038/clients')\n      .its('body').should('deep.eq', { clients: 1 })\n      .then(() => {\n        es.close()\n      })\n\n      cy.wait(100)\n      .then(() => {\n        cy.request('http://localhost:3038/clients')\n        .its('body').should('deep.eq', { clients: 0 })\n      })\n    })\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/subdomain_spec.js": "/* eslint-disable\n    @cypress/dev/skip-comment,\n    no-undef,\n*/\ndescribe('subdomains', () => {\n  beforeEach(() => {\n    cy.visit('http://www.foobar.com:2292')\n  })\n\n  it('can swap to help.foobar.com:2292', () => {\n    cy.get('a').click()\n    cy.get('h1').should('contain', 'Help')\n  })\n\n  it('can directly visit a subdomain in another test', () => {\n    cy.visit('http://help.foobar.com:2292')\n    cy.get('h1').should('contain', 'Help')\n    cy.document().then((document) => {\n    // set cookies that are just on this subdomain\n    // and cookies on the superdomain\n    // and then regular cookies too\n      document.cookie = 'help=true; domain=help.foobar.com'\n      document.cookie = 'asdf=asdf; domain=foobar.com'\n      document.cookie = 'foo=bar'\n    })\n\n    cy.getCookies().then((cookies) => {\n      expect(cookies.length).to.eq(3)\n    })\n  })\n\n  it('issue: #207: does not duplicate or hostOnly cookies as a domain cookie', () => {\n    cy.visit('http://session.foobar.com:2292')\n    cy.getCookies().should('have.length', 1)\n    cy.window().then((win) => {\n      return new Cypress.Promise((resolve) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.open('GET', '/cookies')\n        xhr.send()\n        xhr.onload = () => {\n          return resolve(JSON.parse(xhr.response).cookie)\n        }\n      })\n    }).then((cookie) => {\n    // there should have been only a single secret-session\n    // request cookie sent on this XHR request\n      const occurences = Cypress._.compact(cookie.split('secret-session'))\n\n      expect(occurences).to.have.length(1)\n    })\n  })\n\n  it('correctly sets domain based cookies', () => {\n    cy.visit('http://domain.foobar.com:2292')\n    cy.getCookies().should('have.length', 1)\n    cy.getCookie('nomnom').should('include', {\n      domain: '.foobar.com',\n      name: 'nomnom',\n      value: 'good',\n      path: '/',\n      secure: false,\n      httpOnly: false,\n    })\n\n    cy.window().then((win) => {\n      return new Cypress.Promise((resolve) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.withCredentials = true\n        xhr.open('GET', 'http://www.foobar.com:2292/cookies')\n        xhr.send()\n        xhr.onload = () => {\n          return resolve(JSON.parse(xhr.response).cookie)\n        }\n      })\n    }).then((cookie) => {\n      // only a single nomnom cookie should have been sent\n      // since we set a domain cookie that matches this request\n      expect(cookie).to.eq('nomnom=good')\n    })\n  })\n\n  it.skip('issue #362: do not set domain based (non hostOnly) cookies by default', () => {\n    cy.setCookie('foobar', '1', {\n      domain: 'subdomain.foobar.com',\n    })\n\n    // send a request to localhost but get\n    // redirected back to foobar\n    cy.request('http://localhost:2292/redirect')\n    .its('body.cookie')\n    .should('not.exist')\n  })\n\n  it.skip('sets a hostOnly cookie by default', () => {\n    // this should set a hostOnly cookie for\n    // www.foobar.com\n    cy.setCookie('foobar', '1')\n\n    cy.request('http://domain.foobar.com:2292/cookies')\n    .its('body.cookie')\n    .should('not.exist')\n  })\n\n  it('issue #361: incorrect cookie synchronization between cy.request redirects', () => {\n    // start with a cookie on foobar\n    cy.setCookie('foobar', '1')\n\n    // send a request to localhost but get\n    // redirected back to foobar\n    cy.request('http://localhost:2292/redirect')\n    .its('body.cookie')\n    .should('eq', 'foobar=1')\n  })\n\n  it('issue #362: incorrect cookie synchronization between cy.visit redirects', () => {\n    // start with a cookie on foobar specifically for www\n    cy.setCookie('foobar', '1', { domain: 'www.foobar.com' })\n\n    // send a request to domain.foobar but get\n    // redirected back to www.foobar.com\n    cy.visit('http://domain.foobar.com:2292/domainRedirect')\n    cy.get('#cookie')\n    .should('have.text', 'foobar=1')\n  })\n\n  it('issue #600 can visit between nested subdomains', () => {\n    cy.visit('http://qa.sub.foobar.com:2292')\n    cy.contains('Nested Subdomains')\n    cy.visit('http://staging.sub.foobar.com:2292')\n    cy.contains('Nested Subdomains')\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/uncaught_during_test_spec.js": "/* eslint-disable\n    mocha/handle-done-callback,\n    no-undef,\n*/\ndescribe('foo', () => {\n  it('fails with setTimeout', () => {\n    setTimeout(() => {\n      return foo.bar()\n    }\n    , 10)\n\n    cy.wait(1000)\n  })\n\n  it('fails with setTimeout and done', (done) => {\n    setTimeout(() => {\n      return foo.bar()\n    })\n  })\n\n  it('passes with fail handler after failing with setTimeout', (done) => {\n    cy.on('fail', (err) => {\n      expect(err.message).to.include('foo is not defined')\n\n      setTimeout(() => {\n        return done()\n      })\n\n      return false\n    })\n\n    setTimeout(() => {\n      return foo.bar()\n    })\n  })\n\n  it('fails with async app code error', () => {\n    cy.visit('/js_errors.html')\n    cy.get('.async-error').click()\n\n    cy.wait(10000)\n  })\n\n  it('passes with fail handler after failing with async app code error', (done) => {\n    cy.on('fail', (err) => {\n      expect(err.message).to.include('qax is not defined')\n      expect(err.stack).to.include('qax is not defined')\n\n      setTimeout(() => {\n        return done()\n      })\n\n      return false\n    })\n\n    cy.visit('/js_errors.html')\n    cy.get('.async-error').click()\n\n    cy.wait(10000)\n  })\n\n  // FIXME: Currently times out but doesn't display the error\n  it.skip('fails with promise', () => {\n    setTimeout(() => {\n      return foo.bar()\n    })\n\n    return new Promise(() => {})\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/websockets_spec.js": "/* eslint-disable no-undef */\nconst shouldCloseUrlWithCode = (win, url, code) => {\n  return new Promise((resolve, reject) => {\n    const ws = new win.WebSocket(url)\n\n    // ws.onerror = (err) ->\n    // debugger\n\n    ws.onclose = function (evt) {\n      if (evt.code === code) {\n        return resolve()\n      }\n\n      return reject(new Error(`websocket connection should have been closed with code ${code} for url: ${url} but was instead closed with code: ${evt.code}`))\n    }\n\n    ws.onopen = (evt) => {\n      return reject(new Error(`websocket connection should not have opened for url: ${url}`))\n    }\n  })\n}\n\ndescribe('websockets', () => {\n  it('does not crash', () => {\n    cy.visit('http://localhost:3038/foo')\n    cy.log('should not crash on ECONNRESET websocket upgrade')\n    cy.window().then((win) => {\n      // see https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n      return Cypress.Promise.all([\n        shouldCloseUrlWithCode(win, 'ws://localhost:3038/websocket', 1006),\n        shouldCloseUrlWithCode(win, 'wss://localhost:3040/websocket', 1006),\n      ])\n    })\n\n    cy.log('should be able to send websocket messages')\n\n    cy.window()\n    .then((win) => {\n      return new Promise((resolve, reject) => {\n        const ws = new win.WebSocket('ws://localhost:3039/')\n\n        ws.onmessage = (evt) => {\n          return resolve(evt.data)\n        }\n\n        ws.onerror = () => {\n          return reject(new Error('connection failed, check console for error'))\n        }\n\n        ws.onopen = () => {\n          return ws.send('foo')\n        }\n      })\n    }).should('eq', 'foobar')\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/e2e/cypress/integration/xhr_spec.js": "/* eslint-disable no-undef */\ndescribe('xhrs', () => {\n  it('can encode + decode headers', () => {\n    const getResp = () => {\n      return {\n        'test': 'We’ll',\n      }\n    }\n\n    cy.server()\n    cy.route(/api/, getResp()).as('getApi')\n    cy.visit('/index.html')\n    cy.window().then((win) => {\n      const xhr = new win.XMLHttpRequest\n\n      xhr.open('GET', '/api/v1/foo/bar?a=42')\n\n      xhr.send()\n    })\n\n    cy.wait('@getApi')\n    .its('url').should('include', 'api/v1')\n  })\n\n  it('ensures that request headers + body go out and reach the server unscathed', () => {\n    cy.visit('http://localhost:1919')\n    cy.window().then((win) => {\n      return new Cypress.Promise((resolve) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.open('POST', '/login')\n        xhr.setRequestHeader('Content-Type', 'application/json')\n        xhr.setRequestHeader('X-CSRF-Token', 'abc-123')\n        xhr.send(JSON.stringify({ foo: 'bar' }))\n        xhr.onload = () => {\n          return resolve(JSON.parse(xhr.response))\n        }\n      })\n    }).then((resp) => {\n    // the server sends us back response JSON\n    // with the request details so we can verify\n    // that the backend server received exactly what we sent\n    // and the Cypress proxy did not modify this in any way\n      expect(resp.body).to.deep.eq({ foo: 'bar' })\n      expect(resp.headers).to.have.property('x-csrf-token', 'abc-123')\n\n      expect(resp.headers).to.have.property('content-type', 'application/json')\n    })\n  })\n\n  it('does not inject into json\\'s contents from http server even requesting text/html', () => {\n    cy.visit('http://localhost:1919')\n    cy.window().then((win) => {\n      return new Cypress.Promise((resolve) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.open('POST', '/html')\n        xhr.setRequestHeader('Content-Type', 'text/html')\n        xhr.setRequestHeader('Accept', 'text/html')\n        xhr.send(JSON.stringify({ content: '<html>content</html>' }))\n        xhr.onload = () => {\n          return resolve(JSON.parse(xhr.response))\n        }\n      })\n    }).then((resp) => {\n      // even though our request is requesting text/html\n      // the server sends us back json and the proxy will\n      // not inject into json\n      expect(resp).to.deep.eq({ content: '<html>content</html>' })\n    })\n  })\n\n  it('does not inject into json\\'s contents from file server even requesting text/html', () => {\n    cy.visit('/')\n    cy.window().then((win) => {\n      return new Cypress.Promise((resolve) => {\n        const xhr = new win.XMLHttpRequest\n\n        xhr.open('GET', '/static/content.json')\n        xhr.setRequestHeader('Content-Type', 'text/html')\n        xhr.setRequestHeader('Accept', 'text/html')\n        xhr.send()\n        xhr.onload = () => {\n          return resolve(JSON.parse(xhr.response))\n        }\n      })\n    }).then((resp) => {\n      // even though our request is requesting text/html\n      // the fil server sends us back json and the proxy will\n      // not inject into json\n      expect(resp).to.deep.eq({ content: '<html>content</html>' })\n    })\n  })\n\n  it('works prior to visit', () => {\n    cy.server()\n  })\n\n  // https://github.com/cypress-io/cypress/issues/5431\n  it('can stub a 100kb response', (done) => {\n    const body = 'X'.repeat(100 * 1024)\n\n    cy.server()\n    cy.route({\n      method: 'POST',\n      url: '/foo',\n      response: {\n        'bar': body,\n      },\n    })\n\n    cy.visit('/index.html')\n    .then((win) => {\n      const xhr = new win.XMLHttpRequest\n\n      xhr.open('POST', '/foo')\n      xhr.send()\n\n      const finish = function () {\n        expect(xhr.status).to.eq(200)\n        expect(xhr.responseText).to.include(body)\n\n        return done()\n      }\n\n      xhr.onload = finish\n      xhr.onerror = finish\n    })\n  })\n\n  describe('server with 1 visit', () => {\n    before(() => {\n      cy.visit('/xhr.html')\n    })\n\n    beforeEach(() => {\n      cy.server()\n      cy.route(/users/, [{}, {}]).as('getUsers')\n    })\n\n    it('response body', () => {\n      cy.get('#fetch').click()\n      cy.wait('@getUsers').then((xhr) => {\n        expect(xhr.url).to.include('/users')\n\n        expect(xhr.responseBody).to.deep.eq([{}, {}])\n      })\n    })\n\n    it('request body', () => {\n      cy.route('POST', /users/, { name: 'b' }).as('createUser')\n      cy.get('#create').click()\n      cy.wait('@createUser').its('requestBody')\n      .should('deep.eq', { some: 'data' })\n    })\n\n    it('aborts', () => {\n      cy.window()\n      .then((win) => {\n        cy.route({\n          method: 'POST',\n          url: /users/,\n          response: { name: 'b' },\n          delay: 2000,\n        }).as('createUser')\n\n        cy.get('#create').click().then(() => {\n          return win.location.href = '/index.html'\n        })\n\n        cy.wait('@createUser').its('canceled').should('be.true')\n      })\n    })\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/plugins-async-error/cypress/plugins/index.js": "module.exports = (on) => {\n  on('file:preprocessor', () => {\n    return new Promise(() => {\n      setTimeout(() => {\n        throw new Error('Async error from plugins file')\n      }, 50)\n    })\n  })\n}\n",
    "packages/server/test/support/fixtures/projects/remote-debugging-disconnect/cypress/plugins.js": "const la = require('lazy-ass')\nconst net = require('net')\n\nconst realPort = process.env.CYPRESS_REMOTE_DEBUGGING_PORT\nconst fakePort = 17171\n\nlet currentConnectionCount = 0\nlet totalConnectionCount = 0\n\nlet server\n\n// this is a transparent TCP proxy for Chrome's debugging port\n// it can kill all existing connections or shut the port down independently of Chrome or Cypress\nconst startTcpProxy = () => {\n  return new Promise((resolve, reject) => {\n    server = net.createServer((socket) => {\n      const { remotePort } = socket\n\n      console.error('received connection from ', { remotePort })\n\n      const upstreamSocket = net.connect(fakePort, () => {\n        console.error('hooked to upstream', { remotePort })\n\n        totalConnectionCount++\n        currentConnectionCount++\n\n        server.on('kill-active-connections', () => {\n          console.error('destroying', { remotePort })\n          socket.destroy()\n        })\n\n        socket.on('close', () => {\n          currentConnectionCount--\n        })\n\n        socket.pipe(upstreamSocket)\n        upstreamSocket.pipe(socket)\n      })\n\n      upstreamSocket.on('error', (err) => {\n        console.error('error on upstream', { remotePort })\n        socket.destroy()\n      })\n    })\n\n    server.listen(realPort, resolve)\n    server.on('error', reject)\n  })\n}\n\nmodule.exports = (on) => {\n  on('before:browser:launch', (browser = {}, options) => {\n    la(browser.family === 'chromium', 'this test can only be run with a chromium-family browser')\n\n    // set debugging port to go through our lil TCP proxy\n    const newArgs = options.args.filter((arg) => !arg.startsWith('--remote-debugging-port='))\n\n    newArgs.push(`--remote-debugging-port=${fakePort}`)\n\n    la(newArgs.length === options.args.length, 'arg list length should stay the same length')\n\n    options.args = newArgs\n\n    return startTcpProxy()\n    .then(() => {\n      return options\n    })\n  })\n\n  on('task', {\n    'get:stats' () {\n      return {\n        currentConnectionCount,\n        totalConnectionCount,\n      }\n    },\n    'kill:active:connections' () {\n      server.emit('kill-active-connections')\n\n      return null\n    },\n    'destroy:server' () {\n      console.error('closing server')\n      server.close()\n\n      return null\n    },\n  })\n}\n",
    "packages/server/test/support/helpers/serverStub.ts": "import _ from 'lodash'\nimport Bluebird from 'bluebird'\nimport bodyParser from 'body-parser'\nimport { api as jsonSchemas } from '@cypress/json-schemas'\nimport e2e from './e2e'\n\nexport const postRunResponseWithWarnings = jsonSchemas.getExample('postRunResponse')('2.2.0')\n\nexport const postRunInstanceResponse = jsonSchemas.getExample('postRunInstanceResponse')('2.1.0')\n\nexport const postInstanceTestsResponse = jsonSchemas.getExample('postInstanceTestsResponse')('1.0.0')\n\npostInstanceTestsResponse.actions = []\nexport const postRunResponse = _.assign({}, postRunResponseWithWarnings, { warnings: [] })\n\ntype DeepPartial<T> = {\n  [P in keyof T]?: DeepPartial<T[P]>;\n};\nconst sendUploadUrls = function (req, res) {\n  const { body } = req\n\n  let num = 0\n\n  const json = {} as any\n\n  if (body.video) {\n    json.videoUploadUrl = 'http://localhost:1234/videos/video.mp4'\n  }\n\n  const screenshotUploadUrls = _.map(body.screenshots, (s) => {\n    num += 1\n\n    return {\n      screenshotId: s.screenshotId,\n      uploadUrl: `http://localhost:1234/screenshots/${num}.png`,\n    }\n  })\n\n  json.screenshotUploadUrls = screenshotUploadUrls\n\n  return res.json(json)\n}\nconst mockServerState = {\n  requests: [],\n  setSpecs (req) {\n    mockServerState.specs = [...req.body.specs]\n    mockServerState.allSpecs = [...req.body.specs]\n  },\n  allSpecs: [],\n  specs: [],\n}\n\nconst routeHandlers = {\n  postRun: {\n    method: 'post',\n    url: '/runs',\n    req: 'postRunRequest@2.4.0',\n    resSchema: 'postRunResponse@2.2.0',\n    res: (req, res) => {\n      if (!req.body.specs) {\n        throw new Error('expected for Test Runner to post specs')\n      }\n\n      mockServerState.setSpecs(req)\n\n      return res.json(postRunResponse)\n    },\n  },\n  postRunInstance: {\n    method: 'post',\n    url: '/runs/:id/instances',\n    req: 'postRunInstanceRequest@2.1.0',\n    resSchema: 'postRunInstanceResponse@2.1.0',\n    res: (req, res) => {\n      console.log(mockServerState.allSpecs.length, mockServerState.specs.length)\n      const response = {\n        ...postRunInstanceResponse,\n        spec: mockServerState.specs.shift() || null,\n        claimedInstances: mockServerState.allSpecs.length - mockServerState.specs.length,\n        totalInstances: mockServerState.allSpecs.length,\n      }\n\n      console.log('response', response)\n\n      return res.json(response)\n    },\n  },\n  postInstanceTests: {\n    method: 'post',\n    url: '/instances/:id/tests',\n    req: 'postInstanceTestsRequest@1.0.0',\n    resSchema: 'postInstanceTestsResponse@1.0.0',\n    res: postInstanceTestsResponse,\n  },\n  postInstanceResults: {\n    method: 'post',\n    url: '/instances/:id/results',\n    req: 'postInstanceResultsRequest@1.1.0',\n    resSchema: 'postInstanceResultsResponse@1.0.0',\n    res: sendUploadUrls,\n  },\n  putInstanceStdout: {\n    method: 'put',\n    url: '/instances/:id/stdout',\n    req: 'putInstanceStdoutRequest@1.0.0',\n    res (req, res) {\n      return res.sendStatus(200)\n    },\n  },\n  putVideo: {\n    method: 'put',\n    url: '/videos/:name',\n    res (req, res) {\n      return res.sendStatus(200)\n    },\n  },\n  putScreenshots: {\n    method: 'put',\n    url: '/screenshots/:name',\n    res (req, res) {\n      return Bluebird.delay(300)\n      .then(() => {\n        return res.sendStatus(200)\n      })\n    },\n  },\n\n}\n\nexport const createRoutes = (props: DeepPartial<typeof routeHandlers>) => {\n  return _.values(_.merge(_.cloneDeep(routeHandlers), props))\n}\n\nbeforeEach(() => {\n  mockServerState.requests.length = 0\n  mockServerState.specs.length = 0\n  mockServerState.allSpecs.length = 0\n})\n\nexport const getRequestUrls = () => {\n  return _.map(mockServerState.requests, 'url')\n}\n\nexport const getRequests = () => {\n  return mockServerState.requests\n}\n\nconst getSchemaErr = (tag, err, schema) => {\n  return {\n    errors: err.errors,\n    object: err.object,\n    example: err.example,\n    message: `${tag} should follow ${schema} schema`,\n  }\n}\n\nconst getResponse = function (responseSchema) {\n  if (!responseSchema) {\n    throw new Error('No response schema supplied')\n  }\n\n  if (_.isObject(responseSchema)) {\n    return responseSchema\n  }\n\n  const [name, version] = responseSchema.split('@')\n\n  return jsonSchemas.getExample(name)(version)\n}\n\nconst sendResponse = function (req, res, responseBody) {\n  return new Promise((resolve) => {\n    const _writeRaw = res._writeRaw\n\n    res._writeRaw = function () {\n      resolve()\n\n      return _writeRaw.apply(this, arguments)\n    }\n\n    if (_.isFunction(responseBody)) {\n      return responseBody(req, res)\n    }\n\n    res.json(getResponse(responseBody))\n    resolve()\n  })\n}\n\nconst ensureSchema = function (expectedRequestSchema, responseBody, expectedResponseSchema) {\n  let reqName; let reqVersion\n\n  if (expectedRequestSchema) {\n    [reqName, reqVersion] = expectedRequestSchema.split('@')\n  }\n\n  return async function (req, res) {\n    const { body } = req\n\n    try {\n      if (expectedRequestSchema) {\n        jsonSchemas.assertSchema(reqName, reqVersion)(body)\n      }\n\n      res.expectedResponseSchema = expectedResponseSchema\n\n      await sendResponse(req, res, responseBody)\n\n      const key = [req.method, req.url].join(' ')\n\n      mockServerState.requests.push({\n        url: key,\n        body,\n      })\n    } catch (err) {\n      console.log('Schema Error:', err.message)\n\n      return res.status(412).json(getSchemaErr('request', err, expectedRequestSchema))\n    }\n  }\n}\n\nconst assertResponseBodySchema = function (req, res, next) {\n  const oldWrite = res.write\n  const oldEnd = res.end\n\n  const chunks = []\n\n  res.write = (chunk) => {\n    // buffer the response, we'll really write it on end\n    return chunks.push(chunk)\n  }\n\n  res.end = function (chunk) {\n    if (chunk) {\n      chunks.push(chunk)\n    }\n\n    res.write = oldWrite\n    res.end = oldEnd\n\n    if (res.expectedResponseSchema && _.inRange(res.statusCode, 200, 299)) {\n      const body = JSON.parse(Buffer.concat(chunks).toString('utf8'))\n\n      const [resName, resVersion] = res.expectedResponseSchema.split('@')\n\n      try {\n        jsonSchemas.assertSchema(resName, resVersion)(body)\n      } catch (err) {\n        console.log('Schema Error:', err.message)\n\n        return res.status(412).json(getSchemaErr('response', err, res.expectedResponseSchema))\n      }\n    }\n\n    chunks.map((chunk) => {\n      return res.write(chunk)\n    })\n\n    return res.end()\n  }\n\n  return next()\n}\n\nconst onServer = (routes) => {\n  return (function (app) {\n    app.use(bodyParser.json())\n\n    app.use(assertResponseBodySchema)\n\n    return _.each(routes, (route) => {\n      return app[route.method](route.url, ensureSchema(\n        route.req,\n        route.res,\n        route.resSchema,\n      ))\n    })\n  })\n}\n\nexport const setupStubbedServer = (routes, settings = {}) => {\n  e2e.setup({\n    settings: _.extend({\n      projectId: 'pid123',\n      videoUploadOnPasses: false,\n    }, settings),\n    servers: [{\n      port: 1234,\n      onServer: onServer(routes),\n    }, {\n      port: 3131,\n      static: true,\n    }],\n  })\n\n  return mockServerState\n}\n",
    "packages/server/test/unit/request_spec.js": "require('../spec_helper')\n\nconst _ = require('lodash')\nconst http = require('http')\nconst Bluebird = require('bluebird')\nconst Request = require(`${root}lib/request`)\nconst snapshot = require('snap-shot-it')\n\nconst request = Request({ timeout: 100 })\n\nconst testAttachingCookiesWith = function (fn) {\n  const set = sinon.spy(request, 'setCookiesOnBrowser')\n  const get = sinon.spy(request, 'setRequestCookieHeader')\n\n  nock('http://localhost:1234')\n  .get('/')\n  .reply(302, '', {\n    'set-cookie': 'one=1',\n    location: '/second',\n  })\n  .get('/second')\n  .reply(302, '', {\n    'set-cookie': 'two=2',\n    location: '/third',\n  })\n  .get('/third')\n  .reply(200, '', {\n    'set-cookie': 'three=3',\n  })\n\n  return fn()\n  .then(() => {\n    return snapshot({\n      setCalls: set.getCalls().map((call) => {\n        return {\n          currentUrl: call.args[1],\n          setCookie: call.args[0].headers['set-cookie'],\n        }\n      }),\n      getCalls: get.getCalls().map((call) => {\n        return {\n          newUrl: _.get(call, 'args.1'),\n        }\n      }),\n    })\n  })\n}\n\ndescribe('lib/request', () => {\n  beforeEach(function () {\n    this.fn = sinon.stub()\n    this.fn.withArgs('set:cookie').resolves({})\n    this.fn.withArgs('get:cookies').resolves([])\n  })\n\n  it('is defined', () => {\n    expect(request).to.be.an('object')\n  })\n\n  context('#getDelayForRetry', () => {\n    it('divides by 10 when delay >= 1000 and err.code = ECONNREFUSED', () => {\n      const retryIntervals = [1, 2, 3, 4]\n      const delaysRemaining = [0, 999, 1000, 2000]\n\n      const err = {\n        code: 'ECONNREFUSED',\n      }\n\n      const onNext = sinon.stub()\n\n      retryIntervals.forEach(() => {\n        return request.getDelayForRetry({\n          err,\n          onNext,\n          retryIntervals,\n          delaysRemaining,\n        })\n      })\n\n      expect(delaysRemaining).to.be.empty\n\n      expect(onNext.args).to.deep.eq([\n        [0, 1],\n        [999, 2],\n        [100, 3],\n        [200, 4],\n      ])\n    })\n\n    it('does not divide by 10 when err.code != ECONNREFUSED', () => {\n      const retryIntervals = [1, 2, 3, 4]\n      const delaysRemaining = [2000, 2000, 2000, 2000]\n\n      const err = {\n        code: 'ECONNRESET',\n      }\n\n      const onNext = sinon.stub()\n\n      request.getDelayForRetry({\n        err,\n        onNext,\n        retryIntervals,\n        delaysRemaining,\n      })\n\n      expect(delaysRemaining).to.have.length(3)\n\n      expect(onNext).to.be.calledWith(2000, 1)\n    })\n\n    it('calls onElse when delaysRemaining is exhausted', () => {\n      const retryIntervals = [1, 2, 3, 4]\n      const delaysRemaining = []\n\n      const onNext = sinon.stub()\n      const onElse = sinon.stub()\n\n      request.getDelayForRetry({\n        onElse,\n        onNext,\n        retryIntervals,\n        delaysRemaining,\n      })\n\n      expect(onElse).to.be.calledWithExactly()\n\n      expect(onNext).not.to.be.called\n    })\n  })\n\n  context('#setDefaults', () => {\n    it('delaysRemaining to retryIntervals clone', () => {\n      const retryIntervals = [1, 2, 3, 4]\n\n      const opts = request.setDefaults({ retryIntervals })\n\n      expect(opts.retryIntervals).to.eq(retryIntervals)\n      expect(opts.delaysRemaining).not.to.eq(retryIntervals)\n\n      expect(opts.delaysRemaining).to.deep.eq(retryIntervals)\n    })\n\n    it('retryIntervals to [0, 1000, 2000, 2000] by default', () => {\n      const opts = request.setDefaults({})\n\n      expect(opts.retryIntervals).to.deep.eq([0, 1000, 2000, 2000])\n    })\n\n    it('delaysRemaining can be overridden', () => {\n      const delaysRemaining = [1]\n      const opts = request.setDefaults({ delaysRemaining })\n\n      expect(opts.delaysRemaining).to.eq(delaysRemaining)\n    })\n  })\n\n  context('#normalizeResponse', () => {\n    beforeEach(function () {\n      this.push = sinon.stub()\n    })\n\n    it('sets status to statusCode and deletes statusCode', function () {\n      expect(request.normalizeResponse(this.push, {\n        statusCode: 404,\n        request: {\n          headers: { foo: 'bar' },\n          body: 'body',\n        },\n      })).to.deep.eq({\n        status: 404,\n        statusText: 'Not Found',\n        isOkStatusCode: false,\n        requestHeaders: { foo: 'bar' },\n        requestBody: 'body',\n      })\n\n      expect(this.push).to.be.calledOnce\n    })\n\n    it('picks out status body and headers', function () {\n      expect(request.normalizeResponse(this.push, {\n        foo: 'bar',\n        req: {},\n        originalHeaders: {},\n        headers: { 'Content-Length': 50 },\n        body: '<html>foo</html>',\n        statusCode: 200,\n        request: {\n          headers: { foo: 'bar' },\n          body: 'body',\n        },\n      })).to.deep.eq({\n        body: '<html>foo</html>',\n        headers: { 'Content-Length': 50 },\n        status: 200,\n        statusText: 'OK',\n        isOkStatusCode: true,\n        requestHeaders: { foo: 'bar' },\n        requestBody: 'body',\n      })\n\n      expect(this.push).to.be.calledOnce\n    })\n  })\n\n  context('#create', () => {\n    beforeEach(function (done) {\n      this.hits = 0\n\n      this.srv = http.createServer((req, res) => {\n        this.hits++\n\n        switch (req.url) {\n          case '/never-ends':\n            res.writeHead(200)\n\n            return res.write('foo\\n')\n          case '/econnreset':\n            return req.socket.destroy()\n          default:\n            break\n        }\n      })\n\n      this.srv.listen(9988, done)\n    })\n\n    afterEach(function () {\n      return this.srv.close()\n    })\n\n    context('retries for streams', () => {\n      it('does not retry on a timeout', () => {\n        const opts = request.setDefaults({\n          url: 'http://localhost:9988/never-ends',\n          timeout: 1000,\n        })\n\n        const stream = request.create(opts)\n\n        let retries = 0\n\n        stream.on('retry', () => {\n          retries++\n        })\n\n        const p = Bluebird.fromCallback((cb) => {\n          stream.on('error', cb)\n        })\n\n        return expect(p).to.be.rejected\n        .then((err) => {\n          expect(err.code).to.eq('ESOCKETTIMEDOUT')\n\n          expect(retries).to.eq(0)\n        })\n      })\n\n      it('retries 4x on a connection reset', () => {\n        const opts = {\n          url: 'http://localhost:9988/econnreset',\n          retryIntervals: [0, 1, 2, 3],\n          timeout: 1000,\n        }\n\n        const stream = request.create(opts)\n\n        let retries = 0\n\n        stream.on('retry', () => {\n          retries++\n        })\n\n        const p = Bluebird.fromCallback((cb) => {\n          stream.on('error', cb)\n        })\n\n        return expect(p).to.be.rejected\n        .then((err) => {\n          expect(err.code).to.eq('ECONNRESET')\n\n          expect(retries).to.eq(4)\n        })\n      })\n\n      it('retries 4x on a NXDOMAIN (ENOTFOUND)', () => {\n        nock.enableNetConnect()\n\n        const opts = {\n          url: 'http://will-never-exist.invalid.example.com',\n          retryIntervals: [0, 1, 2, 3],\n          timeout: 1000,\n        }\n\n        const stream = request.create(opts)\n\n        let retries = 0\n\n        stream.on('retry', () => {\n          retries++\n        })\n\n        const p = Bluebird.fromCallback((cb) => {\n          stream.on('error', cb)\n        })\n\n        return expect(p).to.be.rejected\n        .then((err) => {\n          expect(err.code).to.eq('ENOTFOUND')\n\n          expect(retries).to.eq(4)\n        })\n      })\n    })\n\n    context('retries for promises', () => {\n      it('does not retry on a timeout', function () {\n        const opts = {\n          url: 'http://localhost:9988/never-ends',\n          timeout: 100,\n        }\n\n        return request.create(opts, true)\n        .then(() => {\n          throw new Error('should not reach')\n        }).catch((err) => {\n          expect(err.error.code).to.eq('ESOCKETTIMEDOUT')\n\n          expect(this.hits).to.eq(1)\n        })\n      })\n\n      it('retries 4x on a connection reset', function () {\n        const opts = {\n          url: 'http://localhost:9988/econnreset',\n          retryIntervals: [0, 1, 2, 3],\n          timeout: 250,\n        }\n\n        return request.create(opts, true)\n        .then(() => {\n          throw new Error('should not reach')\n        }).catch((err) => {\n          expect(err.error.code).to.eq('ECONNRESET')\n\n          expect(this.hits).to.eq(5)\n        })\n      })\n    })\n  })\n\n  context('#sendPromise', () => {\n    it('sets strictSSL=false', function () {\n      const init = sinon.spy(request.rp.Request.prototype, 'init')\n\n      nock('http://www.github.com')\n      .get('/foo')\n      .reply(200, 'hello', {\n        'Content-Type': 'text/html',\n      })\n\n      return request.sendPromise({}, this.fn, {\n        url: 'http://www.github.com/foo',\n        cookies: false,\n      })\n      .then(() => {\n        expect(init).to.be.calledWithMatch({ strictSSL: false })\n      })\n    })\n\n    it('sets simple=false', function () {\n      nock('http://www.github.com')\n      .get('/foo')\n      .reply(500, '')\n\n      // should not bomb on 500\n      // because simple = false\n      return request.sendPromise({}, this.fn, {\n        url: 'http://www.github.com/foo',\n        cookies: false,\n      })\n    })\n\n    it('sets resolveWithFullResponse=true', function () {\n      nock('http://www.github.com')\n      .get('/foo')\n      .reply(200, 'hello', {\n        'Content-Type': 'text/html',\n      })\n\n      return request.sendPromise({}, this.fn, {\n        url: 'http://www.github.com/foo',\n        cookies: false,\n        body: 'foobarbaz',\n      })\n      .then((resp) => {\n        expect(resp).to.have.keys('status', 'body', 'headers', 'duration', 'isOkStatusCode', 'statusText', 'allRequestResponses', 'requestBody', 'requestHeaders')\n\n        expect(resp.status).to.eq(200)\n        expect(resp.statusText).to.eq('OK')\n        expect(resp.body).to.eq('hello')\n        expect(resp.headers).to.deep.eq({ 'content-type': 'text/html' })\n        expect(resp.isOkStatusCode).to.be.true\n        expect(resp.requestBody).to.eq('foobarbaz')\n        expect(resp.requestHeaders).to.deep.eq({\n          'accept': '*/*',\n          'accept-encoding': 'gzip, deflate',\n          'connection': 'keep-alive',\n          'content-length': 9,\n          'host': 'www.github.com',\n        })\n\n        expect(resp.allRequestResponses).to.deep.eq([\n          {\n            'Request Body': 'foobarbaz',\n            'Request Headers': { 'accept': '*/*', 'accept-encoding': 'gzip, deflate', 'connection': 'keep-alive', 'content-length': 9, 'host': 'www.github.com' },\n            'Request URL': 'http://www.github.com/foo',\n            'Response Body': 'hello',\n            'Response Headers': { 'content-type': 'text/html' },\n            'Response Status': 200,\n          },\n        ])\n      })\n    })\n\n    it('includes redirects', function () {\n      this.fn.resolves()\n\n      nock('http://www.github.com')\n      .get('/dashboard')\n      .reply(301, null, {\n        'location': '/auth',\n      })\n      .get('/auth')\n      .reply(302, null, {\n        'location': '/login',\n      })\n      .get('/login')\n      .reply(200, 'log in', {\n        'Content-Type': 'text/html',\n      })\n\n      return request.sendPromise({}, this.fn, {\n        url: 'http://www.github.com/dashboard',\n        cookies: false,\n      })\n      .then((resp) => {\n        expect(resp).to.have.keys('status', 'body', 'headers', 'duration', 'isOkStatusCode', 'statusText', 'allRequestResponses', 'redirects', 'requestBody', 'requestHeaders')\n\n        expect(resp.status).to.eq(200)\n        expect(resp.statusText).to.eq('OK')\n        expect(resp.body).to.eq('log in')\n        expect(resp.headers).to.deep.eq({ 'content-type': 'text/html' })\n        expect(resp.isOkStatusCode).to.be.true\n        expect(resp.requestBody).to.be.undefined\n        expect(resp.redirects).to.deep.eq([\n          '301: http://www.github.com/auth',\n          '302: http://www.github.com/login',\n        ])\n\n        expect(resp.requestHeaders).to.deep.eq({\n          'accept': '*/*',\n          'accept-encoding': 'gzip, deflate',\n          'connection': 'keep-alive',\n          'referer': 'http://www.github.com/auth',\n          'host': 'www.github.com',\n        })\n\n        expect(resp.allRequestResponses).to.deep.eq([\n          {\n            'Request Body': null,\n            'Request Headers': { 'accept': '*/*', 'accept-encoding': 'gzip, deflate', 'connection': 'keep-alive', 'host': 'www.github.com' },\n            'Request URL': 'http://www.github.com/dashboard',\n            'Response Body': null,\n            'Response Headers': { 'content-type': 'application/json', 'location': '/auth' },\n            'Response Status': 301,\n          }, {\n            'Request Body': null,\n            'Request Headers': { 'accept': '*/*', 'accept-encoding': 'gzip, deflate', 'connection': 'keep-alive', 'host': 'www.github.com', 'referer': 'http://www.github.com/dashboard' },\n            'Request URL': 'http://www.github.com/auth',\n            'Response Body': null,\n            'Response Headers': { 'content-type': 'application/json', 'location': '/login' },\n            'Response Status': 302,\n          }, {\n            'Request Body': null,\n            'Request Headers': { 'accept': '*/*', 'accept-encoding': 'gzip, deflate', 'connection': 'keep-alive', 'host': 'www.github.com', 'referer': 'http://www.github.com/auth' },\n            'Request URL': 'http://www.github.com/login',\n            'Response Body': 'log in',\n            'Response Headers': { 'content-type': 'text/html' },\n            'Response Status': 200,\n          },\n        ])\n      })\n    })\n\n    it('catches errors', function () {\n      nock.enableNetConnect()\n\n      const req = Request({ timeout: 2000 })\n\n      return req.sendPromise({}, this.fn, {\n        url: 'http://localhost:1111/foo',\n        cookies: false,\n      })\n      .then(() => {\n        throw new Error('should have failed but didnt')\n      }).catch((err) => {\n        expect(err.message).to.eq('Error: connect ECONNREFUSED 127.0.0.1:1111')\n      })\n    })\n\n    it('parses response body as json if content-type application/json response headers', function () {\n      nock('http://localhost:8080')\n      .get('/status.json')\n      .reply(200, JSON.stringify({ status: 'ok' }), {\n        'Content-Type': 'application/json',\n      })\n\n      return request.sendPromise({}, this.fn, {\n        url: 'http://localhost:8080/status.json',\n        cookies: false,\n      })\n      .then((resp) => {\n        expect(resp.body).to.deep.eq({ status: 'ok' })\n      })\n    })\n\n    it('parses response body as json if content-type application/vnd.api+json response headers', function () {\n      nock('http://localhost:8080')\n      .get('/status.json')\n      .reply(200, JSON.stringify({ status: 'ok' }), {\n        'Content-Type': 'application/vnd.api+json',\n      })\n\n      return request.sendPromise({}, this.fn, {\n        url: 'http://localhost:8080/status.json',\n        cookies: false,\n      })\n      .then((resp) => {\n        expect(resp.body).to.deep.eq({ status: 'ok' })\n      })\n    })\n\n    it('revives from parsing bad json', function () {\n      nock('http://localhost:8080')\n      .get('/status.json')\n      .reply(200, '{bad: \\'json\\'}', {\n        'Content-Type': 'application/json',\n      })\n\n      return request.sendPromise({}, this.fn, {\n        url: 'http://localhost:8080/status.json',\n        cookies: false,\n      })\n      .then((resp) => {\n        expect(resp.body).to.eq('{bad: \\'json\\'}')\n      })\n    })\n\n    it('sets duration on response', function () {\n      nock('http://localhost:8080')\n      .get('/foo')\n      .delay(10)\n      .reply(200, '123', {\n        'Content-Type': 'text/plain',\n      })\n\n      return request.sendPromise({}, this.fn, {\n        url: 'http://localhost:8080/foo',\n        cookies: false,\n      })\n      .then((resp) => {\n        expect(resp.duration).to.be.a('Number')\n\n        expect(resp.duration).to.be.gt(0)\n      })\n    })\n\n    it('sends up user-agent headers', function () {\n      nock('http://localhost:8080')\n      .matchHeader('user-agent', 'foobarbaz')\n      .get('/foo')\n      .reply(200, 'derp')\n\n      const headers = {}\n\n      headers['user-agent'] = 'foobarbaz'\n\n      return request.sendPromise(headers, this.fn, {\n        url: 'http://localhost:8080/foo',\n        cookies: false,\n      })\n      .then((resp) => {\n        expect(resp.body).to.eq('derp')\n      })\n    })\n\n    it('sends connection: keep-alive by default', function () {\n      nock('http://localhost:8080')\n      .matchHeader('connection', 'keep-alive')\n      .get('/foo')\n      .reply(200, 'it worked')\n\n      return request.sendPromise({}, this.fn, {\n        url: 'http://localhost:8080/foo',\n        cookies: false,\n      })\n      .then((resp) => {\n        expect(resp.body).to.eq('it worked')\n      })\n    })\n\n    it('lower cases headers', function () {\n      nock('http://localhost:8080')\n      .matchHeader('test', 'true')\n      .get('/foo')\n      .reply(200, 'derp')\n\n      const headers = {}\n\n      headers['user-agent'] = 'foobarbaz'\n\n      return request.sendPromise(headers, this.fn, {\n        url: 'http://localhost:8080/foo',\n        cookies: false,\n        headers: {\n          'TEST': true,\n        },\n      })\n      .then((resp) => {\n        expect(resp.body).to.eq('derp')\n      })\n    })\n\n    it('allows overriding user-agent in headers', function () {\n      nock('http://localhost:8080')\n      .matchHeader('user-agent', 'custom-agent')\n      .get('/foo')\n      .reply(200, 'derp')\n\n      const headers = { 'user-agent': 'test' }\n\n      return request.sendPromise(headers, this.fn, {\n        url: 'http://localhost:8080/foo',\n        cookies: false,\n        headers: {\n          'User-Agent': 'custom-agent',\n        },\n      })\n      .then((resp) => {\n        expect(resp.body).to.eq('derp')\n      })\n    })\n\n    context('accept header', () => {\n      it('sets to */* by default', function () {\n        nock('http://localhost:8080')\n        .matchHeader('accept', '*/*')\n        .get('/headers')\n        .reply(200)\n\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/headers',\n          cookies: false,\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(200)\n        })\n      })\n\n      it('can override accept header', function () {\n        nock('http://localhost:8080')\n        .matchHeader('accept', 'text/html')\n        .get('/headers')\n        .reply(200)\n\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/headers',\n          cookies: false,\n          headers: {\n            accept: 'text/html',\n          },\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(200)\n        })\n      })\n\n      it('can override Accept header', function () {\n        nock('http://localhost:8080')\n        .matchHeader('accept', 'text/plain')\n        .get('/headers')\n        .reply(200)\n\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/headers',\n          cookies: false,\n          headers: {\n            Accept: 'text/plain',\n          },\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(200)\n        })\n      })\n    })\n\n    context('qs', () => {\n      it('can accept qs', function () {\n        nock('http://localhost:8080')\n        .get('/foo?bar=baz&q=1')\n        .reply(200)\n\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/foo',\n          cookies: false,\n          qs: {\n            bar: 'baz',\n            q: 1,\n          },\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(200)\n        })\n      })\n    })\n\n    context('followRedirect', () => {\n      beforeEach(function () {\n        this.fn.resolves()\n      })\n\n      it('by default follow redirects', function () {\n        nock('http://localhost:8080')\n        .get('/dashboard')\n        .reply(302, '', {\n          location: 'http://localhost:8080/login',\n        })\n        .get('/login')\n        .reply(200, 'login')\n\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/dashboard',\n          cookies: false,\n          followRedirect: true,\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(200)\n          expect(resp.body).to.eq('login')\n\n          expect(resp).not.to.have.property('redirectedToUrl')\n        })\n      })\n\n      it('follows non-GET redirects by default', function () {\n        nock('http://localhost:8080')\n        .post('/login')\n        .reply(302, '', {\n          location: 'http://localhost:8080/dashboard',\n        })\n        .get('/dashboard')\n        .reply(200, 'dashboard')\n\n        return request.sendPromise({}, this.fn, {\n          method: 'POST',\n          url: 'http://localhost:8080/login',\n          cookies: false,\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(200)\n          expect(resp.body).to.eq('dashboard')\n\n          expect(resp).not.to.have.property('redirectedToUrl')\n        })\n      })\n\n      it('can turn off following redirects', function () {\n        nock('http://localhost:8080')\n        .get('/dashboard')\n        .reply(302, '', {\n          location: 'http://localhost:8080/login',\n        })\n        .get('/login')\n        .reply(200, 'login')\n\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/dashboard',\n          cookies: false,\n          followRedirect: false,\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(302)\n          expect(resp.body).to.eq('')\n\n          expect(resp.redirectedToUrl).to.eq('http://localhost:8080/login')\n        })\n      })\n\n      it('resolves redirectedToUrl on relative redirects', function () {\n        nock('http://localhost:8080')\n        .get('/dashboard')\n        .reply(302, '', {\n          location: '/login', // absolute-relative pathname\n        })\n        .get('/login')\n        .reply(200, 'login')\n\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/dashboard',\n          cookies: false,\n          followRedirect: false,\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(302)\n\n          expect(resp.redirectedToUrl).to.eq('http://localhost:8080/login')\n        })\n      })\n\n      it('resolves redirectedToUrl to another domain', function () {\n        nock('http://localhost:8080')\n        .get('/dashboard')\n        .reply(301, '', {\n          location: 'https://www.google.com/login',\n        })\n        .get('/login')\n        .reply(200, 'login')\n\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/dashboard',\n          cookies: false,\n          followRedirect: false,\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(301)\n\n          expect(resp.redirectedToUrl).to.eq('https://www.google.com/login')\n        })\n      })\n\n      it('does not included redirectedToUrl when following redirects', function () {\n        nock('http://localhost:8080')\n        .get('/dashboard')\n        .reply(302, '', {\n          location: 'http://localhost:8080/login',\n        })\n        .get('/login')\n        .reply(200, 'login')\n\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/dashboard',\n          cookies: false,\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(200)\n\n          expect(resp).not.to.have.property('redirectedToUrl')\n        })\n      })\n\n      it('gets + attaches the cookies at each redirect', function () {\n        return testAttachingCookiesWith(() => {\n          return request.sendPromise({}, this.fn, {\n            url: 'http://localhost:1234/',\n          })\n        })\n      })\n    })\n\n    context('form=true', () => {\n      beforeEach(() => {\n        nock('http://localhost:8080')\n        .matchHeader('Content-Type', 'application/x-www-form-urlencoded')\n        .post('/login', 'foo=bar&baz=quux')\n        .reply(200, '<html></html>')\n      })\n\n      it('takes converts body to x-www-form-urlencoded and sets header', function () {\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/login',\n          method: 'POST',\n          cookies: false,\n          form: true,\n          body: {\n            foo: 'bar',\n            baz: 'quux',\n          },\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(200)\n\n          expect(resp.body).to.eq('<html></html>')\n        })\n      })\n\n      it('does not send body', function () {\n        const init = sinon.spy(request.rp.Request.prototype, 'init')\n\n        const body = {\n          foo: 'bar',\n          baz: 'quux',\n        }\n\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/login',\n          method: 'POST',\n          cookies: false,\n          form: true,\n          json: true,\n          body,\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(200)\n          expect(resp.body).to.eq('<html></html>')\n\n          expect(init).not.to.be.calledWithMatch({ body })\n        })\n      })\n\n      it('does not set json=true', function () {\n        const init = sinon.spy(request.rp.Request.prototype, 'init')\n\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:8080/login',\n          method: 'POST',\n          cookies: false,\n          form: true,\n          json: true,\n          body: {\n            foo: 'bar',\n            baz: 'quux',\n          },\n        })\n        .then((resp) => {\n          expect(resp.status).to.eq(200)\n          expect(resp.body).to.eq('<html></html>')\n\n          expect(init).not.to.be.calledWithMatch({ json: true })\n        })\n      })\n    })\n\n    context('bad headers', () => {\n      beforeEach(function (done) {\n        this.srv = http.createServer((req, res) => {\n          res.writeHead(200)\n\n          res.end()\n        })\n\n        this.srv.listen(9988, done)\n      })\n\n      afterEach(function () {\n        return this.srv.close()\n      })\n\n      it('recovers from bad headers', function () {\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:9988/foo',\n          cookies: false,\n          headers: {\n            'x-text': 'אבגד',\n          },\n        })\n        .then(() => {\n          throw new Error('should have failed')\n        }).catch((err) => {\n          expect(err.message).to.eq('TypeError [ERR_INVALID_CHAR]: Invalid character in header content [\"x-text\"]')\n        })\n      })\n\n      it('handles weird content in the body just fine', function () {\n        return request.sendPromise({}, this.fn, {\n          url: 'http://localhost:9988/foo',\n          cookies: false,\n          json: true,\n          body: {\n            'x-text': 'אבגד',\n          },\n        })\n      })\n    })\n  })\n\n  context('#sendStream', () => {\n    it('allows overriding user-agent in headers', function () {\n      nock('http://localhost:8080')\n      .matchHeader('user-agent', 'custom-agent')\n      .get('/foo')\n      .reply(200, 'derp')\n\n      sinon.spy(request, 'create')\n      this.fn.resolves({})\n\n      const headers = { 'user-agent': 'test' }\n\n      const options = {\n        url: 'http://localhost:8080/foo',\n        cookies: false,\n        headers: {\n          'user-agent': 'custom-agent',\n        },\n      }\n\n      return request.sendStream(headers, this.fn, options)\n      .then((beginFn) => {\n        beginFn()\n        expect(request.create).to.be.calledOnce\n\n        expect(request.create).to.be.calledWith(options)\n      })\n    })\n\n    it('gets + attaches the cookies at each redirect', function () {\n      return testAttachingCookiesWith(() => {\n        return request.sendStream({}, this.fn, {\n          url: 'http://localhost:1234/',\n          followRedirect: _.stubTrue,\n        })\n        .then((fn) => {\n          const req = fn()\n\n          return new Promise((resolve, reject) => {\n            req.on('response', resolve)\n\n            req.on('error', reject)\n          })\n        })\n      })\n    })\n  })\n})\n",
    "packages/server/test/unit/stream_buffer_spec.js": "require('../spec_helper')\n\nconst _ = require('lodash')\nconst fs = require('fs')\nconst stream = require('stream')\nconst Promise = require('bluebird')\nconst { concatStream } = require('@packages/network')\nconst { streamBuffer } = require('../../lib/util/stream_buffer')\n\nfunction drain (stream) {\n  return new Promise((resolve) => {\n    return stream.pipe(concatStream((buf) => {\n      resolve(buf.toString())\n    }))\n  })\n}\n\ndescribe('lib/util/stream_buffer', () => {\n  it('reads out no matter when we write', function (done) {\n    done = _.after(2, done)\n    const pt = stream.PassThrough()\n    const sb = streamBuffer()\n\n    pt.pipe(sb)\n    pt.write('1')\n    pt.write(' 2')\n\n    const tickWrite = (chunk) => {\n      process.nextTick(() => {\n        pt.write(chunk)\n      })\n    }\n\n    const readable = sb.createReadStream()\n\n    readable.once('data', (data2) => {\n      expect(data2.toString()).to.eq('1 2')\n\n      tickWrite(' 3')\n\n      readable.once('data', (data3) => {\n        expect(data3.toString()).to.eq(' 3')\n\n        tickWrite(' 4')\n\n        const readable2 = sb.createReadStream()\n\n        readable.once('data', (data4) => {\n          expect(data4.toString()).to.eq(' 4')\n        })\n\n        readable2.once('data', (data) => {\n          expect(data.toString()).to.eq('1 2 3 4')\n\n          tickWrite(' 5')\n\n          readable2.once('data', (data5) => {\n            expect(data5.toString()).to.eq(' 5')\n\n            done()\n          })\n\n          readable.once('data', (data5) => {\n            expect(data5.toString()).to.eq(' 5')\n\n            done()\n          })\n        })\n      })\n    })\n  })\n\n  it('on overflow, enlarges the internal buffer by the smallest power of 2 that can fit the chunk', () => {\n    const sb = streamBuffer(64)\n\n    sb.write('A'.repeat(65))\n\n    expect(sb._buffer().length).to.eq(128)\n\n    sb.end('A'.repeat(1024))\n\n    expect(sb._buffer().length).to.eq(2048)\n\n    const readable = sb.createReadStream()\n\n    return drain(readable)\n    .then((buf) => {\n      expect(buf).to.eq('A'.repeat(1089))\n    })\n  })\n\n  it('finishes when buffer stream closes while still allowing data to be drained', (done) => {\n    const sb = streamBuffer()\n\n    sb.write('foo')\n    sb.write('bar')\n\n    expect(sb._finished()).to.be.false\n\n    sb.end(() => {\n      expect(sb._finished()).to.be.true\n\n      const readable = sb.createReadStream()\n\n      return drain(readable)\n      .then((buf) => {\n        expect(buf).to.eq('foobar')\n\n        const readable2 = sb.createReadStream()\n\n        return drain(readable2)\n        .then((buf2) => {\n          expect(buf2).to.eq('foobar')\n\n          done()\n        })\n      })\n    })\n  })\n\n  it('can be piped into and then read from', function (done) {\n    const expected = fs.readFileSync(__filename).toString()\n    const rs = fs.createReadStream(__filename)\n    const sb = streamBuffer()\n\n    rs.pipe(sb)\n\n    const readable = sb.createReadStream()\n\n    rs.on('end', () => {\n      return drain(readable)\n      .then((buf) => {\n        expect(buf).to.eq(expected)\n\n        done()\n      })\n    })\n  })\n\n  it('readable recursively pushes until it returns false', (done) => {\n    const sb = streamBuffer()\n    const readable = sb.createReadStream()\n    const writeable = stream.Writable({\n      final () {\n        expect(readable.push).to.be.calledTwice\n        expect(readable.push.firstCall).to.be.calledWith(buf)\n        expect(readable.push.secondCall).to.be.calledWith(null)\n        done()\n      },\n      write (chunk, enc, cb) {\n        cb()\n      },\n    })\n\n    sinon.spy(readable, 'push')\n\n    readable.pipe(writeable)\n\n    const size = 64 * 1024 // 64 kb\n    const buf = Buffer.alloc(size, '!')\n\n    sb.end(buf)\n  })\n\n  it('readable pipes do not end until the writeable ends', function (done) {\n    const sb = streamBuffer()\n    const readable = sb.createReadStream()\n    const writeable = stream.Writable({\n      final () {\n        expect(sb.writable).to.be.false\n        expect(sb._writableState).to.have.property('ended', true)\n        done()\n      },\n      write (chunk, enc, cb) {\n        process.nextTick(() => {\n          if (sb.writable) {\n            sb.end('asdf')\n          }\n        })\n\n        cb()\n      },\n    })\n\n    readable.pipe(writeable)\n\n    const size = 64 * 1024 // 64 kb\n    const buf = Buffer.alloc(size, '!')\n\n    sb.write(buf)\n  })\n\n  it('can handle a massive req body', function (done) {\n    const size = 16 * 1024 // 16 kb\n    const repeat = 3\n\n    const body = Buffer.alloc(size, '!')\n    const sb = streamBuffer()\n\n    const pt = new stream.PassThrough({\n      highWaterMark: Number.MAX_SAFE_INTEGER,\n    })\n\n    pt.pipe(sb, { end: true })\n\n    pt.write(Buffer.alloc(size, '!'))\n    pt.write(Buffer.alloc(size, '!'))\n    pt.write(Buffer.alloc(size, '!'))\n\n    pt.on('end', () => {\n      const readable = sb.createReadStream()\n\n      drain(readable)\n      .then((buf) => {\n        expect(buf.length).to.eq(body.length * repeat)\n\n        expect(buf).to.eq(body.toString().repeat(repeat))\n        done()\n      })\n    })\n\n    pt.end()\n  })\n\n  it('silently discards writes after it has been destroyed, with no consumers', function (done) {\n    const sb = streamBuffer()\n\n    sb.write('foo')\n    sb.unpipeAll()\n    sb.write('bar', done)\n  })\n\n  it('silently discards writes after it has been destroyed, with a consumer', function (done) {\n    const sb = streamBuffer()\n    const pt = stream.PassThrough()\n\n    sb.createReadStream().pipe(pt)\n\n    sb.write('foo')\n    sb.unpipeAll()\n    sb.write('bar', done)\n  })\n})\n",
    "scripts/binary/s3-api.ts": "const debug = require('debug')('cypress:binary')\nimport la from 'lazy-ass'\nimport is from 'check-more-types'\nimport S3 from 'aws-sdk/clients/s3'\nimport { prop, values, all } from 'ramda'\n\nexport const hasOnlyStringValues = (o) => {\n  return all(is.unemptyString, values(o))\n}\n\n/**\n * Utility object with methods that deal with S3.\n * Useful for testing our code that calls S3 methods.\n */\nexport const s3helpers = {\n  makeS3 (aws) {\n    la(is.unemptyString(aws.key), 'missing aws key')\n    la(is.unemptyString(aws.secret), 'missing aws secret')\n\n    return new S3({\n      accessKeyId: aws.key,\n      secretAccessKey: aws.secret,\n    })\n  },\n\n  verifyZipFileExists (zipFile: string, bucket: string, s3: S3): Promise<null> {\n    debug('checking S3 file %s', zipFile)\n    debug('bucket %s', bucket)\n\n    return new Promise((resolve, reject) => {\n      s3.headObject({\n        Bucket: bucket,\n        Key: zipFile,\n      }, (err, data) => {\n        if (err) {\n          debug('error getting object %s', zipFile)\n          debug(err)\n\n          return reject(err)\n        }\n\n        debug('s3 data for %s', zipFile)\n        debug(data)\n        resolve()\n      })\n    })\n  },\n\n  /**\n   * Returns list of prefixes in a given folder\n   */\n  listS3Objects (uploadDir: string, bucket: string, s3: S3): Promise<string[]> {\n    la(is.unemptyString(uploadDir), 'invalid upload dir', uploadDir)\n\n    return new Promise((resolve, reject) => {\n      const prefix = `${uploadDir}/`\n\n      s3.listObjectsV2({\n        Bucket: bucket,\n        Prefix: prefix,\n        Delimiter: '/',\n      }, (err, result) => {\n        if (err) {\n          return reject(err)\n        }\n\n        debug('AWS result in %s %s', bucket, prefix)\n        debug('%o', result)\n\n        resolve(result.CommonPrefixes.map(prop('Prefix')))\n      })\n    })\n  },\n\n  /**\n   * Copies one S3 object into another key, metadata is copied.\n   * For copying a public zip file use content 'application/zip'\n   * and ACL 'public-read'\n   */\n  copyS3 (sourceKey: string, destinationKey: string, bucket: string,\n    contentType: S3.ContentType, acl: S3.ObjectCannedACL,\n    s3: S3): Promise<S3.CopyObjectOutput> {\n    return new Promise((resolve, reject) => {\n      debug('copying %s in bucket %s to %s', sourceKey, bucket, destinationKey)\n\n      const params: S3.CopyObjectRequest = {\n        Bucket: bucket,\n        CopySource: `${bucket}/${sourceKey}`,\n        Key: destinationKey,\n        // when we copy S3 object, copy the original metadata, if any\n        MetadataDirective: 'COPY',\n        ContentType: contentType,\n        ACL: acl,\n      }\n\n      s3.copyObject(params, (err, data) => {\n        if (err) {\n          return reject(err)\n        }\n\n        debug('result of copying')\n        debug('%o', data)\n        resolve(data)\n      })\n    })\n  },\n\n  /**\n   * Returns user metadata for the given S3 object.\n   * Note: on S3 when adding user metadata, each key is prefixed with \"x-amz-meta-\"\n   * but the returned object has these prefixes stripped. Thus if we set\n   * a single \"x-amz-meta-user: gleb\", the resolved object will be simply {user: \"gleb\"}\n  */\n  getUserMetadata (bucket: string, key: string, s3: S3): Promise<S3.Metadata> {\n    return new Promise((resole, reject) => {\n      debug('getting user metadata from %s %s', bucket, key)\n\n      s3.headObject({\n        Bucket: bucket,\n        Key: key,\n      }, (err, data) => {\n        if (err) {\n          return reject(err)\n        }\n\n        debug('user metadata')\n        debug('%o', data.Metadata)\n        resole(data.Metadata)\n      })\n    })\n  },\n\n  /**\n   * Setting user metadata can be accomplished with copying the object back onto itself\n   * with replaced metadata object.\n  */\n  setUserMetadata (bucket: string, key: string, metadata: S3.Metadata,\n    contentType: S3.ContentType, acl: S3.ObjectCannedACL, s3: S3): Promise<S3.CopyObjectOutput> {\n    la(hasOnlyStringValues(metadata),\n      'metadata object can only have string values', metadata)\n\n    return new Promise((resolve, reject) => {\n      debug('setting metadata to %o for %s %s', metadata, bucket, key)\n\n      const params: S3.CopyObjectRequest = {\n        Bucket: bucket,\n        CopySource: `${bucket}/${key}`,\n        Key: key,\n        Metadata: metadata,\n        MetadataDirective: 'REPLACE',\n        ContentType: contentType,\n        ACL: acl,\n      }\n\n      s3.copyObject(params, (err, data) => {\n        if (err) {\n          return reject(err)\n        }\n\n        debug('result of copying')\n        debug('%o', data)\n        resolve(data)\n      })\n    })\n  },\n}\n",
    "scripts/binary/smoke.js": "const _ = require('lodash')\nconst fse = require('fs-extra')\nconst cp = require('child_process')\nconst execa = require('execa')\nconst path = require('path')\nconst Promise = require('bluebird')\nconst os = require('os')\nconst verify = require('../../cli/lib/tasks/verify')\nconst Fixtures = require('../../packages/server/test/support/helpers/fixtures')\n\nconst fs = Promise.promisifyAll(fse)\n\nconst canRecordVideo = () => {\n  return os.platform() !== 'win32'\n}\n\nconst shouldSkipProjectTest = () => {\n  return os.platform() === 'win32'\n}\n\nconst runSmokeTest = function (buildAppExecutable, timeoutSeconds = 30) {\n  const rand = String(_.random(0, 1000))\n\n  console.log(`executable path ${buildAppExecutable}`)\n  console.log(`timeout ${timeoutSeconds} seconds`)\n\n  const hasRightResponse = function (stdout) {\n    // there could be more debug lines in the output, so find 1 line with\n    // expected random value\n    const lines = stdout.split('\\n').map((s) => {\n      return s.trim()\n    })\n\n    return lines.includes(rand)\n  }\n\n  const args = []\n\n  if (verify.needsSandbox()) {\n    args.push('--no-sandbox')\n  }\n\n  // separate any Electron command line arguments from Cypress args\n  args.push('--')\n  args.push('--smoke-test')\n  args.push(`--ping=${rand}`)\n\n  const options = {\n    timeout: timeoutSeconds * 1000,\n  }\n\n  return execa(`${buildAppExecutable}`, args, options)\n  .catch((err) => {\n    console.error('smoke test failed with error %s', err.message)\n    throw err\n  }).then(({ stdout }) => {\n    stdout = stdout.replace(/\\s/, '')\n    if (!hasRightResponse(stdout)) {\n      throw new Error(`Stdout: '${stdout}' did not match the random number: '${rand}'`)\n    }\n\n    console.log('smoke test response', stdout)\n\n    return console.log('smokeTest passes')\n  })\n}\n\nconst runProjectTest = function (buildAppExecutable, e2e) {\n  if (shouldSkipProjectTest()) {\n    console.log('skipping project test')\n\n    return Promise.resolve()\n  }\n\n  return new Promise((resolve, reject) => {\n    const env = _.omit(process.env, 'CYPRESS_INTERNAL_ENV')\n\n    if (!canRecordVideo()) {\n      console.log('cannot record video on this platform yet, disabling')\n      env.CYPRESS_VIDEO_RECORDING = 'false'\n    }\n\n    const args = [\n      `--run-project=${e2e}`,\n      `--spec=${e2e}/cypress/integration/simple_passing_spec.js`,\n    ]\n\n    if (verify.needsSandbox()) {\n      args.push('--no-sandbox')\n    }\n\n    const options = {\n      stdio: 'inherit', env,\n    }\n\n    console.log('running project test')\n    console.log(buildAppExecutable, args.join(' '))\n\n    return cp.spawn(buildAppExecutable, args, options)\n    .on('exit', (code) => {\n      if (code === 0) {\n        return resolve()\n      }\n\n      return reject(new Error(`running project tests failed with: '${code}' errors.`))\n    })\n  })\n}\n\nconst runFailingProjectTest = function (buildAppExecutable, e2e) {\n  if (shouldSkipProjectTest()) {\n    console.log('skipping failing project test')\n\n    return Promise.resolve()\n  }\n\n  console.log('running failing project test')\n\n  const verifyScreenshots = function () {\n    const screenshot1 = path.join(e2e, 'cypress', 'screenshots', 'simple_failing_spec.js', 'simple failing spec -- fails1 (failed).png')\n    const screenshot2 = path.join(e2e, 'cypress', 'screenshots', 'simple_failing_spec.js', 'simple failing spec -- fails2 (failed).png')\n\n    return Promise.all([\n      fs.statAsync(screenshot1),\n      fs.statAsync(screenshot2),\n    ])\n  }\n\n  const spawn = () => {\n    return new Promise((resolve, reject) => {\n      const env = _.omit(process.env, 'CYPRESS_INTERNAL_ENV')\n\n      const args = [\n        `--run-project=${e2e}`,\n        `--spec=${e2e}/cypress/integration/simple_failing_spec.js`,\n      ]\n\n      if (verify.needsSandbox()) {\n        args.push('--no-sandbox')\n      }\n\n      const options = {\n        stdio: 'inherit',\n        env,\n      }\n\n      return cp.spawn(buildAppExecutable, args, options)\n      .on('exit', (code) => {\n        if (code === 2) {\n          return resolve()\n        }\n\n        return reject(new Error(`running project tests failed with: '${code}' errors.`))\n      })\n    })\n  }\n\n  return spawn()\n  .then(verifyScreenshots)\n}\n\nconst test = function (buildAppExecutable) {\n  Fixtures.scaffold()\n\n  const e2e = Fixtures.projectPath('e2e')\n\n  return runSmokeTest(buildAppExecutable)\n  .then(() => {\n    return runProjectTest(buildAppExecutable, e2e)\n  }).then(() => {\n    return runFailingProjectTest(buildAppExecutable, e2e)\n  }).then(() => {\n    return Fixtures.remove()\n  })\n}\n\nmodule.exports = {\n  test,\n}\n",
    "scripts/binary/upload-npm-package.js": "const minimist = require('minimist')\nconst Promise = require('bluebird')\nconst la = require('lazy-ass')\nconst check = require('check-more-types')\nconst fs = require('fs')\nconst path = require('path')\nconst awspublish = require('gulp-awspublish')\nconst rename = require('gulp-rename')\nconst gulpDebug = require('gulp-debug')\nconst gulp = require('gulp')\nconst uploadUtils = require('./util/upload')\n\nconst npmPackageExtension = '.tgz'\nconst uploadFileName = 'cypress.tgz'\n\nconst isNpmPackageFile = check.extension(npmPackageExtension)\n\n// the package tgz file will be uploaded into unique folder\n// in our case something like this\n// https://cdn.cypress.io/beta/npm/<version>/<some unique hash>/cypress.tgz\nconst rootFolder = 'beta'\nconst npmFolder = 'npm'\n\nconst getCDN = function ({ version, hash, filename }) {\n  la(check.semver(version), 'invalid version', version)\n  la(check.unemptyString(hash), 'missing hash', hash)\n  la(check.unemptyString(filename), 'missing filename', filename)\n  la(isNpmPackageFile(filename), 'wrong extension for file', filename)\n  const url = uploadUtils.getUploadUrl()\n\n  la(check.url(url), 'could not get upload url', url)\n\n  return [url, rootFolder, npmFolder, version, hash, filename].join('/')\n}\n\nconst getUploadDirName = function (options) {\n  la(check.unemptyString(options.version), 'missing version', options)\n  la(check.unemptyString(options.hash), 'missing hash', options)\n  const dir = [rootFolder, npmFolder, options.version, options.hash, null].join('/')\n\n  return dir\n}\n\nconst uploadFile = (options) => {\n  return new Promise((resolve, reject) => {\n    const publisher = uploadUtils.getPublisher()\n\n    const headers = {}\n\n    headers['Cache-Control'] = 'no-cache'\n\n    return gulp.src(options.file)\n    .pipe(rename((p) => {\n      p.basename = path.basename(uploadFileName, npmPackageExtension)\n      p.dirname = getUploadDirName(options)\n      console.log('renaming upload to', p.dirname, p.basename)\n      la(check.unemptyString(p.basename), 'missing basename')\n      la(check.unemptyString(p.dirname), 'missing dirname')\n\n      return p\n    })).pipe(gulpDebug())\n    .pipe(publisher.publish(headers))\n    .pipe(awspublish.reporter())\n    .on('error', reject)\n    .on('end', resolve)\n  })\n}\n\nconst uploadNpmPackage = function (args = []) {\n  console.log(args)\n  const options = minimist(args, {\n    string: ['version', 'file', 'hash'],\n    alias: {\n      version: 'v',\n      file: 'f',\n      hash: 'h',\n    },\n  })\n\n  console.log('Upload NPM package options')\n  console.log(options)\n\n  la(check.unemptyString(options.file), 'missing file to upload', options)\n  la(isNpmPackageFile(options.file),\n    'invalid file to upload extension', options.file)\n\n  if (!options.hash) {\n    options.hash = uploadUtils.formHashFromEnvironment()\n  }\n\n  la(check.unemptyString(options.hash), 'missing hash to give', options)\n  la(check.unemptyString(options.version), 'missing version', options)\n\n  la(fs.existsSync(options.file), 'cannot find file', options.file)\n\n  return uploadFile(options)\n  .then(() => {\n    const cdnUrl = getCDN({\n      version: options.version,\n      hash: options.hash,\n      filename: uploadFileName,\n    })\n\n    console.log('NPM package can be installed using URL')\n    console.log('npm install %s', cdnUrl)\n\n    return cdnUrl\n  }).then(uploadUtils.saveUrl('npm-package-url.json'))\n}\n\n// for now disable purging from CDN cache\n// because each upload should be unique by hash\n// .then R.tap(uploadUtils.purgeCache)\n\nmodule.exports = {\n  uploadNpmPackage,\n  getCDN,\n}\n\nif (!module.parent) {\n  uploadNpmPackage(process.argv)\n}\n",
    "scripts/binary/upload-unique-binary.js": "const minimist = require('minimist')\nconst Promise = require('bluebird')\nconst la = require('lazy-ass')\nconst check = require('check-more-types')\nconst fs = require('fs')\nconst path = require('path')\nconst awspublish = require('gulp-awspublish')\nconst rename = require('gulp-rename')\nconst gulpDebug = require('gulp-debug')\nconst gulp = require('gulp')\nconst R = require('ramda')\nconst hasha = require('hasha')\n\nconst uploadUtils = require('./util/upload')\nconst {\n  s3helpers,\n} = require('./s3-api')\n\n// we zip the binary on every platform and upload under same name\nconst binaryExtension = '.zip'\nconst uploadFileName = 'cypress.zip'\n\nconst isBinaryFile = check.extension(binaryExtension)\n\nconst rootFolder = 'beta'\nconst folder = 'binary'\n\n// the binary will be uploaded into unique folder\n// in our case something like this\n// https://cdn.cypress.io/desktop/binary/0.20.2/<platform>/<some unique version info>/cypress.zip\nconst getCDN = function ({ version, hash, filename, platform }) {\n  la(check.semver(version), 'invalid version', version)\n  la(check.unemptyString(hash), 'missing hash', hash)\n  la(check.unemptyString(filename), 'missing filename', filename)\n  la(isBinaryFile(filename), 'wrong extension for file', filename)\n  la(check.unemptyString(platform), 'missing platform', platform)\n\n  const cdnUrl = uploadUtils.getUploadUrl()\n\n  la(check.url(cdnUrl), 'could not get cdn url', cdnUrl)\n\n  return [cdnUrl, rootFolder, folder, version, platform, hash, filename].join('/')\n}\n\n// returns folder that contains beta (unreleased) binaries for given version\n//\nconst getUploadVersionDirName = function (options) {\n  la(check.unemptyString(options.version), 'missing version', options)\n\n  const dir = [rootFolder, folder, options.version].join('/')\n\n  return dir\n}\n\nconst getUploadDirForPlatform = function (options, platformArch) {\n  la(uploadUtils.isValidPlatformArch(platformArch),\n    'missing or invalid platformArch', platformArch)\n\n  const versionDir = getUploadVersionDirName(options)\n\n  la(check.unemptyString(versionDir), 'could not form folder from', options)\n\n  const dir = [versionDir, platformArch].join('/')\n\n  return dir\n}\n\nconst getUploadDirName = function (options) {\n  la(check.unemptyString(options.hash), 'missing hash', options)\n\n  const uploadFolder = getUploadDirForPlatform(options, options.platformArch)\n\n  la(check.unemptyString(uploadFolder), 'could not form folder from', options)\n\n  const dir = [uploadFolder, options.hash, null].join('/')\n\n  return dir\n}\n\nconst uploadFile = (options) => {\n  return new Promise((resolve, reject) => {\n    const publisher = uploadUtils.getPublisher()\n\n    const headers = {}\n\n    headers['Cache-Control'] = 'no-cache'\n\n    let key = null\n\n    return gulp.src(options.file)\n    .pipe(rename((p) => {\n      p.basename = path.basename(uploadFileName, binaryExtension)\n      p.dirname = getUploadDirName(options)\n      console.log('renaming upload to', p.dirname, p.basename)\n      la(check.unemptyString(p.basename), 'missing basename')\n      la(check.unemptyString(p.dirname), 'missing dirname')\n      key = p.dirname + uploadFileName\n\n      return p\n    })).pipe(gulpDebug())\n    .pipe(publisher.publish(headers))\n    .pipe(awspublish.reporter())\n    .on('error', reject)\n    .on('end', () => {\n      return resolve(key)\n    })\n  })\n}\n\nconst setChecksum = (filename, key) => {\n  console.log('setting checksum for file %s', filename)\n  console.log('on s3 object %s', key)\n\n  la(check.unemptyString(filename), 'expected filename', filename)\n  la(check.unemptyString(key), 'expected uploaded S3 key', key)\n\n  const checksum = hasha.fromFileSync(filename, { algorithm: 'sha512' })\n  const {\n    size,\n  } = fs.statSync(filename)\n\n  console.log('SHA256 checksum %s', checksum)\n  console.log('size', size)\n\n  const aws = uploadUtils.getS3Credentials()\n  const s3 = s3helpers.makeS3(aws)\n  // S3 object metadata can only have string values\n  const metadata = {\n    checksum,\n    size: String(size),\n  }\n\n  // by default s3.copyObject does not preserve ACL when copying\n  // thus we need to reset it for our public files\n  return s3helpers.setUserMetadata(aws.bucket, key, metadata,\n    'application/zip', 'public-read', s3)\n}\n\nconst uploadUniqueBinary = function (args = []) {\n  const options = minimist(args, {\n    string: ['version', 'file', 'hash', 'platform'],\n    alias: {\n      version: 'v',\n      file: 'f',\n      hash: 'h',\n    },\n  })\n\n  console.log('Upload unique binary options')\n  const pickOptions = R.pick(['file', 'version', 'hash'])\n\n  console.log(pickOptions(options))\n\n  la(check.unemptyString(options.file), 'missing file to upload', options)\n  la(isBinaryFile(options.file),\n    'invalid file to upload extension', options.file)\n\n  if (!options.hash) {\n    options.hash = uploadUtils.formHashFromEnvironment()\n  }\n\n  la(check.unemptyString(options.hash), 'missing hash to give', options)\n  la(check.unemptyString(options.version), 'missing version', options)\n\n  la(fs.existsSync(options.file), 'cannot find file', options.file)\n\n  const platform = options.platform != null ? options.platform : process.platform\n\n  options.platformArch = uploadUtils.getUploadNameByOsAndArch(platform)\n\n  return uploadFile(options)\n  .then((key) => {\n    return setChecksum(options.file, key)\n  }).then(() => {\n    const cdnUrl = getCDN({\n      version: options.version,\n      hash: options.hash,\n      filename: uploadFileName,\n      platform: options.platformArch,\n    })\n\n    console.log('Binary can be downloaded using URL')\n    console.log(cdnUrl)\n\n    return cdnUrl\n  }).then(uploadUtils.saveUrl('binary-url.json'))\n}\n\nmodule.exports = {\n  getUploadDirName,\n  getUploadDirForPlatform,\n  uploadUniqueBinary,\n  getCDN,\n}\n\nif (!module.parent) {\n  uploadUniqueBinary(process.argv)\n}\n",
    "scripts/binary/upload.js": "const awspublish = require('gulp-awspublish')\nconst rename = require('gulp-rename')\nconst gulpDebug = require('gulp-debug')\nlet fs = require('fs-extra')\nconst path = require('path')\nconst gulp = require('gulp')\nconst Promise = require('bluebird')\nconst meta = require('./meta')\nconst la = require('lazy-ass')\nconst check = require('check-more-types')\nconst uploadUtils = require('./util/upload')\n\nfs = Promise.promisifyAll(fs)\n\n// TODO: refactor this\n// system expects desktop application to be inside a file\n// with this name\nconst zipName = 'cypress.zip'\n\nmodule.exports = {\n  zipName,\n\n  getPublisher () {\n    return uploadUtils.getPublisher(this.getAwsObj)\n  },\n\n  getAwsObj () {\n    return uploadUtils.getS3Credentials()\n  },\n\n  // returns desktop folder for a given folder without platform\n  // something like desktop/0.20.1\n  getUploadeVersionFolder (aws, version) {\n    la(check.unemptyString(aws.folder), 'aws object is missing desktop folder', aws.folder)\n    const dirName = [aws.folder, version].join('/')\n\n    return dirName\n  },\n\n  getFullUploadName ({ folder, version, platformArch, name }) {\n    la(check.unemptyString(folder), 'missing folder', folder)\n    la(check.semver(version), 'missing or invalid version', version)\n    la(check.unemptyString(name), 'missing file name', name)\n    la(uploadUtils.isValidPlatformArch(platformArch),\n      'invalid platform and arch', platformArch)\n\n    const fileName = [folder, version, platformArch, name].join('/')\n\n    return fileName\n  },\n\n  // store uploaded application in subfolders by platform and version\n  // something like desktop/0.20.1/darwin-x64/\n  getUploadDirName ({ version, platform }) {\n    const aws = this.getAwsObj()\n    const platformArch = uploadUtils.getUploadNameByOsAndArch(platform)\n\n    const versionFolder = this.getUploadeVersionFolder(aws, version)\n    const dirName = [versionFolder, platformArch, null].join('/')\n\n    console.log('target directory %s', dirName)\n\n    return dirName\n  },\n\n  getManifestUrl (folder, version, uploadOsName) {\n    const url = uploadUtils.getUploadUrl()\n\n    la(check.url(url), 'could not get upload url', url)\n\n    return {\n      url: [url, folder, version, uploadOsName, zipName].join('/'),\n    }\n  },\n\n  getRemoteManifest (folder, version) {\n    la(check.unemptyString(folder), 'missing manifest folder', folder)\n    la(check.semver(version), 'invalid manifest version', version)\n\n    const getUrl = this.getManifestUrl.bind(null, folder, version)\n\n    return {\n      name: 'Cypress',\n      version,\n      packages: {\n        // keep these for compatibility purposes\n        // although they are now deprecated\n        mac: getUrl('darwin-x64'),\n        win: getUrl('win32-ia32'),\n        linux64: getUrl('linux-x64'),\n\n        // start adding the new ones\n        // using node's platform\n        darwin: getUrl('darwin-x64'),\n        win32: getUrl('win32-ia32'),\n        linux: getUrl('linux-x64'),\n\n        // the new-new names that use platform and arch as is\n        'darwin-x64': getUrl('darwin-x64'),\n        'linux-x64': getUrl('linux-x64'),\n        'win32-ia32': getUrl('win32-ia32'),\n        'win32-x64': getUrl('win32-x64'),\n      },\n    }\n  },\n\n  createRemoteManifest (folder, version) {\n    const obj = this.getRemoteManifest(folder, version)\n\n    const src = path.resolve('manifest.json')\n\n    return fs.outputJsonAsync(src, obj).return(src)\n  },\n\n  s3Manifest (version) {\n    const publisher = this.getPublisher()\n\n    const aws = this.getAwsObj()\n\n    const headers = {}\n\n    headers['Cache-Control'] = 'no-cache'\n\n    let manifest = null\n\n    return new Promise((resolve, reject) => {\n      return this.createRemoteManifest(aws.folder, version)\n      .then((src) => {\n        manifest = src\n\n        return gulp.src(src)\n        .pipe(rename((p) => {\n          p.dirname = `${aws.folder}/${p.dirname}`\n\n          return p\n        })).pipe(gulpDebug())\n        .pipe(publisher.publish(headers))\n        .pipe(awspublish.reporter())\n        .on('error', reject)\n        .on('end', resolve)\n      })\n    }).finally(() => {\n      return fs.removeAsync(manifest)\n    })\n  },\n\n  toS3 ({ zipFile, version, platform }) {\n    console.log('#uploadToS3 ⏳')\n\n    la(check.unemptyString(version), 'expected version string', version)\n    la(check.unemptyString(zipFile), 'expected zip filename', zipFile)\n    la(check.extension('zip', zipFile),\n      'zip filename should end with .zip', zipFile)\n\n    la(meta.isValidPlatform(platform), 'invalid platform', platform)\n\n    console.log(`zip filename ${zipFile}`)\n\n    if (!fs.existsSync(zipFile)) {\n      throw new Error(`Cannot find zip file ${zipFile}`)\n    }\n\n    const upload = () => {\n      return new Promise((resolve, reject) => {\n        const publisher = this.getPublisher()\n\n        const headers = {}\n\n        headers['Cache-Control'] = 'no-cache'\n\n        return gulp.src(zipFile)\n        .pipe(rename((p) => {\n          // rename to standard filename zipName\n          p.basename = path.basename(zipName, p.extname)\n          p.dirname = this.getUploadDirName({ version, platform })\n\n          return p\n        })).pipe(gulpDebug())\n        .pipe(publisher.publish(headers))\n        .pipe(awspublish.reporter())\n        .on('error', reject)\n        .on('end', resolve)\n      })\n    }\n\n    return upload()\n    .then(() => {\n      return uploadUtils.purgeDesktopAppFromCache({ version, platform, zipName })\n    })\n  },\n}\n",
    "scripts/circle-cache.js": "/* eslint-disable no-console */\nconst globby = require('globby')\nconst path = require('path')\nconst fsExtra = require('fs-extra')\nconst minimist = require('minimist')\nconst crypto = require('crypto')\nconst fs = require('fs')\nconst stringify = require('fast-json-stable-stringify')\nconst rootPackageJson = require('../package.json')\n\nconst opts = minimist(process.argv.slice(2))\n\nasync function circleCache () {\n  switch (opts.action) {\n    case 'prepare': return await prepareCircleCache()\n    case 'unpack': return await unpackCircleCache()\n    case 'cacheKey': return await cacheKey()\n    default: {\n      throw new Error('Expected --action \"prepare\", \"unpack\", or \"cacheKey\"')\n    }\n  }\n}\n\nconst BASE_DIR = path.join(__dirname, '..')\nconst CACHE_DIR = path.join(BASE_DIR, 'globbed_node_modules')\nconst p = (str) => path.join(BASE_DIR, str)\n\nconst workspacePaths = rootPackageJson.workspaces.packages\nconst packageGlobs = workspacePaths.filter((s) => s.endsWith('/*'))\n\n// Gets the sha of all of the patch-package files we have, so we can use this in the cache key.\n// Otherwise, adding/editing a patch will not invalidate the CI cache we have for the yarn install\nasync function cacheKey () {\n  const yarnLocks = [p('yarn.lock')]\n  const patchFiles = await globby(p('**/*.patch'), {\n    ignore: ['**/node_modules/**', '**/*_node_modules/**'],\n  })\n  // TODO: base on workspaces or lerna\n  const packageJsons = await globby([\n    p('package.json'),\n    ...workspacePaths.map((dir) => p(`${dir}/package.json`)),\n  ], {\n    ignore: ['**/node_modules/**', '**/*_node_modules/**'],\n  })\n\n  // Concat the stable stringify of all of the package.json dependencies that make up\n  const hashedPackageDeps = packageJsons.sort().map((abs) => require(abs)).map(\n    ({ name, dependencies, devDependencies, peerDependencies }) => {\n      return hashString(\n        stringify({ name, dependencies, devDependencies, peerDependencies }),\n      )\n    },\n  ).join('')\n\n  const filesToHash = yarnLocks.concat(patchFiles).sort()\n  const hashedFiles = await Promise.all(filesToHash.map((p) => hashFile(p)))\n  const cacheKeySource = hashedFiles.concat(hashedPackageDeps)\n  const cacheKey = hashString(cacheKeySource.join(''))\n\n  // Log to stdout, used by circle to generate cache key\n  console.log(cacheKey)\n}\n\n// Need to dynamically unpack and re-assemble all of the node_modules directories\n// https://discuss.circleci.com/t/dynamic-or-programmatic-caching-of-directories/1455\nasync function prepareCircleCache () {\n  const paths = await globby(\n    packageGlobs.map((dir) => p(`${dir}/node_modules`)),\n    { onlyDirectories: true },\n  )\n\n  await Promise.all(\n    paths.map(async (src) => {\n      await fsExtra.move(\n        src,\n        src\n        .replace(/(.*?)\\/node_modules/, '$1_node_modules')\n        .replace(BASE_DIR, CACHE_DIR),\n      )\n    }),\n  )\n\n  console.log(`Moved globbed node_modules for ${packageGlobs.join(', ')} to ${CACHE_DIR}`)\n}\n\nasync function unpackCircleCache () {\n  const paths = await globby(\n    p(`globbed_node_modules/*/*`),\n    { onlyDirectories: true },\n  )\n\n  await Promise.all(\n    paths.map(async (src) => {\n      await fsExtra.move(\n        src,\n        src\n        .replace(CACHE_DIR, BASE_DIR)\n        .replace(/(.*?)_node_modules/, `$1/node_modules`),\n      )\n    }),\n  )\n\n  console.log(`Unpacked globbed node_modules from ${CACHE_DIR} to ${packageGlobs.join(', ')}`)\n\n  await fsExtra.remove(CACHE_DIR)\n}\n\nfunction hashFile (filePath) {\n  return new Promise(\n    (resolve, reject) => {\n      const hash = crypto.createHash('sha1')\n      const rs = fs.createReadStream(filePath)\n\n      rs.on('error', reject)\n      rs.on('data', (chunk) => {\n        hash.update(chunk)\n      })\n\n      rs.on('end', () => {\n        return resolve(hash.digest('hex'))\n      })\n    },\n  )\n}\n\nfunction hashString (s) {\n  return crypto\n  .createHash('sha1')\n  .update(s)\n  .digest('hex')\n}\n\ncircleCache()\n.then(() => {\n  process.exit(0)\n})\n.catch((e) => {\n  console.error(e)\n  process.exit(1)\n})\n",
    "scripts/github-actions/update-browser-versions.js": "const https = require('https')\nconst fs = require('fs')\n\nconst getLatestVersionData = () => {\n  const options = {\n    hostname: 'omahaproxy.appspot.com',\n    port: 443,\n    path: '/all.json',\n    method: 'GET',\n  }\n\n  return new Promise((resolve, reject) => {\n    const req = https.request(options, (res) => {\n      let response = ''\n\n      res.on('data', (d) => {\n        response += d.toString()\n      })\n\n      res.on('end', () => {\n        resolve(response)\n      })\n    })\n\n    req.on('error', (err) => {\n      reject(err)\n    })\n\n    req.end()\n  })\n}\n\nconst getVersions = async ({ core }) => {\n  try {\n    // file path is relative to repo root\n    const currentBrowserVersions = JSON.parse(fs.readFileSync('./browser-versions.json'))\n    const data = JSON.parse(await getLatestVersionData())\n    const linuxData = data.find((item) => item.os === 'linux')\n    const stableData = linuxData.versions.find((version) => version.channel === 'stable')\n    const betaData = linuxData.versions.find((version) => version.channel === 'beta')\n    const hasStableUpdate = currentBrowserVersions['chrome:stable'] !== stableData.version\n    const hasBetaUpdate = currentBrowserVersions['chrome:beta'] !== betaData.version\n    let description = 'Update '\n\n    if (hasStableUpdate) {\n      description += `Chrome (stable) to ${stableData.version}`\n\n      if (hasBetaUpdate) {\n        description += ' and '\n      }\n    }\n\n    if (hasBetaUpdate) {\n      description += `Chrome (beta) to ${betaData.version}`\n    }\n\n    core.setOutput('has_update', (hasStableUpdate || hasBetaUpdate) ? 'true' : 'false')\n    core.setOutput('current_stable_version', currentBrowserVersions['chrome:stable'])\n    core.setOutput('latest_stable_version', stableData.version)\n    core.setOutput('current_beta_version', currentBrowserVersions['chrome:beta'])\n    core.setOutput('latest_beta_version', betaData.version)\n    core.setOutput('description', description)\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.log('Errored checking for new Chrome versions:', err.stack)\n    core.setOutput('has_update', 'false')\n  }\n}\n\nconst checkNeedForBranchUpdate = ({ core, latestStableVersion, latestBetaVersion }) => {\n  // file path is relative to repo root\n  const branchBrowserVersions = JSON.parse(fs.readFileSync('./browser-versions.json'))\n  const hasNewerStableVersion = branchBrowserVersions['chrome:stable'] !== latestStableVersion\n  const hasNewerBetaVersion = branchBrowserVersions['chrome:beta'] !== latestBetaVersion\n\n  core.setOutput('has_newer_update', (hasNewerStableVersion || hasNewerBetaVersion) ? 'true' : 'false')\n}\n\nconst updateBrowserVersionsFile = ({ latestBetaVersion, latestStableVersion }) => {\n  const versions = {\n    'chrome:beta': latestBetaVersion,\n    'chrome:stable': latestStableVersion,\n  }\n\n  // file path is relative to repo root\n  fs.writeFileSync('./browser-versions.json', `${JSON.stringify(versions, null, 2) }\\n`)\n}\n\nconst updatePRTitle = async ({ context, github, baseBranch, branchName, description }) => {\n  const { data } = await github.pulls.list({\n    owner: context.repo.owner,\n    repo: context.repo.repo,\n    base: baseBranch,\n    head: `${context.repo.owner}:${branchName}`,\n  })\n\n  if (!data.length) {\n    // eslint-disable-next-line no-console\n    console.log('Could not find PR for branch:', branchName)\n\n    return\n  }\n\n  await github.pulls.update({\n    owner: context.repo.owner,\n    repo: context.repo.repo,\n    pull_number: data[0].number,\n    title: `chore: ${description}`,\n  })\n}\n\nconst createPullRequest = async ({ context, github, baseBranch, branchName, description }) => {\n  await github.pulls.create({\n    owner: context.repo.owner,\n    repo: context.repo.repo,\n    base: baseBranch,\n    head: branchName,\n    title: `chore: ${description}`,\n    body: 'This PR was auto-generated to update the version(s) of Chrome for driver tests',\n    maintainer_can_modify: true,\n  })\n}\n\nmodule.exports = {\n  getVersions,\n  checkNeedForBranchUpdate,\n  updateBrowserVersionsFile,\n  updatePRTitle,\n  createPullRequest,\n}\n",
    "cli/lib/tasks/get-folder-size.js": "const fs = require('../fs')\nconst { join } = require('path')\nconst Bluebird = require('bluebird')\n\n/**\n * Get the size of a folder or a file.\n *\n * This function returns the actual file size of the folder (size), not the allocated space on disk (size on disk).\n * For more details between the difference, check this link:\n * https://www.howtogeek.com/180369/why-is-there-a-big-difference-between-size-and-size-on-disk/\n *\n * @param {string} path path to the file or the folder.\n */\nasync function getSize (path) {\n  const stat = await fs.lstat(path)\n\n  if (stat.isDirectory()) {\n    const list = await fs.readdir(path)\n\n    return Bluebird.resolve(list).reduce(async (prev, curr) => {\n      const currPath = join(path, curr)\n\n      const s = await fs.lstat(currPath)\n\n      if (s.isDirectory()) {\n        return prev + await getSize(currPath)\n      }\n\n      return prev + s.size\n    }, 0)\n  }\n\n  return stat.size\n}\n\nmodule.exports = getSize\n",
    "cli/test/lib/cypress_spec.js": "require('../spec_helper')\n\nconst os = require('os')\nconst path = require('path')\nconst R = require('ramda')\nconst snapshot = require('../support/snapshot')\nconst Promise = require('bluebird')\nconst tmp = Promise.promisifyAll(require('tmp'))\nconst mockfs = require('mock-fs')\n\nconst fs = require(`${lib}/fs`)\nconst open = require(`${lib}/exec/open`)\nconst run = require(`${lib}/exec/run`)\nconst cypress = require(`${lib}/cypress`)\n\ndescribe('cypress', function () {\n  beforeEach(function () {\n    mockfs({})\n  })\n\n  afterEach(() => {\n    mockfs.restore()\n  })\n\n  context('.open', function () {\n    beforeEach(function () {\n      sinon.stub(open, 'start').resolves()\n    })\n\n    const getCallArgs = R.path(['lastCall', 'args', 0])\n    const getStartArgs = () => {\n      expect(open.start).to.be.called\n\n      return getCallArgs(open.start)\n    }\n\n    it('calls open#start, passing in options', function () {\n      return cypress.open({ foo: 'foo' })\n      .then(getStartArgs)\n      .then((args) => {\n        expect(args.foo).to.equal('foo')\n      })\n    })\n\n    it('normalizes config object', () => {\n      const config = {\n        pageLoadTime: 10000,\n        watchForFileChanges: false,\n      }\n\n      return cypress.open({ config })\n      .then(getStartArgs)\n      .then((args) => {\n        expect(args).to.deep.eq({ config: JSON.stringify(config) })\n      })\n    })\n\n    it('passes configFile: false', () => {\n      const opts = {\n        configFile: false,\n      }\n\n      return cypress.open(opts)\n      .then(getStartArgs)\n      .then((args) => {\n        expect(args).to.deep.eq(opts)\n      })\n    })\n  })\n\n  context('.run fails to write results file', function () {\n    it('resolves with error object', function () {\n      const outputPath = path.join(os.tmpdir(), 'cypress/monorepo/cypress_spec/output.json')\n\n      sinon.stub(tmp, 'fileAsync').resolves(outputPath)\n      sinon.stub(run, 'start').resolves(2)\n      sinon.stub(fs, 'readJsonAsync').withArgs(outputPath).resolves()\n\n      return cypress.run().then((result) => {\n        expect(result).to.deep.equal({\n          status: 'failed',\n          failures: 2,\n          message: 'Could not find Cypress test run results',\n        })\n      })\n    })\n  })\n\n  context('.run', function () {\n    let outputPath\n\n    beforeEach(function () {\n      outputPath = path.join(os.tmpdir(), 'cypress/monorepo/cypress_spec/output.json')\n      sinon.stub(tmp, 'fileAsync').resolves(outputPath)\n      sinon.stub(run, 'start').resolves()\n\n      return fs.outputJsonAsync(outputPath, {\n        code: 0,\n        failingTests: [],\n      })\n    })\n\n    const getCallArgs = R.path(['lastCall', 'args', 0])\n    const normalizeCallArgs = (args) => {\n      expect(args.outputPath).to.equal(outputPath)\n      delete args.outputPath\n\n      return args\n    }\n    const getStartArgs = () => {\n      expect(run.start).to.be.called\n\n      return normalizeCallArgs(getCallArgs(run.start))\n    }\n\n    it('calls run#start, passing in options', () => {\n      return cypress.run({ spec: 'foo' })\n      .then(getStartArgs)\n      .then((args) => {\n        expect(args.spec).to.equal('foo')\n      })\n    })\n\n    it('normalizes config object', () => {\n      const config = {\n        pageLoadTime: 10000,\n        watchForFileChanges: false,\n      }\n\n      return cypress.run({ config })\n      .then(getStartArgs)\n      .then((args) => {\n        expect(args).to.deep.eq({ config: JSON.stringify(config) })\n      })\n    })\n\n    it('normalizes env option if passed an object', () => {\n      const env = { foo: 'bar', another: 'one' }\n\n      return cypress.run({ env })\n      .then(getStartArgs)\n      .then((args) => {\n        expect(args).to.deep.eq({ env: JSON.stringify(env) })\n      })\n    })\n\n    it('gets random tmp file and passes it to run#start', function () {\n      return cypress.run().then(() => {\n        expect(run.start.lastCall.args[0].outputPath).to.equal(outputPath)\n      })\n    })\n\n    it('resolves with contents of tmp file', () => {\n      return cypress.run().then(snapshot)\n    })\n\n    it('passes configFile: false', () => {\n      const opts = {\n        configFile: false,\n      }\n\n      return cypress.run(opts)\n      .then(getStartArgs)\n      .then((args) => {\n        expect(args).to.deep.eq(opts)\n      })\n    })\n\n    it('rejects if project is an empty string', () => {\n      return expect(cypress.run({ project: '' })).to.be.rejected\n    })\n\n    it('rejects if project is true', () => {\n      return expect(cypress.run({ project: true })).to.be.rejected\n    })\n\n    it('rejects if project is false', () => {\n      return expect(cypress.run({ project: false })).to.be.rejected\n    })\n\n    it('passes quiet: true', () => {\n      const opts = {\n        quiet: true,\n      }\n\n      return cypress.run(opts)\n      .then(getStartArgs)\n      .then((args) => {\n        expect(args).to.deep.eq(opts)\n      })\n    })\n  })\n\n  context('cli', function () {\n    describe('.parseRunArguments', function () {\n      it('parses CLI cypress run arguments', async () => {\n        const args = 'cypress run --browser chrome --spec my/test/spec.js'.split(' ')\n        const options = await cypress.cli.parseRunArguments(args)\n\n        expect(options).to.deep.equal({\n          browser: 'chrome',\n          spec: 'my/test/spec.js',\n        })\n      })\n\n      it('parses CLI cypress run shorthand arguments', async () => {\n        const args = 'cypress run -b firefox -p 5005 --headed --quiet'.split(' ')\n        const options = await cypress.cli.parseRunArguments(args)\n\n        expect(options).to.deep.equal({\n          browser: 'firefox',\n          port: 5005,\n          headed: true,\n          quiet: true,\n        })\n      })\n\n      it('coerces --record and --dev', async () => {\n        const args = 'cypress run --record false --dev true'.split(' ')\n        const options = await cypress.cli.parseRunArguments(args)\n\n        expect(options).to.deep.equal({\n          record: false,\n          dev: true,\n        })\n      })\n\n      it('coerces --config-file false to boolean', async () => {\n        const args = 'cypress run --config-file false'.split(' ')\n        const options = await cypress.cli.parseRunArguments(args)\n\n        expect(options).to.deep.equal({\n          configFile: false,\n        })\n      })\n\n      it('coerces --config-file cypress.json to string', async () => {\n        const args = 'cypress run --config-file cypress.json'.split(' ')\n        const options = await cypress.cli.parseRunArguments(args)\n\n        expect(options).to.deep.equal({\n          configFile: 'cypress.json',\n        })\n      })\n\n      it('parses config file false', async () => {\n        const args = 'cypress run --config-file false'.split(' ')\n        const options = await cypress.cli.parseRunArguments(args)\n\n        expect(options).to.deep.equal({\n          configFile: false,\n        })\n      })\n\n      it('parses config', async () => {\n        const args = 'cypress run --config baseUrl=localhost,video=true'.split(' ')\n        const options = await cypress.cli.parseRunArguments(args)\n\n        // we don't need to convert the config into an object\n        // since the logic inside cypress.run handles that\n        expect(options).to.deep.equal({\n          config: 'baseUrl=localhost,video=true',\n        })\n      })\n\n      it('parses env', async () => {\n        const args = 'cypress run --env MY_NUMBER=42,MY_FLAG=true'.split(' ')\n        const options = await cypress.cli.parseRunArguments(args)\n\n        // we don't need to convert the environment into an object\n        // since the logic inside cypress.run handles that\n        expect(options).to.deep.equal({\n          env: 'MY_NUMBER=42,MY_FLAG=true',\n        })\n      })\n    })\n  })\n})\n",
    "cli/test/lib/exec/info_spec.js": "require('../../spec_helper')\n\nconst os = require('os')\nconst util = require(`${lib}/util`)\nconst state = require(`${lib}/tasks/state`)\nconst info = require(`${lib}/exec/info`)\nconst spawn = require(`${lib}/exec/spawn`)\n\nconst snapshot = require('../../support/snapshot')\nconst stdout = require('../../support/stdout')\nconst normalize = require('../../support/normalize')\n\ndescribe('exec info', function () {\n  beforeEach(function () {\n    sinon.stub(process, 'exit')\n\n    // common stubs\n    sinon.stub(spawn, 'start').resolves()\n    os.platform.returns('linux')\n    sinon.stub(os, 'totalmem').returns(1.2e+9)\n    sinon.stub(os, 'freemem').returns(4e+8)\n    sinon.stub(info, 'findProxyEnvironmentVariables').returns({})\n    sinon.stub(info, 'findCypressEnvironmentVariables').returns({})\n    sinon.stub(util, 'getApplicationDataFolder')\n    .withArgs('browsers').returns('/user/app/data/path/to/browsers')\n    .withArgs().returns('/user/app/data/path')\n\n    sinon.stub(state, 'getCacheDir').returns('/user/path/to/binary/cache')\n  })\n\n  const startInfoAndSnapshot = async (snapshotName) => {\n    expect(snapshotName, 'missing snapshot name').to.be.a('string')\n\n    const output = stdout.capture()\n\n    await info.start()\n    stdout.restore()\n\n    snapshot(snapshotName, normalize(output.toString()))\n  }\n\n  it('prints collected info without env vars', async () => {\n    await startInfoAndSnapshot('cypress info without browsers or vars')\n    expect(spawn.start).to.be.calledWith(['--mode=info'], { dev: undefined })\n  })\n\n  it('prints proxy and cypress env vars', async () => {\n    info.findProxyEnvironmentVariables.returns({\n      PROXY_ENV_VAR1: 'some proxy variable',\n      PROXY_ENV_VAR2: 'another proxy variable',\n    })\n\n    info.findCypressEnvironmentVariables.returns({\n      CYPRESS_ENV_VAR1: 'my Cypress variable',\n      CYPRESS_ENV_VAR2: 'my other Cypress variable',\n    })\n\n    await startInfoAndSnapshot('cypress info with proxy and vars')\n  })\n\n  it('redacts sensitive cypress variables', async () => {\n    info.findCypressEnvironmentVariables.returns({\n      CYPRESS_ENV_VAR1: 'my Cypress variable',\n      CYPRESS_ENV_VAR2: 'my other Cypress variable',\n      CYPRESS_PROJECT_ID: 'abc123', // not sensitive\n      CYPRESS_RECORD_KEY: 'really really secret stuff', // should not be printed\n    })\n\n    await startInfoAndSnapshot('cypress redacts sensitive vars')\n  })\n})\n",
    "cli/test/lib/tasks/cache_spec.js": "require('../../spec_helper')\n\nconst mockfs = require('mock-fs')\n\nconst fs = require(`${lib}/fs`)\nconst state = require(`${lib}/tasks/state`)\nconst util = require(`${lib}/util`)\nconst cache = require(`${lib}/tasks/cache`)\nconst stdout = require('../../support/stdout')\nconst snapshot = require('../../support/snapshot')\nconst dayjs = require('dayjs')\nconst stripAnsi = require('strip-ansi')\nconst path = require('path')\nconst termToHtml = require('term-to-html')\nconst mockedEnv = require('mocked-env')\n\nconst outputHtmlFolder = path.join(__dirname, '..', '..', 'html')\n\ndescribe('lib/tasks/cache', () => {\n  beforeEach(() => {\n    mockfs({\n      '/.cache/Cypress': {\n        '1.2.3': {\n          'Cypress': {\n            'file1': Buffer.from(new Array(32 * 1024).fill(1)),\n            'dir': {\n              'file2': Buffer.from(new Array(128 * 1042).fill(2)),\n            },\n          },\n        },\n        '2.3.4': {\n          'Cypress.app': {},\n        },\n      },\n    })\n\n    sinon.stub(state, 'getCacheDir').returns('/.cache/Cypress')\n    sinon.stub(state, 'getBinaryDir').returns('/.cache/Cypress')\n    sinon.stub(util, 'pkgVersion').returns('1.2.3')\n    this.stdout = stdout.capture()\n  })\n\n  const getSnapshotText = () => {\n    this.stdout = this.stdout.toString().split('\\n').slice(0, -1).join('\\n')\n    const stdoutAsString = this.stdout.toString() || '[no output]'\n\n    // first restore the STDOUT, then confirm the value\n    // otherwise the error might not even appear or appear twice!\n    stdout.restore()\n\n    return stdoutAsString\n  }\n\n  const saveHtml = async (filename, html) => {\n    await fs.ensureDirAsync(outputHtmlFolder)\n    const htmlFilename = path.join(outputHtmlFolder, filename)\n\n    await fs.writeFileAsync(htmlFilename, html, 'utf8')\n  }\n\n  afterEach(() => {\n    mockfs.restore()\n  })\n\n  const defaultSnapshot = (snapshotName) => {\n    const stdoutAsString = getSnapshotText()\n    const withoutAnsi = stripAnsi(stdoutAsString)\n\n    if (snapshotName) {\n      snapshot(snapshotName, withoutAnsi)\n    } else {\n      snapshot(withoutAnsi)\n    }\n  }\n\n  const snapshotWithHtml = async (htmlFilename) => {\n    const stdoutAsString = getSnapshotText()\n\n    snapshot(stripAnsi(stdoutAsString))\n\n    // if the sanitized snapshot matches, let's save the ANSI colors converted into HTML\n    const html = termToHtml.strings(stdoutAsString, termToHtml.themes.dark.name)\n\n    await saveHtml(htmlFilename, html)\n  }\n\n  describe('.path', () => {\n    let restoreEnv\n\n    afterEach(() => {\n      if (restoreEnv) {\n        restoreEnv()\n        restoreEnv = null\n      }\n    })\n\n    it('lists path to cache', () => {\n      cache.path()\n      expect(this.stdout.toString()).to.eql('/.cache/Cypress\\n')\n      defaultSnapshot()\n    })\n\n    it('lists path to cache with silent npm loglevel', () => {\n      restoreEnv = mockedEnv({\n        npm_config_loglevel: 'silent',\n      })\n\n      cache.path()\n      expect(this.stdout.toString()).to.eql('/.cache/Cypress\\n')\n    })\n\n    it('lists path to cache with silent npm warn', () => {\n      restoreEnv = mockedEnv({\n        npm_config_loglevel: 'warn',\n      })\n\n      cache.path()\n      expect(this.stdout.toString()).to.eql('/.cache/Cypress\\n')\n    })\n  })\n\n  describe('.clear', () => {\n    it('deletes cache folder and everything inside it', () => {\n      return cache.clear()\n      .then(() => {\n        return fs.pathExistsAsync('/.cache/Cypress')\n        .then((exists) => {\n          expect(exists).to.eql(false)\n          defaultSnapshot()\n        })\n      })\n    })\n  })\n\n  describe('.prune', () => {\n    it('deletes cache binaries for all version but the current one', async () => {\n      await cache.prune()\n\n      const currentVersion = util.pkgVersion()\n\n      const files = await fs.readdir('/.cache/Cypress')\n\n      expect(files.length).to.eq(1)\n\n      files.forEach((file) => {\n        expect(file).to.eq(currentVersion)\n      })\n\n      defaultSnapshot()\n    })\n\n    it('doesn\\'t delete any cache binaries', async () => {\n      const dir = path.join(state.getCacheDir(), '2.3.4')\n\n      await fs.removeAsync(dir)\n      await cache.prune()\n\n      const currentVersion = util.pkgVersion()\n\n      const files = await fs.readdirAsync('/.cache/Cypress')\n\n      expect(files.length).to.eq(1)\n\n      files.forEach((file) => {\n        expect(file).to.eq(currentVersion)\n      })\n\n      defaultSnapshot()\n    })\n\n    it('exits cleanly if cache dir DNE', async () => {\n      await fs.removeAsync(state.getCacheDir())\n      await cache.prune()\n\n      defaultSnapshot()\n    })\n  })\n\n  describe('.list', () => {\n    let restoreEnv\n\n    afterEach(() => {\n      if (restoreEnv) {\n        restoreEnv()\n        restoreEnv = null\n      }\n    })\n\n    it('lists all versions of cached binary', async function () {\n      // unknown access times\n      sinon.stub(state, 'getPathToExecutable').returns('/.cache/Cypress/1.2.3/app/cypress')\n\n      await cache.list()\n\n      defaultSnapshot()\n    })\n\n    it('lists all versions of cached binary with npm log level silent', async function () {\n      restoreEnv = mockedEnv({\n        npm_config_loglevel: 'silent',\n      })\n\n      // unknown access times\n      sinon.stub(state, 'getPathToExecutable').returns('/.cache/Cypress/1.2.3/app/cypress')\n\n      await cache.list()\n\n      // log output snapshot should have a grid of versions\n      defaultSnapshot('cache list with silent log level')\n    })\n\n    it('lists all versions of cached binary with npm log level warn', async function () {\n      restoreEnv = mockedEnv({\n        npm_config_loglevel: 'warn',\n      })\n\n      // unknown access times\n      sinon.stub(state, 'getPathToExecutable').returns('/.cache/Cypress/1.2.3/app/cypress')\n\n      await cache.list()\n\n      // log output snapshot should have a grid of versions\n      defaultSnapshot('cache list with warn log level')\n    })\n\n    it('lists all versions of cached binary with last access', async function () {\n      sinon.stub(state, 'getPathToExecutable').returns('/.cache/Cypress/1.2.3/app/cypress')\n\n      const statAsync = sinon.stub(fs, 'statAsync')\n\n      statAsync.onFirstCall().resolves({\n        atime: dayjs().subtract(3, 'month').valueOf(),\n      })\n\n      statAsync.onSecondCall().resolves({\n        atime: dayjs().subtract(5, 'day').valueOf(),\n      })\n\n      await cache.list()\n      await snapshotWithHtml('list-of-versions.html')\n    })\n\n    it('some versions have never been opened', async function () {\n      sinon.stub(state, 'getPathToExecutable').returns('/.cache/Cypress/1.2.3/app/cypress')\n\n      const statAsync = sinon.stub(fs, 'statAsync')\n\n      statAsync.onFirstCall().resolves({\n        atime: dayjs().subtract(3, 'month').valueOf(),\n      })\n\n      // the second binary has never been accessed\n      statAsync.onSecondCall().resolves()\n\n      await cache.list()\n      await snapshotWithHtml('second-binary-never-used.html')\n    })\n\n    it('shows sizes', async function () {\n      sinon.stub(state, 'getPathToExecutable').returns('/.cache/Cypress/1.2.3/app/cypress')\n\n      const statAsync = sinon.stub(fs, 'statAsync')\n\n      statAsync.onFirstCall().resolves({\n        atime: dayjs().subtract(3, 'month').valueOf(),\n      })\n\n      // the second binary has never been accessed\n      statAsync.onSecondCall().resolves()\n\n      await cache.list(true)\n      await snapshotWithHtml('show-size.html')\n    })\n  })\n})\n",
    "cli/test/lib/tasks/install_spec.js": "require('../../spec_helper')\nconst _ = require('lodash')\nconst os = require('os')\nconst path = require('path')\nconst chalk = require('chalk')\nconst Promise = require('bluebird')\nconst mockfs = require('mock-fs')\nconst mockedEnv = require('mocked-env')\nconst snapshot = require('../../support/snapshot')\n\nconst stdout = require('../../support/stdout')\n\nconst fs = require(`${lib}/fs`)\nconst download = require(`${lib}/tasks/download`)\nconst install = require(`${lib}/tasks/install`)\nconst state = require(`${lib}/tasks/state`)\nconst unzip = require(`${lib}/tasks/unzip`)\nconst logger = require(`${lib}/logger`)\nconst util = require(`${lib}/util`)\n\nconst normalize = require('../../support/normalize')\n\nconst packageVersion = '1.2.3'\nconst downloadDestination = path.join(os.tmpdir(), `cypress-${process.pid}.zip`)\nconst installDir = '/cache/Cypress/1.2.3'\n\ndescribe('/lib/tasks/install', function () {\n  require('mocha-banner').register()\n\n  beforeEach(function () {\n    this.stdout = stdout.capture()\n\n    // allow simpler log message comparison without\n    // chalk's terminal control strings\n    chalk.level = 0\n  })\n\n  afterEach(() => {\n    stdout.restore()\n\n    chalk.level = 3\n  })\n\n  context('.start', function () {\n    beforeEach(function () {\n      logger.reset()\n\n      // sinon.stub(os, 'tmpdir').returns('/tmp')\n      sinon.stub(util, 'isCi').returns(false)\n      sinon.stub(util, 'isPostInstall').returns(false)\n      sinon.stub(util, 'pkgVersion').returns(packageVersion)\n      sinon.stub(download, 'start').resolves(packageVersion)\n      sinon.stub(unzip, 'start').resolves()\n      sinon.stub(Promise, 'delay').resolves()\n      sinon.stub(fs, 'removeAsync').resolves()\n      sinon.stub(state, 'getVersionDir').returns('/cache/Cypress/1.2.3')\n      sinon.stub(state, 'getBinaryDir').returns('/cache/Cypress/1.2.3/Cypress.app')\n      sinon.stub(state, 'getBinaryPkgAsync').resolves()\n      sinon.stub(fs, 'ensureDirAsync').resolves(undefined)\n      os.platform.returns('darwin')\n    })\n\n    describe('skips install', function () {\n      it('when environment variable is set', function () {\n        process.env.CYPRESS_INSTALL_BINARY = '0'\n\n        return install.start()\n        .then(() => {\n          expect(download.start).not.to.be.called\n\n          snapshot(\n            'skip installation 1',\n            normalize(this.stdout.toString()),\n          )\n        })\n      })\n    })\n\n    describe('override version', function () {\n      it('warns when specifying cypress version in env', function () {\n        const version = '0.12.1'\n\n        process.env.CYPRESS_INSTALL_BINARY = version\n\n        return install.start()\n        .then(() => {\n          expect(download.start).to.be.calledWithMatch({\n            version,\n          })\n\n          expect(unzip.start).to.be.calledWithMatch({\n            zipFilePath: downloadDestination,\n          })\n\n          snapshot(\n            'specify version in env vars 1',\n            normalize(this.stdout.toString()),\n          )\n        })\n      })\n\n      it('trims environment variable before installing', function () {\n        // note how the version has extra spaces around it on purpose\n        const filename = '/tmp/local/file.zip'\n        const version = ` ${filename}   `\n\n        process.env.CYPRESS_INSTALL_BINARY = version\n        // internally, the variable should be trimmed and just filename checked\n        sinon.stub(fs, 'pathExistsAsync').withArgs(filename).resolves(true)\n\n        const installDir = state.getVersionDir()\n\n        return install.start()\n        .then(() => {\n          expect(unzip.start).to.be.calledWithMatch({\n            zipFilePath: filename,\n            installDir,\n          })\n        })\n      })\n\n      it('removes double quotes around the environment variable before installing', function () {\n        // note how the version has extra spaces around it on purpose\n        // and there are double quotes\n        const filename = '/tmp/local/file.zip'\n        const version = ` \"${filename}\"   `\n\n        process.env.CYPRESS_INSTALL_BINARY = version\n        // internally, the variable should be trimmed, double quotes removed\n        //  and just filename checked against the file system\n        sinon.stub(fs, 'pathExistsAsync').withArgs(filename).resolves(true)\n\n        const installDir = state.getVersionDir()\n\n        return install.start()\n        .then(() => {\n          expect(unzip.start).to.be.calledWithMatch({\n            zipFilePath: filename,\n            installDir,\n          })\n        })\n      })\n\n      it('can install local binary zip file without download from absolute path', function () {\n        const version = '/tmp/local/file.zip'\n\n        process.env.CYPRESS_INSTALL_BINARY = version\n        sinon.stub(fs, 'pathExistsAsync').withArgs(version).resolves(true)\n\n        const installDir = state.getVersionDir()\n\n        return install.start()\n        .then(() => {\n          expect(unzip.start).to.be.calledWithMatch({\n            zipFilePath: version,\n            installDir,\n          })\n        })\n      })\n\n      it('can install local binary zip file from relative path', function () {\n        const version = './cypress-resources/file.zip'\n\n        mockfs({\n          [version]: 'asdf',\n        })\n\n        process.env.CYPRESS_INSTALL_BINARY = version\n\n        const installDir = state.getVersionDir()\n\n        return install.start()\n        .then(() => {\n          expect(download.start).not.to.be.called\n          expect(unzip.start).to.be.calledWithMatch({\n            zipFilePath: path.resolve(version),\n            installDir,\n          })\n        })\n      })\n\n      describe('when version is already installed', function () {\n        beforeEach(function () {\n          state.getBinaryPkgAsync.resolves({ version: packageVersion })\n        })\n\n        it('doesn\\'t attempt to download', function () {\n          return install.start()\n          .then(() => {\n            expect(download.start).not.to.be.called\n            expect(state.getBinaryPkgAsync).to.be.calledWith('/cache/Cypress/1.2.3/Cypress.app')\n          })\n        })\n\n        it('logs \\'skipping install\\' when explicit cypress install', function () {\n          return install.start()\n          .then(() => {\n            return snapshot(\n              'version already installed - cypress install 1',\n              normalize(this.stdout.toString()),\n            )\n          })\n        })\n\n        it('logs when already installed when run from postInstall', function () {\n          util.isPostInstall.returns(true)\n\n          return install.start()\n          .then(() => {\n            snapshot(\n              'version already installed - postInstall 1',\n              normalize(this.stdout.toString()),\n            )\n          })\n        })\n      })\n\n      describe('when getting installed version fails', function () {\n        beforeEach(function () {\n          state.getBinaryPkgAsync.resolves(null)\n\n          return install.start()\n        })\n\n        it('logs message and starts download', function () {\n          expect(download.start).to.be.calledWithMatch({\n            version: packageVersion,\n          })\n\n          expect(unzip.start).to.be.calledWithMatch({\n            installDir,\n          })\n\n          snapshot(\n            'continues installing on failure 1',\n            normalize(this.stdout.toString()),\n          )\n        })\n      })\n\n      describe('when there is no install version', function () {\n        beforeEach(function () {\n          state.getBinaryPkgAsync.resolves(null)\n\n          return install.start()\n        })\n\n        it('logs message and starts download', function () {\n          expect(download.start).to.be.calledWithMatch({\n            version: packageVersion,\n          })\n\n          expect(unzip.start).to.be.calledWithMatch({\n            installDir,\n          })\n\n          // cleans up the zip file\n          expect(fs.removeAsync).to.be.calledWith(\n            downloadDestination,\n          )\n\n          snapshot(\n            'installs without existing installation 1',\n            normalize(this.stdout.toString()),\n          )\n        })\n      })\n\n      describe('when getting installed version does not match needed version', function () {\n        beforeEach(function () {\n          state.getBinaryPkgAsync.resolves({ version: 'x.x.x' })\n\n          return install.start()\n        })\n\n        it('logs message and starts download', function () {\n          expect(download.start).to.be.calledWithMatch({\n            version: packageVersion,\n          })\n\n          expect(unzip.start).to.be.calledWithMatch({\n            installDir,\n          })\n\n          snapshot(\n            'installed version does not match needed version 1',\n            normalize(this.stdout.toString()),\n          )\n        })\n      })\n\n      describe('with force: true', function () {\n        beforeEach(function () {\n          state.getBinaryPkgAsync.resolves({ version: packageVersion })\n\n          return install.start({ force: true })\n        })\n\n        it('logs message and starts download', function () {\n          expect(download.start).to.be.calledWithMatch({\n            version: packageVersion,\n          })\n\n          expect(unzip.start).to.be.calledWithMatch({\n            installDir,\n          })\n\n          snapshot(\n            'forcing true always installs 1',\n            normalize(this.stdout.toString()),\n          )\n        })\n      })\n\n      describe('as a global install', function () {\n        beforeEach(function () {\n          sinon.stub(util, 'isInstalledGlobally').returns(true)\n\n          state.getBinaryPkgAsync.resolves({ version: 'x.x.x' })\n\n          return install.start()\n        })\n\n        it('logs global warning and download', function () {\n          expect(download.start).to.be.calledWithMatch({\n            version: packageVersion,\n          })\n\n          expect(unzip.start).to.be.calledWithMatch({\n            installDir,\n          })\n\n          snapshot(\n            'warning installing as global 1',\n            normalize(this.stdout.toString()),\n          )\n        })\n      })\n\n      describe('when running in CI', function () {\n        beforeEach(function () {\n          util.isCi.returns(true)\n\n          state.getBinaryPkgAsync.resolves({ version: 'x.x.x' })\n\n          return install.start()\n        })\n\n        it('uses verbose renderer', function () {\n          snapshot(\n            'installing in ci 1',\n            normalize(this.stdout.toString()),\n          )\n        })\n      })\n\n      describe('failed write access to cache directory', function () {\n        it('logs error on failure', function () {\n          os.platform.returns('darwin')\n          sinon.stub(state, 'getCacheDir').returns('/invalid/cache/dir')\n\n          const err = new Error('EACCES: permission denied, mkdir \\'/invalid\\'')\n\n          err.code = 'EACCES'\n          fs.ensureDirAsync.rejects(err)\n\n          return install.start()\n          .then(() => {\n            throw new Error('should have caught error')\n          })\n          .catch((err) => {\n            logger.error(err)\n\n            snapshot(\n              'invalid cache directory 1',\n              normalize(this.stdout.toString()),\n            )\n          })\n        })\n      })\n\n      describe('CYPRESS_INSTALL_BINARY is URL or Zip', function () {\n        it('uses cache when correct version installed given URL', function () {\n          state.getBinaryPkgAsync.resolves({ version: '1.2.3' })\n          util.pkgVersion.returns('1.2.3')\n          process.env.CYPRESS_INSTALL_BINARY = 'www.cypress.io/cannot-download/2.4.5'\n\n          return install.start()\n          .then(() => {\n            expect(download.start).to.not.be.called\n          })\n        })\n\n        it('uses cache when mismatch version given URL ', function () {\n          state.getBinaryPkgAsync.resolves({ version: '1.2.3' })\n          util.pkgVersion.returns('4.0.0')\n          process.env.CYPRESS_INSTALL_BINARY = 'www.cypress.io/cannot-download/2.4.5'\n\n          return install.start()\n          .then(() => {\n            expect(download.start).to.not.be.called\n          })\n        })\n\n        it('uses cache when correct version installed given Zip', function () {\n          sinon.stub(fs, 'pathExistsAsync').withArgs('/path/to/zip.zip').resolves(true)\n\n          state.getBinaryPkgAsync.resolves({ version: '1.2.3' })\n          util.pkgVersion.returns('1.2.3')\n\n          process.env.CYPRESS_INSTALL_BINARY = '/path/to/zip.zip'\n\n          return install.start()\n          .then(() => {\n            expect(unzip.start).to.not.be.called\n          })\n        })\n\n        it('uses cache when mismatch version given Zip ', function () {\n          sinon.stub(fs, 'pathExistsAsync').withArgs('/path/to/zip.zip').resolves(true)\n\n          state.getBinaryPkgAsync.resolves({ version: '1.2.3' })\n          util.pkgVersion.returns('4.0.0')\n          process.env.CYPRESS_INSTALL_BINARY = '/path/to/zip.zip'\n\n          return install.start()\n          .then(() => {\n            expect(unzip.start).to.not.be.called\n          })\n        })\n      })\n    })\n\n    it('is silent when log level is silent', function () {\n      process.env.npm_config_loglevel = 'silent'\n\n      return install.start()\n      .then(() => {\n        return snapshot(\n          'silent install 1',\n          normalize(`[no output]${this.stdout.toString()}`),\n        )\n      })\n    })\n  })\n\n  context('._getBinaryUrlFromPrereleaseNpmUrl', function () {\n    beforeEach(() => {\n      os.platform.returns('linux')\n      sinon.stub(os, 'arch').returns('x64')\n    })\n\n    it('returns binary url for prerelease npm url', function () {\n      expect(install._getBinaryUrlFromPrereleaseNpmUrl('https://cdn.cypress.io/beta/npm/5.1.1/ciprovider-branchname-sha/cypress.tgz'))\n      .to.eq('https://cdn.cypress.io/beta/binary/5.1.1/linux-x64/ciprovider-branchname-sha/cypress.zip')\n\n      expect(install._getBinaryUrlFromPrereleaseNpmUrl('https://cdn.cypress.io/beta/npm/5.1.1/circle-develop-3fdfc3b453eb38ad3c0b079531e4dde6668e3dd0-436710/cypress.tgz'))\n      .to.eq('https://cdn.cypress.io/beta/binary/5.1.1/linux-x64/circle-develop-3fdfc3b453eb38ad3c0b079531e4dde6668e3dd0-436710/cypress.zip')\n    })\n\n    it('returns nothing for an invalid url', function () {\n      expect(install._getBinaryUrlFromPrereleaseNpmUrl('1.2.3')).to.be.undefined\n      expect(install._getBinaryUrlFromPrereleaseNpmUrl(null)).to.be.undefined\n    })\n  })\n\n  context('._getVersionSpecifier', function () {\n    let restoreEnv\n\n    beforeEach(function () {\n      sinon.stub(fs, 'readJSON').rejects()\n      restoreEnv && restoreEnv()\n    })\n\n    it('resolves undefined if no versionSpecifier found', async function () {\n      expect(await install._getVersionSpecifier('/foo/bar/baz')).to.be.undefined\n    })\n\n    it('resolves with cypress.tgz URL if specified in npm argv', async function () {\n      restoreEnv = mockedEnv({\n        npm_config_argv: JSON.stringify({\n          original: ['npm', 'i', 'https://foo.com/cypress.tgz'],\n        }),\n      })\n\n      expect(await install._getVersionSpecifier('/foo/bar/baz')).to.eq('https://foo.com/cypress.tgz')\n    })\n\n    it('resolves with versionSpecifier from parent pkg.json', async function () {\n      fs.readJSON.withArgs('/foo/bar/baz/package.json').resolves({\n        dependencies: {\n          'cypress': '1.2.3',\n        },\n      })\n\n      fs.readJSON.withArgs('/foo/bar/package.json').resolves({\n        dependencies: {\n          'cypress': 'wrong',\n        },\n      })\n\n      expect(await install._getVersionSpecifier('/foo/bar/baz')).to.eq('1.2.3')\n    })\n\n    it('resolves with devDependencies too', async function () {\n      fs.readJSON.withArgs('/foo/bar/baz/package.json').resolves({\n        devDependencies: {\n          'cypress': '4.5.6',\n        },\n      })\n\n      expect(await install._getVersionSpecifier('/foo/bar/baz')).to.eq('4.5.6')\n    })\n\n    it('resolves with optionalDependencies too', async function () {\n      fs.readJSON.withArgs('/foo/bar/baz/package.json').resolves({\n        optionalDependencies: {\n          'cypress': '6.7.8',\n        },\n      })\n\n      expect(await install._getVersionSpecifier('/foo/bar/baz')).to.eq('6.7.8')\n    })\n\n    context('with win32 path functions and paths', async function () {\n      const oldPath = _.clone(path)\n\n      beforeEach(() => {\n        _.assign(path, path.win32)\n      })\n\n      afterEach(() => {\n        _.assign(path, oldPath)\n      })\n\n      it('resolves undefined if no versionSpecifier found', async function () {\n        expect(await install._getVersionSpecifier('C:\\\\foo\\\\bar\\\\baz')).to.be.undefined\n      })\n\n      it('resolves with versionSpecifier from parent pkg.json', async function () {\n        fs.readJSON.withArgs('C:\\\\foo\\\\bar\\\\baz\\\\package.json').resolves({\n          dependencies: {\n            'cypress': '1.2.3',\n          },\n        })\n\n        fs.readJSON.withArgs('C:\\\\foo\\\\bar\\\\package.json').resolves({\n          dependencies: {\n            'cypress': 'wrong',\n          },\n        })\n\n        expect(await install._getVersionSpecifier('C:\\\\foo\\\\bar\\\\baz')).to.eq('1.2.3')\n      })\n\n      it('resolves with devDependencies too', async function () {\n        fs.readJSON.withArgs('C:\\\\foo\\\\bar\\\\baz\\\\package.json').resolves({\n          devDependencies: {\n            'cypress': '4.5.6',\n          },\n        })\n\n        expect(await install._getVersionSpecifier('C:\\\\foo\\\\bar\\\\baz')).to.eq('4.5.6')\n      })\n\n      it('resolves with optionalDependencies too', async function () {\n        fs.readJSON.withArgs('C:\\\\foo\\\\bar\\\\baz\\\\package.json').resolves({\n          optionalDependencies: {\n            'cypress': '6.7.8',\n          },\n        })\n\n        expect(await install._getVersionSpecifier('C:\\\\foo\\\\bar\\\\baz')).to.eq('6.7.8')\n      })\n    })\n  })\n})\n",
    "npm/angular/src/app/routing/page-one/page-one.component.spec.ts": "import { ComponentFixture, TestBed } from '@angular/core/testing'\n\nimport { PageOneComponent } from './page-one.component'\n\ndescribe('PageOneComponent', () => {\n  let component: PageOneComponent\n  let fixture: ComponentFixture<PageOneComponent>\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [PageOneComponent],\n    }).compileComponents()\n  })\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(PageOneComponent)\n    component = fixture.componentInstance\n    fixture.detectChanges()\n  })\n\n  it('should create', () => {\n    expect(component).toBeTruthy()\n  })\n})\n",
    "npm/create-cypress-tests/scripts/example.js": "const fs = require('fs-extra')\nconst chalk = require('chalk')\nconst path = require('path')\nconst program = require('commander')\n\nprogram\n.command('copy-to [destination]')\n.description('copy cypress/packages/example into destination')\n.action(async (destination) => {\n  const exampleFolder = path.resolve(__dirname, '..', '..', '..', 'packages', 'example', 'cypress')\n  const destinationPath = path.resolve(process.cwd(), destination)\n\n  await fs.remove(destinationPath)\n  await fs.copy(exampleFolder, destinationPath, { recursive: true })\n\n  console.log(`✅ Example was successfully created at ${chalk.cyan(destination)}`)\n\n  await fs.copy(path.join(__dirname, 'example-tsconfig.json'), path.join(destination, 'tsconfig.json'))\n\n  console.log(`✅ tsconfig.json was created for ${chalk.cyan(destination)}`)\n})\n\nprogram.parse(process.argv)\n",
    "npm/create-cypress-tests/src/component-testing/babel/babelTransform.ts": "import path from 'path'\nimport * as fs from 'fs-extra'\nimport * as babel from '@babel/core'\nimport * as babelTypes from '@babel/types'\n\ntype AST = ReturnType<typeof babel.template.ast>\n\nexport type PluginsConfigAst = {\n  RequireAst: AST\n  IfComponentTestingPluginsAst: AST\n  requiresReturnConfig?: true\n}\n\nfunction tryRequirePrettier () {\n  try {\n    return require('prettier')\n  } catch (e) {\n    return null\n  }\n}\nconst sharedBabelOptions = {\n  // disable user config\n  configFile: false,\n  babelrc: false,\n  presets: [],\n  root: process.env.BABEL_TEST_ROOT, // for testing\n}\n\nasync function transformFileViaPlugin (filePath: string, babelPlugin: babel.PluginObj) {\n  try {\n    const initialCode = await fs.readFile(filePath, { encoding: 'utf-8' })\n\n    const updatedResult = await babel.transformAsync(initialCode, {\n      filename: path.basename(filePath),\n      filenameRelative: path.relative(process.cwd(), filePath),\n      plugins: [babelPlugin],\n      ...sharedBabelOptions,\n    })\n\n    if (!updatedResult) {\n      return false\n    }\n\n    let finalCode = updatedResult.code\n\n    if (finalCode === initialCode) {\n      return false\n    }\n\n    const maybePrettier = tryRequirePrettier()\n\n    if (maybePrettier && maybePrettier.format) {\n      finalCode = maybePrettier.format(finalCode, { parser: 'babel' })\n    }\n\n    await fs.writeFile(filePath, finalCode)\n\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nconst returnConfigAst = babel.template.ast('return config; // IMPORTANT to return a config', { preserveComments: true })\n\nexport function createTransformPluginsFileBabelPlugin (ast: PluginsConfigAst): babel.PluginObj {\n  return {\n    visitor: {\n      Program: (path) => {\n        path.unshiftContainer('body', ast.RequireAst)\n      },\n      Function: (path) => {\n        if (!babelTypes.isAssignmentExpression(path.parent)) {\n          return\n        }\n\n        const assignment = path.parent.left\n\n        const isModuleExports =\n        babelTypes.isMemberExpression(assignment)\n        && babelTypes.isIdentifier(assignment.object)\n        && assignment.object.name === 'module'\n        && babelTypes.isIdentifier(assignment.property)\n        && assignment.property.name === 'exports'\n\n        if (isModuleExports && babelTypes.isFunction(path.parent.right)) {\n          const paramsLength = path.parent.right.params.length\n\n          if (paramsLength === 0) {\n            path.parent.right.params.push(babelTypes.identifier('on'))\n            path.parent.right.params.push(babelTypes.identifier('config'))\n          }\n\n          if (paramsLength === 1) {\n            path.parent.right.params.push(babelTypes.identifier('config'))\n          }\n\n          const statementToInject = Array.isArray(ast.IfComponentTestingPluginsAst)\n            ? ast.IfComponentTestingPluginsAst\n            : [ast.IfComponentTestingPluginsAst]\n\n          const ifComponentMode = babelTypes.ifStatement(\n            babelTypes.binaryExpression(\n              '===',\n              babelTypes.identifier('config.testingType'),\n              babelTypes.stringLiteral('component'),\n            ),\n            babelTypes.blockStatement(statementToInject as babelTypes.Statement[] | babelTypes.Statement[]),\n          )\n\n          path.get('body').pushContainer('body' as never, ifComponentMode as babel.Node)\n\n          if (ast.requiresReturnConfig) {\n            path.get('body').pushContainer('body' as never, returnConfigAst)\n          }\n        }\n      },\n    },\n  }\n}\n\nexport async function injectPluginsCode (pluginsFilePath: string, ast: PluginsConfigAst) {\n  return transformFileViaPlugin(pluginsFilePath, createTransformPluginsFileBabelPlugin(ast))\n}\n\nexport async function getPluginsSourceExample (ast: PluginsConfigAst) {\n  const exampleCode = [\n    'module.exports = (on, config) => {',\n    '',\n    '}',\n  ].join('\\n')\n\n  try {\n    const babelResult = await babel.transformAsync(exampleCode, {\n      filename: 'nothing.js',\n      plugins: [createTransformPluginsFileBabelPlugin(ast)],\n      ...sharedBabelOptions,\n    })\n\n    if (!babelResult?.code) {\n      throw new Error()\n    }\n\n    return babelResult.code\n  } catch (e) {\n    throw new Error('Can not generate code example for plugins file because of unhandled error. Please update the plugins file manually.')\n  }\n}\n",
    "npm/create-cypress-tests/src/component-testing/init-component-testing.test.ts": "import path from 'path'\nimport fs from 'fs-extra'\nimport snapshot from 'snap-shot-it'\nimport { expect, use } from 'chai'\nimport sinon, { SinonStub, SinonSpy } from 'sinon'\nimport chalk from 'chalk'\nimport mockFs from 'mock-fs'\nimport { initComponentTesting } from './init-component-testing'\nimport inquirer from 'inquirer'\nimport sinonChai from 'sinon-chai'\nimport childProcess from 'child_process'\nimport { someOfSpyCallsIncludes } from '../test-utils'\n\nuse(sinonChai)\n\ndescribe('init component tests script', () => {\n  let promptSpy: SinonStub<any> | null = null\n  let logSpy: SinonSpy | null = null\n  let processExitStub: SinonStub<any> | null = null\n  let execStub: SinonStub | null = null\n\n  const e2eTestOutputPath = path.resolve(__dirname, '..', 'test-output')\n  const cypressConfigPath = path.join(e2eTestOutputPath, 'cypress.json')\n\n  beforeEach(async () => {\n    logSpy = sinon.spy(global.console, 'log')\n    // @ts-ignores\n    execStub = sinon.stub(childProcess, 'exec').callsFake((command, callback) => callback())\n    processExitStub = sinon.stub(process, 'exit').callsFake(() => {\n      throw new Error(`${chalk.red('process.exit')} should not be called`)\n    })\n\n    await fs.remove(e2eTestOutputPath)\n    await fs.mkdir(e2eTestOutputPath)\n\n    process.env.BABEL_TEST_ROOT = e2eTestOutputPath\n  })\n\n  afterEach(() => {\n    mockFs.restore()\n    logSpy?.restore()\n    promptSpy?.restore()\n    processExitStub?.restore()\n    execStub?.restore()\n  })\n\n  function createTempFiles (tempFiles: Record<string, string>) {\n    Object.entries(tempFiles).forEach(([fileName, content]) => {\n      fs.outputFileSync(\n        path.join(e2eTestOutputPath, fileName),\n        content,\n      )\n    })\n  }\n\n  function snapshotGeneratedFiles (name: string) {\n    snapshot(\n      `${name} cypress.json`,\n      fs.readFileSync(\n        path.join(e2eTestOutputPath, 'cypress.json'),\n        { encoding: 'utf-8' },\n      ),\n    )\n\n    snapshot(\n      `${name} plugins/index.js`,\n      fs.readFileSync(\n        path.join(e2eTestOutputPath, 'cypress', 'plugins', 'index.js'),\n        { encoding: 'utf-8' },\n      ),\n    )\n\n    const supportFile = fs.readFileSync(\n      path.join(e2eTestOutputPath, 'cypress', 'support', 'index.js'),\n      { encoding: 'utf-8' },\n    )\n\n    // Comparing empty snapshot errors.\n    if (supportFile.length === 0) {\n      return\n    }\n\n    snapshot(\n      `${name} support/index.js`,\n      fs.readFileSync(\n        path.join(e2eTestOutputPath, 'cypress', 'support', 'index.js'),\n        { encoding: 'utf-8' },\n      ),\n    )\n  }\n\n  it('determines more presumable configuration to suggest', async () => {\n    createTempFiles({\n      '/cypress.json': '{}',\n      '/cypress/support/index.js': '',\n      '/cypress/plugins/index.js': 'module.exports = (on, config) => {}',\n      // For next.js user will have babel config, but we want to suggest to use the closest config for the application code\n      '/babel.config.js': 'module.exports = { }',\n      '/package.json': JSON.stringify({ dependencies: { react: '^17.x', next: '^9.2.0' } }),\n    })\n\n    promptSpy = sinon.stub(inquirer, 'prompt').returns(Promise.resolve({\n      chosenTemplateName: 'next.js',\n      componentFolder: 'src',\n    }) as any)\n\n    await initComponentTesting({ config: {}, cypressConfigPath, useYarn: true })\n\n    const [{ choices }] = (inquirer.prompt as any).args[0][0]\n\n    expect(choices[0]).to.equal('next.js')\n    snapshotGeneratedFiles('injects guessed next.js template')\n  })\n\n  it('automatically suggests to the user which config to use', async () => {\n    createTempFiles({\n      '/cypress.json': '{}',\n      '/cypress/support/index.js': 'import \"./commands.js\";',\n      '/cypress/plugins/index.js': 'module.exports = () => {}',\n      '/package.json': JSON.stringify({\n        dependencies: {\n          react: '^16.10.0',\n        },\n      }),\n      '/webpack.config.js': 'module.exports = { }',\n    })\n\n    promptSpy = sinon.stub(inquirer, 'prompt').returns(Promise.resolve({\n      chosenTemplateName: 'create-react-app',\n      componentFolder: 'cypress/component',\n    }) as any)\n\n    await initComponentTesting({ config: {}, cypressConfigPath, useYarn: true })\n    const [{ choices, message }] = (inquirer.prompt as any).args[0][0]\n\n    expect(choices[0]).to.equal('webpack')\n    expect(message).to.contain(\n      `Press ${chalk.inverse(' Enter ')} to continue with ${chalk.green(\n        'webpack',\n      )} configuration`,\n    )\n\n    snapshotGeneratedFiles('Injected overridden webpack template')\n  })\n\n  it('Asks for preferred bundling tool if can not determine the right one', async () => {\n    createTempFiles({\n      '/cypress.json': '{}',\n      '/webpack.config.js': 'module.exports = { }',\n      '/package.json': JSON.stringify({ dependencies: { } }),\n    })\n\n    promptSpy = sinon.stub(inquirer, 'prompt')\n    .onCall(0)\n    .returns(Promise.resolve({\n      framework: 'vue@2',\n    }) as any)\n    .onCall(1)\n    .returns(Promise.resolve({\n      chosenTemplateName: 'webpack',\n      componentFolder: 'src',\n    }) as any)\n\n    await initComponentTesting({ config: {}, cypressConfigPath, useYarn: true })\n\n    expect(\n      someOfSpyCallsIncludes(global.console.log, 'We were unable to automatically determine your framework 😿'),\n    ).to.be.true\n  })\n\n  it('Asks for framework if more than 1 option was auto detected', async () => {\n    createTempFiles({\n      '/cypress.json': '{}',\n      '/webpack.config.js': 'module.exports = { }',\n      '/package.json': JSON.stringify({ dependencies: { react: '*', vue: '^2.4.5' } }),\n    })\n\n    promptSpy = sinon.stub(inquirer, 'prompt')\n    .onCall(0)\n    .returns(Promise.resolve({\n      framework: 'vue@3',\n    }) as any)\n    .onCall(1)\n    .returns(Promise.resolve({\n      chosenTemplateName: 'webpack',\n      componentFolder: 'src',\n    }) as any)\n\n    await initComponentTesting({ config: {}, cypressConfigPath, useYarn: true })\n\n    expect(\n      someOfSpyCallsIncludes(global.console.log, `It looks like all these frameworks: ${chalk.yellow('react, vue@2')} are available from this directory.`),\n    ).to.be.true\n  })\n\n  it('installs the right adapter', async () => {\n    createTempFiles({\n      '/cypress.json': '{}',\n      '/webpack.config.js': 'module.exports = { }',\n      '/package.json': JSON.stringify({ dependencies: { react: '16.4.5' } }),\n    })\n\n    promptSpy = sinon.stub(inquirer, 'prompt')\n    .onCall(0)\n    .returns(Promise.resolve({\n      chosenTemplateName: 'vite',\n      componentFolder: 'src',\n    }) as any)\n\n    await initComponentTesting({ config: {}, cypressConfigPath, useYarn: true })\n    expect(execStub).to.be.calledWith('yarn add @cypress/react --dev')\n  })\n\n  it('installs the right adapter for vue 3', async () => {\n    createTempFiles({\n      '/cypress.json': '{}',\n      '/vite.config.js': 'module.exports = { }',\n      '/package.json': JSON.stringify({ dependencies: { vue: '^3.0.0' } }),\n    })\n\n    promptSpy = sinon.stub(inquirer, 'prompt')\n    .onCall(0)\n    .returns(Promise.resolve({\n      chosenTemplateName: 'vite',\n      componentFolder: 'src',\n    }) as any)\n\n    await initComponentTesting({ config: {}, cypressConfigPath, useYarn: true })\n    expect(execStub).to.be.calledWith('yarn add @cypress/vue@3 --dev')\n  })\n\n  it('suggest the right instruction based on user template choice', async () => {\n    createTempFiles({\n      '/package.json': JSON.stringify({\n        dependencies: {\n          react: '^16.0.0',\n        },\n      }),\n      '/cypress.json': '{}',\n    })\n\n    promptSpy = sinon.stub(inquirer, 'prompt').returns(Promise.resolve({\n      chosenTemplateName: 'create-react-app',\n      componentFolder: 'src',\n    }) as any)\n\n    await initComponentTesting({ config: {}, cypressConfigPath, useYarn: true })\n    expect(\n      someOfSpyCallsIncludes(\n        global.console.log,\n        'https://github.com/cypress-io/cypress/tree/develop/npm/react/examples/react-scripts',\n      ),\n    ).to.be.true\n  })\n\n  it('suggests right docs example and cypress.json config based on the `componentFolder` answer', async () => {\n    createTempFiles({\n      '/cypress.json': '{}',\n      '/package.json': JSON.stringify({\n        dependencies: {\n          react: '^16.0.0',\n        },\n      }),\n    })\n\n    sinon.stub(inquirer, 'prompt').returns(Promise.resolve({\n      chosenTemplateName: 'create-react-app',\n      componentFolder: 'cypress/component',\n    }) as any)\n\n    await initComponentTesting({ config: {}, cypressConfigPath, useYarn: true })\n\n    const injectedCode = fs.readFileSync(path.join(e2eTestOutputPath, 'cypress.json'), { encoding: 'utf-8' })\n\n    expect(injectedCode).to.equal(JSON.stringify(\n      {\n        componentFolder: 'cypress/component',\n        testFiles: '**/*.spec.{js,ts,jsx,tsx}',\n      },\n      null,\n      2,\n    ))\n  })\n\n  it('Shows help message if cypress files are not created', async () => {\n    createTempFiles({\n      '/cypress.json': '{}',\n      '/package.json': JSON.stringify({\n        dependencies: {\n          react: '^16.0.0',\n        },\n      }),\n    })\n\n    sinon.stub(inquirer, 'prompt').returns(Promise.resolve({\n      chosenTemplateName: 'create-react-app',\n      componentFolder: 'cypress/component',\n    }) as any)\n\n    await initComponentTesting({ config: {}, cypressConfigPath, useYarn: true })\n\n    expect(\n      someOfSpyCallsIncludes(\n        global.console.log,\n        'was not updated automatically. Please add the following config manually:',\n      ),\n    ).to.be.true\n  })\n\n  it('Doesn\\'t affect injected code if user has custom babel.config.js', async () => {\n    createTempFiles({\n      '/cypress/plugins/index.js': 'module.exports = (on, config) => {}',\n      '/cypress.json': '{}',\n      'babel.config.js': `module.exports = ${JSON.stringify({\n        presets: [\n          '@babel/preset-env',\n        ],\n      })}`,\n      '/package.json': JSON.stringify({\n        dependencies: {\n          babel: '*',\n          react: '^16.0.0',\n        },\n      }),\n    })\n\n    sinon.stub(inquirer, 'prompt').returns(Promise.resolve({\n      chosenTemplateName: 'create-react-app',\n      componentFolder: 'cypress/component',\n    }) as any)\n\n    await initComponentTesting({ config: {}, cypressConfigPath, useYarn: true })\n    const babelPluginsOutput = await fs.readFile(\n      path.join(e2eTestOutputPath, 'cypress', 'plugins', 'index.js'),\n      'utf-8',\n    )\n\n    expect(babelPluginsOutput).not.to.contain('use strict')\n    expect(babelPluginsOutput).to.contain('module.exports = (on, config) => {')\n  })\n})\n",
    "npm/create-cypress-tests/src/component-testing/init-component-testing.ts": "import fs from 'fs-extra'\nimport path from 'path'\nimport chalk from 'chalk'\nimport inquirer from 'inquirer'\nimport highlight from 'cli-highlight'\nimport { Template } from './templates/Template'\nimport { guessTemplate } from './templates/guessTemplate'\nimport { installFrameworkAdapter } from './installFrameworkAdapter'\nimport { injectPluginsCode, getPluginsSourceExample } from './babel/babelTransform'\nimport { installDependency } from '../utils'\n\nasync function injectOrShowConfigCode (injectFn: () => Promise<boolean>, {\n  code,\n  filePath,\n  fallbackFileMessage,\n  language,\n}: {\n  code: string\n  filePath: string\n  language: string\n  fallbackFileMessage: string\n}) {\n  const fileExists = fs.existsSync(filePath)\n  const readableFilePath = fileExists ? path.relative(process.cwd(), filePath) : fallbackFileMessage\n\n  const printCode = () => {\n    console.log()\n    console.log(highlight(code, { language }))\n    console.log()\n  }\n\n  const printSuccess = () => {\n    console.log(`✅  ${chalk.bold.green(readableFilePath)} was updated with the following config:`)\n    printCode()\n  }\n\n  const printFailure = () => {\n    console.log(`❌  ${chalk.bold.red(readableFilePath)} was not updated automatically. Please add the following config manually: `)\n    printCode()\n  }\n\n  if (!fileExists) {\n    printFailure()\n\n    return\n  }\n\n  // something get completely wrong when using babel or something. Print error message.\n  const injected = await injectFn().catch(() => false)\n\n  injected ? printSuccess() : printFailure()\n}\n\nasync function injectAndShowCypressJsonConfig (\n  cypressJsonPath: string,\n  componentFolder: string,\n) {\n  const configToInject = {\n    componentFolder,\n    testFiles: '**/*.spec.{js,ts,jsx,tsx}',\n  }\n\n  async function autoInjectCypressJson () {\n    const currentConfig = JSON.parse(await fs.readFile(cypressJsonPath, { encoding: 'utf-8' }))\n\n    await fs.writeFile(cypressJsonPath, JSON.stringify({\n      ...currentConfig,\n      ...configToInject,\n    }, null, 2))\n\n    return true\n  }\n\n  await injectOrShowConfigCode(autoInjectCypressJson, {\n    code: JSON.stringify(configToInject, null, 2),\n    language: 'js',\n    filePath: cypressJsonPath,\n    fallbackFileMessage: 'cypress.json config file',\n  })\n}\n\nasync function injectAndShowPluginConfig<T> (template: Template<T>, {\n  templatePayload,\n  pluginsFilePath,\n  cypressProjectRoot,\n}: {\n  templatePayload: T | null\n  pluginsFilePath: string\n  cypressProjectRoot: string\n}) {\n  const ast = template.getPluginsCodeAst(templatePayload, { cypressProjectRoot })\n\n  await injectOrShowConfigCode(() => injectPluginsCode(pluginsFilePath, ast), {\n    code: await getPluginsSourceExample(ast),\n    language: 'js',\n    filePath: pluginsFilePath,\n    fallbackFileMessage: 'plugins file (https://docs.cypress.io/guides/core-concepts/writing-and-organizing-tests.html#Plugin-files)',\n  })\n}\n\ntype InitComponentTestingOptions = {\n  config: Record<string, string>\n  cypressConfigPath: string\n  useYarn: boolean\n}\n\nexport async function initComponentTesting<T> ({ config, useYarn, cypressConfigPath }: InitComponentTestingOptions) {\n  const cypressProjectRoot = path.resolve(cypressConfigPath, '..')\n\n  const framework = await installFrameworkAdapter(cypressProjectRoot, { useYarn })\n  const {\n    possibleTemplates,\n    defaultTemplate,\n    defaultTemplateName,\n    templatePayload,\n  } = await guessTemplate<T>(framework, cypressProjectRoot)\n\n  const pluginsFilePath = path.resolve(\n    cypressProjectRoot,\n    config.pluginsFile ?? './cypress/plugins/index.js',\n  )\n\n  const templateChoices = Object.keys(possibleTemplates).sort((key) => {\n    return key === defaultTemplateName ? -1 : 0\n  })\n\n  const {\n    chosenTemplateName,\n    componentFolder,\n  }: Record<string, string> = await inquirer.prompt([\n    {\n      type: 'list',\n      name: 'chosenTemplateName',\n      choices: templateChoices,\n      default: defaultTemplate ? 0 : undefined,\n      message: defaultTemplate?.message\n        ? `${defaultTemplate?.message}\\n\\n Press ${chalk.inverse(\n          ' Enter ',\n        )} to continue with ${chalk.green(\n          defaultTemplateName,\n        )} configuration or select another template from the list:`\n        : 'We were not able to automatically determine which framework or bundling tool you are using. Please choose one from the list:',\n    },\n    {\n      type: 'input',\n      name: 'componentFolder',\n      filter: (input) => input.trim(),\n      validate: (input) => {\n        return input === '' || !/^[a-zA-Z].*/.test(input)\n          ? `Directory \"${input}\" is invalid`\n          : true\n      },\n      message: 'Which folder would you like to use for your component tests?',\n      default: (answers: { chosenTemplateName: keyof typeof possibleTemplates }) => {\n        return possibleTemplates[answers.chosenTemplateName].recommendedComponentFolder\n      },\n    },\n  ])\n\n  const chosenTemplate = possibleTemplates[chosenTemplateName] as Template<T>\n\n  console.log()\n  console.log(`Installing required dependencies`)\n  console.log()\n\n  for (const dependency of chosenTemplate.dependencies) {\n    await installDependency(dependency, { useYarn })\n  }\n\n  console.log()\n  console.log(`Let's setup everything for component testing with ${chalk.cyan(chosenTemplateName)}:`)\n  console.log()\n\n  await injectAndShowCypressJsonConfig(cypressConfigPath, componentFolder)\n  await injectAndShowPluginConfig(chosenTemplate, {\n    templatePayload,\n    pluginsFilePath,\n    cypressProjectRoot,\n  })\n\n  if (chosenTemplate.printHelper) {\n    chosenTemplate.printHelper()\n  }\n\n  console.log(\n    `Find examples of component tests for ${chalk.green(\n      chosenTemplateName,\n    )} in ${chalk.underline(chosenTemplate.getExampleUrl({ componentFolder }))}.`,\n  )\n\n  if (framework === 'react') {\n    console.log()\n\n    console.log(\n      `Docs for different recipes of bundling tools: ${chalk.bold.underline(\n        'https://github.com/cypress-io/cypress/tree/develop/npm/react/docs/recipes.md',\n      )}`,\n    )\n  }\n\n  // render delimiter\n  console.log()\n  console.log(new Array(process.stdout.columns).fill('═').join(''))\n  console.log()\n}\n",
    "npm/create-cypress-tests/src/component-testing/installFrameworkAdapter.ts": "import chalk from 'chalk'\nimport inquirer from 'inquirer'\nimport { scanFSForAvailableDependency } from '../findPackageJson'\nimport { installDependency } from '../utils'\n\nasync function guessOrAskForFramework (cwd: string): Promise<'react' | 'vue@2' | 'vue@3'> {\n  // please sort this alphabetically\n  const frameworks = {\n    react: () => scanFSForAvailableDependency(cwd, { react: '*', 'react-dom': '*' }),\n    'vue@2': () => scanFSForAvailableDependency(cwd, { vue: '2.x' }),\n    'vue@3': () => scanFSForAvailableDependency(cwd, { vue: '3.x' }),\n  }\n\n  const guesses = Object.keys(frameworks).filter((framework) => {\n    return frameworks[framework as keyof typeof frameworks]()\n  }) as Array<'react' | 'vue@2' | 'vue@3'>\n\n  // found 1 precise guess. Continue\n  if (guesses.length === 1) {\n    const framework = guesses[0]\n\n    console.log(`\\nThis project is using ${chalk.bold.cyan(framework)}. Let's install the right adapter:`)\n\n    return framework\n  }\n\n  if (guesses.length === 0) {\n    console.log(`We were unable to automatically determine your framework 😿. ${chalk.grey('Make sure to run this command from the directory where your components located in order to make smart detection works. Or continue with manual setup:')}`)\n  }\n\n  if (guesses.length > 0) {\n    console.log(`It looks like all these frameworks: ${chalk.yellow(guesses.join(', '))} are available from this directory. ${chalk.grey('Make sure to run this command from the directory where your components located in order to make smart detection works. Or continue with manual setup:')}`)\n  }\n\n  const { framework } = await inquirer.prompt([\n    {\n      type: 'list',\n      name: 'framework',\n      choices: Object.keys(frameworks),\n      message: `Which framework do you use?`,\n    },\n  ])\n\n  return framework\n}\n\ntype InstallAdapterOptions = {\n  useYarn: boolean\n}\n\nexport async function installFrameworkAdapter (cwd: string, options: InstallAdapterOptions) {\n  const framework = await guessOrAskForFramework(cwd)\n\n  await installDependency(`@cypress/${framework}`, options)\n\n  return framework\n}\n",
    "npm/create-cypress-tests/src/initialTemplate.ts": "import path from 'path'\nimport fs from 'fs-extra'\n\nconst INITIAL_TEMPLATE_PATH = path.resolve(__dirname, '..', 'initial-template')\n\nexport async function getInitialSupportFilesPaths () {\n  return (\n    await fs.readdir(path.join(INITIAL_TEMPLATE_PATH, 'support'))\n  ).map((filename) => path.join(INITIAL_TEMPLATE_PATH, 'support', filename))\n}\n\nexport function getInitialPluginsFilePath () {\n  return path.join(INITIAL_TEMPLATE_PATH, 'plugins', 'index.js')\n}\n\nexport function getInitialTsConfigPath () {\n  return path.join(INITIAL_TEMPLATE_PATH, 'tsconfig.json')\n}\n",
    "npm/create-cypress-tests/src/installCypress.ts": "import fs from 'fs-extra'\nimport findUp from 'find-up'\nimport path from 'path'\nimport { installDependency } from './utils'\nimport chalk from 'chalk'\nimport ora from 'ora'\nimport * as initialTemplate from './initialTemplate'\n\ntype InstallCypressOpts = {\n  useYarn: boolean\n  useTypescript: boolean\n  ignoreExamples: boolean\n}\n\nasync function copyFiles ({ ignoreExamples, useTypescript }: InstallCypressOpts) {\n  let fileSpinner = ora('Creating config files').start()\n\n  await fs.outputFile(path.resolve(process.cwd(), 'cypress.json'), '{}\\n')\n  await fs.copy(\n    initialTemplate.getInitialPluginsFilePath(),\n    path.resolve('cypress', 'plugins/index.js'),\n  )\n\n  const supportFiles: string[] = await initialTemplate.getInitialSupportFilesPaths()\n\n  await Promise.all(\n    supportFiles.map((supportFilePath) => {\n      const newSupportFilePath = path.resolve('cypress', 'support', path.basename(supportFilePath))\n\n      return fs.copy(supportFilePath, newSupportFilePath)\n    }),\n  )\n\n  if (useTypescript) {\n    await fs.copy(initialTemplate.getInitialTsConfigPath(), path.resolve('cypress', 'tsconfig.json'))\n  }\n\n  // TODO think about better approach\n  if (ignoreExamples) {\n    const dummySpec = [\n      'describe(\"Spec\", () => {',\n      '',\n      '})',\n      '',\n    ].join('\\n')\n\n    const specFileToCreate = path.resolve('cypress', 'integration', useTypescript ? 'spec.ts' : 'spec.js')\n\n    await fs.outputFile(path.resolve('cypress', 'integration', useTypescript ? 'spec.js' : 'spec.ts'), dummySpec)\n    console.log(`In order to ignore examples a spec file ${chalk.green(path.relative(process.cwd(), specFileToCreate))}.`)\n  }\n\n  fileSpinner.succeed()\n}\n\nexport async function findInstalledOrInstallCypress (options: InstallCypressOpts) {\n  let cypressJsonPath = await findUp('cypress.json')\n\n  if (!cypressJsonPath) {\n    await installDependency('cypress', options)\n    await copyFiles(options)\n\n    cypressJsonPath = await findUp('cypress.json')\n  }\n\n  if (!cypressJsonPath) {\n    throw new Error('Unexpected error during cypress installation.')\n  }\n\n  return {\n    cypressConfigPath: cypressJsonPath,\n    config: JSON.parse(\n      fs.readFileSync(cypressJsonPath, { encoding: 'utf-8' }).toString(),\n    ) as Record<string, string>,\n  }\n}\n",
    "npm/create-cypress-tests/src/main.test.ts": "import { expect, use } from 'chai'\nimport path from 'path'\nimport sinon, { SinonStub, SinonSpy, SinonSpyCallApi } from 'sinon'\nimport mockFs from 'mock-fs'\nimport fsExtra from 'fs-extra'\nimport { main } from './main'\nimport sinonChai from 'sinon-chai'\nimport childProcess from 'child_process'\n\nuse(sinonChai)\n\nfunction mockFsWithInitialTemplate (...args: Parameters<typeof mockFs>) {\n  const [fsConfig, options] = args\n\n  mockFs({\n    ...fsConfig,\n    // @ts-expect-error Load required template files\n    [path.resolve(__dirname, '..', 'initial-template')]: mockFs.load(path.resolve(__dirname, '..', 'initial-template')),\n  }, options)\n}\n\nfunction someOfSpyCallsIncludes (spy: any, logPart: string) {\n  return spy.getCalls().some(\n    (spy: SinonSpyCallApi<unknown[]>) => {\n      return spy.args.some((callArg) => typeof callArg === 'string' && callArg.includes(logPart))\n    },\n  )\n}\n\ndescribe('create-cypress-tests', () => {\n  let promptSpy: SinonStub<any> | null = null\n  let logSpy: SinonSpy | null = null\n  let errorSpy: SinonSpy | null = null\n  let execStub: SinonStub | null = null\n  let fsCopyStub: SinonStub | null = null\n  let processExitStub: SinonStub | null = null\n\n  beforeEach(() => {\n    logSpy = sinon.spy(global.console, 'log')\n    errorSpy = sinon.spy(global.console, 'error')\n    // @ts-ignore\n    execStub = sinon.stub(childProcess, 'exec').callsFake((command, callback) => callback())\n    // @ts-ignore\n    fsCopyStub = sinon.stub(fsExtra, 'copy').returns(Promise.resolve())\n    processExitStub = sinon.stub(process, 'exit').callsFake(() => {\n      throw new Error('process.exit should not be called')\n    })\n  })\n\n  afterEach(() => {\n    mockFs.restore()\n    logSpy?.restore()\n    promptSpy?.restore()\n    execStub?.restore()\n    fsCopyStub?.restore()\n    processExitStub?.restore()\n    execStub?.restore()\n    errorSpy?.restore()\n  })\n\n  it('Install cypress if no config found', async () => {\n    mockFsWithInitialTemplate({\n      '/package.json': JSON.stringify({ }),\n    })\n\n    await main({ useNpm: false, ignoreTs: false, ignoreExamples: false, setupComponentTesting: false })\n\n    expect(execStub).calledWith('yarn add cypress --dev')\n  })\n\n  it('Uses npm if yarn is not available', async () => {\n    execStub\n    ?.onFirstCall().callsFake((command, callback) => callback('yarn is not available'))\n    ?.onSecondCall().callsFake((command, callback) => callback())\n    ?.onThirdCall().callsFake((command, callback) => callback())\n\n    mockFsWithInitialTemplate({\n      '/package.json': JSON.stringify({ }),\n    })\n\n    await main({ useNpm: false, ignoreTs: false, ignoreExamples: false, setupComponentTesting: false })\n    expect(execStub).calledWith('npm install -D cypress')\n  })\n\n  it('Uses npm if --use-npm was provided', async () => {\n    mockFsWithInitialTemplate({\n      '/package.json': JSON.stringify({ }),\n    })\n\n    await main({ useNpm: true, ignoreTs: false, ignoreExamples: false, setupComponentTesting: false })\n\n    expect(execStub).calledWith('npm install -D cypress')\n  })\n\n  it('Prints correct commands helper for npm', async () => {\n    mockFsWithInitialTemplate({\n      '/package.json': JSON.stringify({ }),\n    })\n\n    await main({ useNpm: true, ignoreTs: false, ignoreExamples: false, setupComponentTesting: false })\n    expect(someOfSpyCallsIncludes(logSpy, 'npx cypress open')).to.be.true\n  })\n\n  it('Prints correct commands helper for yarn', async () => {\n    mockFsWithInitialTemplate({\n      '/package.json': JSON.stringify({ }),\n    })\n\n    await main({ useNpm: false, ignoreTs: false, ignoreExamples: false, setupComponentTesting: false })\n    expect(someOfSpyCallsIncludes(logSpy, 'yarn cypress open')).to.be.true\n  })\n\n  it('Fails if git repository have untracked or uncommited files', async () => {\n    mockFsWithInitialTemplate({\n      '/package.json': JSON.stringify({ }),\n    })\n\n    execStub?.callsFake((_, callback) => callback(null, { stdout: 'test' }))\n    processExitStub?.callsFake(() => {})\n\n    await main({ useNpm: true, ignoreTs: false, ignoreExamples: false, setupComponentTesting: false })\n\n    expect(\n      someOfSpyCallsIncludes(errorSpy, 'This repository has untracked files or uncommmited changes.'),\n    ).to.equal(true)\n\n    expect(processExitStub).to.be.called\n  })\n\n  context('e2e fs tests', () => {\n    const e2eTestOutputPath = path.resolve(__dirname, 'test-output')\n\n    beforeEach(async () => {\n      fsCopyStub?.restore()\n      mockFs.restore()\n      sinon.stub(process, 'cwd').returns(e2eTestOutputPath)\n\n      await fsExtra.remove(e2eTestOutputPath)\n      await fsExtra.mkdir(e2eTestOutputPath)\n    })\n\n    it('Copies plugins and support files', async () => {\n      await fsExtra.outputFile(\n        path.join(e2eTestOutputPath, 'package.json'),\n        JSON.stringify({ name: 'test' }, null, 2),\n      )\n\n      await main({ useNpm: true, ignoreTs: false, ignoreExamples: false, setupComponentTesting: false })\n\n      expect(await fsExtra.pathExists(path.resolve(e2eTestOutputPath, 'cypress', 'plugins', 'index.js'))).to.equal(true)\n      expect(await fsExtra.pathExists(path.resolve(e2eTestOutputPath, 'cypress', 'support', 'index.js'))).to.equal(true)\n      expect(await fsExtra.pathExists(path.resolve(e2eTestOutputPath, 'cypress', 'support', 'commands.js'))).to.equal(true)\n      expect(await fsExtra.pathExists(path.resolve(e2eTestOutputPath, 'cypress.json'))).to.equal(true)\n    })\n\n    it('Copies tsconfig if typescript is installed', async () => {\n      await fsExtra.outputFile(\n        path.join(e2eTestOutputPath, 'package.json'),\n        JSON.stringify({\n          name: 'test-typescript',\n          dependencies: { typescript: '^4.0.0' },\n        }, null, 2),\n      )\n\n      await main({ useNpm: false, ignoreTs: false, ignoreExamples: false, setupComponentTesting: false })\n      await fsExtra.pathExists(path.resolve(e2eTestOutputPath, 'cypress', 'tsconfig.json'))\n      console.log(path.resolve(e2eTestOutputPath, 'cypress', 'tsconfig.json'))\n    })\n  })\n})\n",
    "npm/create-cypress-tests/src/main.ts": "import fs from 'fs'\nimport findUp from 'find-up'\nimport chalk from 'chalk'\nimport util from 'util'\nimport inquirer from 'inquirer'\nimport { initComponentTesting } from './component-testing/init-component-testing'\nimport { exec } from 'child_process'\nimport { scanFSForAvailableDependency } from './findPackageJson'\nimport { findInstalledOrInstallCypress } from './installCypress'\n\ntype MainArgv = {\n  useNpm: boolean\n  ignoreTs: boolean\n  ignoreExamples: boolean\n  setupComponentTesting: boolean\n}\n\nasync function getGitStatus () {\n  const execAsync = util.promisify(exec)\n\n  try {\n    let { stdout } = await execAsync(`git status --porcelain`)\n\n    console.log(stdout)\n\n    return stdout.trim()\n  } catch (e) {\n    return ''\n  }\n}\n\nasync function shouldUseYarn () {\n  const execAsync = util.promisify(exec)\n\n  return execAsync('yarn --version')\n  .then(() => true)\n  .catch(() => false)\n}\n\nfunction shouldUseTypescript () {\n  return scanFSForAvailableDependency(process.cwd(), { typescript: '*' })\n}\n\nasync function askForComponentTesting () {\n  const { shouldSetupComponentTesting } = await inquirer.prompt({\n    type: 'confirm',\n    name: 'shouldSetupComponentTesting',\n    message: `Do you want to setup ${chalk.cyan('component testing')}? ${chalk.grey('You can do this later by rerunning this command')}.`,\n  })\n\n  return shouldSetupComponentTesting\n}\n\nfunction printCypressCommandsHelper (options: { shouldSetupComponentTesting: boolean, useYarn: boolean }) {\n  const printCommand = (command: string, description: string) => {\n    const displayedRunner = options.useYarn ? 'yarn' : 'npx'\n\n    console.log()\n    console.log(chalk.cyan(`  ${displayedRunner} ${command}`))\n    console.log(`    ${description}`)\n  }\n\n  printCommand('cypress open', 'Opens cypress local development app.')\n  printCommand('cypress run', 'Runs tests in headless mode.')\n\n  if (options.shouldSetupComponentTesting) {\n    printCommand('cypress open-ct', 'Opens cypress component-testing web app.')\n    printCommand('cypress run-ct', 'Runs component testing in headless mode.')\n  }\n}\n\nexport async function main ({ useNpm, ignoreTs, setupComponentTesting, ignoreExamples }: MainArgv) {\n  const rootPackageJsonPath = await findUp('package.json')\n  const useYarn = useNpm === true ? false : await shouldUseYarn()\n  const useTypescript = ignoreTs ? false : shouldUseTypescript()\n\n  if (!rootPackageJsonPath) {\n    console.log(`${chalk.bold.red(`It looks like you are running cypress installation wizard outside of npm module.`)}\\nIf you would like to setup a new project for cypress tests please run the ${chalk.inverse(useNpm ? ' npm init ' : ' yarn init ')} first.`)\n    process.exit(1)\n  }\n\n  const { name = 'unknown', version = '0.0.0' } = JSON.parse(fs.readFileSync(rootPackageJsonPath).toString())\n\n  console.log(`Running ${chalk.green('cypress 🌲')} installation wizard for ${chalk.cyan(`${name}@${version}`)}`)\n\n  const gitStatus = await getGitStatus()\n\n  if (gitStatus) {\n    console.error(`\\n${chalk.bold.red('This repository has untracked files or uncommmited changes.')}\\nThis command will ${chalk.cyan('make changes in the codebase')}, so please remove untracked files, stash or commit any changes, and try again.`)\n    process.exit(1)\n  }\n\n  const { config, cypressConfigPath } = await findInstalledOrInstallCypress({ useYarn, useTypescript, ignoreExamples })\n  const shouldSetupComponentTesting = setupComponentTesting ?? await askForComponentTesting()\n\n  if (shouldSetupComponentTesting) {\n    await initComponentTesting({ config, cypressConfigPath, useYarn })\n  }\n\n  console.log(`\\n👍  Success! Cypress is installed and ready to run tests.`)\n  printCypressCommandsHelper({ useYarn, shouldSetupComponentTesting })\n\n  console.log(`\\nHappy testing with ${chalk.green('cypress.io')} 🌲\\n`)\n}\n",
    "npm/create-cypress-tests/src/utils.ts": "import semver from 'semver'\nimport chalk from 'chalk'\nimport ora from 'ora'\nimport util from 'util'\nimport { exec } from 'child_process'\n\n/**\n * Compare available version range with the provided version from package.json\n * @param packageName Package name used to display a helper message to user.\n */\nexport function validateSemverVersion (\n  version: string,\n  allowedVersionRange: string,\n  packageName?: string,\n) {\n  let isValid: boolean\n\n  try {\n    const minAvailableVersion = semver.minVersion(version)?.raw\n\n    isValid = Boolean(\n      minAvailableVersion &&\n        semver.satisfies(minAvailableVersion, allowedVersionRange),\n    )\n  } catch (e) {\n    // handle not semver versions like \"latest\", \"git:\" or \"file:\"\n    isValid = false\n  }\n\n  if (!isValid && packageName) {\n    const packageNameSymbol = chalk.green(packageName)\n\n    console.warn(\n      `It seems like you are using ${packageNameSymbol} with version ${chalk.bold(\n        version,\n      )}, however we support only ${packageNameSymbol} projects with version ${chalk.bold(\n        allowedVersionRange,\n      )}. \\n`,\n    )\n  }\n\n  return isValid\n}\n\nexport async function installDependency (name: string, options: { useYarn: boolean}) {\n  const commandToRun = options.useYarn ? `yarn add ${name} --dev` : `npm install -D ${name}`\n  let cliSpinner = ora(`Installing ${name} ${chalk.gray(`(${commandToRun})`)}`).start()\n\n  try {\n    // do this inside function for test stubbing\n    const execAsync = util.promisify(exec)\n\n    await execAsync(commandToRun)\n  } catch (e) {\n    cliSpinner.fail(`Can not install ${name} using ${chalk.inverse(commandToRun)})}`)\n    console.log(e)\n\n    process.exit(1)\n  }\n\n  cliSpinner.succeed()\n}\n",
    "npm/cypress-schematic/sandbox/e2e/src/app.e2e-spec.ts": "import { browser, logging } from 'protractor'\nimport { AppPage } from './app.po'\n\ndescribe('workspace-project App', () => {\n  let page: AppPage\n\n  beforeEach(() => {\n    page = new AppPage()\n  })\n\n  it('should display welcome message', async () => {\n    await page.navigateTo()\n    expect(await page.getTitleText()).toEqual('sandbox app is running!')\n  })\n\n  afterEach(async () => {\n    // Assert that there are no errors emitted from the browser\n    const logs = await browser.manage().logs().get(logging.Type.BROWSER)\n\n    expect(logs).not.toContain(jasmine.objectContaining({\n      level: logging.Level.SEVERE,\n    } as logging.Entry))\n  })\n})\n",
    "npm/cypress-schematic/sandbox/src/app/app.component.spec.ts": "import { TestBed } from '@angular/core/testing'\nimport { RouterTestingModule } from '@angular/router/testing'\nimport { AppComponent } from './app.component'\n\ndescribe('AppComponent', () => {\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      imports: [\n        RouterTestingModule,\n      ],\n      declarations: [\n        AppComponent,\n      ],\n    }).compileComponents()\n  })\n\n  it('should create the app', () => {\n    const fixture = TestBed.createComponent(AppComponent)\n    const app = fixture.componentInstance\n\n    expect(app).toBeTruthy()\n  })\n\n  it(`should have as title 'sandbox'`, () => {\n    const fixture = TestBed.createComponent(AppComponent)\n    const app = fixture.componentInstance\n\n    expect(app.title).toEqual('sandbox')\n  })\n\n  it('should render title', () => {\n    const fixture = TestBed.createComponent(AppComponent)\n\n    fixture.detectChanges()\n    const compiled = fixture.nativeElement\n\n    expect(compiled.querySelector('.content span').textContent).toContain('sandbox app is running!')\n  })\n})\n",
    "npm/cypress-schematic/src/schematics/cypress/index_spec.ts": "import { SchematicTestRunner, UnitTestTree } from '@angular-devkit/schematics/testing'\nimport { join, resolve } from 'path'\nimport { expect } from 'chai'\n\ndescribe('@cypress/schematic: ng-add', () => {\n  const schematicRunner = new SchematicTestRunner(\n    'schematics',\n    join(__dirname, './../collection.json'),\n  )\n\n  let appTree: UnitTestTree\n\n  const workspaceOptions = {\n    name: 'workspace',\n    newProjectRoot: 'projects',\n    version: '6.0.0',\n    defaultProject: 'sandbox',\n  }\n\n  const appOptions = {\n    name: 'sandbox',\n    inlineTemplate: false,\n    routing: false,\n    skipTests: false,\n    skipPackageJson: false,\n  }\n\n  beforeEach(async () => {\n    appTree = await schematicRunner.runExternalSchematicAsync('@schematics/angular', 'workspace', workspaceOptions).toPromise()\n    appTree = await schematicRunner.runExternalSchematicAsync('@schematics/angular', 'application', appOptions, appTree).toPromise()\n  })\n\n  it('should create cypress files', async () => {\n    const files = ['cypress/integration/spec.ts', 'cypress/plugins/index.js', 'cypress/support/commands.ts', 'cypress/support/index.ts', 'cypress/tsconfig.json', 'cypress.json']\n    const homePath = '/projects/sandbox/'\n\n    return schematicRunner.runSchematicAsync('ng-add', {}, appTree).toPromise().then((tree) => {\n      files.forEach((f) => {\n        const pathToFile = resolve(homePath, f)\n\n        expect(tree.exists(pathToFile), pathToFile).equal(true)\n      })\n    })\n  })\n})\n",
    "npm/eslint-plugin-dev/lib/scripts/lint.spec.js": "const sh = require('shelljs')\nconst sinon = require('sinon')\nconst lintStaged = require('./lint-staged')\nconst lintChanged = require('./lint-changed')\nconst lintPrePush = require('./lint-pre-push')\nconst lintPreCommit = require('./lint-pre-commit')\nconst chai = require('chai')\nconst debug = require('debug')('lint.spec')\n\nconst { expect } = chai\n\nchai.use(require('sinon-chai'))\n\nconst _env = process.env\nconst _argv = process.argv\n\nconst getStagedFiles = () => sh.ShellString('foo.js\\nbar.js')\nconst getUnstagedFiles = () => sh.ShellString('bar.js\\nbaz.js')\nconst getCommittedFiles = () => sh.ShellString('baz.js\\nquux.js')\n\nconst eslintSuccess = (...args) => {\n  debug('eslintSuccess:', args)\n  const ret = sh.ShellString(`GOOD JS`)\n\n  ret.exec = sinon.stub().yields(null, 'success')\n\n  return ret\n}\n\nconst eslintFailure = (...args) => {\n  debug('eslintFailure:', args)\n  const ret = sh.ShellString(`BAD JS`)\n\n  ret.exec = sinon.stub().yields('foo error')\n\n  return ret\n}\n\nbeforeEach(() => {\n  sinon.stub(sh, 'exec')\n  sinon.stub(sh, 'cat')\n  sinon.stub(process, 'exit')\n\n  sh.exec\n  .withArgs(`git branch`).returns(sh.ShellString('* mybranch'))\n\n  .withArgs(`git diff --name-only --diff-filter=MA --staged`)\n  .returns(getStagedFiles())\n\n  .withArgs(`git diff --name-only --diff-filter=M`)\n  .returns(getUnstagedFiles())\n\n  .withArgs(`git diff HEAD origin/mybranch --name-only`)\n  .returns(getCommittedFiles())\n\n  sh.exec.callsFake(eslintSuccess)\n})\n\ndescribe('lint-staged', () => {\n  it('lint success', async () => {\n    await lintStaged.start()\n    expect(process.exit).not.calledOnce\n  })\n\n  it('lint failures', async () => {\n    sh.exec.callsFake(eslintFailure)\n\n    await lintStaged.start()\n    expect(process.exit).calledOnce\n  })\n})\n\ndescribe('lint-changed', () => {\n  const filenames = 'bar.js baz.js foo.js'\n\n  beforeEach(() => {\n    sh.exec\n    .withArgs(`./node_modules/.bin/eslint --color=true '' ${filenames}`)\n    .yields(null, 'success')\n  })\n\n  it('lint success', async () => {\n    await lintChanged.start()\n    expect(process.exit).not.calledOnce\n  })\n\n  it('lint failures', async () => {\n    sh.exec\n    .withArgs(`./node_modules/.bin/eslint --color=true '' ${filenames}`)\n    .yields('foo error')\n\n    await lintChanged.start()\n    expect(process.exit).calledOnce\n  })\n\n  it('lint with --fix', async () => {\n    process.argv = ['_', '_', '--fix']\n    sh.exec\n    .withArgs(`./node_modules/.bin/eslint --color=true --fix '' ${filenames}`)\n    .yields(null, 'success')\n\n    await lintChanged.start()\n    expect(process.exit).not.calledOnce\n  })\n})\n\ndescribe('lint-pre-push', () => {\n  beforeEach(() => {\n    process.env.HUSKY_GIT_PARAMS = 'origin git@github.com:cypress-io/cypress.git'\n  })\n\n  it('lint success', async () => {\n    await lintPrePush.start()\n    expect(process.exit).not.calledOnce\n  })\n\n  it('lint failures', async () => {\n    sh.exec.callsFake(eslintFailure)\n\n    await lintPrePush.start()\n    expect(process.exit).calledOnce\n  })\n})\n\ndescribe('lint-pre-commit', () => {\n  beforeEach(() => {\n    sh.exec\n    .withArgs(`./node_modules/.bin/eslint --color=true --fix '' foo.js`)\n    .yields(null, 'success')\n  })\n\n  it('lint success', async () => {\n    await lintPreCommit.start()\n    expect(process.exit).not.calledOnce\n\n    expect(sh.exec.withArgs('git add foo.js')).calledOnce\n  })\n\n  it('lint failures', async () => {\n    sh.exec.callsFake(eslintFailure)\n\n    await lintPreCommit.start()\n    expect(process.exit).calledOnce\n  })\n})\n\nafterEach(() => {\n  process.argv = _argv\n  process.env = _env\n  sinon.restore()\n})\n\n// sinon.addBehavior('withArgIncludes', (stub, str) => {\n\n// })\n\n// function withArgsInclude() {\n//   this.\n//   .callsFake((...args) => {\n//     args[0].includes()\n\n//   })\n// }\n",
    "npm/react/plugins/next/findNextWebpackConfig.js": "// @ts-check\n/// <reference types=\"next\" />\nconst debug = require('debug')('@cypress/react')\nconst loadConfig = require('next/dist/next-server/server/config').default\nconst getNextJsBaseWebpackConfig = require('next/dist/build/webpack-config').default\n\nasync function getNextWebpackConfig (config) {\n  const nextConfig = await loadConfig('development', config.projectRoot)\n  const nextWebpackConfig = await getNextJsBaseWebpackConfig(\n    config.projectRoot,\n    {\n      buildId: `@cypress/react-${Math.random().toString()}`,\n      config: nextConfig,\n      dev: true,\n      isServer: false,\n      pagesDir: config.projectRoot,\n      entrypoints: {},\n      rewrites: { fallback: [], afterFiles: [], beforeFiles: [] },\n    },\n  )\n\n  debug('resolved next.js webpack config %o', nextWebpackConfig)\n\n  return nextWebpackConfig\n}\n\nlet webpackConfigCache = null\n\n/** Resolving next.js webpack and all config with plugin takes long, so cache the webpack configuration */\nmodule.exports = async function findNextWebpackConfig (config) {\n  // ⛔️ ⛔️ Comment this `if` for debugging\n  if (webpackConfigCache !== null) {\n    return webpackConfigCache\n  }\n\n  webpackConfigCache = await getNextWebpackConfig(config)\n  debug('created and cached webpack preprocessor based on next.config.js', webpackConfigCache)\n\n  return webpackConfigCache\n}\n",
    "npm/vite-dev-server/src/index.ts": "import { debug as debugFn } from 'debug'\nimport { Server } from 'http'\nimport { start as createDevServer, StartDevServer } from './startServer'\nconst debug = debugFn('cypress:vite-dev-server:vite')\n\nexport { StartDevServer }\n\nexport interface ResolvedDevServerConfig {\n  port: number\n  server: Server\n}\n\nexport async function startDevServer (startDevServerArgs: StartDevServer): Promise<ResolvedDevServerConfig> {\n  const viteDevServer = await createDevServer(startDevServerArgs)\n\n  const app = await viteDevServer.listen()\n  const port = app.config.server.port\n\n  debug('Component testing vite server started on port', port)\n\n  return { port, server: app.httpServer }\n}\n",
    "npm/vite-dev-server/src/makeCypressPlugin.ts": "import { resolve, posix, sep } from 'path'\nimport { readFile } from 'fs'\nimport { promisify } from 'util'\nimport Debug from 'debug'\nimport { ModuleNode, Plugin, ViteDevServer } from 'vite'\n\nconst debug = Debug('cypress:vite-dev-server:plugin')\n\nconst read = promisify(readFile)\n\nconst pluginName = 'cypress-transform-html'\nconst OSSepRE = new RegExp(`\\\\${sep}`, 'g')\n\nfunction convertPathToPosix (path: string): string {\n  return sep === '/'\n    ? path\n    : path.replace(OSSepRE, '/')\n}\n\nconst INIT_FILEPATH = resolve(__dirname, '../client/initCypressTests.js')\n\nconst HMR_DEPENDENCY_LOOKUP_MAX_ITERATION = 50\n\nexport const makeCypressPlugin = (\n  projectRoot: string,\n  supportFilePath: string,\n  devServerEvents: EventEmitter,\n  specs: {absolute: string, relative: string}[],\n): Plugin => {\n  let base = '/'\n\n  const specsPathsSet = new Set<string>(specs.map((spec) => spec.absolute))\n\n  const posixSupportFilePath = supportFilePath ? convertPathToPosix(resolve(projectRoot, supportFilePath)) : undefined\n\n  const normalizedSupportFilePath = posixSupportFilePath ? `${base}@fs/${posixSupportFilePath}` : undefined\n\n  return {\n    name: pluginName,\n    enforce: 'pre',\n    config (_, env) {\n      if (env) {\n        return {\n          define: {\n            'import.meta.env.__cypress_supportPath': JSON.stringify(normalizedSupportFilePath),\n            'import.meta.env.__cypress_originAutUrl': JSON.stringify(`__cypress/iframes/${convertPathToPosix(projectRoot)}/`),\n          },\n        }\n      }\n    },\n    configResolved (config) {\n      base = config.base\n    },\n    transformIndexHtml () {\n      debug('transformIndexHtml with base', base)\n\n      return [\n        // load the script at the end of the body\n        // script has to be loaded when the vite client is connected\n        {\n          tag: 'script',\n          injectTo: 'body',\n          attrs: { type: 'module' },\n          children: `import(${JSON.stringify(`${base}@fs/${INIT_FILEPATH}`)})`,\n        },\n      ]\n    },\n    configureServer: async (server: ViteDevServer) => {\n      const indexHtml = await read(resolve(__dirname, '..', 'index.html'), { encoding: 'utf8' })\n\n      const transformedIndexHtml = await server.transformIndexHtml(base, indexHtml)\n\n      server.middlewares.use(`${base}index.html`, (req, res) => res.end(transformedIndexHtml))\n    },\n    handleHotUpdate: ({ server, file }) => {\n      debug('handleHotUpdate - file', file)\n      // get the graph node for the file that just got updated\n      let moduleImporters = server.moduleGraph.fileToModulesMap.get(file)\n      let iterationNumber = 0\n\n      // until we reached a point where the current module is imported by no other\n      while (moduleImporters && moduleImporters.size) {\n        if (iterationNumber > HMR_DEPENDENCY_LOOKUP_MAX_ITERATION) {\n          debug(`max hmr iteration reached: ${HMR_DEPENDENCY_LOOKUP_MAX_ITERATION}; Rerun will not happen on this file change.`)\n\n          return []\n        }\n\n        // as soon as we find one of the specs, we trigger the re-run of tests\n        for (const mod of moduleImporters.values()) {\n          if (specsPathsSet.has(mod.file)) {\n            debug('handleHotUpdate - compile success')\n            devServerEvents.emit('dev-server:compile:success')\n\n            return []\n          }\n        }\n\n        // get all the modules that import the current one\n        moduleImporters = getImporters(moduleImporters)\n        iterationNumber += 1\n      }\n\n      return []\n    },\n  }\n}\n\nfunction getImporters (modules: Set<ModuleNode>): Set<ModuleNode> {\n  const allImporters = new Set<ModuleNode>()\n\n  modules.forEach((m) => {\n    m.importers.forEach((imp) => allImporters.add(imp))\n  })\n\n  return allImporters\n}\n",
    "npm/vite-dev-server/src/startServer.ts": "import Debug from 'debug'\nimport { createServer, ViteDevServer, InlineConfig, UserConfig } from 'vite'\nimport { dirname, resolve } from 'path'\nimport getPort from 'get-port'\nimport { makeCypressPlugin } from './makeCypressPlugin'\n\nconst debug = Debug('cypress:vite-dev-server:start')\n\ninterface Options {\n  specs: Cypress.Cypress['spec'][]\n  config: Record<string, string>\n  devServerEvents: EventEmitter\n  [key: string]: unknown\n}\n\nexport interface StartDevServer {\n  /**\n   * the Cypress options object\n   */\n  options: Options\n  /**\n   * By default, vite will use your vite.config file to\n   * Start the server. If you need additional plugins or\n   * to override some options, you can do so using this.\n   * @optional\n   */\n  viteConfig?: UserConfig\n}\n\nconst resolveServerConfig = async ({ viteConfig, options }: StartDevServer): Promise<InlineConfig> => {\n  const { projectRoot, supportFile } = options.config\n\n  const requiredOptions: InlineConfig = {\n    base: '/__cypress/src/',\n    root: projectRoot,\n  }\n\n  const finalConfig: InlineConfig = { ...viteConfig, ...requiredOptions }\n\n  finalConfig.plugins = [...(viteConfig.plugins || []), makeCypressPlugin(projectRoot, supportFile, options.devServerEvents, options.specs)]\n\n  // This alias is necessary to avoid a \"prefixIdentifiers\" issue from slots mounting\n  // only cjs compiler-core accepts using prefixIdentifiers in slots which vue test utils use.\n  // Could we resolve this usage in test-utils?\n  try {\n    finalConfig.resolve = finalConfig.resolve || {}\n    finalConfig.resolve.alias = {\n      ...finalConfig.resolve.alias,\n      '@vue/compiler-core': resolve(dirname(require.resolve('@vue/compiler-core')), 'dist', 'compiler-core.cjs.js'),\n    }\n  } catch (e) {\n    // Vue 3 is not installed\n  }\n\n  finalConfig.server = finalConfig.server || {}\n\n  finalConfig.server.port = await getPort({ port: finalConfig.server.port || 3000, host: 'localhost' }),\n\n  // Ask vite to pre-optimize all dependencies of the specs\n  finalConfig.optimizeDeps = finalConfig.optimizeDeps || {}\n\n  finalConfig.optimizeDeps.entries = [...options.specs.map((spec) => spec.relative), supportFile]\n\n  debug(`the resolved server config is ${JSON.stringify(finalConfig, null, 2)}`)\n\n  return finalConfig\n}\n\nexport async function start (devServerOptions: StartDevServer): Promise<ViteDevServer> {\n  if (!devServerOptions.viteConfig) {\n    debug('User did not pass in any Vite dev server configuration')\n    devServerOptions.viteConfig = {}\n  }\n\n  debug('starting vite dev server')\n  const resolvedConfig = await resolveServerConfig(devServerOptions)\n\n  return createServer(resolvedConfig)\n}\n",
    "npm/vue/examples/nuxt/cypress/plugins/index.js": "/// <reference types=\"cypress\" />\nconst { startDevServer } = require('@cypress/webpack-dev-server')\nconst { getWebpackConfig } = require('nuxt')\n\n/**\n * @type Cypress.PluginConfig\n */\nmodule.exports = (on, config) => {\n  on('dev-server:start', async (options) => {\n    // Use the modern configuration of webpack since we\n    // will never use it with Internet Explorer within cypress\n    let webpackConfig = await getWebpackConfig('modern', 'dev')\n\n    return startDevServer({\n      options,\n      webpackConfig,\n    })\n  })\n\n  return config\n}\n",
    "npm/webpack-batteries-included-preprocessor/test/e2e/features.spec.js": "const EventEmitter = require('events').EventEmitter\nconst { expect } = require('chai')\nconst fs = require('fs-extra')\nconst path = require('path')\n\nconst preprocessor = require('../../index')\n\nconst fixturesDir = path.join(__dirname, '..', 'fixtures')\nconst outputDir = path.join(__dirname, '..', '_test-output')\n\nconst run = (fileName, options) => {\n  const file = Object.assign(new EventEmitter(), {\n    filePath: path.join(outputDir, fileName),\n    outputPath: path.join(outputDir, fileName.replace('.', '_output.')),\n  })\n\n  return preprocessor(options)(file)\n}\n\nconst runAndEval = async (fileName, options) => {\n  const outputPath = await run(fileName, options)\n  const contents = await fs.readFile(outputPath)\n\n  eval(contents.toString())\n}\n\ndescribe('features', () => {\n  beforeEach(async () => {\n    preprocessor.__reset()\n\n    await fs.remove(outputDir)\n    await fs.copy(fixturesDir, outputDir)\n  })\n\n  it('handles module interop, object spread, class properties, and async/await', async () => {\n    await runAndEval('es_features_spec.js')\n  })\n\n  it('handles jsx', async () => {\n    await runAndEval('jsx_spec.jsx')\n  })\n\n  it('handles mjs', async () => {\n    await runAndEval('mjs_spec.mjs')\n  })\n\n  it('handles coffeescript', async () => {\n    await runAndEval('coffee_spec.coffee')\n  })\n\n  it('handles import default export in coffeescript', async () => {\n    await runAndEval('coffee_imports_spec.coffee')\n  })\n\n  it('handles importing .js, .json, .jsx, .mjs, and .coffee', async () => {\n    await runAndEval('various_imports_spec.js')\n  })\n\n  it('shims node globals', async () => {\n    await runAndEval('node_shim_spec.js')\n  })\n\n  it('shims node builtins', async () => {\n    await runAndEval('node_builtins_spec.js')\n  })\n\n  it('outputs inline source map', async () => {\n    const outputPath = await run('es_features_spec.js')\n    const contents = await fs.readFile(outputPath)\n\n    expect(contents.toString()).to.include('//# sourceMappingURL=data:application/json;charset=utf-8;base64')\n  })\n\n  describe('with typescript option set', () => {\n    const shouldntResolve = () => {\n      throw new Error('Should error, should not resolve')\n    }\n\n    const options = { typescript: require.resolve('typescript') }\n\n    it('handles typescript (and tsconfig paths)', async () => {\n      await runAndEval('ts_spec.ts', { ...options })\n    })\n\n    it('handles tsx', async () => {\n      await runAndEval('tsx_spec.tsx', { ...options })\n    })\n\n    it('handles importing .ts and .tsx', async () => {\n      await runAndEval('typescript_imports_spec.js', { ...options })\n    })\n\n    it('handles esModuleInterop: false (default)', async () => {\n      await runAndEval('typescript_esmoduleinterop_false_spec.ts', { ...options })\n    })\n\n    it('handles esModuleInterop: true', async () => {\n      await runAndEval('esmoduleinterop-true/typescript_esmoduleinterop_true_spec.ts', { ...options })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/15767\n    // defaultOptions don't have typescript config baked in since it requires\n    // the path to typescript and the file, so it needs to be added later\n    it('adds typescript support if using defaultOptions', async () => {\n      await runAndEval('tsx_spec.tsx', { ...options, ...preprocessor.defaultOptions })\n    })\n\n    it('errors when processing .ts file and typescript option is not set', () => {\n      return run('ts_spec.ts')\n      .then(shouldntResolve)\n      .catch((err) => {\n        expect(err.message).to.include(`You are attempting to run a TypeScript file, but do not have TypeScript installed. Ensure you have 'typescript' installed to enable TypeScript support`)\n        expect(err.message).to.include('ts_spec.ts')\n      })\n    })\n\n    it('errors when processing .tsx file and typescript option is not set', () => {\n      return run('tsx_spec.tsx')\n      .then(shouldntResolve)\n      .catch((err) => {\n        expect(err.message).to.include(`You are attempting to run a TypeScript file, but do not have TypeScript installed. Ensure you have 'typescript' installed to enable TypeScript support`)\n        expect(err.message).to.include('tsx_spec.tsx')\n      })\n    })\n  })\n})\n",
    "npm/webpack-batteries-included-preprocessor/test/fixtures/es_features_spec.js": "// ES module / CommonJS interop\nimport { commonJSExport } from './export-commonjs'\nconst { es2015Export, SampleClass, asyncFn } = require('./export-es2015')\n\nexpect(commonJSExport.commonJSKey).to.equal('commonJSValue')\nexpect(es2015Export.es2015Key).to.equal('es2015Value')\n\n// object spread\nconst obj = {\n  ...commonJSExport,\n  ...es2015Export,\n}\n\nexpect(obj).to.eql({\n  commonJSKey: 'commonJSValue',\n  es2015Key: 'es2015Value',\n})\n\n// class properties\nexpect(SampleClass.staticProp).to.equal('staticProp')\nexpect((new SampleClass()).prop).to.equal('prop')\n\n;(async () => {\n  // async/await\n  const value = await asyncFn()\n\n  expect(value).to.equal('value')\n})\n",
    "npm/webpack-preprocessor/test/e2e/compilation.spec.js": "const EventEmitter = require('events').EventEmitter\nconst chai = require('chai')\nconst fs = require('fs-extra')\nconst path = require('path')\nconst snapshot = require('snap-shot-it')\nconst sinon = require('sinon')\nconst Bluebird = require('bluebird')\nconst sinonChai = require('sinon-chai')\n\nchai.use(sinonChai)\nconst { expect } = chai\n\nconst preprocessor = require('../../dist/index')\n\nconst normalizeErrMessage = (message) => {\n  return message.replace(/\\/\\S+\\/_test/g, '<path>/_test')\n}\n\nconst fixturesDir = path.join(__dirname, '..', 'fixtures')\nconst outputDir = path.join(__dirname, '..', '_test-output')\n\nconst createFile = ({ name = 'example_spec.js', shouldWatch = false } = {}) => {\n  return Object.assign(new EventEmitter(), {\n    filePath: path.join(outputDir, name),\n    outputPath: path.join(outputDir, name.replace('.', '_output.')),\n    shouldWatch,\n  })\n}\n\ndescribe('webpack preprocessor - e2e', () => {\n  let file\n\n  beforeEach(async () => {\n    preprocessor.__reset()\n\n    await fs.remove(outputDir)\n    await fs.copy(fixturesDir, outputDir)\n  })\n\n  afterEach(async () => {\n    if (file.shouldWatch) {\n      await new Promise((resolve) => {\n        file.emit('close', resolve)\n      })\n    }\n  })\n\n  it('correctly preprocesses the file', () => {\n    const options = preprocessor.defaultOptions\n\n    options.webpackOptions.mode = 'production' // snapshot will be minified\n    file = createFile()\n\n    return preprocessor(options)(file).then((outputPath) => {\n      snapshot(fs.readFileSync(outputPath).toString())\n    })\n  })\n\n  it('has less verbose \"Module not found\" error', () => {\n    file = createFile({ name: 'imports_nonexistent_file_spec.js' })\n\n    return preprocessor()(file)\n    .then(() => {\n      throw new Error('Should not resolve')\n    })\n    .catch((err) => {\n      snapshot(normalizeErrMessage(err.message))\n    })\n  })\n\n  it('has less verbose syntax error', () => {\n    file = createFile({ name: 'syntax_error_spec.js' })\n\n    return preprocessor()(file)\n    .then(() => {\n      throw new Error('Should not resolve')\n    })\n    .catch((err) => {\n      snapshot(normalizeErrMessage(err.message))\n    })\n  })\n\n  it('allows attaching catch later on syntax error without triggering unhandled rejection', async () => {\n    process.on('unhandledRejection', (err) => {\n      // eslint-disable-next-line no-console\n      console.error('Unhandled Rejection:', err.stack)\n      throw new Error('Should not have trigger unhandled rejection')\n    })\n\n    file = createFile({ shouldWatch: true })\n\n    await preprocessor()(file)\n    await fs.outputFile(file.filePath, '{')\n\n    await new Promise((resolve) => {\n      setTimeout(() => {\n        preprocessor()(file)\n        .catch((err) => {\n          expect(err.stack).to.include('Unexpected token')\n          resolve()\n        })\n      }, 1000)\n    })\n  })\n\n  it('triggers rerun on syntax error', async () => {\n    file = createFile({ shouldWatch: true })\n\n    await preprocessor()(file)\n\n    const _emit = sinon.spy(file, 'emit')\n\n    await fs.outputFile(file.filePath, '{')\n\n    await retry(() => expect(_emit).calledWith('rerun'))\n  })\n\n  it('does not call rerun on initial build, but on subsequent builds', async () => {\n    file = createFile({ shouldWatch: true })\n    const _emit = sinon.spy(file, 'emit')\n\n    await preprocessor()(file)\n\n    expect(_emit).not.to.be.calledWith('rerun')\n\n    await fs.outputFile(file.filePath, 'console.log()')\n\n    await retry(() => expect(_emit).calledWith('rerun'))\n  })\n})\n\nfunction retry (fn, timeout = 1000) {\n  let timedOut = false\n\n  setTimeout(() => timedOut = true, timeout)\n  const tryFn = () => {\n    return Bluebird.try(() => {\n      return fn()\n    })\n\n    .catch((err) => {\n      if (timedOut) {\n        throw err\n      }\n\n      return Bluebird.delay(100).then(() => tryFn())\n    })\n  }\n\n  return tryFn()\n}\n",
    "npm/webpack-preprocessor/test/e2e/helpers.js": "/* eslint-disable no-console, prefer-rest-params */\n\nconst { codeFrameColumns } = require('@babel/code-frame')\nconst fs = require('fs-extra')\nconst _ = require('lodash')\nconst path = require('path')\nconst { expect } = require('chai')\nconst bluebird = require('bluebird')\nconst Debug = require('debug')\nconst chalk = require('chalk')\nconst stripAnsi = require('strip-ansi')\nconst cypress = require('cypress')\nconst debug = Debug('test')\nconst rootDir = process.cwd()\n\nconst cp = require('child_process')\n\nconst _spawn = cp.spawn\n\ncp.spawn = function () {\n  arguments[2].stdio = 'pipe'\n  const ret = _spawn.apply(this, arguments)\n\n  return ret\n}\n\nafterEach(function () {\n  const err = this.currentTest.err\n\n  if (err) {\n    mapError(err)\n  }\n})\n\nbeforeEach(function () {\n  this.currentTest.timeout(50000)\n})\n\nexports.runTest = async (options = {}) => {\n  if (!options.spec) {\n    throw new Error('options.spec not supplied')\n  }\n\n  let parsedSpecOptions = {}\n\n  if (!_.isArray(options.spec)) {\n    const fileStr = (await fs.readFile(options.spec)).toString()\n    const match = /\\/\\*\\s*EXPECT:\\s*({.*})\\s*\\*\\//s.exec(fileStr)\n\n    if (match) {\n      console.log(match[1])\n      parsedSpecOptions = require('json5').parse(match[1])\n    }\n  }\n\n  const opts = _.defaults(options, {\n    spec: '',\n    expectedResults: {\n      totalFailed: 0,\n    },\n    stdoutInclude: null,\n    browser: 'electron',\n    exit: true,\n  })\n\n  _.merge(opts, parsedSpecOptions)\n\n  if (_.isString(opts.stdoutInclude)) {\n    opts.stdoutInclude = [opts.stdoutInclude]\n  }\n\n  console.log(chalk.cyanBright(`starting test run: ${opts.spec}`))\n\n  const stdio = captureStdio(process.stdout)\n\n  let stdout\n\n  _.extend(process.env, {\n    FAKE_CWD_PATH: '/[cwd]',\n    DEBUG_COLORS: '1',\n    // prevent any Compression progress\n    // messages from showing up\n    VIDEO_COMPRESSION_THROTTLE: 120000,\n\n    // don't fail our own tests running from forked PR's\n    CYPRESS_INTERNAL_E2E_TESTS: '1',\n    CYPRESS_ENV: 'test',\n  })\n\n  return cypress.run({\n    spec: opts.spec,\n    browser: opts.browser,\n    exit: opts.exit,\n    config: {\n      video: false,\n    },\n    dev: true,\n  })\n  .finally(() => {\n    stdout = stdio.toString()\n    stdio.restore()\n  })\n  .then((res) => {\n    expect(res).includes(opts.expectedResults)\n  })\n  .then(() => {\n    if (opts.stdoutInclude) {\n      _.forEach(opts.stdoutInclude, (v) => {\n        expect(stdout).include(v)\n        console.log(`${chalk.bold('run matched stdout:')}\\n${v}`)\n      })\n    }\n\n    // console.log(stdout)\n    console.log(`${chalk.bold('run matched these results:')} ${JSON.stringify(opts.expectedResults, null, 2)}`)\n  })\n}\n\nconst mapError = async (e) => {\n  const slicedStack = e.stack.split('\\n') //.slice(1)\n\n  debug({ slicedStack })\n  const lastSrcStack = _.findIndex(\n    slicedStack,\n    (v) => !v.includes('node_modules') && v.split(path.sep).length > 2,\n  )\n\n  debug({ lastSrcStack })\n\n  const entryNodeModuleStack = null //slicedStack[lastSrcStack - 1]\n\n  debug({ entryNodeModuleStack })\n\n  const entryNodeModuleRE = /node_modules\\/(.*?)\\//.exec(\n    entryNodeModuleStack,\n  )\n  let entryNodeModule\n\n  if (entryNodeModuleRE) {\n    entryNodeModule = entryNodeModuleRE[1]\n  }\n\n  // debug({ entryNodeModule })\n  let codeFrame\n\n  debug({ stack: e.stack.split('\\n'), rootDir })\n  const srcStackArr = await bluebird\n  .resolve(\n    e.stack\n    .split('\\n')\n    .filter(\n      (v, i) => {\n        return i === 0 ||\n              (!v.includes('/node_modules/')) // && v.includes(rootDir))\n      },\n    ),\n  )\n  .mapSeries(async (v) => {\n    const match = /^(\\W+)(at[^(]*)\\(?(.+?)(:)(\\d+)(:)(\\d+)(\\)?)/.exec(v)\n\n    debug({ mapStack: v, match })\n    if (match) {\n      const relativePath = match[3] //path.relative(rootDir, match[3])\n\n      match[3] = relativePath\n      if (!codeFrame) {\n        codeFrame = await getCodeFrame(match)\n      }\n\n      match[3] = chalk.rgb(72, 160, 191)(relativePath)\n\n      return match.slice(1).join('')\n    }\n\n    return v\n  })\n\n  const srcStack = srcStackArr.join('\\n')\n  const srcStackShort = srcStackArr.slice(1, 2).join('\\n')\n\n  debug(srcStack)\n\n  console.log(chalk.dim(srcStack))\n  console.log(codeFrame)\n\n  console.log(`\n    ☠️  ${\n  entryNodeModule ? ` [${chalk.bold(entryNodeModule)}] ` : ''\n}${chalk.red(e.message)}\n      ${srcStackShort}\n  `)\n}\n\nconst getCodeFrame = async (info) => {\n  if (await fs.pathExists(info[3])) {\n    const location = { start: { line: +info[5], column: +info[7] } }\n    const rawlines = (await fs.readFile(info[3])).toString()\n    // .split('\\n')\n    // .slice(location.start.line - 2, location.start.line + 2)\n    // .join('\\n')\n    // debug({ path: info[1], location })\n    const result = codeFrameColumns(rawlines, location, {\n      highlightCode: true,\n      linesAbove: 2,\n      linesBelow: 3,\n    })\n\n    return `\\n${result}`\n  }\n}\n\nconst captureStdio = (stdio, tty) => {\n  let logs = []\n  let passThrough = null\n\n  const write = stdio.write\n  const isTTY = stdio.isTTY\n\n  stdio.write = function (str) {\n    logs.push(str)\n    if (passThrough) {\n      return write.apply(this, [passThrough(str)])\n    }\n  }\n\n  if (tty !== undefined) stdio.isTTY = tty\n\n  return {\n    toString: () => {\n      return stripAnsi(logs.join(''))\n    },\n\n    restore () {\n      stdio.write = write\n      stdio.isTTY = isTTY\n    },\n  }\n}\n",
    "packages/driver/cypress/integration/commands/misc_spec.js": "const { _, $, dom } = Cypress\n\ndescribe('src/cy/commands/misc', () => {\n  before(() => {\n    cy\n    .visit('/fixtures/jquery.html')\n    .then(function (win) {\n      this.body = win.document.body.outerHTML\n    })\n  })\n\n  beforeEach(function () {\n    const doc = cy.state('document')\n\n    $(doc.body).empty().html(this.body)\n  })\n\n  context('#end', () => {\n    it('nulls out the subject', () => {\n      cy.noop({}).end().then((subject) => {\n        expect(subject).to.be.null\n      })\n    })\n  })\n\n  context('#log', () => {\n    it('nulls out the subject', () => {\n      cy.wrap({}).log('foo').then((subject) => {\n        expect(subject).to.be.null\n      })\n    })\n\n    describe('.log', () => {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          this.lastLog = log\n          this.logs.push(log)\n        })\n\n        return null\n      })\n\n      it('logs immediately', function (done) {\n        cy.on('log:added', (attrs, log) => {\n          cy.removeAllListeners('log:added')\n\n          expect(log.get('message')).to.eq('foo, {foo: bar}')\n          expect(log.get('name')).to.eq('log')\n          expect(log.get('end')).to.be.true\n\n          done()\n        })\n\n        cy.log('foo', { foo: 'bar' }).then(() => {\n          const { lastLog } = this\n\n          expect(lastLog.get('ended')).to.be.true\n          expect(lastLog.get('snapshots').length).to.eq(1)\n\n          expect(lastLog.get('snapshots')[0]).to.be.an('object')\n        })\n      })\n\n      it('consoleProps', () => {\n        return cy.log('foobarbaz', [{}]).then(function () {\n          expect(this.lastLog.invoke('consoleProps')).to.deep.eq({\n            Command: 'log',\n            args: [[{}]],\n            message: 'foobarbaz',\n          })\n        })\n      })\n\n      // https://github.com/cypress-io/cypress/issues/8084\n      it('log does not corrupt the stack and returns subject correctly', () => {\n        cy.wrap({ a: 42 }).then(async (data) => {\n          cy.log('count', Object.keys(data).length)\n          cy.log('another log')\n\n          return await Object.keys(data).length\n        }).then((test) => {\n          expect(test).to.eq(1)\n        })\n      })\n\n      // https://github.com/cypress-io/cypress/issues/16068\n      it('log does not have limit to the number of arguments', function () {\n        cy.log('msg', 1, 2, 3, 4)\n        .then(() => {\n          const { lastLog } = this\n\n          expect(lastLog.get('message')).to.eq('msg, 1, 2, 3, 4')\n        })\n      })\n    })\n  })\n\n  context('#wrap', () => {\n    beforeEach(function () {\n      this.remoteWindow = cy.state('window')\n\n      delete this.remoteWindow.$.fn.foo\n    })\n\n    it('sets the subject to the first argument', () => {\n      cy.wrap({}).then((subject) => {\n        expect(subject).to.deep.eq({})\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/3241\n    it('cy.wrap(undefined) should retry', () => {\n      const stub = cy.stub()\n\n      cy.wrap().should(() => {\n        stub()\n\n        expect(stub).to.be.calledTwice\n      })\n\n      cy.wrap(undefined).should(() => {\n        stub()\n\n        expect(stub.callCount).to.eq(4)\n      })\n    })\n\n    it('can wrap jquery objects and continue to chain', function () {\n      this.remoteWindow.$.fn.foo = 'foo'\n\n      const append = () => {\n        setTimeout(() => {\n          $('<li class=\\'appended\\'>appended</li>').appendTo(cy.$$('#list'))\n        }, 50)\n      }\n\n      cy.on('command:retry', _.after(2, _.once(append)))\n\n      cy.get('#list').then(($ul) => {\n        cy\n        // ensure that assertions are based on the real subject\n        // and not the cy subject - therefore foo should be defined\n        .wrap($ul).should('have.property', 'foo')\n\n        // then re-wrap $ul and ensure that the subject passed\n        // downstream is the cypress instance\n        .wrap($ul)\n        .find('li.appended')\n        .then(($li) => {\n          // must use explicit non cy.should\n          // else this test will always pass\n          expect($li.length).to.eq(1)\n        })\n      })\n    })\n\n    // TODO: fix this test in 4.0 when we refactor validating subjects\n    it.skip('throws a good error when wrapping mixed types: element + string', () => {\n      cy.get('button').then(($btn) => {\n        const btn = $btn.get(0)\n\n        cy.wrap([btn, 'asdf']).click()\n      })\n    })\n\n    it('can wrap an array of DOM elements and pass command validation', () => {\n      cy.get('button').then(($btn) => {\n        const btn = $btn.get(0)\n\n        cy.wrap([btn]).click().then(($btn) => {\n          expect(dom.isJquery($btn)).to.be.true\n        })\n\n        cy.wrap([btn, btn]).click({ multiple: true }).then(($btns) => {\n          expect(dom.isJquery($btns)).to.be.true\n        })\n      })\n    })\n\n    it('can wrap an array of window without it being altered', () => {\n      cy.window().then((win) => {\n        cy.wrap([win]).then((arr) => {\n          expect(arr).to.be.an('array')\n          expect(Array.isArray(arr)).to.be.true\n        })\n      })\n    })\n\n    it('can wrap an array of document without it being altered', () => {\n      cy.document().then((doc) => {\n        cy.wrap([doc]).then((arr) => {\n          expect(arr).to.be.an('array')\n          expect(Array.isArray(arr)).to.be.true\n          expect(arr[0]).to.eq(doc)\n        })\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/2927\n    it('can properly handle objects with \\'jquery\\' functions as properties', () => {\n      // the root issue here has to do with the fact that window.jquery points\n      // to the jquery constructor, but not an actual jquery instance and\n      // we need to account for that...\n      cy.window().then((win) => {\n        win.jquery = function () {}\n\n        return win\n      })\n    })\n\n    it('can extend the default timeout', () => {\n      Cypress.config('defaultCommandTimeout', 100)\n\n      const timeoutPromise = new Promise((resolve, reject) => {\n        return setTimeout(() => {\n          resolve(null)\n        })\n      }, 200)\n\n      cy.wrap(timeoutPromise, { timeout: 300 })\n    })\n\n    describe('errors', () => {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          if (attrs.name === 'wrap') {\n            this.lastLog = log\n            this.logs.push(log)\n          }\n        })\n\n        return null\n      })\n\n      it('throws when wrapping an array of windows', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.include('`cy.scrollTo()` failed because it requires a DOM element.')\n          expect(err.message).to.include('[<window>]')\n          expect(err.message).to.include('All 2 subject validations failed on this subject.')\n\n          done()\n        })\n\n        cy.window().then((win) => {\n          cy.wrap([win]).scrollTo('bottom')\n        })\n      })\n\n      it('throws when wrapping an array of documents', (done) => {\n        cy.on('fail', (err) => {\n          expect(err.message).to.include('`cy.screenshot()` failed because it requires a DOM element.')\n          expect(err.message).to.include('[<document>]')\n          expect(err.message).to.include('All 3 subject validations failed on this subject.')\n\n          done()\n        })\n\n        cy.document().then((doc) => {\n          cy.wrap([doc]).screenshot()\n        })\n      })\n\n      it('throws when exceeding default timeout', function (done) {\n        Cypress.config('defaultCommandTimeout', 100)\n\n        cy.on('fail', (err) => {\n          expect(this.logs.length).to.eq(1)\n          expect(err.message).to.include('`cy.wrap()` timed out waiting `100ms` to complete.')\n          expect(err.message).to.include('You called `cy.wrap()` with a promise that never resolved.')\n          expect(err.message).to.include('To increase the timeout, use `{ timeout: number }`')\n          expect(this.lastLog.get('error')).to.eq(err)\n          done()\n        })\n\n        const timeoutPromise = new Promise((resolve) => {\n          setTimeout((() => {\n            resolve(null)\n          }), 200)\n        })\n\n        cy.wrap(timeoutPromise)\n      })\n\n      it('throws when exceeding custom timeout', function (done) {\n        cy.on('fail', (err) => {\n          expect(this.logs.length).to.eq(1)\n          expect(err.message).to.include('`cy.wrap()` timed out waiting `100ms` to complete.')\n          expect(err.message).to.include('You called `cy.wrap()` with a promise that never resolved.')\n          expect(err.message).to.include('To increase the timeout, use `{ timeout: number }`')\n          expect(this.lastLog.get('error')).to.eq(err)\n          done()\n        })\n\n        const timeoutPromise = new Promise((resolve) => {\n          setTimeout((() => {\n            resolve(null)\n          }), 200)\n        })\n\n        cy.wrap(timeoutPromise, { timeout: 100 })\n      })\n\n      it('logs once when promise parameter is rejected', function (done) {\n        cy.on('fail', (err) => {\n          expect(this.logs.length).to.eq(1)\n          expect(err.message).to.include('custom error')\n          expect(this.lastLog.get('error')).to.eq(err)\n          done()\n        })\n\n        const rejectedPromise = new Promise((resolve, reject) => {\n          reject(new Error('custom error'))\n        })\n\n        cy.wrap(rejectedPromise)\n      })\n    })\n\n    describe('.log', () => {\n      beforeEach(function () {\n        this.logs = []\n\n        cy.on('log:added', (attrs, log) => {\n          this.lastLog = log\n          this.logs.push(log)\n        })\n\n        return null\n      })\n\n      it('logs immediately', function (done) {\n        cy.on('log:added', (attrs, log) => {\n          cy.removeAllListeners('log:added')\n\n          expect(log.get('message')).to.eq('{}')\n          expect(log.get('name')).to.eq('wrap')\n          expect(log.get('end')).not.to.be.ok\n\n          done()\n        })\n\n        cy.wrap({}).then(() => {\n          const { lastLog } = this\n\n          expect(lastLog.get('ended')).to.be.true\n          expect(lastLog.get('snapshots').length).to.eq(1)\n          expect(lastLog.get('snapshots')[0]).to.be.an('object')\n        })\n      })\n\n      it('stringifies DOM elements and sets $el', () => {\n        const body = $('body')\n\n        cy.wrap(body).then(function ($el) {\n          const { lastLog } = this\n\n          // internally we store the real remote jquery\n          // instance instead of the cypress one\n          expect(lastLog.get('$el')).not.to.eq($el)\n\n          // but make sure they are the same DOM object\n          expect(lastLog.get('$el').get(0)).to.eq($el.get(0))\n          expect(lastLog.get('message')).to.eq('<body>')\n        })\n      })\n    })\n  })\n})\n",
    "packages/driver/cypress/integration/cypress/script_utils_spec.js": "const Promise = require('bluebird')\nconst $scriptUtils = require('@packages/driver/src/cypress/script_utils')\nconst $networkUtils = require('@packages/driver/src/cypress/network_utils')\nconst $sourceMapUtils = require('@packages/driver/src/cypress/source_map_utils')\n\ndescribe('src/cypress/script_utils', () => {\n  context('#runScripts', () => {\n    let scriptWindow\n    const scripts = [\n      { relativeUrl: 'cypress/integration/script1.js' },\n      { relativeUrl: 'cypress/integration/script2.js' },\n    ]\n\n    beforeEach(() => {\n      scriptWindow = {\n        eval: cy.stub(),\n        __onscriptIframeReady: cy.stub(),\n      }\n\n      cy.stub($networkUtils, 'fetch').resolves('the script contents')\n      cy.stub($sourceMapUtils, 'extractSourceMap').returns()\n      cy.stub($sourceMapUtils, 'initializeSourceMapConsumer').resolves()\n    })\n\n    it('fetches each script', () => {\n      return $scriptUtils.runScripts(scriptWindow, scripts)\n      .then(() => {\n        expect($networkUtils.fetch).to.be.calledTwice\n        expect($networkUtils.fetch).to.be.calledWith(scripts[0].relativeUrl)\n        expect($networkUtils.fetch).to.be.calledWith(scripts[1].relativeUrl)\n      })\n    })\n\n    it('extracts the source map from each script', () => {\n      return $scriptUtils.runScripts(scriptWindow, scripts)\n      .then(() => {\n        expect($sourceMapUtils.extractSourceMap).to.be.calledTwice\n        expect($sourceMapUtils.extractSourceMap).to.be.calledWith(scripts[0], 'the script contents')\n        expect($sourceMapUtils.extractSourceMap).to.be.calledWith(scripts[1], 'the script contents')\n      })\n    })\n\n    it('evals each script', () => {\n      return $scriptUtils.runScripts(scriptWindow, scripts)\n      .then(() => {\n        expect(scriptWindow.eval).to.be.calledTwice\n        expect(scriptWindow.eval).to.be.calledWith('the script contents\\n//# sourceURL=http://localhost:3500cypress/integration/script1.js')\n        expect(scriptWindow.eval).to.be.calledWith('the script contents\\n//# sourceURL=http://localhost:3500cypress/integration/script2.js')\n      })\n    })\n  })\n\n  context('#runPromises', () => {\n    it('handles promises and doesnt try to fetch + eval manually', async () => {\n      const scriptsAsPromises = [() => Promise.resolve(), () => Promise.resolve()]\n      const result = await $scriptUtils.runScripts({}, scriptsAsPromises)\n\n      expect(result).to.have.length(scriptsAsPromises.length)\n    })\n  })\n})\n",
    "packages/driver/src/cy/net-stubbing/events/after-response.ts": "import { CyHttpMessages } from '@packages/net-stubbing/lib/types'\nimport { HandlerFn } from '.'\nimport { parseJsonBody } from './utils'\n\nexport const onAfterResponse: HandlerFn<CyHttpMessages.ResponseComplete> = async (Cypress, frame, userHandler, { getRequest, getRoute }) => {\n  const request = getRequest(frame.subscription.routeId, frame.requestId)\n\n  if (!request) {\n    return null\n  }\n\n  if (request.response && frame.data.finalResBody) {\n    request.response.body = frame.data.finalResBody\n    parseJsonBody(request.response)\n  }\n\n  request.state = 'Complete'\n\n  request.log.fireChangeEvent()\n  request.log.end()\n\n  // @ts-ignore\n  userHandler && await userHandler(request.response!)\n\n  return null\n}\n",
    "packages/driver/src/cy/net-stubbing/events/index.ts": "import { Route, Interception, StaticResponse, NetEvent } from '../types'\nimport { onBeforeRequest } from './before-request'\nimport { onResponse } from './response'\nimport { onAfterResponse } from './after-response'\nimport { onNetworkError } from './network-error'\nimport Bluebird from 'bluebird'\nimport { getBackendStaticResponse } from '../static-response-utils'\n\nexport type HandlerResult<D> = {\n  changedData: D\n  stopPropagation?: boolean\n} | null\n\nexport type HandlerFn<D> = (Cypress: Cypress.Cypress, frame: NetEvent.ToDriver.Event<D>, userHandler: (data: D) => void | Promise<void>, opts: {\n  getRequest: (routeId: string, requestId: string) => Interception | undefined\n  getRoute: (routeId: string) => Route | undefined\n  emitNetEvent: (eventName: string, frame: any) => Promise<void>\n  sendStaticResponse: (requestId: string, staticResponse: StaticResponse) => void\n}) => Promise<HandlerResult<D>> | HandlerResult<D>\n\nconst netEventHandlers: { [eventName: string]: HandlerFn<any> } = {\n  'before:request': onBeforeRequest,\n  'before:response': onResponse,\n  'response:callback': onResponse,\n  'response': onResponse,\n  'after:response': onAfterResponse,\n  'network:error': onNetworkError,\n}\n\nexport function registerEvents (Cypress: Cypress.Cypress, cy: Cypress.cy) {\n  const { state } = Cypress\n\n  function getRoute (routeId) {\n    return state('routes')[routeId]\n  }\n\n  function getRequest (routeId: string, requestId: string): Interception | undefined {\n    const route = getRoute(routeId)\n\n    if (route) {\n      return route.requests[requestId]\n    }\n\n    return\n  }\n\n  function emitNetEvent (eventName: string, frame: any): Promise<void> {\n    // all messages from driver to server are wrapped in backend:request\n    return Cypress.backend('net', eventName, frame)\n    .catch((err) => {\n      err.message = `An error was thrown while processing a network event: ${err.message}`\n      failCurrentTest(err)\n    })\n  }\n\n  function sendStaticResponse (requestId: string, staticResponse: StaticResponse) {\n    emitNetEvent('send:static:response', {\n      requestId,\n      staticResponse: getBackendStaticResponse(staticResponse),\n    })\n  }\n\n  function failCurrentTest (err: Error) {\n    // @ts-ignore\n    cy.fail(err, { async: true })\n  }\n\n  Cypress.on('test:before:run', () => {\n    // wipe out callbacks, requests, and routes when tests start\n    state('routes', {})\n    state('aliasedRequests', [])\n  })\n\n  Cypress.on('net:event', (eventName, frame: NetEvent.ToDriver.Event<any>) => {\n    Bluebird.try(async () => {\n      const handler = netEventHandlers[eventName]\n\n      if (!handler) {\n        throw new Error(`received unknown net:event in driver: ${eventName}`)\n      }\n\n      const emitResolved = (result: HandlerResult<any>) => {\n        return emitNetEvent('event:handler:resolved', {\n          eventId: frame.eventId,\n          ...result,\n        })\n      }\n\n      const route = getRoute(frame.subscription.routeId)\n\n      if (!route) {\n        if (frame.subscription.await) {\n          // route not found, just resolve so the request can continue\n          emitResolved(frame.data)\n        }\n\n        return\n      }\n\n      const getUserHandler = () => {\n        if (eventName === 'before:request' && !frame.subscription.id) {\n          // users can not explicitly subscribe to the first `before:request` event (req handler)\n          return route && route.handler\n        }\n\n        const request = getRequest(frame.subscription.routeId, frame.requestId)\n\n        const subscription = request && request.subscriptions.find(({ subscription }) => {\n          return subscription.id === frame.subscription.id\n        })\n\n        return subscription && subscription.handler\n      }\n\n      const userHandler = getUserHandler()\n\n      if (frame.subscription.await && !userHandler) {\n        throw new Error('event is waiting for a response, but no user handler was found')\n      }\n\n      const result = await handler(Cypress, frame, userHandler, {\n        getRoute,\n        getRequest,\n        emitNetEvent,\n        sendStaticResponse,\n      })\n\n      if (!frame.subscription.await) {\n        return\n      }\n\n      return emitResolved(result)\n    })\n    .catch(failCurrentTest)\n  })\n\n  return { emitNetEvent }\n}\n",
    "packages/driver/src/cy/net-stubbing/events/network-error.ts": "import { get } from 'lodash'\nimport { CyHttpMessages } from '@packages/net-stubbing/lib/types'\nimport { errByPath, makeErrFromObj } from '../../../cypress/error_utils'\nimport { HandlerFn } from '.'\n\nexport const onNetworkError: HandlerFn<CyHttpMessages.NetworkError> = async (Cypress, frame, userHandler, { getRequest, getRoute }) => {\n  const request = getRequest(frame.subscription.routeId, frame.requestId)\n\n  const { data } = frame\n\n  if (!request) {\n    return null\n  }\n\n  let err = makeErrFromObj(data.error)\n  // does this request have a user response callback handler?\n  const hasResponseHandler = !!request.subscriptions.find(({ subscription }) => {\n    return subscription.eventName === 'response:callback'\n  })\n  const isAwaitingResponse = hasResponseHandler && ['Received', 'Intercepted'].includes(request.state)\n  const isTimeoutError = data.error.code && ['ESOCKETTIMEDOUT', 'ETIMEDOUT'].includes(data.error.code)\n\n  if (isAwaitingResponse || isTimeoutError) {\n    const errorName = isTimeoutError ? 'timeout' : 'network_error'\n\n    err = errByPath(`net_stubbing.request_error.${errorName}`, {\n      innerErr: err,\n      req: request.request,\n      route: get(getRoute(frame.subscription.routeId), 'options'),\n    })\n  }\n\n  // @ts-ignore\n  userHandler && await userHandler(err)\n\n  request.state = 'Errored'\n  request.error = err\n\n  request.log.error(err)\n\n  if (isAwaitingResponse) {\n    // the user is implicitly expecting there to be a successful response from the server, so fail the test\n    // since a network error has occured\n    throw err\n  }\n\n  return null\n}\n",
    "packages/launcher/test/unit/darwin_spec.ts": "import _ from 'lodash'\nimport * as darwinHelper from '../../lib/darwin'\nimport * as linuxHelper from '../../lib/linux'\nimport * as darwinUtil from '../../lib/darwin/util'\nimport { utils } from '../../lib/utils'\nimport { expect } from 'chai'\nimport sinon, { SinonStub } from 'sinon'\nimport { browsers } from '../../lib/browsers'\nimport Bluebird from 'bluebird'\nimport fse from 'fs-extra'\nimport snapshot from 'snap-shot-it'\n\nfunction generatePlist (key, value) {\n  return `\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n    <plist version=\"1.0\">\n      <dict>\n        <key>${key}</key>\n        <string>${value}</string>\n      </dict>\n    </plist>\n  `\n}\n\nfunction stubBrowser (findAppParams: darwinUtil.FindAppParams) {\n  (utils.getOutput as unknown as SinonStub)\n  .withArgs(`mdfind 'kMDItemCFBundleIdentifier==\"${findAppParams.appId}\"' | head -1`)\n  .resolves({ stdout: `/Applications/${findAppParams.appName}` })\n\n  ;(fse.readFile as SinonStub)\n  .withArgs(`/Applications/${findAppParams.appName}/Contents/Info.plist`)\n  .resolves(generatePlist(findAppParams.versionProperty, 'someVersion'))\n}\n\ndescribe('darwin browser detection', () => {\n  beforeEach(() => {\n    sinon.stub(fse, 'readFile').rejects({ code: 'ENOENT' })\n    sinon.stub(utils, 'getOutput').resolves({ stdout: '' })\n  })\n\n  it('detects browsers as expected', async () => {\n    // this test uses the macOS detectors to stub out the expected calls\n    _.forEach(darwinHelper.browsers, (channels) => {\n      _.forEach(channels, stubBrowser)\n    })\n\n    // then, it uses the main browsers list to attempt detection of all browsers, which should succeed\n    const detected = (await Bluebird.mapSeries(browsers, (browser) => {\n      return darwinHelper.detect(browser)\n      .then((foundBrowser) => {\n        const findAppParams = darwinHelper.browsers[browser.name][browser.channel]\n\n        return _.merge(browser, foundBrowser, { findAppParams })\n      })\n    }))\n\n    snapshot(detected)\n  })\n\n  it('getVersionString is re-exported from linuxHelper', () => {\n    expect(darwinHelper.getVersionString).to.eq(linuxHelper.getVersionString)\n  })\n})\n",
    "packages/launcher/test/unit/detect_spec.ts": "require('../spec_helper')\nimport { firefoxGcWarning, detect, detectByPath, setMajorVersion } from '../../lib/detect'\nimport { goalBrowsers } from '../fixtures'\nimport { expect } from 'chai'\nimport { utils } from '../../lib/utils'\nimport sinon, { SinonStub } from 'sinon'\nconst os = require('os')\nimport { log } from '../log'\nimport { project } from 'ramda'\n\nconst isWindows = () => {\n  return os.platform() === 'win32'\n}\n\ndescribe('browser detection', () => {\n  // making simple to debug tests\n  // using DEBUG=... flag\n  const checkBrowsers = (browsers) => {\n    log('detected browsers %j', browsers)\n    expect(browsers).to.be.an('array')\n\n    const mainProps = project(['name', 'version'], browsers)\n\n    log('%d browsers\\n%j', browsers.length, mainProps)\n\n    if (isWindows()) {\n      // we might not find any browsers on Windows CI\n      expect(browsers.length).to.be.gte(0)\n    } else {\n      expect(browsers.length).to.be.gt(0)\n    }\n  }\n\n  // we are only going to run tests on platforms with at least\n  // one browser. This test, is really E2E because it finds\n  // real browsers\n  it('detects available browsers', () => {\n    return detect().then(checkBrowsers)\n  })\n\n  context('#setMajorVersion', () => {\n    const foundBrowser = {\n      name: 'test browser',\n      version: '11.22.33',\n    }\n\n    const res = setMajorVersion(foundBrowser)\n\n    // @ts-ignore\n    expect(res.majorVersion, 'major version was converted to number').to.equal(11)\n  })\n\n  context('#detectByPath', () => {\n    let execa: SinonStub\n\n    beforeEach(() => {\n      execa = sinon.stub(utils, 'getOutput')\n\n      execa.withArgs('/Applications/My Shiny New Browser.app', ['--version'])\n      .resolves({ stdout: 'foo-browser v100.1.2.3' })\n\n      execa.withArgs('/foo/bar/browser', ['--version'])\n      .resolves({ stdout: 'foo-browser v9001.1.2.3' })\n\n      execa.withArgs('/not/a/browser', ['--version'])\n      .resolves({ stdout: 'not a browser version string' })\n\n      execa.withArgs('/not/a/real/path', ['--version'])\n      .rejects()\n    })\n\n    it('detects by path', () => {\n      // @ts-ignore\n      return detectByPath('/foo/bar/browser', goalBrowsers)\n      .then((browser) => {\n        expect(browser).to.deep.equal(\n          Object.assign({}, goalBrowsers.find((gb) => {\n            return gb.name === 'foo-browser'\n          }), {\n            displayName: 'Custom Foo Browser',\n            info: 'Loaded from /foo/bar/browser',\n            custom: true,\n            version: '9001.1.2.3',\n            majorVersion: 9001,\n            path: '/foo/bar/browser',\n          }),\n        )\n      })\n    })\n\n    it('rejects when there was no matching versionRegex', () => {\n      // @ts-ignore\n      return detectByPath('/not/a/browser', goalBrowsers)\n      .then(() => {\n        throw Error('Should not find a browser')\n      })\n      .catch((err) => {\n        expect(err.notDetectedAtPath).to.be.true\n      })\n    })\n\n    it('rejects when there was an error executing the command', () => {\n      // @ts-ignore\n      return detectByPath('/not/a/real/path', goalBrowsers)\n      .then(() => {\n        throw Error('Should not find a browser')\n      })\n      .catch((err) => {\n        expect(err.notDetectedAtPath).to.be.true\n      })\n    })\n\n    it('works with spaces in the path', () => {\n      // @ts-ignore\n      return detectByPath('/Applications/My Shiny New Browser.app', goalBrowsers)\n      .then((browser) => {\n        expect(browser).to.deep.equal(\n          Object.assign({}, goalBrowsers.find((gb) => {\n            return gb.name === 'foo-browser'\n          }), {\n            displayName: 'Custom Foo Browser',\n            info: 'Loaded from /Applications/My Shiny New Browser.app',\n            custom: true,\n            version: '100.1.2.3',\n            majorVersion: 100,\n            path: '/Applications/My Shiny New Browser.app',\n          }),\n        )\n      })\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/8241\n    it('adds warnings to Firefox versions less than 80', async () => {\n      execa.withArgs('/good-firefox', ['--version'])\n      .resolves({ stdout: 'Mozilla Firefox 80.0' })\n\n      execa.withArgs('/bad-firefox', ['--version'])\n      .resolves({ stdout: 'Mozilla Firefox 79.1' })\n\n      expect(await detectByPath('/good-firefox')).to.not.have.property('warning')\n      expect(await detectByPath('/bad-firefox')).to.include({\n        warning: firefoxGcWarning,\n      })\n    })\n  })\n})\n",
    "packages/launcher/test/unit/linux_spec.ts": "require('../spec_helper')\n\nimport _ from 'lodash'\nimport * as linuxHelper from '../../lib/linux'\nimport 'chai-as-promised'\nimport { log } from '../log'\nimport { detect, firefoxGcWarning } from '../../lib/detect'\nimport { browsers } from '../../lib/browsers'\nimport { goalBrowsers } from '../fixtures'\nimport { expect } from 'chai'\nimport { utils } from '../../lib/utils'\nimport os from 'os'\nimport sinon, { SinonStub } from 'sinon'\n\ndescribe('linux browser detection', () => {\n  let execa: SinonStub\n\n  beforeEach(() => {\n    sinon.restore()\n    execa = sinon.stub(utils, 'getOutput')\n\n    execa.withArgs('test-browser', ['--version'])\n    .resolves({ stdout: 'test-browser v100.1.2.3' })\n\n    execa.withArgs('foo-browser', ['--version'])\n    .resolves({ stdout: 'foo-browser v100.1.2.3' })\n\n    execa.withArgs('foo-bar-browser', ['--version'])\n    .resolves({ stdout: 'foo-browser v100.1.2.3' })\n\n    execa.withArgs('/foo/bar/browser', ['--version'])\n    .resolves({ stdout: 'foo-browser v9001.1.2.3' })\n  })\n\n  it('detects browser by running --version', () => {\n    const goal = goalBrowsers[0]\n    const checkBrowser = (browser) => {\n      expect(browser).to.deep.equal({\n        name: 'test-browser-name',\n        path: 'test-browser',\n        version: '100.1.2.3',\n      })\n    }\n\n    // @ts-ignore\n    return linuxHelper.detect(goal).then(checkBrowser)\n  })\n\n  // https://github.com/cypress-io/cypress/pull/7039\n  it('sets profilePath on snapcraft chromium', () => {\n    execa.withArgs('chromium', ['--version'])\n    .resolves({ stdout: 'Chromium 1.2.3 snap' })\n\n    sinon.stub(os, 'platform').returns('linux')\n    sinon.stub(os, 'homedir').returns('/home/foo')\n\n    const checkBrowser = ([browser]) => {\n      expect(browser).to.deep.equal({\n        channel: 'stable',\n        name: 'chromium',\n        family: 'chromium',\n        displayName: 'Chromium',\n        majorVersion: 1,\n        path: 'chromium',\n        profilePath: '/home/foo/snap/chromium/current',\n        version: '1.2.3',\n      })\n    }\n\n    return detect().then(checkBrowser)\n  })\n\n  // https://github.com/cypress-io/cypress/issues/6669\n  it('detects browser if the --version stdout is multiline', () => {\n    execa.withArgs('multiline-foo', ['--version'])\n    .resolves({\n      stdout: `\n        Running without a11y support!\n        foo-browser v9001.1.2.3\n      `,\n    })\n\n    const goal = _.defaults({ binary: 'multiline-foo' }, _.find(goalBrowsers, { name: 'foo-browser' }))\n    const checkBrowser = (browser) => {\n      expect(browser).to.deep.equal({\n        name: 'foo-browser',\n        path: 'multiline-foo',\n        version: '9001.1.2.3',\n      })\n    }\n\n    // @ts-ignore\n    return linuxHelper.detect(goal).then(checkBrowser)\n  })\n\n  // @see https://github.com/cypress-io/cypress/issues/8241\n  it('adds warnings to Firefox versions less than 80', async () => {\n    const goalFirefox = _.find(browsers, { binary: 'firefox' })\n\n    sinon.stub(os, 'platform').withArgs().returns('linux')\n    execa.withArgs('firefox', ['--version']).resolves({ stdout: 'Mozilla Firefox 79.1' })\n\n    expect((await detect([goalFirefox]))[0]).to.include({\n      warning: firefoxGcWarning,\n    })\n  })\n\n  // despite using detect(), this test is in linux/spec instead of detect_spec because it is\n  // testing side effects that occur within the Linux-specific detect function\n  // https://github.com/cypress-io/cypress/issues/1400\n  it('properly eliminates duplicates', () => {\n    const expected = [\n      {\n        displayName: 'Test Browser',\n        name: 'test-browser-name',\n        version: '100.1.2.3',\n        path: 'test-browser',\n        majorVersion: 100,\n      },\n      {\n        displayName: 'Foo Browser',\n        name: 'foo-browser',\n        version: '100.1.2.3',\n        path: 'foo-browser',\n        majorVersion: 100,\n      },\n    ]\n\n    // @ts-ignore\n    return detect(goalBrowsers).then((browsers) => {\n      log('Browsers: %o', browsers)\n      log('Expected browsers: %o', expected)\n      expect(browsers).to.deep.equal(expected)\n    })\n  })\n\n  it('considers multiple binary names', () => {\n    const goalBrowsers = [\n      {\n        name: 'foo-browser',\n        versionRegex: /v(\\S+)$/,\n        binary: ['foo-browser', 'foo-bar-browser'],\n      },\n    ]\n\n    const expected = [\n      {\n        name: 'foo-browser',\n        version: '100.1.2.3',\n        path: 'foo-browser',\n        majorVersion: 100,\n      },\n    ]\n\n    // @ts-ignore\n    return detect(goalBrowsers).then((browsers) => {\n      log('Browsers: %o', browsers)\n      log('Expected browsers: %o', expected)\n      expect(browsers).to.deep.equal(expected)\n    })\n  })\n\n  context('#getVersionString', () => {\n    it('runs the command with `--version` and returns trimmed output', async () => {\n      execa.withArgs('foo', ['--version']).resolves({ stdout: '  bar  ' })\n\n      expect(await linuxHelper.getVersionString('foo')).to.eq('bar')\n    })\n\n    it('rejects with errors', async () => {\n      const err = new Error()\n\n      execa.withArgs('foo', ['--version']).rejects(err)\n\n      await expect(linuxHelper.getVersionString('foo')).to.be.rejectedWith(err)\n    })\n  })\n})\n",
    "packages/launcher/test/unit/windows_spec.ts": "import _ from 'lodash'\nimport { expect } from 'chai'\nimport * as windowsHelper from '../../lib/windows'\nimport { normalize } from 'path'\nimport { utils } from '../../lib/utils'\nimport sinon, { SinonStub } from 'sinon'\nimport { browsers } from '../../lib/browsers'\nimport Bluebird from 'bluebird'\nimport fse from 'fs-extra'\nimport os from 'os'\nimport snapshot from 'snap-shot-it'\nimport { Browser } from '../../lib/types'\nimport { detectByPath } from '../../lib/detect'\nimport { goalBrowsers } from '../fixtures'\n\nfunction stubBrowser (path: string, version: string) {\n  path = windowsHelper.doubleEscape(normalize(path))\n\n  ;(utils.execa as unknown as SinonStub)\n  .withArgs('wmic', ['datafile', 'where', `name=\"${path}\"`, 'get', 'Version', '/value'])\n  .resolves({ stdout: `Version=${version}` })\n\n  ;(fse.pathExists as SinonStub)\n  .withArgs(path)\n  .resolves(true)\n}\n\nfunction detect (goalBrowsers: Browser[]) {\n  return Bluebird.mapSeries(goalBrowsers, (browser) => {\n    return windowsHelper.detect(browser)\n    .then((foundBrowser) => {\n      return _.merge(browser, foundBrowser)\n    })\n  })\n}\n\nconst HOMEDIR = 'C:/Users/flotwig'\n\ndescribe('windows browser detection', () => {\n  beforeEach(() => {\n    sinon.stub(fse, 'pathExists').resolves(false)\n    sinon.stub(os, 'homedir').returns(HOMEDIR)\n    sinon.stub(utils, 'execa').rejects()\n  })\n\n  it('detects browsers as expected', async () => {\n    stubBrowser('C:/Program Files (x86)/Google/Chrome/Application/chrome.exe', '1.2.3')\n    stubBrowser('C:/Program Files (x86)/Google/chrome-win32/chrome.exe', '2.3.4')\n\n    stubBrowser('C:/Program Files (x86)/Google/Chrome Beta/Application/chrome.exe', '6.7.8')\n\n    // canary is installed in homedir\n    stubBrowser(`${HOMEDIR}/AppData/Local/Google/Chrome SxS/Application/chrome.exe`, '3.4.5')\n\n    // have 32-bit and 64-bit ff - 64-bit will be preferred\n    stubBrowser('C:/Program Files (x86)/Mozilla Firefox/firefox.exe', '72')\n    stubBrowser('C:/Program Files/Mozilla Firefox/firefox.exe', '72')\n\n    // 32-bit dev edition\n    stubBrowser('C:/Program Files (x86)/Firefox Developer Edition/firefox.exe', '73')\n\n    // 64-bit nightly edition\n    stubBrowser('C:/Program Files/Firefox Nightly/firefox.exe', '74')\n\n    stubBrowser('C:/Program Files (x86)/Microsoft/Edge/Application/msedge.exe', '11')\n    stubBrowser('C:/Program Files (x86)/Microsoft/Edge Beta/Application/msedge.exe', '12')\n    stubBrowser('C:/Program Files (x86)/Microsoft/Edge Dev/Application/msedge.exe', '13')\n\n    // edge canary is installed in homedir\n    stubBrowser(`${HOMEDIR}/AppData/Local/Microsoft/Edge SxS/Application/msedge.exe`, '14')\n\n    snapshot(await detect(browsers))\n  })\n\n  it('detects 64-bit Chrome Beta app path', async () => {\n    stubBrowser('C:/Program Files/Google/Chrome Beta/Application/chrome.exe', '9.0.1')\n    const chrome = _.find(browsers, { name: 'chrome', channel: 'beta' })\n\n    snapshot(await windowsHelper.detect(chrome))\n  })\n\n  // @see https://github.com/cypress-io/cypress/issues/8425\n  it('detects new Chrome 64-bit app path', async () => {\n    stubBrowser('C:/Program Files/Google/Chrome/Application/chrome.exe', '4.4.4')\n    const chrome = _.find(browsers, { name: 'chrome', channel: 'stable' })\n\n    snapshot(await windowsHelper.detect(chrome))\n  })\n\n  // @see https://github.com/cypress-io/cypress/issues/8432\n  it('detects local Firefox installs', async () => {\n    stubBrowser(`${HOMEDIR}/AppData/Local/Mozilla Firefox/firefox.exe`, '100')\n    stubBrowser(`${HOMEDIR}/AppData/Local/Firefox Nightly/firefox.exe`, '200')\n    stubBrowser(`${HOMEDIR}/AppData/Local/Firefox Developer Edition/firefox.exe`, '300')\n\n    const firefoxes = _.filter(browsers, { family: 'firefox' })\n\n    snapshot(await detect(firefoxes))\n  })\n\n  it('works with :browserName format in Windows', () => {\n    sinon.stub(os, 'platform').returns('win32')\n    let path = `${HOMEDIR}/foo/bar/browser.exe`\n    let win10Path = windowsHelper.doubleEscape(path)\n\n    stubBrowser(path, '100')\n\n    return detectByPath(`${path}:foo-browser`, goalBrowsers as Browser[]).then((browser) => {\n      expect(browser).to.deep.equal(\n        Object.assign({}, goalBrowsers.find((gb) => {\n          return gb.name === 'foo-browser'\n        }), {\n          displayName: 'Custom Foo Browser',\n          info: `Loaded from ${win10Path}`,\n          custom: true,\n          version: '100',\n          majorVersion: 100,\n          path: win10Path,\n        }),\n      )\n    })\n  })\n\n  it('identifies browser if name in path', async () => {\n    sinon.stub(os, 'platform').returns('win32')\n    let path = `${HOMEDIR}/foo/bar/chrome.exe`\n    let win10Path = windowsHelper.doubleEscape(path)\n\n    stubBrowser(path, '100')\n\n    return detectByPath(path).then((browser) => {\n      expect(browser).to.deep.equal(\n        Object.assign({}, browsers.find((gb) => {\n          return gb.name === 'chrome'\n        }), {\n          displayName: 'Custom Chrome',\n          info: `Loaded from ${win10Path}`,\n          custom: true,\n          version: '100',\n          majorVersion: 100,\n          path: win10Path,\n        }),\n      )\n    })\n  })\n\n  context('#getVersionString', () => {\n    it('runs wmic and returns output', async () => {\n      stubBrowser('foo', 'bar')\n\n      expect(await windowsHelper.getVersionString('foo')).to.eq('Version=bar')\n    })\n\n    it('rejects with errors', async () => {\n      const err = new Error()\n\n      ;(utils.execa as unknown as SinonStub)\n      .withArgs('wmic', ['datafile', 'where', 'name=\"foo\"', 'get', 'Version', '/value'])\n      .rejects(err)\n\n      await expect(windowsHelper.getVersionString('foo')).to.be.rejectedWith(err)\n    })\n  })\n\n  context('#getPathData', () => {\n    it('returns path and browserKey given path with browser key', () => {\n      const browserPath = 'C:\\\\foo\\\\bar.exe'\n      const res = windowsHelper.getPathData(`${browserPath}:firefox`)\n\n      expect(res.path).to.eq(windowsHelper.doubleEscape(browserPath))\n      expect(res.browserKey).to.eq('firefox')\n    })\n\n    it('returns path and browserKey given path with a lot of slashes plus browser key', () => {\n      const browserPath = 'C:\\\\\\\\\\\\\\\\foo\\\\\\\\\\\\bar.exe'\n      const res = windowsHelper.getPathData(`${browserPath}:firefox`)\n\n      expect(res.path).to.eq(windowsHelper.doubleEscape(browserPath))\n      expect(res.browserKey).to.eq('firefox')\n    })\n\n    it('returns path and browserKey given nix path with browser key', () => {\n      const browserPath = 'C:/foo/bar.exe'\n      const res = windowsHelper.getPathData(`${browserPath}:firefox`)\n\n      expect(res.path).to.eq(windowsHelper.doubleEscape(browserPath))\n      expect(res.browserKey).to.eq('firefox')\n    })\n\n    it('returns path and chrome given just path', () => {\n      const browserPath = 'C:\\\\foo\\\\bar\\\\chrome.exe'\n      const res = windowsHelper.getPathData(browserPath)\n\n      expect(res.path).to.eq(windowsHelper.doubleEscape(browserPath))\n      expect(res.browserKey).to.eq('chrome')\n    })\n\n    it('returns path and chrome given just nix path', () => {\n      const browserPath = 'C:/foo/bar/chrome.exe'\n      const res = windowsHelper.getPathData(browserPath)\n\n      expect(res.path).to.eq(windowsHelper.doubleEscape(browserPath))\n      expect(res.browserKey).to.eq('chrome')\n    })\n\n    it('returns path and edge given just path for edge', () => {\n      const browserPath = 'C:\\\\foo\\\\bar\\\\edge.exe'\n      const res = windowsHelper.getPathData(browserPath)\n\n      expect(res.path).to.eq(windowsHelper.doubleEscape(browserPath))\n      expect(res.browserKey).to.eq('edge')\n    })\n\n    it('returns path and edge given just path for msedge', () => {\n      const browserPath = 'C:\\\\foo\\\\bar\\\\msedge.exe'\n      const res = windowsHelper.getPathData(browserPath)\n\n      expect(res.path).to.eq(windowsHelper.doubleEscape(browserPath))\n      expect(res.browserKey).to.eq('edge')\n    })\n\n    it('returns path and edge given just nix path', () => {\n      const browserPath = 'C:/foo/bar/edge.exe'\n      const res = windowsHelper.getPathData(browserPath)\n\n      expect(res.path).to.eq(windowsHelper.doubleEscape(browserPath))\n      expect(res.browserKey).to.eq('edge')\n    })\n\n    it('returns path and edge given just nix path for msedge', () => {\n      const browserPath = 'C:/foo/bar/msedge.exe'\n      const res = windowsHelper.getPathData(browserPath)\n\n      expect(res.path).to.eq(windowsHelper.doubleEscape(browserPath))\n      expect(res.browserKey).to.eq('edge')\n    })\n\n    it('returns path and firefox given just path', () => {\n      const browserPath = 'C:\\\\foo\\\\bar\\\\firefox.exe'\n      const res = windowsHelper.getPathData(browserPath)\n\n      expect(res.path).to.eq(windowsHelper.doubleEscape(browserPath))\n      expect(res.browserKey).to.eq('firefox')\n    })\n\n    it('returns path and firefox given just nix path', () => {\n      const browserPath = 'C:/foo/bar/firefox.exe'\n      const res = windowsHelper.getPathData(browserPath)\n\n      expect(res.path).to.eq(windowsHelper.doubleEscape(browserPath))\n      expect(res.browserKey).to.eq('firefox')\n    })\n  })\n\n  context('#doubleEscape', () => {\n    let winPath = 'C:\\\\\\\\foo\\\\\\\\bar.exe'\n\n    it('converts nix path into double escaped win path', async () => {\n      let nixPath = 'C:/foo/bar.exe'\n\n      expect(windowsHelper.doubleEscape(nixPath)).to.eq(winPath)\n    })\n\n    it('converts win path with different backslash combination into double escaped win path', async () => {\n      let badWinPath = 'C:\\\\\\\\\\\\\\\\\\\\foo\\\\bar.exe'\n\n      expect(windowsHelper.doubleEscape(badWinPath)).to.eq(winPath)\n    })\n\n    it('converts single escaped win path into double escaped win path', async () => {\n      let badWinPath = 'C:\\\\foo\\\\bar.exe'\n\n      expect(windowsHelper.doubleEscape(badWinPath)).to.eq(winPath)\n    })\n\n    it('does not affect an already double escaped win path', async () => {\n      let badWinPath = 'C:\\\\\\\\foo\\\\\\\\bar.exe'\n\n      expect(windowsHelper.doubleEscape(badWinPath)).to.eq(badWinPath)\n    })\n  })\n})\n",
    "packages/net-stubbing/lib/server/middleware/error.ts": "import Debug from 'debug'\n\nimport { ErrorMiddleware } from '@packages/proxy'\nimport { CyHttpMessages } from '../../types'\nimport _ from 'lodash'\nimport errors from '@packages/server/lib/errors'\n\nconst debug = Debug('cypress:net-stubbing:server:intercept-error')\n\nexport const InterceptError: ErrorMiddleware = async function () {\n  const request = this.netStubbingState.requests[this.req.requestId]\n\n  if (!request) {\n    // the original request was not intercepted, nothing to do\n    return this.next()\n  }\n\n  debug('intercepting error %o', { req: this.req, request })\n\n  request.continueResponse = this.next\n\n  await request.handleSubscriptions<CyHttpMessages.NetworkError>({\n    eventName: 'network:error',\n    data: {\n      error: errors.clone(this.error),\n    },\n    mergeChanges: _.noop,\n  })\n\n  this.next()\n}\n",
    "packages/net-stubbing/lib/server/middleware/response.ts": "import _ from 'lodash'\nimport { concatStream, httpUtils } from '@packages/network'\nimport Debug from 'debug'\nimport { Readable } from 'stream'\nimport { getEncoding } from 'istextorbinary'\n\nimport {\n  ResponseMiddleware,\n} from '@packages/proxy'\nimport {\n  CyHttpMessages,\n  SERIALIZABLE_RES_PROPS,\n} from '../../types'\nimport {\n  getBodyStream,\n  mergeDeletedHeaders,\n} from '../util'\n\nconst debug = Debug('cypress:net-stubbing:server:intercept-response')\n\nexport const InterceptResponse: ResponseMiddleware = async function () {\n  const request = this.netStubbingState.requests[this.req.requestId]\n\n  debug('InterceptResponse %o', { req: _.pick(this.req, 'url'), request })\n\n  if (!request) {\n    // original request was not intercepted, nothing to do\n    return this.next()\n  }\n\n  request.onResponse = (incomingRes, resStream) => {\n    this.incomingRes = incomingRes\n\n    request.continueResponse!(resStream)\n  }\n\n  request.continueResponse = (newResStream?: Readable) => {\n    if (newResStream) {\n      this.incomingResStream = newResStream.on('error', this.onError)\n    }\n\n    this.next()\n  }\n\n  this.makeResStreamPlainText()\n\n  const body: Buffer | string = await new Promise<Buffer>((resolve) => {\n    if (httpUtils.responseMustHaveEmptyBody(this.req, this.incomingRes)) {\n      resolve(Buffer.from(''))\n    } else {\n      this.incomingResStream.pipe(concatStream(resolve))\n    }\n  })\n  .then((buf) => {\n    return getEncoding(buf) !== 'binary' ? buf.toString('utf8') : buf\n  })\n\n  const res = _.extend(_.pick(this.incomingRes, SERIALIZABLE_RES_PROPS), {\n    url: this.req.proxiedUrl,\n    body,\n  }) as CyHttpMessages.IncomingResponse\n\n  if (!_.isString(res.body) && !_.isBuffer(res.body)) {\n    throw new Error('res.body must be a string or a Buffer')\n  }\n\n  const mergeChanges = (before: CyHttpMessages.IncomingResponse, after: CyHttpMessages.IncomingResponse) => {\n    _.merge(before, _.pick(after, SERIALIZABLE_RES_PROPS))\n\n    mergeDeletedHeaders(before, after)\n  }\n\n  const modifiedRes = await request.handleSubscriptions<CyHttpMessages.IncomingResponse>({\n    eventName: ['before:response', 'response:callback', 'response'],\n    data: res,\n    mergeChanges,\n  })\n\n  mergeChanges(request.res as any, modifiedRes)\n\n  const bodyStream = getBodyStream(modifiedRes.body, _.pick(modifiedRes, ['throttleKbps', 'delay']) as any)\n\n  return request.continueResponse!(bodyStream)\n}\n",
    "packages/net-stubbing/lib/server/util.ts": "import _ from 'lodash'\nimport Debug from 'debug'\nimport isHtml from 'is-html'\nimport { IncomingMessage } from 'http'\nimport {\n  RouteMatcherOptionsGeneric,\n  STRING_MATCHER_FIELDS,\n  DICT_STRING_MATCHER_FIELDS,\n  BackendStaticResponse,\n} from '../types'\nimport { Readable, PassThrough } from 'stream'\nimport CyServer from '@packages/server'\nimport { Socket } from 'net'\nimport { GetFixtureFn } from './types'\nimport ThrottleStream from 'throttle'\nimport MimeTypes from 'mime-types'\nimport { CypressIncomingRequest } from '@packages/proxy'\nimport { InterceptedRequest } from './intercepted-request'\n\n// TODO: move this into net-stubbing once cy.route is removed\nimport { parseContentType } from '@packages/server/lib/controllers/xhrs'\nimport { CyHttpMessages } from '../external-types'\nimport { getEncoding } from 'istextorbinary'\n\nconst debug = Debug('cypress:net-stubbing:server:util')\n\nexport function emit (socket: CyServer.Socket, eventName: string, data: object) {\n  if (debug.enabled) {\n    debug('sending event to driver %o', { eventName, data: _.chain(data).cloneDeep().omit('res.body').value() })\n  }\n\n  socket.toDriver('net:event', eventName, data)\n}\n\nexport function getAllStringMatcherFields (options: RouteMatcherOptionsGeneric<any>) {\n  return _.concat(\n    _.filter(STRING_MATCHER_FIELDS, _.partial(_.has, options)),\n    // add the nested DictStringMatcher values to the list of fields\n    _.flatten(\n      _.filter(\n        DICT_STRING_MATCHER_FIELDS.map((field) => {\n          const value = options[field]\n\n          if (value) {\n            return _.keys(value).map((key) => {\n              return `${field}.${key}`\n            })\n          }\n\n          return ''\n        }),\n      ),\n    ),\n  )\n}\n\n/**\n * Generate a \"response object\" that looks like a real Node HTTP response.\n * Instead of directly manipulating the response by using `res.status`, `res.setHeader`, etc.,\n * generating an IncomingMessage allows us to treat the response the same as any other \"real\"\n * HTTP response, which means the proxy layer can apply response middleware to it.\n */\nfunction _getFakeClientResponse (opts: {\n  statusCode: number\n  headers: {\n    [k: string]: string\n  }\n  body: string\n}) {\n  const clientResponse = new IncomingMessage(new Socket)\n\n  // be nice and infer this content-type for the user\n  if (!caseInsensitiveGet(opts.headers || {}, 'content-type') && isHtml(opts.body)) {\n    opts.headers['content-type'] = 'text/html'\n  }\n\n  _.merge(clientResponse, opts)\n\n  return clientResponse\n}\n\nconst caseInsensitiveGet = function (obj, lowercaseProperty) {\n  for (let key of Object.keys(obj)) {\n    if (key.toLowerCase() === lowercaseProperty) {\n      return obj[key]\n    }\n  }\n}\n\nconst caseInsensitiveHas = function (obj, lowercaseProperty) {\n  for (let key of Object.keys(obj)) {\n    if (key.toLowerCase() === lowercaseProperty) {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport function setDefaultHeaders (req: CypressIncomingRequest, res: IncomingMessage) {\n  const setDefaultHeader = (lowercaseHeader: string, defaultValueFn: () => string) => {\n    if (!caseInsensitiveHas(res.headers, lowercaseHeader)) {\n      res.headers[lowercaseHeader] = defaultValueFn()\n    }\n  }\n\n  // https://github.com/cypress-io/cypress/issues/15050\n  // Check if res.headers has a custom header.\n  // If so, set access-control-expose-headers to '*'.\n  const hasCustomHeader = Object.keys(res.headers).some((header) => {\n    // The list of header items that can be accessed from cors request\n    // without access-control-expose-headers\n    // @see https://stackoverflow.com/a/37931084/1038927\n    return ![\n      'cache-control',\n      'content-language',\n      'content-type',\n      'expires',\n      'last-modified',\n      'pragma',\n    ].includes(header.toLowerCase())\n  })\n\n  // We should not override the user's access-control-expose-headers setting.\n  if (hasCustomHeader && !res.headers['access-control-expose-headers']) {\n    setDefaultHeader('access-control-expose-headers', _.constant('*'))\n  }\n\n  setDefaultHeader('access-control-allow-origin', () => caseInsensitiveGet(req.headers, 'origin') || '*')\n  setDefaultHeader('access-control-allow-credentials', _.constant('true'))\n}\n\nexport async function setResponseFromFixture (getFixtureFn: GetFixtureFn, staticResponse: BackendStaticResponse) {\n  const { fixture } = staticResponse\n\n  if (!fixture) {\n    return\n  }\n\n  const data = await getFixtureFn(fixture.filePath, { encoding: fixture.encoding || null })\n\n  const { headers } = staticResponse\n\n  if (!headers || !caseInsensitiveGet(headers, 'content-type')) {\n    // attempt to detect mimeType based on extension, fall back to regular cy.fixture inspection otherwise\n    const mimeType = MimeTypes.lookup(fixture.filePath) || parseContentType(data)\n\n    _.set(staticResponse, 'headers.content-type', mimeType)\n  }\n\n  function getBody (): string {\n    // NOTE: for backwards compatibility with cy.route\n    if (data === null) {\n      return JSON.stringify('')\n    }\n\n    if (!_.isBuffer(data) && !_.isString(data)) {\n      // TODO: probably we can use another function in fixtures.js that doesn't require us to remassage the fixture\n      return JSON.stringify(data)\n    }\n\n    return data\n  }\n\n  staticResponse.body = getBody()\n}\n\n/**\n * Using an existing response object, send a response shaped by a StaticResponse object.\n * @param backendRequest BackendRequest object.\n * @param staticResponse BackendStaticResponse object.\n */\nexport function sendStaticResponse (backendRequest: Pick<InterceptedRequest, 'res' | 'onError' | 'onResponse'>, staticResponse: BackendStaticResponse) {\n  const { onError, onResponse } = backendRequest\n\n  if (staticResponse.forceNetworkError) {\n    debug('forcing network error')\n    const err = new Error('forceNetworkError called')\n\n    return onError(err)\n  }\n\n  const statusCode = staticResponse.statusCode || 200\n  const headers = staticResponse.headers || {}\n  const body = backendRequest.res.body = _.isUndefined(staticResponse.body) ? '' : staticResponse.body\n\n  const incomingRes = _getFakeClientResponse({\n    statusCode,\n    headers,\n    body,\n  })\n\n  const bodyStream = getBodyStream(body, _.pick(staticResponse, 'throttleKbps', 'delay'))\n\n  onResponse!(incomingRes, bodyStream)\n}\n\nexport function getBodyStream (body: Buffer | string | Readable | undefined, options: { delay?: number, throttleKbps?: number }): Readable {\n  const { delay, throttleKbps } = options\n  const pt = new PassThrough()\n\n  const sendBody = () => {\n    let writable = pt\n\n    if (throttleKbps) {\n      // ThrottleStream must be instantiated after any other delays because it uses a `Date.now()`\n      // called at construction-time to decide if it's behind on throttling bytes\n      writable = new ThrottleStream({ bps: throttleKbps * 1024 })\n      writable.pipe(pt)\n    }\n\n    if (!_.isUndefined(body)) {\n      if ((body as Readable).pipe) {\n        return (body as Readable).pipe(writable)\n      }\n\n      writable.write(body)\n    }\n\n    return writable.end()\n  }\n\n  delay ? setTimeout(sendBody, delay) : sendBody()\n\n  return pt\n}\n\nexport function mergeDeletedHeaders (before: CyHttpMessages.BaseMessage, after: CyHttpMessages.BaseMessage) {\n  for (const k in before.headers) {\n    // a header was deleted from `after` but was present in `before`, delete it in `before` too\n    !after.headers[k] && delete before.headers[k]\n  }\n}\n\ntype BodyEncoding = 'utf8' | 'binary' | null\n\nexport function getBodyEncoding (req: CyHttpMessages.IncomingRequest): BodyEncoding {\n  if (!req || !req.body) {\n    return null\n  }\n\n  // a simple heuristic for detecting UTF8 encoded requests\n  if (req.headers && req.headers['content-type']) {\n    const contentType = req.headers['content-type'].toLowerCase()\n\n    if (contentType.includes('charset=utf-8') || contentType.includes('charset=\"utf-8\"')) {\n      return 'utf8'\n    }\n  }\n\n  // with fallback to inspecting the buffer using\n  // https://github.com/bevry/istextorbinary\n  return getEncoding(req.body)\n}\n",
    "packages/proxy/lib/http/util/rewriter.ts": "import * as inject from './inject'\nimport * as astRewriter from './ast-rewriter'\nimport * as regexRewriter from './regex-rewriter'\n\nexport type SecurityOpts = {\n  isHtml?: boolean\n  url: string\n  useAstSourceRewriting: boolean\n  deferSourceMapRewrite: (opts: any) => string\n}\n\nexport type InjectionOpts = {\n  domainName: string\n  wantsInjection: WantsInjection\n  wantsSecurityRemoved: any\n}\n\nconst doctypeRe = /(<\\!doctype.*?>)/i\nconst headRe = /(<head(?!er).*?>)/i\nconst bodyRe = /(<body.*?>)/i\nconst htmlRe = /(<html.*?>)/i\n\ntype WantsInjection = 'full' | 'partial' | false\n\nfunction getRewriter (useAstSourceRewriting: boolean) {\n  return useAstSourceRewriting ? astRewriter : regexRewriter\n}\n\nfunction getHtmlToInject ({ domainName, wantsInjection }: InjectionOpts) {\n  switch (wantsInjection) {\n    case 'full':\n      return inject.full(domainName)\n    case 'partial':\n      return inject.partial(domainName)\n    default:\n      return\n  }\n}\n\nexport async function html (html: string, opts: SecurityOpts & InjectionOpts) {\n  const replace = (re, str) => {\n    return html.replace(re, str)\n  }\n\n  const htmlToInject = await Promise.resolve(getHtmlToInject(opts))\n\n  // strip clickjacking and framebusting\n  // from the HTML if we've been told to\n  if (opts.wantsSecurityRemoved) {\n    html = await Promise.resolve(getRewriter(opts.useAstSourceRewriting).strip(html, opts))\n  }\n\n  if (!htmlToInject) {\n    return html\n  }\n\n  // TODO: move this into regex-rewriting and have ast-rewriting handle this in its own way\n  switch (false) {\n    case !headRe.test(html):\n      return replace(headRe, `$1 ${htmlToInject}`)\n\n    case !bodyRe.test(html):\n      return replace(bodyRe, `<head> ${htmlToInject} </head> $1`)\n\n    case !htmlRe.test(html):\n      return replace(htmlRe, `$1 <head> ${htmlToInject} </head>`)\n\n    case !doctypeRe.test(html):\n      // if only <!DOCTYPE> content, inject <head> after doctype\n      return `${html}<head> ${htmlToInject} </head>`\n\n    default:\n      return `<head> ${htmlToInject} </head>${html}`\n  }\n}\n\nexport function security (opts: SecurityOpts) {\n  return getRewriter(opts.useAstSourceRewriting).stripStream(opts)\n}\n",
    "packages/proxy/test/integration/net-stubbing.spec.ts": "import { NetworkProxy } from '../../'\nimport {\n  netStubbingState as _netStubbingState,\n  NetStubbingState,\n  onNetEvent,\n} from '@packages/net-stubbing'\nimport { defaultMiddleware } from '../../lib/http'\nimport express from 'express'\nimport sinon from 'sinon'\nimport { expect } from 'chai'\nimport supertest from 'supertest'\nimport { allowDestroy } from '@packages/network'\nimport { EventEmitter } from 'events'\n\nconst Request = require('@packages/server/lib/request')\nconst getFixture = async () => {}\n\ncontext('network stubbing', () => {\n  let config\n  let remoteState\n  let netStubbingState: NetStubbingState\n  let app\n  let destinationApp\n  let server\n  let destinationPort\n  let socket\n\n  beforeEach((done) => {\n    config = {}\n    remoteState = {}\n    socket = new EventEmitter()\n    socket.toDriver = sinon.stub()\n    app = express()\n    netStubbingState = _netStubbingState()\n\n    const proxy = new NetworkProxy({\n      socket,\n      netStubbingState,\n      config,\n      middleware: defaultMiddleware,\n      getRemoteState: () => remoteState,\n      getFileServerToken: () => 'fake-token',\n      request: new Request(),\n    })\n\n    app.use((req, res, next) => {\n      req.proxiedUrl = req.url = req.url.slice(1)\n      req.cookies = {}\n      next()\n    })\n\n    app.use((req, res) => {\n      proxy.handleHttpRequest(req, res)\n    })\n\n    destinationApp = express()\n\n    destinationApp.get('/', (req, res) => res.send('it worked'))\n\n    server = allowDestroy(destinationApp.listen(() => {\n      destinationPort = server.address().port\n      done()\n    }))\n  })\n\n  afterEach(() => {\n    server.destroy()\n  })\n\n  it('can make a vanilla request', (done) => {\n    supertest(app)\n    .get(`/http://localhost:${destinationPort}`)\n    .expect('it worked', done)\n  })\n\n  it('does not add CORS headers to all responses', () => {\n    return supertest(app)\n    .get(`/http://localhost:${destinationPort}`)\n    .then((res) => {\n      expect(res.headers).to.not.have.property('access-control-allow-origin')\n    })\n  })\n\n  it('adds CORS headers to static stubs', () => {\n    netStubbingState.routes.push({\n      id: '1',\n      routeMatcher: {\n        url: '*',\n      },\n      hasInterceptor: false,\n      staticResponse: {\n        body: 'foo',\n      },\n      getFixture: async () => {},\n    })\n\n    return supertest(app)\n    .get(`/http://localhost:${destinationPort}`)\n    .then((res) => {\n      expect(res.headers).to.include({\n        'access-control-allow-origin': '*',\n        'access-control-allow-credentials': 'true',\n      })\n\n      expect(res.text).to.eq('foo')\n    })\n  })\n\n  it('does not override CORS headers', () => {\n    netStubbingState.routes.push({\n      id: '1',\n      routeMatcher: {\n        url: '*',\n      },\n      hasInterceptor: false,\n      staticResponse: {\n        body: 'foo',\n        headers: {\n          'access-control-allow-origin': 'something',\n        },\n      },\n      getFixture: async () => {},\n    })\n\n    return supertest(app)\n    .get(`/http://localhost:${destinationPort}`)\n    .then((res) => {\n      expect(res.headers).to.include({\n        'access-control-allow-origin': 'something',\n      })\n    })\n  })\n\n  it('uses Origin to set CORS header', () => {\n    netStubbingState.routes.push({\n      id: '1',\n      routeMatcher: {\n        url: '*',\n      },\n      hasInterceptor: false,\n      staticResponse: {\n        body: 'foo',\n      },\n      getFixture: async () => {},\n    })\n\n    return supertest(app)\n    .get(`/http://localhost:${destinationPort}`)\n    .set('Origin', 'http://foo.com')\n    .then((res) => {\n      expect(res.headers).to.include({\n        'access-control-allow-origin': 'http://foo.com',\n      })\n    })\n  })\n\n  it('adds CORS headers to dynamically intercepted requests', () => {\n    netStubbingState.routes.push({\n      id: '1',\n      routeMatcher: {\n        url: '*',\n      },\n      hasInterceptor: true,\n      getFixture,\n    })\n\n    socket.toDriver.callsFake((_, event, data) => {\n      if (event === 'before:request') {\n        onNetEvent({\n          eventName: 'send:static:response',\n          // @ts-ignore\n          frame: {\n            requestId: data.requestId,\n            staticResponse: {\n              ...data.data,\n              body: 'replaced',\n            },\n          },\n          state: netStubbingState,\n          getFixture,\n          args: [],\n        })\n      }\n    })\n\n    return supertest(app)\n    .get(`/http://localhost:${destinationPort}`)\n    .then((res) => {\n      expect(res.text).to.eq('replaced')\n      expect(res.headers).to.include({\n        'access-control-allow-origin': '*',\n      })\n    })\n  })\n\n  it('does not modify multipart/form-data files', async () => {\n    const png = Buffer.from('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==', 'base64')\n    let sendContentLength = ''\n    let receivedContentLength = ''\n    let realContentLength = ''\n\n    destinationApp.post('/', (req, res) => {\n      const chunks = []\n\n      req.on('data', (chunk) => {\n        chunks.push(chunk)\n      })\n\n      req.on('error', (error) => {\n        throw error\n      })\n\n      req.on('end', () => {\n        realContentLength = Buffer.byteLength(Buffer.concat(chunks)).toString()\n        receivedContentLength = req.headers['content-length']\n        res.send('ok')\n      })\n    })\n\n    // capture unintercepted content-length\n    await supertest(app)\n    .post(`/http://localhost:${destinationPort}`)\n    .attach('file', png)\n\n    netStubbingState.routes.push({\n      id: '1',\n      routeMatcher: {\n        url: '*',\n      },\n      hasInterceptor: true,\n      getFixture,\n    })\n\n    socket.toDriver.callsFake((_, event, data) => {\n      if (event === 'before:request') {\n        sendContentLength = data.data.headers['content-length']\n        onNetEvent({\n          eventName: 'send:static:response',\n          // @ts-ignore\n          frame: {\n            requestId: data.requestId,\n            staticResponse: {\n              ...data.data,\n            },\n          },\n          state: netStubbingState,\n          getFixture,\n          args: [],\n        })\n      }\n    })\n\n    // capture content-length after intercepting\n    await supertest(app)\n    .post(`/http://localhost:${destinationPort}`)\n    .attach('file', png)\n\n    expect(sendContentLength).to.eq(receivedContentLength)\n    expect(sendContentLength).to.eq(realContentLength)\n  })\n})\n",
    "packages/rewriter/lib/deferred-source-map-cache.ts": "import _ from 'lodash'\nimport Debug from 'debug'\nimport { rewriteJsSourceMapAsync } from './async-rewriters'\nimport * as sourceMaps from './util/source-maps'\nimport url from 'url'\n\nconst debug = Debug('cypress:rewriter:deferred-source-map-cache')\n\nexport type DeferredSourceMapRequest = {\n  uniqueId: string\n  url: string\n  js?: string\n  sourceMap?: any\n  resHeaders?: any\n}\n\nconst caseInsensitiveGet = (obj, lowercaseProperty) => {\n  for (let key of Object.keys(obj)) {\n    if (key.toLowerCase() === lowercaseProperty) {\n      return obj[key]\n    }\n  }\n}\n\nconst getSourceMapHeader = (headers) => {\n  // sourcemap has precedence\n  // @see https://searchfox.org/mozilla-central/rev/dc4560dcaafd79375b9411fdbbaaebb0a59a93ac/devtools/shared/DevToolsUtils.js#611-619\n  return caseInsensitiveGet(headers, 'sourcemap') || caseInsensitiveGet(headers, 'x-sourcemap')\n}\n\n/**\n * Holds on to data necessary to rewrite user JS to maybe generate a sourcemap at a later time,\n * potentially composed with the user's own sourcemap if one is present.\n *\n * The purpose of this is to avoid wasting CPU time and network I/O on generating, composing, and\n * sending a sourcemap along with every single rewritten JS snippet, since the source maps are\n * going to be unused and discarded most of the time.\n */\nexport class DeferredSourceMapCache {\n  _idCounter = 0\n  requests: DeferredSourceMapRequest[] = []\n  requestLib: any\n\n  constructor (requestLib) {\n    this.requestLib = requestLib\n  }\n\n  defer = (request: DeferredSourceMapRequest) => {\n    if (this._getRequestById(request.uniqueId)) {\n      // prevent duplicate uniqueIds from ever existing\n      throw new Error(`Deferred sourcemap key \"${request.uniqueId}\" is not unique`)\n    }\n\n    // remove existing requests for this URL since they will not be loaded again\n    this._removeRequestsByUrl(request.url)\n\n    this.requests.push(request)\n  }\n\n  _removeRequestsByUrl (url: string) {\n    _.remove(this.requests, { url })\n  }\n\n  _getRequestById (uniqueId: string) {\n    return _.find(this.requests, { uniqueId })\n  }\n\n  async _getInputSourceMap (request: DeferredSourceMapRequest, headers: any) {\n    // prefer inline sourceMappingURL over headers\n    const sourceMapUrl = sourceMaps.getMappingUrl(request.js!) || getSourceMapHeader(request.resHeaders)\n\n    if (!sourceMapUrl) {\n      return\n    }\n\n    // try to decode it as a base64 string\n    const inline = sourceMaps.tryDecodeInlineUrl(sourceMapUrl)\n\n    if (inline) {\n      return inline\n    }\n\n    // try to load it from the web\n    const req = {\n      url: url.resolve(request.url, sourceMapUrl),\n      // TODO: this assumes that the sourcemap is on the same base domain, so it's safe to send the same headers\n      // the browser sent for this sourcemap request - but if sourcemap is on a different domain, this will not\n      // be true. need to use browser's cookiejar instead.\n      headers,\n      timeout: 5000,\n    }\n\n    try {\n      const { body } = await this.requestLib(req, true)\n\n      return body\n    } catch (error) {\n      // eslint-disable-next-line no-console\n      debug('got an error loading user-provided sourcemap, serving proxy-generated sourcemap only %o', { url: request.url, headers, error })\n    }\n  }\n\n  async resolve (uniqueId: string, headers: any) {\n    const request = this._getRequestById(uniqueId)\n\n    if (!request) {\n      throw new Error(`Missing request with ID '${uniqueId}'`)\n    }\n\n    if (request.sourceMap) {\n      return request.sourceMap\n    }\n\n    if (!request.js) {\n      throw new Error('Missing JS for source map rewrite')\n    }\n\n    const inputSourceMap = await this._getInputSourceMap(request, headers)\n\n    // cache the sourceMap so we don't need to regenerate it\n    request.sourceMap = await rewriteJsSourceMapAsync(request.url, request.js, inputSourceMap)\n    delete request.js // won't need this again\n    delete request.resHeaders\n\n    return request.sourceMap\n  }\n}\n",
    "packages/rewriter/lib/threads/index.ts": "import _ from 'lodash'\nimport Bluebird from 'bluebird'\nimport Debug from 'debug'\nimport * as path from 'path'\nimport os from 'os'\nimport { MessageChannel, Worker } from 'worker_threads'\nimport { RewriteRequest, RewriteResponse } from './types'\nimport { DeferSourceMapRewriteFn } from '../js'\n\nconst debug = Debug('cypress:rewriter:threads')\n\nconst _debugWorker = !debug.enabled ? _.noop : (worker: WorkerInfo) => {\n  return { ..._.pick(worker, 'isBusy', 'id'), freeWorkers: _.filter(workers, { isBusy: false }).length }\n}\n\nconst _debugOpts = !debug.enabled ? _.noop : (opts: RewriteOpts) => {\n  return { ..._.pick(opts, 'isHtml'), sourceLength: opts.source.length }\n}\n\n// in production, it is preferable to use the transpiled version of `worker.ts`\n// because it does not require importing @packages/ts like development does.\n// this has a huge performance impact, bringing the `responsiveMs` for threads\n// from ~1s to about ~300ms on my system\nconst WORKER_FILENAME = process.env.CYPRESS_INTERNAL_ENV === 'production' ? 'worker.js' : 'worker-shim.js'\n\nconst WORKER_PATH = path.join(__dirname, WORKER_FILENAME)\n\n// spawn up to `os.cpus().length` threads (default to 4 if this call fails)\nconst MAX_WORKER_THREADS = _.get(os.cpus(), 'length') || 4\n\n// spawn up to 4 threads at startup\nconst INITIAL_WORKER_THREADS = Math.min(MAX_WORKER_THREADS, 4)\n\ntype DeferredPromise<T> = { p: Promise<T>, resolve: () => {}, reject: () => {} }\n\ntype WorkerInfo = {\n  id: number\n  thread: Worker\n  isBusy: boolean\n}\n\ntype QueuedRewrite = {\n  deferred: DeferredPromise<string>\n  opts: RewriteOpts\n}\n\ntype RewriteOpts = Pick<RewriteRequest, 'url' | 'source' | 'isHtml' | 'sourceMap' | 'inputSourceMap'> & {\n  deferSourceMapRewrite?: DeferSourceMapRewriteFn\n}\n\nconst workers: WorkerInfo[] = []\nconst queued: QueuedRewrite[] = []\n\nlet originalProcessExit\n\n// HACK: electron can SIGABRT if exiting while worker_threads are active, so overwrite process.exit\n// to ensure that all worker threads are killed *before* exiting.\n// @see https://github.com/electron/electron/issues/23366\nfunction wrapProcessExit () {\n  if (originalProcessExit) {\n    return\n  }\n\n  originalProcessExit = process.exit\n\n  // note - process.exit is normally synchronous, so this could potentially cause strange behavior\n  // @ts-ignore\n  process.exit = _.once(async (...args) => {\n    debug('intercepted process.exit called, closing worker threads')\n    terminateAllWorkers()\n    .delay(100)\n    .finally(() => {\n      debug('all workers terminated, exiting for real')\n      originalProcessExit.call(process, ...args)\n    })\n  })\n}\n\nfunction createWorker () {\n  const startedAt = Date.now()\n  let onlineMs: number\n\n  const thread = new Worker(WORKER_PATH)\n  .on('exit', (exitCode) => {\n    debug('worker exited %o', { exitCode, worker: _debugWorker(worker) })\n    _.remove(workers, worker)\n  })\n  .on('online', () => {\n    onlineMs = Date.now() - startedAt\n  })\n  .on('message', () => {\n    debug('received initial ready message from worker %o', {\n      onlineMs, // time for JS to start executing\n      responsiveMs: Date.now() - startedAt, // time for worker to be ready for commands\n      worker: _debugWorker(worker),\n    })\n  })\n\n  const worker = {\n    id: thread.threadId,\n    isBusy: false,\n    thread,\n  }\n\n  workers.push(worker)\n\n  wrapProcessExit()\n\n  return worker\n}\n\nexport function createInitialWorkers () {\n  // since workers take a little bit of time to start up (due to loading Node and `require`s),\n  // performance can be gained by letting them start before user tests run\n  if (workers.length > 0) {\n    return\n  }\n\n  _.times(INITIAL_WORKER_THREADS, createWorker)\n}\n\n// try to cleanly shut down worker threads to avoid SIGABRT in Electron\n// @see https://github.com/electron/electron/issues/23366\nexport function shutdownWorker (workerInfo: WorkerInfo) {\n  const { thread } = workerInfo\n\n  return new Bluebird((resolve) => {\n    thread.once('exit', resolve)\n    thread.once('error', resolve)\n    thread.postMessage({ shutdown: true })\n  })\n  .timeout(100)\n  .catch((err) => {\n    debug('error cleanly shutting down worker, terminating from parent %o', { err, workerInfo: _debugWorker(workerInfo) })\n\n    return thread.terminate()\n  })\n}\n\nexport function terminateAllWorkers () {\n  return Bluebird.map(workers, shutdownWorker)\n}\n\nasync function sendRewrite (worker: WorkerInfo, opts: RewriteOpts): Promise<string> {\n  const startedAt = Date.now()\n\n  debug('sending rewrite to worker %o', { worker: _debugWorker(worker), opts: _debugOpts(opts) })\n\n  if (worker.isBusy) {\n    throw new Error('worker is already busy')\n  }\n\n  worker.isBusy = true\n\n  if (!getFreeWorker() && workers.length < MAX_WORKER_THREADS) {\n    // create a worker in anticipation of another rewrite coming in\n    createWorker()\n  }\n\n  const { port1, port2 } = new MessageChannel()\n\n  const req: RewriteRequest = {\n    port: port1,\n    ..._.omit(opts, 'deferSourceMapRewrite'),\n  }\n\n  worker.thread.postMessage(req, [req.port])\n\n  const code = await new Promise((resolve, reject) => {\n    const onExit = (exitCode) => {\n      reject(new Error(`worker exited with exit code ${exitCode}`))\n    }\n\n    worker.thread.once('exit', onExit)\n    worker.thread.once('error', reject)\n    port2.on('message', (res: RewriteResponse) => {\n      if (res.deferredSourceMap) {\n        return opts.deferSourceMapRewrite!(res.deferredSourceMap)\n      }\n\n      const totalMs = Date.now() - startedAt\n\n      debug('received response from worker %o', {\n        error: res.error,\n        totalMs: Date.now() - startedAt,\n        threadMs: res.threadMs, // time taken to run rewriting in thread\n        overheadMs: totalMs - res.threadMs, // time not accounted for by `threadMs`\n        worker: _debugWorker(worker),\n        opts: _debugOpts(opts),\n      })\n\n      worker.thread.removeListener('exit', onExit)\n      worker.thread.removeListener('error', reject)\n\n      if (res.error) {\n        return reject(res.error)\n      }\n\n      return resolve(res.output)\n    })\n  })\n  .finally(() => {\n    port2.close()\n    worker.isBusy = false\n    maybeRunNextInQueue()\n  }) as Promise<string>\n\n  return code\n}\n\nfunction maybeRunNextInQueue () {\n  const next = queued.shift()\n\n  if (!next) {\n    return\n  }\n\n  debug('running next rewrite in queue', { opts: _debugOpts() })\n\n  queueRewriting(next.opts)\n  .then(next.deferred.resolve)\n  .catch(next.deferred.reject)\n}\n\nfunction getFreeWorker (): WorkerInfo | undefined {\n  return _.find(workers, { isBusy: false })\n}\n\nexport function queueRewriting (opts: RewriteOpts): Promise<string> {\n  // if a worker is free now, use it\n  const freeWorker = getFreeWorker()\n\n  if (freeWorker) {\n    debug('sending source to free worker')\n\n    return sendRewrite(freeWorker, opts)\n  }\n\n  // if there's room, create a new thread\n  if (workers.length < MAX_WORKER_THREADS) {\n    debug('creating new worker')\n    const newWorker = createWorker()\n\n    return sendRewrite(newWorker, opts)\n  }\n\n  // otherwise enqueue\n  debug('enqueuing source for rewriting %o', { opts: _debugOpts(opts), prevQueueLength: queued.length })\n  const deferred = getDeferredPromise()\n\n  queued.push({ opts, deferred })\n\n  return deferred.p\n}\n\nfunction getDeferredPromise (): DeferredPromise<any> {\n  let resolve; let reject\n\n  const p = new Promise((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  })\n\n  return { p, resolve, reject }\n}\n",
    "packages/rewriter/test/unit/deferred-source-map-cache-spec.ts": "import { DeferredSourceMapCache } from '../../lib/deferred-source-map-cache'\nimport sinon from 'sinon'\nimport chai, { expect } from 'chai'\nimport chaiAsPromised from 'chai-as-promised'\nimport sinonChai from 'sinon-chai'\nimport {\n  testSourceWithExternalSourceMap,\n  testSourceWithInlineSourceMap,\n  testSourceMap,\n  testSourceWithNoSourceMap,\n} from '../fixtures'\nimport snapshot from 'snap-shot-it'\n\nchai.use(chaiAsPromised)\nchai.use(sinonChai)\n\ndescribe('DeferredSourceMapCache', function () {\n  let cache: DeferredSourceMapCache\n\n  beforeEach(() => {\n    cache = new DeferredSourceMapCache(sinon.stub())\n  })\n\n  afterEach(() => {\n    sinon.restore()\n  })\n\n  context('#defer', () => {\n    it('adds to requests', () => {\n      const request = { uniqueId: 'foo', url: 'bar' }\n\n      cache.defer(request)\n      expect(cache.requests).to.deep.eq([request])\n    })\n\n    it('replaces existing requests for same URL', () => {\n      const request0 = { uniqueId: 'kung-fu', url: 'http://other.url/foo.js' }\n      const request1 = { uniqueId: 'foo', url: 'http://bar.baz/quux.js' }\n      const request2 = { uniqueId: 'kung-foo', url: 'http://bar.baz/quux.js' }\n\n      cache.defer(request0)\n      cache.defer(request1)\n      cache.defer(request2)\n      expect(cache.requests).to.deep.eq([request0, request2])\n    })\n\n    it('throws if uniqueId is duplicated', () => {\n      cache.defer({ uniqueId: 'foo', url: 'bar' })\n      expect(() => {\n        cache.defer({ uniqueId: 'foo', url: 'baz' })\n      }).to.throw\n    })\n  })\n\n  context('#resolve', () => {\n    it('rejects if unknown uniqueId', async () => {\n      cache.defer({\n        uniqueId: 'baz',\n        url: 'quux',\n      })\n\n      await expect(cache.resolve('foo', {})).to.be.rejectedWith('Missing request with ID \\'foo\\'')\n    })\n\n    it('rejects if request missing JS', async () => {\n      cache.defer({\n        uniqueId: 'foo',\n        url: 'bar',\n      })\n\n      await expect(cache.resolve('foo', {})).to.be.rejectedWith(/^Missing JS/)\n    })\n\n    context('sourcemap generation', () => {\n      it('for JS with no original sourcemap', async () => {\n        cache.defer({\n          uniqueId: 'foo',\n          url: 'bar',\n          js: 'console.log()',\n          resHeaders: {},\n        })\n\n        snapshot(await cache.resolve('foo', {}))\n      })\n\n      it('resolves with cached sourceMap on retry', async () => {\n        cache.defer({\n          uniqueId: 'foo',\n          url: 'bar',\n          js: 'console.log()',\n          resHeaders: {},\n        })\n\n        const result0 = await cache.resolve('foo', {})\n        const result1 = await cache.resolve('foo', {})\n\n        expect(result0).to.eq(result1) // same object reference\n      })\n\n      context('composition', () => {\n        const URL = 'http://somedomain.net/dir/foo.js'\n\n        const testExternalSourceMap = (js, resHeaders, expectRequest = true) => {\n          return async () => {\n            cache.defer({\n              uniqueId: 'foo',\n              url: URL,\n              js,\n              resHeaders,\n            })\n\n            // @ts-ignore: https://github.com/bahmutov/snap-shot-it/issues/522\n            snapshot('composed sourcemap', await cache.resolve('foo', {}), { allowSharedSnapshot: true })\n\n            if (!expectRequest) {\n              return\n            }\n\n            expect(cache.requestLib).to.be.calledWith({\n              url: 'http://somedomain.net/dir/test.js.map',\n              headers: {},\n              timeout: 5000,\n            })\n          }\n        }\n\n        beforeEach(() => {\n          cache.requestLib.resolves({ body: testSourceMap })\n        })\n\n        it('with inlined base64 sourceMappingURL', testExternalSourceMap(testSourceWithInlineSourceMap, {}, false))\n\n        it('with external sourceMappingURL', testExternalSourceMap(testSourceWithExternalSourceMap, {\n          // sourceMappingURL should override headers\n          'SOURCEmap': 'garbage',\n          'x-sourceMAP': 'garbage',\n        }))\n\n        it('with map referenced by sourcemap header', testExternalSourceMap(testSourceWithNoSourceMap, {\n          'SOURCEmap': 'test.js.map',\n          'x-sourceMAP': 'garbage', // SourceMap header should override x-sourcemap\n        }))\n\n        it('with map referenced by x-sourcemap header', testExternalSourceMap(testSourceWithNoSourceMap, {\n          'x-sourceMAP': 'test.js.map',\n        }))\n      })\n    })\n  })\n})\n",
    "packages/server/lib/browsers/chrome.ts": "import Bluebird from 'bluebird'\nimport check from 'check-more-types'\nimport debugModule from 'debug'\nimport la from 'lazy-ass'\nimport _ from 'lodash'\nimport os from 'os'\nimport path from 'path'\nimport extension from '@packages/extension'\nimport mime from 'mime'\nimport { launch } from '@packages/launcher'\n\nimport appData from '../util/app_data'\nimport { fs } from '../util/fs'\nimport { CdpAutomation } from './cdp_automation'\nimport * as CriClient from './cri-client'\nimport * as protocol from './protocol'\nimport utils from './utils'\nimport { Browser } from './types'\n\n// TODO: this is defined in `cypress-npm-api` but there is currently no way to get there\ntype CypressConfiguration = any\n\nconst debug = debugModule('cypress:server:browsers:chrome')\n\nconst LOAD_EXTENSION = '--load-extension='\nconst CHROME_VERSIONS_WITH_BUGGY_ROOT_LAYER_SCROLLING = '66 67'.split(' ')\nconst CHROME_VERSION_INTRODUCING_PROXY_BYPASS_ON_LOOPBACK = 72\n\nconst CHROME_PREFERENCE_PATHS = {\n  default: path.join('Default', 'Preferences'),\n  defaultSecure: path.join('Default', 'Secure Preferences'),\n  localState: 'Local State',\n}\n\ntype ChromePreferences = {\n  default: object\n  defaultSecure: object\n  localState: object\n}\n\nconst pathToExtension = extension.getPathToExtension()\nconst pathToTheme = extension.getPathToTheme()\n\n// Common Chrome Flags for Automation\n// https://github.com/GoogleChrome/chrome-launcher/blob/master/docs/chrome-flags-for-tools.md\nconst DEFAULT_ARGS = [\n  '--test-type',\n  '--ignore-certificate-errors',\n  '--start-maximized',\n  '--silent-debugger-extension-api',\n  '--no-default-browser-check',\n  '--no-first-run',\n  '--noerrdialogs',\n  '--enable-fixed-layout',\n  '--disable-popup-blocking',\n  '--disable-password-generation',\n  '--disable-single-click-autofill',\n  '--disable-prompt-on-repos',\n  '--disable-background-timer-throttling',\n  '--disable-renderer-backgrounding',\n  '--disable-renderer-throttling',\n  '--disable-backgrounding-occluded-windows',\n  '--disable-restore-session-state',\n  '--disable-new-profile-management',\n  '--disable-new-avatar-menu',\n  '--allow-insecure-localhost',\n  '--reduce-security-for-testing',\n  '--enable-automation',\n  '--disable-print-preview',\n\n  '--disable-device-discovery-notifications',\n\n  // https://github.com/cypress-io/cypress/issues/2376\n  '--autoplay-policy=no-user-gesture-required',\n\n  // http://www.chromium.org/Home/chromium-security/site-isolation\n  // https://github.com/cypress-io/cypress/issues/1951\n  '--disable-site-isolation-trials',\n\n  // the following come frome chromedriver\n  // https://code.google.com/p/chromium/codesearch#chromium/src/chrome/test/chromedriver/chrome_launcher.cc&sq=package:chromium&l=70\n  '--metrics-recording-only',\n  '--disable-prompt-on-repost',\n  '--disable-hang-monitor',\n  '--disable-sync',\n  // this flag is causing throttling of XHR callbacks for\n  // as much as 30 seconds. If you VNC in and open dev tools or\n  // click on a button, it'll \"instantly\" work. with this\n  // option enabled, it will time out some of our tests in circle\n  // \"--disable-background-networking\"\n  '--disable-web-resources',\n  '--safebrowsing-disable-download-protection',\n  '--disable-client-side-phishing-detection',\n  '--disable-component-update',\n  '--disable-default-apps',\n\n  // These flags are for webcam/WebRTC testing\n  // https://github.com/cypress-io/cypress/issues/2704\n  '--use-fake-ui-for-media-stream',\n  '--use-fake-device-for-media-stream',\n\n  // so Cypress commands don't get throttled\n  // https://github.com/cypress-io/cypress/issues/5132\n  '--disable-ipc-flooding-protection',\n\n  // misc. options puppeteer passes\n  // https://github.com/cypress-io/cypress/issues/3633\n  '--disable-backgrounding-occluded-window',\n  '--disable-breakpad',\n  '--password-store=basic',\n  '--use-mock-keychain',\n\n  // write shared memory files into '/tmp' instead of '/dev/shm'\n  // https://github.com/cypress-io/cypress/issues/5336\n  '--disable-dev-shm-usage',\n]\n\n/**\n * Reads all known preference files (CHROME_PREFERENCE_PATHS) from disk and retur\n * @param userDir\n */\nconst _getChromePreferences = (userDir: string): Bluebird<ChromePreferences> => {\n  debug('reading chrome preferences... %o', { userDir, CHROME_PREFERENCE_PATHS })\n\n  return Bluebird.props(_.mapValues(CHROME_PREFERENCE_PATHS, (prefPath) => {\n    return fs.readJson(path.join(userDir, prefPath))\n    .catch((err) => {\n      // return empty obj if it doesn't exist\n      if (err.code === 'ENOENT') {\n        return {}\n      }\n\n      throw err\n    })\n  }))\n}\n\nconst _mergeChromePreferences = (originalPrefs: ChromePreferences, newPrefs: ChromePreferences): ChromePreferences => {\n  return _.mapValues(CHROME_PREFERENCE_PATHS, (_v, prefPath) => {\n    const original = _.cloneDeep(originalPrefs[prefPath])\n\n    if (!newPrefs[prefPath]) {\n      return original\n    }\n\n    let deletions: any[] = []\n\n    _.mergeWith(original, newPrefs[prefPath], (_objValue, newValue, key, obj) => {\n      if (newValue == null) {\n        // setting a key to null should remove it\n        deletions.push([obj, key])\n      }\n    })\n\n    deletions.forEach(([obj, key]) => {\n      delete obj[key]\n    })\n\n    return original\n  })\n}\n\nconst _writeChromePreferences = (userDir: string, originalPrefs: ChromePreferences, newPrefs: ChromePreferences) => {\n  return Bluebird.map(_.keys(originalPrefs), (key) => {\n    const originalJson = originalPrefs[key]\n    const newJson = newPrefs[key]\n\n    if (!newJson || _.isEqual(originalJson, newJson)) {\n      return\n    }\n\n    return fs.outputJson(path.join(userDir, CHROME_PREFERENCE_PATHS[key]), newJson)\n  })\n  .return()\n}\n\nconst getRemoteDebuggingPort = async () => {\n  const port = Number(process.env.CYPRESS_REMOTE_DEBUGGING_PORT)\n\n  return port || utils.getPort()\n}\n\n/**\n * Merge the different `--load-extension` arguments into one.\n *\n * @param extPath path to Cypress extension\n * @param args all browser args\n * @param browser the current browser being launched\n * @returns the modified list of arguments\n */\nconst _normalizeArgExtensions = function (extPath, args, pluginExtensions, browser: Browser): string[] {\n  if (browser.isHeadless) {\n    return args\n  }\n\n  let userExtensions = []\n  const loadExtension = _.find(args, (arg) => {\n    return arg.includes(LOAD_EXTENSION)\n  })\n\n  if (loadExtension) {\n    args = _.without(args, loadExtension)\n\n    // form into array, enabling users to pass multiple extensions\n    userExtensions = userExtensions.concat(loadExtension.replace(LOAD_EXTENSION, '').split(','))\n  }\n\n  if (pluginExtensions) {\n    userExtensions = userExtensions.concat(pluginExtensions)\n  }\n\n  const extensions = [].concat(userExtensions, extPath, pathToTheme)\n\n  args.push(LOAD_EXTENSION + _.compact(extensions).join(','))\n\n  return args\n}\n\n// we now store the extension in each browser profile\nconst _removeRootExtension = () => {\n  return fs\n  .removeAsync(appData.path('extensions'))\n  .catchReturn(null)\n} // noop if doesn't exist fails for any reason\n\n// https://github.com/cypress-io/cypress/issues/2048\nconst _disableRestorePagesPrompt = function (userDir) {\n  const prefsPath = path.join(userDir, 'Default', 'Preferences')\n\n  return fs.readJson(prefsPath)\n  .then((preferences) => {\n    const profile = preferences.profile\n\n    if (profile) {\n      if ((profile['exit_type'] !== 'Normal') || (profile['exited_cleanly'] !== true)) {\n        debug('cleaning up unclean exit status')\n\n        profile['exit_type'] = 'Normal'\n        profile['exited_cleanly'] = true\n\n        return fs.outputJson(prefsPath, preferences)\n      }\n    }\n\n    return\n  })\n  .catch(() => { })\n}\n\n// After the browser has been opened, we can connect to\n// its remote interface via a websocket.\nconst _connectToChromeRemoteInterface = function (port, onError) {\n  // @ts-ignore\n  la(check.userPort(port), 'expected port number to connect CRI to', port)\n\n  debug('connecting to Chrome remote interface at random port %d', port)\n\n  return protocol.getWsTargetFor(port)\n  .then((wsUrl) => {\n    debug('received wsUrl %s for port %d', wsUrl, port)\n\n    return CriClient.create(wsUrl, onError)\n  })\n}\n\nconst _maybeRecordVideo = async function (client, options) {\n  if (!options.onScreencastFrame) {\n    debug('options.onScreencastFrame is false')\n\n    return client\n  }\n\n  debug('starting screencast')\n  client.on('Page.screencastFrame', (meta) => {\n    options.onScreencastFrame(meta)\n    client.send('Page.screencastFrameAck', { sessionId: meta.sessionId })\n  })\n\n  await client.send('Page.startScreencast', {\n    format: 'jpeg',\n  })\n\n  return client\n}\n\n// a utility function that navigates to the given URL\n// once Chrome remote interface client is passed to it.\nconst _navigateUsingCRI = async function (client, url) {\n  // @ts-ignore\n  la(check.url(url), 'missing url to navigate to', url)\n  la(client, 'could not get CRI client')\n  debug('received CRI client')\n  debug('navigating to page %s', url)\n\n  // when opening the blank page and trying to navigate\n  // the focus gets lost. Restore it and then navigate.\n  await client.send('Page.bringToFront')\n  await client.send('Page.navigate', { url })\n}\n\nconst _handleDownloads = async function (client, dir, automation) {\n  await client.send('Page.enable')\n\n  client.on('Page.downloadWillBegin', (data) => {\n    const downloadItem = {\n      id: data.guid,\n      url: data.url,\n    }\n\n    const filename = data.suggestedFilename\n\n    if (filename) {\n      // @ts-ignore\n      downloadItem.filePath = path.join(dir, data.suggestedFilename)\n      // @ts-ignore\n      downloadItem.mime = mime.getType(data.suggestedFilename)\n    }\n\n    automation.push('create:download', downloadItem)\n  })\n\n  client.on('Page.downloadProgress', (data) => {\n    if (data.state !== 'completed') return\n\n    automation.push('complete:download', {\n      id: data.guid,\n    })\n  })\n\n  await client.send('Page.setDownloadBehavior', {\n    behavior: 'allow',\n    downloadPath: dir,\n  })\n}\n\nconst _setAutomation = (client, automation) => {\n  return automation.use(\n    CdpAutomation(client.send),\n  )\n}\n\nexport = {\n  //\n  // tip:\n  //   by adding utility functions that start with \"_\"\n  //   as methods here we can easily stub them from our unit tests\n  //\n\n  _normalizeArgExtensions,\n\n  _removeRootExtension,\n\n  _connectToChromeRemoteInterface,\n\n  _maybeRecordVideo,\n\n  _navigateUsingCRI,\n\n  _handleDownloads,\n\n  _setAutomation,\n\n  _getChromePreferences,\n\n  _mergeChromePreferences,\n\n  _writeChromePreferences,\n\n  async _writeExtension (browser: Browser, options) {\n    if (browser.isHeadless) {\n      debug('chrome is running headlessly, not installing extension')\n\n      return\n    }\n\n    // get the string bytes for the final extension file\n    const str = await extension.setHostAndPath(options.proxyUrl, options.socketIoRoute)\n    const extensionDest = utils.getExtensionDir(browser, options.isTextTerminal)\n    const extensionBg = path.join(extensionDest, 'background.js')\n\n    // copy the extension src to the extension dist\n    await utils.copyExtension(pathToExtension, extensionDest)\n    await fs.writeFileAsync(extensionBg, str)\n\n    return extensionDest\n  },\n\n  _getArgs (browser: Browser, options: CypressConfiguration, port: string) {\n    const args = ([] as string[]).concat(DEFAULT_ARGS)\n\n    if (os.platform() === 'linux') {\n      args.push('--disable-gpu')\n      args.push('--no-sandbox')\n    }\n\n    const ua = options.userAgent\n\n    if (ua) {\n      args.push(`--user-agent=${ua}`)\n    }\n\n    const ps = options.proxyServer\n\n    if (ps) {\n      args.push(`--proxy-server=${ps}`)\n    }\n\n    if (options.chromeWebSecurity === false) {\n      args.push('--disable-web-security')\n      args.push('--allow-running-insecure-content')\n    }\n\n    // prevent AUT shaking in 66 & 67, but flag breaks chrome in 68+\n    // https://github.com/cypress-io/cypress/issues/2037\n    // https://github.com/cypress-io/cypress/issues/2215\n    // https://github.com/cypress-io/cypress/issues/2223\n    const { majorVersion, isHeadless } = browser\n\n    if (CHROME_VERSIONS_WITH_BUGGY_ROOT_LAYER_SCROLLING.includes(majorVersion)) {\n      args.push('--disable-blink-features=RootLayerScrolling')\n    }\n\n    // https://chromium.googlesource.com/chromium/src/+/da790f920bbc169a6805a4fb83b4c2ab09532d91\n    // https://github.com/cypress-io/cypress/issues/1872\n    if (majorVersion >= CHROME_VERSION_INTRODUCING_PROXY_BYPASS_ON_LOOPBACK) {\n      args.push('--proxy-bypass-list=<-loopback>')\n    }\n\n    if (isHeadless) {\n      args.push('--headless')\n\n      // set default headless size to 1920x1080\n      // https://github.com/cypress-io/cypress/issues/6210\n      args.push('--window-size=1920,1080')\n    }\n\n    // force ipv4\n    // https://github.com/cypress-io/cypress/issues/5912\n    args.push(`--remote-debugging-port=${port}`)\n    args.push('--remote-debugging-address=127.0.0.1')\n\n    return args\n  },\n\n  async open (browser: Browser, url, options: CypressConfiguration = {}, automation) {\n    const { isTextTerminal } = options\n\n    const userDir = utils.getProfileDir(browser, isTextTerminal)\n\n    const [port, preferences] = await Bluebird.all([\n      getRemoteDebuggingPort(),\n      _getChromePreferences(userDir),\n    ])\n\n    const defaultArgs = this._getArgs(browser, options, port)\n\n    const defaultLaunchOptions = utils.getDefaultLaunchOptions({\n      preferences,\n      args: defaultArgs,\n    })\n\n    const [cacheDir, launchOptions] = await Bluebird.all([\n      // ensure that we have a clean cache dir\n      // before launching the browser every time\n      utils.ensureCleanCache(browser, isTextTerminal),\n      utils.executeBeforeBrowserLaunch(browser, defaultLaunchOptions, options),\n    ])\n\n    if (launchOptions.preferences) {\n      launchOptions.preferences = _mergeChromePreferences(preferences, launchOptions.preferences as ChromePreferences)\n    }\n\n    const [extDest] = await Bluebird.all([\n      this._writeExtension(\n        browser,\n        options,\n      ),\n      _removeRootExtension(),\n      _disableRestorePagesPrompt(userDir),\n      _writeChromePreferences(userDir, preferences, launchOptions.preferences as ChromePreferences),\n    ])\n    // normalize the --load-extensions argument by\n    // massaging what the user passed into our own\n    const args = _normalizeArgExtensions(extDest, launchOptions.args, launchOptions.extensions, browser)\n\n    // this overrides any previous user-data-dir args\n    // by being the last one\n    args.push(`--user-data-dir=${userDir}`)\n    args.push(`--disk-cache-dir=${cacheDir}`)\n\n    debug('launching in chrome with debugging port', { url, args, port })\n\n    // FIRST load the blank page\n    // first allows us to connect the remote interface,\n    // start video recording and then\n    // we will load the actual page\n    const launchedBrowser = await launch(browser, 'about:blank', args)\n\n    la(launchedBrowser, 'did not get launched browser instance')\n\n    // SECOND connect to the Chrome remote interface\n    // and when the connection is ready\n    // navigate to the actual url\n    const criClient = await this._connectToChromeRemoteInterface(port, options.onError)\n\n    la(criClient, 'expected Chrome remote interface reference', criClient)\n\n    await criClient.ensureMinimumProtocolVersion('1.3')\n    .catch((err) => {\n      // if this minumum chrome version changes, sync it with\n      // packages/web-config/webpack.config.base.ts and\n      // npm/webpack-batteries-included-preprocessor/index.js\n      throw new Error(`Cypress requires at least Chrome 64.\\n\\nDetails:\\n${err.message}`)\n    })\n\n    this._setAutomation(criClient, automation)\n\n    // monkey-patch the .kill method to that the CDP connection is closed\n    const originalBrowserKill = launchedBrowser.kill\n\n    /* @ts-expect-error */\n    launchedBrowser.kill = async (...args) => {\n      debug('closing remote interface client')\n\n      await criClient.close()\n      debug('closing chrome')\n\n      await originalBrowserKill.apply(launchedBrowser, args)\n    }\n\n    await this._maybeRecordVideo(criClient, options)\n    await this._navigateUsingCRI(criClient, url)\n    await this._handleDownloads(criClient, options.downloadsFolder, automation)\n\n    // return the launched browser process\n    // with additional method to close the remote connection\n    return launchedBrowser\n  },\n}\n",
    "packages/server/lib/browsers/electron.js": "const _ = require('lodash')\nconst EE = require('events')\nconst path = require('path')\nconst Bluebird = require('bluebird')\nconst debug = require('debug')('cypress:server:browsers:electron')\nconst menu = require('../gui/menu')\nconst Windows = require('../gui/windows')\nconst { CdpAutomation } = require('./cdp_automation')\nconst savedState = require('../saved_state')\nconst utils = require('./utils')\nconst errors = require('../errors')\n\n// additional events that are nice to know about to be logged\n// https://electronjs.org/docs/api/browser-window#instance-events\nconst ELECTRON_DEBUG_EVENTS = [\n  'close',\n  'responsive',\n  'session-end',\n  'unresponsive',\n]\n\nlet instance = null\n\nconst tryToCall = function (win, method) {\n  try {\n    if (!win.isDestroyed()) {\n      if (_.isString(method)) {\n        return win[method]()\n      }\n\n      return method()\n    }\n  } catch (err) {\n    return debug('got error calling window method:', err.stack)\n  }\n}\n\nconst _getAutomation = function (win, options) {\n  const sendCommand = Bluebird.method((...args) => {\n    return tryToCall(win, () => {\n      return win.webContents.debugger.sendCommand\n      .apply(win.webContents.debugger, args)\n    })\n  })\n\n  const automation = CdpAutomation(sendCommand)\n\n  if (!options.onScreencastFrame) {\n    // after upgrading to Electron 8, CDP screenshots can hang if a screencast is not also running\n    // workaround: start and stop screencasts between screenshots\n    // @see https://github.com/cypress-io/cypress/pull/6555#issuecomment-596747134\n    automation.onRequest = _.wrap(automation.onRequest, async (fn, message, data) => {\n      if (message !== 'take:screenshot') {\n        return fn(message, data)\n      }\n\n      await sendCommand('Page.startScreencast')\n\n      const ret = await fn(message, data)\n\n      await sendCommand('Page.stopScreencast')\n\n      return ret\n    })\n  }\n\n  return automation\n}\n\nconst _installExtensions = function (win, extensionPaths = [], options) {\n  Windows.removeAllExtensions(win)\n\n  return Bluebird.map(extensionPaths, (extensionPath) => {\n    try {\n      return Windows.installExtension(win, extensionPath)\n    } catch (error) {\n      return options.onWarning(errors.get('EXTENSION_NOT_LOADED', 'Electron', extensionPath))\n    }\n  })\n}\n\nconst _maybeRecordVideo = function (webContents, options) {\n  return async () => {\n    const { onScreencastFrame } = options\n\n    debug('maybe recording video %o', { onScreencastFrame })\n\n    if (!onScreencastFrame) {\n      return\n    }\n\n    webContents.debugger.on('message', (event, method, params) => {\n      if (method === 'Page.screencastFrame') {\n        onScreencastFrame(params)\n        webContents.debugger.sendCommand('Page.screencastFrameAck', { sessionId: params.sessionId })\n      }\n    })\n\n    await webContents.debugger.sendCommand('Page.startScreencast', {\n      format: 'jpeg',\n    })\n  }\n}\n\nmodule.exports = {\n  _defaultOptions (projectRoot, state, options, automation) {\n    const _this = this\n\n    const defaults = {\n      x: state.browserX,\n      y: state.browserY,\n      width: state.browserWidth || 1280,\n      height: state.browserHeight || 720,\n      devTools: state.isBrowserDevToolsOpen,\n      minWidth: 100,\n      minHeight: 100,\n      contextMenu: true,\n      partition: this._getPartition(options),\n      trackState: {\n        width: 'browserWidth',\n        height: 'browserHeight',\n        x: 'browserX',\n        y: 'browserY',\n        devTools: 'isBrowserDevToolsOpen',\n      },\n      webPreferences: {\n        sandbox: true,\n      },\n      onFocus () {\n        if (options.show) {\n          return menu.set({ withDevTools: true })\n        }\n      },\n      onNewWindow (e, url) {\n        const _win = this\n\n        return _this._launchChild(e, url, _win, projectRoot, state, options, automation)\n        .then((child) => {\n          // close child on parent close\n          _win.on('close', () => {\n            if (!child.isDestroyed()) {\n              child.destroy()\n            }\n          })\n\n          // add this pid to list of pids\n          tryToCall(child, () => {\n            if (instance && instance.pid) {\n              instance.pid.push(child.webContents.getOSProcessId())\n            }\n          })\n        })\n      },\n    }\n\n    if (options.browser.isHeadless) {\n      // prevents a tiny 1px padding around the window\n      // causing screenshots/videos to be off by 1px\n      options.resizable = false\n    }\n\n    return _.defaultsDeep({}, options, defaults)\n  },\n\n  _getAutomation,\n\n  _render (url, automation, preferences = {}, options = {}) {\n    const win = Windows.create(options.projectRoot, preferences)\n\n    if (preferences.browser.isHeadless) {\n      // seemingly the only way to force headless to a certain screen size\n      // electron BrowserWindow constructor is not respecting width/height preferences\n      win.setSize(preferences.width, preferences.height)\n    } else if (options.isTextTerminal) {\n      // we maximize in headed mode as long as it's run mode\n      // this is consistent with chrome+firefox headed\n      win.maximize()\n    }\n\n    automation.use(_getAutomation(win, preferences))\n\n    return this._launch(win, url, automation, preferences)\n    .tap(_maybeRecordVideo(win.webContents, preferences))\n  },\n\n  _launchChild (e, url, parent, projectRoot, state, options, automation) {\n    e.preventDefault()\n\n    const [parentX, parentY] = parent.getPosition()\n\n    options = this._defaultOptions(projectRoot, state, options)\n\n    _.extend(options, {\n      x: parentX + 100,\n      y: parentY + 100,\n      trackState: false,\n    })\n\n    const win = Windows.create(projectRoot, options)\n\n    // needed by electron since we prevented default and are creating\n    // our own BrowserWindow (https://electron.atom.io/docs/api/web-contents/#event-new-window)\n    e.newGuest = win\n\n    return this._launch(win, url, automation, options)\n  },\n\n  _launch (win, url, automation, options) {\n    if (options.show) {\n      menu.set({ withDevTools: true })\n    }\n\n    ELECTRON_DEBUG_EVENTS.forEach((e) => {\n      win.on(e, () => {\n        debug('%s fired on the BrowserWindow %o', e, { browserWindowUrl: url })\n      })\n    })\n\n    return Bluebird.try(() => {\n      return this._attachDebugger(win.webContents)\n    })\n    .then(() => {\n      let ua\n\n      ua = options.userAgent\n\n      if (ua) {\n        this._setUserAgent(win.webContents, ua)\n      }\n\n      const setProxy = () => {\n        let ps\n\n        ps = options.proxyServer\n\n        if (ps) {\n          return this._setProxy(win.webContents, ps)\n        }\n      }\n\n      return Bluebird.join(\n        setProxy(),\n        this._clearCache(win.webContents),\n      )\n    })\n    .then(() => {\n      return win.loadURL(url)\n    })\n    .then(() => {\n      // enabling can only happen once the window has loaded\n      return this._enableDebugger(win.webContents)\n    })\n    .then(() => {\n      return this._handleDownloads(win, options.downloadsFolder, automation)\n    })\n    .return(win)\n  },\n\n  _attachDebugger (webContents) {\n    try {\n      webContents.debugger.attach('1.3')\n      debug('debugger attached')\n    } catch (err) {\n      debug('debugger attached failed %o', { err })\n      throw err\n    }\n\n    const originalSendCommand = webContents.debugger.sendCommand\n\n    webContents.debugger.sendCommand = function (message, data) {\n      debug('debugger: sending %s with params %o', message, data)\n\n      return originalSendCommand.call(webContents.debugger, message, data)\n      .then((res) => {\n        let debugRes = res\n\n        if (debug.enabled && (_.get(debugRes, 'data.length') > 100)) {\n          debugRes = _.clone(debugRes)\n          debugRes.data = `${debugRes.data.slice(0, 100)} [truncated]`\n        }\n\n        debug('debugger: received response to %s: %o', message, debugRes)\n\n        return res\n      }).catch((err) => {\n        debug('debugger: received error on %s: %o', message, err)\n        throw err\n      })\n    }\n\n    webContents.debugger.sendCommand('Browser.getVersion')\n\n    webContents.debugger.on('detach', (event, reason) => {\n      debug('debugger detached due to %o', { reason })\n    })\n\n    webContents.debugger.on('message', (event, method, params) => {\n      if (method === 'Console.messageAdded') {\n        debug('console message: %o', params.message)\n      }\n    })\n  },\n\n  _enableDebugger (webContents) {\n    debug('debugger: enable Console and Network')\n\n    return webContents.debugger.sendCommand('Console.enable')\n  },\n\n  _handleDownloads (win, dir, automation) {\n    const onWillDownload = (event, downloadItem) => {\n      const savePath = path.join(dir, downloadItem.getFilename())\n\n      automation.push('create:download', {\n        id: downloadItem.getETag(),\n        filePath: savePath,\n        mime: downloadItem.getMimeType(),\n        url: downloadItem.getURL(),\n      })\n\n      downloadItem.once('done', () => {\n        automation.push('complete:download', {\n          id: downloadItem.getETag(),\n        })\n      })\n    }\n\n    const { session } = win.webContents\n\n    session.on('will-download', onWillDownload)\n\n    // avoid adding redundant `will-download` handlers if session is reused for next spec\n    win.on('closed', () => session.removeListener('will-download', onWillDownload))\n\n    return win.webContents.debugger.sendCommand('Page.setDownloadBehavior', {\n      behavior: 'allow',\n      downloadPath: dir,\n    })\n  },\n\n  _getPartition (options) {\n    if (options.isTextTerminal) {\n      // create dynamic persisted run\n      // to enable parallelization\n      return `persist:run-${process.pid}`\n    }\n\n    // we're in interactive mode and always\n    // use the same session\n    return 'persist:interactive'\n  },\n\n  _clearCache (webContents) {\n    debug('clearing cache')\n\n    return webContents.session.clearCache()\n  },\n\n  _setUserAgent (webContents, userAgent) {\n    debug('setting user agent to:', userAgent)\n    // set both because why not\n    webContents.userAgent = userAgent\n\n    return webContents.session.setUserAgent(userAgent)\n  },\n\n  _setProxy (webContents, proxyServer) {\n    return webContents.session.setProxy({\n      proxyRules: proxyServer,\n      // this should really only be necessary when\n      // running Chromium versions >= 72\n      // https://github.com/cypress-io/cypress/issues/1872\n      proxyBypassRules: '<-loopback>',\n    })\n  },\n\n  open (browser, url, options = {}, automation) {\n    const { projectRoot, isTextTerminal } = options\n\n    debug('open %o', { browser, url })\n\n    return savedState.create(projectRoot, isTextTerminal)\n    .then((state) => {\n      return state.get()\n    }).then((state) => {\n      debug('received saved state %o', state)\n\n      // get our electron default options\n      // TODO: this is bad, don't mutate the options object\n      options = this._defaultOptions(projectRoot, state, options, automation)\n\n      // get the GUI window defaults now\n      options = Windows.defaults(options)\n\n      debug('browser window options %o', _.omitBy(options, _.isFunction))\n\n      const defaultLaunchOptions = utils.getDefaultLaunchOptions({\n        preferences: options,\n      })\n\n      return utils.executeBeforeBrowserLaunch(browser, defaultLaunchOptions, options)\n    }).then((launchOptions) => {\n      const { preferences } = launchOptions\n\n      debug('launching browser window to url: %s', url)\n\n      return this._render(url, automation, preferences, {\n        projectRoot: options.projectRoot,\n        isTextTerminal: options.isTextTerminal,\n      })\n      .then(async (win) => {\n        await _installExtensions(win, launchOptions.extensions, options)\n\n        // cause the webview to receive focus so that\n        // native browser focus + blur events fire correctly\n        // https://github.com/cypress-io/cypress/issues/1939\n        tryToCall(win, 'focusOnWebView')\n\n        const events = new EE\n\n        win.once('closed', () => {\n          debug('closed event fired')\n\n          Windows.removeAllExtensions(win)\n\n          return events.emit('exit')\n        })\n\n        instance = _.extend(events, {\n          pid: [tryToCall(win, () => {\n            return win.webContents.getOSProcessId()\n          })],\n          browserWindow: win,\n          kill () {\n            if (this.isProcessExit) {\n              // if the process is exiting, all BrowserWindows will be destroyed anyways\n              return\n            }\n\n            return tryToCall(win, 'destroy')\n          },\n          removeAllListeners () {\n            return tryToCall(win, 'removeAllListeners')\n          },\n        })\n\n        return instance\n      })\n    })\n  },\n}\n",
    "packages/server/lib/browsers/firefox-util.ts": "import Bluebird from 'bluebird'\nimport Debug from 'debug'\nimport _ from 'lodash'\nimport Marionette from 'marionette-client'\nimport { Command } from 'marionette-client/lib/marionette/message.js'\nimport util from 'util'\nimport Foxdriver from '@benmalka/foxdriver'\nimport * as protocol from './protocol'\n\nconst errors = require('../errors')\n\nconst debug = Debug('cypress:server:browsers:firefox-util')\n\nlet forceGcCc: () => Promise<void>\n\nlet timings = {\n  gc: [] as any[],\n  cc: [] as any[],\n  collections: [] as any[],\n}\n\nconst getTabId = (tab) => {\n  return _.get(tab, 'browsingContextID')\n}\n\nconst getDelayMsForRetry = (i) => {\n  if (i < 10) {\n    return 100\n  }\n\n  if (i < 18) {\n    return 500\n  }\n\n  if (i < 63) {\n    return 1000\n  }\n\n  return\n}\n\nconst getPrimaryTab = Bluebird.method((browser) => {\n  const setPrimaryTab = () => {\n    return browser.listTabs()\n    .then((tabs) => {\n      browser.tabs = tabs\n\n      return browser.primaryTab = _.first(tabs)\n    })\n  }\n\n  // on first connection\n  if (!browser.primaryTab) {\n    return setPrimaryTab()\n  }\n\n  // `listTabs` will set some internal state, including marking attached tabs\n  // as detached. so use the raw `request` here:\n  return browser.request('listTabs')\n  .then(({ tabs }) => {\n    const firstTab = _.first(tabs)\n\n    // primaryTab has changed, get all tabs and rediscover first tab\n    if (getTabId(browser.primaryTab.data) !== getTabId(firstTab)) {\n      return setPrimaryTab()\n    }\n\n    return browser.primaryTab\n  })\n})\n\nconst attachToTabMemory = Bluebird.method((tab) => {\n  // TODO: figure out why tab.memory is sometimes undefined\n  if (!tab.memory) return\n\n  if (tab.memory.isAttached) {\n    return\n  }\n\n  return tab.memory.getState()\n  .then((state) => {\n    if (state === 'attached') {\n      return\n    }\n\n    tab.memory.on('garbage-collection', ({ data }) => {\n      data.num = timings.collections.length + 1\n      timings.collections.push(data)\n      debug('received garbage-collection event %o', data)\n    })\n\n    return tab.memory.attach()\n  })\n})\n\nconst logGcDetails = () => {\n  const reducedTimings = {\n    ...timings,\n    collections: _.map(timings.collections, (event) => {\n      return _\n      .chain(event)\n      .extend({\n        duration: _.sumBy(event.collections, (collection: any) => {\n          return collection.endTimestamp - collection.startTimestamp\n        }),\n        spread: _.chain(event.collections).thru((collection) => {\n          const first = _.first(collection)\n          const last = _.last(collection)\n\n          return last.endTimestamp - first.startTimestamp\n        }).value(),\n      })\n      .pick('num', 'nonincrementalReason', 'reason', 'gcCycleNumber', 'duration', 'spread')\n      .value()\n    }),\n  }\n\n  debug('forced GC timings %o', util.inspect(reducedTimings, {\n    breakLength: Infinity,\n    maxArrayLength: Infinity,\n  }))\n\n  debug('forced GC times %o', {\n    gc: reducedTimings.gc.length,\n    cc: reducedTimings.cc.length,\n    collections: reducedTimings.collections.length,\n  })\n\n  debug('forced GC averages %o', {\n    gc: _.chain(reducedTimings.gc).sum().divide(reducedTimings.gc.length).value(),\n    cc: _.chain(reducedTimings.cc).sum().divide(reducedTimings.cc.length).value(),\n    collections: _.chain(reducedTimings.collections).sumBy('duration').divide(reducedTimings.collections.length).value(),\n    spread: _.chain(reducedTimings.collections).sumBy('spread').divide(reducedTimings.collections.length).value(),\n  })\n\n  debug('forced GC totals %o', {\n    gc: _.sum(reducedTimings.gc),\n    cc: _.sum(reducedTimings.cc),\n    collections: _.sumBy(reducedTimings.collections, 'duration'),\n    spread: _.sumBy(reducedTimings.collections, 'spread'),\n  })\n\n  // reset all the timings\n  timings = {\n    gc: [],\n    cc: [],\n    collections: [],\n  }\n}\n\nexport default {\n  log () {\n    logGcDetails()\n  },\n\n  collectGarbage () {\n    return forceGcCc()\n  },\n\n  setup ({\n    extensions,\n    url,\n    marionettePort,\n    foxdriverPort,\n  }) {\n    return Bluebird.all([\n      this.setupFoxdriver(foxdriverPort),\n      this.setupMarionette(extensions, url, marionettePort),\n    ])\n  },\n\n  async setupFoxdriver (port) {\n    await protocol._connectAsync({\n      host: '127.0.0.1',\n      port,\n      getDelayMsForRetry,\n    })\n\n    const foxdriver = await Foxdriver.attach('127.0.0.1', port)\n\n    const { browser } = foxdriver\n\n    browser.on('error', (err) => {\n      debug('received error from foxdriver connection, ignoring %o', err)\n    })\n\n    forceGcCc = () => {\n      let gcDuration; let ccDuration\n\n      const gc = (tab) => {\n        return () => {\n          // TODO: figure out why tab.memory is sometimes undefined\n          if (!tab.memory) return\n\n          const start = Date.now()\n\n          return tab.memory.forceGarbageCollection()\n          .then(() => {\n            gcDuration = Date.now() - start\n            timings.gc.push(gcDuration)\n          })\n        }\n      }\n\n      const cc = (tab) => {\n        return () => {\n          // TODO: figure out why tab.memory is sometimes undefined\n          if (!tab.memory) return\n\n          const start = Date.now()\n\n          return tab.memory.forceCycleCollection()\n          .then(() => {\n            ccDuration = Date.now() - start\n            timings.cc.push(ccDuration)\n          })\n        }\n      }\n\n      debug('forcing GC and CC...')\n\n      return getPrimaryTab(browser)\n      .then((tab) => {\n        return attachToTabMemory(tab)\n        .then(gc(tab))\n        .then(cc(tab))\n      })\n      .then(() => {\n        debug('forced GC and CC completed %o', { ccDuration, gcDuration })\n      })\n      .tapCatch((err) => {\n        debug('firefox RDP error while forcing GC and CC %o', err)\n      })\n    }\n  },\n\n  async setupMarionette (extensions, url, port) {\n    await protocol._connectAsync({\n      host: '127.0.0.1',\n      port,\n      getDelayMsForRetry,\n    })\n\n    const driver = new Marionette.Drivers.Promises({\n      port,\n      tries: 1, // marionette-client has its own retry logic which we want to avoid\n    })\n\n    const sendMarionette = (data) => {\n      return driver.send(new Command(data))\n    }\n\n    debug('firefox: navigating page with webdriver')\n\n    const onError = (from, reject?) => {\n      if (!reject) {\n        reject = (err) => {\n          throw err\n        }\n      }\n\n      return (err) => {\n        debug('error in marionette %o', { from, err })\n        reject(errors.get('FIREFOX_MARIONETTE_FAILURE', from, err))\n      }\n    }\n\n    await driver.connect()\n    .catch(onError('connection'))\n\n    await new Bluebird((resolve, reject) => {\n      const _onError = (from) => {\n        return onError(from, reject)\n      }\n\n      const { tcp } = driver\n\n      tcp.socket.on('error', _onError('Socket'))\n      tcp.client.on('error', _onError('CommandStream'))\n\n      sendMarionette({\n        name: 'WebDriver:NewSession',\n        parameters: { acceptInsecureCerts: true },\n      }).then(() => {\n        return Bluebird.all(_.map(extensions, (path) => {\n          return sendMarionette({\n            name: 'Addon:Install',\n            parameters: { path, temporary: true },\n          })\n        }))\n      })\n      .then(() => {\n        return sendMarionette({\n          name: 'WebDriver:Navigate',\n          parameters: { url },\n        })\n      })\n      .then(resolve)\n      .catch(_onError('commands'))\n    })\n\n    // even though Marionette is not used past this point, we have to keep the session open\n    // or else `acceptInsecureCerts` will cease to apply and SSL validation prompts will appear.\n  },\n}\n",
    "packages/server/lib/browsers/firefox.ts": "import _ from 'lodash'\nimport Bluebird from 'bluebird'\nimport fs from 'fs-extra'\nimport Debug from 'debug'\nimport getPort from 'get-port'\nimport path from 'path'\nimport urlUtil from 'url'\nimport { launch } from '@packages/launcher/lib/browsers'\nimport FirefoxProfile from 'firefox-profile'\nimport firefoxUtil from './firefox-util'\nimport utils from './utils'\nimport * as launcherDebug from '@packages/launcher/lib/log'\nimport { Browser, BrowserInstance } from './types'\nimport { EventEmitter } from 'events'\nimport os from 'os'\nimport treeKill from 'tree-kill'\nimport mimeDb from 'mime-db'\n\nconst errors = require('../errors')\n\nconst debug = Debug('cypress:server:browsers:firefox')\n\n// used to prevent the download prompt for the specified file types.\n// this should cover most/all file types, but if it's necessary to\n// discover more, open Firefox DevTools, download the file yourself\n// and observe the Response Headers content-type in the Network tab\nconst downloadMimeTypes = Object.keys(mimeDb).filter((mimeType) => {\n  return mimeDb[mimeType].extensions?.length\n}).join(',')\n\nconst defaultPreferences = {\n  /**\n   * Taken from https://github.com/puppeteer/puppeteer/blob/8b49dc62a62282543ead43541316e23d3450ff3c/lib/Launcher.js#L520\n   * with minor modifications\n   * BEGIN: Copyright 2017 Google Inc. All rights reserved. Licensed under the Apache License, Version 2.0\n   */\n\n  // Make sure Shield doesn't hit the network.\n  'app.normandy.api_url': '',\n  // Disable Firefox old build background check\n  'app.update.checkInstallTime': false,\n  // Disable automatically upgrading Firefox\n  'app.update.disabledForTesting': true,\n\n  // Increase the APZ content response timeout to 1 minute\n  'apz.content_response_timeout': 60000,\n\n  // Prevent various error message on the console\n  // jest-puppeteer asserts that no error message is emitted by the console\n  'browser.contentblocking.features.standard': '-tp,tpPrivate,cookieBehavior0,-cm,-fp',\n\n  // Enable the dump function: which sends messages to the system\n  // console\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1543115\n  'browser.dom.window.dump.enabled': true,\n  // Disable topstories\n  'browser.newtabpage.activity-stream.feeds.section.topstories': false,\n  // Always display a blank page\n  'browser.newtabpage.enabled': false,\n  // Background thumbnails in particular cause grief: and disabling\n  // thumbnails in general cannot hurt\n  'browser.pagethumbnails.capturing_disabled': true,\n\n  // Disable safebrowsing components.\n  'browser.safebrowsing.blockedURIs.enabled': false,\n  'browser.safebrowsing.downloads.enabled': false,\n  'browser.safebrowsing.malware.enabled': false,\n  'browser.safebrowsing.passwords.enabled': false,\n  'browser.safebrowsing.phishing.enabled': false,\n\n  // Disable updates to search engines.\n  'browser.search.update': false,\n  // Do not restore the last open set of tabs if the browser has crashed\n  'browser.sessionstore.resume_from_crash': false,\n  // Skip check for default browser on startup\n  'browser.shell.checkDefaultBrowser': false,\n\n  // Disable newtabpage\n  'browser.startup.homepage': 'about:blank',\n  // Do not redirect user when a milstone upgrade of Firefox is detected\n  'browser.startup.homepage_override.mstone': 'ignore',\n  // Start with a blank page about:blank\n  'browser.startup.page': 0,\n\n  // Do not allow background tabs to be zombified on Android: otherwise for\n  // tests that open additional tabs: the test harness tab itself might get\n  // unloaded\n  'browser.tabs.disableBackgroundZombification': false,\n  // Do not warn when closing all other open tabs\n  'browser.tabs.warnOnCloseOtherTabs': false,\n  // Do not warn when multiple tabs will be opened\n  'browser.tabs.warnOnOpen': false,\n\n  // Disable the UI tour.\n  'browser.uitour.enabled': false,\n  // Turn off search suggestions in the location bar so as not to trigger\n  // network connections.\n  'browser.urlbar.suggest.searches': false,\n  // Disable first run splash page on Windows 10\n  'browser.usedOnWindows10.introURL': '',\n  // Do not warn on quitting Firefox\n  'browser.warnOnQuit': false,\n\n  // Do not show datareporting policy notifications which can\n  // interfere with tests\n  'datareporting.healthreport.about.reportUrl': '',\n  'datareporting.healthreport.documentServerURI': '',\n  'datareporting.healthreport.logging.consoleEnabled': false,\n  'datareporting.healthreport.service.enabled': false,\n  'datareporting.healthreport.service.firstRun': false,\n  'datareporting.healthreport.uploadEnabled': false,\n  'datareporting.policy.dataSubmissionEnabled': false,\n  'datareporting.policy.dataSubmissionPolicyAccepted': false,\n  'datareporting.policy.dataSubmissionPolicyBypassNotification': true,\n\n  // DevTools JSONViewer sometimes fails to load dependencies with its require.js.\n  // This doesn't affect Puppeteer but spams console (Bug 1424372)\n  'devtools.jsonview.enabled': false,\n\n  // Disable popup-blocker\n  'dom.disable_open_during_load': false,\n\n  // Enable the support for File object creation in the content process\n  // Required for |Page.setFileInputFiles| protocol method.\n  'dom.file.createInChild': true,\n\n  // Disable the ProcessHangMonitor\n  'dom.ipc.reportProcessHangs': false,\n\n  // Disable slow script dialogues\n  'dom.max_chrome_script_run_time': 0,\n  'dom.max_script_run_time': 0,\n\n  // Only load extensions from the application and user profile\n  // AddonManager.SCOPE_PROFILE + AddonManager.SCOPE_APPLICATION\n  'extensions.autoDisableScopes': 0,\n  'extensions.enabledScopes': 5,\n\n  // Disable metadata caching for installed add-ons by default\n  'extensions.getAddons.cache.enabled': false,\n\n  // Disable installing any distribution extensions or add-ons.\n  'extensions.installDistroAddons': false,\n\n  // Disabled screenshots extension\n  'extensions.screenshots.disabled': true,\n\n  // Turn off extension updates so they do not bother tests\n  'extensions.update.enabled': false,\n\n  // Turn off extension updates so they do not bother tests\n  'extensions.update.notifyUser': false,\n\n  // Make sure opening about:addons will not hit the network\n  'extensions.webservice.discoverURL': '',\n\n  // Allow the application to have focus even it runs in the background\n  'focusmanager.testmode': true,\n  // Disable useragent updates\n  'general.useragent.updates.enabled': false,\n  // Always use network provider for geolocation tests so we bypass the\n  // macOS dialog raised by the corelocation provider\n  'geo.provider.testing': true,\n  // Do not scan Wifi\n  'geo.wifi.scan': false,\n  // No hang monitor\n  'hangmonitor.timeout': 0,\n  // Show chrome errors and warnings in the error console\n  'javascript.options.showInConsole': true,\n\n  // Disable download and usage of OpenH264: and Widevine plugins\n  'media.gmp-manager.updateEnabled': false,\n  // Prevent various error message on the console\n  // jest-puppeteer asserts that no error message is emitted by the console\n  'network.cookie.cookieBehavior': 0,\n\n  // Do not prompt for temporary redirects\n  'network.http.prompt-temp-redirect': false,\n\n  // Disable speculative connections so they are not reported as leaking\n  // when they are hanging around\n  'network.http.speculative-parallel-limit': 0,\n\n  // Do not automatically switch between offline and online\n  'network.manage-offline-status': false,\n\n  // Make sure SNTP requests do not hit the network\n  'network.sntp.pools': '',\n\n  // Disable Flash.\n  'plugin.state.flash': 0,\n\n  'privacy.trackingprotection.enabled': false,\n\n  // Enable Remote Agent\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1544393\n  'remote.enabled': true,\n\n  // Don't do network connections for mitm priming\n  'security.certerrors.mitm.priming.enabled': false,\n  // Local documents have access to all other local documents,\n  // including directory listings\n  'security.fileuri.strict_origin_policy': false,\n  // Do not wait for the notification button security delay\n  'security.notification_enable_delay': 0,\n\n  // Ensure blocked updates do not hit the network\n  'services.settings.server': '',\n\n  // Do not automatically fill sign-in forms with known usernames and\n  // passwords\n  'signon.autofillForms': false,\n  // Disable password capture, so that tests that include forms are not\n  // influenced by the presence of the persistent doorhanger notification\n  'signon.rememberSignons': false,\n\n  // Disable first-run welcome page\n  'startup.homepage_welcome_url': 'about:blank',\n\n  // Disable first-run welcome page\n  'startup.homepage_welcome_url.additional': '',\n\n  // Disable browser animations (tabs, fullscreen, sliding alerts)\n  'toolkit.cosmeticAnimations.enabled': false,\n\n  'toolkit.telemetry.server': `''`,\n  // Prevent starting into safe mode after application crashes\n  'toolkit.startup.max_resumed_crashes': -1,\n\n  /**\n   * END: Copyright 2017 Google Inc. All rights reserved.\n   */\n\n  'network.proxy.type': 1,\n\n  // necessary for adding extensions\n  'devtools.debugger.remote-enabled': true,\n  // bind foxdriver to 127.0.0.1\n  'devtools.debugger.remote-host': '127.0.0.1',\n  // devtools.debugger.remote-port is set per-launch\n\n  'devtools.debugger.prompt-connection': false,\n  // \"devtools.debugger.remote-websocket\": true\n  'devtools.chrome.enabled': true,\n  'app.update.auto': false,\n  'app.update.enabled': false,\n  'browser.displayedE10SNotice': 4,\n  'browser.download.manager.showWhenStarting': false,\n  'browser.EULA.override': true,\n  'browser.EULA.3.accepted': true,\n  'browser.link.open_external': 2,\n  'browser.link.open_newwindow': 2,\n  'browser.offline': false,\n  'browser.reader.detectedFirstArticle': true,\n  'browser.selfsupport.url': '',\n  'browser.tabs.warnOnClose': false,\n  'devtools.errorconsole.enabled': true,\n  'extensions.blocklist.enabled': false,\n  'extensions.checkCompatibility.nightly': false,\n  'extensions.logging.enabled': true,\n  'javascript.enabled': true,\n  'network.http.phishy-userpass-length': 255,\n  'offline-apps.allow_by_default': true,\n  'prompts.tab_modal.enabled': false,\n  'security.fileuri.origin_policy': 3,\n  'toolkit.networkmanager.disable': true,\n  'toolkit.telemetry.prompted': 2,\n  'toolkit.telemetry.enabled': false,\n  'toolkit.telemetry.rejected': true,\n  'xpinstall.signatures.required': false,\n  'xpinstall.whitelist.required': false,\n  'browser.laterrun.enabled': false,\n  'browser.newtab.url': 'about:blank',\n  'dom.report_all_js_exceptions': true,\n  'network.captive-portal-service.enabled': false,\n  'security.csp.enable': false,\n  'webdriver_accept_untrusted_certs': true,\n  'webdriver_assume_untrusted_issuer': true,\n  'toolkit.legacyUserProfileCustomizations.stylesheets': true,\n\n  // setting to true hides system window bar, but causes weird resizing issues.\n  'browser.tabs.drawInTitlebar': false,\n\n  // allow playing videos w/o user interaction\n  'media.autoplay.default': 0,\n\n  'browser.safebrowsing.enabled': false,\n\n  // allow capturing screen through getUserMedia(...)\n  // and auto-accept the permissions prompt\n  'media.getusermedia.browser.enabled': true,\n  'media.navigator.permission.disabled': true,\n\n  'dom.min_background_timeout_value': 4,\n  'dom.timeout.enable_budget_timer_throttling': false,\n\n  // allow getUserMedia APIs on insecure domains\n  'media.devices.insecure.enabled':\ttrue,\n  'media.getusermedia.insecure.enabled': true,\n\n  'marionette.log.level': launcherDebug.log.enabled ? 'Debug' : undefined,\n\n  // where to download files\n  // 0: desktop\n  // 1: default \"Downloads\" directory\n  // 2: directory specified with 'browser.download.dir' (set dynamically below)\n  'browser.download.folderList': 2,\n  // prevents the download prompt for the specified types of files\n  'browser.helperApps.neverAsk.saveToDisk': downloadMimeTypes,\n}\n\nconst FIREFOX_HEADED_USERCSS = `\\\n#urlbar:not(.megabar), #urlbar.megabar > #urlbar-background, #searchbar {\n  background: -moz-Field !important;\n  color: -moz-FieldText !important;\n}`\n\nconst FIREFOX_HEADLESS_USERCSS = `\\\n#urlbar {\n  height: 0px !important;\n  min-height: 0px !important;\n  overflow: hidden !important;\n}\n#toolbar {\n  height: 0px !important;\n  min-height: 0px !important;\n  overflow: hidden !important;\n}\ntoolbar {\n  height: 0px !important;\n  min-height: 0px !important;\n  overflow: hidden !important;\n}\n#titlebar {\n  height: 0px !important;\n  min-height: 0px !important;\n  overflow: hidden !important;\n  display: none;\n}\n\n`\n\nexport function _createDetachedInstance (browserInstance: BrowserInstance): BrowserInstance {\n  const detachedInstance: BrowserInstance = new EventEmitter() as BrowserInstance\n\n  detachedInstance.pid = browserInstance.pid\n\n  // kill the entire process tree, from the spawned instance up\n  detachedInstance.kill = (): void => {\n    treeKill(browserInstance.pid, (err?, result?) => {\n      debug('force-exit of process tree complete %o', { err, result })\n      detachedInstance.emit('exit')\n    })\n  }\n\n  return detachedInstance\n}\n\nexport async function open (browser: Browser, url, options: any = {}): Promise<BrowserInstance> {\n  const defaultLaunchOptions = utils.getDefaultLaunchOptions({\n    extensions: [] as string[],\n    preferences: _.extend({}, defaultPreferences),\n    args: [\n      '-marionette',\n      '-new-instance',\n      '-foreground',\n      '-start-debugger-server', // uses the port+host defined in devtools.debugger.remote\n      '-no-remote', // @see https://github.com/cypress-io/cypress/issues/6380\n    ],\n  })\n\n  if (browser.isHeadless) {\n    defaultLaunchOptions.args.push('-headless')\n    // we don't need to specify width/height since MOZ_HEADLESS_ env vars will be set\n    // and the browser will spawn maximized. The user may still supply these args to override\n    // defaultLaunchOptions.args.push('--width=1920')\n    // defaultLaunchOptions.args.push('--height=1081')\n  }\n\n  debug('firefox open %o', options)\n\n  const ps = options.proxyServer\n\n  if (ps) {\n    let { hostname, port, protocol } = urlUtil.parse(ps)\n\n    if (port == null) {\n      port = protocol === 'https:' ? '443' : '80'\n    }\n\n    _.extend(defaultLaunchOptions.preferences, {\n      'network.proxy.allow_hijacking_localhost': true,\n      'network.proxy.http': hostname,\n      'network.proxy.ssl': hostname,\n      'network.proxy.http_port': +port,\n      'network.proxy.ssl_port': +port,\n      'network.proxy.no_proxies_on': '',\n      'browser.download.dir': options.downloadsFolder,\n    })\n  }\n\n  const ua = options.userAgent\n\n  if (ua) {\n    defaultLaunchOptions.preferences['general.useragent.override'] = ua\n  }\n\n  const [\n    foxdriverPort,\n    marionettePort,\n  ] = await Bluebird.all([getPort(), getPort()])\n\n  defaultLaunchOptions.preferences['devtools.debugger.remote-port'] = foxdriverPort\n  defaultLaunchOptions.preferences['marionette.port'] = marionettePort\n\n  debug('available ports: %o', { foxdriverPort, marionettePort })\n\n  const [\n    cacheDir,\n    extensionDest,\n    launchOptions,\n  ] = await Bluebird.all([\n    utils.ensureCleanCache(browser, options.isTextTerminal),\n    utils.writeExtension(browser, options.isTextTerminal, options.proxyUrl, options.socketIoRoute),\n    utils.executeBeforeBrowserLaunch(browser, defaultLaunchOptions, options),\n  ])\n\n  if (Array.isArray(launchOptions.extensions)) {\n    launchOptions.extensions.push(extensionDest)\n  } else {\n    launchOptions.extensions = [extensionDest]\n  }\n\n  const profileDir = utils.getProfileDir(browser, options.isTextTerminal)\n\n  const profile = new FirefoxProfile({\n    destinationDirectory: profileDir,\n  })\n\n  debug('firefox directories %o', { path: profile.path(), cacheDir, extensionDest })\n\n  const xulStorePath = path.join(profile.path(), 'xulstore.json')\n\n  // if user has set custom window.sizemode pref or it's the first time launching on this profile, write to xulStore.\n  if (!await fs.pathExists(xulStorePath)) {\n    // this causes the browser to launch maximized, which chrome does by default\n    // otherwise an arbitrary size will be picked for the window size\n    // this will not have an effect after first launch in 'interactive' mode\n    const sizemode = 'maximized'\n\n    await fs.writeJSON(xulStorePath, { 'chrome://browser/content/browser.xhtml': { 'main-window': { 'width': 1280, 'height': 1024, sizemode } } })\n  }\n\n  launchOptions.preferences['browser.cache.disk.parent_directory'] = cacheDir\n  for (const pref in launchOptions.preferences) {\n    const value = launchOptions.preferences[pref]\n\n    profile.setPreference(pref, value)\n  }\n\n  // TODO: fix this - synchronous FS operation\n  profile.updatePreferences()\n\n  const userCSSPath = path.join(profileDir, 'chrome')\n\n  if (!await fs.pathExists(path.join(userCSSPath, 'userChrome.css'))) {\n    try {\n      await fs.mkdir(userCSSPath)\n    } catch {\n      // probably the folder already exists, this is fine\n    }\n\n    // if we're headed we change the yellow automation mode url bar back to a normal color\n    //\n    // if we're headless we use userCss to 'trick' the browser\n    //  into having a consistent browser window size that's near-fullscreen\n    //  however it unfortunately still leaves 1px of padding at the top)\n    //  without this trick there would be ~74px of padding at the top instead of 1px.\n    //\n    // TODO: allow configuring userCss through launchOptions\n\n    const userCss = options.browser.isHeadless ? FIREFOX_HEADLESS_USERCSS : FIREFOX_HEADED_USERCSS\n\n    await fs.writeFile(path.join(profileDir, 'chrome', 'userChrome.css'), userCss)\n  }\n\n  launchOptions.args = launchOptions.args.concat([\n    '-profile',\n    profile.path(),\n  ])\n\n  debug('launch in firefox', { url, args: launchOptions.args })\n\n  const browserInstance = await launch(browser, 'about:blank', launchOptions.args, {\n    // sets headless resolution to 1920x1080 by default\n    // user can overwrite this default with these env vars or --height, --width arguments\n    MOZ_HEADLESS_WIDTH: '1920',\n    MOZ_HEADLESS_HEIGHT: '1081',\n  })\n\n  await firefoxUtil.setup({ extensions: launchOptions.extensions, url, foxdriverPort, marionettePort })\n  .catch((err) => {\n    errors.throw('FIREFOX_COULD_NOT_CONNECT', err)\n  })\n\n  if (os.platform() === 'win32') {\n    // override the .kill method for Windows so that the detached Firefox process closes between specs\n    // @see https://github.com/cypress-io/cypress/issues/6392\n    return _createDetachedInstance(browserInstance)\n  }\n\n  return browserInstance\n}\n",
    "packages/server/lib/browsers/utils.ts": "import _ from 'lodash'\nimport { FoundBrowser } from '@packages/launcher'\n// @ts-ignore\nimport errors from '../errors'\n// @ts-ignore\nimport plugins from '../plugins'\n\nconst path = require('path')\nconst debug = require('debug')('cypress:server:browsers:utils')\nconst Bluebird = require('bluebird')\nconst getPort = require('get-port')\nconst launcher = require('@packages/launcher')\nconst { fs } = require('../util/fs')\nconst extension = require('@packages/extension')\nconst appData = require('../util/app_data')\nconst profileCleaner = require('../util/profile_cleaner')\n\nconst pathToBrowsers = appData.path('browsers')\nconst legacyProfilesWildcard = path.join(pathToBrowsers, '*')\n\nconst getAppDataPath = (browser) => {\n  if (!browser || !browser.profilePath) {\n    return pathToBrowsers\n  }\n\n  return path.join(browser.profilePath, 'Cypress')\n}\n\nconst getProfileWildcard = (browser) => {\n  return path.join(getAppDataPath(browser), '*')\n}\n\nconst getBrowserPath = (browser) => {\n  // TODO need to check if browser.name is an unempty string\n  return path.join(\n    getAppDataPath(browser),\n    `${browser.name}-${browser.channel}`,\n  )\n}\n\nconst defaultLaunchOptions: {\n  preferences: {[key: string]: any}\n  extensions: string[]\n  args: string[]\n} = {\n  preferences: {},\n  extensions: [],\n  args: [],\n}\n\nconst KNOWN_LAUNCH_OPTION_PROPERTIES = _.keys(defaultLaunchOptions)\n\nconst getDefaultLaunchOptions = (options) => {\n  return _.defaultsDeep(options, defaultLaunchOptions)\n}\n\nconst copyExtension = (src, dest) => {\n  return fs.copyAsync(src, dest)\n}\n\nconst getPartition = function (isTextTerminal) {\n  if (isTextTerminal) {\n    return `run-${process.pid}`\n  }\n\n  return 'interactive'\n}\n\nconst getProfileDir = (browser, isTextTerminal) => {\n  return path.join(\n    getBrowserPath(browser),\n    getPartition(isTextTerminal),\n  )\n}\n\nconst getExtensionDir = (browser, isTextTerminal) => {\n  return path.join(\n    getProfileDir(browser, isTextTerminal),\n    'CypressExtension',\n  )\n}\n\nconst ensureCleanCache = async function (browser, isTextTerminal) {\n  const p = path.join(\n    getProfileDir(browser, isTextTerminal),\n    'CypressCache',\n  )\n\n  await fs.removeAsync(p)\n  await fs.ensureDirAsync(p)\n\n  return p\n}\n\n// we now store profiles inside the Cypress binary folder\n// so we need to remove the legacy root profiles that existed before\nfunction removeLegacyProfiles () {\n  return profileCleaner.removeRootProfile(legacyProfilesWildcard, [\n    path.join(legacyProfilesWildcard, 'run-*'),\n    path.join(legacyProfilesWildcard, 'interactive'),\n  ])\n}\n\nconst removeOldProfiles = function (browser) {\n  // a profile is considered old if it was used\n  // in a previous run for a PID that is either\n  // no longer active, or isnt a cypress related process\n  const pathToPartitions = appData.electronPartitionsPath()\n\n  return Bluebird.all([\n    removeLegacyProfiles(),\n    profileCleaner.removeInactiveByPid(getProfileWildcard(browser), 'run-'),\n    profileCleaner.removeInactiveByPid(pathToPartitions, 'run-'),\n  ])\n}\n\nconst pathToExtension = extension.getPathToExtension()\n\nasync function executeBeforeBrowserLaunch (browser, launchOptions: typeof defaultLaunchOptions, options) {\n  if (plugins.has('before:browser:launch')) {\n    const pluginConfigResult = await plugins.execute('before:browser:launch', browser, launchOptions)\n\n    if (pluginConfigResult) {\n      extendLaunchOptionsFromPlugins(launchOptions, pluginConfigResult, options)\n    }\n  }\n\n  return launchOptions\n}\n\nfunction extendLaunchOptionsFromPlugins (launchOptions, pluginConfigResult, options) {\n  // if we returned an array from the plugin\n  // then we know the user is using the deprecated\n  // interface and we need to warn them\n  // TODO: remove this logic in >= v5.0.0\n  if (pluginConfigResult[0]) {\n    options.onWarning(errors.get(\n      'DEPRECATED_BEFORE_BROWSER_LAUNCH_ARGS',\n    ))\n\n    _.extend(pluginConfigResult, {\n      args: _.filter(pluginConfigResult, (_val, key) => {\n        return _.isNumber(key)\n      }),\n      extensions: [],\n    })\n  } else {\n    // either warn about the array or potentially error on invalid props, but not both\n\n    // strip out all the known launch option properties from the resulting object\n    const unexpectedProperties: string[] = _\n    .chain(pluginConfigResult)\n    .omit(KNOWN_LAUNCH_OPTION_PROPERTIES)\n    .keys()\n    .value()\n\n    if (unexpectedProperties.length) {\n      errors.throw('UNEXPECTED_BEFORE_BROWSER_LAUNCH_PROPERTIES', unexpectedProperties, KNOWN_LAUNCH_OPTION_PROPERTIES)\n    }\n  }\n\n  _.forEach(launchOptions, (val, key) => {\n    const pluginResultValue = pluginConfigResult[key]\n\n    if (pluginResultValue) {\n      if (_.isPlainObject(val)) {\n        launchOptions[key] = _.extend({}, launchOptions[key], pluginResultValue)\n\n        return\n      }\n\n      launchOptions[key] = pluginResultValue\n\n      return\n    }\n  })\n\n  return launchOptions\n}\n\nexport = {\n  extendLaunchOptionsFromPlugins,\n\n  executeBeforeBrowserLaunch,\n\n  defaultLaunchOptions,\n\n  getDefaultLaunchOptions,\n\n  getPort,\n\n  copyExtension,\n\n  getBrowserPath,\n\n  getProfileDir,\n\n  getExtensionDir,\n\n  ensureCleanCache,\n\n  removeOldProfiles,\n\n  getBrowserByPath: launcher.detectByPath,\n\n  writeExtension (browser, isTextTerminal, proxyUrl, socketIoRoute) {\n    debug('writing extension')\n\n    // debug('writing extension to chrome browser')\n    // get the string bytes for the final extension file\n    return extension.setHostAndPath(proxyUrl, socketIoRoute)\n    .then((str) => {\n      const extensionDest = getExtensionDir(browser, isTextTerminal)\n      const extensionBg = path.join(extensionDest, 'background.js')\n\n      // copy the extension src to the extension dist\n      return copyExtension(pathToExtension, extensionDest)\n      .then(() => {\n        debug('copied extension')\n\n        // and overwrite background.js with the final string bytes\n        return fs.writeFileAsync(extensionBg, str)\n      })\n      .return(extensionDest)\n    })\n  },\n\n  getBrowsers () {\n    debug('getBrowsers')\n\n    return launcher.detect()\n    .then((browsers: FoundBrowser[] = []) => {\n      let majorVersion\n\n      debug('found browsers %o', { browsers })\n\n      if (!process.versions.electron) {\n        debug('not in electron, skipping adding electron browser')\n\n        return browsers\n      }\n\n      // @ts-ignore\n      const version = process.versions.chrome || ''\n\n      if (version) {\n        majorVersion = parseFloat(version.split('.')[0])\n      }\n\n      const electronBrowser: FoundBrowser = {\n        name: 'electron',\n        channel: 'stable',\n        family: 'chromium',\n        displayName: 'Electron',\n        version,\n        path: '',\n        majorVersion,\n        info: 'Electron is the default browser that comes with Cypress. This is the default browser that runs in headless mode. Selecting this browser is useful when debugging. The version number indicates the underlying Chromium version that Electron uses.',\n      }\n\n      // the internal version of Electron, which won't be detected by `launcher`\n      debug('adding Electron browser %o', electronBrowser)\n\n      return browsers.concat(electronBrowser)\n    })\n  },\n}\n",
    "packages/server/lib/modes/info.js": "/* eslint-disable no-console */\nconst debug = require('debug')('cypress:server:info')\nconst launcher = require('@packages/launcher')\nconst pluralize = require('pluralize')\nconst { stripIndent } = require('common-tags')\nconst { sortWith, ascend, prop } = require('ramda')\nconst browserUtils = require('../browsers/utils')\nconst _ = require('lodash')\nconst chalk = require('chalk')\nconst { fs } = require('../util/fs')\n\n// color for numbers and short values\nconst n = chalk.green\n// color for paths\nconst p = chalk.cyan\n// color for accents and examples\nconst a = chalk.yellow\n// urls\nconst link = chalk.blue.underline\n\n/**\n * If the list has at least 1 item, picks a random item\n * and returns it AND the remaining items.\n */\nconst pickRandomItem = (list) => {\n  if (!list.length) {\n    return {\n      item: null,\n      remaining: list,\n    }\n  }\n\n  const item = _.sample(list)\n  const remaining = _.without(list, item)\n\n  return {\n    item, remaining,\n  }\n}\n\n// Usually the full browser name to pass via --browser\n// is <name>:<channel>. If the channel is stable, you\n// can just do \"--browser <name>\"\nconst formBrowserName = (browser) => {\n  if (browser.channel === 'stable') {\n    return browser.name\n  }\n\n  return `${browser.name}:${browser.channel}`\n}\n\n// for each browser computes the profile folder\n// and checks if the folder exists. If exists,\n// adds it to the browser object as a property\nconst addProfilePath = async (browsers = []) => {\n  for (const browser of browsers) {\n    const profilePath = browserUtils.getBrowserPath(browser)\n\n    debug('checking profile path %s for browser %s:%s', profilePath, browser.name, browser.channel)\n    try {\n      const profileExists = await fs.statAsync(profilePath)\n\n      if (profileExists && profileExists.isDirectory()) {\n        debug('profile folder exists %s', profilePath)\n        browser.profilePath = profilePath\n      }\n    } catch (e) {\n      debug('problem checking profile folder %s %s', profilePath, e.message)\n    }\n  }\n\n  return browsers\n}\n\nconst print = (browsers = []) => {\n  console.log('Displaying Cypress info...')\n  console.log('')\n  if (browsers.length) {\n    console.log('Detected %s %s installed:', n(browsers.length), pluralize('browser', browsers.length))\n  } else {\n    console.log('Detected no known browsers installed')\n  }\n\n  console.log('')\n\n  const sortByNameAndMajor = sortWith([\n    ascend(prop('name')),\n    ascend(prop('majorVersion')),\n  ])\n  const sortedByNameAndMajorVersion = sortByNameAndMajor(browsers)\n\n  sortedByNameAndMajorVersion.forEach((browser, k) => {\n    const text = stripIndent`\n      ${k + 1}. ${a(browser.displayName)}\n        - Name: ${browser.name}\n        - Channel: ${browser.channel}\n        - Version: ${n(browser.version)}\n        - Executable: ${p(browser.path)}\n        ${browser.profilePath ? `- Profile: ${browser.profilePath}` : ''}\n    `\n\n    console.log(text)\n    console.log('')\n  })\n\n  // randomly a few detected browsers to use as examples\n  if (browsers.length) {\n    const highlightedBrowser = a('--browser')\n\n    console.log('Note: to run these browsers, pass <name>:<channel> to the \\'%s\\' field',\n      highlightedBrowser)\n\n    console.log('')\n\n    const firstDraw = pickRandomItem(browsers)\n\n    if (firstDraw.item) {\n      console.log('Examples:')\n      console.log(a(`- cypress run --browser ${formBrowserName(firstDraw.item)}`))\n\n      const secondDraw = pickRandomItem(firstDraw.remaining)\n\n      if (secondDraw.item) {\n        console.log(a(`- cypress run --browser ${formBrowserName(secondDraw.item)}`))\n      }\n    }\n\n    console.log('')\n    console.log('Learn More: %s', link('https://on.cypress.io/launching-browsers'))\n  }\n}\n\nconst info = () => {\n  return launcher.detect()\n  .then(addProfilePath)\n  .then(print)\n}\n\nmodule.exports = info\n",
    "packages/server/lib/modes/interactive-ct.js": "const serverCt = require('@packages/server-ct')\nconst { getBrowsers } = require('../browsers/utils')\n\nconst browsersForCtInteractive = ['chrome', 'chromium', 'edge', 'electron', 'firefox']\n\nconst returnDefaultBrowser = (browsersByPriority, installedBrowsers) => {\n  const browserMap = installedBrowsers.reduce((acc, curr) => {\n    acc[curr.name] = true\n\n    return acc\n  }, {})\n\n  for (const browser of browsersByPriority) {\n    if (browserMap[browser]) {\n      return browser\n    }\n  }\n}\n\nconst run = async (options) => {\n  const installedBrowsers = await getBrowsers()\n\n  options.browser = options.browser || returnDefaultBrowser(browsersForCtInteractive, installedBrowsers)\n\n  return serverCt.start(options.projectRoot, options)\n}\n\nmodule.exports = {\n  run,\n  returnDefaultBrowser,\n  browsersForCtInteractive,\n}\n",
    "packages/server/lib/modes/interactive-e2e.js": "const _ = require('lodash')\nconst os = require('os')\nconst EE = require('events')\nconst { app } = require('electron')\nconst image = require('electron').nativeImage\nconst cyIcons = require('@cypress/icons')\nconst savedState = require('../saved_state')\nconst menu = require('../gui/menu')\nconst Events = require('../gui/events')\nconst Windows = require('../gui/windows')\n\nconst isDev = () => {\n  return process.env['CYPRESS_INTERNAL_ENV'] === 'development'\n}\n\nmodule.exports = {\n  isMac () {\n    return os.platform() === 'darwin'\n  },\n\n  getWindowArgs (state, options = {}) {\n    const common = {\n      backgroundColor: '#dfe2e4',\n      width: state.appWidth || 800,\n      height: state.appHeight || 550,\n      minWidth: 458,\n      minHeight: 400,\n      x: state.appX,\n      y: state.appY,\n      type: 'INDEX',\n      devTools: state.isAppDevToolsOpen,\n      trackState: {\n        width: 'appWidth',\n        height: 'appHeight',\n        x: 'appX',\n        y: 'appY',\n        devTools: 'isAppDevToolsOpen',\n      },\n      onBlur () {\n        if (this.webContents.isDevToolsOpened()) {\n          return\n        }\n\n        return Windows.hideAllUnlessAnotherWindowIsFocused()\n      },\n      onFocus () {\n        // hide dev tools if in production and previously focused\n        // window was the electron browser\n        menu.set({ withDevTools: isDev() })\n\n        return Windows.showAll()\n      },\n      onClose () {\n        return process.exit()\n      },\n    }\n\n    return _.extend(common, this.platformArgs())\n  },\n\n  platformArgs () {\n    const args = {\n      darwin: {\n        show: true,\n        frame: true,\n        transparent: false,\n      },\n\n      linux: {\n        show: true,\n        frame: true,\n        transparent: false,\n        icon: image.createFromPath(cyIcons.getPathToIcon('icon_128x128.png')),\n      },\n    }\n\n    return args[os.platform()]\n  },\n\n  ready (options = {}) {\n    const bus = new EE\n\n    const { projectRoot } = options\n\n    // TODO: potentially just pass an event emitter\n    // instance here instead of callback functions\n    menu.set({\n      withDevTools: isDev(),\n      onLogOutClicked () {\n        return bus.emit('menu:item:clicked', 'log:out')\n      },\n    })\n\n    return savedState.create(projectRoot, false)\n    .then((state) => {\n      return state.get()\n    })\n    .then((state) => {\n      return Windows.open(projectRoot, this.getWindowArgs(state, options))\n      .then((win) => {\n        Events.start(_.extend({}, options, {\n          onFocusTests () {\n            return app.focus({ steal: true }) || win.focus()\n          },\n          os: os.platform(),\n        }), bus)\n\n        return win\n      })\n    })\n  },\n\n  async run (options) {\n    await app.whenReady()\n\n    return this.ready(options)\n  },\n}\n",
    "packages/server/lib/modes/record.js": "const _ = require('lodash')\nconst la = require('lazy-ass')\nconst chalk = require('chalk')\nconst check = require('check-more-types')\nconst debug = require('debug')('cypress:server:record')\nconst debugCiInfo = require('debug')('cypress:server:record:ci-info')\nconst Promise = require('bluebird')\nconst isForkPr = require('is-fork-pr')\nconst commitInfo = require('@cypress/commit-info')\nconst api = require('../api')\nconst logger = require('../logger')\nconst errors = require('../errors')\nconst capture = require('../capture')\nconst upload = require('../upload')\nconst Config = require('../config')\nconst env = require('../util/env')\nconst keys = require('../util/keys')\nconst terminal = require('../util/terminal')\nconst ciProvider = require('../util/ci_provider')\nconst settings = require('../util/settings')\nconst testsUtils = require('../util/tests_utils')\nconst specWriter = require('../util/spec_writer')\n\nconst logException = (err) => {\n  // give us up to 1 second to\n  // create this exception report\n  return logger.createException(err)\n  .timeout(1000)\n  .catch(() => {})\n}\n\n// dont yell about any errors either\n\nconst runningInternalTests = () => {\n  return env.get('CYPRESS_INTERNAL_E2E_TESTS') === '1'\n}\n\nconst haveProjectIdAndKeyButNoRecordOption = (projectId, options) => {\n  // if we have a project id and we have a key\n  // and record hasn't been set to true or false\n  return (projectId && options.key) && (\n    _.isUndefined(options.record)\n  )\n}\n\nconst warnIfProjectIdButNoRecordOption = (projectId, options) => {\n  if (haveProjectIdAndKeyButNoRecordOption(projectId, options)) {\n    // log a warning telling the user\n    // that they either need to provide us\n    // with a RECORD_KEY or turn off\n    // record mode\n    return errors.warning('PROJECT_ID_AND_KEY_BUT_MISSING_RECORD_OPTION', projectId)\n  }\n}\n\nconst throwDashboardCannotProceed = ({ parallel, ciBuildId, group, err }) => {\n  const errMsg = parallel ? 'DASHBOARD_CANNOT_PROCEED_IN_PARALLEL' : 'DASHBOARD_CANNOT_PROCEED_IN_SERIAL'\n\n  const errToThrow = errors.get(errMsg, {\n    response: err,\n    flags: {\n      group,\n      ciBuildId,\n    },\n  })\n\n  // tells error handler to exit immediately without running anymore specs\n  errToThrow.isFatalApiErr = true\n\n  throw errToThrow\n}\n\nconst throwIfIndeterminateCiBuildId = (ciBuildId, parallel, group) => {\n  if ((!ciBuildId && !ciProvider.provider()) && (parallel || group)) {\n    errors.throw(\n      'INDETERMINATE_CI_BUILD_ID',\n      {\n        group,\n        parallel,\n      },\n      ciProvider.detectableCiBuildIdProviders(),\n    )\n  }\n}\n\nconst throwIfRecordParamsWithoutRecording = (record, ciBuildId, parallel, group, tag) => {\n  if (!record && _.some([ciBuildId, parallel, group, tag])) {\n    errors.throw('RECORD_PARAMS_WITHOUT_RECORDING', {\n      ciBuildId,\n      tag,\n      group,\n      parallel,\n    })\n  }\n}\n\nconst throwIfIncorrectCiBuildIdUsage = (ciBuildId, parallel, group) => {\n  // we've been given an explicit ciBuildId\n  // but no parallel or group flag\n  if (ciBuildId && (!parallel && !group)) {\n    errors.throw('INCORRECT_CI_BUILD_ID_USAGE', { ciBuildId })\n  }\n}\n\nconst throwIfNoProjectId = (projectId, configFile) => {\n  if (!projectId) {\n    errors.throw('CANNOT_RECORD_NO_PROJECT_ID', configFile)\n  }\n}\n\nconst getSpecRelativePath = (spec) => {\n  return _.get(spec, 'relative', null)\n}\n\nconst uploadArtifacts = (options = {}) => {\n  const { video, screenshots, videoUploadUrl, shouldUploadVideo, screenshotUploadUrls, quiet } = options\n\n  const uploads = []\n  let count = 0\n\n  const nums = () => {\n    count += 1\n\n    return chalk.gray(`(${count}/${uploads.length})`)\n  }\n\n  const send = (pathToFile, url) => {\n    const success = () => {\n      if (!quiet) {\n        // eslint-disable-next-line no-console\n        return console.log(`  - Done Uploading ${nums()}`, chalk.blue(pathToFile))\n      }\n    }\n\n    const fail = (err) => {\n      debug('failed to upload artifact %o', {\n        file: pathToFile,\n        stack: err.stack,\n      })\n\n      if (!quiet) {\n        // eslint-disable-next-line no-console\n        return console.log(`  - Failed Uploading ${nums()}`, chalk.red(pathToFile))\n      }\n    }\n\n    return uploads.push(\n      upload.send(pathToFile, url)\n      .then(success)\n      .catch(fail),\n    )\n  }\n\n  if (videoUploadUrl && shouldUploadVideo) {\n    send(video, videoUploadUrl)\n  }\n\n  if (screenshotUploadUrls) {\n    screenshotUploadUrls.forEach((obj) => {\n      const screenshot = _.find(screenshots, { screenshotId: obj.screenshotId })\n\n      return send(screenshot.path, obj.uploadUrl)\n    })\n  }\n\n  if (!uploads.length && !quiet) {\n    // eslint-disable-next-line no-console\n    console.log('  - Nothing to Upload')\n  }\n\n  return Promise\n  .all(uploads)\n  .catch((err) => {\n    errors.warning('DASHBOARD_CANNOT_UPLOAD_RESULTS', err)\n\n    return logException(err)\n  })\n}\n\nconst updateInstanceStdout = (options = {}) => {\n  const { runId, instanceId, captured } = options\n\n  const stdout = captured.toString()\n\n  return api.updateInstanceStdout({\n    runId,\n    stdout,\n    instanceId,\n  }).catch((err) => {\n    debug('failed updating instance stdout %o', {\n      stack: err.stack,\n    })\n\n    errors.warning('DASHBOARD_CANNOT_CREATE_RUN_OR_INSTANCE', err)\n\n    // dont log exceptions if we have a 503 status code\n    if (err.statusCode !== 503) {\n      return logException(err)\n    }\n  }).finally(capture.restore)\n}\n\nconst postInstanceResults = (options = {}) => {\n  const { runId, instanceId, results, group, parallel, ciBuildId, metadata } = options\n  let { stats, tests, video, screenshots, reporterStats, error } = results\n\n  video = Boolean(video)\n\n  // get rid of the path property\n  screenshots = _.map(screenshots, (screenshot) => {\n    return _.omit(screenshot, 'path')\n  })\n\n  tests = tests && _.map(tests, (test) => {\n    return _.omit({\n      clientId: test.testId,\n      ...test,\n    }, 'title', 'body', 'testId')\n  })\n\n  return api.postInstanceResults({\n    runId,\n    instanceId,\n    stats,\n    tests,\n    exception: error,\n    video,\n    reporterStats,\n    screenshots,\n    metadata,\n  })\n  .catch((err) => {\n    debug('failed updating instance %o', {\n      stack: err.stack,\n    })\n\n    throwDashboardCannotProceed({ parallel, ciBuildId, group, err })\n  })\n}\n\nconst getCommitFromGitOrCi = (git) => {\n  la(check.object(git), 'expected git information object', git)\n\n  return ciProvider.commitDefaults({\n    sha: git.sha,\n    branch: git.branch,\n    authorName: git.author,\n    authorEmail: git.email,\n    message: git.message,\n    remoteOrigin: git.remote,\n    defaultBranch: null,\n  })\n}\n\nconst usedTestsMessage = (limit, phrase) => {\n  if (_.isFinite(limit)) {\n    return `The limit is ${chalk.blue(limit)} ${phrase} results.`\n  }\n\n  return ''\n}\n\nconst billingLink = (orgId) => {\n  if (orgId) {\n    return `https://on.cypress.io/dashboard/organizations/${orgId}/billing`\n  }\n\n  return 'https://on.cypress.io/set-up-billing'\n}\n\nconst gracePeriodMessage = (gracePeriodEnds) => {\n  return gracePeriodEnds || 'the grace period ends'\n}\n\nconst createRun = Promise.method((options = {}) => {\n  _.defaults(options, {\n    group: null,\n    tags: null,\n    parallel: null,\n    ciBuildId: null,\n  })\n\n  let { projectId, recordKey, platform, git, specPattern, specs, parallel, ciBuildId, group, tags, testingType } = options\n\n  if (recordKey == null) {\n    recordKey = env.get('CYPRESS_RECORD_KEY')\n  }\n\n  if (!recordKey) {\n    // are we a forked pull request (forked PR) and are we NOT running our own internal\n    // e2e tests? currently some e2e tests fail when a user submits\n    // a PR because this logic triggers unintended here\n    if (isForkPr.isForkPr() && !runningInternalTests()) {\n      // bail with a warning\n      return errors.warning('RECORDING_FROM_FORK_PR')\n    }\n\n    // else throw\n    errors.throw('RECORD_KEY_MISSING')\n  }\n\n  // go back to being a string\n  if (specPattern) {\n    specPattern = specPattern.join(',')\n  }\n\n  if (ciBuildId) {\n    // stringify\n    ciBuildId = String(ciBuildId)\n  }\n\n  specs = _.map(specs, getSpecRelativePath)\n\n  const commit = getCommitFromGitOrCi(git)\n  const ci = {\n    params: ciProvider.ciParams(),\n    provider: ciProvider.provider(),\n  }\n\n  // write git commit and CI provider information\n  // in its own log source to expose separately\n  debugCiInfo('commit information %o', commit)\n  debugCiInfo('CI provider information %o', ci)\n\n  return api.createRun({\n    specs,\n    group,\n    tags,\n    parallel,\n    platform,\n    ciBuildId,\n    projectId,\n    recordKey,\n    specPattern,\n    testingType,\n    ci,\n    commit,\n  })\n  .tap((response) => {\n    if (!(response && response.warnings && response.warnings.length)) {\n      return\n    }\n\n    return _.each(response.warnings, (warning) => {\n      switch (warning.code) {\n        case 'FREE_PLAN_IN_GRACE_PERIOD_EXCEEDS_MONTHLY_PRIVATE_TESTS':\n          return errors.warning('FREE_PLAN_IN_GRACE_PERIOD_EXCEEDS_MONTHLY_PRIVATE_TESTS', {\n            usedTestsMessage: usedTestsMessage(warning.limit, 'private test'),\n            gracePeriodMessage: gracePeriodMessage(warning.gracePeriodEnds),\n            link: billingLink(warning.orgId),\n          })\n        case 'FREE_PLAN_IN_GRACE_PERIOD_EXCEEDS_MONTHLY_TESTS':\n          return errors.warning('FREE_PLAN_IN_GRACE_PERIOD_EXCEEDS_MONTHLY_TESTS', {\n            usedTestsMessage: usedTestsMessage(warning.limit, 'test'),\n            gracePeriodMessage: gracePeriodMessage(warning.gracePeriodEnds),\n            link: billingLink(warning.orgId),\n          })\n        case 'FREE_PLAN_IN_GRACE_PERIOD_PARALLEL_FEATURE':\n          return errors.warning('FREE_PLAN_IN_GRACE_PERIOD_PARALLEL_FEATURE', {\n            gracePeriodMessage: gracePeriodMessage(warning.gracePeriodEnds),\n            link: billingLink(warning.orgId),\n          })\n        case 'FREE_PLAN_EXCEEDS_MONTHLY_TESTS_V2':\n          return errors.warning('PLAN_EXCEEDS_MONTHLY_TESTS', {\n            planType: 'free',\n            usedTestsMessage: usedTestsMessage(warning.limit, 'test'),\n            link: billingLink(warning.orgId),\n          })\n        case 'PAID_PLAN_EXCEEDS_MONTHLY_PRIVATE_TESTS':\n          return errors.warning('PLAN_EXCEEDS_MONTHLY_TESTS', {\n            planType: 'current',\n            usedTestsMessage: usedTestsMessage(warning.limit, 'private test'),\n            link: billingLink(warning.orgId),\n          })\n        case 'PAID_PLAN_EXCEEDS_MONTHLY_TESTS':\n          return errors.warning('PLAN_EXCEEDS_MONTHLY_TESTS', {\n            planType: 'current',\n            usedTestsMessage: usedTestsMessage(warning.limit, 'test'),\n            link: billingLink(warning.orgId),\n          })\n        case 'PLAN_IN_GRACE_PERIOD_RUN_GROUPING_FEATURE_USED':\n          return errors.warning('PLAN_IN_GRACE_PERIOD_RUN_GROUPING_FEATURE_USED', {\n            gracePeriodMessage: gracePeriodMessage(warning.gracePeriodEnds),\n            link: billingLink(warning.orgId),\n          })\n        default:\n          return errors.warning('DASHBOARD_UNKNOWN_CREATE_RUN_WARNING', {\n            message: warning.message,\n            props: _.omit(warning, 'message'),\n          })\n      }\n    })\n  }).catch((err) => {\n    debug('failed creating run with status %d %o', err.statusCode, {\n      stack: err.stack,\n    })\n\n    switch (err.statusCode) {\n      case 401:\n        recordKey = keys.hide(recordKey)\n        if (!recordKey) {\n          // make sure the key is defined, otherwise the error\n          // printing logic substitutes the default value {}\n          // leading to \"[object Object]\" :)\n          recordKey = 'undefined'\n        }\n\n        return errors.throw('DASHBOARD_RECORD_KEY_NOT_VALID', recordKey, projectId)\n      case 402: {\n        const { code, payload } = err.error\n\n        const limit = _.get(payload, 'limit')\n        const orgId = _.get(payload, 'orgId')\n\n        switch (code) {\n          case 'FREE_PLAN_EXCEEDS_MONTHLY_PRIVATE_TESTS':\n            return errors.throw('FREE_PLAN_EXCEEDS_MONTHLY_PRIVATE_TESTS', {\n              usedTestsMessage: usedTestsMessage(limit, 'private test'),\n              link: billingLink(orgId),\n            })\n          case 'FREE_PLAN_EXCEEDS_MONTHLY_TESTS':\n            return errors.throw('FREE_PLAN_EXCEEDS_MONTHLY_TESTS', {\n              usedTestsMessage: usedTestsMessage(limit, 'test'),\n              link: billingLink(orgId),\n            })\n          case 'PARALLEL_FEATURE_NOT_AVAILABLE_IN_PLAN':\n            return errors.throw('PARALLEL_FEATURE_NOT_AVAILABLE_IN_PLAN', {\n              link: billingLink(orgId),\n            })\n          case 'RUN_GROUPING_FEATURE_NOT_AVAILABLE_IN_PLAN':\n            return errors.throw('RUN_GROUPING_FEATURE_NOT_AVAILABLE_IN_PLAN', {\n              link: billingLink(orgId),\n            })\n          default:\n            return errors.throw('DASHBOARD_UNKNOWN_INVALID_REQUEST', {\n              response: err,\n              flags: {\n                group,\n                tags,\n                parallel,\n                ciBuildId,\n              },\n            })\n        }\n      }\n      case 404:\n        return errors.throw('DASHBOARD_PROJECT_NOT_FOUND', projectId, settings.configFile(options))\n      case 412:\n        return errors.throw('DASHBOARD_INVALID_RUN_REQUEST', err.error)\n      case 422: {\n        const { code, payload } = err.error\n\n        const runUrl = _.get(payload, 'runUrl')\n\n        switch (code) {\n          case 'RUN_GROUP_NAME_NOT_UNIQUE':\n            return errors.throw('DASHBOARD_RUN_GROUP_NAME_NOT_UNIQUE', {\n              group,\n              runUrl,\n              ciBuildId,\n            })\n          case 'PARALLEL_GROUP_PARAMS_MISMATCH': {\n            const { browserName, browserVersion, osName, osVersion } = platform\n\n            return errors.throw('DASHBOARD_PARALLEL_GROUP_PARAMS_MISMATCH', {\n              group,\n              runUrl,\n              ciBuildId,\n              parameters: {\n                osName,\n                osVersion,\n                browserName,\n                browserVersion,\n                specs,\n              },\n            })\n          }\n          case 'PARALLEL_DISALLOWED':\n            return errors.throw('DASHBOARD_PARALLEL_DISALLOWED', {\n              tags,\n              group,\n              runUrl,\n              ciBuildId,\n            })\n          case 'PARALLEL_REQUIRED':\n            return errors.throw('DASHBOARD_PARALLEL_REQUIRED', {\n              tags,\n              group,\n              runUrl,\n              ciBuildId,\n            })\n          case 'ALREADY_COMPLETE':\n            return errors.throw('DASHBOARD_ALREADY_COMPLETE', {\n              runUrl,\n              tags,\n              group,\n              parallel,\n              ciBuildId,\n            })\n          case 'STALE_RUN':\n            return errors.throw('DASHBOARD_STALE_RUN', {\n              runUrl,\n              tags,\n              group,\n              parallel,\n              ciBuildId,\n            })\n          default:\n            return errors.throw('DASHBOARD_UNKNOWN_INVALID_REQUEST', {\n              response: err,\n              flags: {\n                tags,\n                group,\n                parallel,\n                ciBuildId,\n              },\n            })\n        }\n      }\n      default:\n        throwDashboardCannotProceed({ parallel, ciBuildId, group, err })\n    }\n  })\n})\n\nconst createInstance = (options = {}) => {\n  let { runId, group, groupId, parallel, machineId, ciBuildId, platform, spec } = options\n\n  spec = getSpecRelativePath(spec)\n\n  return api.createInstance({\n    spec,\n    runId,\n    groupId,\n    platform,\n    machineId,\n  })\n\n  .catch((err) => {\n    debug('failed creating instance %o', {\n      stack: err.stack,\n    })\n\n    throwDashboardCannotProceed({\n      err,\n      group,\n      ciBuildId,\n      parallel,\n    })\n  })\n}\n\nconst _postInstanceTests = ({\n  runId,\n  instanceId,\n  config,\n  tests,\n  hooks,\n  parallel,\n  ciBuildId,\n  group,\n}) => {\n  return api.postInstanceTests({\n    runId,\n    instanceId,\n    config,\n    tests,\n    hooks,\n  })\n  .catch((err) => {\n    throwDashboardCannotProceed({ parallel, ciBuildId, group, err })\n  })\n}\n\nconst createRunAndRecordSpecs = (options = {}) => {\n  const { specPattern,\n    specs,\n    sys,\n    browser,\n    projectId,\n    config,\n    projectRoot,\n    runAllSpecs,\n    parallel,\n    ciBuildId,\n    group,\n    project,\n    onError,\n    testingType,\n    quiet,\n  } = options\n  const recordKey = options.key\n\n  // we want to normalize this to an array to send to API\n  const tags = _.split(options.tag, ',')\n\n  return commitInfo.commitInfo(projectRoot)\n  .then((git) => {\n    debugCiInfo('found the following git information')\n    debugCiInfo(git)\n\n    const platform = {\n      osCpus: sys.osCpus,\n      osName: sys.osName,\n      osMemory: sys.osMemory,\n      osVersion: sys.osVersion,\n      browserName: browser.displayName,\n      browserVersion: browser.version,\n    }\n\n    return createRun({\n      git,\n      specs,\n      group,\n      tags,\n      parallel,\n      platform,\n      recordKey,\n      ciBuildId,\n      projectId,\n      specPattern,\n      testingType,\n    })\n    .then((resp) => {\n      if (!resp) {\n        // if a forked run, can't record and can't be parallel\n        // because the necessary env variables aren't present\n        return runAllSpecs({\n          parallel: false,\n        })\n      }\n\n      const { runUrl, runId, machineId, groupId } = resp\n\n      let captured = null\n      let instanceId = null\n\n      const beforeSpecRun = (spec) => {\n        project.setOnTestsReceived(onTestsReceived)\n        capture.restore()\n\n        captured = capture.stdout()\n\n        return createInstance({\n          spec,\n          runId,\n          group,\n          groupId,\n          platform,\n          parallel,\n          ciBuildId,\n          machineId,\n        })\n        .then((resp = {}) => {\n          instanceId = resp.instanceId\n\n          // pull off only what we need\n          return _\n          .chain(resp)\n          .pick('spec', 'claimedInstances', 'totalInstances')\n          .extend({\n            estimated: resp.estimatedWallClockDuration,\n          })\n          .value()\n        })\n      }\n\n      const afterSpecRun = (spec, results, config) => {\n        // dont do anything if we failed to\n        // create the instance\n        if (!instanceId || results.skippedSpec) {\n          return\n        }\n\n        debug('after spec run %o', { spec })\n\n        if (!quiet) {\n          // eslint-disable-next-line no-console\n          console.log('')\n\n          terminal.header('Uploading Results', {\n            color: ['blue'],\n          })\n\n          // eslint-disable-next-line no-console\n          console.log('')\n        }\n\n        return specWriter.countStudioUsage(spec.absolute)\n        .then((metadata) => {\n          return postInstanceResults({\n            group,\n            config,\n            results,\n            parallel,\n            ciBuildId,\n            instanceId,\n            metadata,\n          })\n        })\n        .then((resp) => {\n          if (!resp) {\n            return\n          }\n\n          const { video, shouldUploadVideo, screenshots } = results\n          const { videoUploadUrl, screenshotUploadUrls } = resp\n\n          return uploadArtifacts({\n            video,\n            screenshots,\n            videoUploadUrl,\n            shouldUploadVideo,\n            screenshotUploadUrls,\n            quiet,\n          })\n          .finally(() => {\n            // always attempt to upload stdout\n            // even if uploading failed\n            return updateInstanceStdout({\n              captured,\n              instanceId,\n            })\n          })\n        })\n      }\n\n      const onTestsReceived = (async (runnables, cb) => {\n        // we failed createInstance earlier, nothing to do\n        if (!instanceId) {\n          return cb()\n        }\n\n        // runnables will be null when there' no tests\n        // this also means runtimeConfig will be missing\n        runnables = runnables || {}\n\n        const r = testsUtils.flattenSuiteIntoRunnables(runnables)\n        const runtimeConfig = runnables.runtimeConfig\n        const resolvedRuntimeConfig = Config.getResolvedRuntimeConfig(config, runtimeConfig)\n\n        const tests = _.chain(r[0])\n        .uniqBy('id')\n        .map((v) => {\n          if (v.originalTitle) {\n            v._titlePath.splice(-1, 1, v.originalTitle)\n          }\n\n          return _.pick({\n            ...v,\n            clientId: v.id,\n            config: v._testConfig || null,\n            title: v._titlePath,\n            hookIds: v.hooks.map((hook) => hook.hookId),\n          },\n          'clientId', 'body', 'title', 'config', 'hookIds')\n        })\n        .value()\n\n        const hooks = _.chain(r[1])\n        .uniqBy('hookId')\n        .map((v) => {\n          return _.pick({\n            ...v,\n            clientId: v.hookId,\n            title: [v.title],\n            type: v.hookName,\n          },\n          'clientId',\n          'type',\n          'title',\n          'body')\n        })\n        .value()\n\n        const responseDidFail = {}\n        const response = await _postInstanceTests({\n          runId,\n          instanceId,\n          config: resolvedRuntimeConfig,\n          tests,\n          hooks,\n          parallel,\n          ciBuildId,\n          group,\n        })\n        .catch((err) => {\n          onError(err)\n\n          return responseDidFail\n        })\n\n        if (response === responseDidFail) {\n          // dont call the cb, let the browser hang until it's killed\n          return\n        }\n\n        if (_.some(response.actions, { type: 'SPEC', action: 'SKIP' })) {\n          errors.warning('DASHBOARD_CANCEL_SKIPPED_SPEC')\n\n          // set a property on the response so the browser runner\n          // knows not to start executing tests\n          project.emit('end', { skippedSpec: true, stats: {} })\n\n          // dont call the cb, let the browser hang until it's killed\n          return\n        }\n\n        return cb(response)\n      })\n\n      return runAllSpecs({\n        runUrl,\n        parallel,\n        onTestsReceived,\n        beforeSpecRun,\n        afterSpecRun,\n      })\n    })\n  })\n}\n\nmodule.exports = {\n  createRun,\n\n  createInstance,\n\n  postInstanceResults,\n\n  _postInstanceTests,\n\n  updateInstanceStdout,\n\n  uploadArtifacts,\n\n  throwIfNoProjectId,\n\n  throwIfIndeterminateCiBuildId,\n\n  throwIfIncorrectCiBuildIdUsage,\n\n  warnIfProjectIdButNoRecordOption,\n\n  throwIfRecordParamsWithoutRecording,\n\n  createRunAndRecordSpecs,\n\n  getCommitFromGitOrCi,\n}\n",
    "packages/server/lib/project-base.ts": "// @ts-nocheck\n\nimport Bluebird from 'bluebird'\nimport check from 'check-more-types'\nimport Debug from 'debug'\nimport EE from 'events'\nimport la from 'lazy-ass'\nimport _ from 'lodash'\nimport path from 'path'\nimport R from 'ramda'\n\nimport commitInfo from '@cypress/commit-info'\nimport pkg from '@packages/root'\nimport { RunnablesStore } from '@packages/reporter'\nimport { ServerCt } from '@packages/server-ct'\nimport api from './api'\nimport { Automation } from './automation'\nimport cache from './cache'\nimport config from './config'\nimport cwd from './cwd'\nimport errors from './errors'\nimport logger from './logger'\nimport Reporter from './reporter'\nimport runEvents from './plugins/run_events'\nimport savedState from './saved_state'\nimport scaffold from './scaffold'\nimport { ServerE2E } from './server-e2e'\nimport system from './util/system'\nimport user from './user'\nimport { ensureProp } from './util/class-helpers'\nimport { escapeFilenameInUrl } from './util/escape_filename'\nimport { fs } from './util/fs'\nimport keys from './util/keys'\nimport settings from './util/settings'\nimport specsUtil from './util/specs'\nimport Watchers from './watchers'\n\ninterface CloseOptions {\n  onClose: () => any\n}\n\ninterface OpenOptions {\n  onOpen: (cfg: any) => Bluebird<any>\n  onAfterOpen: (cfg: any) => Bluebird<any>\n}\n\nexport type Cfg = Record<string, any>\n\nconst localCwd = cwd()\nconst multipleForwardSlashesRe = /[^:\\/\\/](\\/{2,})/g\nconst backSlashesRe = /\\\\/g\n\nconst debug = Debug('cypress:server:project')\nconst debugScaffold = Debug('cypress:server:scaffold')\n\nexport class ProjectBase<TServer extends ServerE2E | ServerCt> extends EE {\n  protected projectRoot: string\n  protected watchers: Watchers\n  protected options?: Record<string, any>\n  protected spec: Cypress.Cypress['spec'] | null\n  protected _cfg?: Cfg\n  protected _server?: TServer\n  protected _automation?: Automation\n  private _recordTests = null\n\n  public browser: any\n\n  constructor (projectRoot: string) {\n    super()\n\n    if (!projectRoot) {\n      throw new Error('Instantiating lib/project requires a projectRoot!')\n    }\n\n    if (!check.unemptyString(projectRoot)) {\n      throw new Error(`Expected project root path, not ${projectRoot}`)\n    }\n\n    this.projectRoot = path.resolve(projectRoot)\n    this.watchers = new Watchers()\n    this.spec = null\n    this.browser = null\n\n    debug('Project created %o', {\n      projectType: this.projectType,\n      projectRoot: this.projectRoot,\n    })\n  }\n\n  protected ensureProp = ensureProp\n\n  get projectType () {\n    if (this.constructor === ProjectBase) {\n      return 'base'\n    }\n\n    throw new Error('Project#projectType must be defined')\n  }\n\n  setOnTestsReceived (fn) {\n    this._recordTests = fn\n  }\n\n  get server () {\n    return this.ensureProp(this._server, 'open')\n  }\n\n  get automation () {\n    return this.ensureProp(this._automation, 'open')\n  }\n\n  get cfg () {\n    return this.ensureProp(this._cfg, 'open')\n  }\n\n  open (options = {}, callbacks: OpenOptions) {\n    debug('opening project instance %s', this.projectRoot)\n    debug('project open options %o', options)\n\n    _.defaults(options, {\n      report: false,\n      onFocusTests () {},\n      onError () {},\n      onWarning () {},\n      onSettingsChanged: false,\n    })\n\n    debug('project options %o', options)\n    this.options = options\n\n    return this.getConfig(options)\n    .tap((cfg) => {\n      process.chdir(this.projectRoot)\n\n      // attach warning message if user has \"chromeWebSecurity: false\" for unsupported browser\n      if (cfg.chromeWebSecurity === false) {\n        _.chain(cfg.browsers)\n        .filter((browser) => browser.family !== 'chromium')\n        .each((browser) => browser.warning = errors.getMsgByType('CHROME_WEB_SECURITY_NOT_SUPPORTED', browser.name))\n        .value()\n      }\n\n      // TODO: we currently always scaffold the plugins file\n      // even when headlessly or else it will cause an error when\n      // we try to load it and it's not there. We must do this here\n      // else initialing the plugins will instantly fail.\n      if (cfg.pluginsFile) {\n        debug('scaffolding with plugins file %s', cfg.pluginsFile)\n\n        return scaffold.plugins(path.dirname(cfg.pluginsFile), cfg)\n      }\n    })\n    .then(callbacks.onOpen)\n    .tap(({ cfg, port, warning }) => {\n      // if we didnt have a cfg.port\n      // then get the port once we\n      // open the server\n      if (!cfg.port) {\n        cfg.port = port\n\n        // and set all the urls again\n        _.extend(cfg, config.setUrls(cfg))\n      }\n    })\n    .tap(callbacks.onAfterOpen)\n    .then(({ cfg, port, warning }) => {\n      // store the cfg from\n      // opening the server\n      this._cfg = cfg\n\n      debug('project config: %o', _.omit(cfg, 'resolved'))\n\n      if (warning) {\n        options.onWarning(warning)\n      }\n\n      options.onSavedStateChanged = (state) => this.saveState(state)\n\n      return Bluebird.join(\n        this.watchSettingsAndStartWebsockets(options, cfg),\n        this.scaffold(cfg),\n      )\n      .then(() => {\n        return Bluebird.join(\n          this.checkSupportFile(cfg),\n          this.watchPluginsFile(cfg, options),\n        )\n      })\n      .then(() => {\n        if (cfg.isTextTerminal || !cfg.experimentalInteractiveRunEvents) return\n\n        return system.info()\n        .then((sys) => {\n          const beforeRunDetails = {\n            config: cfg,\n            cypressVersion: pkg.version,\n            system: _.pick(sys, 'osName', 'osVersion'),\n          }\n\n          return runEvents.execute('before:run', cfg, beforeRunDetails)\n        })\n      })\n    })\n    .return(this)\n  }\n\n  getRuns () {\n    return Bluebird.all([\n      this.getProjectId(),\n      user.ensureAuthToken(),\n    ])\n    .spread((projectId, authToken) => {\n      return api.getProjectRuns(projectId, authToken)\n    })\n  }\n\n  reset () {\n    debug('resetting project instance %s', this.projectRoot)\n\n    this.spec = null\n    this.browser = null\n\n    return Bluebird.try(() => {\n      if (this._automation) {\n        this._automation.reset()\n      }\n\n      if (this._server) {\n        return this._server.reset()\n      }\n    })\n  }\n\n  close (options?: CloseOptions) {\n    debug('closing project instance %s', this.projectRoot)\n\n    this.spec = null\n    this.browser = null\n\n    return Bluebird.join(\n      this.server?.close(),\n      this.watchers?.close(),\n      options?.onClose(),\n    )\n    .then(() => {\n      process.chdir(localCwd)\n\n      return this.getConfig()\n    })\n    .then((config) => {\n      if (config.isTextTerminal || !config.experimentalInteractiveRunEvents) return\n\n      return runEvents.execute('after:run', config)\n    })\n  }\n\n  checkSupportFile (cfg) {\n    const supportFile = cfg.supportFile\n\n    if (supportFile) {\n      return fs.pathExists(supportFile)\n      .then((found) => {\n        if (!found) {\n          errors.throw('SUPPORT_FILE_NOT_FOUND', supportFile, settings.configFile(cfg))\n        }\n      })\n    }\n  }\n\n  watchPluginsFile (cfg, options) {\n    debug(`attempt watch plugins file: ${cfg.pluginsFile}`)\n    if (!cfg.pluginsFile || options.isTextTerminal) {\n      return Bluebird.resolve()\n    }\n\n    return fs.pathExists(cfg.pluginsFile)\n    .then((found) => {\n      debug(`plugins file found? ${found}`)\n      // ignore if not found. plugins#init will throw the right error\n      if (!found) {\n        return\n      }\n\n      debug('watch plugins file')\n\n      return this.watchers.watchTree(cfg.pluginsFile, {\n        onChange: () => {\n          // TODO: completely re-open project instead?\n          debug('plugins file changed')\n\n          // re-init plugins after a change\n          this._initPlugins(cfg, options)\n          .catch((err) => {\n            options.onError(err)\n          })\n        },\n      })\n    })\n  }\n\n  watchSettings (onSettingsChanged, options) {\n    // bail if we havent been told to\n    // watch anything (like in run mode)\n    if (!onSettingsChanged) {\n      return\n    }\n\n    debug('watch settings files')\n\n    const obj = {\n      onChange: () => {\n        // dont fire change events if we generated\n        // a project id less than 1 second ago\n        if (this.generatedProjectIdTimestamp &&\n          ((Date.now() - this.generatedProjectIdTimestamp) < 1000)) {\n          return\n        }\n\n        // call our callback function\n        // when settings change!\n        onSettingsChanged.call(this)\n      },\n    }\n\n    if (options.configFile !== false) {\n      this.watchers.watch(settings.pathToConfigFile(this.projectRoot, options), obj)\n    }\n\n    return this.watchers.watch(settings.pathToCypressEnvJson(this.projectRoot), obj)\n  }\n\n  watchSettingsAndStartWebsockets (options: Record<string, unknown> = {}, cfg: Record<string, unknown> = {}) {\n    this.watchSettings(options.onSettingsChanged, options)\n\n    const { projectRoot } = cfg\n    let { reporter } = cfg as { reporter: RunnablesStore }\n\n    // if we've passed down reporter\n    // then record these via mocha reporter\n    if (cfg.report) {\n      try {\n        Reporter.loadReporter(reporter, projectRoot)\n      } catch (err) {\n        const paths = Reporter.getSearchPathsForReporter(reporter, projectRoot)\n\n        // only include the message if this is the standard MODULE_NOT_FOUND\n        // else include the whole stack\n        const errorMsg = err.code === 'MODULE_NOT_FOUND' ? err.message : err.stack\n\n        errors.throw('INVALID_REPORTER_NAME', {\n          paths,\n          error: errorMsg,\n          name: reporter,\n        })\n      }\n\n      reporter = Reporter.create(reporter, cfg.reporterOptions, projectRoot)\n    }\n\n    this._automation = new Automation(cfg.namespace, cfg.socketIoCookie, cfg.screenshotsFolder)\n\n    this.server.startWebsockets(this.automation, cfg, {\n      onReloadBrowser: options.onReloadBrowser,\n\n      onFocusTests: options.onFocusTests,\n\n      onSpecChanged: options.onSpecChanged,\n\n      onSavedStateChanged: options.onSavedStateChanged,\n\n      onCaptureVideoFrames: (data) => {\n        // TODO: move this to browser automation middleware\n        this.emit('capture:video:frames', data)\n      },\n\n      onConnect: (id) => {\n        debug('socket:connected')\n        this.emit('socket:connected', id)\n      },\n\n      onTestsReceivedAndMaybeRecord: async (runnables, cb) => {\n        debug('received runnables %o', runnables)\n\n        if (reporter != null) {\n          reporter.setRunnables(runnables)\n        }\n\n        if (this._recordTests) {\n          await this._recordTests(runnables, cb)\n\n          this._recordTests = null\n\n          return\n        }\n\n        cb()\n      },\n\n      onMocha: (event, runnable) => {\n        debug('onMocha', event)\n        // bail if we dont have a\n        // reporter instance\n        if (!reporter) {\n          return\n        }\n\n        reporter.emit(event, runnable)\n\n        if (event === 'end') {\n          return Bluebird.all([\n            (reporter != null ? reporter.end() : undefined),\n            this.server.end(),\n          ])\n          .spread((stats = {}) => {\n            this.emit('end', stats)\n          })\n        }\n      },\n    })\n  }\n\n  changeToUrl (url) {\n    this.server.changeToUrl(url)\n  }\n\n  setCurrentSpecAndBrowser (spec, browser: Cypress.Browser) {\n    this.spec = spec\n    this.browser = browser\n  }\n\n  getCurrentSpecAndBrowser () {\n    return {\n      spec: this.spec,\n      browser: this.browser,\n    }\n  }\n\n  setBrowsers (browsers = []) {\n    debug('getting config before setting browsers %o', browsers)\n\n    return this.getConfig()\n    .then((cfg) => {\n      debug('setting config browsers to %o', browsers)\n\n      cfg.browsers = browsers\n    })\n  }\n\n  getAutomation () {\n    return this.automation\n  }\n\n  // do not check files again and again - keep previous promise\n  // to refresh it - just close and open the project again.\n  determineIsNewProject (folder) {\n    return scaffold.isNewProject(folder)\n  }\n\n  // returns project config (user settings + defaults + cypress.json)\n  // with additional object \"state\" which are transient things like\n  // window width and height, DevTools open or not, etc.\n  getConfig (options = {}): Bluebird<Cfg> {\n    if (options == null) {\n      options = this.options\n    }\n\n    if (this._cfg) {\n      debug('project has config %o', this._cfg)\n\n      return Bluebird.resolve(this._cfg)\n    }\n\n    const setNewProject = (cfg) => {\n      if (cfg.isTextTerminal) {\n        return\n      }\n\n      // decide if new project by asking scaffold\n      // and looking at previously saved user state\n      if (!cfg.integrationFolder) {\n        throw new Error('Missing integration folder')\n      }\n\n      return this.determineIsNewProject(cfg.integrationFolder)\n      .then((untouchedScaffold) => {\n        const userHasSeenOnBoarding = _.get(cfg, 'state.showedOnBoardingModal', false)\n\n        debugScaffold(`untouched scaffold ${untouchedScaffold} modal closed ${userHasSeenOnBoarding}`)\n        cfg.isNewProject = untouchedScaffold && !userHasSeenOnBoarding\n      })\n    }\n\n    return config.get(this.projectRoot, options)\n    .then((cfg) => {\n      return this._setSavedState(cfg)\n    })\n    .tap(setNewProject)\n  }\n\n  // forces saving of project's state by first merging with argument\n  saveState (stateChanges = {}) {\n    if (!this.cfg) {\n      throw new Error('Missing project config')\n    }\n\n    if (!this.projectRoot) {\n      throw new Error('Missing project root')\n    }\n\n    const newState = _.merge({}, this.cfg.state, stateChanges)\n\n    return savedState.create(this.projectRoot, this.cfg.isTextTerminal)\n    .then((state) => state.set(newState))\n    .then(() => {\n      this.cfg.state = newState\n\n      return newState\n    })\n  }\n\n  _setSavedState (cfg) {\n    debug('get saved state')\n\n    return savedState.create(this.projectRoot, cfg.isTextTerminal)\n    .then((state) => state.get())\n    .then((state) => {\n      cfg.state = state\n\n      return cfg\n    })\n  }\n\n  getSpecUrl (absoluteSpecPath, specType) {\n    debug('get spec url: %s for spec type %s', absoluteSpecPath, specType)\n\n    return this.getConfig()\n    .then((cfg) => {\n      // if we don't have a absoluteSpecPath or its __all\n      if (!absoluteSpecPath || (absoluteSpecPath === '__all')) {\n        const url = this.normalizeSpecUrl(cfg.browserUrl, '/__all')\n\n        debug('returning url to run all specs: %s', url)\n\n        return url\n      }\n\n      // TODO:\n      // to handle both unit + integration tests we need\n      // to figure out (based on the config) where this absoluteSpecPath\n      // lives. does it live in the integrationFolder or\n      // the unit folder?\n      // once we determine that we can then prefix it correctly\n      // with either integration or unit\n      const prefixedPath = this.getPrefixedPathToSpec(cfg, absoluteSpecPath, specType)\n      const url = this.normalizeSpecUrl(cfg.browserUrl, prefixedPath)\n\n      debug('return path to spec %o', { specType, absoluteSpecPath, prefixedPath, url })\n\n      return url\n    })\n  }\n\n  getPrefixedPathToSpec (cfg, pathToSpec, type = 'integration') {\n    const { integrationFolder, componentFolder, projectRoot } = cfg\n\n    // for now hard code the 'type' as integration\n    // but in the future accept something different here\n\n    // strip out the integration folder and prepend with \"/\"\n    // example:\n    //\n    // /Users/bmann/Dev/cypress-app/.projects/cypress/integration\n    // /Users/bmann/Dev/cypress-app/.projects/cypress/integration/foo.js\n    //\n    // becomes /integration/foo.js\n\n    const folderToUse = type === 'integration' ? integrationFolder : componentFolder\n\n    // To avoid having invalid urls from containing backslashes,\n    // we normalize specUrls to posix by replacing backslash by slash\n    // Indeed, path.realtive will return something different on windows\n    // than on posix systems which can lead to problems\n    const url = `/${path.join(type, path.relative(\n      folderToUse,\n      path.resolve(projectRoot, pathToSpec),\n    )).replace(backSlashesRe, '/')}`\n\n    debug('prefixed path for spec %o', { pathToSpec, type, url })\n\n    return url\n  }\n\n  normalizeSpecUrl (browserUrl, specUrl) {\n    const replacer = (match) => match.replace('//', '/')\n\n    return [\n      browserUrl,\n      '#/tests',\n      escapeFilenameInUrl(specUrl),\n    ].join('/')\n    .replace(multipleForwardSlashesRe, replacer)\n  }\n\n  scaffold (cfg: Cfg) {\n    debug('scaffolding project %s', this.projectRoot)\n\n    const scaffolds = []\n\n    const push = scaffolds.push.bind(scaffolds)\n\n    // TODO: we are currently always scaffolding support\n    // even when headlessly - this is due to a major breaking\n    // change of 0.18.0\n    // we can later force this not to always happen when most\n    // of our users go beyond 0.18.0\n    //\n    // ensure support dir is created\n    // and example support file if dir doesnt exist\n    push(scaffold.support(cfg.supportFolder, cfg))\n\n    // if we're in headed mode add these other scaffolding tasks\n    debug('scaffold flags %o', {\n      isTextTerminal: cfg.isTextTerminal,\n      CYPRESS_INTERNAL_FORCE_SCAFFOLD: process.env.CYPRESS_INTERNAL_FORCE_SCAFFOLD,\n    })\n\n    const scaffoldExamples = !cfg.isTextTerminal || process.env.CYPRESS_INTERNAL_FORCE_SCAFFOLD\n\n    if (scaffoldExamples) {\n      debug('will scaffold integration and fixtures folder')\n      push(scaffold.integration(cfg.integrationFolder, cfg))\n      push(scaffold.fixture(cfg.fixturesFolder, cfg))\n    } else {\n      debug('will not scaffold integration or fixtures folder')\n    }\n\n    return Bluebird.all(scaffolds)\n  }\n\n  writeProjectId (id) {\n    const attrs = { projectId: id }\n\n    logger.info('Writing Project ID', _.clone(attrs))\n\n    this.generatedProjectIdTimestamp = new Date()\n\n    return settings\n    .write(this.projectRoot, attrs)\n    .return(id)\n  }\n\n  getProjectId () {\n    return this.verifyExistence()\n    .then(() => {\n      return settings.read(this.projectRoot, this.options)\n    })\n    .then((readSettings) => {\n      if (readSettings && readSettings.projectId) {\n        return readSettings.projectId\n      }\n\n      errors.throw('NO_PROJECT_ID', settings.configFile(this.options), this.projectRoot)\n    })\n  }\n\n  verifyExistence () {\n    return fs\n    .statAsync(this.projectRoot)\n    .return(this)\n    .catch(() => {\n      errors.throw('NO_PROJECT_FOUND_AT_PROJECT_ROOT', this.projectRoot)\n    })\n  }\n\n  createCiProject (projectDetails) {\n    debug('create CI project with projectDetails %o', projectDetails)\n\n    return user.ensureAuthToken()\n    .then((authToken) => {\n      const remoteOrigin = commitInfo.getRemoteOrigin(this.projectRoot)\n\n      debug('found remote origin at projectRoot %o', {\n        remoteOrigin,\n        projectRoot: this.projectRoot,\n      })\n\n      return remoteOrigin\n      .then((remoteOrigin) => {\n        return api.createProject(projectDetails, remoteOrigin, authToken)\n      })\n    }).then((newProject) => {\n      return this.writeProjectId(newProject.id)\n      .return(newProject)\n    })\n  }\n\n  getRecordKeys () {\n    return Bluebird.all([\n      this.getProjectId(),\n      user.ensureAuthToken(),\n    ])\n    .spread((projectId, authToken) => {\n      return api.getProjectRecordKeys(projectId, authToken)\n    })\n  }\n\n  requestAccess (projectId) {\n    return user.ensureAuthToken()\n    .then((authToken) => {\n      return api.requestAccess(projectId, authToken)\n    })\n  }\n\n  static getOrgs () {\n    return user.ensureAuthToken()\n    .then((authToken) => {\n      return api.getOrgs(authToken)\n    })\n  }\n\n  static paths () {\n    return cache.getProjectRoots()\n  }\n\n  static getPathsAndIds () {\n    return cache.getProjectRoots()\n    // this assumes that the configFile for a cached project is 'cypress.json'\n    // https://git.io/JeGyF\n    .map((projectRoot) => {\n      return Bluebird.props({\n        path: projectRoot,\n        id: settings.id(projectRoot),\n      })\n    })\n  }\n\n  static getDashboardProjects () {\n    return user.ensureAuthToken()\n    .then((authToken) => {\n      debug('got auth token: %o', { authToken: keys.hide(authToken) })\n\n      return api.getProjects(authToken)\n    })\n  }\n\n  static _mergeDetails (clientProject, project) {\n    return _.extend({}, clientProject, project, { state: 'VALID' })\n  }\n\n  static _mergeState (clientProject, state) {\n    return _.extend({}, clientProject, { state })\n  }\n\n  static _getProject (clientProject, authToken) {\n    debug('get project from api', clientProject.id, clientProject.path)\n\n    return api.getProject(clientProject.id, authToken)\n    .then((project) => {\n      debug('got project from api')\n\n      return ProjectBase._mergeDetails(clientProject, project)\n    }).catch((err) => {\n      debug('failed to get project from api', err.statusCode)\n      switch (err.statusCode) {\n        case 404:\n          // project doesn't exist\n          return ProjectBase._mergeState(clientProject, 'INVALID')\n        case 403:\n          // project exists, but user isn't authorized for it\n          return ProjectBase._mergeState(clientProject, 'UNAUTHORIZED')\n        default:\n          throw err\n      }\n    })\n  }\n\n  static getProjectStatuses (clientProjects = []) {\n    debug(`get project statuses for ${clientProjects.length} projects`)\n\n    return user.ensureAuthToken()\n    .then((authToken) => {\n      debug('got auth token: %o', { authToken: keys.hide(authToken) })\n\n      return api.getProjects(authToken).then((projects = []) => {\n        debug(`got ${projects.length} projects`)\n        const projectsIndex = _.keyBy(projects, 'id')\n\n        return Bluebird.all(_.map(clientProjects, (clientProject) => {\n          debug('looking at', clientProject.path)\n          // not a CI project, just mark as valid and return\n          if (!clientProject.id) {\n            debug('no project id')\n\n            return ProjectBase._mergeState(clientProject, 'VALID')\n          }\n\n          const project = projectsIndex[clientProject.id]\n\n          if (project) {\n            debug('found matching:', project)\n\n            // merge in details for matching project\n            return ProjectBase._mergeDetails(clientProject, project)\n          }\n\n          debug('did not find matching:', project)\n\n          // project has id, but no matching project found\n          // check if it doesn't exist or if user isn't authorized\n          return ProjectBase._getProject(clientProject, authToken)\n        }))\n      })\n    })\n  }\n\n  static getProjectStatus (clientProject) {\n    debug('get project status for client id %s at path %s', clientProject.id, clientProject.path)\n\n    if (!clientProject.id) {\n      debug('no project id')\n\n      return Bluebird.resolve(ProjectBase._mergeState(clientProject, 'VALID'))\n    }\n\n    return user.ensureAuthToken().then((authToken) => {\n      debug('got auth token: %o', { authToken: keys.hide(authToken) })\n\n      return ProjectBase._getProject(clientProject, authToken)\n    })\n  }\n\n  static remove (path) {\n    return cache.removeProject(path)\n  }\n\n  static add (path, options) {\n    // don't cache a project if a non-default configFile is set\n    // https://git.io/JeGyF\n    if (settings.configFile(options) !== 'cypress.json') {\n      return Bluebird.resolve({ path })\n    }\n\n    return cache.insertProject(path)\n    .then(() => {\n      return this.id(path)\n    }).then((id) => {\n      return { id, path }\n    })\n    .catch(() => {\n      return { path }\n    })\n  }\n\n  static id (path) {\n    return new ProjectBase(path).getProjectId()\n  }\n\n  static ensureExists (path, options) {\n    // is there a configFile? is the root writable?\n    return settings.exists(path, options)\n  }\n\n  static config (path) {\n    return new ProjectBase(path).getConfig()\n  }\n\n  static getSecretKeyByPath (path) {\n    // get project id\n    return ProjectBase.id(path)\n    .then((id) => {\n      return user.ensureAuthToken()\n      .then((authToken) => {\n        return api.getProjectToken(id, authToken)\n        .catch(() => {\n          errors.throw('CANNOT_FETCH_PROJECT_TOKEN')\n        })\n      })\n    })\n  }\n\n  static generateSecretKeyByPath (path) {\n    // get project id\n    return ProjectBase.id(path)\n    .then((id) => {\n      return user.ensureAuthToken()\n      .then((authToken) => {\n        return api.updateProjectToken(id, authToken)\n        .catch(() => {\n          errors.throw('CANNOT_CREATE_PROJECT_TOKEN')\n        })\n      })\n    })\n  }\n\n  // Given a path to the project, finds all specs\n  // returns list of specs with respect to the project root\n  static findSpecs (projectRoot, specPattern) {\n    debug('finding specs for project %s', projectRoot)\n    la(check.unemptyString(projectRoot), 'missing project path', projectRoot)\n    la(check.maybe.unemptyString(specPattern), 'invalid spec pattern', specPattern)\n\n    // if we have a spec pattern\n    if (specPattern) {\n      // then normalize to create an absolute\n      // file path from projectRoot\n      // ie: **/* turns into /Users/bmann/dev/project/**/*\n      specPattern = path.resolve(projectRoot, specPattern)\n      debug('full spec pattern \"%s\"', specPattern)\n    }\n\n    return new ProjectBase(projectRoot)\n    .getConfig()\n    // TODO: handle wild card pattern or spec filename\n    .then((cfg) => {\n      return specsUtil.find(cfg, specPattern)\n    }).then(R.prop('integration'))\n    .then(R.map(R.prop('name')))\n  }\n}\n",
    "packages/server/lib/updater.js": "const os = require('os')\nconst debug = require('debug')('cypress:server:updater')\nconst semver = require('semver')\nconst rp = require('@cypress/request-promise')\nconst pkg = require('@packages/root')\nconst { agent } = require('@packages/network')\nconst konfig = require('./konfig')\nconst { machineId } = require('./util/machine_id')\n\nconst _getManifest = ({ id, initialLaunch, testingType }) => {\n  const url = konfig('desktop_manifest_url')\n\n  return rp.get({\n    url,\n    headers: {\n      'x-cypress-version': pkg.version,\n      'x-os-name': os.platform(),\n      'x-arch': os.arch(),\n      'x-machine-id': id,\n      'x-initial-launch': String(initialLaunch),\n      'x-testing-type': testingType,\n    },\n    agent,\n    proxy: null,\n    json: true,\n  })\n}\n\nconst check = async ({ testingType, initialLaunch, onNewVersion, onNoNewVersion } = {}) => {\n  try {\n    const id = await machineId()\n    const manifest = await _getManifest({\n      id,\n      testingType,\n      initialLaunch,\n    })\n\n    if (!manifest || !manifest.version) {\n      throw new Error('manifest is empty or does not have a version')\n    }\n\n    debug('latest version of Cypress is:', manifest.version)\n\n    const localVersion = pkg.version\n    const newVersionAvailable = semver.gt(manifest.version, localVersion)\n\n    if (newVersionAvailable) {\n      debug('new version of Cypress exists:', manifest.version)\n      onNewVersion(manifest)\n    } else {\n      debug('new version of Cypress does not exist')\n      onNoNewVersion()\n    }\n  } catch (err) {\n    debug('error getting latest version of Cypress', err)\n    onNoNewVersion()\n  }\n}\n\nmodule.exports = {\n  check,\n  _getManifest,\n}\n",
    "packages/server/test/e2e/0_max_listeners_spec.ts": "import _ from 'lodash'\nimport path from 'path'\nimport fs from 'fs-extra'\n\nimport e2e from '../support/helpers/e2e'\nimport Fixtures from '../support/helpers/fixtures'\n\nconst projectPath = Fixtures.projectPath('max-listeners')\n\ndescribe('max listeners warning spec', () => {\n  e2e.setup()\n\n  // @see https://github.com/cypress-io/cypress/issues/1305\n  e2e.it('does not log MaxEventListeners error', {\n    browser: 'electron',\n    project: projectPath,\n    spec: '*',\n    processEnv: {\n      CYPRESS_INTERNAL_ENV: 'production',\n    },\n    onRun: async (exec) => {\n      const integrationPath = path.join(projectPath, 'cypress/integration')\n\n      // create a bunch of dummy test files to reproduce #1305\n      await fs.mkdirp(integrationPath)\n      await Promise.all(\n        _.times(15, (i) => fs.writeFile(path.join(integrationPath, `${i}.spec.js`), `it('test', () => {})`)),\n      )\n\n      const { stderr } = await exec()\n\n      expect(stderr).to.not.include('setMaxListeners')\n      expect(stderr).to.not.include('preprocessor:close')\n    },\n  })\n})\n",
    "packages/server/test/e2e/1_firefox_spec.ts": "import path from 'path'\nimport util from 'util'\nimport fs from 'fs-extra'\n\nimport e2e, { expect } from '../support/helpers/e2e'\nimport Bluebird from 'bluebird'\nimport Fixtures from '../support/helpers/fixtures'\n\nconst e2ePath = Fixtures.projectPath('e2e')\nconst outputPath = path.join(e2ePath, 'output.json')\n\ndescribe('e2e firefox', function () {\n  e2e.setup()\n\n  // NOTE: This can be used to demonstrate the Firefox out-of-memory issue, but it is skipped\n  // because it takes forever and is redundant since we test `services` against Cypress prereleases.\n  // @see https://github.com/cypress-io/cypress/issues/6187\n  e2e.it.skip('can run a lot of tests', {\n    outputPath,\n    project: Fixtures.projectPath('firefox-memory'),\n    spec: 'spec.js',\n    browser: 'firefox',\n    expectedExitCode: 0,\n    timeout: 1e9,\n    config: {\n      video: false,\n    },\n    exit: false,\n    onRun: (exec) => {\n      return exec()\n      .then(() => {\n        return Bluebird.resolve(fs.readJson(outputPath))\n        .get('runs')\n        .get(0)\n        .get('tests')\n        .map((test: any, i) => {\n          return {\n            num: i + 1,\n            ...test.timings,\n          }\n        })\n        .then((tests) => {\n          // eslint-disable-next-line\n          console.log(util.inspect(tests, {\n            depth: Infinity,\n            breakLength: Infinity,\n            maxArrayLength: Infinity,\n          }))\n        })\n      })\n    },\n    // snapshot: true,\n  })\n\n  e2e.it('launches maximized by default', {\n    browser: 'firefox',\n    project: Fixtures.projectPath('screen-size'),\n    spec: 'maximized.spec.js',\n    onRun: async (exec) => {\n      const { stderr } = await exec({\n        processEnv: {\n          // trigger foxdriver's built-in debug logs\n          DEBUG: process.env.DEBUG || 'foo',\n        },\n      })\n\n      // @see https://github.com/cypress-io/cypress/issues/7723\n      expect(stderr).not.to.include('foxdriver')\n    },\n  })\n\n  // NOTE: only an issue on windows\n  // https://github.com/cypress-io/cypress/issues/6392\n  e2e.it.skip('can run multiple specs', {\n    browser: 'firefox',\n    project: Fixtures.projectPath('e2e'),\n    spec: 'simple_spec.js,simple_passing_spec.js',\n  })\n})\n",
    "packages/server/test/e2e/3_testConfigOverrides_spec.ts": "import fs from 'fs-extra'\nimport path from 'path'\nimport e2e, { expect } from '../support/helpers/e2e'\nimport Fixtures from '../support/helpers/fixtures'\n\nconst e2ePath = Fixtures.projectPath('e2e')\n\nconst outputPath = path.join(e2ePath, 'output.json')\n\ndescribe('testConfigOverrides', () => {\n  e2e.setup()\n\n  e2e.it('fails when passing invalid config value browser', {\n    spec: 'testConfigOverrides-invalid-browser.js',\n    snapshot: true,\n    expectedExitCode: 1,\n\n  })\n\n  e2e.it('has originalTitle when skip due to browser config', {\n    spec: 'testConfigOverrides-skip-browser.js',\n    snapshot: true,\n    outputPath,\n    browser: 'electron',\n    async onRun (exec) {\n      await exec()\n      const results = await fs.readJson(outputPath)\n\n      // make sure we've respected test.originalTitle\n      expect(results.runs[0].tests[0].title).deep.eq(['suite', 'has invalid testConfigOverrides'])\n    },\n  })\n})\n",
    "packages/server/test/e2e/4_downloads_spec.ts": "import path from 'path'\n\nimport e2e, { expect } from '../support/helpers/e2e'\nimport Fixtures from '../support/helpers/fixtures'\nimport { fs } from '../../lib/util/fs'\n\nconst downloadsProject = Fixtures.projectPath('downloads')\n\ndescribe('e2e downloads', () => {\n  e2e.setup()\n\n  e2e.it('handles various file downloads', {\n    project: downloadsProject,\n    spec: 'downloads_spec.ts',\n    config: {\n      video: false,\n    },\n  })\n\n  const fileExists = (fileName) => {\n    return fs.pathExists(path.join(Fixtures.projectPath('downloads'), 'cypress', 'dls', fileName))\n  }\n\n  e2e.it('allows changing the downloads folder', {\n    project: Fixtures.projectPath('downloads'),\n    spec: '*',\n    config: {\n      downloadsFolder: 'cypress/dls',\n      video: false,\n    },\n    onRun: async (exec) => {\n      await exec()\n\n      expect(await fileExists('records.csv'), 'records.csv should exist').to.be.true\n      expect(await fileExists('files.zip'), 'files.zip should exist').to.be.true\n      expect(await fileExists('people.xlsx'), 'people.xlsx should exist').to.be.true\n    },\n  })\n\n  it('trashes downloads between runs', async function () {\n    await e2e.exec(this, {\n      project: downloadsProject,\n      spec: 'download_csv_spec.ts',\n    })\n\n    // this run should trash the downloads from the above run\n    await e2e.exec(this, {\n      project: downloadsProject,\n      spec: 'simple_passing_spec.ts',\n    })\n\n    const filePath = path.join(downloadsProject, 'cypress', 'downloads', 'records.csv')\n    const exists = await fs.pathExists(filePath)\n\n    expect(exists, `Expected ${filePath} not to exist, but it does`).to.be.false\n  })\n\n  it('does not trash downloads between runs if trashAssetsBeforeRuns: false', async function () {\n    await e2e.exec(this, {\n      project: downloadsProject,\n      spec: 'download_csv_spec.ts',\n    })\n\n    // this run should _not_ trash the downloads from the above run\n    await e2e.exec(this, {\n      project: downloadsProject,\n      spec: 'simple_passing_spec.ts',\n      config: {\n        trashAssetsBeforeRuns: false,\n      },\n    })\n\n    const filePath = path.join(downloadsProject, 'cypress', 'downloads', 'records.csv')\n    const exists = await fs.pathExists(filePath)\n\n    expect(exists, `Expected ${filePath} to exist, but it does not`).to.be.true\n  })\n})\n",
    "packages/server/test/e2e/4_form_submissions_spec.js": "const rp = require('@cypress/request-promise')\nconst path = require('path')\nconst bodyParser = require('body-parser')\nconst multer = require('multer')\nconst { fs } = require('../../lib/util/fs')\nconst e2e = require('../support/helpers/e2e').default\nconst Fixtures = require('../support/helpers/fixtures')\n\nconst HTTPS_PORT = 11443\nconst HTTP_PORT = 11180\n\ndescribe('e2e form submissions', () => {\n  return e2e.setup()\n})\n\nconst e2ePath = Fixtures.projectPath('e2e')\nconst pathToLargeImage = Fixtures.path('server/imgs/earth.jpg')\n\nconst getFormHtml = (formAttrs, textValue = '') => {\n  return `\\\n<html>\n<body>\n  <form method=\"POST\" ${formAttrs}>\n    <input name=\"foo\" type=\"text\" value=\"${textValue}\"/>\n    <input name=\"bar\" type=\"file\"/>\n    <input type=\"submit\"/>\n  </form>\n</body>\n</html>\\\n`\n}\n\nconst onServer = function (app) {\n  app.post('/verify-attachment', multer().any(), async (req, res) => {\n    const file = req.files[0]\n\n    const fixturePath = path.resolve(e2ePath, 'cypress', 'fixtures', req.body.foo)\n\n    const fixtureBuf = await fs.readFileAsync(fixturePath)\n    const uploadBuf = file.buffer\n\n    const ret = fixtureBuf.compare(uploadBuf)\n\n    if (ret === 0) {\n      return res.send('files match')\n    }\n\n    return res.send(\n      `\\\nfile did not match. file at ${fixturePath} did not match uploaded buf.\n<br/>\n<hr/>\nbuffer compare yielded: ${ret}\\\n`,\n    )\n  })\n\n  // all routes below this point will have bodies parsed\n  app.use(bodyParser.text({\n    type: '*/*', // parse any content-type\n  }))\n\n  app.get('/', (req, res) => {\n    return res\n    .type('html')\n    .send(getFormHtml('action=\"/dump-body\"'))\n  })\n\n  app.get('/multipart-form-data', (req, res) => {\n    return res\n    .type('html')\n    .send(getFormHtml('action=\"/dump-body\" enctype=\"multipart/form-data\"'))\n  })\n\n  app.get('/multipart-with-attachment', (req, res) => {\n    return res\n    .type('html')\n    .send(getFormHtml('action=\"/verify-attachment\" enctype=\"multipart/form-data\"', req.query.fixturePath))\n  })\n\n  return app.post('/dump-body', (req, res) => {\n    return res\n    .type('html')\n    .send(req.body)\n  })\n}\n\ndescribe('e2e forms', () => {\n  context('submissions with jquery XHR POST', () => {\n    e2e.setup()\n\n    e2e.it('passing', {\n      spec: 'form_submission_passing_spec.js',\n      snapshot: true,\n    })\n\n    e2e.it('failing', {\n      spec: 'form_submission_failing_spec.js',\n      snapshot: true,\n      expectedExitCode: 1,\n      onStdout: (stdout) => {\n        return stdout\n        .replace(/((?: {6}-)+[^\\n]+\\n)/gm, '')\n      }, // remove variable diff\n    })\n  })\n\n  context('<form> submissions', () => {\n    e2e.setup({\n      settings: {\n        env: {\n          PATH_TO_LARGE_IMAGE: pathToLargeImage,\n        },\n      },\n      servers: [\n        {\n          port: HTTPS_PORT,\n          https: true,\n          onServer,\n        },\n        {\n          port: HTTP_PORT,\n          onServer,\n        },\n      ],\n    })\n\n    before(() => {\n      // go out and fetch this image if we don't already have it\n      return fs\n      .readFileAsync(pathToLargeImage)\n      .catch({ code: 'ENOENT' }, () => {\n        // 16MB image, too big to include with git repo\n        return rp('https://test-page-speed.cypress.io/files/huge-image.jpg')\n        .then((resp) => {\n          return fs.outputFileAsync(pathToLargeImage, resp)\n        })\n      })\n    })\n\n    e2e.it('passes with https on localhost', {\n      config: {\n        baseUrl: `https://localhost:${HTTPS_PORT}`,\n      },\n      spec: 'form_submission_multipart_spec.js',\n      snapshot: true,\n    })\n\n    e2e.it('passes with http on localhost', {\n      config: {\n        baseUrl: `http://localhost:${HTTP_PORT}`,\n      },\n      spec: 'form_submission_multipart_spec.js',\n      snapshot: true,\n    })\n  })\n})\n",
    "packages/server/test/e2e/5_spec_isolation_spec.js": "// TODO: rename this file to 5_module_api_spec\n\nconst path = require('path')\nconst _ = require('lodash')\nconst snapshot = require('snap-shot-it')\nconst { fs } = require('../../lib/util/fs')\nconst { default: e2e, STDOUT_DURATION_IN_TABLES_RE } = require('../support/helpers/e2e')\nconst Fixtures = require('../support/helpers/fixtures')\nconst { expectCorrectModuleApiResult } = require('../support/helpers/resultsUtils')\nconst e2ePath = Fixtures.projectPath('e2e')\nconst { it } = e2e\n\nconst outputPath = path.join(e2ePath, 'output.json')\n\nconst specs = [\n  'simple_passing_spec.js',\n  'simple_hooks_spec.js',\n  'simple_failing_spec.js',\n  'simple_failing_h*_spec.js', // simple failing hook spec\n].join(',')\n\ndescribe('e2e spec_isolation', () => {\n  e2e.setup()\n\n  it('fails', {\n    spec: specs,\n    outputPath,\n    snapshot: false,\n    expectedExitCode: 5,\n    config: {\n      video: false,\n    },\n    async onRun (execFn) {\n      const { stdout } = await execFn()\n\n      _.each(STDOUT_DURATION_IN_TABLES_RE.exec(stdout), (str) => {\n        expect(str.trim(), 'spec durations in tables should not be 0ms').not.eq('0ms')\n      })\n\n      // now what we want to do is read in the outputPath\n      // and snapshot it so its what we expect after normalizing it\n      let json = await fs.readJsonAsync(outputPath)\n\n      json.runs = e2e.normalizeRuns(json.runs)\n\n      // also mutates into normalized obj ready for snapshot\n      expectCorrectModuleApiResult(json, {\n        e2ePath, runs: 4, video: false,\n      })\n\n      snapshot(json, { allowSharedSnapshot: true })\n    },\n  })\n\n  it('failing with retries enabled', {\n    spec: 'simple_failing_hook_spec.js,simple_retrying_spec.js',\n    outputPath,\n    snapshot: true,\n    expectedExitCode: 4,\n    config: {\n      retries: 1,\n      video: false,\n    },\n    async onRun (execFn) {\n      await execFn()\n      let json = await fs.readJsonAsync(outputPath)\n\n      json.runs = e2e.normalizeRuns(json.runs)\n\n      // also mutates into normalized obj ready for snapshot\n      expectCorrectModuleApiResult(json, {\n        e2ePath, runs: 2, video: false,\n      })\n\n      snapshot(json)\n    },\n  })\n})\n",
    "packages/server/test/e2e/7_record_spec.js": "const _ = require('lodash')\nconst path = require('path')\nconst Promise = require('bluebird')\nconst jsonSchemas = require('@cypress/json-schemas').api\nconst snapshot = require('snap-shot-it')\nconst e2e = require('../support/helpers/e2e').default\nconst { fs } = require('../../lib/util/fs')\nconst Fixtures = require('../support/helpers/fixtures')\nconst {\n  createRoutes,\n  setupStubbedServer,\n  getRequestUrls, getRequests,\n  postRunResponse,\n  postRunResponseWithWarnings,\n  postRunInstanceResponse,\n  postInstanceTestsResponse,\n} = require('../support/helpers/serverStub')\nconst { expectRunsToHaveCorrectTimings } = require('../support/helpers/resultsUtils')\n\nconst e2ePath = Fixtures.projectPath('e2e')\nconst outputPath = path.join(e2ePath, 'output.json')\n\nlet { runId, groupId, machineId, runUrl, tags } = postRunResponse\nconst { instanceId } = postRunInstanceResponse\n\nlet requests = null\n\ndescribe('e2e record', () => {\n  beforeEach(() => {\n    requests = getRequests()\n  })\n\n  context('passing', () => {\n    setupStubbedServer(createRoutes())\n\n    it('passes', async function () {\n      const { stdout } = await e2e.exec(this, {\n        key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n        spec: 'record*',\n        record: true,\n        snapshot: true,\n        outputPath,\n        expectedExitCode: 3,\n      })\n\n      console.log(stdout)\n      expect(stdout).to.include('Run URL:')\n      expect(stdout).to.include(runUrl)\n\n      const urls = getRequestUrls()\n\n      const instanceReqs = urls.slice(0, 22)\n\n      expect(instanceReqs).to.deep.eq([\n        // first create run request\n        'POST /runs',\n\n        // spec 1\n        `POST /runs/${runId}/instances`,\n        // no instances/:id/tests becuase spec failed during eval\n        `POST /instances/${instanceId}/results`,\n        'PUT /videos/video.mp4',\n        `PUT /instances/${instanceId}/stdout`,\n\n        // spec 2\n        `POST /runs/${runId}/instances`,\n        `POST /instances/${instanceId}/tests`,\n        `POST /instances/${instanceId}/results`,\n        'PUT /videos/video.mp4',\n        'PUT /screenshots/1.png',\n        `PUT /instances/${instanceId}/stdout`,\n\n        // spec 3\n        `POST /runs/${runId}/instances`,\n        `POST /instances/${instanceId}/tests`,\n        `POST /instances/${instanceId}/results`,\n        // no video because no tests failed\n        'PUT /screenshots/1.png',\n        `PUT /instances/${instanceId}/stdout`,\n\n        // spec 4\n        `POST /runs/${runId}/instances`,\n        `POST /instances/${instanceId}/tests`,\n        `POST /instances/${instanceId}/results`,\n        'PUT /videos/video.mp4',\n        'PUT /screenshots/1.png',\n        `PUT /instances/${instanceId}/stdout`,\n      ])\n\n      const postRun = requests[0]\n\n      // ensure its relative to projectRoot\n      expect(postRun.body.specs).to.deep.eq([\n        'cypress/integration/record_error_spec.js',\n        'cypress/integration/record_fail_spec.js',\n        'cypress/integration/record_pass_spec.js',\n        'cypress/integration/record_uncaught_spec.js',\n      ])\n\n      expect(postRun.body.projectId).to.eq('pid123')\n      expect(postRun.body.recordKey).to.eq('f858a2bc-b469-4e48-be67-0876339ee7e1')\n      expect(postRun.body.specPattern).to.eq('cypress/integration/record*')\n      expect(postRun.body.testingType).to.eq('e2e')\n\n      const firstInstance = requests[1]\n\n      expect(firstInstance.body.groupId).to.eq(groupId)\n      expect(firstInstance.body.machineId).to.eq(machineId)\n      expect(firstInstance.body.spec).to.eq(null)\n\n      const firstInstancePostResults = requests[2]\n\n      expect(firstInstancePostResults.body.exception).to.include('Oops...we found an error preparing this test file')\n      expect(firstInstancePostResults.body.tests).to.be.null\n      expect(firstInstancePostResults.body.hooks).to.not.exist\n      expect(firstInstancePostResults.body.screenshots).to.have.length(0)\n      expect(firstInstancePostResults.body.stats.tests).to.eq(0)\n      expect(firstInstancePostResults.body.stats.failures).to.eq(1)\n      expect(firstInstancePostResults.body.stats.passes).to.eq(0)\n\n      const firstInstanceStdout = requests[4]\n\n      expect(firstInstanceStdout.body.stdout).to.include('record_error_spec.js')\n\n      const secondInstance = requests[5]\n\n      expect(secondInstance.body.groupId).to.eq(groupId)\n      expect(secondInstance.body.machineId).to.eq(machineId)\n      expect(secondInstance.body.spec).to.eq(null)\n\n      const secondInstancePostTests = requests[6].body\n\n      expect(secondInstancePostTests.tests).length(2)\n      expect(secondInstancePostTests.hooks).length(1)\n      expect(secondInstancePostTests.config).is.an('object')\n\n      const secondInstancePostResults = requests[7]\n\n      expect(secondInstancePostResults.body.exception).to.be.null\n      expect(secondInstancePostResults.body.tests).to.have.length(2)\n      expect(secondInstancePostResults.body.screenshots).to.have.length(1)\n      expect(secondInstancePostResults.body.stats.tests).to.eq(2)\n      expect(secondInstancePostResults.body.stats.failures).to.eq(1)\n      expect(secondInstancePostResults.body.stats.passes).to.eq(0)\n      expect(secondInstancePostResults.body.stats.skipped).to.eq(1)\n      expect(secondInstancePostResults.body.hooks).not.exist\n      expect(secondInstancePostResults.body.cypressConfig).not.exist\n\n      const secondInstanceStdout = requests[10]\n\n      expect(secondInstanceStdout.body.stdout).to.include('record_fail_spec.js')\n      expect(secondInstanceStdout.body.stdout).not.to.include('record_error_spec.js')\n\n      const thirdInstance = requests[11]\n\n      expect(thirdInstance.body.groupId).to.eq(groupId)\n      expect(thirdInstance.body.machineId).to.eq(machineId)\n      expect(thirdInstance.body.spec).to.eq(null)\n\n      const thirdInstancePostTests = requests[12].body\n\n      expect(thirdInstancePostTests.tests[0].config.env.foo).eq(true)\n      expect(thirdInstancePostTests.tests).length(2)\n      expect(thirdInstancePostTests.hooks).length(0)\n      expect(thirdInstancePostTests.config).is.an('object')\n\n      const thirdInstancePostResults = requests[13]\n\n      expect(thirdInstancePostResults.body.exception).to.be.null\n      expect(thirdInstancePostResults.body.tests).to.have.length(2)\n      expect(thirdInstancePostResults.body.screenshots).to.have.length(1)\n      expect(thirdInstancePostResults.body.stats.tests).to.eq(2)\n      expect(thirdInstancePostResults.body.stats.passes).to.eq(1)\n      expect(thirdInstancePostResults.body.stats.failures).to.eq(0)\n      expect(thirdInstancePostResults.body.stats.pending).to.eq(1)\n\n      const thirdInstanceStdout = requests[15]\n\n      console.log('13')\n\n      expect(thirdInstanceStdout.body.stdout).to.include('record_pass_spec.js')\n      expect(thirdInstanceStdout.body.stdout).not.to.include('record_error_spec.js')\n      expect(thirdInstanceStdout.body.stdout).not.to.include('record_fail_spec.js')\n\n      const fourthInstance = requests[16]\n\n      console.log('14')\n\n      expect(fourthInstance.body.groupId).to.eq(groupId)\n      expect(fourthInstance.body.machineId).to.eq(machineId)\n      expect(fourthInstance.body.spec).to.eq(null)\n\n      const fourthInstancePostResults = requests[18]\n\n      console.log('15')\n\n      expect(fourthInstancePostResults.body.exception).to.be.null\n      expect(fourthInstancePostResults.body.tests).to.have.length(1)\n      expect(fourthInstancePostResults.body.screenshots).to.have.length(1)\n      expect(fourthInstancePostResults.body.stats.tests).to.eq(1)\n      expect(fourthInstancePostResults.body.stats.failures).to.eq(1)\n      expect(fourthInstancePostResults.body.stats.passes).to.eq(0)\n\n      const forthInstanceStdout = requests[21]\n\n      console.log('18')\n\n      expect(forthInstanceStdout.body.stdout).to.include('record_uncaught_spec.js')\n      expect(forthInstanceStdout.body.stdout).not.to.include('record_error_spec.js')\n      expect(forthInstanceStdout.body.stdout).not.to.include('record_fail_spec.js')\n      expect(forthInstanceStdout.body.stdout).not.to.include('record_pass_spec.js')\n\n      let runs = requests.filter((v) => v.url.match(/POST \\/instances\\/.*\\/results/) && v.body.tests).map((v) => v.body)\n\n      expectRunsToHaveCorrectTimings(runs)\n\n      runs = e2e.normalizeRuns(runs)\n\n      snapshot(runs)\n\n      const results = await fs.readJsonAsync(outputPath)\n\n      expect(results.runUrl).to.equal(runUrl)\n    })\n  })\n\n  context('parallelization', () => {\n    const allSpecs = [\n      'cypress/integration/record_error_spec.js',\n      'cypress/integration/record_fail_spec.js',\n      'cypress/integration/record_pass_spec.js',\n      'cypress/integration/record_uncaught_spec.js',\n    ]\n\n    const postInstanceResponses = (specs) => {\n      return _\n      .chain(specs)\n      .map((spec, i) => {\n        return {\n          spec,\n          instanceId,\n          estimatedWallClockDuration: (i + 1) * 1000,\n        }\n      })\n      .concat({\n        spec: null,\n        instanceId: null,\n        estimatedWallClockDuration: null,\n      })\n      .value()\n    }\n\n    // a1 does 3 specs, b2 does 1 spec\n    const a1Specs = _.without(allSpecs, 'cypress/integration/record_pass_spec.js')\n    const b2Specs = _.difference(allSpecs, a1Specs)\n\n    let firstRunResponse = false\n    let waitUntilSecondInstanceClaims = null\n\n    const claimed = []\n\n    const responses = {\n      a1: postInstanceResponses(a1Specs),\n      b2: postInstanceResponses(b2Specs),\n    }\n\n    // replace the 1st + 2nd routes object\n    const routes = createRoutes({\n      postRun: {\n        res (req, res) {\n          let ciBuildId; let group;\n\n          ({ group, tags, ciBuildId } = req.body)\n\n          expect(group).to.eq('prod-e2e')\n          expect(tags).to.deep.eq(['nightly'])\n          expect(ciBuildId).to.eq('ciBuildId123')\n\n          // if this is the first response\n          // give machineId a1, else b2\n          if (!firstRunResponse) {\n            firstRunResponse = true\n            machineId = 'a1ad2bcf-6398-46ed-b201-2fd90b188d5f'\n          } else {\n            machineId = 'b2bd2bcf-6398-46ed-b201-2fd90b188d5f'\n          }\n\n          return res.json(\n            _.extend({}, postRunResponse, { machineId }),\n          )\n        },\n      },\n      postRunInstance: {\n        res (req, res) {\n          let spec;\n\n          ({ machineId, spec } = req.body)\n\n          expect(spec).to.be.null\n\n          const mId = machineId.slice(0, 2)\n\n          const respond = function () {\n            const resp = responses[mId].shift()\n\n            // if theres a spec to claim\n            if (resp.spec) {\n              claimed.push(resp)\n            }\n\n            resp.claimedInstances = claimed.length\n            resp.totalInstances = allSpecs.length\n\n            jsonSchemas.assertSchema('postRunInstanceResponse', '2.1.0')(resp)\n\n            return res.json(resp)\n          }\n\n          // when the 1st machine attempts to claim its FIRST spec, we\n          // automatically delay it until the 2nd machine claims its FIRST\n          // spec so that the request URL's are deterministic\n          if ((mId === 'a1') && (claimed.length === 0)) {\n            waitUntilSecondInstanceClaims = function () {\n              waitUntilSecondInstanceClaims = null\n\n              return respond()\n            }\n          } else {\n            respond()\n\n            return (typeof waitUntilSecondInstanceClaims === 'function' ? waitUntilSecondInstanceClaims() : undefined)\n          }\n        },\n      },\n    })\n\n    setupStubbedServer(routes)\n\n    it('passes in parallel with group', function () {\n      this.retries(3)\n\n      return Promise.all([\n        e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record*',\n          group: 'prod-e2e',\n          record: true,\n          parallel: true,\n          snapshot: true,\n          tag: 'nightly',\n          ciBuildId: 'ciBuildId123',\n          expectedExitCode: 3,\n          config: {\n            trashAssetsBeforeRuns: false,\n          },\n        })\n        .get('stdout'),\n\n        // stagger the 2nd run\n        // starting up a bit\n        Promise\n        .delay(3000)\n        .then(() => {\n          return e2e.exec(this, {\n            key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n            spec: 'record*',\n            group: 'prod-e2e',\n            record: true,\n            parallel: true,\n            snapshot: true,\n            tag: 'nightly',\n            ciBuildId: 'ciBuildId123',\n            config: {\n              trashAssetsBeforeRuns: false,\n            },\n          })\n          .get('stdout')\n        }),\n      ])\n    })\n  })\n\n  context('metadata', () => {\n    setupStubbedServer(createRoutes())\n\n    it('sends Studio usage metadata', function () {\n      return e2e.exec(this, {\n        key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n        spec: 'studio_written.spec.js',\n        record: true,\n        snapshot: true,\n      })\n      .then(() => {\n        const postResults = requests[3]\n\n        expect(postResults.url).to.eq(`POST /instances/${instanceId}/results`)\n\n        expect(postResults.body.metadata.studioCreated).to.eq(2)\n        expect(postResults.body.metadata.studioExtended).to.eq(4)\n      })\n    })\n  })\n\n  context('misconfiguration', () => {\n    setupStubbedServer([])\n\n    it('errors and exits when no specs found', function () {\n      return e2e.exec(this, {\n        spec: 'notfound/**',\n        snapshot: true,\n        expectedExitCode: 1,\n      })\n      .then(() => {\n        expect(getRequestUrls()).to.be.empty\n      })\n    })\n\n    it('errors and exits when no browser found', function () {\n      return e2e.exec(this, {\n        browser: 'browserDoesNotExist',\n        spec: 'record_pass*',\n        snapshot: true,\n        expectedExitCode: 1,\n      })\n      .then(() => {\n        expect(getRequestUrls()).to.be.empty\n      })\n    })\n  })\n\n  context('empty specs', () => {\n    setupStubbedServer(createRoutes())\n\n    // https://github.com/cypress-io/cypress/issues/15512\n    it('succeeds when empty spec file', async function () {\n      await e2e.exec(this, {\n        key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n        record: true,\n        spec: 'empty_suite.spec.js,empty.spec.js',\n        snapshot: true,\n        expectedExitCode: 0,\n      })\n\n      expect(getRequestUrls()).deep.eq([\n        'POST /runs',\n        `POST /runs/${runId}/instances`,\n        `POST /instances/${instanceId}/tests`,\n        `POST /instances/${instanceId}/results`,\n        `PUT /instances/${instanceId}/stdout`,\n\n        `POST /runs/${runId}/instances`,\n        `POST /instances/${instanceId}/tests`,\n        `POST /instances/${instanceId}/results`,\n        `PUT /instances/${instanceId}/stdout`,\n\n        `POST /runs/${runId}/instances`,\n      ])\n    })\n  })\n\n  context('projectId', () => {\n    e2e.setup()\n\n    it('errors and exits without projectId', function () {\n      return e2e.exec(this, {\n        key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n        spec: 'record_pass*',\n        record: true,\n        snapshot: true,\n        expectedExitCode: 1,\n      })\n    })\n  })\n\n  context('quiet mode', () => {\n    setupStubbedServer(createRoutes())\n\n    it('respects quiet mode', function () {\n      return e2e.exec(this, {\n        key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n        spec: 'record_pass*',\n        record: true,\n        snapshot: true,\n        expectedExitCode: 0,\n        quiet: true,\n      })\n    })\n  })\n\n  context('recordKey', () => {\n    setupStubbedServer(createRoutes())\n\n    it('errors and exits without recordKey', function () {\n      return e2e.exec(this, {\n        spec: 'record_pass*',\n        record: true,\n        snapshot: true,\n        expectedExitCode: 1,\n      })\n      .then(() => {\n        expect(getRequestUrls()).to.be.empty\n      })\n    })\n\n    it('warns but does not exit when is forked pr', function () {\n      process.env.CIRCLECI = 'true'\n      process.env.CIRCLE_PR_NUMBER = '123'\n      process.env.CIRCLE_PR_USERNAME = 'brian-mann'\n      process.env.CIRCLE_PR_REPONAME = 'cypress'\n      process.env.CYPRESS_INTERNAL_E2E_TESTS = '0'\n\n      return e2e.exec(this, {\n        spec: 'record_pass*',\n        record: true,\n        snapshot: true,\n      })\n      .then(() => {\n        console.log('GETREQUESTURLS', getRequestUrls())\n\n        expect(getRequestUrls()).to.be.empty\n      })\n    })\n\n    it('warns but does not exit when is forked pr and parallel', function () {\n      process.env.CIRCLECI = 'true'\n      process.env.CIRCLE_WORKFLOW_ID = '123'\n      process.env.CIRCLE_PR_NUMBER = '123'\n      process.env.CIRCLE_PR_USERNAME = 'brian-mann'\n      process.env.CIRCLE_PR_REPONAME = 'cypress'\n      process.env.CYPRESS_INTERNAL_E2E_TESTS = '0'\n\n      return e2e.exec(this, {\n        spec: 'record_pass*',\n        record: true,\n        parallel: true,\n        snapshot: true,\n      })\n      .then(() => {\n        expect(getRequestUrls()).to.be.empty\n      })\n    })\n  })\n\n  context('test configuration', () => {\n    setupStubbedServer(createRoutes(), {\n      video: false,\n      defaultCommandTimeout: 9999,\n    })\n\n    it('config from runtime, testOptions', async function () {\n      await e2e.exec(this, {\n        key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n        spec: 'config_record_spec*',\n        record: true,\n        snapshot: false,\n\n      })\n\n      expect(requests[2].body.config.defaultCommandTimeout).eq(1111)\n      expect(requests[2].body.config.resolved.defaultCommandTimeout).deep.eq({\n        value: 1111,\n        from: 'runtime',\n      })\n\n      expect(requests[2].body.config.pageLoadTimeout).eq(3333)\n      expect(requests[2].body.config.resolved.pageLoadTimeout).deep.eq({\n        value: 3333,\n        from: 'runtime',\n      })\n\n      expect(requests[2].body.tests[0].config).deep.eq({\n        defaultCommandTimeout: 1234,\n        env: { foo: true },\n        retries: 2,\n      })\n\n      expect(requests[2].body.tests[3].title).deep.eq([\n        'record pass',\n        'is skipped due to browser',\n      ])\n\n      expect(requests[2].body.tests[3].config).deep.eq({\n        defaultCommandTimeout: 1234,\n        browser: 'edge',\n      })\n    })\n  })\n\n  context('record in non-parallel', () => {\n    describe('api reordering specs', () => {\n      let mockServerState\n\n      mockServerState = setupStubbedServer(createRoutes({\n        postRun: {\n          res (req, res) {\n            console.log(req.body.specs)\n            mockServerState.specs = req.body.specs.slice().reverse()\n            console.log(mockServerState.specs)\n            mockServerState.allSpecs = req.body.specs\n            res.json(postRunResponse)\n          },\n        },\n      }), { video: false })\n\n      it('changes spec run order', async function () {\n        await e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'a_record.spec.js,b_record.spec.js',\n          record: true,\n          snapshot: false,\n        })\n\n        // specs were reordered\n        expect(requests[2].body.tests[0].title[1]).eq('b test')\n        expect(requests[6].body.tests[0].title[1]).eq('a test')\n      })\n    })\n  })\n\n  describe('api skips specs', () => {\n    let mockServerState = setupStubbedServer(createRoutes({\n\n      postInstanceTests: {\n        res: (req, res) => {\n          console.log(mockServerState.specs)\n          if (mockServerState.specs.length > 0) {\n            return res.json({\n              ...postInstanceTestsResponse,\n              actions: [{\n                type: 'SPEC',\n                action: 'SKIP',\n              }],\n            })\n          }\n\n          return res.json({\n            ...postInstanceTestsResponse,\n            actions: [],\n          })\n        },\n      },\n\n    }), { video: false })\n\n    it('records tests and exits without executing', async function () {\n      await e2e.exec(this, {\n        key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n        spec: 'a_record_instantfail.spec.js,b_record.spec.js',\n        record: true,\n        snapshot: true,\n        expectedExitCode: 1,\n      })\n\n      expect(getRequestUrls()).deep.eq([\n        'POST /runs',\n        'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n        'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/tests',\n        'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n        'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/tests',\n        'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/results',\n        'PUT /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/stdout',\n        'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n      ])\n\n      console.log(requests[0].body.runnerCapabilities)\n      expect(requests[0].body).property('runnerCapabilities').deep.eq({\n        'dynamicSpecsInSerialMode': true,\n        'skipSpecAction': true,\n      })\n    })\n\n    it('records tests and exits without executing in parallel', async function () {\n      await e2e.exec(this, {\n        key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n        spec: 'a_record_instantfail.spec.js,b_record.spec.js',\n        record: true,\n        snapshot: true,\n        group: 'abc',\n        parallel: true,\n        ciBuildId: 'ciBuildId123',\n        expectedExitCode: 1,\n      })\n\n      expect(getRequestUrls()).deep.eq([\n        'POST /runs',\n        'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n        'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/tests',\n        'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n        'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/tests',\n        'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/results',\n        'PUT /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/stdout',\n        'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n      ])\n    })\n  })\n\n  context('video recording', () => {\n    setupStubbedServer(createRoutes(), {\n      video: false,\n    })\n\n    it('does not upload when not enabled', function () {\n      return e2e.exec(this, {\n        key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n        spec: 'record_pass*',\n        record: true,\n        snapshot: true,\n      })\n    })\n  })\n\n  context('api interaction errors', () => {\n    describe('recordKey and projectId', () => {\n      const routes = createRoutes({\n        postRun: {\n          res (req, res) {\n            return res.sendStatus(401)\n          },\n        },\n      })\n\n      setupStubbedServer(routes)\n\n      it('errors and exits on 401', function () {\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n      })\n    })\n\n    describe('project 404', () => {\n      const routes = createRoutes({\n        postRun: {\n          res (req, res) {\n            return res.sendStatus(404)\n          },\n        },\n      })\n\n      setupStubbedServer(routes)\n\n      it('errors and exits', function () {\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n      })\n    })\n\n    describe('create run 500', () => {\n      const routes = createRoutes({\n        postRun: {\n          res (req, res) {\n            return res.sendStatus(500)\n          },\n        },\n      })\n\n      setupStubbedServer(routes)\n\n      it('errors and exits', function () {\n        process.env.DISABLE_API_RETRIES = 'true'\n\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n          ])\n        })\n      })\n\n      it('when grouping without parallelization errors and exits', function () {\n        process.env.DISABLE_API_RETRIES = 'true'\n\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          group: 'foo',\n          record: true,\n          snapshot: true,\n          ciBuildId: 'ciBuildId123',\n          expectedExitCode: 1,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n          ])\n        })\n      })\n\n      it('does not proceed and exits with error when parallelizing', function () {\n        process.env.DISABLE_API_RETRIES = 'true'\n\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          group: 'foo',\n          tag: 'nightly',\n          record: true,\n          parallel: true,\n          snapshot: true,\n          ciBuildId: 'ciBuildId123',\n          expectedExitCode: 1,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n          ])\n        })\n      })\n    })\n\n    describe('create instance 500', () => {\n      const routes = createRoutes({\n        postRunInstance: {\n          res (req, res) {\n            return res.sendStatus(500)\n          },\n        },\n      })\n\n      setupStubbedServer(_.values(routes))\n\n      it('does not proceed and exits with error when parallelizing and creating instance', function () {\n        process.env.DISABLE_API_RETRIES = 'true'\n\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          group: 'foo',\n          tag: 'nightly',\n          record: true,\n          parallel: true,\n          snapshot: true,\n          ciBuildId: 'ciBuildId123',\n          expectedExitCode: 1,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n            `POST /runs/${runId}/instances`,\n          ])\n        })\n      })\n\n      it('without parallelization - does not proceed', async function () {\n        process.env.DISABLE_API_RETRIES = 'true'\n\n        await e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: '*_record.spec.js',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n            'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n          ])\n        })\n      })\n    })\n\n    describe('update instance 500', () => {\n      const routes = createRoutes({\n        postRunInstance: {\n          res (req, res) {\n            return res.json({\n              instanceId,\n              spec: 'cypress/integration/record_pass_spec.js',\n              estimatedWallClockDuration: 5000,\n              totalInstances: 1,\n              claimedInstances: 1,\n            })\n          },\n        },\n        postInstanceResults: {\n          res (req, res) {\n            return res.sendStatus(500)\n          },\n        },\n      })\n\n      setupStubbedServer(routes)\n\n      it('does not proceed and exits with error when parallelizing and updating instance', function () {\n        process.env.DISABLE_API_RETRIES = 'true'\n\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          group: 'foo',\n          tag: 'nightly',\n          record: true,\n          parallel: true,\n          snapshot: true,\n          ciBuildId: 'ciBuildId123',\n          expectedExitCode: 1,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n            `POST /runs/${runId}/instances`,\n            'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/tests',\n            'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/results',\n          ])\n        })\n      })\n    })\n\n    describe('create run 422', () => {\n      setupStubbedServer(createRoutes({\n        postRun: {\n          res (req, res) {\n            return res.status(422).json({\n              code: 'RUN_GROUP_NAME_NOT_UNIQUE',\n              message: 'Run group name cannot be used again without passing the parallel flag.',\n              payload: {\n                runUrl: 'https://dashboard.cypress.io/runs/12345',\n              },\n            })\n          },\n        },\n      }))\n\n      // the other 422 tests for this are in integration/cypress_spec\n      it('errors and exits when group name is in use', function () {\n        process.env.CIRCLECI = '1'\n\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          group: 'e2e-tests',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n          ])\n        })\n      })\n    })\n\n    describe('create run unknown 422', () => {\n      setupStubbedServer(createRoutes({\n        postRun: {\n          res (req, res) {\n            return res.status(422).json({\n              code: 'SOMETHING_UNKNOWN',\n              message: 'An unknown message here from the server.',\n            })\n          },\n        },\n      }))\n\n      it('errors and exits when there is an unknown 422 response', function () {\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          group: 'e2e-tests',\n          tag: 'nightly',\n          record: true,\n          parallel: true,\n          snapshot: true,\n          ciBuildId: 'ciBuildId123',\n          expectedExitCode: 1,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n          ])\n        })\n      })\n    })\n\n    describe('create run 402 - free plan exceeds monthly private tests', () => {\n      setupStubbedServer(createRoutes({\n        postRun: {\n          res (req, res) {\n            return res.status(402).json({\n              code: 'FREE_PLAN_EXCEEDS_MONTHLY_PRIVATE_TESTS',\n              payload: {\n                used: 600,\n                limit: 500,\n                orgId: 'org-id-1234',\n              },\n            })\n          },\n        },\n      }))\n\n      it('errors and exits when on free plan and over recorded runs limit', function () {\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n      })\n    })\n\n    describe('create run 402 - free plan exceeds monthly tests', () => {\n      setupStubbedServer(createRoutes({\n        postRun: {\n          res (req, res) {\n            return res.status(402).json({\n              code: 'FREE_PLAN_EXCEEDS_MONTHLY_TESTS',\n              payload: {\n                used: 600,\n                limit: 500,\n                orgId: 'org-id-1234',\n              },\n            })\n          },\n        },\n      }))\n\n      it('errors and exits when on free plan and over recorded tests limit', function () {\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n      })\n    })\n\n    describe('create run 402 - parallel feature not available in plan', () => {\n      setupStubbedServer(createRoutes({\n        postRun: {\n          res (req, res) {\n            return res.status(402).json({\n              code: 'PARALLEL_FEATURE_NOT_AVAILABLE_IN_PLAN',\n              payload: {\n                orgId: 'org-id-1234',\n              },\n            })\n          },\n        } }))\n\n      it('errors and exits when attempting parallel run when not available in plan', function () {\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n      })\n    })\n\n    describe('create run 402 - grouping feature not available in plan', () => {\n      setupStubbedServer(createRoutes({ postRun: {\n        res (req, res) {\n          return res.status(402).json({\n            code: 'RUN_GROUPING_FEATURE_NOT_AVAILABLE_IN_PLAN',\n            payload: {\n              orgId: 'org-id-1234',\n            },\n          })\n        },\n      } }))\n\n      it('errors and exits when attempting parallel run when not available in plan', function () {\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n      })\n    })\n\n    describe('create run 402 - unknown error', () => {\n      setupStubbedServer(createRoutes({ postRun: {\n        res (req, res) {\n          return res.status(402).json({\n            error: 'Something went wrong',\n          })\n        },\n      } }))\n\n      it('errors and exits when there\\'s an unknown 402 error', function () {\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n      })\n    })\n\n    describe('create instance', () => {\n      setupStubbedServer(createRoutes({\n        postRunInstance: {\n          res (req, res) {\n            return res.sendStatus(500)\n          },\n        },\n      }))\n\n      it('errors and exits on createInstance error', function () {\n        process.env.DISABLE_API_RETRIES = 'true'\n\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: '*_record_*',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n            `POST /runs/${runId}/instances`,\n          ])\n        })\n      })\n    })\n\n    describe('postInstanceTests', () => {\n      setupStubbedServer(createRoutes({\n        postInstanceTests: {\n          res (req, res) {\n            res.sendStatus(500)\n          },\n        },\n      }))\n\n      // it('without parallelization continues, does not post instance results', async function () {\n      //   process.env.DISABLE_API_RETRIES = 'true'\n\n      //   return e2e.exec(this, {\n      //     key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n      //     spec: '*_record.spec*',\n      //     record: true,\n      //     snapshot: true,\n      //   })\n      //   .then(() => {\n      //     const urls = getRequestUrls()\n\n      //     expect(urls).to.deep.eq([\n      //       'POST /runs',\n      //       'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n      //       'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/tests',\n      //       'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n      //       'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/tests',\n      //     ])\n      //   })\n      // })\n\n      it('without parallelization errors and exits', async function () {\n        process.env.DISABLE_API_RETRIES = 'true'\n\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: '*_record.spec*',\n          group: 'foo',\n          ciBuildId: 1,\n          expectedExitCode: 1,\n          record: true,\n          snapshot: true,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n            'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n            'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/tests',\n          ])\n        })\n      })\n\n      it('with parallelization errors and exits', async function () {\n        process.env.DISABLE_API_RETRIES = 'true'\n\n        await e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: '*_record.spec.js',\n          record: true,\n          group: 'foo',\n          ciBuildId: 'ciBuildId123',\n          expectedExitCode: 1,\n          parallel: true,\n          snapshot: true,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n            'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n            'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/tests',\n          ])\n        })\n      })\n    })\n\n    describe('postInstanceResults', () => {\n      const routes = createRoutes({\n        postInstanceResults: {\n          res (req, res) {\n            return res.sendStatus(500)\n          },\n        },\n      })\n\n      setupStubbedServer(routes)\n\n      it('errors and exits in serial', function () {\n        process.env.DISABLE_API_RETRIES = 'true'\n\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          record: true,\n          snapshot: true,\n          expectedExitCode: 1,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n            `POST /runs/${runId}/instances`,\n            `POST /instances/${instanceId}/tests`,\n            `POST /instances/${instanceId}/results`,\n          ])\n        })\n      })\n    })\n\n    describe('update instance stdout', () => {\n      const routes = createRoutes({\n        putInstanceStdout: {\n          res (req, res) {\n            return res.sendStatus(500)\n          },\n        },\n      })\n\n      setupStubbedServer(routes)\n\n      it('warns but proceeds', function () {\n        process.env.DISABLE_API_RETRIES = 'true'\n\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          record: true,\n          snapshot: true,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n            `POST /runs/${runId}/instances`,\n            `POST /instances/${instanceId}/tests`,\n            `POST /instances/${instanceId}/results`,\n            'PUT /screenshots/1.png',\n            `PUT /instances/${instanceId}/stdout`,\n            `POST /runs/${runId}/instances`,\n          ])\n        })\n      })\n    })\n\n    describe('uploading assets', () => {\n      const routes = createRoutes({\n\n        putVideo: {\n          res (req, res) {\n            return Promise.delay(500)\n            .then(() => {\n              return res.sendStatus(500)\n            })\n          },\n        },\n        putScreenshots: {\n          res (req, res) {\n            return res.sendStatus(500)\n          },\n        },\n      })\n\n      setupStubbedServer(routes, {\n        videoUploadOnPasses: true,\n      })\n\n      it('warns but proceeds', function () {\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          record: true,\n          snapshot: true,\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.have.members([\n            'POST /runs',\n            `POST /runs/${runId}/instances`,\n            `POST /instances/${instanceId}/tests`,\n            `POST /instances/${instanceId}/results`,\n            'PUT /videos/video.mp4',\n            'PUT /screenshots/1.png',\n            `PUT /instances/${instanceId}/stdout`,\n          ])\n        })\n      })\n    })\n\n    describe('api retries on error', () => {\n      let count = 0\n\n      const routes = createRoutes({\n        postRun: {\n          res (req, res) {\n            count += 1\n\n            if (count === 4) {\n              return res.json(postRunResponse)\n            }\n\n            return res.sendStatus(500)\n          },\n        },\n        postRunInstance: {\n          res (req, res) {\n            count += 1\n\n            if (count === 5) {\n              return res.sendStatus(500)\n            }\n\n            if (count === 6) {\n              return res.json({\n                instanceId,\n                spec: 'cypress/integration/record_pass_spec.js',\n                estimatedWallClockDuration: 5000,\n                totalInstances: 1,\n                claimedInstances: 1,\n              })\n            }\n\n            return res.json({\n              instanceId,\n              spec: null,\n              estimatedWallClockDuration: null,\n              totalInstances: 0,\n              claimedInstances: 0,\n            })\n          },\n        },\n\n      })\n\n      setupStubbedServer(routes)\n\n      it('warns and does not create or update instances', function () {\n        process.env.API_RETRY_INTERVALS = '1000,2000,3000'\n\n        return e2e.exec(this, {\n          key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n          spec: 'record_pass*',\n          group: 'foo',\n          tag: 'nightly',\n          record: true,\n          parallel: true,\n          snapshot: true,\n          ciBuildId: 'ciBuildId123',\n        })\n        .then(() => {\n          const urls = getRequestUrls()\n\n          expect(urls).to.deep.eq([\n            'POST /runs',\n            'POST /runs',\n            'POST /runs',\n            'POST /runs',\n            'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n            'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n            'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/tests',\n            'POST /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/results',\n            'PUT /screenshots/1.png',\n            'PUT /instances/e9e81b5e-cc58-4026-b2ff-8ae3161435a6/stdout',\n            'POST /runs/00748421-e035-4a3d-8604-8468cc48bdb5/instances',\n          ])\n        })\n      })\n    })\n  })\n\n  describe('api interaction warnings', () => {\n    describe('create run warnings', () => {\n      describe('grace period - over private tests limit', () => {\n        const mockServer = setupStubbedServer(createRoutes({\n          postRun: {\n            res (req, res) {\n              mockServer.setSpecs(req)\n\n              return res.status(200).json({\n                runId,\n                groupId,\n                machineId,\n                runUrl,\n                tags,\n                warnings: [{\n                  name: 'foo',\n                  message: 'foo',\n                  code: 'FREE_PLAN_IN_GRACE_PERIOD_EXCEEDS_MONTHLY_PRIVATE_TESTS',\n                  limit: 500,\n                  gracePeriodEnds: '2999-12-31',\n                  orgId: 'org-id-1234',\n                }],\n              })\n            },\n          },\n\n        }))\n\n        it('warns when over private test results', function () {\n          return e2e.exec(this, {\n            key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n            spec: 'record_pass*',\n            record: true,\n            snapshot: true,\n          })\n        })\n      })\n\n      describe('grace period - over tests limit', () => {\n        const mockServer = setupStubbedServer(createRoutes({\n          postRun: {\n            res (req, res) {\n              mockServer.setSpecs(req)\n\n              return res.status(200).json({\n                runId,\n                groupId,\n                machineId,\n                runUrl,\n                tags,\n                warnings: [{\n                  name: 'foo',\n                  message: 'foo',\n                  code: 'FREE_PLAN_IN_GRACE_PERIOD_EXCEEDS_MONTHLY_TESTS',\n                  limit: 500,\n                  gracePeriodEnds: '2999-12-31',\n                  orgId: 'org-id-1234',\n                }],\n              })\n            },\n          },\n        }))\n\n        it('warns when over test results', function () {\n          return e2e.exec(this, {\n            key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n            spec: 'record_pass*',\n            record: true,\n            snapshot: true,\n          })\n        })\n      })\n\n      describe('grace period - parallel feature', () => {\n        const mockServer = setupStubbedServer(createRoutes({\n          postRun: {\n            res (req, res) {\n              mockServer.setSpecs(req)\n\n              return res.status(200).json({\n                runId,\n                groupId,\n                machineId,\n                runUrl,\n                tags,\n                warnings: [{\n                  name: 'foo',\n                  message: 'foo',\n                  code: 'FREE_PLAN_IN_GRACE_PERIOD_PARALLEL_FEATURE',\n                  gracePeriodEnds: '2999-12-31',\n                  orgId: 'org-id-1234',\n                }],\n              })\n            },\n          },\n        }))\n\n        it('warns when using parallel feature', function () {\n          return e2e.exec(this, {\n            key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n            spec: 'record_pass*',\n            record: true,\n            snapshot: true,\n          })\n        })\n      })\n\n      describe('grace period - grouping feature', () => {\n        const mockServer = setupStubbedServer(createRoutes({\n          postRun: {\n            res (req, res) {\n              mockServer.setSpecs(req)\n\n              return res.status(200).json({\n                runId,\n                groupId,\n                machineId,\n                runUrl,\n                tags,\n                warnings: [{\n                  name: 'foo',\n                  message: 'foo',\n                  code: 'PLAN_IN_GRACE_PERIOD_RUN_GROUPING_FEATURE_USED',\n                  gracePeriodEnds: '2999-12-31',\n                  orgId: 'org-id-1234',\n                }],\n              })\n            },\n          },\n        }))\n\n        it('warns when using parallel feature', function () {\n          return e2e.exec(this, {\n            key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n            spec: 'record_pass*',\n            record: true,\n            snapshot: true,\n          })\n        })\n      })\n\n      describe('paid plan - over private tests limit', () => {\n        const mockServer = setupStubbedServer(createRoutes({\n          postRun: {\n            res (req, res) {\n              mockServer.setSpecs(req)\n\n              return res.status(200).json({\n                runId,\n                groupId,\n                machineId,\n                runUrl,\n                tags,\n                warnings: [{\n                  name: 'foo',\n                  message: 'foo',\n                  code: 'PAID_PLAN_EXCEEDS_MONTHLY_PRIVATE_TESTS',\n                  used: 700,\n                  limit: 500,\n                  orgId: 'org-id-1234',\n                }],\n              })\n            },\n          },\n        }))\n\n        it('warns when over private test results', function () {\n          return e2e.exec(this, {\n            key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n            spec: 'record_pass*',\n            record: true,\n            snapshot: true,\n          })\n        })\n      })\n\n      describe('paid plan - over tests limit', () => {\n        const mockServer = setupStubbedServer(createRoutes({\n          postRun: {\n            res (req, res) {\n              mockServer.setSpecs(req)\n\n              return res.status(200).json({\n                runId,\n                groupId,\n                machineId,\n                runUrl,\n                tags,\n                warnings: [{\n                  name: 'foo',\n                  message: 'foo',\n                  code: 'PAID_PLAN_EXCEEDS_MONTHLY_TESTS',\n                  used: 700,\n                  limit: 500,\n                  orgId: 'org-id-1234',\n                }],\n              })\n            },\n          },\n        }))\n\n        it('warns when over test results', function () {\n          return e2e.exec(this, {\n            key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n            spec: 'record_pass*',\n            record: true,\n            snapshot: true,\n          })\n        })\n      })\n\n      describe('free plan - over tests limit v2', () => {\n        const mockServer = setupStubbedServer(createRoutes({\n          postRun: {\n            res (req, res) {\n              mockServer.setSpecs(req)\n\n              return res.status(200).json({\n                runId,\n                groupId,\n                machineId,\n                runUrl,\n                tags,\n                warnings: [{\n                  name: 'FreePlanExceedsMonthlyTests',\n                  message: 'Warning from Cypress Dashboard: Organization with free plan has exceeded monthly test results limit.',\n                  code: 'FREE_PLAN_EXCEEDS_MONTHLY_TESTS_V2',\n                  used: 700,\n                  limit: 500,\n                  orgId: 'org-id-1234',\n                }],\n              })\n            },\n          },\n        }))\n\n        it('warns when over test results', function () {\n          return e2e.exec(this, {\n            key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n            spec: 'record_pass*',\n            record: true,\n            snapshot: true,\n          })\n        })\n      })\n\n      describe('unknown warning', () => {\n        const mockServer = setupStubbedServer(createRoutes({\n          postRun: {\n            res: (req, res) => {\n              mockServer.setSpecs(req)\n              res.json(postRunResponseWithWarnings)\n            },\n          },\n        }))\n\n        it('warns with unknown warning code', function () {\n          return e2e.exec(this, {\n            key: 'f858a2bc-b469-4e48-be67-0876339ee7e1',\n            spec: 'record_pass*',\n            record: true,\n            snapshot: true,\n          })\n        })\n      })\n    })\n  })\n})\n",
    "packages/server/test/integration/cypress_spec.js": "require('../spec_helper')\n\nconst R = require('ramda')\nconst _ = require('lodash')\nconst path = require('path')\nconst EE = require('events')\nconst http = require('http')\nconst Promise = require('bluebird')\nconst electron = require('electron')\nconst commitInfo = require('@cypress/commit-info')\nconst Fixtures = require('../support/helpers/fixtures')\nconst snapshot = require('snap-shot-it')\nconst stripAnsi = require('strip-ansi')\nconst debug = require('debug')('test')\nconst pkg = require('@packages/root')\nconst detect = require('@packages/launcher/lib/detect')\nconst launch = require('@packages/launcher/lib/browsers')\nconst extension = require('@packages/extension')\nconst argsUtil = require(`${root}lib/util/args`)\nconst { fs } = require(`${root}lib/util/fs`)\nconst ciProvider = require(`${root}lib/util/ci_provider`)\nconst settings = require(`${root}lib/util/settings`)\nconst Events = require(`${root}lib/gui/events`)\nconst Windows = require(`${root}lib/gui/windows`)\nconst interactiveMode = require(`${root}lib/modes/interactive-e2e`)\nconst runMode = require(`${root}lib/modes/run`)\nconst api = require(`${root}lib/api`)\nconst cwd = require(`${root}lib/cwd`)\nconst user = require(`${root}lib/user`)\nconst config = require(`${root}lib/config`)\nconst cache = require(`${root}lib/cache`)\nconst errors = require(`${root}lib/errors`)\nconst plugins = require(`${root}lib/plugins`)\nconst cypress = require(`${root}lib/cypress`)\nconst { ProjectBase } = require(`${root}lib/project-base`)\nconst { ProjectE2E } = require(`${root}lib/project-e2e`)\nconst { ServerE2E } = require(`${root}lib/server-e2e`)\nconst Reporter = require(`${root}lib/reporter`)\nconst Watchers = require(`${root}lib/watchers`)\nconst browsers = require(`${root}lib/browsers`)\nconst videoCapture = require(`${root}lib/video_capture`)\nconst browserUtils = require(`${root}lib/browsers/utils`)\nconst chromeBrowser = require(`${root}lib/browsers/chrome`)\nconst openProject = require(`${root}lib/open_project`)\nconst env = require(`${root}lib/util/env`)\nconst v = require(`${root}lib/util/validation`)\nconst system = require(`${root}lib/util/system`)\nconst appData = require(`${root}lib/util/app_data`)\nconst electronApp = require('../../lib/util/electron-app')\nconst savedState = require(`${root}lib/saved_state`)\n\nconst TYPICAL_BROWSERS = [\n  {\n    name: 'chrome',\n    family: 'chromium',\n    channel: 'stable',\n    displayName: 'Chrome',\n    version: '60.0.3112.101',\n    path: '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',\n    majorVersion: '60',\n  }, {\n    name: 'chromium',\n    family: 'chromium',\n    channel: 'stable',\n    displayName: 'Chromium',\n    version: '49.0.2609.0',\n    path: '/Users/bmann/Downloads/chrome-mac/Chromium.app/Contents/MacOS/Chromium',\n    majorVersion: '49',\n  }, {\n    name: 'chrome',\n    family: 'chromium',\n    channel: 'canary',\n    displayName: 'Canary',\n    version: '62.0.3197.0',\n    path: '/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary',\n    majorVersion: '62',\n  },\n]\n\nconst ELECTRON_BROWSER = {\n  name: 'electron',\n  family: 'chromium',\n  displayName: 'Electron',\n  path: '',\n  version: '99.101.1234',\n  majorVersion: 99,\n}\n\nconst previousCwd = process.cwd()\n\nconst snapshotConsoleLogs = function (name) {\n  const args = _\n  .chain(console.log.args)\n  .map((innerArgs) => {\n    return innerArgs.join(' ')\n  }).join('\\n')\n  .value()\n\n  // our cwd() is currently the project\n  // so must switch back to original\n  process.chdir(previousCwd)\n\n  return snapshot(name, stripAnsi(args))\n}\n\ndescribe('lib/cypress', () => {\n  require('mocha-banner').register()\n\n  beforeEach(function () {\n    this.timeout(8000)\n\n    cache.__removeSync()\n\n    Fixtures.scaffold()\n    this.todosPath = Fixtures.projectPath('todos')\n    this.pristinePath = Fixtures.projectPath('pristine')\n    this.noScaffolding = Fixtures.projectPath('no-scaffolding')\n    this.recordPath = Fixtures.projectPath('record')\n    this.pluginConfig = Fixtures.projectPath('plugin-config')\n    this.pluginBrowser = Fixtures.projectPath('plugin-browser')\n    this.idsPath = Fixtures.projectPath('ids')\n\n    // force cypress to call directly into main without\n    // spawning a separate process\n    sinon.stub(videoCapture, 'start').resolves({})\n    sinon.stub(plugins, 'init').resolves(undefined)\n    sinon.stub(electronApp, 'isRunning').returns(true)\n    sinon.stub(extension, 'setHostAndPath').resolves()\n    sinon.stub(detect, 'detect').resolves(TYPICAL_BROWSERS)\n    sinon.stub(process, 'exit')\n    sinon.stub(ServerE2E.prototype, 'reset')\n    sinon.stub(errors, 'warning')\n    .callThrough()\n    .withArgs('INVOKED_BINARY_OUTSIDE_NPM_MODULE')\n    .returns(null)\n\n    sinon.spy(errors, 'log')\n    sinon.spy(errors, 'logException')\n    sinon.spy(console, 'log')\n\n    // to make sure our Electron browser mock object passes validation during tests\n    sinon.stub(process, 'versions').value({\n      chrome: ELECTRON_BROWSER.version,\n      electron: '123.45.6789',\n    })\n\n    this.expectExitWith = (code) => {\n      expect(process.exit).to.be.calledWith(code)\n    }\n\n    // returns error object\n    this.expectExitWithErr = (type, msg1, msg2) => {\n      expect(errors.log, 'error was logged').to.be.calledWithMatch({ type })\n      expect(process.exit, 'process.exit was called').to.be.calledWith(1)\n\n      const err = errors.log.getCall(0).args[0]\n\n      if (msg1) {\n        expect(err.message, 'error text').to.include(msg1)\n      }\n\n      if (msg2) {\n        expect(err.message, 'second error text').to.include(msg2)\n      }\n\n      return err\n    }\n  })\n\n  afterEach(async () => {\n    try {\n      // make sure every project\n      // we spawn is closed down\n      await openProject.close()\n    } catch (e) {\n      // ...\n    }\n\n    Fixtures.remove()\n  })\n\n  context('test browsers', () => {\n    // sanity checks to make sure the browser objects we pass during tests\n    // all pass the internal validation function\n    it('has valid browsers', () => {\n      expect(v.isValidBrowserList('browsers', TYPICAL_BROWSERS)).to.be.true\n    })\n\n    it('has valid electron browser', () => {\n      expect(v.isValidBrowserList('browsers', [ELECTRON_BROWSER])).to.be.true\n    })\n\n    it('allows browser major to be a number', () => {\n      const browser = {\n        name: 'Edge Beta',\n        family: 'chromium',\n        displayName: 'Edge Beta',\n        version: '80.0.328.2',\n        path: '/some/path',\n        majorVersion: 80,\n      }\n\n      expect(v.isValidBrowserList('browsers', [browser])).to.be.true\n    })\n\n    it('validates returned list', () => {\n      return browserUtils.getBrowsers().then((list) => {\n        expect(v.isValidBrowserList('browsers', list)).to.be.true\n      })\n    })\n  })\n\n  context('error handling', function () {\n    it('exits if config cannot be parsed', function () {\n      return cypress.start(['--config', 'xyz'])\n      .then(() => {\n        const err = this.expectExitWithErr('COULD_NOT_PARSE_ARGUMENTS')\n\n        snapshot('could not parse config error', stripAnsi(err.message))\n      })\n    })\n\n    it('exits if env cannot be parsed', function () {\n      return cypress.start(['--env', 'a123'])\n      .then(() => {\n        const err = this.expectExitWithErr('COULD_NOT_PARSE_ARGUMENTS')\n\n        snapshot('could not parse env error', stripAnsi(err.message))\n      })\n    })\n\n    it('exits if reporter options cannot be parsed', function () {\n      return cypress.start(['--reporterOptions', 'nonono'])\n      .then(() => {\n        const err = this.expectExitWithErr('COULD_NOT_PARSE_ARGUMENTS')\n\n        snapshot('could not parse reporter options error', stripAnsi(err.message))\n      })\n    })\n  })\n\n  context('invalid config', function () {\n    beforeEach(function () {\n      this.win = {\n        on: sinon.stub(),\n        webContents: {\n          on: sinon.stub(),\n        },\n      }\n\n      sinon.stub(electron.app, 'on').withArgs('ready').yieldsAsync()\n      sinon.stub(Windows, 'open').resolves(this.win)\n    })\n\n    it('shows warning if config is not valid', function () {\n      return cypress.start(['--config=test=false', '--cwd=/foo/bar'])\n      .then(() => {\n        expect(errors.warning).to.be.calledWith('INVALID_CONFIG_OPTION')\n        expect(console.log).to.be.calledWithMatch('`test` is not a valid configuration option')\n        expect(console.log).to.be.calledWithMatch('https://on.cypress.io/configuration')\n      })\n    })\n\n    it('shows warning when multiple config are not valid', function () {\n      return cypress.start(['--config=test=false,foo=bar', '--cwd=/foo/bar'])\n      .then(() => {\n        expect(errors.warning).to.be.calledWith('INVALID_CONFIG_OPTION')\n        expect(console.log).to.be.calledWithMatch('`test` is not a valid configuration option')\n        expect(console.log).to.be.calledWithMatch('`foo` is not a valid configuration option')\n        expect(console.log).to.be.calledWithMatch('https://on.cypress.io/configuration')\n\n        snapshotConsoleLogs('INVALID_CONFIG_OPTION')\n      })\n    })\n\n    it('does not show warning if config is valid', function () {\n      return cypress.start(['--config=trashAssetsBeforeRuns=false'])\n      .then(() => {\n        expect(errors.warning).to.not.be.calledWith('INVALID_CONFIG_OPTION')\n      })\n    })\n  })\n\n  context('--get-key', () => {\n    it('writes out key and exits on success', function () {\n      return Promise.all([\n        user.set({ name: 'brian', authToken: 'auth-token-123' }),\n\n        ProjectBase.id(this.todosPath)\n        .then((id) => {\n          this.projectId = id\n        }),\n      ])\n      .then(() => {\n        sinon.stub(api, 'getProjectToken')\n        .withArgs(this.projectId, 'auth-token-123')\n        .resolves('new-key-123')\n\n        return cypress.start(['--get-key', `--project=${this.todosPath}`])\n      }).then(() => {\n        expect(console.log).to.be.calledWith('new-key-123')\n        this.expectExitWith(0)\n      })\n    })\n\n    it('logs error and exits when user isn\\'t logged in', function () {\n      return user.set({})\n      .then(() => {\n        return cypress.start(['--get-key', `--project=${this.todosPath}`])\n      }).then(() => {\n        this.expectExitWithErr('NOT_LOGGED_IN')\n      })\n    })\n\n    it('logs error and exits when project does not have an id', function () {\n      return user.set({ authToken: 'auth-token-123' })\n      .then(() => {\n        return cypress.start(['--get-key', `--project=${this.pristinePath}`])\n      }).then(() => {\n        this.expectExitWithErr('NO_PROJECT_ID', this.pristinePath)\n      })\n    })\n\n    it('logs error and exits when project could not be found at the path', function () {\n      return user.set({ authToken: 'auth-token-123' })\n      .then(() => {\n        return cypress.start(['--get-key', '--project=path/to/no/project'])\n      }).then(() => {\n        this.expectExitWithErr('NO_PROJECT_FOUND_AT_PROJECT_ROOT', 'path/to/no/project')\n      })\n    })\n\n    it('logs error and exits when project token cannot be fetched', function () {\n      return Promise.all([\n        user.set({ authToken: 'auth-token-123' }),\n\n        ProjectBase.id(this.todosPath)\n        .then((id) => {\n          this.projectId = id\n        }),\n      ])\n      .then(() => {\n        sinon.stub(api, 'getProjectToken')\n        .withArgs(this.projectId, 'auth-token-123')\n        .rejects(new Error())\n\n        return cypress.start(['--get-key', `--project=${this.todosPath}`])\n      }).then(() => {\n        this.expectExitWithErr('CANNOT_FETCH_PROJECT_TOKEN')\n      })\n    })\n  })\n\n  context('--new-key', () => {\n    it('writes out key and exits on success', function () {\n      return Promise.all([\n        user.set({ name: 'brian', authToken: 'auth-token-123' }),\n\n        ProjectBase.id(this.todosPath)\n        .then((id) => {\n          this.projectId = id\n        }),\n      ])\n      .then(() => {\n        sinon.stub(api, 'updateProjectToken')\n        .withArgs(this.projectId, 'auth-token-123')\n        .resolves('new-key-123')\n\n        return cypress.start(['--new-key', `--project=${this.todosPath}`])\n      }).then(() => {\n        expect(console.log).to.be.calledWith('new-key-123')\n        this.expectExitWith(0)\n      })\n    })\n\n    it('logs error and exits when user isn\\'t logged in', function () {\n      return user.set({})\n      .then(() => {\n        return cypress.start(['--new-key', `--project=${this.todosPath}`])\n      }).then(() => {\n        this.expectExitWithErr('NOT_LOGGED_IN')\n      })\n    })\n\n    it('logs error and exits when project does not have an id', function () {\n      return user.set({ authToken: 'auth-token-123' })\n      .then(() => {\n        return cypress.start(['--new-key', `--project=${this.pristinePath}`])\n      }).then(() => {\n        this.expectExitWithErr('NO_PROJECT_ID', this.pristinePath)\n      })\n    })\n\n    it('logs error and exits when project could not be found at the path', function () {\n      return user.set({ authToken: 'auth-token-123' })\n      .then(() => {\n        return cypress.start(['--new-key', '--project=path/to/no/project'])\n      }).then(() => {\n        this.expectExitWithErr('NO_PROJECT_FOUND_AT_PROJECT_ROOT', 'path/to/no/project')\n      })\n    })\n\n    it('logs error and exits when project token cannot be fetched', function () {\n      return Promise.all([\n        user.set({ authToken: 'auth-token-123' }),\n\n        ProjectBase.id(this.todosPath)\n        .then((id) => {\n          this.projectId = id\n        }),\n      ])\n      .then(() => {\n        sinon.stub(api, 'updateProjectToken')\n        .withArgs(this.projectId, 'auth-token-123')\n        .rejects(new Error())\n\n        return cypress.start(['--new-key', `--project=${this.todosPath}`])\n      }).then(() => {\n        this.expectExitWithErr('CANNOT_CREATE_PROJECT_TOKEN')\n      })\n    })\n  })\n\n  context('--run-project', () => {\n    beforeEach(() => {\n      sinon.stub(electron.app, 'on').withArgs('ready').yieldsAsync()\n      sinon.stub(runMode, 'waitForSocketConnection').resolves()\n      sinon.stub(runMode, 'listenForProjectEnd').resolves({ stats: { failures: 0 } })\n      sinon.stub(browsers, 'open')\n      sinon.stub(commitInfo, 'getRemoteOrigin').resolves('remoteOrigin')\n    })\n\n    it('runs project headlessly and exits with exit code 0', function () {\n      return cypress.start([`--run-project=${this.todosPath}`])\n      .then(() => {\n        expect(browsers.open).to.be.calledWithMatch(ELECTRON_BROWSER)\n        this.expectExitWith(0)\n      })\n    })\n\n    it('sets --headed false if --headless', function () {\n      sinon.spy(cypress, 'startInMode')\n\n      return cypress.start([`--run-project=${this.todosPath}`, '--headless'])\n      .then(() => {\n        expect(browsers.open).to.be.calledWithMatch(ELECTRON_BROWSER)\n        this.expectExitWith(0)\n\n        // check how --headless option sets --headed\n        expect(cypress.startInMode).to.be.calledOnce\n        expect(cypress.startInMode).to.be.calledWith('run')\n        const startInModeOptions = cypress.startInMode.firstCall.args[1]\n\n        expect(startInModeOptions).to.include({\n          headless: true,\n          headed: false,\n        })\n      })\n    })\n\n    it('throws an error if both --headed and --headless are true', function () {\n      // error is thrown synchronously\n      expect(() => cypress.start([`--run-project=${this.todosPath}`, '--headless', '--headed']))\n      .to.throw('Impossible options: both headless and headed are true')\n    })\n\n    describe('strips --', () => {\n      beforeEach(() => {\n        sinon.spy(argsUtil, 'toObject')\n      })\n\n      it('strips leading', function () {\n        return cypress.start(['--', `--run-project=${this.todosPath}`])\n        .then(() => {\n          expect(argsUtil.toObject).to.have.been.calledWith([`--run-project=${this.todosPath}`])\n          expect(browsers.open).to.be.calledWithMatch(ELECTRON_BROWSER)\n          this.expectExitWith(0)\n        })\n      })\n\n      it('strips in the middle', function () {\n        return cypress.start([`--run-project=${this.todosPath}`, '--', '--browser=electron'])\n        .then(() => {\n          expect(argsUtil.toObject).to.have.been.calledWith([`--run-project=${this.todosPath}`, '--browser=electron'])\n          expect(browsers.open).to.be.calledWithMatch(ELECTRON_BROWSER)\n          this.expectExitWith(0)\n        })\n      })\n    })\n\n    it('runs project headlessly and exits with exit code 10', function () {\n      sinon.stub(runMode, 'runSpecs').resolves({ totalFailed: 10 })\n\n      return cypress.start([`--run-project=${this.todosPath}`])\n      .then(() => {\n        this.expectExitWith(10)\n      })\n    })\n\n    it('does not generate a project id even if missing one', function () {\n      sinon.stub(api, 'createProject')\n\n      return user.set({ authToken: 'auth-token-123' })\n      .then(() => {\n        return cypress.start([`--run-project=${this.noScaffolding}`])\n      }).then(() => {\n        this.expectExitWith(0)\n      }).then(() => {\n        expect(api.createProject).not.to.be.called\n\n        return (new ProjectBase(this.noScaffolding)).getProjectId()\n        .then(() => {\n          throw new Error('should have caught error but did not')\n        }).catch((err) => {\n          expect(err.type).to.eq('NO_PROJECT_ID')\n        })\n      })\n    })\n\n    it('does not add project to the global cache', function () {\n      return cache.getProjectRoots()\n      .then((projects) => {\n        // no projects in the cache\n        expect(projects.length).to.eq(0)\n\n        return cypress.start([`--run-project=${this.todosPath}`])\n      }).then(() => {\n        return cache.getProjectRoots()\n      }).then((projects) => {\n        // still not projects\n        expect(projects.length).to.eq(0)\n      })\n    })\n\n    it('runs project by relative spec and exits with status 0', function () {\n      const relativePath = path.relative(cwd(), this.todosPath)\n\n      return cypress.start([\n        `--run-project=${this.todosPath}`,\n        `--spec=${relativePath}/tests/test2.coffee`,\n      ])\n      .then(() => {\n        expect(browsers.open).to.be.calledWithMatch(ELECTRON_BROWSER, {\n          url: 'http://localhost:8888/__/#/tests/integration/test2.coffee',\n        })\n\n        this.expectExitWith(0)\n      })\n    })\n\n    it('runs project by specific spec with default configuration', function () {\n      return cypress.start([`--run-project=${this.idsPath}`, `--spec=${this.idsPath}/cypress/integration/bar.js`, '--config', 'port=2020'])\n      .then(() => {\n        expect(browsers.open).to.be.calledWithMatch(ELECTRON_BROWSER, { url: 'http://localhost:2020/__/#/tests/integration/bar.js' })\n        this.expectExitWith(0)\n      })\n    })\n\n    it('runs project by specific absolute spec and exits with status 0', function () {\n      return cypress.start([`--run-project=${this.todosPath}`, `--spec=${this.todosPath}/tests/test2.coffee`])\n      .then(() => {\n        expect(browsers.open).to.be.calledWithMatch(ELECTRON_BROWSER, { url: 'http://localhost:8888/__/#/tests/integration/test2.coffee' })\n        this.expectExitWith(0)\n      })\n    })\n\n    it('runs project by limiting spec files via config.testFiles string glob pattern', function () {\n      return cypress.start([`--run-project=${this.todosPath}`, `--config=testFiles=${this.todosPath}/tests/test2.coffee`])\n      .then(() => {\n        expect(browsers.open).to.be.calledWithMatch(ELECTRON_BROWSER, { url: 'http://localhost:8888/__/#/tests/integration/test2.coffee' })\n        this.expectExitWith(0)\n      })\n    })\n\n    it('runs project by limiting spec files via config.testFiles as a JSON array of string glob patterns', function () {\n      return cypress.start([`--run-project=${this.todosPath}`, '--config=testFiles=[\"**/test2.coffee\",\"**/test1.js\"]'])\n      .then(() => {\n        expect(browsers.open).to.be.calledWithMatch(ELECTRON_BROWSER, { url: 'http://localhost:8888/__/#/tests/integration/test2.coffee' })\n      }).then(() => {\n        expect(browsers.open).to.be.calledWithMatch(ELECTRON_BROWSER, { url: 'http://localhost:8888/__/#/tests/integration/test1.js' })\n        this.expectExitWith(0)\n      })\n    })\n\n    it('does not watch settings or plugins in run mode', function () {\n      const watch = sinon.spy(Watchers.prototype, 'watch')\n      const watchTree = sinon.spy(Watchers.prototype, 'watchTree')\n\n      return cypress.start([`--run-project=${this.pluginConfig}`])\n      .then(() => {\n        expect(watchTree).not.to.be.called\n        expect(watch).not.to.be.called\n        this.expectExitWith(0)\n      })\n    })\n\n    it('scaffolds out integration and example specs if they do not exist when not runMode', function () {\n      return config.get(this.pristinePath)\n      .then((cfg) => {\n        return fs.statAsync(cfg.integrationFolder)\n        .then(() => {\n          throw new Error('integrationFolder should not exist!')\n        }).catch(() => {\n          return cypress.start([`--run-project=${this.pristinePath}`, '--no-run-mode'])\n        }).then(() => {\n          return fs.statAsync(cfg.integrationFolder)\n        }).then(() => {\n          return Promise.join(\n            fs.statAsync(path.join(cfg.integrationFolder, 'examples', 'actions.spec.js')),\n            fs.statAsync(path.join(cfg.integrationFolder, 'examples', 'files.spec.js')),\n            fs.statAsync(path.join(cfg.integrationFolder, 'examples', 'viewport.spec.js')),\n          )\n        })\n      })\n    })\n\n    it('does not scaffold when headless and exits with error when no existing project', function () {\n      const ensureDoesNotExist = function (inspection, index) {\n        if (!inspection.isRejected()) {\n          throw new Error(`File or folder was scaffolded at index: ${index}`)\n        }\n\n        expect(inspection.reason()).to.have.property('code', 'ENOENT')\n      }\n\n      return Promise.all([\n        fs.statAsync(path.join(this.pristinePath, 'cypress')).reflect(),\n        fs.statAsync(path.join(this.pristinePath, 'cypress.json')).reflect(),\n      ])\n      .each(ensureDoesNotExist)\n      .then(() => {\n        return cypress.start([`--run-project=${this.pristinePath}`])\n      }).then(() => {\n        return Promise.all([\n          fs.statAsync(path.join(this.pristinePath, 'cypress')).reflect(),\n          fs.statAsync(path.join(this.pristinePath, 'cypress.json')).reflect(),\n        ])\n      }).each(ensureDoesNotExist)\n      .then(() => {\n        this.expectExitWithErr('CONFIG_FILE_NOT_FOUND', this.pristinePath)\n      })\n    })\n\n    it('does not scaffold integration or example specs when runMode', function () {\n      return settings.write(this.pristinePath, {})\n      .then(() => {\n        return cypress.start([`--run-project=${this.pristinePath}`])\n      }).then(() => {\n        return fs.statAsync(path.join(this.pristinePath, 'cypress', 'integration'))\n      }).then(() => {\n        throw new Error('integration folder should not exist!')\n      }).catch({ code: 'ENOENT' }, () => {})\n    })\n\n    it('scaffolds out fixtures + files if they do not exist', function () {\n      return config.get(this.pristinePath)\n      .then((cfg) => {\n        return fs.statAsync(cfg.fixturesFolder)\n        .then(() => {\n          throw new Error('fixturesFolder should not exist!')\n        }).catch(() => {\n          return cypress.start([`--run-project=${this.pristinePath}`, '--no-run-mode'])\n        }).then(() => {\n          return fs.statAsync(cfg.fixturesFolder)\n        }).then(() => {\n          return fs.statAsync(path.join(cfg.fixturesFolder, 'example.json'))\n        })\n      })\n    })\n\n    it('scaffolds out support + files if they do not exist', function () {\n      const supportFolder = path.join(this.pristinePath, 'cypress/support')\n\n      return config.get(this.pristinePath)\n      .then(() => {\n        return fs.statAsync(supportFolder)\n        .then(() => {\n          throw new Error('supportFolder should not exist!')\n        }).catch({ code: 'ENOENT' }, () => {\n          return cypress.start([`--run-project=${this.pristinePath}`, '--no-run-mode'])\n        }).then(() => {\n          return fs.statAsync(supportFolder)\n        }).then(() => {\n          return fs.statAsync(path.join(supportFolder, 'index.js'))\n        }).then(() => {\n          return fs.statAsync(path.join(supportFolder, 'commands.js'))\n        })\n      })\n    })\n\n    it('removes fixtures when they exist and fixturesFolder is false', function (done) {\n      config.get(this.idsPath)\n      .then((cfg) => {\n        this.cfg = cfg\n\n        return fs.statAsync(this.cfg.fixturesFolder)\n      }).then(() => {\n        return settings.read(this.idsPath)\n      }).then((json) => {\n        json.fixturesFolder = false\n\n        return settings.write(this.idsPath, json)\n      }).then(() => {\n        return cypress.start([`--run-project=${this.idsPath}`])\n      }).then(() => {\n        return fs.statAsync(this.cfg.fixturesFolder)\n        .then(() => {\n          throw new Error('fixturesFolder should not exist!')\n        }).catch(() => {\n          return done()\n        })\n      })\n    })\n\n    it('runs project headlessly and displays gui', function () {\n      return cypress.start([`--run-project=${this.todosPath}`, '--headed'])\n      .then(() => {\n        expect(browsers.open).to.be.calledWithMatch(ELECTRON_BROWSER, {\n          proxyServer: 'http://localhost:8888',\n          show: true,\n        })\n\n        this.expectExitWith(0)\n      })\n    })\n\n    it('turns on reporting', function () {\n      sinon.spy(Reporter, 'create')\n\n      return cypress.start([`--run-project=${this.todosPath}`])\n      .then(() => {\n        expect(Reporter.create).to.be.calledWith('spec')\n        this.expectExitWith(0)\n      })\n    })\n\n    it('can change the reporter to nyan', function () {\n      sinon.spy(Reporter, 'create')\n\n      return cypress.start([`--run-project=${this.todosPath}`, '--reporter=nyan'])\n      .then(() => {\n        expect(Reporter.create).to.be.calledWith('nyan')\n        this.expectExitWith(0)\n      })\n    })\n\n    it('can change the reporter with cypress.json', function () {\n      sinon.spy(Reporter, 'create')\n\n      return config.get(this.idsPath)\n      .then((cfg) => {\n        this.cfg = cfg\n\n        return settings.read(this.idsPath)\n      }).then((json) => {\n        json.reporter = 'dot'\n\n        return settings.write(this.idsPath, json)\n      }).then(() => {\n        return cypress.start([`--run-project=${this.idsPath}`])\n      }).then(() => {\n        expect(Reporter.create).to.be.calledWith('dot')\n        this.expectExitWith(0)\n      })\n    })\n\n    it('runs tests even when user isn\\'t logged in', function () {\n      return user.set({})\n      .then(() => {\n        return cypress.start([`--run-project=${this.todosPath}`])\n      }).then(() => {\n        this.expectExitWith(0)\n      })\n    })\n\n    it('logs warning when projectId and key but no record option', function () {\n      return cypress.start([`--run-project=${this.todosPath}`, '--key=asdf'])\n      .then(() => {\n        expect(errors.warning).to.be.calledWith('PROJECT_ID_AND_KEY_BUT_MISSING_RECORD_OPTION', 'abc123')\n        expect(console.log).to.be.calledWithMatch('You also provided your Record Key, but you did not pass the --record flag.')\n        expect(console.log).to.be.calledWithMatch('cypress run --record')\n        expect(console.log).to.be.calledWithMatch('https://on.cypress.io/recording-project-runs')\n      })\n    })\n\n    it('logs warning when removing old browser profiles fails', function () {\n      const err = new Error('foo')\n\n      sinon.stub(browsers, 'removeOldProfiles').rejects(err)\n\n      return cypress.start([`--run-project=${this.todosPath}`])\n      .then(() => {\n        expect(errors.warning).to.be.calledWith('CANNOT_REMOVE_OLD_BROWSER_PROFILES', err.stack)\n        expect(console.log).to.be.calledWithMatch('Warning: We failed to remove old browser profiles from previous runs.')\n        expect(console.log).to.be.calledWithMatch(err.message)\n      })\n    })\n\n    it('does not log warning when no projectId', function () {\n      return cypress.start([`--run-project=${this.pristinePath}`, '--key=asdf'])\n      .then(() => {\n        expect(errors.warning).not.to.be.calledWith('PROJECT_ID_AND_KEY_BUT_MISSING_RECORD_OPTION', 'abc123')\n        expect(console.log).not.to.be.calledWithMatch('cypress run --key <record_key>')\n      })\n    })\n\n    it('does not log warning when projectId but --record false', function () {\n      return cypress.start([`--run-project=${this.todosPath}`, '--key=asdf', '--record=false'])\n      .then(() => {\n        expect(errors.warning).not.to.be.calledWith('PROJECT_ID_AND_KEY_BUT_MISSING_RECORD_OPTION', 'abc123')\n        expect(console.log).not.to.be.calledWithMatch('cypress run --key <record_key>')\n      })\n    })\n\n    it('logs error when supportFile doesn\\'t exist', function () {\n      return settings.write(this.idsPath, { supportFile: '/does/not/exist' })\n      .then(() => {\n        return cypress.start([`--run-project=${this.idsPath}`])\n      }).then(() => {\n        this.expectExitWithErr('SUPPORT_FILE_NOT_FOUND', 'Your `supportFile` is set to `/does/not/exist`,')\n      })\n    })\n\n    it('logs error when browser cannot be found', function () {\n      browsers.open.restore()\n\n      return cypress.start([`--run-project=${this.idsPath}`, '--browser=foo'])\n      .then(() => {\n        this.expectExitWithErr('BROWSER_NOT_FOUND_BY_NAME')\n\n        // get all the error args\n        const argsSet = errors.log.args\n\n        const found1 = _.find(argsSet, (args) => {\n          return _.find(args, (arg) => {\n            return arg.message && arg.message.includes(\n              'Browser: \\'foo\\' was not found on your system or is not supported by Cypress.',\n            )\n          })\n        })\n\n        expect(found1, 'foo should not be found').to.be.ok\n\n        const found2 = _.find(argsSet, (args) => {\n          return _.find(args, (arg) => {\n            return arg.message && arg.message.includes(\n              'Cypress supports the following browsers:',\n            )\n          })\n        })\n\n        expect(found2, 'supported browsers should be listed').to.be.ok\n\n        const found3 = _.find(argsSet, (args) => {\n          return _.find(args, (arg) => {\n            return arg.message && arg.message.includes(\n              'Available browsers found on your system are:\\n- chrome\\n- chromium\\n- chrome:canary\\n- electron',\n            )\n          })\n        })\n\n        expect(found3, 'browser names should be listed').to.be.ok\n      })\n    })\n\n    describe('no specs found', function () {\n      it('logs error and exits when spec file was specified and does not exist', function () {\n        return cypress.start([`--run-project=${this.todosPath}`, '--spec=path/to/spec'])\n        .then(() => {\n          // includes the search spec\n          this.expectExitWithErr('NO_SPECS_FOUND', 'path/to/spec')\n          this.expectExitWithErr('NO_SPECS_FOUND', 'We searched for any files matching this glob pattern:')\n          // includes the project path\n          this.expectExitWithErr('NO_SPECS_FOUND', this.todosPath)\n        })\n      })\n\n      it('logs error and exits when spec absolute file was specified and does not exist', function () {\n        return cypress.start([\n          `--run-project=${this.todosPath}`,\n          `--spec=${this.todosPath}/tests/path/to/spec`,\n        ])\n        .then(() => {\n          // includes path to the spec\n          this.expectExitWithErr('NO_SPECS_FOUND', 'tests/path/to/spec')\n          // includes folder name\n          this.expectExitWithErr('NO_SPECS_FOUND', this.todosPath)\n        })\n      })\n\n      it('logs error and exits when no specs were found at all', function () {\n        return cypress.start([\n          `--run-project=${this.todosPath}`,\n          '--config=integrationFolder=cypress/specs',\n        ])\n        .then(() => {\n          this.expectExitWithErr('NO_SPECS_FOUND', 'We searched for any files inside of this folder:')\n          this.expectExitWithErr('NO_SPECS_FOUND', 'cypress/specs')\n        })\n      })\n    })\n\n    it('logs error and exits when project has cypress.json syntax error', function () {\n      return fs.writeFileAsync(`${this.todosPath}/cypress.json`, '{\\'foo\\': \\'bar}')\n      .then(() => {\n        return cypress.start([`--run-project=${this.todosPath}`])\n      }).then(() => {\n        this.expectExitWithErr('ERROR_READING_FILE', this.todosPath)\n      })\n    })\n\n    it('logs error and exits when project has cypress.env.json syntax error', function () {\n      return fs.writeFileAsync(`${this.todosPath}/cypress.env.json`, '{\\'foo\\': \\'bar}')\n      .then(() => {\n        return cypress.start([`--run-project=${this.todosPath}`])\n      }).then(() => {\n        this.expectExitWithErr('ERROR_READING_FILE', this.todosPath)\n      })\n    })\n\n    it('logs error and exits when project has invalid cypress.json values', function () {\n      return settings.write(this.todosPath, { baseUrl: 'localhost:9999' })\n      .then(() => {\n        return cypress.start([`--run-project=${this.todosPath}`])\n      }).then(() => {\n        this.expectExitWithErr('SETTINGS_VALIDATION_ERROR', 'cypress.json')\n      })\n    })\n\n    it('logs error and exits when project has invalid config values from the CLI', function () {\n      return cypress.start([\n        `--run-project=${this.todosPath}`,\n        '--config=baseUrl=localhost:9999',\n      ])\n      .then(() => {\n        this.expectExitWithErr('CONFIG_VALIDATION_ERROR', 'localhost:9999')\n        this.expectExitWithErr('CONFIG_VALIDATION_ERROR', 'We found an invalid configuration value')\n      })\n    })\n\n    it('logs error and exits when project has invalid config values from env vars', function () {\n      process.env.CYPRESS_BASE_URL = 'localhost:9999'\n\n      return cypress.start([`--run-project=${this.todosPath}`])\n      .then(() => {\n        this.expectExitWithErr('CONFIG_VALIDATION_ERROR', 'localhost:9999')\n        this.expectExitWithErr('CONFIG_VALIDATION_ERROR', 'We found an invalid configuration value')\n      })\n    })\n\n    const renamedConfigs = [\n      {\n        old: 'blacklistHosts',\n        new: 'blockHosts',\n      },\n    ]\n\n    renamedConfigs.forEach(function (config) {\n      it(`logs error and exits when using an old configuration option: ${config.old}`, function () {\n        return cypress.start([\n          `--run-project=${this.todosPath}`,\n          `--config=${config.old}=''`,\n        ])\n        .then(() => {\n          this.expectExitWithErr('RENAMED_CONFIG_OPTION', config.old)\n          this.expectExitWithErr('RENAMED_CONFIG_OPTION', config.new)\n        })\n      })\n    })\n\n    // TODO: make sure we have integration tests around this\n    // for headed projects!\n    // also make sure we test the rest of the integration functionality\n    // for headed errors! <-- not unit tests, but integration tests!\n    it('logs error and exits when project folder has read permissions only and cannot write cypress.json', function () {\n      // test disabled if running as root - root can write all things at all times\n      if (process.geteuid() === 0) {\n        return\n      }\n\n      const permissionsPath = path.resolve('./permissions')\n\n      const cypressJson = path.join(permissionsPath, 'cypress.json')\n\n      return fs.outputFileAsync(cypressJson, '{}')\n      .then(() => {\n        // read only\n        return fs.chmodAsync(permissionsPath, '555')\n      }).then(() => {\n        return cypress.start([`--run-project=${permissionsPath}`])\n      }).then(() => {\n        return fs.chmodAsync(permissionsPath, '777')\n      }).then(() => {\n        return fs.removeAsync(permissionsPath)\n      }).then(() => {\n        this.expectExitWithErr('ERROR_READING_FILE', path.join(permissionsPath, 'cypress.json'))\n      })\n    })\n\n    it('logs error and exits when reporter does not exist', function () {\n      return cypress.start([`--run-project=${this.todosPath}`, '--reporter', 'foobarbaz'])\n      .then(() => {\n        this.expectExitWithErr('INVALID_REPORTER_NAME', 'foobarbaz')\n      })\n    })\n\n    describe('state', () => {\n      beforeEach(function () {\n        return appData.remove()\n        .then(() => {\n          return savedState.formStatePath(this.todosPath)\n        }).then((statePathStart) => {\n          this.statePath = appData.projectsPath(statePathStart)\n        })\n      })\n\n      it('does not save project state', function () {\n        return cypress.start([`--run-project=${this.todosPath}`, `--spec=${this.todosPath}/tests/test2.coffee`])\n        .then(() => {\n          this.expectExitWith(0)\n\n          // this should not save the project's state\n          // because its a noop in 'cypress run' mode\n          return openProject.getProject().saveState()\n        }).then(() => {\n          return fs.statAsync(this.statePath)\n          .then(() => {\n            throw new Error(`saved state should not exist but it did here: ${this.statePath}`)\n          }).catch({ code: 'ENOENT' }, () => {})\n        })\n      })\n    })\n\n    describe('morgan', () => {\n      it('sets morgan to false', function () {\n        return cypress.start([`--run-project=${this.todosPath}`])\n        .then(() => {\n          expect(openProject.getProject().cfg.morgan).to.be.false\n          this.expectExitWith(0)\n        })\n      })\n    })\n\n    describe('config overrides', () => {\n      it('can override default values', function () {\n        return cypress.start([`--run-project=${this.todosPath}`, '--config=requestTimeout=1234,videoCompression=false'])\n        .then(() => {\n          const { cfg } = openProject.getProject()\n\n          expect(cfg.videoCompression).to.be.false\n          expect(cfg.requestTimeout).to.eq(1234)\n\n          expect(cfg.resolved.videoCompression).to.deep.eq({\n            value: false,\n            from: 'cli',\n          })\n\n          expect(cfg.resolved.requestTimeout).to.deep.eq({\n            value: 1234,\n            from: 'cli',\n          })\n\n          this.expectExitWith(0)\n        })\n      })\n\n      it('can override values in plugins', function () {\n        plugins.init.restore()\n\n        return cypress.start([\n          `--run-project=${this.pluginConfig}`, '--config=requestTimeout=1234,videoCompression=false',\n          '--env=foo=foo,bar=bar',\n        ])\n        .then(() => {\n          const { cfg } = openProject.getProject()\n\n          expect(cfg.videoCompression).to.eq(20)\n          expect(cfg.defaultCommandTimeout).to.eq(500)\n          expect(cfg.env).to.deep.eq({\n            foo: 'bar',\n            bar: 'bar',\n          })\n\n          expect(cfg.resolved.videoCompression).to.deep.eq({\n            value: 20,\n            from: 'plugin',\n          })\n\n          expect(cfg.resolved.requestTimeout).to.deep.eq({\n            value: 1234,\n            from: 'cli',\n          })\n\n          expect(cfg.resolved.env.foo).to.deep.eq({\n            value: 'bar',\n            from: 'plugin',\n          })\n\n          expect(cfg.resolved.env.bar).to.deep.eq({\n            value: 'bar',\n            from: 'cli',\n          })\n\n          this.expectExitWith(0)\n        })\n      })\n    })\n\n    describe('plugins', () => {\n      beforeEach(() => {\n        plugins.init.restore()\n        browsers.open.restore()\n\n        const ee = new EE()\n\n        ee.kill = () => {\n          // ughh, would be nice to test logic inside the launcher\n          // that cleans up after the browser exit\n          // like calling client.close() if available to let the\n          // browser free any resources\n          return ee.emit('exit')\n        }\n\n        ee.destroy = () => {\n          return ee.emit('closed')\n        }\n\n        ee.isDestroyed = () => {\n          return false\n        }\n\n        ee.loadURL = () => {}\n        ee.focusOnWebView = () => {}\n        ee.webContents = {\n          debugger: {\n            on: sinon.stub(),\n            attach: sinon.stub(),\n            sendCommand: sinon.stub().resolves(),\n          },\n          getOSProcessId: sinon.stub(),\n          setUserAgent: sinon.stub(),\n          session: {\n            clearCache: sinon.stub().resolves(),\n            setProxy: sinon.stub().resolves(),\n            setUserAgent: sinon.stub(),\n            on: sinon.stub(),\n            removeListener: sinon.stub(),\n          },\n        }\n\n        ee.maximize = sinon.stub\n        ee.setSize = sinon.stub\n\n        sinon.stub(launch, 'launch').resolves(ee)\n        sinon.stub(Windows, 'create').returns(ee)\n      })\n\n      context('before:browser:launch', () => {\n        it('chrome', function () {\n          // during testing, do not try to connect to the remote interface or\n          // use the Chrome remote interface client\n          const criClient = {\n            ensureMinimumProtocolVersion: sinon.stub().resolves(),\n            close: sinon.stub().resolves(),\n            on: sinon.stub(),\n            send: sinon.stub(),\n          }\n\n          sinon.stub(chromeBrowser, '_writeExtension').resolves()\n\n          sinon.stub(chromeBrowser, '_connectToChromeRemoteInterface').resolves(criClient)\n          // the \"returns(resolves)\" stub is due to curried method\n          // it accepts URL to visit and then waits for actual CRI client reference\n          // and only then navigates to that URL\n          sinon.stub(chromeBrowser, '_navigateUsingCRI').resolves()\n          sinon.stub(chromeBrowser, '_handleDownloads').resolves()\n\n          sinon.stub(chromeBrowser, '_setAutomation').returns()\n\n          return cypress.start([\n            `--run-project=${this.pluginBrowser}`,\n            '--browser=chrome',\n          ])\n          .then(() => {\n            const { args } = launch.launch.firstCall\n\n            // when we work with the browsers we set a few extra flags\n            const chrome = _.find(TYPICAL_BROWSERS, { name: 'chrome' })\n            const launchedChrome = R.merge(chrome, {\n              isHeadless: false,\n              isHeaded: true,\n            })\n\n            expect(args[0], 'found and used Chrome').to.deep.eq(launchedChrome)\n\n            const browserArgs = args[2]\n\n            expect(browserArgs.slice(0, 4), 'first 4 custom launch arguments to Chrome').to.deep.eq([\n              'chrome', 'foo', 'bar', 'baz',\n            ])\n\n            this.expectExitWith(0)\n\n            expect(chromeBrowser._navigateUsingCRI).to.have.been.calledOnce\n            expect(chromeBrowser._setAutomation).to.have.been.calledOnce\n\n            expect(chromeBrowser._connectToChromeRemoteInterface).to.have.been.calledOnce\n          })\n        })\n\n        it('electron', function () {\n          const writeVideoFrame = sinon.stub()\n\n          videoCapture.start.returns({ writeVideoFrame })\n\n          return cypress.start([\n            `--run-project=${this.pluginBrowser}`,\n            '--browser=electron',\n          ])\n          .then(() => {\n            expect(Windows.create).to.be.calledWithMatch(this.pluginBrowser, {\n              browser: 'electron',\n              foo: 'bar',\n              onNewWindow: sinon.match.func,\n              onScreencastFrame: sinon.match.func,\n            })\n\n            this.expectExitWith(0)\n          })\n        })\n      })\n    })\n\n    describe('--port', () => {\n      beforeEach(() => {\n        return runMode.listenForProjectEnd.resolves({ stats: { failures: 0 } })\n      })\n\n      it('can change the default port to 5544', function () {\n        const listen = sinon.spy(http.Server.prototype, 'listen')\n        const open = sinon.spy(ServerE2E.prototype, 'open')\n\n        return cypress.start([`--run-project=${this.todosPath}`, '--port=5544'])\n        .then(() => {\n          expect(openProject.getProject().cfg.port).to.eq(5544)\n          expect(listen).to.be.calledWith(5544)\n          expect(open).to.be.calledWithMatch({ port: 5544 })\n          this.expectExitWith(0)\n        })\n      })\n\n      // TODO: handle PORT_IN_USE short integration test\n      it('logs error and exits when port is in use', function () {\n        let server = http.createServer()\n\n        server = Promise.promisifyAll(server)\n\n        return server.listenAsync(5544, '127.0.0.1')\n        .then(() => {\n          return cypress.start([`--run-project=${this.todosPath}`, '--port=5544'])\n        }).then(() => {\n          this.expectExitWithErr('PORT_IN_USE_LONG', '5544')\n        })\n      })\n    })\n\n    describe('--env', () => {\n      beforeEach(() => {\n        process.env = _.omit(process.env, 'CYPRESS_DEBUG')\n\n        return runMode.listenForProjectEnd.resolves({ stats: { failures: 0 } })\n      })\n\n      it('can set specific environment variables', function () {\n        return cypress.start([\n          `--run-project=${this.todosPath}`,\n          '--video=false',\n          '--env',\n          'version=0.12.1,foo=bar,host=http://localhost:8888,baz=quux=dolor',\n        ])\n        .then(() => {\n          expect(openProject.getProject().cfg.env).to.deep.eq({\n            version: '0.12.1',\n            foo: 'bar',\n            host: 'http://localhost:8888',\n            baz: 'quux=dolor',\n          })\n\n          this.expectExitWith(0)\n        })\n      })\n\n      it('parses environment variables with empty values', function () {\n        return cypress.start([\n          `--run-project=${this.todosPath}`,\n          '--video=false',\n          '--env=FOO=,BAR=,BAZ=ipsum',\n        ])\n        .then(() => {\n          expect(openProject.getProject().cfg.env).to.deep.eq({\n            FOO: '',\n            BAR: '',\n            BAZ: 'ipsum',\n          })\n\n          this.expectExitWith(0)\n        })\n      })\n    })\n\n    describe('--config-file', () => {\n      it('false does not require cypress.json to run', function () {\n        return fs.statAsync(path.join(this.pristinePath, 'cypress.json'))\n        .then(() => {\n          throw new Error('cypress.json should not exist')\n        }).catch({ code: 'ENOENT' }, () => {\n          return cypress.start([\n            `--run-project=${this.pristinePath}`,\n            '--no-run-mode',\n            '--config-file',\n            'false',\n          ]).then(() => {\n            this.expectExitWith(0)\n          })\n        })\n      })\n\n      it('with a custom config file fails when it doesn\\'t exist', function () {\n        this.filename = 'abcdefgh.test.json'\n\n        return fs.statAsync(path.join(this.todosPath, this.filename))\n        .then(() => {\n          throw new Error(`${this.filename} should not exist`)\n        }).catch({ code: 'ENOENT' }, () => {\n          return cypress.start([\n            `--run-project=${this.todosPath}`,\n            '--no-run-mode',\n            '--config-file',\n            this.filename,\n          ]).then(() => {\n            this.expectExitWithErr('CONFIG_FILE_NOT_FOUND', this.filename, this.todosPath)\n          })\n        })\n      })\n    })\n  })\n\n  // most record mode logic is covered in e2e tests.\n  // we only need to cover the edge cases / warnings\n  context('--record', () => {\n    beforeEach(function () {\n      sinon.stub(api, 'createRun').resolves()\n      sinon.stub(electron.app, 'on').withArgs('ready').yieldsAsync()\n      sinon.stub(browsers, 'open')\n      sinon.stub(runMode, 'waitForSocketConnection').resolves()\n      sinon.stub(runMode, 'waitForTestsToFinishRunning').resolves({\n        stats: {\n          tests: 1,\n          passes: 2,\n          failures: 3,\n          pending: 4,\n          skipped: 5,\n          wallClockDuration: 6,\n        },\n        tests: [],\n        hooks: [],\n        video: 'path/to/video',\n        shouldUploadVideo: true,\n        screenshots: [],\n        config: {},\n        spec: {},\n      })\n\n      return Promise.all([\n        // make sure we have no user object\n        user.set({}),\n\n        ProjectBase.id(this.todosPath)\n        .then((id) => {\n          this.projectId = id\n        }),\n      ])\n    })\n\n    it('uses process.env.CYPRESS_PROJECT_ID', function () {\n      sinon.stub(env, 'get').withArgs('CYPRESS_PROJECT_ID').returns(this.projectId)\n\n      return cypress.start([\n        '--cwd=/foo/bar',\n        `--run-project=${this.noScaffolding}`,\n        '--record',\n        '--key=token-123',\n      ])\n      .then(() => {\n        expect(api.createRun).to.be.calledWithMatch({ projectId: this.projectId })\n        expect(errors.warning).not.to.be.called\n        this.expectExitWith(3)\n      })\n    })\n\n    it('uses process.env.CYPRESS_RECORD_KEY', function () {\n      sinon.stub(env, 'get')\n      .withArgs('CYPRESS_PROJECT_ID').returns('foo-project-123')\n      .withArgs('CYPRESS_RECORD_KEY').returns('token')\n\n      return cypress.start([\n        '--cwd=/foo/bar',\n        `--run-project=${this.noScaffolding}`,\n        '--record',\n      ])\n      .then(() => {\n        expect(api.createRun).to.be.calledWithMatch({\n          projectId: 'foo-project-123',\n          recordKey: 'token',\n        })\n\n        expect(errors.warning).not.to.be.called\n        this.expectExitWith(3)\n      })\n    })\n\n    it('errors and exits when using --group but ciBuildId could not be generated', function () {\n      sinon.stub(ciProvider, 'provider').returns(null)\n\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--record',\n        '--key=token-123',\n        '--group=e2e-tests',\n      ])\n      .then(() => {\n        this.expectExitWithErr('INDETERMINATE_CI_BUILD_ID')\n\n        return snapshotConsoleLogs('INDETERMINATE_CI_BUILD_ID-group 1')\n      })\n    })\n\n    it('errors and exits when using --parallel but ciBuildId could not be generated', function () {\n      sinon.stub(ciProvider, 'provider').returns(null)\n\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--record',\n        '--key=token-123',\n        '--parallel',\n      ])\n      .then(() => {\n        this.expectExitWithErr('INDETERMINATE_CI_BUILD_ID')\n\n        return snapshotConsoleLogs('INDETERMINATE_CI_BUILD_ID-parallel 1')\n      })\n    })\n\n    it('errors and exits when using --parallel and --group but ciBuildId could not be generated', function () {\n      sinon.stub(ciProvider, 'provider').returns(null)\n\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--record',\n        '--key=token-123',\n        '--group=e2e-tests-chrome',\n        '--parallel',\n      ])\n      .then(() => {\n        this.expectExitWithErr('INDETERMINATE_CI_BUILD_ID')\n\n        return snapshotConsoleLogs('INDETERMINATE_CI_BUILD_ID-parallel-group 1')\n      })\n    })\n\n    it('errors and exits when using --ci-build-id with no group or parallelization', function () {\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--record',\n        '--key=token-123',\n        '--ci-build-id=ciBuildId123',\n      ])\n      .then(() => {\n        this.expectExitWithErr('INCORRECT_CI_BUILD_ID_USAGE')\n\n        return snapshotConsoleLogs('INCORRECT_CI_BUILD_ID_USAGE 1')\n      })\n    })\n\n    it('errors and exits when using --ci-build-id without recording', function () {\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--ci-build-id=ciBuildId123',\n      ])\n      .then(() => {\n        this.expectExitWithErr('RECORD_PARAMS_WITHOUT_RECORDING')\n\n        return snapshotConsoleLogs('RECORD_PARAMS_WITHOUT_RECORDING-ciBuildId 1')\n      })\n    })\n\n    it('errors and exits when using --group without recording', function () {\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--group=e2e-tests',\n      ])\n      .then(() => {\n        this.expectExitWithErr('RECORD_PARAMS_WITHOUT_RECORDING')\n\n        return snapshotConsoleLogs('RECORD_PARAMS_WITHOUT_RECORDING-group 1')\n      })\n    })\n\n    it('errors and exits when using --parallel without recording', function () {\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--parallel',\n      ])\n      .then(() => {\n        this.expectExitWithErr('RECORD_PARAMS_WITHOUT_RECORDING')\n\n        return snapshotConsoleLogs('RECORD_PARAMS_WITHOUT_RECORDING-parallel 1')\n      })\n    })\n\n    it('errors and exits when using --tag without recording', function () {\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--tag=nightly',\n      ])\n      .then(() => {\n        this.expectExitWithErr('RECORD_PARAMS_WITHOUT_RECORDING')\n\n        return snapshotConsoleLogs('RECORD_PARAMS_WITHOUT_RECORDING-tag 1')\n      })\n    })\n\n    it('errors and exits when using --group and --parallel without recording', function () {\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--tag=nightly',\n        '--group=electron-smoke-tests',\n        '--parallel',\n      ])\n      .then(() => {\n        this.expectExitWithErr('RECORD_PARAMS_WITHOUT_RECORDING')\n\n        return snapshotConsoleLogs('RECORD_PARAMS_WITHOUT_RECORDING-group-parallel 1')\n      })\n    })\n\n    it('errors and exits when group name is not unique and explicitly passed ciBuildId', function () {\n      const err = new Error()\n\n      err.statusCode = 422\n      err.error = {\n        code: 'RUN_GROUP_NAME_NOT_UNIQUE',\n        payload: {\n          runUrl: 'https://dashboard.cypress.io/runs/12345',\n        },\n      }\n\n      api.createRun.rejects(err)\n\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--record',\n        '--key=token-123',\n        '--group=electron-smoke-tests',\n        '--ciBuildId=ciBuildId123',\n      ])\n      .then(() => {\n        this.expectExitWithErr('DASHBOARD_RUN_GROUP_NAME_NOT_UNIQUE')\n\n        return snapshotConsoleLogs('DASHBOARD_RUN_GROUP_NAME_NOT_UNIQUE 1')\n      })\n    })\n\n    it('errors and exits when parallel group params are different', function () {\n      sinon.stub(system, 'info').returns({\n        osName: 'darwin',\n        osVersion: 'v1',\n      })\n\n      sinon.stub(browsers, 'ensureAndGetByNameOrPath').resolves({\n        version: '59.1.2.3',\n        displayName: 'Electron',\n      })\n\n      const err = new Error()\n\n      err.statusCode = 422\n      err.error = {\n        code: 'PARALLEL_GROUP_PARAMS_MISMATCH',\n        payload: {\n          runUrl: 'https://dashboard.cypress.io/runs/12345',\n        },\n      }\n\n      api.createRun.rejects(err)\n\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--record',\n        '--key=token-123',\n        '--parallel',\n        '--group=electron-smoke-tests',\n        '--ciBuildId=ciBuildId123',\n      ])\n      .then(() => {\n        this.expectExitWithErr('DASHBOARD_PARALLEL_GROUP_PARAMS_MISMATCH')\n\n        return snapshotConsoleLogs('DASHBOARD_PARALLEL_GROUP_PARAMS_MISMATCH 1')\n      })\n    })\n\n    it('errors and exits when parallel is not allowed', function () {\n      const err = new Error()\n\n      err.statusCode = 422\n      err.error = {\n        code: 'PARALLEL_DISALLOWED',\n        payload: {\n          runUrl: 'https://dashboard.cypress.io/runs/12345',\n        },\n      }\n\n      api.createRun.rejects(err)\n\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--record',\n        '--key=token-123',\n        '--parallel',\n        '--group=electron-smoke-tests',\n        '--ciBuildId=ciBuildId123',\n      ])\n      .then(() => {\n        this.expectExitWithErr('DASHBOARD_PARALLEL_DISALLOWED')\n\n        return snapshotConsoleLogs('DASHBOARD_PARALLEL_DISALLOWED 1')\n      })\n    })\n\n    it('errors and exits when parallel is required', function () {\n      const err = new Error()\n\n      err.statusCode = 422\n      err.error = {\n        code: 'PARALLEL_REQUIRED',\n        payload: {\n          runUrl: 'https://dashboard.cypress.io/runs/12345',\n        },\n      }\n\n      api.createRun.rejects(err)\n\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--record',\n        '--key=token-123',\n        '--parallel',\n        '--tag=nightly',\n        '--group=electron-smoke-tests',\n        '--ciBuildId=ciBuildId123',\n      ])\n      .then(() => {\n        this.expectExitWithErr('DASHBOARD_PARALLEL_REQUIRED')\n\n        return snapshotConsoleLogs('DASHBOARD_PARALLEL_REQUIRED 1')\n      })\n    })\n\n    it('errors and exits when run is already complete', function () {\n      const err = new Error()\n\n      err.statusCode = 422\n      err.error = {\n        code: 'ALREADY_COMPLETE',\n        payload: {\n          runUrl: 'https://dashboard.cypress.io/runs/12345',\n        },\n      }\n\n      api.createRun.rejects(err)\n\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--record',\n        '--key=token-123',\n        '--tag=nightly',\n        '--group=electron-smoke-tests',\n        '--ciBuildId=ciBuildId123',\n      ])\n      .then(() => {\n        this.expectExitWithErr('DASHBOARD_ALREADY_COMPLETE')\n\n        return snapshotConsoleLogs('DASHBOARD_ALREADY_COMPLETE 1')\n      })\n    })\n\n    it('errors and exits when run is stale', function () {\n      const err = new Error()\n\n      err.statusCode = 422\n      err.error = {\n        code: 'STALE_RUN',\n        payload: {\n          runUrl: 'https://dashboard.cypress.io/runs/12345',\n        },\n      }\n\n      api.createRun.rejects(err)\n\n      return cypress.start([\n        `--run-project=${this.recordPath}`,\n        '--record',\n        '--key=token-123',\n        '--parallel',\n        '--tag=nightly',\n        '--group=electron-smoke-tests',\n        '--ciBuildId=ciBuildId123',\n      ])\n      .then(() => {\n        this.expectExitWithErr('DASHBOARD_STALE_RUN')\n\n        return snapshotConsoleLogs('DASHBOARD_STALE_RUN 1')\n      })\n    })\n  })\n\n  context('--return-pkg', () => {\n    beforeEach(() => {\n      console.log.restore()\n\n      sinon.stub(console, 'log')\n    })\n\n    it('logs package.json and exits', function () {\n      return cypress.start(['--return-pkg'])\n      .then(() => {\n        expect(console.log).to.be.calledWithMatch('{\"name\":\"cypress\"')\n        this.expectExitWith(0)\n      })\n    })\n  })\n\n  context('--version', () => {\n    beforeEach(() => {\n      console.log.restore()\n\n      sinon.stub(console, 'log')\n    })\n\n    it('logs version and exits', function () {\n      return cypress.start(['--version'])\n      .then(() => {\n        expect(console.log).to.be.calledWith(pkg.version)\n        this.expectExitWith(0)\n      })\n    })\n  })\n\n  context('--smoke-test', () => {\n    beforeEach(() => {\n      console.log.restore()\n\n      sinon.stub(console, 'log')\n    })\n\n    it('logs pong value and exits', function () {\n      return cypress.start(['--smoke-test', '--ping=abc123'])\n      .then(() => {\n        expect(console.log).to.be.calledWith('abc123')\n        this.expectExitWith(0)\n      })\n    })\n  })\n\n  context('interactive', () => {\n    beforeEach(function () {\n      this.win = {\n        on: sinon.stub(),\n        webContents: {\n          on: sinon.stub(),\n        },\n      }\n\n      sinon.stub(electron.app, 'on').withArgs('ready').yieldsAsync()\n      sinon.stub(Windows, 'open').resolves(this.win)\n      sinon.stub(ServerE2E.prototype, 'startWebsockets')\n      sinon.spy(Events, 'start')\n      sinon.stub(electron.ipcMain, 'on')\n    })\n\n    it('passes options to interactiveMode.ready', () => {\n      sinon.stub(interactiveMode, 'ready')\n\n      return cypress.start(['--updating', '--port=2121', '--config=pageLoadTimeout=1000'])\n      .then(() => {\n        expect(interactiveMode.ready).to.be.calledWithMatch({\n          updating: true,\n          config: {\n            port: 2121,\n            pageLoadTimeout: 1000,\n          },\n        })\n      })\n    })\n\n    it('passes options to Events.start', () => {\n      return cypress.start(['--port=2121', '--config=pageLoadTimeout=1000'])\n      .then(() => {\n        expect(Events.start).to.be.calledWithMatch({\n          config: {\n            pageLoadTimeout: 1000,\n            port: 2121,\n          },\n        })\n      })\n    })\n\n    it('passes filtered options to Project#open and sets cli config', function () {\n      const getConfig = sinon.spy(ProjectE2E.prototype, 'getConfig')\n      const open = sinon.stub(ServerE2E.prototype, 'open').resolves([])\n\n      process.env.CYPRESS_FILE_SERVER_FOLDER = 'foo'\n      process.env.CYPRESS_BASE_URL = 'http://localhost'\n      process.env.CYPRESS_port = '2222'\n      process.env.CYPRESS_responseTimeout = '5555'\n      process.env.CYPRESS_watch_for_file_changes = 'false'\n\n      return user.set({ name: 'brian', authToken: 'auth-token-123' })\n      .then(() => {\n        return settings.read(this.todosPath)\n      }).then((json) => {\n        // this should be overriden by the env argument\n        json.baseUrl = 'http://localhost:8080'\n\n        return settings.write(this.todosPath, json)\n      }).then(() => {\n        return cypress.start([\n          '--port=2121',\n          '--config',\n          'pageLoadTimeout=1000',\n          '--foo=bar',\n          '--env=baz=baz',\n        ])\n      }).then(() => {\n        const options = Events.start.firstCall.args[0]\n\n        return Events.handleEvent(options, {}, {}, 123, 'open:project', this.todosPath)\n      }).then(() => {\n        expect(getConfig).to.be.calledWithMatch({\n          port: 2121,\n          pageLoadTimeout: 1000,\n          report: false,\n          env: { baz: 'baz' },\n        })\n\n        expect(open).to.be.called\n\n        const cfg = open.getCall(0).args[0]\n\n        expect(cfg.fileServerFolder).to.eq(path.join(this.todosPath, 'foo'))\n        expect(cfg.pageLoadTimeout).to.eq(1000)\n        expect(cfg.port).to.eq(2121)\n        expect(cfg.baseUrl).to.eq('http://localhost')\n        expect(cfg.watchForFileChanges).to.be.false\n        expect(cfg.responseTimeout).to.eq(5555)\n        expect(cfg.env.baz).to.eq('baz')\n        expect(cfg.env).not.to.have.property('fileServerFolder')\n        expect(cfg.env).not.to.have.property('port')\n        expect(cfg.env).not.to.have.property('BASE_URL')\n        expect(cfg.env).not.to.have.property('watchForFileChanges')\n        expect(cfg.env).not.to.have.property('responseTimeout')\n\n        expect(cfg.resolved.fileServerFolder).to.deep.eq({\n          value: 'foo',\n          from: 'env',\n        })\n\n        expect(cfg.resolved.pageLoadTimeout).to.deep.eq({\n          value: 1000,\n          from: 'cli',\n        })\n\n        expect(cfg.resolved.port).to.deep.eq({\n          value: 2121,\n          from: 'cli',\n        })\n\n        expect(cfg.resolved.baseUrl).to.deep.eq({\n          value: 'http://localhost',\n          from: 'env',\n        })\n\n        expect(cfg.resolved.watchForFileChanges).to.deep.eq({\n          value: false,\n          from: 'env',\n        })\n\n        expect(cfg.resolved.responseTimeout).to.deep.eq({\n          value: 5555,\n          from: 'env',\n        })\n\n        expect(cfg.resolved.env.baz).to.deep.eq({\n          value: 'baz',\n          from: 'cli',\n        })\n      })\n    })\n\n    it('sends warning when baseUrl cannot be verified', function () {\n      const bus = new EE()\n      const event = { sender: { send: sinon.stub() } }\n      const warning = { message: 'Blah blah baseUrl blah blah' }\n\n      sinon.stub(ServerE2E.prototype, 'open').resolves([2121, warning])\n\n      return cypress.start(['--port=2121', '--config', 'pageLoadTimeout=1000', '--foo=bar', '--env=baz=baz'])\n      .then(() => {\n        const options = Events.start.firstCall.args[0]\n\n        Events.handleEvent(options, bus, event, 123, 'on:project:warning')\n\n        return Events.handleEvent(options, bus, event, 123, 'open:project', this.todosPath)\n      }).then(() => {\n        expect(event.sender.send.withArgs('response').firstCall.args[1].data).to.eql(warning)\n      })\n    })\n\n    describe('--config-file', () => {\n      beforeEach(function () {\n        this.filename = 'foo.bar.baz.asdf.quux.json'\n        this.open = sinon.stub(ServerE2E.prototype, 'open').resolves([])\n      })\n\n      it('reads config from a custom config file', function () {\n        sinon.stub(fs, 'readJsonAsync')\n        fs.readJsonAsync.withArgs(path.join(this.pristinePath, this.filename)).resolves({\n          env: { foo: 'bar' },\n          port: 2020,\n        })\n\n        fs.readJsonAsync.callThrough()\n\n        return cypress.start([\n          `--config-file=${this.filename}`,\n        ])\n        .then(() => {\n          const options = Events.start.firstCall.args[0]\n\n          return Events.handleEvent(options, {}, {}, 123, 'open:project', this.pristinePath)\n        }).then(() => {\n          expect(this.open).to.be.called\n\n          const cfg = this.open.getCall(0).args[0]\n\n          expect(cfg.env.foo).to.equal('bar')\n\n          expect(cfg.port).to.equal(2020)\n        })\n      })\n\n      it('creates custom config file if it does not exist', function () {\n        return cypress.start([\n          `--config-file=${this.filename}`,\n        ])\n        .then(() => {\n          debug('cypress started with config %s', this.filename)\n          const options = Events.start.firstCall.args[0]\n\n          debug('first call arguments %o', Events.start.firstCall.args)\n\n          return Events.handleEvent(options, {}, {}, 123, 'open:project', this.pristinePath)\n        }).then(() => {\n          expect(this.open, 'open was called').to.be.called\n\n          return fs.readJsonAsync(path.join(this.pristinePath, this.filename))\n          .then((json) => {\n            expect(json, 'json file is empty').to.deep.equal({})\n          })\n        })\n      })\n    })\n  })\n\n  context('--cwd', () => {\n    beforeEach(() => {\n      errors.warning.restore()\n      sinon.stub(electron.app, 'on').withArgs('ready').yieldsAsync()\n      sinon.stub(interactiveMode, 'ready').resolves()\n      sinon.spy(errors, 'warning')\n    })\n\n    it('shows warning if Cypress has been started directly', () => {\n      return cypress.start().then(() => {\n        expect(errors.warning).to.be.calledWith('INVOKED_BINARY_OUTSIDE_NPM_MODULE')\n        expect(console.log).to.be.calledWithMatch('It looks like you are running the Cypress binary directly.')\n        expect(console.log).to.be.calledWithMatch('https://on.cypress.io/installing-cypress')\n      })\n    })\n\n    it('does not show warning if finds --cwd', () => {\n      return cypress.start(['--cwd=/foo/bar']).then(() => {\n        expect(errors.warning).not.to.be.called\n      })\n    })\n  })\n\n  context('no args', () => {\n    beforeEach(() => {\n      sinon.stub(electron.app, 'on').withArgs('ready').yieldsAsync()\n      sinon.stub(interactiveMode, 'ready').resolves()\n    })\n\n    it('runs interactiveMode and does not exit', () => {\n      return cypress.start().then(() => {\n        expect(interactiveMode.ready).to.be.calledOnce\n      })\n    })\n  })\n})\n",
    "packages/server/test/integration/http_requests_spec.js": "require('../spec_helper')\n\nconst _ = require('lodash')\nlet r = require('@cypress/request')\nconst rp = require('@cypress/request-promise')\nconst compression = require('compression')\nconst dns = require('dns')\nconst express = require('express')\nconst http = require('http')\nconst path = require('path')\nconst url = require('url')\nlet zlib = require('zlib')\nconst str = require('underscore.string')\nconst evilDns = require('evil-dns')\nconst Promise = require('bluebird')\n\nconst httpsServer = require(`${root}../https-proxy/test/helpers/https_server`)\nconst pkg = require('@packages/root')\nconst SseStream = require('ssestream')\nconst EventSource = require('eventsource')\nconst config = require(`${root}lib/config`)\nconst { ServerE2E } = require(`${root}lib/server-e2e`)\nconst { ProjectE2E } = require(`${root}lib/project-e2e`)\nconst Watchers = require(`${root}lib/watchers`)\nconst pluginsModule = require(`${root}lib/plugins`)\nconst preprocessor = require(`${root}lib/plugins/preprocessor`)\nconst resolve = require(`${root}lib/util/resolve`)\nconst { fs } = require(`${root}lib/util/fs`)\nconst glob = require(`${root}lib/util/glob`)\nconst CacheBuster = require(`${root}lib/util/cache_buster`)\nconst Fixtures = require(`${root}test/support/helpers/fixtures`)\nconst runner = require(`${root}../runner/lib/resolve-dist`)\n\nzlib = Promise.promisifyAll(zlib)\n\n// force supertest-session to use promises provided in supertest\nconst session = proxyquire('supertest-session', { supertest })\n\nconst absolutePathRegex = /\"\\/[^{}]*?\\.projects/g\nlet sourceMapRegex = /\\n\\/\\/# sourceMappingURL\\=.*/\n\nconst replaceAbsolutePaths = (content) => {\n  return content.replace(absolutePathRegex, '\"/<path-to-project>')\n}\n\nconst removeWhitespace = function (c) {\n  c = str.clean(c)\n  c = str.lines(c).join(' ')\n\n  return c\n}\n\nconst cleanResponseBody = (body) => {\n  return replaceAbsolutePaths(removeWhitespace(body))\n}\n\ndescribe('Routes', () => {\n  require('mocha-banner').register()\n\n  beforeEach(function () {\n    process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'\n\n    sinon.stub(CacheBuster, 'get').returns('-123')\n    sinon.stub(ServerE2E.prototype, 'reset')\n    sinon.stub(pluginsModule, 'has').returns(false)\n\n    nock.enableNetConnect()\n\n    this.setup = (initialUrl, obj = {}) => {\n      if (_.isObject(initialUrl)) {\n        obj = initialUrl\n        initialUrl = null\n      }\n\n      if (!obj.projectRoot) {\n        obj.projectRoot = '/foo/bar/'\n      }\n\n      // get all the config defaults\n      // and allow us to override them\n      // for each test\n      return config.set(obj)\n      .then((cfg) => {\n        // use a jar for each test\n        // but reset it automatically\n        // between test\n        const jar = rp.jar()\n\n        this.r = function (options = {}, cb) {\n          _.defaults(options, {\n            proxy: this.proxy,\n            jar,\n            simple: false,\n            followRedirect: false,\n            resolveWithFullResponse: true,\n          })\n\n          return r(options, cb)\n        }\n\n        // use a custom request promise\n        // to automatically backfill these\n        // options including our proxy\n        this.rp = (options = {}) => {\n          let targetUrl\n\n          if (_.isString(options)) {\n            targetUrl = options\n            options = {}\n          }\n\n          _.defaults(options, {\n            url: targetUrl,\n            proxy: this.proxy,\n            jar,\n            simple: false,\n            followRedirect: false,\n            resolveWithFullResponse: true,\n          })\n\n          return rp(options)\n        }\n\n        const open = () => {\n          this.project = new ProjectE2E('/path/to/project-e2e')\n\n          cfg.pluginsFile = false\n\n          return Promise.all([\n            // open our https server\n            httpsServer.start(8443),\n\n            // and open our cypress server\n            (this.server = new ServerE2E(new Watchers())),\n\n            this.server.open(cfg, this.project)\n            .spread(async (port) => {\n              const automationStub = {\n                use: () => { },\n              }\n\n              await this.server.startWebsockets(automationStub, config, {})\n\n              if (initialUrl) {\n                this.server._onDomainSet(initialUrl)\n              }\n\n              this.srv = this.server.getHttpServer()\n\n              this.session = session(this.srv)\n\n              this.proxy = `http://localhost:${port}`\n            }),\n\n            pluginsModule.init(cfg, {\n              projectRoot: cfg.projectRoot,\n            }),\n          ])\n        }\n\n        if (this.server) {\n          return Promise.join(\n            httpsServer.stop(),\n            this.server.close(),\n          )\n          .then(open)\n        }\n\n        return open()\n      })\n    }\n  })\n\n  afterEach(function () {\n    evilDns.clear()\n    nock.cleanAll()\n    Fixtures.remove()\n    this.session.destroy()\n    preprocessor.close()\n    this.project = null\n\n    return Promise.join(\n      this.server.close(),\n      httpsServer.stop(),\n    )\n  })\n\n  context('GET /', () => {\n    beforeEach(function () {\n      return this.setup()\n    })\n\n    // this tests a situation where we open our browser in another browser\n    // without proxy mode set\n    it('redirects to config.clientRoute without a _remoteOrigin and without a proxy', function () {\n      return this.rp({\n        url: this.proxy,\n        proxy: null,\n      })\n      .then((res) => {\n        expect(res.statusCode).to.eq(302)\n\n        expect(res.headers.location).to.eq('/__/')\n      })\n    })\n\n    it('does not redirect with _remoteOrigin set', function () {\n      return this.setup('http://www.github.com')\n      .then(() => {\n        nock(this.server._remoteOrigin)\n        .get('/')\n        .reply(200, '<html></html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.github.com/',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('<html>')\n          expect(res.body).to.include('document.domain = \\'github.com\\'')\n\n          expect(res.body).to.include('</html>')\n        })\n      })\n    })\n\n    it('does not redirect when visiting http site which isnt cypress server', function () {\n      // this tests the 'default' state of cypress when a server\n      // is instantiated. i noticed that before you do your first\n      // cy.visit() that all http sites would redirect which is\n      // incorrect. we only want the cypress port to redirect initially\n\n      nock('http://www.momentjs.com')\n      .get('/')\n      .reply(200)\n\n      return this.rp('http://www.momentjs.com/')\n      .then((res) => {\n        expect(res.statusCode).to.eq(200)\n\n        expect(res.headers.location).not.to.eq('/__/')\n      })\n    })\n\n    it('proxies through https', function () {\n      return this.setup('https://localhost:8443')\n      .then(() => {\n        return this.rp({\n          url: 'https://localhost:8443/',\n          headers: {\n            'Accept': 'text/html, application/xhtml+xml, */*',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).not.to.include('Cypress')\n          expect(res.body).to.include('document.domain = \\'localhost\\'')\n\n          expect(res.body).to.include('<body>https server</body>')\n        })\n      })\n    })\n  })\n\n  context('GET /__', () => {\n    beforeEach(function () {\n      return this.setup({ projectName: 'foobarbaz' })\n    })\n\n    it('routes config.clientRoute to serve cypress client app html', function () {\n      return this.rp('http://localhost:2020/__')\n      .then((res) => {\n        expect(res.statusCode).to.eq(200)\n\n        expect(res.body).to.match(/Runner.start/)\n      })\n    })\n\n    it('sets title to projectName', function () {\n      return this.rp('http://localhost:2020/__')\n      .then((res) => {\n        expect(res.statusCode).to.eq(200)\n\n        expect(res.body).to.include('<title>foobarbaz</title>')\n      })\n    })\n\n    it('omits x-powered-by', function () {\n      return this.rp('http://localhost:2020/__')\n      .then((res) => {\n        expect(res.statusCode).to.eq(200)\n\n        expect(res.headers['x-powered-by']).not.to.exist\n      })\n    })\n\n    it('proxies through https', function () {\n      return this.setup('https://localhost:8443')\n      .then(() => {\n        return this.rp('https://localhost:8443/__')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.match(/Runner.start\\(.+\\)/)\n        })\n      })\n    })\n\n    it('clientRoute routes to \\'not launched through Cypress\\' without a proxy set', function () {\n      return this.rp({\n        url: `${this.proxy}/__`,\n        proxy: null,\n      })\n      .then((res) => {\n        expect(res.statusCode).to.eq(200)\n\n        expect(res.body).to.match(/This browser was not launched through Cypress\\./)\n      })\n    })\n\n    it('other URLs redirect to clientRoute without a proxy set', function () {\n      // test something that isn't the clientRoute\n      return this.rp({\n        url: `${this.proxy}/__cypress/xhrs/foo`,\n        proxy: null,\n      })\n      .then((res) => {\n        expect(res.statusCode).to.eq(302)\n\n        expect(res.headers['location']).to.eq('/__/')\n      })\n    })\n\n    it('routes when baseUrl is set', function () {\n      return this.setup({ baseUrl: 'http://localhost:9999/app' })\n      .then(() => {\n        return this.rp('http://localhost:9999/__')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.match(/Runner.start/)\n        })\n      })\n    })\n\n    it('sends Cypress.version', function () {\n      return this.setup({ baseUrl: 'http://localhost:9999/app' })\n      .then(() => {\n        return this.rp('http://localhost:9999/__')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const base64Config = /Runner\\.start\\(.*, \"(.*)\"\\)/.exec(res.body)[1]\n          const configStr = Buffer.from(base64Config, 'base64').toString()\n\n          expect(configStr).to.include('version')\n\n          expect(configStr).to.include(pkg.version)\n        })\n      })\n    })\n  })\n\n  context('GET /__cypress/runner/*', () => {\n    beforeEach(function () {\n      return this.setup('http://localhost:8443')\n    })\n\n    it('can get cypress_runner.js', function () {\n      return this.rp('http://localhost:8443/__cypress/runner/cypress_runner.js')\n      .then((res) => {\n        expect(res.statusCode).to.eq(200)\n\n        expect(res.body).to.match(/React/)\n      })\n    })\n\n    it('can get cypress_runner.css', function () {\n      return this.rp('http://localhost:8443/__cypress/runner/cypress_runner.css')\n      .then((res) => {\n        expect(res.statusCode).to.eq(200)\n\n        expect(res.body).to.match(/spec-iframe/)\n      })\n    })\n  })\n\n  context('GET /__cypress/files', () => {\n    beforeEach(() => {\n      Fixtures.scaffold('todos')\n\n      return Fixtures.scaffold('ids')\n    })\n\n    describe('todos with specific configuration', () => {\n      beforeEach(function () {\n        return this.setup({\n          projectRoot: Fixtures.projectPath('todos'),\n          config: {\n            integrationFolder: 'tests',\n            fixturesFolder: 'tests/_fixtures',\n            supportFile: 'tests/_support/spec_helper.js',\n            javascripts: ['tests/etc/**/*'],\n          },\n        })\n      })\n\n      it('returns base json file path objects of only tests', function () {\n        // this should omit any _fixture files, _support files and javascripts\n        return glob(path.join(Fixtures.projectPath('todos'), 'tests', '_fixtures', '**', '*'))\n        .then((files) => {\n          // make sure there are fixtures in here!\n          expect(files.length).to.be.gt(0)\n\n          return glob(path.join(Fixtures.projectPath('todos'), 'tests', '_support', '**', '*'))\n          .then((files) => {\n            // make sure there are support files in here!\n            expect(files.length).to.be.gt(0)\n\n            return this.rp({\n              url: 'http://localhost:2020/__cypress/files',\n              json: true,\n            })\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n\n              const {\n                body,\n              } = res\n\n              expect(body.integration).to.have.length(4)\n\n              // remove the absolute path key\n              body.integration = _.map(body.integration, (obj) => {\n                return _.pick(obj, 'name', 'relative')\n              })\n\n              expect(res.body).to.deep.eq({\n                integration: [\n                  {\n                    'name': 'sub/a&b%c.js',\n                    'relative': 'tests/sub/a&b%c.js',\n                  },\n                  {\n                    name: 'sub/sub_test.coffee',\n                    relative: 'tests/sub/sub_test.coffee',\n                  },\n                  {\n                    name: 'test1.js',\n                    relative: 'tests/test1.js',\n                  },\n                  {\n                    name: 'test2.coffee',\n                    relative: 'tests/test2.coffee',\n                  },\n                ],\n              })\n            })\n          })\n        })\n      })\n    })\n\n    describe('ids with regular configuration', () => {\n      it('returns test files as json ignoring *.hot-update.js', function () {\n        return this.setup({\n          projectRoot: Fixtures.projectPath('ids'),\n        })\n        .then(() => {\n          return this.rp({\n            url: 'http://localhost:2020/__cypress/files',\n            json: true,\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            const {\n              body,\n            } = res\n\n            expect(body.integration).to.have.length(7)\n\n            // remove the absolute path key\n            body.integration = _.map(body.integration, (obj) => {\n              return _.pick(obj, 'name', 'relative')\n            })\n\n            expect(body).to.deep.eq({\n              integration: [\n                {\n                  name: 'bar.js',\n                  relative: 'cypress/integration/bar.js',\n                },\n                {\n                  name: 'baz.js',\n                  relative: 'cypress/integration/baz.js',\n                },\n                {\n                  name: 'dom.jsx',\n                  relative: 'cypress/integration/dom.jsx',\n                },\n                {\n                  name: 'es6.js',\n                  relative: 'cypress/integration/es6.js',\n                },\n                {\n                  name: 'foo.coffee',\n                  relative: 'cypress/integration/foo.coffee',\n                },\n                {\n                  name: 'nested/tmp.js',\n                  relative: 'cypress/integration/nested/tmp.js',\n                },\n                {\n                  name: 'noop.coffee',\n                  relative: 'cypress/integration/noop.coffee',\n                },\n              ],\n            })\n          })\n        })\n      })\n\n      it('can ignore other files as well', function () {\n        return this.setup({\n          projectRoot: Fixtures.projectPath('ids'),\n          config: {\n            ignoreTestFiles: ['**/bar.js', 'foo.coffee', '**/*.hot-update.js', '**/nested/*'],\n          },\n        })\n        .then(() => {\n          return this.rp({\n            url: 'http://localhost:2020/__cypress/files',\n            json: true,\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            const {\n              body,\n            } = res\n\n            expect(body.integration).to.have.length(4)\n\n            // remove the absolute path key\n            body.integration = _.map(body.integration, (obj) => {\n              return _.pick(obj, 'name', 'relative')\n            })\n\n            expect(body).to.deep.eq({\n              integration: [\n                {\n                  name: 'baz.js',\n                  relative: 'cypress/integration/baz.js',\n                },\n                {\n                  name: 'dom.jsx',\n                  relative: 'cypress/integration/dom.jsx',\n                },\n                {\n                  name: 'es6.js',\n                  relative: 'cypress/integration/es6.js',\n                },\n                {\n                  name: 'noop.coffee',\n                  relative: 'cypress/integration/noop.coffee',\n                },\n              ],\n            })\n          })\n        })\n      })\n    })\n  })\n\n  context('GET /__cypress/tests', () => {\n    describe('ids with typescript', () => {\n      beforeEach(function () {\n        Fixtures.scaffold('ids')\n\n        return this.setup({\n          projectRoot: Fixtures.projectPath('ids'),\n        })\n      })\n\n      it('processes foo.coffee spec', function () {\n        return this.rp('http://localhost:2020/__cypress/tests?p=cypress/integration/foo.coffee')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('expect(\"foo.coffee\")')\n        })\n      })\n\n      it('processes dom.jsx spec', function () {\n        return this.rp('http://localhost:2020/__cypress/tests?p=cypress/integration/baz.js')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('React.createElement(')\n        })\n      })\n\n      it('processes spec into modern javascript', function () {\n        return this.rp('http://localhost:2020/__cypress/tests?p=cypress/integration/es6.js')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          // \"modern\" features should remain and not be transpiled into es5\n          expect(res.body).to.include('const numbers')\n          expect(res.body).to.include('[...numbers]')\n          expect(res.body).to.include('async function')\n          expect(res.body).to.include('await Promise')\n        })\n      })\n\n      it('serves error javascript file when the file is missing', function () {\n        return this.rp('http://localhost:2020/__cypress/tests?p=does/not/exist.coffee')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('Cypress.action(\"spec:script:error\", {')\n          expect(res.body).to.include('Module not found')\n        })\n      })\n    })\n\n    describe('ids without typescript', () => {\n      beforeEach(function () {\n        Fixtures.scaffold('ids')\n\n        sinon.stub(resolve, 'typescript').callsFake(() => {\n          return null\n        })\n\n        return this.setup({\n          projectRoot: Fixtures.projectPath('ids'),\n        })\n      })\n\n      it('processes foo.coffee spec', function () {\n        return this.rp('http://localhost:2020/__cypress/tests?p=cypress/integration/foo.coffee')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.match(sourceMapRegex)\n          expect(res.body).to.include('expect(\"foo.coffee\")')\n        })\n      })\n\n      it('processes dom.jsx spec', function () {\n        return this.rp('http://localhost:2020/__cypress/tests?p=cypress/integration/baz.js')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.match(sourceMapRegex)\n          expect(res.body).to.include('React.createElement(')\n        })\n      })\n\n      it('serves error javascript file when the file is missing', function () {\n        return this.rp('http://localhost:2020/__cypress/tests?p=does/not/exist.coffee')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('Cypress.action(\"spec:script:error\", {')\n          expect(res.body).to.include('Module not found')\n        })\n      })\n    })\n\n    describe('failures', () => {\n      beforeEach(function () {\n        Fixtures.scaffold('failures')\n\n        return this.setup({\n          projectRoot: Fixtures.projectPath('failures'),\n        })\n      })\n\n      it('serves error javascript file when there\\'s a syntax error', function () {\n        return this.rp('http://localhost:2020/__cypress/tests?p=cypress/integration/syntax_error.js')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('Cypress.action(\"spec:script:error\", {')\n          expect(res.body).to.include('Unexpected token')\n        })\n      })\n    })\n\n    describe('no-server', () => {\n      beforeEach(function () {\n        Fixtures.scaffold('no-server')\n\n        return this.setup({\n          projectRoot: Fixtures.projectPath('no-server'),\n          config: {\n            integrationFolder: 'my-tests',\n            javascripts: ['helpers/includes.js'],\n          },\n        })\n      })\n\n      it('processes my-tests/test1.js spec', function () {\n        return this.rp('http://localhost:2020/__cypress/tests?p=my-tests/test1.js')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.match(sourceMapRegex)\n          expect(res.body).to.include(`expect('no-server')`)\n        })\n      })\n\n      it('processes helpers/includes.js javascripts', function () {\n        return this.rp('http://localhost:2020/__cypress/tests?p=helpers/includes.js')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.match(sourceMapRegex)\n          expect(res.body).to.include(`console.log('includes')`)\n        })\n      })\n    })\n  })\n\n  context('ALL /__cypress/xhrs/*', () => {\n    beforeEach(function () {\n      return this.setup()\n    })\n\n    describe('delay', () => {\n      it('can set delay to 10ms', function () {\n        const delay = sinon.spy(Promise, 'delay')\n\n        return this.rp({\n          url: 'http://localhost:2020/__cypress/xhrs/users/1',\n          headers: {\n            'x-cypress-delay': '10',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(delay).to.be.calledWith(10)\n        })\n      })\n\n      it('does not call Promise.delay when no delay', function () {\n        const delay = sinon.spy(Promise, 'delay')\n\n        return this.rp('http://localhost:2020/__cypress/xhrs/users/1')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(delay).not.to.be.called\n        })\n      })\n    })\n\n    describe('status', () => {\n      it('can set status', function () {\n        return this.rp({\n          url: 'http://localhost:2020/__cypress/xhrs/users/1',\n          headers: {\n            'x-cypress-status': '401',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(401)\n        })\n      })\n    })\n\n    describe('headers', () => {\n      it('can set headers', function () {\n        const headers = JSON.stringify({\n          'x-token': '123',\n          'content-type': 'text/plain',\n        })\n\n        return this.rp({\n          url: 'http://localhost:2020/__cypress/xhrs/users/1',\n          headers: {\n            'x-cypress-headers': headers,\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.headers['content-type']).to.match(/text\\/plain/)\n\n          expect(res.headers['x-token']).to.eq('123')\n        })\n      })\n\n      it('sets headers from response type', function () {\n        const headers = JSON.stringify({\n          'x-token': '123',\n        })\n\n        return this.rp({\n          url: 'http://localhost:2020/__cypress/xhrs/users/1',\n          json: true,\n          headers: {\n            'x-cypress-headers': headers,\n            'x-cypress-response': JSON.stringify({ foo: 'bar' }),\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.headers['content-type']).to.match(/application\\/json/)\n          expect(res.headers['x-token']).to.eq('123')\n\n          expect(res.body).to.deep.eq({ foo: 'bar' })\n        })\n      })\n    })\n\n    describe('response', () => {\n      it('sets response to json', function () {\n        return this.rp({\n          url: 'http://localhost:2020/__cypress/xhrs/users/1',\n          json: true,\n          headers: {\n            'x-cypress-response': JSON.stringify([1, 2, 3]),\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.headers['content-type']).to.match(/application\\/json/)\n\n          expect(res.body).to.deep.eq([1, 2, 3])\n        })\n      })\n\n      it('sets response to text/html', function () {\n        return this.rp({\n          url: 'http://localhost:2020/__cypress/xhrs/users/1',\n          headers: {\n            'x-cypress-response': '<html>foo</html>',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.headers['content-type']).to.match(/text\\/html/)\n\n          expect(res.body).to.eq('<html>foo</html>')\n        })\n      })\n\n      it('sets response to text/plain', function () {\n        return this.rp({\n          url: 'http://localhost:2020/__cypress/xhrs/users/1',\n          headers: {\n            'x-cypress-response': 'foobarbaz',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.headers['content-type']).to.match(/text\\/plain/)\n\n          expect(res.body).to.eq('foobarbaz')\n        })\n      })\n\n      it('sets response to text/plain on empty response', function () {\n        return this.rp({\n          url: 'http://localhost:2020/__cypress/xhrs/users/1',\n          headers: {\n            'x-cypress-response': '',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.headers['content-type']).to.match(/text\\/plain/)\n\n          expect(res.body).to.eq('')\n        })\n      })\n\n      it('decodes responses', function () {\n        const response = encodeURI(JSON.stringify({\n          'test': 'We’ll',\n        }))\n\n        return this.rp({\n          url: 'http://localhost:2020/__cypress/xhrs/users/1',\n          json: true,\n          headers: {\n            'x-cypress-response': response,\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.deep.eq({ test: 'We’ll' })\n        })\n      })\n\n      context('fixture', () => {\n        beforeEach(function () {\n          Fixtures.scaffold('todos')\n\n          return this.setup({\n            projectRoot: Fixtures.projectPath('todos'),\n            config: {\n              integrationFolder: 'tests',\n              fixturesFolder: 'tests/_fixtures',\n            },\n          })\n        })\n\n        it('returns fixture contents', function () {\n          return this.rp({\n            url: 'http://localhost:2020/__cypress/xhrs/bar',\n            json: true,\n            headers: {\n              'x-cypress-response': 'fixture:foo',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.headers['content-type']).to.match(/application\\/json/)\n\n            expect(res.body).to.deep.eq([{ json: true }])\n          })\n        })\n\n        it('returns __error on fixture errors', function () {\n          return this.rp({\n            url: 'http://localhost:2020/__cypress/xhrs/bar',\n            json: true,\n            headers: {\n              'x-cypress-response': 'fixture:bad_json',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(400)\n            expect(res.headers['content-type']).to.match(/application\\/json/)\n\n            expect(res.body.__error).to.include('\\'bad_json\\' is not valid JSON.')\n          })\n        })\n\n        it('can change the fixture encoding', function () {\n          return fs.readFileAsync(Fixtures.projectPath('todos/tests/_fixtures/images/flower.png'), 'binary')\n          .then((bin) => {\n            return this.rp({\n              url: 'http://localhost:2020/__cypress/xhrs/bar',\n              headers: {\n                'x-cypress-response': 'fixture:images/flower.png,binary',\n                'x-cypress-headers': JSON.stringify({\n                  'content-type': 'binary/octet-stream',\n                }),\n              },\n            })\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n              expect(res.headers['content-type']).to.include('binary/octet-stream')\n\n              expect(res.headers['content-length']).to.eq(`${bin.length}`)\n            })\n          })\n        })\n      })\n\n      context('PUT', () => {\n        it('can issue PUT requests', function () {\n          return this.rp({\n            method: 'put',\n            url: 'http://localhost:2020/__cypress/xhrs/users/1',\n            json: true,\n            body: {\n              name: 'brian',\n            },\n            headers: {\n              'x-cypress-response': JSON.stringify({ id: 123, name: 'brian' }),\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.headers['content-type']).to.match(/application\\/json/)\n\n            expect(res.body).to.deep.eq({ id: 123, name: 'brian' })\n          })\n        })\n      })\n\n      context('POST', () => {\n        it('can issue POST requests', function () {\n          return this.rp({\n            method: 'post',\n            url: 'http://localhost:2020/__cypress/xhrs/users/1',\n            json: true,\n            body: {\n              name: 'brian',\n            },\n            headers: {\n              'x-cypress-response': JSON.stringify({ id: 123, name: 'brian' }),\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.headers['content-type']).to.match(/application\\/json/)\n\n            expect(res.body).to.deep.eq({ id: 123, name: 'brian' })\n          })\n        })\n      })\n\n      context('HEAD', () => {\n        it('can issue PUT requests', function () {\n          return this.rp({\n            method: 'head',\n            url: 'http://localhost:2020/__cypress/xhrs/users/1',\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.headers['content-type']).to.match(/text\\/plain/)\n          })\n        })\n      })\n\n      context('DELETE', () => {\n        it('can issue DELETE requests', function () {\n          return this.rp({\n            method: 'delete',\n            url: 'http://localhost:2020/__cypress/xhrs/users/1',\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.headers['content-type']).to.match(/text\\/plain/)\n          })\n        })\n      })\n    })\n  })\n\n  // describe \"maximum header size\", ->\n  //   ## https://github.com/cypress-io/cypress/issues/76\n  //   it \"does not bomb on huge headers\", ->\n  //     json = Fixtures.get(\"server/really_big_json.json\")\n\n  //     supertest(@srv)\n  //       .get(\"/__cypress/xhrs/users\")\n  //       .set(\"x-cypress-response\", json)\n  //       .set(\"x-cypress-response-2\", json)\n  //       .expect(200)\n  //       .expect(\"Content-Type\", /application\\/json/)\n  //       .expect(JSON.parse(json))\n\n  context('GET /__cypress/iframes/*', () => {\n    beforeEach(() => {\n      Fixtures.scaffold('e2e')\n      Fixtures.scaffold('todos')\n      Fixtures.scaffold('no-server')\n\n      return Fixtures.scaffold('ids')\n    })\n\n    describe('todos', () => {\n      beforeEach(function () {\n        return this.setup({\n          projectRoot: Fixtures.projectPath('todos'),\n          config: {\n            integrationFolder: 'tests',\n            fixturesFolder: 'tests/_fixtures',\n            supportFile: 'tests/_support/spec_helper.js',\n            javascripts: ['tests/etc/etc.js'],\n          },\n        })\n      })\n\n      it('renders iframe with variables passed in', function () {\n        const contents = removeWhitespace(Fixtures.get('server/expected_todos_iframe.html'))\n\n        return this.rp('http://localhost:2020/__cypress/iframes/integration/test2.coffee')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const body = cleanResponseBody(res.body)\n\n          expect(body).to.eq(contents)\n        })\n      })\n\n      it('can send back all tests', function () {\n        const contents = removeWhitespace(Fixtures.get('server/expected_todos_all_tests_iframe.html'))\n\n        return this.rp('http://localhost:2020/__cypress/iframes/__all')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const body = cleanResponseBody(res.body)\n\n          expect(body).to.eq(contents)\n        })\n      })\n\n      it('can send back tests matching spec filter', function () {\n        // only returns tests with \"sub_test\" in their names\n        const contents = removeWhitespace(Fixtures.get('server/expected_todos_filtered_tests_iframe.html'))\n\n        this.project.spec = {\n          specFilter: 'sub_test',\n        }\n\n        return this.rp('http://localhost:2020/__cypress/iframes/__all')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const body = cleanResponseBody(res.body)\n\n          console.log(body)\n\n          expect(body).to.eq(contents)\n        })\n      })\n    })\n\n    describe('no-server', () => {\n      beforeEach(function () {\n        return this.setup({\n          projectRoot: Fixtures.projectPath('no-server'),\n          config: {\n            integrationFolder: 'my-tests',\n            supportFile: 'helpers/includes.js',\n            fileServerFolder: 'foo',\n          },\n        })\n      })\n\n      it('renders iframe with variables passed in', function () {\n        const contents = removeWhitespace(Fixtures.get('server/expected_no_server_iframe.html'))\n\n        return this.rp('http://localhost:2020/__cypress/iframes/integration/test1.js')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const body = cleanResponseBody(res.body)\n\n          expect(body).to.eq(contents)\n        })\n      })\n    })\n\n    describe('no-server with supportFile: false', () => {\n      beforeEach(function () {\n        return this.setup({\n          projectRoot: Fixtures.projectPath('no-server'),\n          config: {\n            integrationFolder: 'my-tests',\n            supportFile: false,\n          },\n        })\n      })\n\n      it('renders iframe without support file', function () {\n        const contents = removeWhitespace(Fixtures.get('server/expected_no_server_no_support_iframe.html'))\n\n        return this.rp('http://localhost:2020/__cypress/iframes/__all')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const body = cleanResponseBody(res.body)\n\n          expect(body).to.eq(contents)\n        })\n      })\n    })\n\n    describe('e2e', () => {\n      beforeEach(function () {\n        return this.setup({\n          projectRoot: Fixtures.projectPath('e2e'),\n          config: {\n            integrationFolder: 'cypress/integration',\n            supportFile: 'cypress/support/commands.js',\n          },\n        })\n      })\n\n      it('omits support directories', function () {\n        const contents = removeWhitespace(Fixtures.get('server/expected_e2e_iframe.html'))\n\n        return this.rp('http://localhost:2020/__cypress/iframes/integration/app_spec.coffee')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const body = cleanResponseBody(res.body)\n\n          expect(body).to.eq(contents)\n        })\n      })\n    })\n\n    describe('ids', () => {\n      beforeEach(function () {\n        return this.setup({\n          projectRoot: Fixtures.projectPath('ids'),\n        })\n      })\n\n      it('renders iframe with variables passed in', function () {\n        const contents = removeWhitespace(Fixtures.get('server/expected_ids_iframe.html'))\n\n        return this.rp('http://localhost:2020/__cypress/iframes/integration/foo.coffee')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const body = cleanResponseBody(res.body)\n\n          expect(body).to.eq(contents)\n        })\n      })\n\n      it('can send back all tests', function () {\n        const contents = removeWhitespace(Fixtures.get('server/expected_ids_all_tests_iframe.html'))\n\n        return this.rp('http://localhost:2020/__cypress/iframes/__all')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const body = cleanResponseBody(res.body)\n\n          expect(body).to.eq(contents)\n        })\n      })\n    })\n  })\n\n  context('GET *', () => {\n    context('basic request', () => {\n      beforeEach(function () {\n        return this.setup('http://www.github.com')\n      })\n\n      it('basic 200 html response', function () {\n        nock(this.server._remoteOrigin)\n        .get('/')\n        .reply(200, 'hello from bar!', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.github.com/',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.include('hello from bar!')\n        })\n      })\n    })\n\n    context('gzip', () => {\n      beforeEach(function () {\n        return this.setup('http://www.github.com')\n      })\n\n      it('unzips, injects, and then rezips initial content', function () {\n        nock(this.server._remoteOrigin)\n        .get('/gzip')\n        .matchHeader('accept-encoding', 'gzip')\n        .replyWithFile(200, Fixtures.path('server/gzip.html.gz'), {\n          'Content-Type': 'text/html',\n          'Content-Encoding': 'gzip',\n        })\n\n        return this.rp({\n          url: 'http://www.github.com/gzip',\n          gzip: true,\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('<html>')\n          expect(res.body).to.include('gzip')\n          expect(res.body).to.include('parent.Cypress')\n          expect(res.body).to.include('document.domain = \\'github.com\\'')\n\n          expect(res.body).to.include('</html>')\n        })\n      })\n\n      it('unzips, injects, and then rezips regular http content', function () {\n        nock(this.server._remoteOrigin)\n        .get('/gzip')\n        .matchHeader('accept-encoding', 'gzip')\n        .replyWithFile(200, Fixtures.path('server/gzip.html.gz'), {\n          'Content-Type': 'text/html',\n          'Content-Encoding': 'gzip',\n        })\n\n        return this.rp({\n          url: 'http://www.github.com/gzip',\n          gzip: true,\n          headers: {\n            'Cookie': '__cypress.initial=false',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('<html>')\n          expect(res.body).to.include('gzip')\n          expect(res.body).to.include('document.domain = \\'github.com\\'')\n\n          expect(res.body).to.include('</html>')\n        })\n      })\n\n      it('does not inject on regular gzip\\'d content', function () {\n        nock(this.server._remoteOrigin)\n        .get('/gzip')\n        .matchHeader('accept-encoding', 'gzip')\n        .replyWithFile(200, Fixtures.path('server/gzip.html.gz'), {\n          'Content-Type': 'text/html',\n          'Content-Encoding': 'gzip',\n        })\n\n        return this.rp({\n          url: 'http://www.github.com/gzip',\n          gzip: true,\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('<html>')\n          expect(res.body).to.include('gzip')\n          expect(res.body).not.to.include('document.domain = \\'github.com\\'')\n\n          expect(res.body).to.include('</html>')\n        })\n      })\n\n      // https://github.com/cypress-io/cypress/issues/1746\n      it('can ungzip utf-8 javascript and inject without corrupting it', function () {\n        let js = ''\n\n        const app = express()\n\n        app.use(compression({ chunkSize: 64, threshold: 1 }))\n\n        app.get('/', (req, res) => {\n          res.setHeader('content-type', 'application/javascript; charset=UTF-8')\n          res.setHeader('transfer-encoding', 'chunked')\n\n          const write = (chunk) => {\n            js += chunk\n\n            return res.write(chunk)\n          }\n\n          // note - this is unintentionally invalid JS, just try executing it anywhere\n          write('function ')\n          _.times(100, () => {\n            return write('😡😈'.repeat(10))\n          })\n\n          write(' () { }')\n\n          return res.end()\n        })\n\n        const server = http.createServer(app)\n\n        return Promise.fromCallback((cb) => {\n          return server.listen(12345, cb)\n        }).then(() => {\n          return this.rp({\n            url: 'http://localhost:12345',\n            gzip: true,\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.body).to.deep.eq(js)\n          })\n        }).finally(() => {\n          return Promise.fromCallback((cb) => {\n            return server.close(cb)\n          })\n        })\n      })\n    })\n\n    context('accept-encoding', () => {\n      beforeEach(function () {\n        return this.setup('http://www.github.com')\n      })\n\n      it('strips unsupported deflate and br encoding', function () {\n        nock(this.server._remoteOrigin)\n        .get('/accept')\n        .matchHeader('accept-encoding', 'gzip')\n        .reply(200, '<html>accept</html>')\n\n        return this.rp({\n          url: 'http://www.github.com/accept',\n          gzip: true,\n          headers: {\n            'accept-encoding': 'gzip,deflate,br',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.eq('<html>accept</html>')\n        })\n      })\n\n      it('removes accept-encoding when nothing is supported', function () {\n        nock(this.server._remoteOrigin, {\n          badheaders: ['accept-encoding'],\n        })\n        .get('/accept')\n        .reply(200, '<html>accept</html>')\n\n        return this.rp({\n          url: 'http://www.github.com/accept',\n          gzip: true,\n          headers: {\n            'accept-encoding': 'foo,bar,baz',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.eq('<html>accept</html>')\n        })\n      })\n    })\n\n    context('304 Not Modified', () => {\n      beforeEach(function () {\n        return this.setup('http://localhost:8080')\n      })\n\n      it('sends back a 304', function () {\n        nock(this.server._remoteOrigin)\n        .get('/assets/app.js')\n        .reply(304)\n\n        return this.rp({\n          url: 'http://localhost:8080/assets/app.js',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(304)\n        })\n      })\n    })\n\n    context('redirects', () => {\n      beforeEach(function () {\n        return this.setup('http://getbootstrap.com')\n      })\n\n      it('passes the location header through', function () {\n        nock(this.server._remoteOrigin)\n        .get('/foo')\n        .reply(302, undefined, {\n          'Location': '/',\n        })\n        .get('/')\n        .reply(200, '<html></html', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://getbootstrap.com/foo',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(302)\n          expect(res.headers['set-cookie']).to.include('__cypress.initial=true; Domain=getbootstrap.com; Path=/')\n\n          expect(res.headers['location']).to.eq('/')\n        })\n      })\n\n      // this fixes improper url merge where we took query params\n      // and added them needlessly\n      it('doesnt redirect with query params or hashes which werent in location header', function () {\n        nock(this.server._remoteOrigin)\n        .get('/foo?bar=baz')\n        .reply(302, undefined, {\n          'Location': '/css',\n        })\n\n        return this.rp({\n          url: 'http://getbootstrap.com/foo?bar=baz',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(302)\n          expect(res.headers['set-cookie']).to.include('__cypress.initial=true; Domain=getbootstrap.com; Path=/')\n\n          expect(res.headers['location']).to.eq('/css')\n        })\n      })\n\n      it('does redirect with query params if location header includes them', function () {\n        nock(this.server._remoteOrigin)\n        .get('/foo?bar=baz')\n        .reply(302, undefined, {\n          'Location': '/css?q=search',\n        })\n        .get('/')\n        .reply(200, '<html></html', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://getbootstrap.com/foo?bar=baz',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(302)\n          expect(res.headers['set-cookie']).to.include('__cypress.initial=true; Domain=getbootstrap.com; Path=/')\n\n          expect(res.headers['location']).to.eq('/css?q=search')\n        })\n      })\n\n      it('does redirect with query params to external domain if location header includes them', function () {\n        nock(this.server._remoteOrigin)\n        .get('/foo?bar=baz')\n        .reply(302, undefined, {\n          'Location': 'https://www.google.com/search?q=cypress',\n        })\n        .get('/')\n        .reply(200, '<html></html', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://getbootstrap.com/foo?bar=baz',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(302)\n          expect(res.headers['set-cookie']).to.include('__cypress.initial=true; Domain=getbootstrap.com; Path=/')\n\n          expect(res.headers['location']).to.eq('https://www.google.com/search?q=cypress')\n        })\n      })\n\n      it('sets cookies and removes __cypress.initial when initial is originally false', function () {\n        nock(this.server._remoteOrigin)\n        .get('/css')\n        .reply(302, undefined, {\n          'Set-Cookie': 'foo=bar; Path=/',\n          'Location': '/css/',\n        })\n\n        return this.rp({\n          url: 'http://getbootstrap.com/css',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(302)\n          // since this is not a cypress cookie we do not set the domain\n          expect(res.headers['set-cookie']).to.deep.eq(['foo=bar; Path=/'])\n\n          expect(res.headers['location']).to.eq('/css/')\n        })\n      })\n\n      return [301, 302, 303, 307, 308].forEach((code) => {\n        it(`handles direct for status code: ${code}`, function () {\n          return this.setup('http://auth.example.com')\n          .then(() => {\n            nock(this.server._remoteOrigin)\n            .get('/login')\n            .reply(code, undefined, {\n              Location: 'http://app.example.com/users/1',\n            })\n\n            return this.rp({\n              url: 'http://auth.example.com/login',\n              headers: {\n                'Cookie': '__cypress.initial=true',\n              },\n            })\n            .then((res) => {\n              expect(res.statusCode).to.eq(code)\n\n              expect(res.headers['set-cookie']).to.include('__cypress.initial=true; Domain=example.com; Path=/')\n            })\n          })\n        })\n      })\n    })\n\n    context('error handling', () => {\n      beforeEach(function () {\n        return this.setup('http://www.github.com')\n      })\n\n      it('passes through status code + content', function () {\n        nock(this.server._remoteOrigin)\n        .get('/index.html')\n        .reply(500, 'server error', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.github.com/index.html',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(500)\n          expect(res.body).to.include('server error')\n          expect(res.body).to.include('document.domain = \\'github.com\\'')\n\n          expect(res.headers['set-cookie']).to.match(/__cypress.initial=;/)\n        })\n      })\n\n      it('sends back socket hang up on request errors which match origin', function () {\n        nock('http://app.github.com')\n        .get('/')\n        .replyWithError('ECONNREFUSED')\n\n        return this.rp({\n          url: 'http://app.github.com/',\n          headers: {\n            'Accept': 'text/html, application/xhtml+xml, */*',\n          },\n        })\n        .then(() => {\n          throw new Error('should not reach')\n        }).catch((err) => {\n          expect(err.message).to.eq('Error: socket hang up')\n        })\n      })\n\n      it('sends back socket hang up on actual request errors', function () {\n        return this.setup('http://localhost:64644')\n        .then(() => {\n          return this.rp({\n            url: 'http://localhost:64644',\n            headers: {\n              'Accept': 'text/html, application/xhtml+xml, */*',\n            },\n          })\n        }).then(() => {\n          throw new Error('should not reach')\n        }).catch((err) => {\n          expect(err.message).to.eq('Error: socket hang up')\n        })\n      })\n\n      it('sends back socket hang up on http errors when no matching origin', function () {\n        return this.rp({\n          url: 'http://localhost:64644',\n          headers: {\n            'Accept': 'text/html, application/xhtml+xml, */*',\n          },\n        })\n        .then(() => {\n          throw new Error('should not reach')\n        }).catch((err) => {\n          expect(err.message).to.eq('Error: socket hang up')\n        })\n      })\n\n      it('sends back 401 when file server does not receive correct auth', function () {\n        return this.setup('<root>', {\n          config: {\n            fileServerFolder: '/Users/bmann/Dev/projects',\n          },\n        })\n        .then(() => {\n          return rp(`http://localhost:${this.server._fileServer.port()}/foo/views/test/index.html`, {\n            resolveWithFullResponse: true,\n            simple: false,\n          })\n        }).then((res) => {\n          expect(res.statusCode).to.eq(401)\n        })\n      })\n\n      it('sends back 404 when file does not exist locally', function () {\n        return this.setup('<root>', {\n          config: {\n            fileServerFolder: '/Users/bmann/Dev/projects',\n          },\n        })\n        .then(() => {\n          return this.rp(`${this.proxy}/foo/views/test/index.html`)\n          .then((res) => {\n            expect(res.statusCode).to.eq(404)\n            expect(res.body).to.include('Cypress errored trying to serve this file from your system:')\n            expect(res.body).to.include('/Users/bmann/Dev/projects/foo/views/test/index.html')\n            expect(res.body).to.include('The file was not found.')\n            expect(res.body).to.include('<html>\\n<head> <script')\n            expect(res.body).to.include('</script> </head> <body>')\n\n            expect(res.body).to.include('document.domain = \\'localhost\\';')\n          })\n        })\n      }) // should continue to inject\n\n      it('does not inject on file server errors when origin does not match', function () {\n        return this.setup('<root>', {\n          config: {\n            fileServerFolder: '/Users/bmann/Dev/projects',\n          },\n        })\n        .then(() => {\n          nock('http://www.github.com')\n          .get('/index.html')\n          .reply(500, 'server error', {\n            'Content-Type': 'text/html',\n          })\n\n          return this.rp('http://www.github.com/index.html')\n          .then((res) => {\n            expect(res.statusCode).to.eq(500)\n\n            expect(res.body).to.eq('server error')\n          })\n        })\n      })\n\n      it('transparently proxies decoding gzip failures', function () {\n        nock(this.server._remoteOrigin)\n        .get('/index.html')\n        .replyWithFile(200, Fixtures.path('server/gzip-bad.html.gz'), {\n          'Content-Type': 'text/html',\n          'Content-Encoding': 'gzip',\n        })\n\n        return this.rp({\n          url: 'http://www.github.com/index.html',\n          headers: {\n            'Accept': 'text/html, application/xhtml+xml, */*',\n          },\n          gzip: true,\n        })\n        .then(() => {\n          throw new Error('should not reach')\n        }).catch((err) => {\n          expect(err.error.code).to.eq('ECONNRESET')\n        })\n      })\n    })\n\n    context('headers', () => {\n      beforeEach(function () {\n        return this.setup('http://localhost:8080')\n      })\n\n      describe('when unload is true', () => {\n        it('automatically redirects back to clientRoute', function () {\n          return this.rp({\n            url: 'http://localhost:8080/_',\n            headers: {\n              'Cookie': '__cypress.unload=true; __cypress.initial=true',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(302)\n\n            expect(res.headers['location']).to.eq('/__/')\n          })\n        })\n      })\n\n      describe('when initial is true', () => {\n        it('sets back to false', function () {\n          nock(this.server._remoteOrigin)\n          .get('/app.html')\n          .reply(200, 'OK', {\n            'Content-Type': 'text/html',\n          })\n\n          return this.rp({\n            url: 'http://localhost:8080/app.html',\n            headers: {\n              'Cookie': '__cypress.initial=true',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.headers['set-cookie']).to.match(/initial=;/)\n          })\n        })\n      })\n\n      describe('when initial is false', () => {\n        it('does not reset initial or remoteHost', function () {\n          nock(this.server._remoteOrigin)\n          .get('/app.html')\n          .reply(200, 'OK', {\n            'Content-Type': 'text/html',\n          })\n\n          return this.rp({\n            url: 'http://localhost:8080/app.html',\n            headers: {\n              'Cookie': '__cypress.initial=false',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            // there shouldnt be any cookies set here by us\n            expect(res.headers['set-cookie']).not.to.exist\n          })\n        })\n      })\n\n      it('sends with Transfer-Encoding: chunked without Content-Length', function () {\n        nock(this.server._remoteOrigin)\n        .get('/login')\n        .reply(200, Buffer.from('foo'), {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/login',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('foo')\n          expect(res.headers['transfer-encoding']).to.eq('chunked')\n\n          expect(res.headers).not.to.have.property('content-length')\n        })\n      })\n\n      it('does not have Content-Length', function () {\n        nock(this.server._remoteOrigin)\n        .get('/login')\n        .reply(200, 'foo', {\n          'Content-Type': 'text/html',\n          'Content-Length': 123,\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/login',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('foo')\n          expect(res.headers['transfer-encoding']).to.eq('chunked')\n\n          expect(res.headers).not.to.have.property('content-length')\n        })\n      })\n\n      it('forwards cookies from incoming responses', function () {\n        nock(this.server._remoteOrigin)\n        .get('/login')\n        .reply(200, 'OK', {\n          'set-cookie': 'userId=123',\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/login',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.headers['set-cookie']).to.match(/userId=123/)\n        })\n      })\n\n      it('appends to previous cookies from incoming responses', function () {\n        nock(this.server._remoteOrigin)\n        .get('/login')\n        .reply(200, '<html></html>', {\n          'set-cookie': 'userId=123; Path=/',\n          'content-type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/login',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const setCookie = res.headers['set-cookie']\n\n          expect(setCookie[0]).to.eq('userId=123; Path=/')\n\n          expect(setCookie[1]).to.eq('__cypress.initial=; Domain=localhost; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT')\n        })\n      })\n\n      it('appends cookies on redirects', function () {\n        nock(this.server._remoteOrigin)\n        .get('/login')\n        .reply(302, undefined, {\n          'location': '/dashboard',\n          'set-cookie': 'userId=123; Path=/',\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/login',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(302)\n\n          expect(res.headers['location']).to.eq('/dashboard')\n\n          expect(res.headers['set-cookie']).to.deep.eq([\n            'userId=123; Path=/',\n            '__cypress.initial=true; Domain=localhost; Path=/',\n          ])\n        })\n      })\n\n      it('passes invalid cookies', function () {\n        nock(this.server._remoteOrigin)\n        .get('/invalid')\n        .reply(200, 'OK', {\n          'set-cookie': [\n            'foo=bar; Path=/',\n            '___utmvmXluIZsM=fidJKOsDSdm; path=/; Max-Age=900',\n            '___utmvbXluIZsM=bZM\\n    XtQOGalF: VtR; path=/; Max-Age=900',\n          ],\n        })\n\n        return this.rp('http://localhost:8080/invalid')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.headers['set-cookie']).to.deep.eq([\n            'foo=bar; Path=/',\n            '___utmvmXluIZsM=fidJKOsDSdm; path=/; Max-Age=900',\n            '___utmvbXluIZsM=bZM    XtQOGalF: VtR; path=/; Max-Age=900',\n          ])\n        })\n      })\n\n      it('forwards other headers from incoming responses', function () {\n        nock(this.server._remoteOrigin)\n        .get('/auth')\n        .reply(200, 'OK', {\n          'x-token': 'abc-123',\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/auth',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.headers['x-token']).to.eq('abc-123')\n        })\n      })\n\n      it('forwards headers to outgoing requests', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .matchHeader('x-custom', 'value')\n        .reply(200, 'hello from bar!', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n            'x-custom': 'value',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.include('hello from bar!')\n        })\n      })\n\n      it('omits x-frame-options', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, 'OK', {\n          'Content-Type': 'text/html',\n          'x-frame-options': 'SAMEORIGIN',\n        })\n\n        return this.rp('http://localhost:8080/bar')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.headers).not.to.have.property('x-frame-options')\n        })\n      })\n\n      it('omits content-security-policy', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, 'OK', {\n          'Content-Type': 'text/html',\n          'content-security-policy': 'foobar;',\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/bar',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.headers).not.to.have.property('content-security-policy')\n        })\n      })\n\n      it('omits content-security-policy-report-only', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, 'OK', {\n          'Content-Type': 'text/html',\n          'content-security-policy-report-only': 'foobar;',\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/bar',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.headers).not.to.have.property('content-security-policy-report-only')\n        })\n      })\n\n      it('omits document-domain from Feature-Policy header', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, 'OK', {\n          'Content-Type': 'text/html',\n          'Feature-Policy': 'camera *; document-domain \\'none\\'; autoplay \\'self\\'',\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/bar',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.headers['feature-policy']).to.include('camera *')\n          expect(res.headers['feature-policy']).to.include('autoplay \\'self\\'')\n\n          expect(res.headers['feature-policy']).not.to.include('document-domain \\'none\\'')\n        })\n      })\n\n      it('does not modify host origin header', function () {\n        return this.setup('http://foobar.com')\n        .then(() => {\n          nock(this.server._remoteOrigin)\n          .get('/css')\n          .matchHeader('host', 'foobar.com')\n          .reply(200)\n\n          return this.rp({\n            url: 'http://foobar.com/css',\n            headers: {\n              'Cookie': '__cypress.initial=false',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n          })\n        })\n      })\n\n      it('does not cache when initial response', function () {\n        nock(this.server._remoteOrigin)\n        .get('/')\n        .reply(200, 'hello from bar!', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.headers['cache-control']).to.eq('no-cache, no-store, must-revalidate')\n        })\n      })\n\n      it('does cache requesting resource without injection', function () {\n        nock(this.server._remoteOrigin)\n        .get('/')\n        .reply(200, 'hello from bar!', {\n          'Content-Type': 'text/plain',\n          'Cache-Control': 'max-age=86400',\n        })\n\n        return this.rp('http://localhost:8080/')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.headers['cache-control']).to.eq('max-age=86400')\n        })\n      })\n\n      it('forwards origin header', function () {\n        nock(this.server._remoteOrigin)\n        .get('/foo')\n        .matchHeader('host', 'localhost:8080')\n        .matchHeader('origin', 'http://localhost:8080')\n        .reply(200, '<html>origin</html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://localhost:8080/foo',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n            'Origin': 'http://localhost:8080',\n            'Accept': 'text/html, application/xhtml+xml, */*',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.include('origin')\n          expect(res.body).to.include('document.domain = \\'localhost\\'')\n\n          expect(res.body).not.to.include('Cypress')\n        })\n      })\n\n      it('issue #222 - correctly sets http host headers', function () {\n        const matches = (url, fn) => {\n          return this.setup(url)\n          .then(() => {\n            this.server.onRequest(fn)\n\n            return this.rp(url)\n          }).then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.body).to.eq('{}')\n          })\n        }\n\n        return matches('http://localhost:8080/app.css', () => {\n          return nock('http://localhost:8080')\n          .matchHeader('host', 'localhost:8080')\n          .get('/app.css')\n          .reply(200, '{}', {\n            'Content-Type': 'text/css',\n          })\n        }).then(() => {\n          return matches('http://127.0.0.1/app.css', () => {\n            return nock('http://127.0.0.1')\n            .matchHeader('host', '127.0.0.1')\n            .get('/app.css')\n            .reply(200, '{}', {\n              'Content-Type': 'text/css',\n            })\n          })\n        }).then(() => {\n          return matches('http://127.0.0.1:80/app2.css', () => {\n            return nock('http://127.0.0.1:80')\n            .matchHeader('host', '127.0.0.1')\n            .get('/app2.css')\n            .reply(200, '{}', {\n              'Content-Type': 'text/css',\n            })\n          })\n        }).then(() => {\n          return matches('https://www.google.com:443/app.css', () => {\n            return nock('https://www.google.com')\n            .matchHeader('host', 'www.google.com')\n            .get('/app.css')\n            .reply(200, '{}', {\n              'Content-Type': 'text/css',\n            })\n          })\n        }).then(() => {\n          return matches('https://www.apple.com/app.css', () => {\n            return nock('https://www.apple.com')\n            .matchHeader('host', 'www.apple.com')\n            .get('/app.css')\n            .reply(200, '{}', {\n              'Content-Type': 'text/css',\n            })\n          })\n        })\n      })\n\n      context('authorization', () => {\n        it('attaches auth headers when matches origin', function () {\n          const username = 'u'\n          const password = 'p'\n\n          const base64 = Buffer.from(`${username}:${password}`).toString('base64')\n\n          this.server._remoteAuth = {\n            username,\n            password,\n          }\n\n          nock('http://localhost:8080')\n          .get('/index')\n          .matchHeader('authorization', `Basic ${base64}`)\n          .reply(200, '')\n\n          return this.rp('http://localhost:8080/index')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n          })\n        })\n\n        it('does not attach auth headers when not matching origin', function () {\n          nock('http://localhost:8080', {\n            badheaders: ['authorization'],\n          })\n          .get('/index')\n          .reply(200, '')\n\n          return this.rp('http://localhost:8080/index')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n          })\n        })\n\n        it('does not modify existing auth headers when matching origin', function () {\n          const existing = 'Basic asdf'\n\n          this.server._remoteAuth = {\n            username: 'u',\n            password: 'p',\n          }\n\n          nock('http://localhost:8080')\n          .get('/index')\n          .matchHeader('authorization', existing)\n          .reply(200, '')\n\n          return this.rp({\n            url: 'http://localhost:8080/index',\n            headers: {\n              'Authorization': existing,\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n          })\n        })\n\n        // https://github.com/cypress-io/cypress/issues/4267\n        it('doesn\\'t attach auth headers to a diff protection space on the same origin', function () {\n          return this.setup('http://beta.something.com')\n          .then(() => {\n            const username = 'u'\n            const password = 'p'\n\n            const base64 = Buffer.from(`${username}:${password}`).toString('base64')\n\n            this.server._remoteAuth = {\n              username,\n              password,\n            }\n\n            nock(/.*\\.something.com/)\n            .get('/index')\n            .matchHeader('authorization', `Basic ${base64}`)\n            .reply(200, '')\n            .get('/index')\n            .matchHeader('authorization', _.isUndefined)\n            .reply(200, '')\n\n            return this.rp('http://beta.something.com/index')\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n\n              return this.rp('http://cdn.something.com/index')\n            }).then((res) => {\n              expect(res.statusCode).to.eq(200)\n            })\n          })\n        })\n      })\n    })\n\n    context('images', () => {\n      beforeEach(() => {\n        return Fixtures.scaffold()\n      })\n\n      it('passes the bytes through without injection on http servers', function () {\n        const image = Fixtures.projectPath('e2e/static/javascript-logo.png')\n\n        return Promise.all([\n          fs.statAsync(image).get('size'),\n          fs.readFileAsync(image, 'utf8'),\n          this.setup('http://localhost:8881'),\n        ])\n        .spread((size, bytes, setup) => {\n          nock(this.server._remoteOrigin)\n          .get('/javascript-logo.png')\n          .replyWithFile(200, image, {\n            'Content-Type': 'image/png',\n          })\n\n          return this.rp({\n            url: 'http://localhost:8881/javascript-logo.png',\n            headers: {\n              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.body).not.to.include('<script')\n\n            expect(res.body).to.eq(bytes)\n          })\n        })\n      })\n\n      it('passes the bytes through without injection on http servers with gzip', function () {\n        const image = Fixtures.projectPath('e2e/static/javascript-logo.png')\n        const zipped = Fixtures.projectPath('e2e/static/javascript-logo.png.gz')\n\n        return Promise.all([\n          fs.statAsync(image).get('size'),\n          fs.readFileAsync(image, 'utf8'),\n          this.setup('http://localhost:8881'),\n        ])\n        .spread((size, bytes, setup) => {\n          nock(this.server._remoteOrigin)\n          .get('/javascript-logo.png')\n          .replyWithFile(200, zipped, {\n            'Content-Type': 'image/png',\n            'Content-Encoding': 'gzip',\n          })\n\n          return this.rp({\n            url: 'http://localhost:8881/javascript-logo.png',\n            gzip: true,\n            headers: {\n              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.body).not.to.include('<script')\n\n            expect(res.body).to.eq(bytes)\n          })\n        })\n      })\n    })\n\n    context('woff', () => {\n      beforeEach(() => {\n        return Fixtures.scaffold()\n      })\n\n      it('passes the bytes through without injection', function () {\n        const font = Fixtures.projectPath('e2e/static/FiraSans-Regular.woff')\n\n        return Promise.all([\n          fs.statAsync(font).get('size'),\n          fs.readFileAsync(font, 'utf8'),\n          this.setup('http://localhost:8881'),\n        ])\n        .spread((size, bytes, setup) => {\n          nock(this.server._remoteOrigin)\n          .get('/font.woff')\n          .replyWithFile(200, font, {\n            'Content-Type': 'application/font-woff; charset=utf-8',\n          })\n\n          return this.rp({\n            url: 'http://localhost:8881/font.woff',\n            headers: {\n              'Accept': '*/*',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.body).not.to.include('<script')\n\n            expect(res.body).to.eq(bytes)\n          })\n        })\n      })\n    })\n\n    context('svg', () => {\n      beforeEach(function () {\n        return this.setup('http://www.google.com')\n      })\n\n      it('rewrites <svg> without hanging', function () {\n        // if this test finishes without timing out we know its all good\n        const contents = removeWhitespace(Fixtures.get('server/err_response.html'))\n\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, contents, {\n          'Content-Type': 'text/html; charset=utf-8',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n        })\n      })\n    })\n\n    context('content injection', () => {\n      beforeEach(function () {\n        return this.setup('http://www.google.com')\n      })\n\n      it('injects when head has attributes', async function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<html> <head prefix=\"og: foo\"> <meta name=\"foo\" content=\"bar\"> </head> <body>hello from bar!</body> </html>', {\n          'Content-Type': 'text/html',\n        })\n\n        const injection = await runner.getInjectionContents()\n        const contents = removeWhitespace(Fixtures.get('server/expected_head_inject.html').replace('{{injection}}', injection))\n        const res = await this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        const body = cleanResponseBody(res.body)\n\n        expect(res.statusCode).to.eq(200)\n        expect(body).to.eq(contents)\n      })\n\n      it('injects even when head tag is missing', async function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<html> <body>hello from bar!</body> </html>', {\n          'Content-Type': 'text/html',\n        })\n\n        const injection = await runner.getInjectionContents()\n        const contents = removeWhitespace(Fixtures.get('server/expected_no_head_tag_inject.html').replace('{{injection}}', injection))\n\n        const res = await this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        const body = cleanResponseBody(res.body)\n\n        expect(res.statusCode).to.eq(200)\n        expect(body).to.eq(contents)\n      })\n\n      it('injects when head is capitalized', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<HTML> <HEAD>hello from bar!</HEAD> </HTML>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.include('<HTML> <HEAD> <script type=\\'text/javascript\\'> document.domain = \\'google.com\\';')\n        })\n      })\n\n      it('injects when head missing but has <header>', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<html> <body><nav>some nav</nav><header>header</header></body> </html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.include('<html> <head> <script type=\\'text/javascript\\'> document.domain = \\'google.com\\';')\n\n          expect(res.body).to.include('</head> <body><nav>some nav</nav><header>header</header></body> </html>')\n        })\n      })\n\n      it('injects when body is capitalized', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<HTML> <BODY>hello from bar!</BODY> </HTML>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.include('</script> </head> <BODY>hello from bar!</BODY> </HTML>')\n        })\n      })\n\n      it('injects when both head + body are missing', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<HTML>hello from bar!</HTML>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.include('<HTML> <head> <script')\n\n          expect(res.body).to.include('</head>hello from bar!</HTML>')\n        })\n      })\n\n      it('injects even when html + head + body are missing', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<div>hello from bar!</div>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.include('<head> <script')\n\n          expect(res.body).to.include('</head><div>hello from bar!</div>')\n        })\n      })\n\n      it('injects after DOCTYPE declaration when no other content', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<!DOCTYPE>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.include('<!DOCTYPE><head> <script')\n        })\n      })\n\n      it('injects superdomain even when head tag is missing', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<html> <body>hello from bar!</body> </html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.eq('<html> <head> <script type=\\'text/javascript\\'> document.domain = \\'google.com\\'; </script> </head> <body>hello from bar!</body> </html>')\n        })\n      })\n\n      it('injects content after following redirect', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(302, undefined, {\n          // redirect us to google.com!\n          'Location': 'http://www.google.com/foo',\n        })\n\n        nock(this.server._remoteOrigin)\n        .get('/foo')\n        .reply(200, '<html> <head prefix=\"og: foo\"> <title>foo</title> </head> <body>hello from bar!</body> </html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(302)\n          expect(res.headers['location']).to.eq('http://www.google.com/foo')\n          expect(res.headers['set-cookie']).to.match(/initial=true/)\n\n          return this.rp(res.headers['location'])\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.headers['set-cookie']).to.match(/initial=;/)\n\n            expect(res.body).to.include('parent.Cypress')\n          })\n        })\n      })\n\n      it('injects performantly on a huge amount of elements over http', function () {\n        Fixtures.scaffold()\n\n        nock(this.server._remoteOrigin)\n        .get('/elements.html')\n        .replyWithFile(200, Fixtures.projectPath('e2e/elements.html'), {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/elements.html',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.include('document.domain = \\'google.com\\';')\n        })\n      })\n\n      it('injects performantly on a huge amount of elements over file', function () {\n        Fixtures.scaffold()\n\n        return this.setup('/index.html', {\n          projectRoot: Fixtures.projectPath('e2e'),\n        })\n        .then(() => {\n          return this.rp({\n            url: `${this.proxy}/elements.html`,\n            headers: {\n              'Cookie': '__cypress.initial=true',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.body).to.include('document.domain = \\'localhost\\';')\n          })\n        })\n      })\n\n      it('does not inject when not initial and not html', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<html><head></head></html>', {\n          'Content-Type': 'text/plain',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.eq('<html><head></head></html>')\n        })\n      })\n\n      it('injects into https server', async function () {\n        await this.setup('https://localhost:8443')\n\n        const injection = await runner.getInjectionContents()\n        const contents = removeWhitespace(Fixtures.get('server/expected_https_inject.html').replace('{{injection}}', injection))\n        const res = await this.rp({\n          url: 'https://localhost:8443/',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        const body = cleanResponseBody(res.body)\n\n        expect(res.statusCode).to.eq(200)\n        expect(body).to.eq(contents)\n      })\n\n      it('injects into https://www.google.com', function () {\n        return this.setup('https://www.google.com')\n        .then(() => {\n          this.server.onRequest((req, res) => {\n            return nock('https://www.google.com')\n            .get('/')\n            .reply(200, '<html><head></head><body>google</body></html>', {\n              'Content-Type': 'text/html',\n            })\n          })\n\n          return this.rp({\n            url: 'https://www.google.com/',\n            headers: {\n              'Cookie': '__cypress.initial=true',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.body).to.include('parent.Cypress')\n          })\n        })\n      })\n\n      it('injects even on 5xx responses', function () {\n        return this.setup('https://www.google.com')\n        .then(() => {\n          this.server.onRequest((req, res) => {\n            return nock('https://www.google.com')\n            .get('/')\n            .reply(500, '<html><head></head><body>google</body></html>', {\n              'Content-Type': 'text/html',\n            })\n          })\n\n          return this.rp({\n            url: 'https://www.google.com/',\n            headers: {\n              'Accept': 'text/html, application/xhtml+xml, */*',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(500)\n\n            expect(res.body).to.include('document.domain = \\'google.com\\'')\n          })\n        })\n      })\n\n      it('works with host swapping', async function () {\n        await this.setup('https://www.foobar.com:8443')\n        evilDns.add('*.foobar.com', '127.0.0.1')\n\n        const injection = await runner.getInjectionContents()\n        const contents = removeWhitespace(Fixtures.get('server/expected_https_inject.html').replace('{{injection}}', injection))\n        const res = await this.rp({\n          url: 'https://www.foobar.com:8443/index.html',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        const body = cleanResponseBody(res.body)\n\n        expect(res.statusCode).to.eq(200)\n        expect(body).to.eq(contents.replace('localhost', 'foobar.com'))\n      })\n\n      it('continues to inject on the same https superdomain but different subdomain', async function () {\n        await this.setup('https://www.foobar.com:8443')\n        evilDns.add('*.foobar.com', '127.0.0.1')\n\n        const injection = await runner.getInjectionContents()\n        const contents = removeWhitespace(Fixtures.get('server/expected_https_inject.html').replace('{{injection}}', injection))\n        const res = await this.rp({\n          url: 'https://docs.foobar.com:8443/index.html',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n          },\n        })\n        const body = cleanResponseBody(res.body)\n\n        expect(res.statusCode).to.eq(200)\n        expect(body).to.eq(contents.replace('localhost', 'foobar.com'))\n      })\n\n      it('injects document.domain on https requests to same superdomain but different subdomain', function () {\n        return this.setup('https://www.foobar.com:8443')\n        .then(() => {\n          evilDns.add('*.foobar.com', '127.0.0.1')\n\n          return this.rp({\n            url: 'https://docs.foobar.com:8443/index.html',\n            headers: {\n              'Cookie': '__cypress.initial=false',\n              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            const body = cleanResponseBody(res.body)\n\n            expect(body).to.eq('<html><head> <script type=\\'text/javascript\\'> document.domain = \\'foobar.com\\'; </script></head><body>https server</body></html>')\n          })\n        })\n      })\n\n      it('injects document.domain on other http requests', function () {\n        nock(this.server._remoteOrigin)\n        .get('/iframe')\n        .reply(200, '<html><head></head></html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/iframe',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const body = cleanResponseBody(res.body)\n\n          expect(body).to.eq('<html><head> <script type=\\'text/javascript\\'> document.domain = \\'google.com\\'; </script></head></html>')\n        })\n      })\n\n      it('injects document.domain on matching super domains but different subdomain', function () {\n        nock('http://mail.google.com')\n        .get('/iframe')\n        .reply(200, '<html><head></head></html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://mail.google.com/iframe',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const body = cleanResponseBody(res.body)\n\n          expect(body).to.eq('<html><head> <script type=\\'text/javascript\\'> document.domain = \\'google.com\\'; </script></head></html>')\n        })\n      })\n\n      it('does not inject document.domain on non http requests', function () {\n        nock(this.server._remoteOrigin)\n        .get('/json')\n        .reply(200, {\n          foo: '<html><head></head></html>',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/json',\n          json: true,\n          headers: {\n            'Cookie': '__cypress.initial=false',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.deep.eq({ foo: '<html><head></head></html>' })\n        })\n      })\n\n      it('does not inject document.domain on http requests which do not match current superDomain', function () {\n        nock('http://www.foobar.com')\n        .get('/')\n        .reply(200, '<html><head></head><body>hi</body></html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.foobar.com',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.eq('<html><head></head><body>hi</body></html>')\n        })\n      })\n\n      it('does not inject anything when not text/html response content-type even when __cypress.initial=true', function () {\n        nock(this.server._remoteOrigin)\n        .get('/json')\n        .reply(200, { foo: 'bar' })\n\n        return this.rp({\n          url: 'http://www.google.com/json',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n            'Accept': 'application/json',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.eq(JSON.stringify({ foo: 'bar' }))\n\n          // it should not be telling us to turn this off either\n          expect(res.headers['set-cookie']).not.to.match(/initial/)\n        })\n      })\n\n      it('does not inject into x-requested-with request headers', function () {\n        nock(this.server._remoteOrigin)\n        .get('/iframe')\n        .reply(200, '<html><head></head></html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/iframe',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n            'X-Requested-With': 'XMLHttpRequest',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const body = cleanResponseBody(res.body)\n\n          expect(body).to.eq('<html><head></head></html>')\n        })\n      })\n\n      return ['text/html', 'application/xhtml+xml', 'text/plain, application/xhtml+xml', '', null].forEach((type) => {\n        it(`does not inject unless both text/html and application/xhtml+xml is requested: tried to accept: ${type}`, function () {\n          nock(this.server._remoteOrigin)\n          .get('/iframe')\n          .reply(200, '<html><head></head></html>', {\n            'Content-Type': 'text/html',\n          })\n\n          const headers = {\n            'Cookie': '__cypress.initial=false',\n          }\n\n          headers['Accept'] = type\n\n          return this.rp({\n            url: 'http://www.google.com/iframe',\n            headers,\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            const body = cleanResponseBody(res.body)\n\n            expect(body).to.eq('<html><head></head></html>')\n          })\n        })\n      })\n    })\n\n    context('security rewriting', () => {\n      describe('on by default', () => {\n        beforeEach(function () {\n          return this.setup('http://www.google.com')\n        })\n\n        it('replaces obstructive code in HTML files', function () {\n          const html = '<html><body><script>if (top !== self) { }</script></body></html>'\n\n          nock(this.server._remoteOrigin)\n          .get('/index.html')\n          .reply(200, html, {\n            'Content-Type': 'text/html',\n          })\n\n          return this.rp({\n            url: 'http://www.google.com/index.html',\n            headers: {\n              'Cookie': '__cypress.initial=true',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.body).to.include(\n              '<script>if (self !== self) { }</script>',\n            )\n          })\n        })\n\n        it('replaces obstructive code in JS files', function () {\n          nock(this.server._remoteOrigin)\n          .get('/app.js')\n          .reply(200, 'if (top !== self) { }', {\n            'Content-Type': 'application/javascript',\n          })\n\n          return this.rp('http://www.google.com/app.js')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.body).to.eq(\n              'if (self !== self) { }',\n            )\n          })\n        })\n\n        it('handles multi-byte characters correctly when injecting', function () {\n          const bytes = `0${Array(16 * 1024 * 10).fill('λφ').join('')}`\n\n          const response = `<html>${bytes}</html>`\n\n          return zlib.gzipAsync(response)\n          .then((resp) => {\n            nock(this.server._remoteOrigin)\n            .get('/index.html')\n            .reply(200, resp, {\n              'Content-Type': 'text/html',\n              'Content-Encoding': 'gzip',\n            })\n\n            return this.rp({\n              url: 'http://www.google.com/index.html',\n              gzip: true,\n              headers: {\n                'Cookie': '__cypress.initial=true',\n              },\n            })\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n\n              expect(res.body).to.include(`${bytes}</html>`)\n            })\n          })\n        })\n\n        // https://github.com/cypress-io/cypress/issues/1396\n        it('handles multi-byte characters correctly on JS files', function () {\n          const response = `0${Array(16 * 1024 * 2).fill('λφ').join('')}`\n\n          return zlib.gzipAsync(response)\n          .then((resp) => {\n            nock(this.server._remoteOrigin)\n            .get('/index.js')\n            .reply(200, resp, {\n              'Content-Type': 'application/javascript',\n              'Content-Encoding': 'gzip',\n            })\n\n            return this.rp({\n              url: 'http://www.google.com/index.js',\n              gzip: true,\n            })\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n\n              expect(res.body).to.eq(response)\n            })\n          })\n        })\n\n        // https://github.com/cypress-io/cypress/issues/1756\n        // https://github.com/nodejs/node/issues/5761\n        it('handles gzip responses that are slightly truncated', function () {\n          const response = 'I am a gzipped response'\n\n          return zlib.gzipAsync(response)\n          .then((resp) => {\n            nock(this.server._remoteOrigin)\n            .get('/app.js')\n            // remove the last 8 characters which\n            // truncates the CRC checksum and size check\n            // at the end of the stream\n            .reply(200, resp.slice(0, -8), {\n              'Content-Type': 'application/javascript',\n              'Content-Encoding': 'gzip',\n            })\n\n            return this.rp({\n              url: 'http://www.google.com/app.js',\n              gzip: true,\n            })\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n\n              expect(res.body).to.eq(response)\n            })\n          })\n        })\n\n        it('handles gzip responses that are slightly truncated when injecting', function () {\n          const response = '<html>I am a gzipped response</html>'\n\n          return zlib.gzipAsync(response)\n          .then((resp) => {\n            nock(this.server._remoteOrigin)\n            .get('/index.html')\n            // remove the last 8 characters which\n            // truncates the CRC checksum and size check\n            // at the end of the stream\n            .reply(200, resp.slice(0, -8), {\n              'Content-Type': 'text/html',\n              'Content-Encoding': 'gzip',\n            })\n\n            return this.rp({\n              url: 'http://www.google.com/index.html',\n              gzip: true,\n              headers: {\n                'Cookie': '__cypress.initial=true',\n              },\n            })\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n\n              expect(res.body).to.include('I am a gzipped response</html>')\n            })\n          })\n        })\n\n        it('ECONNRESETs bad gzip responses when not injecting', function (done) {\n          nock(this.server._remoteOrigin)\n          .get('/app.js')\n          .delayBody(100)\n          .replyWithFile(200, Fixtures.path('server/gzip-bad.html.gz'), {\n            'Content-Type': 'application/javascript',\n            'Content-Encoding': 'gzip',\n          })\n\n          return this.r({\n            url: 'http://www.google.com/app.js',\n            gzip: true,\n          })\n          .on('error', (err) => {\n            expect(err.code).to.eq('ECONNRESET')\n\n            return done()\n          })\n        })\n\n        it('ECONNRESETs bad gzip responses when injecting', function () {\n          nock(this.server._remoteOrigin)\n          .get('/index.html')\n          .replyWithFile(200, Fixtures.path('server/gzip-bad.html.gz'), {\n            'Content-Type': 'text/html',\n            'Content-Encoding': 'gzip',\n          })\n\n          return this.rp({\n            url: 'http://www.google.com/index.html',\n            gzip: true,\n            headers: {\n              'Cookie': '__cypress.initial=true',\n            },\n          })\n          .then(() => {\n            throw new Error('should not reach')\n          }).catch((err) => {\n            expect(err.error.code).to.eq('ECONNRESET')\n          })\n        })\n\n        it('does not die rewriting a huge JS file', function () {\n          const pathToHugeAppJs = Fixtures.path('server/libs/huge_app.js')\n\n          const getHugeFile = () => {\n            return rp('https://s3.amazonaws.com/internal-test-runner-assets.cypress.io/huge_app.js')\n            .then((resp) => {\n              return fs\n              .outputFileAsync(pathToHugeAppJs, resp)\n              .return(resp)\n            })\n          }\n\n          return fs\n          .readFileAsync(pathToHugeAppJs, 'utf8')\n          .catch(getHugeFile)\n          .then((hugeJsFile) => {\n            nock(this.server._remoteOrigin)\n            .get('/app.js')\n            .reply(200, hugeJsFile, {\n              'Content-Type': 'application/javascript',\n            })\n\n            let reqTime = new Date()\n\n            return this.rp('http://www.google.com/app.js')\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n\n              reqTime = new Date() - reqTime\n\n              // shouldn't be more than 500ms\n              expect(reqTime).to.be.lt(500)\n            })\n          })\n        })\n      })\n\n      describe('off with config', () => {\n        beforeEach(function () {\n          return this.setup('http://www.google.com', {\n            config: {\n              modifyObstructiveCode: false,\n            },\n          })\n        })\n\n        it('can turn off security rewriting for HTML', function () {\n          const html = '<html><body><script>if (top !== self) { }</script></body></html>'\n\n          nock(this.server._remoteOrigin)\n          .get('/index.html')\n          .reply(200, html, {\n            'Content-Type': 'text/html',\n          })\n\n          return this.rp({\n            url: 'http://www.google.com/index.html',\n            headers: {\n              'Cookie': '__cypress.initial=true',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.body).to.include(\n              '<script>if (top !== self) { }</script>',\n            )\n          })\n        })\n\n        it('does not replaces obstructive code in JS files', function () {\n          nock(this.server._remoteOrigin)\n          .get('/app.js')\n          .reply(200, 'if (top !== self) { }', {\n            'Content-Type': 'application/javascript',\n          })\n\n          return this.rp('http://www.google.com/app.js')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(res.body).to.eq(\n              'if (top !== self) { }',\n            )\n          })\n        })\n      })\n    })\n\n    context('FQDN rewriting', () => {\n      beforeEach(function () {\n        return this.setup('http://www.google.com')\n      })\n\n      it('does not rewrite html when initial', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<html><body><a href=\\'http://www.google.com\\'>google</a></body></html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=true',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const {\n            body,\n          } = res\n\n          expect(body).to.include('<a href=\\'http://www.google.com\\'>google</a>')\n        })\n      })\n\n      it('does not rewrite html when not initial', function () {\n        nock(this.server._remoteOrigin)\n        .get('/bar')\n        .reply(200, '<html><body><a href=\\'http://www.google.com\\'>google</a></body></html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.rp({\n          url: 'http://www.google.com/bar',\n          headers: {\n            'Cookie': '__cypress.initial=false',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          const {\n            body,\n          } = res\n\n          expect(body).to.include('<a href=\\'http://www.google.com\\'>google</a>')\n        })\n      })\n    })\n\n    context('file requests', () => {\n      beforeEach(function () {\n        Fixtures.scaffold()\n\n        return this.setup('/index.html', {\n          projectRoot: Fixtures.projectPath('no-server'),\n          config: {\n            fileServerFolder: 'dev',\n            integrationFolder: 'my-tests',\n          },\n        })\n        .then(() => {\n          return this.rp({\n            url: `${this.proxy}/index.html`,\n            headers: {\n              'Cookie': '__cypress.initial=true',\n              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n            },\n          })\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.body).to.include('index.html content')\n            expect(res.body).to.include('parent.Cypress')\n\n            expect(res.headers['set-cookie']).to.match(/initial=;/)\n            expect(res.headers['cache-control']).to.eq('no-cache, no-store, must-revalidate')\n            expect(res.headers['etag']).to.exist\n\n            expect(res.headers['last-modified']).to.exist\n          })\n        })\n      })\n\n      it('sets etag', function () {\n        return this.rp(`${this.proxy}/assets/app.css`)\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.eq('html { color: black; }')\n\n          expect(res.headers['etag']).to.be.a('string')\n        })\n      })\n\n      it('sets last-modified', function () {\n        return this.rp(`${this.proxy}/assets/app.css`)\n        .then((res) => {\n          expect(res.headers['last-modified']).to.be.a('string')\n        })\n      })\n\n      it('streams from file system', function () {\n        return this.rp(`${this.proxy}/assets/app.css`)\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.eq('html { color: black; }')\n        })\n      })\n\n      it('sets content-type', function () {\n        return this.rp(`${this.proxy}/assets/app.css`)\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.headers['content-type']).to.match(/text\\/css/)\n        })\n      })\n\n      it('disregards anything past the pathname', function () {\n        return this.rp(`${this.proxy}/assets/app.css?foo=bar#hash`)\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.eq('html { color: black; }')\n        })\n      })\n\n      it('can serve files with spaces in the path', function () {\n        return this.rp(`${this.proxy}/a space/foo.txt`)\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.eq('foo')\n        })\n      })\n\n      it('sets x-cypress-file-path headers', function () {\n        return this.rp(`${this.proxy}/assets/app.css`)\n        .then((res) => {\n          expect(res.headers).to.have.property('x-cypress-file-path', `${Fixtures.projectPath('no-server')}/dev/assets/app.css`)\n        })\n      })\n\n      it('sets x-cypress-file-server-error headers on error', function () {\n        return this.rp(`${this.proxy}/does-not-exist.html`)\n        .then((res) => {\n          expect(res.statusCode).to.eq(404)\n\n          expect(res.headers).to.have.property('x-cypress-file-server-error', 'true')\n        })\n      })\n\n      it('injects document.domain on other http requests', function () {\n        return this.rp({\n          url: `${this.proxy}/index.html`,\n          headers: {\n            'Cookie': '__cypress.initial=false',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.include('document.domain = \\'localhost\\';')\n        })\n      })\n\n      it('injects document.domain on other http requests to root', function () {\n        return this.rp({\n          url: `${this.proxy}/sub/`,\n          headers: {\n            'Cookie': '__cypress.initial=false',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.include('document.domain = \\'localhost\\';')\n        })\n      })\n\n      it('does not inject injects document.domain on 301 redirects to folders', function () {\n        return this.rp({\n          url: `${this.proxy}/sub`,\n          headers: {\n            'Cookie': '__cypress.initial=false',\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(301)\n\n          expect(res.body).not.to.include('document.domain = \\'localhost\\';')\n        })\n      })\n\n      it('does not inject document.domain on non http requests', function () {\n        return this.rp({\n          url: `${this.proxy}/assets/foo.json`,\n          json: true,\n          headers: {\n            'Cookie': '__cypress.initial=false',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.deep.eq({ contents: '<html><head></head></html>' })\n        })\n      })\n\n      it('does not inject anything when not text/html response content-type even when __cypress.initial=true', function () {\n        return this.rp({\n          url: `${this.proxy}/assets/foo.json`,\n          headers: {\n            'Cookie': '__cypress.initial=true',\n            'Accept': 'application/json',\n          },\n        })\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n          expect(res.body).to.deep.eq(JSON.stringify({ contents: '<html><head></head></html>' }, null, 2))\n\n          // it should not be telling us to turn this off either\n          expect(res.headers['set-cookie']).not.to.match(/initial/)\n        })\n      })\n    })\n\n    context('http requests', () => {\n      beforeEach(function () {\n        return this.setup('http://getbootstrap.com')\n        .then(() => {\n          nock(this.server._remoteOrigin)\n          .get('/components')\n          .reply(200, 'content page', {\n            'Content-Type': 'text/html',\n          })\n\n          return this.rp('http://getbootstrap.com/components')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n          })\n        })\n      })\n\n      it('proxies http requests', function () {\n        nock(this.server._remoteOrigin)\n        .get('/assets/css/application.css')\n        .reply(200, 'html { color: #333 }', {\n          'Content-Type': 'text/css',\n        })\n\n        return this.rp('http://getbootstrap.com/assets/css/application.css')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.eq('html { color: #333 }')\n        })\n      })\n    })\n\n    context('when session is already set', () => {\n      beforeEach(function () {\n        return this.setup('http://getbootstrap.com')\n        .then(() => {\n          // make an initial request to set the\n          // session proxy!\n          nock(this.server._remoteOrigin)\n          .get('/css')\n          .reply(200, 'css content page', {\n            'Content-Type': 'text/html',\n          })\n\n          return this.rp('http://getbootstrap.com/css')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n          })\n        })\n      })\n\n      it('proxies to the remote session', function () {\n        nock(this.server._remoteOrigin)\n        .get('/assets/css/application.css')\n        .reply(200, 'html { color: #333 }', {\n          'Content-Type': 'text/css',\n        })\n\n        return this.rp('http://getbootstrap.com/assets/css/application.css')\n        .then((res) => {\n          expect(res.statusCode).to.eq(200)\n\n          expect(res.body).to.eq('html { color: #333 }')\n        })\n      })\n    })\n\n    context('localhost', () => {\n      beforeEach(function () {\n        return this.setup('http://localhost:6565')\n      })\n\n      it('makes requests to ipv6 when ipv4 fails', function (done) {\n        // make sure that this test times out relatively fast\n        // to ensure that requests are fast, the retrying functionality\n        // does not extend them, and that the server closes quickly\n        // due to the reduced keep alive timeout\n        this.timeout(1500)\n\n        return dns.lookup('localhost', { all: true }, (err, addresses) => {\n          if (err) {\n            return done(err)\n          }\n\n          // if we dont have multiple addresses aka ipv6 then\n          // just skip this test\n          if (!_.find(addresses, { family: 6 })) {\n            return done()\n          }\n\n          // create a server that is only bound to ipv6\n          // and ensure that it is found by localhost dns lookup\n          const server = http.createServer((req, res) => {\n            res.writeHead(200)\n\n            return res.end()\n          })\n\n          // reduce this down from 5000ms to 100ms\n          // so that our server closes much faster\n          server.keepAliveTimeout = 100\n\n          // start the server listening on ipv6 only\n          // for demo how to bind to localhost via ipv6 see project\n          // https://github.com/bahmutov/docker-ip6\n          return server.listen(6565, '::', () => {\n            return this.rp('http://localhost:6565/#/foo')\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n\n              return server.close(() => {\n                return done()\n              })\n            })\n          })\n        })\n      })\n\n      it('handles 204 no content status codes', function () {\n        nock('http://localhost:6565')\n        .get('/user/rooms')\n        .reply(204, '')\n\n        return this.rp('http://localhost:6565/user/rooms')\n        .then((res) => {\n          expect(res.statusCode).to.eq(204)\n\n          expect(res.body).to.eq('')\n        })\n      })\n    })\n\n    context('blocked hosts', () => {\n      beforeEach(function () {\n        return this.setup({\n          config: {\n            blockHosts: [\n              '*.google.com',\n              'shop.apple.com',\n              'cypress.io',\n              'localhost:6666',\n              '*adwords.com',\n            ],\n          },\n        })\n      })\n\n      it('returns 503 and custom headers for all hosts', function () {\n        const expectedHeader = (res, val) => {\n          expect(res.headers['x-cypress-matched-blocked-host']).to.eq(val)\n        }\n\n        return Promise.all([\n          this.rp('https://mail.google.com/f'),\n          this.rp('http://shop.apple.com/o'),\n          this.rp('https://cypress.io'),\n          this.rp('https://localhost:6666/o'),\n          this.rp('https://some.adwords.com'),\n        ])\n        .spread((...responses) => {\n          _.every(responses, (res) => {\n            expect(res.statusCode).to.eq(503)\n\n            expect(res.body).to.be.empty\n          })\n\n          expectedHeader(responses[0], '*.google.com')\n          expectedHeader(responses[1], 'shop.apple.com')\n          expectedHeader(responses[2], 'cypress.io')\n          expectedHeader(responses[3], 'localhost:6666')\n\n          return expectedHeader(responses[4], '*adwords.com')\n        })\n      })\n    })\n\n    context('client aborts', () => {\n      beforeEach(function () {\n        return this.setup('http://localhost:6565')\n      })\n\n      it('aborts the proxied request', function (done) {\n        fs\n        .readFileAsync(Fixtures.path('server/libs/huge_app.js'), 'utf8')\n        .then((str) => {\n          const server = http.createServer((req, res) => {\n            // when the incoming message to our\n            // 3rd party server is aborted then\n            // we know we've juggled up the event\n            // properly\n            req.on('aborted', () => {\n              return server.close(() => {\n                return done()\n              })\n            })\n\n            res.writeHead(200, {\n              'Content-Type': 'application/javascript',\n            })\n\n            // write some bytes, causing\n            // the response event to fire\n            // on our request\n            return res.write(str.slice(0, 10000))\n          })\n\n          return server.listen(6565, () => {\n            const abort = () => {\n              return r.abort()\n            }\n\n            r = this.r({\n              url: 'http://localhost:6565/app.js',\n            })\n            // abort when we get the\n            // response headers\n            .on('response', abort)\n          })\n        })\n      })\n    })\n\n    context('event source / server sent events / SSE', () => {\n      let onRequest = null\n\n      beforeEach(function () {\n        onRequest = function () {}\n\n        return this.setup('http://localhost:5959', {\n          config: {\n            responseTimeout: 50,\n          },\n        })\n        .then(() => {\n          this.srv = http.createServer((req, res) => {\n            onRequest(req, res)\n\n            this.sseStream = new SseStream(req)\n\n            return this.sseStream.pipe(res)\n          })\n\n          Promise.promisifyAll(this.srv)\n\n          return this.srv.listenAsync()\n          .then(() => {\n            this.port = this.srv.address().port\n          })\n        })\n      })\n\n      afterEach(function () {\n        return this.srv.closeAsync()\n      })\n\n      it('receives event source messages through the proxy', function (done) {\n        onRequest = function (req, res) {\n          // when the request is finally\n          // aborted then we know we've closed\n          // the connection correctly\n          const closed = new Promise((resolve) => {\n            return res.on('close', () => {\n              return resolve()\n            })\n          })\n\n          const aborted = new Promise((resolve) => {\n            return req.on('aborted', () => {\n              return resolve()\n            })\n          })\n\n          return Promise.join(aborted, closed)\n          .then(() => {\n            return done()\n          })\n        }\n\n        const es = new EventSource(`http://localhost:${this.port}/sse`, {\n          proxy: this.proxy,\n        })\n\n        es.onopen = () => {\n          return Promise\n          .delay(100)\n          .then(() => {\n            return this.sseStream.write({\n              data: 'hey',\n            })\n          })\n        }\n\n        es.onmessage = (m) => {\n          expect(m.data).to.eq('hey')\n\n          return es.close()\n        }\n      })\n    })\n\n    context('when body should be empty', function () {\n      this.timeout(1000)\n\n      beforeEach(function (done) {\n        this.httpSrv = http.createServer((req, res) => {\n          const { query } = url.parse(req.url, true)\n\n          if (_.has(query, 'chunked')) {\n            res.setHeader('tranfer-encoding', 'chunked')\n          } else {\n            res.setHeader('content-length', '0')\n          }\n\n          res.writeHead(Number(query.status), {\n            'x-foo': 'bar',\n          })\n\n          return res.end()\n        })\n\n        return this.httpSrv.listen(() => {\n          this.port = this.httpSrv.address().port\n\n          return this.setup(`http://localhost:${this.port}`)\n          .then(_.ary(done, 0))\n        })\n      })\n\n      afterEach(function () {\n        return this.httpSrv.close()\n      })\n\n      return [204, 304].forEach((status) => {\n        it(`passes through a ${status} response immediately`, function () {\n          return this.rp({\n            url: `http://localhost:${this.port}/?status=${status}`,\n            timeout: 100,\n          })\n          .then((res) => {\n            expect(res.headers['x-foo']).to.eq('bar')\n\n            expect(res.statusCode).to.eq(status)\n          })\n        })\n\n        it(`passes through a ${status} response with chunked encoding immediately`, function () {\n          return this.rp({\n            url: `http://localhost:${this.port}/?status=${status}&chunked`,\n            timeout: 100,\n          })\n          .then((res) => {\n            expect(res.headers['x-foo']).to.eq('bar')\n\n            expect(res.statusCode).to.eq(status)\n          })\n        })\n      })\n    })\n  })\n\n  context('POST *', () => {\n    beforeEach(function () {\n      return this.setup('http://localhost:8000')\n    })\n\n    it('processes POST + redirect on remote proxy', function () {\n      nock(this.server._remoteOrigin)\n      .post('/login', {\n        username: 'brian@cypress.io',\n        password: 'foobar',\n      })\n      .reply(302, undefined, {\n        'Location': '/dashboard',\n      })\n\n      return this.rp({\n        method: 'POST',\n        url: 'http://localhost:8000/login',\n        form: {\n          username: 'brian@cypress.io',\n          password: 'foobar',\n        },\n        headers: {\n          'Cookie': '__cypress.initial=false',\n        },\n      })\n      .then((res) => {\n        expect(res.statusCode).to.eq(302)\n\n        expect(res.headers['location']).to.match(/dashboard/)\n      })\n    })\n\n    // this happens on a real form submit because beforeunload fires\n    // and initial=true gets set\n    it('processes POST + redirect on remote initial', function () {\n      nock(this.server._remoteOrigin)\n      .post('/login', {\n        username: 'brian@cypress.io',\n        password: 'foobar',\n      })\n      .reply(302, undefined, {\n        'Location': '/dashboard',\n      })\n\n      return this.rp({\n        method: 'POST',\n        url: 'http://localhost:8000/login',\n        form: {\n          username: 'brian@cypress.io',\n          password: 'foobar',\n        },\n        headers: {\n          'Cookie': '__cypress.initial=true',\n        },\n      })\n      .then((res) => {\n        expect(res.statusCode).to.eq(302)\n        expect(res.headers['location']).to.match(/dashboard/)\n\n        expect(res.headers['set-cookie']).to.match(/initial=true/)\n      })\n    })\n\n    it('does not alter request headers', function () {\n      nock(this.server._remoteOrigin)\n      .matchHeader('x-csrf-token', 'abc-123')\n      .post('/login', {\n        username: 'brian@cypress.io',\n        password: 'foobar',\n      })\n      .reply(200, 'OK')\n\n      return this.rp({\n        method: 'POST',\n        url: 'http://localhost:8000/login',\n        form: {\n          username: 'brian@cypress.io',\n          password: 'foobar',\n        },\n        headers: {\n          'X-CSRF-Token': 'abc-123',\n        },\n      })\n      .then((res) => {\n        expect(res.statusCode).to.eq(200)\n\n        expect(res.body).to.eq('OK')\n      })\n    })\n\n    it('does not fail on a big cookie', function () {\n      nock(this.server._remoteOrigin)\n      .post('/login')\n      .reply(200)\n\n      return this.rp({\n        method: 'POST',\n        url: 'http://localhost:8000/login',\n        json: true,\n        body: {\n          'query': { 'bool': { 'must': [{ 'filtered': { 'filter': { 'term': { 'brand_id': 3 } } } }, { 'filtered': { 'filter': { 'term': { 'is_live': true } } } }, { 'filtered': { 'filter': { 'bool': { 'should': [{ 'term': { 'subcategory_id': 25 } }, { 'term': { 'subcategory_id': 21 } }] } } } }] } }, 'aggs': { 'colors.raw3': { 'filter': {}, 'aggs': { 'colors.raw': { 'terms': { 'field': 'colors.raw', 'size': 50 } }, 'colors.raw_count': { 'cardinality': { 'field': 'colors.raw' } } } }, 'patterns.raw4': { 'filter': {}, 'aggs': { 'patterns.raw': { 'terms': { 'field': 'patterns.raw', 'size': 50 } }, 'patterns.raw_count': { 'cardinality': { 'field': 'patterns.raw' } } } }, 'custom_filters_a.raw5': { 'filter': {}, 'aggs': { 'custom_filters_a.raw': { 'terms': { 'field': 'custom_filters_a.raw', 'size': 50 } }, 'custom_filters_a.raw_count': { 'cardinality': { 'field': 'custom_filters_a.raw' } } } }, 'custom_filters_b.raw6': { 'filter': {}, 'aggs': { 'custom_filters_b.raw': { 'terms': { 'field': 'custom_filters_b.raw', 'size': 50 } }, 'custom_filters_b.raw_count': { 'cardinality': { 'field': 'custom_filters_b.raw' } } } } }, 'size': 100,\n        },\n        headers: {\n          'Cookie': '_treebook_session=MmxpQUFjak1mZXN1L21FSnY2dzhJaWFPa0kxaXR2MFVMMTFKQnhFMTY0ZGhVZDJLV3BPUm9xT3BWREVDOFExTFBSaDEzY2htQTVVZ0dpZjg0VmF1SmRINlVSZ2ZFeFpzd0s3Yk4wakRxQS9TdW11N3ZURnIvbHAvQ2NTVjZWY0VqdFNQZTFHV09xclZnM0lDNE1JUzZzN3BWamF0dXRSM09uRFZZeWMwd01ESkdWUzY2MFE2QkY0cStIQnBwNGk0V3hhWkNVd0QwamtMeDJheWxxb04wZVkwRzJmdmVLZXJsR3M5UFAyK0Y3ST0tLTBFWmJwWktQaThrWnN6dUZVaVBGckE9PQ%3D%3D--a07f8cd3fc4db9a0c52676e274e71546a9f047fb; _my-site_session=NVp4akFGelljaFZJR3A4US9ES1ZBcTZ4K2ZqNklkUzNKZUVGU3RuQk1HSGZxenU1Z2VDOHBvTmdwL0x3c0E0TGEvTmZDWVR5Y205ZkVOZWwrYkdaWEV2V3k0T1h0elN1NjlsSWo1dFZqVG9nNy9MNWp6enoyZmdYSzYwb3d4WVlvMG9qVXlOTnNNSm1VYlpSSWc3bkFnPT0tLWhQcnVqQ0NQMGF6dVE0SCtRQk1sdmc9PQ%3D%3D--2d25be12c8415195314fe3990cad281c14022d9d; _first_app_session=ajBJcFpRa2dSR29MaTd5UUFnTU45dVZzd2tKeUY2enpuR1cyNFB2bVRCQ201RTh5bXAvaTdlN2NuRm1WeEJOZlkyTWtIRXhpZm1HTlZMM0hPeHVzWUkvQWNhUmNUcUNRRzlDbW8yMlA4SjFZSjhYQ1I4V0FNU3k2Um1mOHlQNU94SkdrT1ZmZS9PZHB6WDVGN0s4cGNnPT0tLTA0aE5hQStvbXQ5T1VXN0UrT3MxN0E9PQ%3D%3D--1daec80639465389f0e5437193e633eeb7bbfca9; _pet_store_session=N055S0M0azJlUlFJWGdDN01MQ3Z4aXFCWHNFU2ttZUp0SDJyL3BPeTVOdzBYWGROb1F1UWx2eG80ZjlobDF2QWJ4Rk5uVFliSWtMSEltZ2RUVDNZUVFLd2VYS3JTQldRbkNnMVdReVY0V1FyWjBNdTVjSk9SQUJNZ0JmMitEcG9JQnh0WVErY2lZaWo4WGJFeXpKUElBPT0tLUZDL2k3bUlKQUl4aGV3ZGEvQXRCaUE9PQ%3D%3D--a658fa7995dec5c7ec3e041d5dc5f52e4f7be0ee; _adventures_session=MDZDeDBDQmRJRFdpYzk5SWFEa0txd0xBVmQyei9xTUhQZ3VlZjNRcUY2c0VsWkZaNUo2SktlNGRvcFNrdDlqL0wzRnA4eVdpMTdMUjJlcHJuMkVWU05SdmNRa29QQU5HWlhxajRZcWNSY1lqR1RDZjhsQ3loUzMvd1M5V3ZCck5iMHRkQXgzcFAwRlBOMFFja2dURDFBPT0tLWMyMHZvcnV6OUIvS0tkeFFpTVA5Qnc9PQ%3D%3D--04a940aa32a208e9bfb6b422481e658f57411132; _classroom_session=NFRSY05TaHZZdkVMYkRZdXh5djQxSmxYY2xIaHJDamI3bGJuRjRxbDZCcWxCMVRxOVpkdWV2MnQ0ajBBNDdOb0ZtTUZPUkFLNmJ0SHFVUlJCZ3FUSjBvSUkxTzZpL1h6ZWhsVlJ6Z2xGRjhWamlVSHJ3NG1vZ3IxSC9PaUxkNVA0Q2x6ZDRTaXJxcGlvc0tsazdkRHFBPT0tLTZ1Z0hxcU16cmZoRTR1VHBqN3RkbXc9PQ%3D%3D--cea92642cc4ec52a81ad6892db90e0e8b8236069; _boo_scaffold_session=am5oQVhMN2ZQQlJBb2VUdDNtdUVic0NMeFlhWVJOa0Y5SEhERjdpUmd2aVZicnY0Z1VsL0hTWVNudTF0dm1SQWNKZHhzZmpJQi9FK1JZVXZwU3Q2RHNObmFWcVg5T0thYmUrY0k2YTJaQjMzUVp3MlRNenk3a2JxczdWZmF6MUxEaW1EejlxeWpUNjFack4rM3N1bm5yZlFKT3BTYnIvTTNNaG5haXZrMEFZWUp2cHBRQnNXbldLUkRZZlBuRDlWdWRldTJqYmh6K0lWWGRyVGpOUERtbFBQUFVHS1pOR3RtMmRuYUxLbjUvYXQra3UwcUxkK3BHRzFRR2RqMWVGay0tQU9DdlFMNEluVVJPTUNlbDh3L1Y0Zz09--c3e2745720ea2080dadaac45223d36ed15fd7fb4; _db_explore_session=RW5NUDlSaG5SVFF4Zms4YmRwQmhZaitrckhRVXN0VzlKS3E3M3Fxa0xwQmZGcDY1amlVOG5DRnpPQ3hLSVBoUFZ5b3lKWGd2Z0JZWnptMEREcU1DUE04SkRMN1RUbVUvUDFaTkNFcUpqQkZ0NmxjTkhrZHZlM1pibmIyTGQxZ3UzNVpvTUlDSnNhcUxBcHRJaVJqdENRPT0tLTBXWVhqK3lwcTVONzVLRVhnZldmQkE9PQ%3D%3D--10c607bc41831a8b4e80689d051a5cfc19872cc1; _furniture_store_session=cm5lTW9XR0ptc2lCSVJNY0c3dW1oVFlJdG9OaGh1OENhdjgyMW5Heis0RlB3ZkNPR2ZZUmdiV1VlbGY3NmdmdHU0cERBZGtpWGFUeHo5cHM4K1lKa053cEhrV2VaR3Q5RVYzZms0VVh2aFBrd2N6U3hzeWhZTEhnVG1qYldxNFZOemVTMGRkQmZQSEFHWEJZZWNQWS9BPT0tLWk1R0d0SW1pZVEyckRGK2R1Vzh4M0E9PQ%3D%3D--99c9ed2f5a43af5bc018d930b6210b50bf973a79; _travel_session=VEcxVlB4NTg0SGNHdjdOekZndW5Jc1FJY2VJd3NTaDhVVk4vNnVuekpWUVE2ekVhK25YVWVUemhOUnl2S3pVWTc3U0trTTI2cUVNakwyd254M3RMT0J2L0dheTdRUVpGY1FRd0FTT3pSaGpsK3kreVJxNVdMbWFsY3pWSVdMUU5mRzRzQnIzRzFNMS8zQThZQStLTE9nPT0tLVNMK2hsYjVpRmZNMngwUFI1QU0zemc9PQ%3D%3D--19113054b718f1b9c733427c9a3e110b60187f4f; _doctors_office_session=RGxTSWhxVm45am0rSGZVb25jRnBVdVRvcHIxbTR3dVZWdjYvYklGY3BVa2FnYm5sRXlNUlp2TmN2Q3R3NndxWnFFdStPT2ZieTVKaE1SMUpFM0ZUaFhUb3ZhbkxDbDlrZk9lUVh5dlRCY0hhQ1NVNUVKSjhJSnhyTkFkWi9FUm1UZis1VEhVb2tXQW9Qb2MrQU5IMHNRPT0tLUMxdlpYMEVKV081L3QveFBHMS9scWc9PQ%3D%3D--7a4196ea6b5194f412be549a0f30925ec6bd118f; _recipe_app_session=OE1saTRQZ1pRQnNrdHNCNllyNld3cnVTcnhqUjh0Q2NZaSt3eWlLbjljUWxMdk5seW9SVnQwcmZ4VVBhdWRDUE5qM1hWSi9QaW9adnVFalJ6VjJFVFFhWm1LZFB1ZXlzRzR1UFpDSks0V01pdWFuWk04bExMeDdvYWFZRU9OQm5qQ2ZKcXRLYUdiZmwvWTYwUCs4bnJBPT0tLVdtYkh4cmFJeHQrZXdoazFGSUo2aGc9PQ%3D%3D--1649c7bd76e8944a0911d9e6a59d5a82aa1a0559; _ajax-sample_session=ZDM2NU8xZTRocmxFUlR5ZjZhMGxUSkgzdmFOcVVrQ1ZUN1ZNMFliRGNuRFQ2SkNvV1pVdUlLRWVoY2dodWxQRjNiek84Y0dhdk44dkN6Sy9naDRsQjFRY2FVMXYzcXc3TkVzY28wMnp4OFdiWnBFMFEvNUltK1ZYUUd2THRMblpLVmJHOFIvMEVQaWpMV2dqamI1ZFBnPT0tLTJ4RURLbjVEYkZaSGpvdDk1RU9sNEE9PQ%3D%3D--f13942ae013f1252c609762922b21b8a233b36ed; _stripe_test_session=RnRoMngvN0IwVjBENElrY0w1eStwOGYxdDgxKzNBbStYaHErMkxRQk9xUGFMenRqU3h3UFVNSGNoKzNWSXZJMVZHMXYxcUoyeEpBMVRQVk9CQktOampnaFdYdUJzYTFjSTJJYlI5SkpzTVdPSVJTNU5GaGR2UVJqa3NNaW1UM1l2N2YxUWVKeEtzOUtneldlVjdNcm1BPT0tLWEyaVVValdCSlJhcmRJUmNXVGNqR3c9PQ%3D%3D--66f51d7d80652f09a3d2c56f94a8bd6380d4972b; _wunderground_session=SFViSXNZeVFMYkp0MXNOWkZiSW5BMG94QzlqOFBIZnBSOGY2S3B4RkIybzFZdFBQeUlZTlAwMjVNRWJqckRRc2R6V1pweWZhdmpqcTgrNWliM3Izbk4xaWo4d05Tc1YvMyt4L2tuNTlIVjlUZUpTZEwxcE0xUXRTTjAwQjI3eVpSM2c4MlRnY21jUEpIcGo4SjNnY0pRPT0tLTc3TlMrZjFJT1U2S1cySm9DN0RDNGc9PQ%3D%3D--accf1fa6ea2a345286abe82acd0e882d9f4f2c40; _ecommerce_app_session=S1JlZ3BYTDZraDdZU3RZUmpCMHR2aTRGaUpvL1BJN0p6MjRqM0krbXplRFdjemhOMnQ0ckp1ZERzTUp2eWQ5Zit2bEVCOGZLRU9pOHJCRHp1Z0Z1UUZtRlVEVnBhaFBielBjckNMVmlXR0dxS1ZabjNKUFdBcVBUR1JSUlUxYWFSemNNem50TzFxam9aU1BTRXpvQkNrWHpMMVdvUEM2MjdWbHh3NVdYU2QxM1ZwMmFWM3RZdjVlSWFnd1o5OWxtb1lMenJiVStKUnRRcHEzdHlSTGUvdDlCcnFXWDF5TTBmdXFPN0VsUHJxVk50dTREeHkzZG9PdERZV2l6WXJIOEpyVnRjU0FVOW9XeWpldzdZVFBXM0xFTktjQWFMbXpuWHlLay9pK0ZhSVZ6dUVsVXJleDYwR090QjdmaTIyb0E5ODh6cWVHaTE2SHFCZ2JrcWFaMmtWTlM0K0lVejNUZVZkQThGVTN4N3VBPS0ta1E2clFzb1VRQS91WEFOYjl2NGdJUT09--c47816c90bd08c466f3f8f60f4db07eb40807b08; _Top5_session=dndqMXRCdFVxbERXWCs4UStiQ1gwc0daWE9aOW1wRndWTHVjSk1kNXR1T2xoOUNwbk1ndGR0T1lqZXBkSUVuN2VPRU05RnNxcGx1aUg2RjJya1dWaUNTekZ4RzZCb0VvdEFNYmhaUHNjZXhmWDFWM3EzK0lVUm4yazhoaXZLZlpxSldqUC9GN1NMNm54NHpyRUpTK0tBPT0tLW5QQldSb2VVVWJ2V2syRDhXVUs1TlE9PQ%3D%3D--3f5773b8063cfd8dc61e917501485c86e625a4a6; _recruiting_session=cnlTQ2h6YWZKZFVPb1Q1cklSVngvK3hTK0M5ckhJUmhheE83QStTRThCeGg0dGpaNGJCMVRrUGFiQXphQm5Pb2FZbGNkV095bGdNNjlMUmRCTmhSa2duNzRzZEppc2JBT0VoSnZIVWlCMVJtWXZmZktJQWgvM3paM2ZKbmZCdWd4MGw0SHF3OGt6b0xJaXhXTzVGSGxaL2ZBNkNPZ0dGL0ZPMklkNXVKQXRTdFY4Y0J4bGx1eTZYWW9QQlpPZ2JsLS02b3NpWmZibGJGd3JhWEg0TUJzYUpBPT0%3D--722ac1ecda4ef81214e52effeef8fe14317c2bd3; _marta_near_me_session=N2MreUZINElveVZMN2NyNkUrUkduZVZBZHdHMVRCcHE1TE02ZXlKeGdJd21iYUlDeGl4aGkwWUNiODZPRVNPTTlGd1ZlRWlJZjZTUHVzZ25qWHdtaTg1NjBkR3hKQ2hjSWUvTElQY0t1azN3UmpJbXQ2T0xiTlpCOVphTkVxcjlrNVVGNXhNcTZaY3dVY0JEcmtUb0FkeWRVQVdtWm5sU3l4NG1tbWQ0Z2lSYXpNSUsvNGt1V0IwV2NQV1RjVEZ5NWpWUG0rQWR4N1FTSzlxcUFLRW1LOFVEY1VzaXd2K0x4OHJnRVV6OVdlNTI0ZFJGUytqbUNmMmI0SWJsVWpnRWhWTTNWRnUzYksvazNTK01Zd3drTWc9PS0tVWxaSG1FeGl5Z2JrcUxXUUl3aDhJUT09--80376da7d66242e7d73d7e1e598b115d22ec59d6; _sassy_session=MTBuOGpOaVlWbDc3NEl5U0t5U0o3OHk3N0VOc3FNbVdnU2xEajBqTGtaQm5sMStQT3E0bTlLZmpRYy9zY2xKOVgrK1hhcVhSc2UvalVWYm9jS2RlMlhMTCtOK1JETFZQRUtnTUxRSmlrOHFNU0l4SmxmSTRYcUIrSHJ4cEJBbUNZMXBCS3NBL3hoYmhJY2xOZlJyaW13PT0tLW5ZOTBjUS92MjJ3bXlNWlRwb2wvZFE9PQ%3D%3D--62667911aa0f694c2215d10622c4a2e6d4d41007; _gf-hackathon_session=Z0xBUTAreU1EM1h4NFluL3BsMUhicE9wa1BtUHdQRWRic2NpOWh3NjIyNnduamRsZGh4UDhFcW83MDhXenhhQ2ZsNloxKzZsa3RxQXcycVVtcUw4Tnh4UVRwTVVqUWJiOExtSnQwcHJFb1BnM3d4eTVjejgza3pPTFV2OEwwWTZ2UE04cmVwc3IvN21wRks3c0NWK1A1dEpYdmVsK1NlTGt4b2JKRkpSOE1Db2oxajE0aHQ4YS8wYXVLNDM0OTBkcXlQUzJUVFlUeFc5dUxuRzNtaVU4YWZUSVBKQVUwM1dkRmFJcUpiR0JlST0tLVJEMzZNUWpmU0hqcFEzbVAyLzlDVFE9PQ%3D%3D--7bd822b0ba783a644ba067a9bc664450c8d8c7bb; _Library_session=eXhPTWVQLzFWcVlzcCtIMVJReDdaSzBLZXFsa3NJeFpzb21RdUYyb1d1OHJGaWdhMmVxV1l2aDFkUHZ3dUhLalRFenN6QWpPVDFnSTFKQUJpaWE2MHJZOXVtaWVGSU95SnVQeE13ZmdoV0FMYlYvSDR1NVRQMld5NTgxYTRnbS9VekZlT1VuNkl0TVVwSDdWMDNsbFZ3PT0tLVpocjJmTjZBSDRueTEwc3VMWHZ5Rmc9PQ%3D%3D--7470bc2a23b85bab792f4a9d2ef7e75438503948; _fittery-project_session=NVdHZ2Y4c3h0VFJDQkQ1d1lmTFlNVnZyeml1RzVoN1NBMnh4OTFCYmdYQXQyS0oyT1M5R2R2WFRSNStmdEhWMVpmcWJJYTR2a1RwNnJ3b0RnTWpKZTE3amtPQVhYeERUVWdVbC9pbjF0U2g4T1FFQzJDb2pjZGFDZnhFUkJqOUtuN05jSG1WSVRaZm4wQUgxNjZNWllnPT0tLXhONHdmQkp6T2RvbEVyL09POU8xK2c9PQ%3D%3D--559898f1567aac047c39765abe134e9c9b5081c7; _rubix-3_0-rails_session=ckZBdUFhOCsvbjBxWGk4SGZyQkJkZGFvdG9ReG9wRVBkTVBrRzljN1d5WXMxbzBJakNXZ01KamdGZTdpbTNiTUZPNktObGppbzZndEdkaE84S1pRU3RubEpsMm1VTndiNlVmYk9oWmN6dHczc3RWWUMwUmg2a1JWN1gzK2lmR3Y0aHFBUEJjTU9qOFo3MlZmSkh1dkVRPT0tLVZuN3FJQnhuZER6UVlmaXUvWm5yaGc9PQ%3D%3D--beae7a3f4cd8c9179965f81f4da275b27c9fd20c; _mainmarket_session=OGNILytyTzFxR1RRd1I3dnJva2V1UWMrYzBBckRkRC9nWmxxWC9MdXhUcUMzV0QxbVFnUVAzdWpXU2l1VFByODNDdWRpUzYyVHVwVTFlamNIaGFiSk9kTkZWSy9kWHpqa0xneC9FeVNOZjNYbDhMVU1UT0dYOElua0NaMTV3dFRoV1RHaGRIS3dMcElTZ0p6K1QxYnVrWlNTRXJMenlkVUZ5aWtnWkpRSFZndEpFMHVNR3gxcFRGYVhKaGVUT3BvVEdKMGRRUmFERlQxUDYxbHRJc29OamZJWVM5UUJSeXZzMDVzaUxzN3JYcWswYXZHb0YxZTFuNlhxYlBleEs4ZFBvekkrOXFOYU9QeUcrUHowZ3FpUG0zaE5NamwvOUppZSs1VWV3NXczbi85M2pGWG5ENnlvd1lCcGc5bEpUTTZBeUkyM2Vyd09Vb0dqSjd6Q2x5Z1g4MllzZzV3TkU2ejZ4ek5lVmtGaHlIcGU5NWlXMlNLazc2N0JvUHorT2o0MURRQVFUbHZLMFBraHAxTWRYZGZmT2gzMUx0aDdkdDNESFdMV1hLTUJZQS9XS3RsSGc5U3FQSzJaUmRjdDBjMi0tQlgyVzJITjVPbURqN2gxK1d5dmdQZz09--121f584b91d060b407193488b5341fc4919bfa28; _blog_app_session=VU0xeHFmL29hRTdBTWl6WExCZ2JGbHFwL2s1Qnh0QXpBajlsU2ZseHpDdjl3TzhHZzl0NHhVSFVLUktqRTRxejlYTXVFMW9rRllZSTJ3NTlUcHZHYkdhaFFObG43bkN5VkgwbmdzRWY0c21ZT3RJM0lFcXpCMHh1YjRqakpMdFFPZzc4b1dXLzRsQWc5QXJPMTdZNmwzajBOeG5kRHduYzdObFZSUDNMakFHUXNmU3k3MFdCYkRncU94cE0zcEVyOEN6dER2aXYwUGo2Mm44NW1Ub29sSzJ2RUxGVmV4V05oM2JUUHVjV1hhRT0tLUM4YUM3MUpPeWtDSEYxMTU1aStyR3c9PQ%3D%3D--f30b07b16552349bfb6d11fbae3afd1cbac32bcf; _todo_list_session=eER5TjRjMWdEL0p4eVY1SHFlcUdCYzhVNldhRk5qclVEWTJCSVFjdkNZcXFvT053VXRpU1NKdG9qb3dFdGdpMUwwcmxXbmJIMXVrbDBxSFVjZTNXcHBIbDRkTXhGaTRmTm90YXZ4d2plSWtuWWlwZGdMSkVMRkliSS8wajhVejJ1MC83Q0h3d2NuaTdmMC9WT3o4NTVnPT0tLWtmUlh5SzFiQ2llZHk0am15d3dzeVE9PQ%3D%3D--5a16fdce0a2c0afe942f70c3203334df3a64d2e8; _tts-reddit_session=WkxWcERrRUJFNURkTGxvR3h5VHpPa2FhWXJhc0RrUElIOFVuT1ZhQ3FGSXhta0ZnVm1GNlVUdnJmOUxIOE9aTUhUcS9hMGY0bFl2K1dyUEYvTlpaNlNjTjV4OHBvWW1YdzM0SFozUkZKQTd5YktMeHI3dXRDV21hN3piaGhyalh6b1EzSExmb0Vod1FRYkhPeU1meFVGaUhPVVM5cllPV3dRT2dsQlM4Ty9vT3VRSkdmcTBsZlFhNXBrYU1CWWlMUE5FSmZDam5DRjlUOGdOMjlHOW9TdVVSYlR4MVlFdWZ2b0dzYTJFajhsMD0tLWY5a1o3U1krKzRUK3pBNmc0bEsyS2c9PQ%3D%3D--458a23790e533b457ebbb80e9dd5bdf76e0de77a; _tweeter_session=ZFpCZHR2dklyd0ozUzJ4ZDBCWjhGZVJ1bFlvNGo0bmdIdkltalN4aDNmY1RsbmlhczR4cThsa3JJUGlFZ0JxcHFiUSsxOU5LbDhVdmtsb2ttWndpUWVMcXYzNEpEbXRpZ3JyOERrQytxMmoxT0FZd1orNDdQOEFGNFFqWllyWmJIdHE1RFF5aVY5MndoOGVmOUpMZTZFbEdJTjk2QzhUQWZXOEJNOCtXbWphM2QwS2NxRkhOUFl6ZTIrMDd6RHFJd2QyTDJkVEh5SmhqSnZvVjZZUllFbU5vOExXQmFGM2ppV2JXSXBXRUo3ZVY5ZG5ycEo0dnRnb0kxeitUT1JNWmhTZnNIMDVvbjV4emxQUDF5b2x2Njk3djREZmNza0NudDB4ZW0yay8xaytYS2QrU0cySzJ0ZzEvUUdhcEZwanBoN3o0OWpsaHVmYTc0dUY3U0R6VDN3PT0tLUE0Zy9mS0VmcGp2bXNDSVJ4UGQ2ZkE9PQ%3D%3D--e1ca4a8f11b7d639e0235fec0644adf6e4576888; _angular_rails_reddit_session=RVQ2anNFSE1qK3VGYjFyMzdTTnRXc1ZDM25JNkNqT25OT1ZTK3RWUXptUWtwSHZwVE1vOE5tUWJML2NKUDZVemRYcThicUpYYzJxejJab3RPanRNR21BSTZVM2NBVFRZeE94OE9QVzVhUTFFdUJ6WmljbTN4eFVQV1VKMkVyY3RjYlE5dkRyZVArelFNSTV5UWdqVTJBPT0tLTN4dUlHaVZXcW1wZFNER1JyOFBxWlE9PQ%3D%3D--67046be80e6a383c4ecf3d47bfb8b5d58f5ed7d1; _fittery_session=b1FVdGtyVTN5Sy9MOWdHTEJzU0RxYjBEeERteC9tTTd3ekFOZE02eXV3VHNTM29XV0F4dVhUb1ppTzNmdHZKZGRUSWVpU0lYTm1vQ045TFFCWDhKZldQTFJ1cWpvTkFiZlBIQnVuL0I4SGhIODA0bFNwK1diOVJXVnZ0MzNaekovcEN3dDI2cHdjN3lUSnVlVzdoYjY5a04wYXJiQk41aTc5TGVleExwZkZzdExGTDJrejJtTktiL0p4K3FreENBYnlPTW1WWXFSbEZMWWtidFdzMldDSDVyaG1acEM0OVhxREVlMUg0S0xWcGV2Q0dxTzNaODZWWmhvWWFrNW55SEJ3ZmtEMjR1YlpYSk5uV1Flem4wUjV4U0hSSUtyQlF0QUcvQkc5TGtBWUl1UFRNNEhzLzgrVlg0RmxMcGw3QW42UDVmUjVqQ1hPd0V1K1M1aXFFb0NnPT0tLUw1K0dHZXh6b3pPMDBNT1YwZFEyVFE9PQ%3D%3D--527a62a03427f1ed30709c0a8a591cadb7a26cea; _ladies-of-tts_session=OHEwdWNLVFJyRU8yQTEyVjZyNUp6YzdyUjNJSlVreU15dktVRk1QNlEzQ0xRcUFTUUx3M0hlTEZlUnE5MkNadmZwaWtqTUp0SVRQaGFZcHZ1TDh3am5wZ3J3MnBMaHVFOG5oeDZXTDBRb2VHcmVKZS9ORUpHSmFmcHg0V0dWKzdESGRkZnpZUGVoM3lvQU02VVBaalBnPT0tLVRPbTNQSkY3VUczUUk5UnQ1OUtZNkE9PQ%3D%3D--f48ce24828b13200003ee27dcc8717925dcfc9ce; _three-good-things_session=RWZ0NS92QVN2dWoxWkpzVk1RNEN6UmlXMlFhSnYyc0pXd1l1Q2NzMGFQM1BmMkJlM1gzMG9LeTFKY3I0L2NoUzJwRk1PZnprQUx6U3duUStYYkFBT055WkVRVVIxdlVkalFUaVNBaEdqSW9EM1ZSMUR5d0pUbDgxcUJ5cnZ5cDY5YkFhUlJYTStzZ0JINENTbnFjK2tGU1IxZEg2TWlnUGtuUjlvRXozbnVrcFdEZFlOQWdTREFVTCtOTHRhUW1MZDFWMXVSSDZwdXNmQWlHRlk1Q3ZsWmJWbjMwb0NjRDhNQk90L0YyY1RRST0tLVY2ZnZRemluWWNkY2ZyNTJONEpWNmc9PQ%3D%3D--0e7bf64b6d71d668d845f98f35c1f94d239aefc3; _my_site_session=MFE2NWZydk1Fa05PRHpwbWdDNzl3TXJZZHFEa01pdEFSQUdsSWpzN0F0dGx6cklacFZzV2hsaTdITWpubU5PUDdYU1ZZWkZEOUpWb1pIbDUyeDVHR0ZiNDZHU0U4K2V4QnU0K2pRTmdpdWNlUHFvTnZMQ3g3MHBDSEhjV2VKOWRoTEVFUm9NRWdIUzZ1YjFIaE9aVVlnPT0tLWpjVUVuaHJyM0JoWm1GUit0WmFWL2c9PQ%3D%3D--d7711f08ae193bd0528e10198728887b9eedc426; _rails-starter-kit_session=NmRveUJiZ0RMTTlRR003L1RrUE5lem5oMmRjdG5xMmtZcDRlUTFWRjBXNmNPMkFvT1RqSFBPd1pBQVBHSHRLSmg3Qk53WXZ3Ykp6bkQvT2lqa2dyQU5ZYXlJcXBnaEdabzhTSEJteHl5K1lBNzU2R1BMNGx6WGpFa1dOTVpOUS9mZ09LZWJYZlQwMjhRL2xiWFBnVU9BPT0tLUthVEdXNDlQZDREQTd0MWVkU093SUE9PQ%3D%3D--41cea213452b8234f53415d44c98bf55997633be; step-1=60; step-2=140; step-3=0; step-4=13; step-5=30; step-6=26; step-7=26; step-8=0; current-step=9; step-9=0; sid=111; __cypress.initial=false; __cypress.remoteHost=http://localhost:8000; best_fit=14 1/2, 34-35, Traditional',\n        },\n      })\n      .then((res) => {\n        expect(res.statusCode).to.eq(200)\n      })\n    })\n\n    it('hands back 201 status codes', function () {\n      nock(this.server._remoteOrigin)\n      .post('/companies/validate', {\n        payload: { name: 'Brian' },\n      })\n      .reply(201)\n\n      return this.rp({\n        method: 'POST',\n        url: 'http://localhost:8000/companies/validate',\n        json: true,\n        body: {\n          payload: { name: 'Brian' },\n        },\n        headers: {\n          'Cookie': '__cypress.initial=false',\n        },\n      })\n      .then((res) => {\n        expect(res.statusCode).to.eq(201)\n      })\n    })\n  })\n})\n",
    "packages/server/test/integration/server_spec.js": "require('../spec_helper')\n\nconst _ = require('lodash')\nconst http = require('http')\nconst rp = require('@cypress/request-promise')\nconst Promise = require('bluebird')\nconst evilDns = require('evil-dns')\nconst httpsServer = require(`${root}../https-proxy/test/helpers/https_server`)\nconst config = require(`${root}lib/config`)\nconst { ServerE2E } = require(`${root}lib/server-e2e`)\nconst Fixtures = require(`${root}test/support/helpers/fixtures`)\n\nconst s3StaticHtmlUrl = 'https://s3.amazonaws.com/internal-test-runner-assets.cypress.io/index.html'\n\nconst expectToEqDetails = function (actual, expected) {\n  actual = _.omit(actual, 'totalTime')\n\n  expect(actual).to.deep.eq(expected)\n}\n\ndescribe('Server', () => {\n  require('mocha-banner').register()\n\n  beforeEach(() => {\n    return sinon.stub(ServerE2E.prototype, 'reset')\n  })\n\n  context('resolving url', () => {\n    beforeEach(function () {\n      process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'\n\n      nock.enableNetConnect()\n\n      this.automationRequest = sinon.stub()\n      this.automationRequest.withArgs('get:cookies').resolves([])\n      this.automationRequest.withArgs('set:cookie').resolves({})\n\n      this.setup = (initialUrl, obj = {}) => {\n        if (_.isObject(initialUrl)) {\n          obj = initialUrl\n          initialUrl = null\n        }\n\n        // get all the config defaults\n        // and allow us to override them\n        // for each test\n        return config.set(obj)\n        .then((cfg) => {\n          // use a jar for each test\n          // but reset it automatically\n          // between test\n          const jar = rp.jar()\n\n          // use a custom request promise\n          // to automatically backfill these\n          // options including our proxy\n          this.rp = (options = {}) => {\n            let url\n\n            if (_.isString(options)) {\n              url = options\n              options = {}\n            }\n\n            _.defaults(options, {\n              url,\n              proxy: this.proxy,\n              jar,\n              simple: false,\n              followRedirect: false,\n              resolveWithFullResponse: true,\n            })\n\n            return rp(options)\n          }\n\n          return Promise.all([\n            // open our https server\n            httpsServer.start(8443),\n\n            // and open our cypress server\n            (this.server = new ServerE2E()),\n\n            this.server.open(cfg)\n            .spread(async (port) => {\n              const automationStub = {\n                use: () => { },\n              }\n\n              await this.server.startWebsockets(automationStub, config, {})\n              if (initialUrl) {\n                this.server._onDomainSet(initialUrl)\n              }\n\n              this.srv = this.server.getHttpServer()\n\n              // @session = new (Session({app: @srv}))\n\n              this.proxy = `http://localhost:${port}`\n\n              this.buffers = this.server._networkProxy.http.buffers\n\n              this.fileServer = this.server._fileServer.address()\n            }),\n          ])\n        })\n      }\n    })\n\n    afterEach(function () {\n      nock.cleanAll()\n\n      evilDns.clear()\n\n      return Promise.join(\n        this.server.close(),\n        httpsServer.stop(),\n      )\n    })\n\n    describe('file', () => {\n      beforeEach(function () {\n        Fixtures.scaffold('no-server')\n\n        return this.setup({\n          projectRoot: Fixtures.projectPath('no-server'),\n          config: {\n            port: 2000,\n            fileServerFolder: 'dev',\n          },\n        })\n      })\n\n      it('can serve static assets', function () {\n        return this.server._onResolveUrl('/index.html', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://localhost:2000/index.html',\n            originalUrl: '/index.html',\n            filePath: Fixtures.projectPath('no-server/dev/index.html'),\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        }).then(() => {\n          return this.rp('http://localhost:2000/index.html')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.headers['etag']).to.exist\n            expect(res.headers['set-cookie']).not.to.match(/initial=;/)\n            expect(res.headers['cache-control']).to.eq('no-cache, no-store, must-revalidate')\n            expect(res.body).to.include('index.html content')\n            expect(res.body).to.include('document.domain = \\'localhost\\'')\n\n            expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n            expect(res.body).to.include('</script>\\n  </head>')\n          })\n        })\n      })\n\n      it('sends back the content type', function () {\n        return this.server._onResolveUrl('/assets/foo.json', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: false,\n            contentType: 'application/json',\n            url: 'http://localhost:2000/assets/foo.json',\n            originalUrl: '/assets/foo.json',\n            filePath: Fixtures.projectPath('no-server/dev/assets/foo.json'),\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        })\n      })\n\n      it('buffers the response', function () {\n        sinon.spy(this.server.request, 'sendStream')\n\n        return this.server._onResolveUrl('/index.html', {}, this.automationRequest)\n        .then((obj = {}) => {\n          expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://localhost:2000/index.html',\n            originalUrl: '/index.html',\n            filePath: Fixtures.projectPath('no-server/dev/index.html'),\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n\n          expect(this.buffers.buffer).to.include({ url: 'http://localhost:2000/index.html' })\n        }).then(() => {\n          return this.server._onResolveUrl('/index.html', {}, this.automationRequest)\n          .then((obj = {}) => {\n            expectToEqDetails(obj, {\n              isOkStatusCode: true,\n              isHtml: true,\n              contentType: 'text/html',\n              url: 'http://localhost:2000/index.html',\n              originalUrl: '/index.html',\n              filePath: Fixtures.projectPath('no-server/dev/index.html'),\n              status: 200,\n              statusText: 'OK',\n              redirects: [],\n              cookies: [],\n            })\n\n            expect(this.server.request.sendStream).to.be.calledTwice\n          })\n        }).then(() => {\n          return this.rp('http://localhost:2000/index.html')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.body).to.include('document.domain')\n            expect(res.body).to.include('localhost')\n            expect(res.body).to.include('Cypress')\n\n            expect(this.buffers.buffer).to.be.undefined\n          })\n        })\n      })\n\n      it('can follow static file redirects', function () {\n        return this.server._onResolveUrl('/sub', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://localhost:2000/sub/',\n            originalUrl: '/sub',\n            filePath: Fixtures.projectPath('no-server/dev/sub/'),\n            status: 200,\n            statusText: 'OK',\n            redirects: ['301: http://localhost:2000/sub/'],\n            cookies: [],\n          })\n        }).then(() => {\n          return this.rp('http://localhost:2000/sub/')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(this.server._getRemoteState()).to.deep.eq({\n              auth: undefined,\n              origin: 'http://localhost:2000',\n              strategy: 'file',\n              visiting: false,\n              domainName: 'localhost',\n              fileServer: this.fileServer,\n              props: null,\n            })\n          })\n        })\n      })\n\n      it('gracefully handles 404', function () {\n        return this.server._onResolveUrl('/does-not-exist', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: false,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://localhost:2000/does-not-exist',\n            originalUrl: '/does-not-exist',\n            filePath: Fixtures.projectPath('no-server/dev/does-not-exist'),\n            status: 404,\n            statusText: 'Not Found',\n            redirects: [],\n            cookies: [],\n          })\n        }).then(() => {\n          return this.rp('http://localhost:2000/does-not-exist')\n          .then((res) => {\n            expect(res.statusCode).to.eq(404)\n            expect(res.body).to.include('Cypress errored trying to serve this file from your system:')\n            expect(res.body).to.include('does-not-exist')\n\n            expect(res.body).to.include('The file was not found')\n          })\n        })\n      })\n\n      it('handles urls with hashes', function () {\n        return this.server._onResolveUrl('/index.html#/foo/bar', {}, this.automationRequest)\n        .then((obj = {}) => {\n          expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://localhost:2000/index.html',\n            originalUrl: '/index.html',\n            filePath: Fixtures.projectPath('no-server/dev/index.html'),\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n\n          expect(this.buffers.buffer).to.include({ url: 'http://localhost:2000/index.html' })\n        }).then(() => {\n          return this.rp('http://localhost:2000/index.html')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(this.buffers.buffer).to.be.undefined\n          })\n        })\n      })\n    })\n\n    describe('http', () => {\n      beforeEach(function () {\n        return this.setup({\n          projectRoot: '/foo/bar/',\n          config: {\n            port: 2000,\n          },\n        })\n      })\n\n      context('only having one request in flight at a time', () => {\n        beforeEach(function (done) {\n          this.httpServer = http.createServer((req, res) => {\n            const [path, ms] = req.url.split('/').slice(1)\n\n            switch (path) {\n              case 'pause-before-body':\n                res.writeHead(200, { 'content-type': 'text/html' })\n\n                return setTimeout(() => {\n                  res.write('ok')\n\n                  return res.end()\n                }\n                , Number(ms))\n              case 'pause-before-headers':\n                return setTimeout(() => {\n                  res.writeHead(200, { 'content-type': 'text/html' })\n                  res.write('ok')\n\n                  return res.end()\n                }\n                , Number(ms))\n              default:\n            }\n          })\n\n          this.httpServer.listen(() => {\n            this.httpPort = this.httpServer.address().port\n\n            return done()\n          })\n\n          this.runOneReqTest = (path) => {\n            // put the first request in flight\n            const p1 = this.server._onResolveUrl(`http://localhost:${this.httpPort}/${path}/1000`, {}, this.automationRequest)\n\n            return Promise.delay(100)\n            .then(() => {\n              // the p1 should not have a current promise phase or reqStream until it's canceled\n              expect(p1).not.to.have.property('currentPromisePhase')\n              expect(p1).not.to.have.property('reqStream')\n\n              // fire the 2nd request now that the first one has had some time to reach out\n              return this.server._onResolveUrl(`http://localhost:${this.httpPort}/${path}/100`, {}, this.automationRequest)\n            }).then((obj) => {\n              expectToEqDetails(obj, {\n                isOkStatusCode: true,\n                isHtml: true,\n                contentType: 'text/html',\n                url: `http://localhost:${this.httpPort}/${path}/100`,\n                originalUrl: `http://localhost:${this.httpPort}/${path}/100`,\n                status: 200,\n                statusText: 'OK',\n                redirects: [],\n                cookies: [],\n              })\n\n              expect(p1.isCancelled()).to.be.true\n              expect(p1).to.have.property('currentPromisePhase')\n\n              expect(p1.reqStream.aborted).to.be.true\n            })\n          }\n        })\n\n        it('cancels and aborts the 1st request when it hasn\\'t loaded headers and a 2nd request is made', function () {\n          return this.runOneReqTest('pause-before-headers')\n        })\n\n        it('cancels and aborts the 1st request when it hasn\\'t loaded body and a 2nd request is made', function () {\n          return this.runOneReqTest('pause-before-body')\n        })\n      })\n\n      it('can serve http requests', function () {\n        nock('http://getbootstrap.com')\n        .matchHeader('user-agent', 'foobarbaz')\n        .matchHeader('accept', 'text/html,*/*')\n        .get('/')\n        .reply(200, '<html>content</html>', {\n          'X-Foo-Bar': 'true',\n          'Content-Type': 'text/html',\n          'Cache-Control': 'public, max-age=3600',\n        })\n\n        const headers = {}\n\n        headers['user-agent'] = 'foobarbaz'\n\n        return this.server._onResolveUrl('http://getbootstrap.com/', headers, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://getbootstrap.com/',\n            originalUrl: 'http://getbootstrap.com/',\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        }).then(() => {\n          return this.rp('http://getbootstrap.com/')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.headers['set-cookie']).not.to.match(/initial=;/)\n            expect(res.headers['x-foo-bar']).to.eq('true')\n            expect(res.headers['cache-control']).to.eq('no-cache, no-store, must-revalidate')\n            expect(res.body).to.include('content')\n            expect(res.body).to.include('document.domain = \\'getbootstrap.com\\'')\n\n            expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n            expect(res.body).to.include('</head>content</html>')\n          })\n        })\n      })\n\n      it('sends back the content type', function () {\n        nock('http://getbootstrap.com')\n        .get('/user.json')\n        .reply(200, {})\n\n        return this.server._onResolveUrl('http://getbootstrap.com/user.json', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: false,\n            contentType: 'application/json',\n            url: 'http://getbootstrap.com/user.json',\n            originalUrl: 'http://getbootstrap.com/user.json',\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        })\n      })\n\n      // @see https://github.com/cypress-io/cypress/issues/8506\n      it('yields isHtml true for unconventional HTML content-types', async function () {\n        const scope = nock('http://example.com')\n        .get('/a').reply(200, 'notHtml')\n        .get('/b').reply(200, 'notHtml', { 'content-type': 'Text/Html' })\n        .get('/c').reply(200, 'notHtml', { 'content-type': 'text/html;charset=utf-8' })\n        // invalid, but let's be tolerant\n        .get('/d').reply(200, 'notHtml', { 'content-type': 'text/html;' })\n        .get('/e').reply(200, 'notHtml', { 'content-type': 'application/xhtml+xml' })\n\n        const bad = await this.server._onResolveUrl('http://example.com/a', {}, this.automationRequest)\n\n        expect(bad.isHtml).to.be.false\n\n        for (const path of ['/b', '/c', '/d', '/e']) {\n          const details = await this.server._onResolveUrl(`http://example.com${path}`, {}, this.automationRequest)\n\n          expect(details.isHtml).to.be.true\n        }\n\n        scope.done()\n      })\n\n      it('yields isHtml true for HTML-shaped responses', function () {\n        nock('http://example.com')\n        .get('/')\n        .reply(200, '<html>foo</html>')\n\n        return this.server._onResolveUrl('http://example.com', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: undefined,\n            url: 'http://example.com/',\n            originalUrl: 'http://example.com/',\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        })\n      })\n\n      it('yields isHtml false for non-HTML-shaped responses', function () {\n        nock('http://example.com')\n        .get('/')\n        .reply(200, '{ foo: \"bar\" }')\n\n        return this.server._onResolveUrl('http://example.com', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: false,\n            contentType: undefined,\n            url: 'http://example.com/',\n            originalUrl: 'http://example.com/',\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        })\n      })\n\n      it('can follow multiple http redirects', function () {\n        nock('http://espn.com')\n        .get('/')\n        .reply(301, undefined, {\n          'Location': '/foo',\n        })\n        .get('/foo')\n        .reply(302, undefined, {\n          'Location': 'http://espn.go.com/',\n        })\n\n        nock('http://espn.go.com')\n        .get('/')\n        .reply(200, '<html>content</html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.server._onResolveUrl('http://espn.com/', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://espn.go.com/',\n            originalUrl: 'http://espn.com/',\n            status: 200,\n            statusText: 'OK',\n            cookies: [],\n            redirects: [\n              '301: http://espn.com/foo',\n              '302: http://espn.go.com/',\n            ],\n          })\n        }).then(() => {\n          return this.rp('http://espn.go.com/')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.body).to.include('content')\n            expect(res.body).to.include('document.domain = \\'go.com\\'')\n            expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n            expect(res.body).to.include('</head>content</html>')\n\n            expect(this.server._getRemoteState()).to.deep.eq({\n              auth: undefined,\n              origin: 'http://espn.go.com',\n              strategy: 'http',\n              visiting: false,\n              domainName: 'go.com',\n              fileServer: null,\n              props: {\n                domain: 'go',\n                tld: 'com',\n                port: '80',\n              },\n            })\n          })\n        })\n      })\n\n      it('buffers the http response', function () {\n        sinon.spy(this.server.request, 'sendStream')\n\n        nock('http://espn.com')\n        .get('/')\n        .times(2)\n        .reply(301, undefined, {\n          'Location': '/foo',\n        })\n        .get('/foo')\n        .times(2)\n        .reply(302, undefined, {\n          'Location': 'http://espn.go.com/',\n        })\n\n        nock('http://espn.go.com')\n        .get('/')\n        .times(2)\n        .reply(200, '<html><head></head><body>espn</body></html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.server._onResolveUrl('http://espn.com/', {}, this.automationRequest)\n        .then((obj = {}) => {\n          expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://espn.go.com/',\n            originalUrl: 'http://espn.com/',\n            status: 200,\n            statusText: 'OK',\n            cookies: [],\n            redirects: [\n              '301: http://espn.com/foo',\n              '302: http://espn.go.com/',\n            ],\n          })\n\n          expect(this.buffers.buffer).to.include({ url: 'http://espn.go.com/' })\n        }).then(() => {\n          return this.server._onResolveUrl('http://espn.com/', {}, this.automationRequest)\n          .then((obj = {}) => {\n            expectToEqDetails(obj, {\n              isOkStatusCode: true,\n              isHtml: true,\n              contentType: 'text/html',\n              url: 'http://espn.go.com/',\n              originalUrl: 'http://espn.com/',\n              status: 200,\n              statusText: 'OK',\n              cookies: [],\n              redirects: [\n                '301: http://espn.com/foo',\n                '302: http://espn.go.com/',\n              ],\n            })\n\n            expect(this.server.request.sendStream).to.be.calledTwice\n          })\n        }).then(() => {\n          return this.rp('http://espn.go.com/')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.body).to.include('document.domain')\n            expect(res.body).to.include('go.com')\n            expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n            expect(res.body).to.include('</script></head><body>espn</body></html>')\n\n            expect(this.buffers.buffer).to.be.undefined\n          })\n        })\n      })\n\n      it('does not buffer \\'bad\\' responses', function () {\n        sinon.spy(this.server.request, 'sendStream')\n\n        nock('http://espn.com')\n        .get('/')\n        .reply(404, undefined)\n        .get('/')\n        .reply(301, undefined, {\n          'Location': '/foo',\n        })\n        .get('/foo')\n        .reply(301, undefined, {\n          'Location': 'http://espn.go.com/',\n        })\n\n        nock('http://espn.go.com')\n        .get('/')\n        .reply(200, 'content', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.server._onResolveUrl('http://espn.com/', {}, this.automationRequest)\n        .then((obj = {}) => {\n          expectToEqDetails(obj, {\n            isOkStatusCode: false,\n            isHtml: false,\n            contentType: undefined,\n            url: 'http://espn.com/',\n            originalUrl: 'http://espn.com/',\n            status: 404,\n            statusText: 'Not Found',\n            cookies: [],\n            redirects: [],\n          })\n\n          return this.server._onResolveUrl('http://espn.com/', {}, this.automationRequest)\n          .then((obj = {}) => {\n            expectToEqDetails(obj, {\n              isOkStatusCode: true,\n              isHtml: true,\n              contentType: 'text/html',\n              url: 'http://espn.go.com/',\n              originalUrl: 'http://espn.com/',\n              status: 200,\n              statusText: 'OK',\n              cookies: [],\n              redirects: [\n                '301: http://espn.com/foo',\n                '301: http://espn.go.com/',\n              ],\n            })\n\n            expect(this.server.request.sendStream).to.be.calledTwice\n          })\n        })\n      })\n\n      it('gracefully handles 500', function () {\n        nock('http://mlb.com')\n        .get('/')\n        .reply(307, undefined, {\n          'Location': 'http://mlb.mlb.com/',\n        })\n\n        nock('http://mlb.mlb.com')\n        .get('/')\n        .reply(500, undefined, {\n          'Content-Type': 'text/html',\n        })\n\n        return this.server._onResolveUrl('http://mlb.com/', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: false,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://mlb.mlb.com/',\n            originalUrl: 'http://mlb.com/',\n            status: 500,\n            statusText: 'Internal Server Error',\n            cookies: [],\n            redirects: ['307: http://mlb.mlb.com/'],\n          })\n        })\n      })\n\n      it('gracefully handles http errors', function () {\n        return this.server._onResolveUrl('http://localhost:64646', {}, this.automationRequest)\n        .catch((err) => {\n          expect(err.message).to.eq('connect ECONNREFUSED 127.0.0.1:64646')\n          expect(err.port).to.eq(64646)\n\n          expect(err.code).to.eq('ECONNREFUSED')\n        })\n      })\n\n      it('handles url hashes', function () {\n        nock('http://getbootstrap.com')\n        .get('/')\n        .reply(200, 'content page', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.server._onResolveUrl('http://getbootstrap.com/#/foo', {}, this.automationRequest)\n        .then((obj = {}) => {\n          expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://getbootstrap.com/',\n            originalUrl: 'http://getbootstrap.com/',\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n\n          expect(this.buffers.buffer).to.include({ url: 'http://getbootstrap.com/' })\n        }).then(() => {\n          return this.rp('http://getbootstrap.com/')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n\n            expect(this.buffers.buffer).to.be.undefined\n          })\n        })\n      })\n\n      it('can serve non 2xx status code requests when option set', function () {\n        nock('http://google.com')\n        .matchHeader('user-agent', 'foobarbaz')\n        .matchHeader('accept', 'text/html,*/*')\n        .get('/foo')\n        .reply(404, '<html>content</html>', {\n          'X-Foo-Bar': 'true',\n          'Content-Type': 'text/html',\n          'Cache-Control': 'public, max-age=3600',\n        })\n\n        const headers = {}\n\n        headers['user-agent'] = 'foobarbaz'\n\n        return this.server._onResolveUrl('http://google.com/foo', headers, this.automationRequest, { failOnStatusCode: false })\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://google.com/foo',\n            originalUrl: 'http://google.com/foo',\n            status: 404,\n            statusText: 'Not Found',\n            redirects: [],\n            cookies: [],\n          })\n        }).then(() => {\n          return this.rp('http://google.com/foo')\n          .then((res) => {\n            expect(res.statusCode).to.eq(404)\n            expect(res.headers['set-cookie']).not.to.match(/initial=;/)\n            expect(res.headers['x-foo-bar']).to.eq('true')\n            expect(res.headers['cache-control']).to.eq('no-cache, no-store, must-revalidate')\n            expect(res.body).to.include('content')\n            expect(res.body).to.include('document.domain = \\'google.com\\'')\n\n            expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n            expect(res.body).to.include('</head>content</html>')\n          })\n        })\n      })\n\n      it('passes auth through', function () {\n        const username = 'u'\n        const password = 'p'\n\n        const base64 = Buffer.from(`${username}:${password}`).toString('base64')\n\n        const auth = {\n          username,\n          password,\n        }\n\n        nock('http://google.com')\n        .get('/index')\n        .matchHeader('authorization', `Basic ${base64}`)\n        .reply(200, '<html>content</html>', {\n          'Content-Type': 'text/html',\n        })\n        .get('/index2')\n        .matchHeader('authorization', `Basic ${base64}`)\n        .reply(200, '<html>content</html>', {\n          'Content-Type': 'text/html',\n        })\n\n        const headers = {}\n\n        headers['user-agent'] = 'foobarbaz'\n\n        return this.server._onResolveUrl('http://google.com/index', headers, this.automationRequest, { auth })\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://google.com/index',\n            originalUrl: 'http://google.com/index',\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        }).then(() => {\n          return this.rp('http://google.com/index2')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n          })\n        }).then(() => {\n          expect(this.server._getRemoteState()).to.deep.eq({\n            auth,\n            origin: 'http://google.com',\n            strategy: 'http',\n            visiting: false,\n            domainName: 'google.com',\n            fileServer: null,\n            props: {\n              domain: 'google',\n              tld: 'com',\n              port: '80',\n            },\n          })\n        })\n      })\n    })\n\n    describe('both', () => {\n      beforeEach(function () {\n        Fixtures.scaffold('no-server')\n\n        return this.setup({\n          projectRoot: Fixtures.projectPath('no-server'),\n          config: {\n            port: 2000,\n            fileServerFolder: 'dev',\n          },\n        })\n      })\n\n      it('can go from file -> http -> file', function () {\n        nock('http://www.google.com')\n        .get('/')\n        .reply(200, 'content page', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.server._onResolveUrl('/index.html', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://localhost:2000/index.html',\n            originalUrl: '/index.html',\n            filePath: Fixtures.projectPath('no-server/dev/index.html'),\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        }).then(() => {\n          return this.rp('http://localhost:2000/index.html')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n          })\n        }).then(() => {\n          return this.server._onResolveUrl('http://www.google.com/', {}, this.automationRequest)\n        }).then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://www.google.com/',\n            originalUrl: 'http://www.google.com/',\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        }).then(() => {\n          return this.rp('http://www.google.com/')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n          })\n        }).then(() => {\n          expect(this.server._getRemoteState()).to.deep.eq({\n            auth: undefined,\n            origin: 'http://www.google.com',\n            strategy: 'http',\n            visiting: false,\n            domainName: 'google.com',\n            fileServer: null,\n            props: {\n              domain: 'google',\n              tld: 'com',\n              port: '80',\n            },\n          })\n        }).then(() => {\n          return this.server._onResolveUrl('/index.html', {}, this.automationRequest)\n          .then((obj = {}) => {\n            return expectToEqDetails(obj, {\n              isOkStatusCode: true,\n              isHtml: true,\n              contentType: 'text/html',\n              url: 'http://localhost:2000/index.html',\n              originalUrl: '/index.html',\n              filePath: Fixtures.projectPath('no-server/dev/index.html'),\n              status: 200,\n              statusText: 'OK',\n              redirects: [],\n              cookies: [],\n            })\n          })\n        }).then(() => {\n          return this.rp('http://localhost:2000/index.html')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n          })\n        }).then(() => {\n          expect(this.server._getRemoteState()).to.deep.eq({\n            auth: undefined,\n            origin: 'http://localhost:2000',\n            strategy: 'file',\n            visiting: false,\n            domainName: 'localhost',\n            fileServer: this.fileServer,\n            props: null,\n          })\n        })\n      })\n\n      it('can go from http -> file -> http', function () {\n        nock('http://www.google.com')\n        .get('/')\n        .reply(200, '<html><head></head><body>google</body></html>', {\n          'Content-Type': 'text/html',\n        })\n        .get('/')\n        .reply(200, '<html><head></head><body>google</body></html>', {\n          'Content-Type': 'text/html',\n        })\n\n        return this.server._onResolveUrl('http://www.google.com/', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'http://www.google.com/',\n            originalUrl: 'http://www.google.com/',\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        }).then(() => {\n          return this.rp('http://www.google.com/')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.body).to.include('document.domain')\n            expect(res.body).to.include('google.com')\n\n            expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n            expect(res.body).to.include('</script></head><body>google</body></html>')\n          })\n        }).then(() => {\n          expect(this.server._getRemoteState()).to.deep.eq({\n            auth: undefined,\n            origin: 'http://www.google.com',\n            strategy: 'http',\n            visiting: false,\n            domainName: 'google.com',\n            fileServer: null,\n            props: {\n              domain: 'google',\n              tld: 'com',\n              port: '80',\n            },\n          })\n        }).then(() => {\n          return this.server._onResolveUrl('/index.html', {}, this.automationRequest)\n          .then((obj = {}) => {\n            return expectToEqDetails(obj, {\n              isOkStatusCode: true,\n              isHtml: true,\n              contentType: 'text/html',\n              url: 'http://localhost:2000/index.html',\n              originalUrl: '/index.html',\n              filePath: Fixtures.projectPath('no-server/dev/index.html'),\n              status: 200,\n              statusText: 'OK',\n              redirects: [],\n              cookies: [],\n            })\n          })\n        }).then(() => {\n          return this.rp('http://localhost:2000/index.html')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.body).to.include('document.domain')\n            expect(res.body).to.include('localhost')\n\n            expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n          })\n        }).then(() => {\n          expect(this.server._getRemoteState()).to.deep.eq({\n            auth: undefined,\n            origin: 'http://localhost:2000',\n            strategy: 'file',\n            visiting: false,\n            domainName: 'localhost',\n            fileServer: this.fileServer,\n            props: null,\n          })\n        }).then(() => {\n          return this.server._onResolveUrl('http://www.google.com/', {}, this.automationRequest)\n          .then((obj = {}) => {\n            return expectToEqDetails(obj, {\n              isOkStatusCode: true,\n              isHtml: true,\n              contentType: 'text/html',\n              url: 'http://www.google.com/',\n              originalUrl: 'http://www.google.com/',\n              status: 200,\n              statusText: 'OK',\n              redirects: [],\n              cookies: [],\n            })\n          }).then(() => {\n            return this.rp('http://www.google.com/')\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n              expect(res.body).to.include('document.domain')\n              expect(res.body).to.include('google.com')\n\n              expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n              expect(res.body).to.include('</script></head><body>google</body></html>')\n            })\n          }).then(() => {\n            expect(this.server._getRemoteState()).to.deep.eq({\n              auth: undefined,\n              origin: 'http://www.google.com',\n              strategy: 'http',\n              visiting: false,\n              domainName: 'google.com',\n              fileServer: null,\n              props: {\n                domain: 'google',\n                tld: 'com',\n                port: '80',\n              },\n            })\n          })\n        })\n      })\n\n      it('can go from https -> file -> https', function () {\n        evilDns.add('*.foobar.com', '127.0.0.1')\n\n        return this.server._onResolveUrl('https://www.foobar.com:8443/', {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: 'https://www.foobar.com:8443/',\n            originalUrl: 'https://www.foobar.com:8443/',\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        }).then(() => {\n          return this.rp('https://www.foobar.com:8443/')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.body).to.include('document.domain')\n            expect(res.body).to.include('foobar.com')\n\n            expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n            expect(res.body).to.include('</script></head><body>https server</body></html>')\n          })\n        }).then(() => {\n          expect(this.server._getRemoteState()).to.deep.eq({\n            auth: undefined,\n            origin: 'https://www.foobar.com:8443',\n            strategy: 'http',\n            visiting: false,\n            domainName: 'foobar.com',\n            fileServer: null,\n            props: {\n              domain: 'foobar',\n              tld: 'com',\n              port: '8443',\n            },\n          })\n        }).then(() => {\n          return this.server._onResolveUrl('/index.html', {}, this.automationRequest)\n          .then((obj = {}) => {\n            return expectToEqDetails(obj, {\n              isOkStatusCode: true,\n              isHtml: true,\n              contentType: 'text/html',\n              url: 'http://localhost:2000/index.html',\n              originalUrl: '/index.html',\n              filePath: Fixtures.projectPath('no-server/dev/index.html'),\n              status: 200,\n              statusText: 'OK',\n              redirects: [],\n              cookies: [],\n            })\n          })\n        }).then(() => {\n          return this.rp('http://localhost:2000/index.html')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.body).to.include('document.domain')\n            expect(res.body).to.include('localhost')\n\n            expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n          })\n        }).then(() => {\n          expect(this.server._getRemoteState()).to.deep.eq({\n            auth: undefined,\n            origin: 'http://localhost:2000',\n            strategy: 'file',\n            visiting: false,\n            domainName: 'localhost',\n            fileServer: this.fileServer,\n            props: null,\n          })\n        }).then(() => {\n          return this.server._onResolveUrl('https://www.foobar.com:8443/', {}, this.automationRequest)\n          .then((obj = {}) => {\n            return expectToEqDetails(obj, {\n              isOkStatusCode: true,\n              isHtml: true,\n              contentType: 'text/html',\n              url: 'https://www.foobar.com:8443/',\n              originalUrl: 'https://www.foobar.com:8443/',\n              status: 200,\n              statusText: 'OK',\n              redirects: [],\n              cookies: [],\n            })\n          }).then(() => {\n            return this.rp('https://www.foobar.com:8443/')\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n              expect(res.body).to.include('document.domain')\n              expect(res.body).to.include('foobar.com')\n\n              expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n              expect(res.body).to.include('</script></head><body>https server</body></html>')\n            })\n          }).then(() => {\n            expect(this.server._getRemoteState()).to.deep.eq({\n              auth: undefined,\n              origin: 'https://www.foobar.com:8443',\n              strategy: 'http',\n              visiting: false,\n              fileServer: null,\n              domainName: 'foobar.com',\n              props: {\n                domain: 'foobar',\n                tld: 'com',\n                port: '8443',\n              },\n            })\n          })\n        })\n      })\n\n      it('can go from https -> file -> https without a port', function () {\n        this.timeout(5000)\n\n        return this.server._onResolveUrl(s3StaticHtmlUrl, {}, this.automationRequest)\n        .then((obj = {}) => {\n          return expectToEqDetails(obj, {\n            isOkStatusCode: true,\n            isHtml: true,\n            contentType: 'text/html',\n            url: s3StaticHtmlUrl,\n            originalUrl: s3StaticHtmlUrl,\n            status: 200,\n            statusText: 'OK',\n            redirects: [],\n            cookies: [],\n          })\n        }).then(() => {\n          // @server.onRequest (req, res) ->\n          //   console.log \"ON REQUEST!!!!!!!!!!!!!!!!!!!!!!\"\n\n          //   nock(\"https://s3.amazonaws.com\")\n          //   .get(\"/internal-test-runner-assets.cypress.io/index.html\")\n          //   .reply 200, \"<html><head></head><body>jsonplaceholder</body></html>\", {\n          //     \"Content-Type\": \"text/html\"\n          //   }\n\n          return this.rp(s3StaticHtmlUrl)\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.body).to.include('document.domain')\n            expect(res.body).to.include('amazonaws.com')\n\n            expect(res.body).to.include('Cypress')\n          })\n        }).then(() => {\n          expect(this.server._getRemoteState()).to.deep.eq({\n            auth: undefined,\n            origin: 'https://s3.amazonaws.com',\n            strategy: 'http',\n            visiting: false,\n            domainName: 's3.amazonaws.com',\n            fileServer: null,\n            props: {\n              domain: '',\n              tld: 's3.amazonaws.com',\n              port: '443',\n            },\n          })\n        }).then(() => {\n          return this.server._onResolveUrl('/index.html', {}, this.automationRequest)\n          .then((obj = {}) => {\n            return expectToEqDetails(obj, {\n              isOkStatusCode: true,\n              isHtml: true,\n              contentType: 'text/html',\n              url: 'http://localhost:2000/index.html',\n              originalUrl: '/index.html',\n              filePath: Fixtures.projectPath('no-server/dev/index.html'),\n              status: 200,\n              statusText: 'OK',\n              redirects: [],\n              cookies: [],\n            })\n          })\n        }).then(() => {\n          return this.rp('http://localhost:2000/index.html')\n          .then((res) => {\n            expect(res.statusCode).to.eq(200)\n            expect(res.body).to.include('document.domain')\n            expect(res.body).to.include('localhost')\n\n            expect(res.body).to.include('.action(\"app:window:before:load\",window)')\n          })\n        }).then(() => {\n          expect(this.server._getRemoteState()).to.deep.eq({\n            auth: undefined,\n            origin: 'http://localhost:2000',\n            strategy: 'file',\n            visiting: false,\n            domainName: 'localhost',\n            fileServer: this.fileServer,\n            props: null,\n          })\n        }).then(() => {\n          return this.server._onResolveUrl(s3StaticHtmlUrl, {}, this.automationRequest)\n          .then((obj = {}) => {\n            return expectToEqDetails(obj, {\n              isOkStatusCode: true,\n              isHtml: true,\n              contentType: 'text/html',\n              url: s3StaticHtmlUrl,\n              originalUrl: s3StaticHtmlUrl,\n              status: 200,\n              statusText: 'OK',\n              redirects: [],\n              cookies: [],\n            })\n          }).then(() => {\n            // @server.onNextRequest (req, res) ->\n            //   nock(\"https://s3.amazonaws.com\")\n            //   .get(\"/internal-test-runner-assets.cypress.io/index.html\")\n            //   .reply 200, \"<html><head></head><body>jsonplaceholder</body></html>\", {\n            //     \"Content-Type\": \"text/html\"\n            //   }\n\n            return this.rp(s3StaticHtmlUrl)\n            .then((res) => {\n              expect(res.statusCode).to.eq(200)\n              expect(res.body).to.include('document.domain')\n              expect(res.body).to.include('amazonaws.com')\n\n              expect(res.body).to.include('Cypress')\n            })\n          }).then(() => {\n            expect(this.server._getRemoteState()).to.deep.eq({\n              auth: undefined,\n              origin: 'https://s3.amazonaws.com',\n              strategy: 'http',\n              visiting: false,\n              fileServer: null,\n              domainName: 's3.amazonaws.com',\n              props: {\n                domain: '',\n                tld: 's3.amazonaws.com',\n                port: '443',\n              },\n            })\n          })\n        })\n      })\n    })\n  })\n})\n",
    "packages/server/test/integration/video_capture_spec.ts": "const { expect, sinon } = require('../spec_helper')\nimport videoCapture from '../../lib/video_capture'\nimport path from 'path'\nimport fse from 'fs-extra'\nimport os from 'os'\n\nasync function startSpiedVideoCapture (filename) {\n  const props = await videoCapture.start(filename)\n\n  const END_OF_FILE_ERROR = `ffmpeg exited with code 1: Output #0, mp4, to '${filename}':\nOutput file #0 does not contain any stream\\n`\n\n  sinon.spy(props._pt, 'write')\n\n  function writeVideoFrameAsBuffer (data) {\n    const buf = Buffer.from(data)\n\n    props.writeVideoFrame(buf)\n\n    return buf\n  }\n\n  return {\n    ...props,\n    writeVideoFrameAsBuffer,\n    END_OF_FILE_ERROR,\n  }\n}\n\ndescribe('Video Capture', () => {\n  context('#start', () => {\n    let tmpFilename\n\n    beforeEach(() => {\n      tmpFilename = path.join(fse.mkdtempSync(path.join(os.tmpdir(), 'cy-video-')), 'video.mp4')\n    })\n\n    it('writes video frames to passthru stream', async () => {\n      const { _pt, writeVideoFrameAsBuffer, endVideoCapture, END_OF_FILE_ERROR } = await startSpiedVideoCapture(tmpFilename)\n\n      const [buf] = [\n        writeVideoFrameAsBuffer('foo'),\n        writeVideoFrameAsBuffer('foobar'),\n      ]\n\n      expect(_pt.write).calledWith(buf)\n\n      await expect(endVideoCapture()).rejectedWith(END_OF_FILE_ERROR)\n    })\n\n    it('does not write anything on empty chunk', async () => {\n      const { _pt, writeVideoFrameAsBuffer, endVideoCapture, END_OF_FILE_ERROR } = await startSpiedVideoCapture(tmpFilename)\n\n      const [, buf2] = [\n        writeVideoFrameAsBuffer('foo'),\n        writeVideoFrameAsBuffer('foobar'),\n        writeVideoFrameAsBuffer(''),\n      ]\n\n      expect(_pt.write.lastCall).calledWith(buf2)\n\n      await expect(endVideoCapture()).rejectedWith(END_OF_FILE_ERROR)\n    })\n\n    it('will eventually timeout on single frame write', async () => {\n      const { writeVideoFrameAsBuffer, endVideoCapture } = await startSpiedVideoCapture(tmpFilename)\n\n      writeVideoFrameAsBuffer('foo')\n\n      await expect(endVideoCapture(1)).be.rejectedWith('operation timed out')\n    })\n\n    // https://github.com/cypress-io/cypress/issues/6408\n    it('waits for at least 2 stream writes before ending', async () => {\n      const { writeVideoFrameAsBuffer, endVideoCapture, END_OF_FILE_ERROR } = await startSpiedVideoCapture(tmpFilename)\n\n      writeVideoFrameAsBuffer('foo')\n\n      const endVideoCaptureResult = endVideoCapture()\n\n      writeVideoFrameAsBuffer('foobar')\n\n      await expect(endVideoCaptureResult).rejectedWith(END_OF_FILE_ERROR)\n    })\n  })\n})\n",
    "packages/server/test/integration/websockets_spec.js": "process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0'\nrequire('../spec_helper')\n\nconst ws = require('ws')\nconst httpsProxyAgent = require('https-proxy-agent')\nconst evilDns = require('evil-dns')\nconst Promise = require('bluebird')\nconst socketIo = require(`${root}../socket`)\nconst httpsServer = require(`${root}../https-proxy/test/helpers/https_server`)\nconst config = require(`${root}lib/config`)\nconst { ServerE2E } = require(`${root}lib/server-e2e`)\nconst { Automation } = require(`${root}lib/automation`)\nconst Fixtures = require(`${root}/test/support/helpers/fixtures`)\n\nconst cyPort = 12345\nconst otherPort = 55551\nconst wsPort = 20000\nconst wssPort = 8443\n\ndescribe('Web Sockets', () => {\n  require('mocha-banner').register()\n\n  beforeEach(function () {\n    Fixtures.scaffold()\n\n    this.idsPath = Fixtures.projectPath('ids')\n\n    return config.get(this.idsPath, { port: cyPort })\n    .then((cfg) => {\n      this.cfg = cfg\n      this.ws = new ws.Server({ port: wsPort })\n\n      this.server = new ServerE2E()\n\n      return this.server.open(this.cfg)\n      .then(async () => {\n        const automationStub = {\n          use: () => { },\n        }\n\n        await this.server.startWebsockets(automationStub, config, {})\n\n        return httpsServer.start(wssPort)\n      }).then((httpsSrv) => {\n        this.wss = new ws.Server({ server: httpsSrv })\n      })\n    })\n  })\n\n  afterEach(function () {\n    Fixtures.remove()\n\n    evilDns.clear()\n\n    this.ws.close()\n    this.wss.close()\n\n    return Promise.join(\n      this.server.close(),\n      httpsServer.stop(),\n    )\n  })\n\n  context('proxying external websocket requests', () => {\n    it('sends back ECONNRESET when error upgrading', function (done) {\n      const agent = new httpsProxyAgent(`http://localhost:${cyPort}`)\n\n      this.server._onDomainSet(`http://localhost:${otherPort}`)\n\n      const client = new ws(`ws://localhost:${otherPort}`, {\n        agent,\n      })\n\n      return client.on('error', (err) => {\n        expect(err.code).to.eq('ECONNRESET')\n        expect(err.message).to.eq('socket hang up')\n\n        return done()\n      })\n    })\n\n    it('proxies https messages', function (done) {\n      const agent = new httpsProxyAgent(`http://localhost:${cyPort}`, {\n      })\n\n      this.wss.on('connection', (c) => {\n        return c.on('message', (msg) => {\n          return c.send(`response:${msg}`)\n        })\n      })\n\n      const client = new ws(`wss://localhost:${wssPort}`, {\n        rejectUnauthorized: false,\n        agent,\n      })\n\n      client.on('message', (data) => {\n        expect(data).to.eq('response:foo')\n\n        return done()\n      })\n\n      return client.on('open', () => {\n        return client.send('foo')\n      })\n    })\n\n    it('proxies http messages through http proxy', function (done) {\n      // force node into legit proxy mode like a browser\n      const agent = new httpsProxyAgent(`http://localhost:${cyPort}`)\n\n      this.server._onDomainSet(`http://localhost:${wsPort}`)\n\n      this.ws.on('connection', (c) => {\n        return c.on('message', (msg) => {\n          return c.send(`response:${msg}`)\n        })\n      })\n\n      const client = new ws(`ws://localhost:${wsPort}`, {\n        agent,\n      })\n\n      client.on('message', (data) => {\n        expect(data).to.eq('response:foo')\n\n        return done()\n      })\n\n      return client.on('open', () => {\n        return client.send('foo')\n      })\n    })\n\n    it('proxies https messages through http', function (done) {\n      // force node into legit proxy mode like a browser\n      const agent = new httpsProxyAgent({\n        host: 'localhost',\n        port: cyPort,\n        rejectUnauthorized: false,\n      })\n\n      this.server._onDomainSet(`https://localhost:${wssPort}`)\n\n      this.wss.on('connection', (c) => {\n        return c.on('message', (msg) => {\n          return c.send(`response:${msg}`)\n        })\n      })\n\n      const client = new ws(`wss://localhost:${wssPort}`, {\n        agent,\n      })\n\n      client.on('message', (data) => {\n        expect(data).to.eq('response:foo')\n\n        return done()\n      })\n\n      return client.on('open', () => {\n        return client.send('foo')\n      })\n    })\n\n    it('proxies through subdomain by using host header', function (done) {\n      // we specifically only allow remote connections\n      // to ws.foobar.com since that is where the websocket\n      // server is mounted and this tests that we make\n      // a connection to the right host instead of the\n      // origin (which isnt ws.foobar.com)\n      nock.enableNetConnect('ws.foobar.com')\n\n      evilDns.add('ws.foobar.com', '127.0.0.1')\n\n      // force node into legit proxy mode like a browser\n      const agent = new httpsProxyAgent({\n        host: 'localhost',\n        port: cyPort,\n        rejectUnauthorized: false,\n      })\n\n      this.server._onDomainSet(`https://foobar.com:${wssPort}`)\n\n      this.wss.on('connection', (c) => {\n        return c.on('message', (msg) => {\n          return c.send(`response:${msg}`)\n        })\n      })\n\n      const client = new ws(`wss://ws.foobar.com:${wssPort}`, {\n        agent,\n      })\n\n      client.on('message', (data) => {\n        expect(data).to.eq('response:foo')\n\n        return done()\n      })\n\n      return client.on('open', () => {\n        return client.send('foo')\n      })\n    })\n  })\n\n  context('socket.io handling', () => {\n    beforeEach(function () {\n      this.automation = new Automation(this.cfg.namespace, this.cfg.socketIoCookie, this.cfg.screenshotsFolder)\n\n      return this.server.startWebsockets(this.automation, this.cfg, {})\n    })\n\n    const testSocketIo = function (wsUrl, beforeFn) {\n      context('behind Cy proxy', () => {\n        beforeEach(function (done) {\n          // force node into legit proxy mode like a browser\n          const agent = new httpsProxyAgent(`http://localhost:${cyPort}`)\n\n          if (beforeFn != null) {\n            beforeFn.call(this)\n          }\n\n          this.wsClient = socketIo.client(wsUrl || this.cfg.proxyUrl, {\n            agent,\n            path: this.cfg.socketIoRoute,\n            transports: ['websocket'],\n            rejectUnauthorized: false,\n          })\n\n          return this.wsClient.on('connect', () => {\n            return done()\n          })\n        })\n\n        afterEach(function () {\n          return this.wsClient.disconnect()\n        })\n\n        it('continues to handle socket.io requests just fine', function (done) {\n          return this.wsClient.emit('backend:request', 'get:fixture', 'example.json', {}, (data) => {\n            expect(data.response).to.deep.eq({ foo: 'bar' })\n\n            return done()\n          })\n        })\n      })\n\n      context('without Cy proxy', () => {\n        beforeEach(function () {\n          return (beforeFn != null ? beforeFn.call(this) : undefined)\n        })\n\n        afterEach(function () {\n          return this.wsClient.disconnect()\n        })\n\n        it('fails to connect via websocket', function (done) {\n          this.wsClient = socketIo.client(wsUrl || this.cfg.proxyUrl, {\n            path: this.cfg.socketIoRoute,\n            transports: ['websocket'],\n            rejectUnauthorized: false,\n            reconnection: false,\n          })\n\n          this.wsClient.on('connect', () => {\n            return done(new Error('should not have been able to connect'))\n          })\n\n          return this.wsClient.io.on('error', () => {\n            return done()\n          })\n        })\n\n        it('fails to connect via polling', function (done) {\n          this.wsClient = socketIo.client(wsUrl || this.cfg.proxyUrl, {\n            path: this.cfg.socketIoRoute,\n            transports: ['polling'],\n            rejectUnauthorized: false,\n            reconnection: false,\n          })\n\n          this.wsClient.on('connect', () => {\n            return done(new Error('should not have been able to connect'))\n          })\n\n          return this.wsClient.io.on('error', () => {\n            return done()\n          })\n        })\n      })\n    }\n\n    context('http', () => {\n      return testSocketIo()\n    })\n\n    context('when http superDomain has been set', () => {\n      return testSocketIo(`http://localhost:${otherPort}`, function () {\n        return this.server._onDomainSet(`http://localhost:${otherPort}`)\n      })\n    })\n\n    context('when https superDomain has been set', () => {\n      return testSocketIo(`http://localhost:${wssPort}`, function () {\n        return this.server._onDomainSet(`http://localhost:${wssPort}`)\n      })\n    })\n  })\n})\n",
    "packages/server/test/support/fixtures/projects/ids/cypress/integration/es6.js": "const numbers = [1, 2, 3]\nconst sameNumbers = [...numbers]\n\nasync function resolvePromise () {\n  await Promise.resolve('foo')\n}\n",
    "packages/server/test/support/helpers/e2e.ts": "import { expect, root } from '../../spec_helper'\n\nrequire('mocha-banner').register()\nconst chalk = require('chalk').default\nconst _ = require('lodash')\nlet cp = require('child_process')\nconst path = require('path')\nconst http = require('http')\nconst human = require('human-interval')\nconst morgan = require('morgan')\nconst stream = require('stream')\nconst express = require('express')\nconst Bluebird = require('bluebird')\nconst snapshot = require('snap-shot-it')\nconst debug = require('debug')('cypress:support:e2e')\nconst httpsProxy = require('@packages/https-proxy')\nconst Fixtures = require('./fixtures')\nconst { fs } = require(`${root}../lib/util/fs`)\nconst { allowDestroy } = require(`${root}../lib/util/server_destroy`)\nconst cypress = require(`${root}../lib/cypress`)\nconst screenshots = require(`${root}../lib/screenshots`)\nconst videoCapture = require(`${root}../lib/video_capture`)\nconst settings = require(`${root}../lib/util/settings`)\n\n// mutates mocha test runner - needed for `test.titlePath`\nrequire(`${root}../lib/project-e2e`)\n\ncp = Bluebird.promisifyAll(cp)\n\nconst env = _.clone(process.env)\n\nBluebird.config({\n  longStackTraces: true,\n})\n\nconst e2ePath = Fixtures.projectPath('e2e')\nconst pathUpToProjectName = Fixtures.projectPath('')\n\nconst DEFAULT_BROWSERS = ['electron', 'chrome', 'firefox']\n\nconst stackTraceLinesRe = /(\\n?[^\\S\\n\\r]*).*?(@|\\bat\\b).*\\.(js|coffee|ts|html|jsx|tsx)(-\\d+)?:\\d+:\\d+[\\n\\S\\s]*?(\\n\\s*?\\n|$)/g\nconst browserNameVersionRe = /(Browser\\:\\s+)(Custom |)(Electron|Chrome|Canary|Chromium|Firefox)(\\s\\d+)(\\s\\(\\w+\\))?(\\s+)/\nconst availableBrowsersRe = /(Available browsers found on your system are:)([\\s\\S]+)/g\nconst crossOriginErrorRe = /(Blocked a frame .* from accessing a cross-origin frame.*|Permission denied.*cross-origin object.*)/gm\nconst whiteSpaceBetweenNewlines = /\\n\\s+\\n/\nconst retryDuration = /Timed out retrying after (\\d+)ms/g\nconst escapedRetryDuration = /TORA(\\d+)/g\n\nexport const STDOUT_DURATION_IN_TABLES_RE = /(\\s+?)(\\d+ms|\\d+:\\d+:?\\d+)/g\n\n// this captures an entire stack trace and replaces it with [stack trace lines]\n// so that the stdout can contain stack traces of different lengths\n// '@' will be present in firefox stack trace lines\n// 'at' will be present in chrome stack trace lines\nconst replaceStackTraceLines = (str) => {\n  return str.replace(stackTraceLinesRe, (match, ...parts) => {\n    const isFirefoxStack = parts[1] === '@'\n    let post = parts[4]\n\n    if (isFirefoxStack) {\n      post = post.replace(whiteSpaceBetweenNewlines, '\\n')\n    }\n\n    return `\\n      [stack trace lines]${post}`\n  })\n}\n\nconst replaceBrowserName = function (str, key, customBrowserPath, browserName, version, headless, whitespace) {\n  // get the padding for the existing browser string\n  const lengthOfExistingBrowserString = _.sum([browserName.length, version.length, _.get(headless, 'length', 0), whitespace.length])\n\n  // this ensures we add whitespace so the border is not shifted\n  return key + customBrowserPath + _.padEnd('FooBrowser 88', lengthOfExistingBrowserString)\n}\n\nconst replaceDurationSeconds = function (str, p1, p2, p3, p4) {\n  // get the padding for the existing duration\n  const lengthOfExistingDuration = _.sum([(p2 != null ? p2.length : undefined) || 0, p3.length, p4.length])\n\n  return p1 + _.padEnd('X seconds', lengthOfExistingDuration)\n}\n\n// duration='1589'\nconst replaceDurationFromReporter = (str, p1, p2, p3) => {\n  return p1 + _.padEnd('X', p2.length, 'X') + p3\n}\n\nconst replaceNodeVersion = (str, p1, p2, p3) => _.padEnd(`${p1}X (/foo/bar/node)`, (p1.length + p2.length + p3.length))\n\nconst replaceCypressVersion = (str, p1, p2) => {\n  // Cypress: 12.10.10 -> Cypress: 1.2.3 (handling padding)\n  return _.padEnd(`${p1}1.2.3`, (p1.length + p2.length))\n}\n\n// when swapping out the duration, ensure we pad the\n// full length of the duration so it doesn't shift content\nconst replaceDurationInTables = (str, p1, p2) => {\n  return _.padStart('XX:XX', p1.length + p2.length)\n}\n\n// could be (1 second) or (10 seconds)\n// need to account for shortest and longest\nconst replaceParenTime = (str, p1) => {\n  return _.padStart('(X second)', p1.length)\n}\n\nconst replaceScreenshotDims = (str, p1) => _.padStart('(YxX)', p1.length)\n\nconst replaceUploadingResults = function (orig, ...rest) {\n  const adjustedLength = Math.max(rest.length, 2)\n  const match = rest.slice(0, adjustedLength - 2)\n  const results = match[1].split('\\n').map((res) => res.replace(/\\(\\d+\\/(\\d+)\\)/g, '(*/$1)'))\n  .sort()\n  .join('\\n')\n  const ret = match[0] + results + match[3]\n\n  return ret\n}\n\n/**\n * Takes normalized runner STDOUT, finds the \"Run Finished\" line\n * and returns everything AFTER that, which usually is just the\n * test summary table.\n * @param {string} stdout from the test run, probably normalized\n*/\nconst leaveRunFinishedTable = (stdout) => {\n  const index = stdout.indexOf('  (Run Finished)')\n\n  if (index === -1) {\n    throw new Error('Cannot find Run Finished line')\n  }\n\n  return stdout.slice(index)\n}\n\nconst normalizeStdout = function (str, options: any = {}) {\n  const { normalizeStdoutAvailableBrowsers } = options\n\n  // remove all of the dynamic parts of stdout\n  // to normalize against what we expected\n  str = str\n  // /Users/jane/........../ -> //foo/bar/.projects/\n  // (Required when paths are printed outside of our own formatting)\n  .split(pathUpToProjectName).join('/foo/bar/.projects')\n\n  // unless normalization is explicitly turned off then\n  // always normalize the stdout replacing the browser text\n  if (normalizeStdoutAvailableBrowsers !== false) {\n    // usually we are not interested in the browsers detected on this particular system\n    // but some tests might filter / change the list of browsers\n    // in that case the test should pass \"normalizeStdoutAvailableBrowsers: false\" as options\n    str = str.replace(availableBrowsersRe, '$1\\n- browser1\\n- browser2\\n- browser3')\n  }\n\n  str = str\n  .replace(browserNameVersionRe, replaceBrowserName)\n  // numbers in parenths\n  .replace(/\\s\\(\\d+([ms]|ms)\\)/g, '')\n  // escape \"Timed out retrying\" messages\n  .replace(retryDuration, 'TORA$1')\n  // 12:35 -> XX:XX\n  .replace(STDOUT_DURATION_IN_TABLES_RE, replaceDurationInTables)\n  // restore \"Timed out retrying\" messages\n  .replace(escapedRetryDuration, 'Timed out retrying after $1ms')\n  .replace(/(coffee|js)-\\d{3}/g, '$1-456')\n  // Cypress: 2.1.0 -> Cypress: 1.2.3\n  .replace(/(Cypress\\:\\s+)(\\d+\\.\\d+\\.\\d+)/g, replaceCypressVersion)\n  // Node Version: 10.2.3 (Users/jane/node) -> Node Version: X (foo/bar/node)\n  .replace(/(Node Version\\:\\s+v)(\\d+\\.\\d+\\.\\d+)( \\(.*\\)\\s+)/g, replaceNodeVersion)\n  // 15 seconds -> X second\n  .replace(/(Duration\\:\\s+)(\\d+\\sminutes?,\\s+)?(\\d+\\sseconds?)(\\s+)/g, replaceDurationSeconds)\n  // duration='1589' -> duration='XXXX'\n  .replace(/(duration\\=\\')(\\d+)(\\')/g, replaceDurationFromReporter)\n  // (15 seconds) -> (XX seconds)\n  .replace(/(\\((\\d+ minutes?,\\s+)?\\d+ seconds?\\))/g, replaceParenTime)\n  .replace(/\\r/g, '')\n  // replaces multiple lines of uploading results (since order not guaranteed)\n  .replace(/(Uploading Results.*?\\n\\n)((.*-.*[\\s\\S\\r]){2,}?)(\\n\\n)/g, replaceUploadingResults)\n  // fix \"Require stacks\" for CI\n  .replace(/^(\\- )(\\/.*\\/packages\\/server\\/)(.*)$/gm, '$1$3')\n  // Different browsers have different cross-origin error messages\n  .replace(crossOriginErrorRe, '[Cross origin error message]')\n\n  if (options.sanitizeScreenshotDimensions) {\n    // screenshot dimensions\n    str = str.replace(/(\\(\\d+x\\d+\\))/g, replaceScreenshotDims)\n  }\n\n  return replaceStackTraceLines(str)\n}\n\nconst ensurePort = function (port) {\n  if (port === 5566) {\n    throw new Error('Specified port cannot be on 5566 because it conflicts with --inspect-brk=5566')\n  }\n}\n\nconst startServer = function (obj) {\n  const { onServer, port, https } = obj\n\n  ensurePort(port)\n\n  const app = express()\n\n  const srv = https ? httpsProxy.httpsServer(app) : new http.Server(app)\n\n  allowDestroy(srv)\n\n  app.use(morgan('dev'))\n\n  if (obj.cors) {\n    app.use(require('cors')())\n  }\n\n  const s = obj.static\n\n  if (s) {\n    const opts = _.isObject(s) ? s : {}\n\n    app.use(express.static(e2ePath, opts))\n  }\n\n  return new Bluebird((resolve) => {\n    return srv.listen(port, () => {\n      console.log(`listening on port: ${port}`)\n      if (typeof onServer === 'function') {\n        onServer(app, srv)\n      }\n\n      return resolve(srv)\n    })\n  })\n}\n\nconst stopServer = (srv) => srv.destroyAsync()\n\nconst copy = function () {\n  const ca = process.env.CIRCLE_ARTIFACTS\n\n  debug('Should copy Circle Artifacts?', Boolean(ca))\n\n  if (ca) {\n    const videosFolder = path.join(e2ePath, 'cypress/videos')\n    const screenshotsFolder = path.join(e2ePath, 'cypress/screenshots')\n\n    debug('Copying Circle Artifacts', ca, videosFolder, screenshotsFolder)\n\n    // copy each of the screenshots and videos\n    // to artifacts using each basename of the folders\n    return Bluebird.join(\n      screenshots.copy(\n        screenshotsFolder,\n        path.join(ca, path.basename(screenshotsFolder)),\n      ),\n      videoCapture.copy(\n        videosFolder,\n        path.join(ca, path.basename(videosFolder)),\n      ),\n    )\n  }\n}\n\nconst getMochaItFn = function (only, skip, browser, specifiedBrowser) {\n  // if we've been told to skip this test\n  // or if we specified a particular browser and this\n  // doesn't match the one we're currently trying to run...\n  if (skip || (specifiedBrowser && (specifiedBrowser !== browser))) {\n    // then skip this test\n    return it.skip\n  }\n\n  if (only) {\n    return it.only\n  }\n\n  return it\n}\n\nfunction getBrowsers (browserPattern) {\n  if (!browserPattern.length) {\n    return DEFAULT_BROWSERS\n  }\n\n  let selected = []\n\n  const addBrowsers = _.clone(browserPattern)\n  const removeBrowsers = _.remove(addBrowsers, (b) => b.startsWith('!')).map((b) => b.slice(1))\n\n  if (removeBrowsers.length) {\n    selected = _.without(DEFAULT_BROWSERS, ...removeBrowsers)\n  } else {\n    selected = _.intersection(DEFAULT_BROWSERS, addBrowsers)\n  }\n\n  if (!selected.length) {\n    throw new Error(`options.browser: \"${browserPattern}\" matched no browsers`)\n  }\n\n  return selected\n}\n\nconst normalizeToArray = (value) => {\n  if (value && !_.isArray(value)) {\n    return [value]\n  }\n\n  return value\n}\n\nconst localItFn = function (title, opts = {}) {\n  opts.browser = normalizeToArray(opts.browser)\n\n  const DEFAULT_OPTIONS = {\n    only: false,\n    skip: false,\n    browser: [],\n    snapshot: false,\n    spec: 'no spec name supplied!',\n    onStdout: _.noop,\n    onRun (execFn, browser, ctx) {\n      return execFn()\n    },\n  }\n\n  const options = _.defaults({}, opts, DEFAULT_OPTIONS)\n\n  if (!title) {\n    throw new Error('e2e.it(...) must be passed a title as the first argument')\n  }\n\n  // LOGIC FOR AUTOGENERATING DYNAMIC TESTS\n  // - create multiple tests for each default browser\n  // - if browser is specified in options:\n  //   ...skip the tests for each default browser if that browser\n  //   ...does not match the specified one (used in CI)\n\n  // run the tests for all the default browsers, or if a browser\n  // has been specified, only run it for that\n  const specifiedBrowser = process.env.BROWSER\n  const browsersToTest = getBrowsers(options.browser)\n\n  const browserToTest = function (browser) {\n    const mochaItFn = getMochaItFn(options.only, options.skip, browser, specifiedBrowser)\n\n    const testTitle = `${title} [${browser}]`\n\n    return mochaItFn(testTitle, function () {\n      if (options.useSeparateBrowserSnapshots) {\n        title = testTitle\n      }\n\n      const originalTitle = this.test.parent.titlePath().concat(title).join(' / ')\n\n      const ctx = this\n\n      const execFn = (overrides = {}) => {\n        return e2e.exec(ctx, _.extend({ originalTitle }, options, overrides, { browser }))\n      }\n\n      return options.onRun(execFn, browser, ctx)\n    })\n  }\n\n  return _.each(browsersToTest, browserToTest)\n}\n\nlocalItFn.only = function (title, options) {\n  options.only = true\n\n  return localItFn(title, options)\n}\n\nlocalItFn.skip = function (title, options) {\n  options.skip = true\n\n  return localItFn(title, options)\n}\n\nconst maybeVerifyExitCode = (expectedExitCode, fn) => {\n  // bail if this is explicitly null so\n  // devs can turn off checking the exit code\n  if (expectedExitCode === null) {\n    return\n  }\n\n  return fn()\n}\n\nconst e2e = {\n\n  replaceStackTraceLines,\n\n  normalizeStdout,\n\n  leaveRunFinishedTable,\n\n  it: localItFn,\n\n  snapshot (...args) {\n    args = _.compact(args)\n\n    return snapshot.apply(null, args)\n  },\n\n  setup (options = {}) {\n    // cleanup old node_modules that may have been around from legacy tests\n    before(() => {\n      return fs.removeAsync(Fixtures.path('projects/e2e/node_modules'))\n    })\n\n    beforeEach(async function () {\n      // after installing node modules copying all of the fixtures\n      // can take a long time (5-15 secs)\n      this.timeout(human('2 minutes'))\n      Fixtures.scaffold()\n\n      if (process.env.NO_EXIT) {\n        Fixtures.scaffoldWatch()\n      }\n\n      sinon.stub(process, 'exit')\n\n      if (options.servers) {\n        const optsServers = [].concat(options.servers)\n\n        const servers = await Bluebird.map(optsServers, startServer)\n\n        this.servers = servers\n      } else {\n        this.servers = null\n      }\n\n      const s = options.settings\n\n      if (s) {\n        await settings.write(e2ePath, s)\n      }\n    })\n\n    afterEach(async function () {\n      process.env = _.clone(env)\n\n      this.timeout(human('2 minutes'))\n\n      Fixtures.remove()\n\n      const s = this.servers\n\n      if (s) {\n        await Bluebird.map(s, stopServer)\n      }\n    })\n  },\n\n  options (ctx, options = {}) {\n    if (options.inspectBrk != null) {\n      throw new Error(`\n      passing { inspectBrk: true } to e2e options is no longer supported\n      Please pass the --cypress-inspect-brk flag to the test command instead\n      e.g. \"yarn test test/e2e/1_async_timeouts_spec.js --cypress-inspect-brk\"\n      `)\n    }\n\n    _.defaults(options, {\n      browser: 'electron',\n      headed: process.env.HEADED || false,\n      project: e2ePath,\n      timeout: 120000,\n      originalTitle: null,\n      expectedExitCode: 0,\n      sanitizeScreenshotDimensions: false,\n      normalizeStdoutAvailableBrowsers: true,\n      noExit: process.env.NO_EXIT,\n      inspectBrk: process.env.CYPRESS_INSPECT_BRK,\n    })\n\n    if (options.exit != null) {\n      throw new Error(`\n      passing { exit: false } to e2e options is no longer supported\n      Please pass the --no-exit flag to the test command instead\n      e.g. \"yarn test test/e2e/1_async_timeouts_spec.js --no-exit\"\n      `)\n    }\n\n    if (options.noExit && options.timeout < 3000000) {\n      options.timeout = 3000000\n    }\n\n    ctx.timeout(options.timeout)\n\n    const { spec } = options\n\n    if (spec) {\n      // normalize into array and then prefix\n      const specs = spec.split(',').map((spec) => {\n        if (path.isAbsolute(spec)) {\n          return spec\n        }\n\n        // TODO would not work for component tests\n        return path.join(options.project, 'cypress', 'integration', spec)\n      })\n\n      // normalize the path to the spec\n      options.spec = specs.join(',')\n    }\n\n    return options\n  },\n\n  args (options = {}) {\n    debug('converting options to args %o', { options })\n\n    const args = [\n      // hides a user warning to go through NPM module\n      `--cwd=${process.cwd()}`,\n      `--run-project=${options.project}`,\n      `--testingType=e2e`,\n    ]\n\n    if (options.testingType === 'component') {\n      args.push('--component-testing')\n    }\n\n    if (options.spec) {\n      args.push(`--spec=${options.spec}`)\n    }\n\n    if (options.port) {\n      ensurePort(options.port)\n      args.push(`--port=${options.port}`)\n    }\n\n    if (!_.isUndefined(options.headed)) {\n      args.push('--headed', options.headed)\n    }\n\n    if (options.record) {\n      args.push('--record')\n    }\n\n    if (options.quiet) {\n      args.push('--quiet')\n    }\n\n    if (options.parallel) {\n      args.push('--parallel')\n    }\n\n    if (options.group) {\n      args.push(`--group=${options.group}`)\n    }\n\n    if (options.ciBuildId) {\n      args.push(`--ci-build-id=${options.ciBuildId}`)\n    }\n\n    if (options.key) {\n      args.push(`--key=${options.key}`)\n    }\n\n    if (options.reporter) {\n      args.push(`--reporter=${options.reporter}`)\n    }\n\n    if (options.reporterOptions) {\n      args.push(`--reporter-options=${options.reporterOptions}`)\n    }\n\n    if (options.browser) {\n      args.push(`--browser=${options.browser}`)\n    }\n\n    if (options.config) {\n      args.push('--config', JSON.stringify(options.config))\n    }\n\n    if (options.env) {\n      args.push('--env', options.env)\n    }\n\n    if (options.outputPath) {\n      args.push('--output-path', options.outputPath)\n    }\n\n    if (options.noExit) {\n      args.push('--no-exit')\n    }\n\n    if (options.inspectBrk) {\n      args.push('--inspect-brk')\n    }\n\n    if (options.tag) {\n      args.push(`--tag=${options.tag}`)\n    }\n\n    if (options.configFile) {\n      args.push(`--config-file=${options.configFile}`)\n    }\n\n    return args\n  },\n\n  start (ctx, options = {}) {\n    options = this.options(ctx, options)\n    const args = this.args(options)\n\n    return cypress.start(args)\n    .then(() => {\n      const { expectedExitCode } = options\n\n      maybeVerifyExitCode(expectedExitCode, () => {\n        expect(process.exit).to.be.calledWith(expectedExitCode)\n      })\n    })\n  },\n\n  /**\n   * Executes a given project and optionally sanitizes and checks output.\n   * @example\n    ```\n      e2e.setup()\n      project = Fixtures.projectPath(\"component-tests\")\n      e2e.exec(this, {\n        project,\n        config: {\n          video: false\n        }\n      })\n      .then (result) ->\n        console.log(e2e.normalizeStdout(result.stdout))\n    ```\n   */\n  exec (ctx, options = {}) {\n    debug('e2e exec options %o', options)\n    options = this.options(ctx, options)\n    debug('processed options %o', options)\n    let args = this.args(options)\n\n    const specifiedBrowser = process.env.BROWSER\n\n    if (specifiedBrowser && (![].concat(options.browser).includes(specifiedBrowser))) {\n      ctx.skip()\n    }\n\n    if (options.stubPackage) {\n      Fixtures.installStubPackage(options.project, options.stubPackage)\n    }\n\n    args = ['index.js'].concat(args)\n\n    let stdout = ''\n    let stderr = ''\n\n    const exit = function (code) {\n      const { expectedExitCode } = options\n\n      maybeVerifyExitCode(expectedExitCode, () => {\n        expect(code).to.eq(expectedExitCode, 'expected exit code')\n      })\n\n      // snapshot the stdout!\n      if (options.snapshot) {\n        // enable callback to modify stdout\n        const ostd = options.onStdout\n\n        if (ostd) {\n          const newStdout = ostd(stdout)\n\n          if (_.isString(newStdout)) {\n            stdout = newStdout\n          }\n        }\n\n        // if we have browser in the stdout make\n        // sure its legit\n        const matches = browserNameVersionRe.exec(stdout)\n\n        if (matches) {\n          // eslint-disable-next-line no-unused-vars\n          const [, , customBrowserPath, browserName, version, headless] = matches\n\n          const { browser } = options\n\n          if (browser && !customBrowserPath) {\n            expect(_.capitalize(browser)).to.eq(browserName)\n          }\n\n          expect(parseFloat(version)).to.be.a.number\n\n          // if we are in headed mode or headed is undefined in a browser other\n          // than electron\n          if (options.headed || (_.isUndefined(options.headed) && browser && browser !== 'electron')) {\n            expect(headless).not.to.exist\n          } else {\n            expect(headless).to.include('(headless)')\n          }\n        }\n\n        const str = normalizeStdout(stdout, options)\n\n        if (options.originalTitle) {\n          snapshot(options.originalTitle, str, { allowSharedSnapshot: true })\n        } else {\n          snapshot(str)\n        }\n      }\n\n      return {\n        code,\n        stdout,\n        stderr,\n      }\n    }\n\n    return new Bluebird((resolve, reject) => {\n      debug('spawning Cypress %o', { args })\n      const sp = cp.spawn('node', args, {\n        env: _.chain(process.env)\n        .omit('CYPRESS_DEBUG')\n        .extend({\n          // FYI: color will be disabled\n          // because we are piping the child process\n          COLUMNS: 100,\n          LINES: 24,\n        })\n        .defaults({\n          // match CircleCI's filesystem limits, so screenshot names in snapshots match\n          CYPRESS_MAX_SAFE_FILENAME_BYTES: 242,\n          FAKE_CWD_PATH: '/XXX/XXX/XXX',\n          DEBUG_COLORS: '1',\n          // prevent any Compression progress\n          // messages from showing up\n          VIDEO_COMPRESSION_THROTTLE: 120000,\n\n          // don't fail our own tests running from forked PR's\n          CYPRESS_INTERNAL_E2E_TESTS: '1',\n\n          // Emulate no typescript environment\n          CYPRESS_INTERNAL_NO_TYPESCRIPT: options.noTypeScript ? '1' : '0',\n\n          // force file watching for use with --no-exit\n          ...(options.noExit ? { CYPRESS_INTERNAL_FORCE_FILEWATCH: '1' } : {}),\n        })\n        .extend(options.processEnv)\n        .value(),\n      })\n\n      const ColorOutput = function () {\n        const colorOutput = new stream.Transform()\n\n        colorOutput._transform = (chunk, encoding, cb) => cb(null, chalk.magenta(chunk.toString()))\n\n        return colorOutput\n      }\n\n      // pipe these to our current process\n      // so we can see them in the terminal\n      // color it so we can tell which is test output\n      sp.stdout\n      .pipe(ColorOutput())\n      .pipe(process.stdout)\n\n      sp.stderr\n      .pipe(ColorOutput())\n      .pipe(process.stderr)\n\n      sp.stdout.on('data', (buf) => stdout += buf.toString())\n      sp.stderr.on('data', (buf) => stderr += buf.toString())\n      sp.on('error', reject)\n\n      return sp.on('exit', resolve)\n    }).tap(copy)\n    .then(exit)\n  },\n\n  sendHtml (contents) {\n    return function (req, res) {\n      res.set('Content-Type', 'text/html')\n\n      return res.send(`\\\n<!DOCTYPE html>\n<html lang=\"en\">\n<body>\n  ${contents}\n</body>\n</html>\\\n`)\n    }\n  },\n\n  normalizeWebpackErrors (stdout) {\n    return stdout\n    .replace(/using description file: .* \\(relative/g, 'using description file: [..] (relative')\n    .replace(/Module build failed \\(from .*\\)/g, 'Module build failed (from [..])')\n  },\n\n  normalizeRuns (runs) {\n    runs.forEach((run) => {\n      run.tests.forEach((test) => {\n        test.attempts.forEach((attempt) => {\n          const codeFrame = attempt.error && attempt.error.codeFrame\n\n          if (codeFrame) {\n            codeFrame.absoluteFile = codeFrame.absoluteFile.split(pathUpToProjectName).join('/foo/bar/.projects')\n          }\n        })\n      })\n    })\n\n    return runs\n  },\n}\n\nexport {\n  e2e as default,\n  expect,\n}\n",
    "packages/server/test/support/helpers/fixtures.js": "const fs = require('fs-extra')\nconst path = require('path')\nconst chokidar = require('chokidar')\n\nconst root = path.join(__dirname, '..', '..', '..')\nconst projects = path.join(root, 'test', 'support', 'fixtures', 'projects')\nconst tmpDir = path.join(root, '.projects')\n\n// copy contents instead of deleting+creating new file, which can cause\n// filewatchers to lose track of toFile.\nconst copyContents = (fromFile, toFile) => {\n  return Promise.all([\n    fs.open(toFile, 'w'),\n    fs.readFile(fromFile),\n  ])\n  .then(([toFd, fromFileBuf]) => {\n    return fs.write(toFd, fromFileBuf)\n    .finally(() => {\n      return fs.close(toFd)\n    })\n  })\n}\n\nmodule.exports = {\n  // copies all of the project fixtures\n  // to the tmpDir .projects in the root\n  scaffold () {\n    return fs.copySync(projects, tmpDir)\n  },\n\n  scaffoldWatch () {\n    const watchdir = path.resolve(__dirname, '../fixtures/projects')\n\n    console.log('watching files due to --no-exit', watchdir)\n\n    chokidar.watch(watchdir, {\n    })\n    .on('change', (srcFilepath, stats) => {\n      const tmpFilepath = path.join(tmpDir, path.relative(watchdir, srcFilepath))\n\n      return copyContents(srcFilepath, tmpFilepath)\n    })\n    .on('error', console.error)\n  },\n\n  // removes all of the project fixtures\n  // from the tmpDir .projects in the root\n  remove () {\n    return fs.removeSync(tmpDir)\n  },\n\n  async installStubPackage (projectPath, pkgName) {\n    const pathToPkg = path.join(projectPath, 'node_modules', pkgName)\n\n    await fs.outputJSON(path.join(projectPath, 'package.json'), { name: 'some-project' })\n    await fs.mkdirp(pathToPkg)\n    await fs.outputFile(path.join(pathToPkg, 'index.js'), '')\n  },\n\n  // returns the path to project fixture\n  // in the tmpDir\n  project (...args) {\n    return this.projectPath.apply(this, args)\n  },\n\n  projectPath (name) {\n    return path.join(tmpDir, name)\n  },\n\n  get (fixture, encoding = 'utf8') {\n    return fs.readFileSync(path.join(root, 'test', 'support', 'fixtures', fixture), encoding)\n  },\n\n  path (fixture) {\n    return path.join(root, 'test', 'support', 'fixtures', fixture)\n  },\n}\n",
    "packages/server/test/unit/browsers/cri-client_spec.ts": "import Bluebird from 'bluebird'\nimport { create } from '../../../lib/browsers/cri-client'\nimport EventEmitter from 'events'\n\nconst { expect, proxyquire, sinon } = require('../../spec_helper')\n\nconst DEBUGGER_URL = 'http://foo'\n\ndescribe('lib/browsers/cri-client', function () {\n  let criClient: {\n    create: typeof create\n  }\n  let send: sinon.SinonStub\n  let criImport: sinon.SinonStub\n  let onError: sinon.SinonStub\n  let getClient: () => ReturnType<typeof create>\n\n  beforeEach(function () {\n    sinon.stub(Bluebird, 'promisify').returnsArg(0)\n\n    send = sinon.stub()\n    onError = sinon.stub()\n\n    criImport = sinon.stub()\n    .withArgs({\n      target: DEBUGGER_URL,\n      local: true,\n    })\n    .resolves({\n      send,\n      close: sinon.stub(),\n      _notifier: new EventEmitter(),\n    })\n\n    criClient = proxyquire('../lib/browsers/cri-client', {\n      'chrome-remote-interface': criImport,\n    })\n\n    getClient = () => criClient.create(DEBUGGER_URL, onError)\n  })\n\n  context('.create', function () {\n    it('returns an instance of the CRI client', async function () {\n      const client = await getClient()\n\n      expect(client.send).to.be.instanceOf(Function)\n    })\n\n    context('#send', function () {\n      it('calls cri.send with command and data', async function () {\n        send.resolves()\n        const client = await getClient()\n\n        client.send('Browser.getVersion', { baz: 'quux' })\n        expect(send).to.be.calledWith('Browser.getVersion', { baz: 'quux' })\n      })\n\n      it('rejects if cri.send rejects', async function () {\n        const err = new Error\n\n        send.rejects(err)\n        const client = await getClient()\n\n        await expect(client.send('Browser.getVersion', { baz: 'quux' }))\n        .to.be.rejectedWith(err)\n      })\n\n      context('retries', () => {\n        ([\n          'WebSocket is not open',\n          // @see https://github.com/cypress-io/cypress/issues/7180\n          'WebSocket is already in CLOSING or CLOSED state',\n        ]).forEach((msg) => {\n          it(`with '${msg}'`, async function () {\n            const err = new Error(msg)\n\n            send.onFirstCall().rejects(err)\n            send.onSecondCall().resolves()\n\n            const client = await getClient()\n\n            await client.send('Browser.getVersion', { baz: 'quux' })\n\n            expect(send).to.be.calledTwice\n          })\n        })\n      })\n    })\n\n    context('#ensureMinimumProtocolVersion', function () {\n      function withProtocolVersion (actual, test) {\n        if (actual) {\n          send.withArgs('Browser.getVersion')\n          .resolves({ protocolVersion: actual })\n        }\n\n        return getClient()\n        .then((client) => {\n          return client.ensureMinimumProtocolVersion(test)\n        })\n      }\n\n      it('resolves if protocolVersion = current', function () {\n        return expect(withProtocolVersion('1.3', '1.3')).to.be.fulfilled\n      })\n\n      it('resolves if protocolVersion > current', function () {\n        return expect(withProtocolVersion('1.4', '1.3')).to.be.fulfilled\n      })\n\n      it('rejects if Browser.getVersion not supported yet', function () {\n        send.withArgs('Browser.getVersion')\n        .rejects()\n\n        return expect(withProtocolVersion(null, '1.3')).to.be\n        .rejectedWith('A minimum CDP version of v1.3 is required, but the current browser has an older version.')\n      })\n\n      it('rejects if protocolVersion < current', function () {\n        return expect(withProtocolVersion('1.2', '1.3')).to.be\n        .rejectedWith('A minimum CDP version of v1.3 is required, but the current browser has v1.2.')\n      })\n    })\n  })\n})\n",
    "packages/server/test/unit/browsers/firefox_spec.ts": "require('../../spec_helper')\n\nimport 'chai-as-promised'\nimport { expect } from 'chai'\nimport { EventEmitter } from 'events'\nimport Foxdriver from '@benmalka/foxdriver'\nimport Marionette from 'marionette-client'\nimport os from 'os'\nimport sinon from 'sinon'\nimport * as firefox from '../../../lib/browsers/firefox'\nimport firefoxUtil from '../../../lib/browsers/firefox-util'\n\nconst mockfs = require('mock-fs')\nconst FirefoxProfile = require('firefox-profile')\nconst launch = require('@packages/launcher/lib/browsers')\nconst utils = require('../../../lib/browsers/utils')\nconst plugins = require('../../../lib/plugins')\nconst protocol = require('../../../lib/browsers/protocol')\nconst specUtil = require('../../specUtils')\n\ndescribe('lib/browsers/firefox', () => {\n  const port = 3333\n  let marionetteDriver: any\n  let marionetteSendCb: any\n  let foxdriver: any\n  let foxdriverTab: any\n\n  const stubMarionette = () => {\n    marionetteSendCb = null\n\n    const connect = sinon.stub()\n\n    connect.resolves()\n\n    const send = sinon.stub().callsFake((opts) => {\n      if (marionetteSendCb) {\n        return marionetteSendCb(opts)\n      }\n\n      return Promise.resolve()\n    })\n\n    const close = sinon.stub()\n\n    const socket = new EventEmitter()\n    const client = new EventEmitter()\n\n    const tcp = { socket, client }\n\n    marionetteDriver = {\n      tcp, connect, send, close,\n    }\n\n    sinon.stub(Marionette.Drivers, 'Promises').returns(marionetteDriver)\n  }\n\n  const stubFoxdriver = () => {\n    foxdriverTab = {\n      data: '',\n      memory: {\n        isAttached: false,\n        getState: sinon.stub().resolves(),\n        attach: sinon.stub().resolves(),\n        on: sinon.stub(),\n        forceGarbageCollection: sinon.stub().resolves(),\n        forceCycleCollection: sinon.stub().resolves(),\n      },\n    }\n\n    const browser = {\n      listTabs: sinon.stub().resolves([foxdriverTab]),\n      request: sinon.stub().withArgs('listTabs').resolves({ tabs: [foxdriverTab] }),\n      on: sinon.stub(),\n    }\n\n    foxdriver = {\n      browser,\n    }\n\n    sinon.stub(Foxdriver, 'attach').resolves(foxdriver)\n  }\n\n  afterEach(() => {\n    return mockfs.restore()\n  })\n\n  beforeEach(() => {\n    sinon.stub(utils, 'getProfileDir').returns('/path/to/appData/firefox-stable/interactive')\n\n    mockfs({\n      '/path/to/appData/firefox-stable/interactive': {},\n    })\n\n    sinon.stub(protocol, '_connectAsync').resolves(null)\n\n    stubMarionette()\n    stubFoxdriver()\n  })\n\n  context('#open', () => {\n    beforeEach(function () {\n      this.browser = { name: 'firefox', channel: 'stable' }\n      this.options = {\n        proxyUrl: 'http://proxy-url',\n        socketIoRoute: 'socket/io/route',\n        browser: this.browser,\n      }\n\n      this.browserInstance = {\n        // should be high enough to not kill any real PIDs\n        pid: Number.MAX_SAFE_INTEGER,\n      }\n\n      sinon.stub(process, 'pid').value(1111)\n\n      protocol.foo = 'bar'\n\n      sinon.stub(plugins, 'has')\n      sinon.stub(plugins, 'execute')\n      sinon.stub(utils, 'writeExtension').resolves('/path/to/ext')\n      sinon.stub(launch, 'launch').resolves(this.browserInstance)\n      sinon.spy(FirefoxProfile.prototype, 'setPreference')\n      sinon.spy(FirefoxProfile.prototype, 'updatePreferences')\n\n      return sinon.spy(FirefoxProfile.prototype, 'path')\n    })\n\n    it('executes before:browser:launch if registered', function () {\n      plugins.has.returns(true)\n      plugins.execute.resolves(null)\n\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(plugins.execute).to.be.called\n      })\n    })\n\n    it('does not execute before:browser:launch if not registered', function () {\n      plugins.has.returns(false)\n\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(plugins.execute).not.to.be.called\n      })\n    })\n\n    it('uses default preferences if before:browser:launch returns falsy value', function () {\n      plugins.has.returns(true)\n      plugins.execute.resolves(null)\n\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(FirefoxProfile.prototype.setPreference).to.be.calledWith('network.proxy.type', 1)\n      })\n    })\n\n    it('uses default preferences if before:browser:launch returns object with non-object preferences', function () {\n      plugins.has.returns(true)\n      plugins.execute.resolves({\n        preferences: [],\n      })\n\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(FirefoxProfile.prototype.setPreference).to.be.calledWith('network.proxy.type', 1)\n      })\n    })\n\n    it('sets preferences if returned by before:browser:launch', function () {\n      plugins.has.returns(true)\n      plugins.execute.resolves({\n        preferences: { 'foo': 'bar' },\n      })\n\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(FirefoxProfile.prototype.setPreference).to.be.calledWith('foo', 'bar')\n      })\n    })\n\n    it('adds extensions returned by before:browser:launch, along with cypress extension', function () {\n      plugins.has.returns(true)\n      plugins.execute.resolves({\n        extensions: ['/path/to/user/ext'],\n      })\n\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(marionetteDriver.send).calledWithMatch({ name: 'Addon:Install', params: { path: '/path/to/ext' } })\n\n        expect(marionetteDriver.send).calledWithMatch({ name: 'Addon:Install', params: { path: '/path/to/user/ext' } })\n      })\n    })\n\n    it('adds only cypress extension if before:browser:launch returns object with non-array extensions', function () {\n      plugins.has.returns(true)\n      plugins.execute.resolves({\n        extensions: 'not-an-array',\n      })\n\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(marionetteDriver.send).calledWithMatch({ name: 'Addon:Install', params: { path: '/path/to/ext' } })\n\n        expect(marionetteDriver.send).not.calledWithMatch({ name: 'Addon:Install', params: { path: '/path/to/user/ext' } })\n      })\n    })\n\n    it('sets user-agent preference if specified', function () {\n      this.options.userAgent = 'User Agent'\n\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(FirefoxProfile.prototype.setPreference).to.be.calledWith('general.useragent.override', 'User Agent')\n      })\n    })\n\n    it('writes extension', function () {\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(utils.writeExtension).to.be.calledWith(this.options.browser, this.options.isTextTerminal, this.options.proxyUrl, this.options.socketIoRoute)\n      })\n    })\n\n    // TODO: pick open port for debugger\n    it.skip('finds remote port for firefox debugger', function () {\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        // expect(firefoxUtil.findRemotePort).to.be.called\n      })\n    })\n\n    it('sets proxy-related preferences if specified', function () {\n      this.options.proxyServer = 'http://proxy-server:1234'\n\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(FirefoxProfile.prototype.setPreference).to.be.calledWith('network.proxy.http', 'proxy-server')\n        expect(FirefoxProfile.prototype.setPreference).to.be.calledWith('network.proxy.ssl', 'proxy-server')\n        expect(FirefoxProfile.prototype.setPreference).to.be.calledWith('network.proxy.http_port', 1234)\n        expect(FirefoxProfile.prototype.setPreference).to.be.calledWith('network.proxy.ssl_port', 1234)\n\n        expect(FirefoxProfile.prototype.setPreference).to.be.calledWith('network.proxy.no_proxies_on')\n      })\n    })\n\n    it('does not set proxy-related preferences if not specified', function () {\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(FirefoxProfile.prototype.setPreference).not.to.be.calledWith('network.proxy.http', 'proxy-server')\n        expect(FirefoxProfile.prototype.setPreference).not.to.be.calledWith('network.proxy.https', 'proxy-server')\n        expect(FirefoxProfile.prototype.setPreference).not.to.be.calledWith('network.proxy.http_port', 1234)\n        expect(FirefoxProfile.prototype.setPreference).not.to.be.calledWith('network.proxy.https_port', 1234)\n\n        expect(FirefoxProfile.prototype.setPreference).not.to.be.calledWith('network.proxy.no_proxies_on')\n      })\n    })\n\n    it('updates the preferences', function () {\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(FirefoxProfile.prototype.updatePreferences).to.be.called\n      })\n    })\n\n    it('launches with the url and args', function () {\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(launch.launch).to.be.calledWith(this.browser, 'about:blank', [\n          '-marionette',\n          '-new-instance',\n          '-foreground',\n          '-start-debugger-server',\n          '-no-remote',\n          '-profile',\n          '/path/to/appData/firefox-stable/interactive',\n        ])\n      })\n    })\n\n    it('resolves the browser instance', function () {\n      return firefox.open(this.browser, 'http://', this.options).then((result) => {\n        expect(result).to.equal(this.browserInstance)\n      })\n    })\n\n    it('does not clear user profile if already exists', function () {\n      mockfs({\n        '/path/to/appData/firefox-stable/interactive/': {\n          'xulstore.json': '[foo xulstore.json]',\n          'chrome': { 'userChrome.css': '[foo userChrome.css]' },\n        },\n      })\n\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        // @ts-ignore\n        expect(specUtil.getFsPath('/path/to/appData/firefox-stable/interactive')).containSubset({\n          'xulstore.json': '[foo xulstore.json]',\n          'chrome': { 'userChrome.css': '[foo userChrome.css]' },\n        })\n      })\n    })\n\n    it('creates xulstore.json if not exist', function () {\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        // @ts-ignore\n        expect(specUtil.getFsPath('/path/to/appData/firefox-stable/interactive')).containSubset({\n          'xulstore.json': '{\"chrome://browser/content/browser.xhtml\":{\"main-window\":{\"width\":1280,\"height\":1024,\"sizemode\":\"maximized\"}}}\\n',\n        })\n      })\n    })\n\n    it('creates chrome/userChrome.css if not exist', function () {\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        expect(specUtil.getFsPath('/path/to/appData/firefox-stable/interactive/chrome/userChrome.css')).ok\n      })\n    })\n\n    it('clears browser cache', function () {\n      mockfs({\n        '/path/to/appData/firefox-stable/interactive/': {\n          'CypressCache': { 'foo': 'bar' },\n        },\n      })\n\n      this.options.isTextTerminal = false\n\n      return firefox.open(this.browser, 'http://', this.options).then(() => {\n        // @ts-ignore\n        expect(specUtil.getFsPath('/path/to/appData/firefox-stable/interactive')).containSubset({\n          'CypressCache': {},\n        })\n      })\n    })\n\n    it('wraps errors when retrying socket fails', async function () {\n      const err = new Error\n\n      protocol._connectAsync.rejects()\n\n      await expect(firefox.open(this.browser, 'http://', this.options)).to.be.rejectedWith()\n      .then((wrapperErr) => {\n        expect(wrapperErr.message).to.include('Cypress failed to make a connection to Firefox.')\n        expect(wrapperErr.message).to.include(err.message)\n      })\n    })\n\n    context('returns BrowserInstance', function () {\n      it('from browsers.launch', async function () {\n        const instance = await firefox.open(this.browser, 'http://', this.options)\n\n        expect(instance).to.eq(this.browserInstance)\n      })\n\n      // @see https://github.com/cypress-io/cypress/issues/6392\n      it('detached on Windows', async function () {\n        sinon.stub(os, 'platform').returns('win32')\n        const instance = await firefox.open(this.browser, 'http://', this.options)\n\n        expect(instance).to.not.eq(this.browserInstance)\n        expect(instance.pid).to.eq(this.browserInstance.pid)\n\n        await new Promise((resolve) => {\n          // ensure events are wired as expected\n          instance.on('exit', resolve)\n          instance.kill()\n        })\n      })\n    })\n  })\n\n  context('firefox-util', () => {\n    context('#setupMarionette', () => {\n      // @see https://github.com/cypress-io/cypress/issues/7159\n      it('attaches geckodriver after testing connection', async () => {\n        await firefoxUtil.setupMarionette([], '', port)\n\n        expect(marionetteDriver.connect).to.be.calledOnce\n        expect(protocol._connectAsync).to.be.calledWith({\n          host: '127.0.0.1',\n          port,\n          getDelayMsForRetry: sinon.match.func,\n        })\n      })\n\n      it('rejects on errors on socket', async () => {\n        marionetteSendCb = () => {\n          marionetteDriver.tcp.socket.emit('error', new Error('foo error'))\n\n          return Promise.resolve()\n        }\n\n        await expect(firefoxUtil.setupMarionette([], '', port))\n        .to.be.rejectedWith('An unexpected error was received from Marionette Socket:\\n\\nError: foo error')\n      })\n\n      it('rejects on errors from marionette commands', async () => {\n        marionetteSendCb = () => {\n          return Promise.reject(new Error('foo error'))\n        }\n\n        await expect(firefoxUtil.setupMarionette([], '', port))\n        .to.be.rejectedWith('An unexpected error was received from Marionette commands:\\n\\nError: foo error')\n      })\n\n      it('rejects on errors during initial Marionette connection', async () => {\n        marionetteDriver.connect.rejects(new Error('not connectable'))\n\n        await expect(firefoxUtil.setupMarionette([], '', port))\n        .to.be.rejectedWith('An unexpected error was received from Marionette connection:\\n\\nError: not connectable')\n      })\n    })\n\n    context('#setupFoxdriver', () => {\n      it('attaches foxdriver after testing connection', async () => {\n        await firefoxUtil.setupFoxdriver(port)\n\n        expect(Foxdriver.attach).to.be.calledWith('127.0.0.1', port)\n        expect(protocol._connectAsync).to.be.calledWith({\n          host: '127.0.0.1',\n          port,\n          getDelayMsForRetry: sinon.match.func,\n        })\n      })\n\n      it('sets the collectGarbage callback which can be used to force GC+CC', async () => {\n        await firefoxUtil.setupFoxdriver(port)\n\n        const { memory } = foxdriverTab\n\n        expect(memory.forceCycleCollection).to.not.be.called\n        expect(memory.forceGarbageCollection).to.not.be.called\n\n        await firefoxUtil.collectGarbage()\n\n        expect(memory.forceCycleCollection).to.be.calledOnce\n        expect(memory.forceGarbageCollection).to.be.calledOnce\n\n        await firefoxUtil.collectGarbage()\n\n        expect(memory.forceCycleCollection).to.be.calledTwice\n        expect(memory.forceGarbageCollection).to.be.calledTwice\n      })\n    })\n  })\n})\n",
    "packages/server/test/unit/browsers/protocol_spec.ts": "import '../../spec_helper'\nimport _ from 'lodash'\nimport Bluebird from 'bluebird'\nimport 'chai-as-promised' // for the types!\nimport chalk from 'chalk'\nimport { connect } from '@packages/network'\nimport CRI from 'chrome-remote-interface'\nimport { expect } from 'chai'\nimport humanInterval from 'human-interval'\nimport * as protocol from '../../../lib/browsers/protocol'\nimport sinon from 'sinon'\nimport snapshot from 'snap-shot-it'\nimport stripAnsi from 'strip-ansi'\nimport { stripIndents } from 'common-tags'\n\ndescribe('lib/browsers/protocol', () => {\n  // protocol connects explicitly to this host\n  const host = '127.0.0.1'\n\n  context('._getDelayMsForRetry', () => {\n    it('retries as expected for up to 50 seconds', () => {\n      const log = sinon.spy(console, 'log')\n\n      let delays = []\n      let delay: number\n      let i = 0\n\n      while ((delay = protocol._getDelayMsForRetry(i))) {\n        delays.push(delay)\n        i++\n      }\n\n      expect(_.sum(delays)).to.eq(humanInterval('50 seconds'))\n\n      log.getCalls().forEach((log, i) => {\n        const line = stripAnsi(log.args[0])\n\n        expect(line).to.include(`Failed to connect to Chrome, retrying in 1 second (attempt ${i + 18}/62)`)\n      })\n\n      snapshot(delays)\n    })\n  })\n\n  context('.getWsTargetFor', () => {\n    const expectedCdpFailedError = stripIndents`\n      Cypress failed to make a connection to the Chrome DevTools Protocol after retrying for 50 seconds.\n\n      This usually indicates there was a problem opening the Chrome browser.\n\n      The CDP port requested was ${chalk.yellow('12345')}.\n\n      Error details:\n    `\n\n    it('rejects if CDP connection fails', () => {\n      const innerErr = new Error('cdp connection failure')\n\n      sinon.stub(connect, 'createRetryingSocket').callsArgWith(1, innerErr)\n      const p = protocol.getWsTargetFor(12345)\n\n      return expect(p).to.eventually.be.rejected\n      .and.property('message').include(expectedCdpFailedError)\n      .and.include(innerErr.message)\n    })\n\n    it('rejects if CRI.List fails', () => {\n      const innerErr = new Error('cdp connection failure')\n\n      sinon.stub(Bluebird, 'delay').resolves()\n\n      sinon.stub(CRI, 'List')\n      .withArgs({ host, port: 12345, getDelayMsForRetry: sinon.match.func })\n      .rejects(innerErr)\n\n      const end = sinon.stub()\n\n      sinon.stub(connect, 'createRetryingSocket').callsArgWith(1, null, { end })\n\n      const p = protocol.getWsTargetFor(12345)\n\n      return expect(p).to.eventually.be.rejected\n      .and.property('message').include(expectedCdpFailedError)\n      .and.include(innerErr.message)\n    })\n\n    it('returns the debugger URL of the first about:blank tab', async () => {\n      const targets = [\n        {\n          type: 'page',\n          url: 'chrome://newtab',\n          webSocketDebuggerUrl: 'foo',\n        },\n        {\n          type: 'page',\n          url: 'about:blank',\n          webSocketDebuggerUrl: 'bar',\n        },\n      ]\n\n      const end = sinon.stub()\n\n      sinon.stub(CRI, 'List')\n      .withArgs({ host, port: 12345, getDelayMsForRetry: sinon.match.func })\n      .resolves(targets)\n\n      sinon.stub(connect, 'createRetryingSocket').callsArgWith(1, null, { end })\n\n      const p = protocol.getWsTargetFor(12345)\n\n      await expect(p).to.eventually.equal('bar')\n      expect(end).to.be.calledOnce\n    })\n  })\n\n  context('CRI.List', () => {\n    const port = 1234\n    const targets = [\n      {\n        type: 'page',\n        url: 'chrome://newtab',\n        webSocketDebuggerUrl: 'foo',\n      },\n      {\n        type: 'page',\n        url: 'about:blank',\n        webSocketDebuggerUrl: 'ws://debug-url',\n      },\n    ]\n\n    it('retries several times if starting page cannot be found', async () => {\n      const end = sinon.stub()\n\n      sinon.stub(connect, 'createRetryingSocket').callsArgWith(1, null, { end })\n\n      const criList = sinon.stub(CRI, 'List')\n      .withArgs({ host, port, getDelayMsForRetry: sinon.match.func }).resolves(targets)\n      .onFirstCall().resolves([])\n      .onSecondCall().resolves([])\n      .onThirdCall().resolves(targets)\n\n      const targetUrl = await protocol.getWsTargetFor(port)\n\n      expect(criList).to.have.been.calledThrice\n      expect(targetUrl).to.equal('ws://debug-url')\n    })\n\n    it('logs correctly if retries occur while connecting to CDP and while listing CRI targets', async () => {\n      const log = sinon.spy(console, 'log')\n\n      const end = sinon.stub()\n\n      // fail 20 times to get 2 log lines from connect failures\n      sinon.stub(connect, 'createRetryingSocket').callsFake((opts, cb) => {\n        _.times(20, (i) => {\n          opts.getDelayMsForRetry(i, new Error)\n        })\n\n        // @ts-ignore\n        return cb(null, { end })\n      })\n\n      sinon.stub(Bluebird, 'delay').resolves()\n\n      // fail an additional 2 times on CRI.List\n      const criList = sinon.stub(CRI, 'List')\n      .withArgs({ host, port, getDelayMsForRetry: sinon.match.func }).resolves(targets)\n      .onFirstCall().resolves([])\n      .onSecondCall().resolves([])\n      .onThirdCall().resolves(targets)\n\n      const targetUrl = await protocol.getWsTargetFor(port)\n\n      expect(criList).to.have.been.calledThrice\n      expect(targetUrl).to.equal('ws://debug-url')\n\n      // 2 from connect failing, 2 from CRI.List failing\n      expect(log).to.have.callCount(4)\n\n      log.getCalls().forEach((log, i) => {\n        const line = stripAnsi(log.args[0])\n\n        expect(line).to.include(`Failed to connect to Chrome, retrying in 1 second (attempt ${i + 18}/62)`)\n      })\n    })\n  })\n})\n",
    "packages/server/test/unit/config_spec.js": "require('../spec_helper')\n\nconst _ = require('lodash')\nconst path = require('path')\nconst R = require('ramda')\nconst debug = require('debug')('test')\nconst config = require(`${root}lib/config`)\nconst errors = require(`${root}lib/errors`)\nconst configUtil = require(`${root}lib/util/config`)\nconst findSystemNode = require(`${root}lib/util/find_system_node`)\nconst scaffold = require(`${root}lib/scaffold`)\nlet settings = require(`${root}lib/util/settings`)\n\ndescribe('lib/config', () => {\n  beforeEach(function () {\n    this.env = process.env\n\n    process.env = _.omit(process.env, 'CYPRESS_DEBUG')\n  })\n\n  afterEach(function () {\n    process.env = this.env\n  })\n\n  context('environment name check', () => {\n    it('throws an error for unknown CYPRESS_INTERNAL_ENV', () => {\n      sinon.stub(errors, 'throw').withArgs('INVALID_CYPRESS_INTERNAL_ENV', 'foo-bar')\n      process.env.CYPRESS_INTERNAL_ENV = 'foo-bar'\n      const cfg = {\n        projectRoot: '/foo/bar/',\n      }\n      const options = {}\n\n      config.mergeDefaults(cfg, options)\n\n      expect(errors.throw).have.been.calledOnce\n    })\n\n    it('allows production CYPRESS_INTERNAL_ENV', () => {\n      sinon.stub(errors, 'throw')\n      process.env.CYPRESS_INTERNAL_ENV = 'production'\n      const cfg = {\n        projectRoot: '/foo/bar/',\n      }\n      const options = {}\n\n      config.mergeDefaults(cfg, options)\n\n      expect(errors.throw).not.to.be.called\n    })\n  })\n\n  context('.get', () => {\n    beforeEach(function () {\n      this.projectRoot = '/_test-output/path/to/project'\n\n      this.setup = (cypressJson = {}, cypressEnvJson = {}) => {\n        sinon.stub(settings, 'read').withArgs(this.projectRoot).resolves(cypressJson)\n        sinon.stub(settings, 'readEnv').withArgs(this.projectRoot).resolves(cypressEnvJson)\n      }\n    })\n\n    it('sets projectRoot', function () {\n      this.setup({}, { foo: 'bar' })\n\n      return config.get(this.projectRoot)\n      .then((obj) => {\n        expect(obj.projectRoot).to.eq(this.projectRoot)\n\n        expect(obj.env).to.deep.eq({ foo: 'bar' })\n      })\n    })\n\n    it('sets projectName', function () {\n      this.setup({}, { foo: 'bar' })\n\n      return config.get(this.projectRoot)\n      .then((obj) => {\n        expect(obj.projectName).to.eq('project')\n      })\n    })\n\n    it('clones settings and env settings, so they are not mutated', function () {\n      const settings = { foo: 'bar' }\n      const envSettings = { baz: 'qux' }\n\n      this.setup(settings, envSettings)\n\n      return config.get(this.projectRoot)\n      .then(() => {\n        expect(settings).to.deep.equal({ foo: 'bar' })\n        expect(envSettings).to.deep.equal({ baz: 'qux' })\n      })\n    })\n\n    context('port', () => {\n      beforeEach(function () {\n        return this.setup({}, { foo: 'bar' })\n      })\n\n      it('can override default port', function () {\n        return config.get(this.projectRoot, { port: 8080 })\n        .then((obj) => {\n          expect(obj.port).to.eq(8080)\n        })\n      })\n\n      it('updates browserUrl', function () {\n        return config.get(this.projectRoot, { port: 8080 })\n        .then((obj) => {\n          expect(obj.browserUrl).to.eq('http://localhost:8080/__/')\n        })\n      })\n\n      it('updates proxyUrl', function () {\n        return config.get(this.projectRoot, { port: 8080 })\n        .then((obj) => {\n          expect(obj.proxyUrl).to.eq('http://localhost:8080')\n        })\n      })\n    })\n\n    context('validation', () => {\n      beforeEach(function () {\n        this.expectValidationPasses = () => {\n          return config.get(this.projectRoot) // shouldn't throw\n        }\n\n        this.expectValidationFails = (errorMessage = 'validation error') => {\n          return config.get(this.projectRoot)\n          .then(() => {\n            throw new Error('should throw validation error')\n          }).catch((err) => {\n            expect(err.message).to.include(errorMessage)\n          })\n        }\n      })\n\n      it('values are optional', function () {\n        this.setup()\n\n        return this.expectValidationPasses()\n      })\n\n      it('validates cypress.json', function () {\n        this.setup({ reporter: 5 })\n\n        return this.expectValidationFails('cypress.json')\n      })\n\n      it('validates cypress.env.json', function () {\n        this.setup({}, { reporter: 5 })\n\n        return this.expectValidationFails('cypress.env.json')\n      })\n\n      it('only validates known values', function () {\n        this.setup({ foo: 'bar' })\n\n        return this.expectValidationPasses()\n      })\n\n      context('animationDistanceThreshold', () => {\n        it('passes if a number', function () {\n          this.setup({ animationDistanceThreshold: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ animationDistanceThreshold: { foo: 'bar' } })\n          this.expectValidationFails('be a number')\n\n          return this.expectValidationFails('the value was: \\`{\"foo\":\"bar\"}\\`')\n        })\n      })\n\n      context('baseUrl', () => {\n        it('passes if begins with http://', function () {\n          this.setup({ baseUrl: 'http://example.com' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if begins with https://', function () {\n          this.setup({ baseUrl: 'https://example.com' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string', function () {\n          this.setup({ baseUrl: false })\n\n          return this.expectValidationFails('be a fully qualified URL')\n        })\n\n        it('fails if not a fully qualified url', function () {\n          this.setup({ baseUrl: 'localhost' })\n\n          return this.expectValidationFails('be a fully qualified URL')\n        })\n      })\n\n      context('chromeWebSecurity', () => {\n        it('passes if a boolean', function () {\n          this.setup({ chromeWebSecurity: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a boolean', function () {\n          this.setup({ chromeWebSecurity: 42 })\n          this.expectValidationFails('be a boolean')\n\n          return this.expectValidationFails('the value was: `42`')\n        })\n      })\n\n      context('modifyObstructiveCode', () => {\n        it('passes if a boolean', function () {\n          this.setup({ modifyObstructiveCode: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a boolean', function () {\n          this.setup({ modifyObstructiveCode: 42 })\n          this.expectValidationFails('be a boolean')\n\n          return this.expectValidationFails('the value was: `42`')\n        })\n      })\n\n      context('component', () => {\n        it('passes if an object with valid properties', function () {\n          this.setup({\n            component: {\n              baseUrl: 'https://cypress.com',\n              execTimeout: 10000,\n            },\n          })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a plain object', function () {\n          this.setup({ component: false })\n          this.expectValidationFails('to be a plain object')\n\n          return this.expectValidationFails('the value was: `false`')\n        })\n\n        it('fails if nested property is incorrect', function () {\n          this.setup({ component: { baseUrl: false } })\n          this.expectValidationFails('Expected `component.baseUrl` to be a fully qualified URL (starting with `http://` or `https://`).')\n\n          return this.expectValidationFails('the value was: `false`')\n        })\n      })\n\n      context('e2e', () => {\n        it('passes if an object with valid properties', function () {\n          this.setup({\n            e2e: {\n              baseUrl: 'https://cypress.com',\n              execTimeout: 10000,\n            },\n          })\n        })\n\n        it('fails if not a plain object', function () {\n          this.setup({ e2e: false })\n          this.expectValidationFails('to be a plain object')\n\n          return this.expectValidationFails('the value was: `false`')\n        })\n\n        it('fails if nested property is incorrect', function () {\n          this.setup({ e2e: { animationDistanceThreshold: 'this is definitely not a number' } })\n          this.expectValidationFails('Expected `e2e.animationDistanceThreshold` to be a number')\n\n          return this.expectValidationFails('the value was: `\"this is definitely not a number\"`')\n        })\n\n        it('fails if nested property is incorrect', function () {\n          this.setup({ component: { baseUrl: false } })\n          this.expectValidationFails('Expected `component.baseUrl` to be a fully qualified URL (starting with `http://` or `https://`).')\n\n          return this.expectValidationFails('the value was: `false`')\n        })\n      })\n\n      context('defaultCommandTimeout', () => {\n        it('passes if a number', function () {\n          this.setup({ defaultCommandTimeout: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ defaultCommandTimeout: 'foo' })\n          this.expectValidationFails('be a number')\n\n          return this.expectValidationFails('the value was: `\"foo\"`')\n        })\n      })\n\n      context('env', () => {\n        it('passes if an object', function () {\n          this.setup({ env: {} })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not an object', function () {\n          this.setup({ env: 'not an object that\\'s for sure' })\n\n          return this.expectValidationFails('a plain object')\n        })\n      })\n\n      context('execTimeout', () => {\n        it('passes if a number', function () {\n          this.setup({ execTimeout: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ execTimeout: 'foo' })\n\n          return this.expectValidationFails('be a number')\n        })\n      })\n\n      context('taskTimeout', () => {\n        it('passes if a number', function () {\n          this.setup({ taskTimeout: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ taskTimeout: 'foo' })\n\n          return this.expectValidationFails('be a number')\n        })\n      })\n\n      context('fileServerFolder', () => {\n        it('passes if a string', function () {\n          this.setup({ fileServerFolder: '_files' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string', function () {\n          this.setup({ fileServerFolder: true })\n          this.expectValidationFails('be a string')\n\n          return this.expectValidationFails('the value was: `true`')\n        })\n      })\n\n      context('fixturesFolder', () => {\n        it('passes if a string', function () {\n          this.setup({ fixturesFolder: '_fixtures' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if false', function () {\n          this.setup({ fixturesFolder: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string or false', function () {\n          this.setup({ fixturesFolder: true })\n\n          return this.expectValidationFails('be a string or false')\n        })\n      })\n\n      context('ignoreTestFiles', () => {\n        it('passes if a string', function () {\n          this.setup({ ignoreTestFiles: '*.jsx' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if an array of strings', function () {\n          this.setup({ ignoreTestFiles: ['*.jsx'] })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string or array', function () {\n          this.setup({ ignoreTestFiles: 5 })\n\n          return this.expectValidationFails('be a string or an array of strings')\n        })\n\n        it('fails if not an array of strings', function () {\n          this.setup({ ignoreTestFiles: [5] })\n          this.expectValidationFails('be a string or an array of strings')\n\n          return this.expectValidationFails('the value was: `[5]`')\n        })\n      })\n\n      context('integrationFolder', () => {\n        it('passes if a string', function () {\n          this.setup({ integrationFolder: '_tests' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string', function () {\n          this.setup({ integrationFolder: true })\n\n          return this.expectValidationFails('be a string')\n        })\n      })\n\n      context('downloadsFolder', () => {\n        it('passes if a string', function () {\n          this.setup({ downloadsFolder: '_downloads' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string', function () {\n          this.setup({ downloadsFolder: true })\n\n          return this.expectValidationFails('be a string')\n        })\n      })\n\n      context('userAgent', () => {\n        it('passes if a string', function () {\n          this.setup({ userAgent: '_tests' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string', function () {\n          this.setup({ userAgent: true })\n\n          return this.expectValidationFails('be a string')\n        })\n      })\n\n      context('numTestsKeptInMemory', () => {\n        it('passes if a number', function () {\n          this.setup({ numTestsKeptInMemory: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ numTestsKeptInMemory: 'foo' })\n\n          return this.expectValidationFails('be a number')\n        })\n      })\n\n      context('pageLoadTimeout', () => {\n        it('passes if a number', function () {\n          this.setup({ pageLoadTimeout: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ pageLoadTimeout: 'foo' })\n\n          return this.expectValidationFails('be a number')\n        })\n      })\n\n      context('pluginsFile', () => {\n        it('passes if a string', function () {\n          this.setup({ pluginsFile: 'cypress/plugins' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if false', function () {\n          this.setup({ pluginsFile: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string or false', function () {\n          this.setup({ pluginsFile: 42 })\n\n          return this.expectValidationFails('be a string')\n        })\n      })\n\n      context('port', () => {\n        it('passes if a number', function () {\n          this.setup({ port: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ port: 'foo' })\n\n          return this.expectValidationFails('be a number')\n        })\n      })\n\n      context('reporter', () => {\n        it('passes if a string', function () {\n          this.setup({ reporter: '_custom' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string', function () {\n          this.setup({ reporter: true })\n\n          return this.expectValidationFails('be a string')\n        })\n      })\n\n      context('requestTimeout', () => {\n        it('passes if a number', function () {\n          this.setup({ requestTimeout: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ requestTimeout: 'foo' })\n\n          return this.expectValidationFails('be a number')\n        })\n      })\n\n      context('responseTimeout', () => {\n        it('passes if a number', function () {\n          this.setup({ responseTimeout: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ responseTimeout: 'foo' })\n\n          return this.expectValidationFails('be a number')\n        })\n      })\n\n      context('testFiles', () => {\n        it('passes if a string', function () {\n          this.setup({ testFiles: '**/*.coffee' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if an array of strings', function () {\n          this.setup({ testFiles: ['**/*.coffee', '**/*.jsx'] })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string or array', function () {\n          this.setup({ testFiles: 42 })\n\n          return this.expectValidationFails('be a string or an array of strings')\n        })\n\n        it('fails if not an array of strings', function () {\n          this.setup({ testFiles: [5] })\n          this.expectValidationFails('be a string or an array of strings')\n\n          return this.expectValidationFails('the value was: `[5]`')\n        })\n      })\n\n      context('supportFile', () => {\n        it('passes if a string', function () {\n          this.setup({ supportFile: 'cypress/support' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if false', function () {\n          this.setup({ supportFile: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string or false', function () {\n          this.setup({ supportFile: true })\n\n          return this.expectValidationFails('be a string or false')\n        })\n      })\n\n      context('trashAssetsBeforeRuns', () => {\n        it('passes if a boolean', function () {\n          this.setup({ trashAssetsBeforeRuns: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a boolean', function () {\n          this.setup({ trashAssetsBeforeRuns: 42 })\n\n          return this.expectValidationFails('be a boolean')\n        })\n      })\n\n      context('videoCompression', () => {\n        it('passes if a number', function () {\n          this.setup({ videoCompression: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if false', function () {\n          this.setup({ videoCompression: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ videoCompression: 'foo' })\n\n          return this.expectValidationFails('be a number or false')\n        })\n      })\n\n      context('video', () => {\n        it('passes if a boolean', function () {\n          this.setup({ video: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a boolean', function () {\n          this.setup({ video: 42 })\n\n          return this.expectValidationFails('be a boolean')\n        })\n      })\n\n      context('videoUploadOnPasses', () => {\n        it('passes if a boolean', function () {\n          this.setup({ videoUploadOnPasses: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a boolean', function () {\n          this.setup({ videoUploadOnPasses: 99 })\n\n          return this.expectValidationFails('be a boolean')\n        })\n      })\n\n      context('videosFolder', () => {\n        it('passes if a string', function () {\n          this.setup({ videosFolder: '_videos' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string', function () {\n          this.setup({ videosFolder: true })\n\n          return this.expectValidationFails('be a string')\n        })\n      })\n\n      context('screenshotOnRunFailure', () => {\n        it('passes if a boolean', function () {\n          this.setup({ screenshotOnRunFailure: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a boolean', function () {\n          this.setup({ screenshotOnRunFailure: 42 })\n\n          return this.expectValidationFails('be a boolean')\n        })\n      })\n\n      context('viewportHeight', () => {\n        it('passes if a number', function () {\n          this.setup({ viewportHeight: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ viewportHeight: 'foo' })\n\n          return this.expectValidationFails('be a number')\n        })\n      })\n\n      context('viewportWidth', () => {\n        it('passes if a number', function () {\n          this.setup({ viewportWidth: 10 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a number', function () {\n          this.setup({ viewportWidth: 'foo' })\n\n          return this.expectValidationFails('be a number')\n        })\n      })\n\n      context('waitForAnimations', () => {\n        it('passes if a boolean', function () {\n          this.setup({ waitForAnimations: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a boolean', function () {\n          this.setup({ waitForAnimations: 42 })\n\n          return this.expectValidationFails('be a boolean')\n        })\n      })\n\n      context('scrollBehavior', () => {\n        it('passes if false', function () {\n          this.setup({ scrollBehavior: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if an enum (center)', function () {\n          this.setup({ scrollBehavior: 'center' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if an enum (top)', function () {\n          this.setup({ scrollBehavior: 'top' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if an enum (bottom)', function () {\n          this.setup({ scrollBehavior: 'bottom' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if an enum (nearest)', function () {\n          this.setup({ scrollBehavior: 'nearest' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not valid (number)', function () {\n          this.setup({ scrollBehavior: 42 })\n\n          return this.expectValidationFails('be one of these values')\n        })\n\n        it('fails if not a valid (null)', function () {\n          this.setup({ scrollBehavior: null })\n\n          return this.expectValidationFails('be one of these values')\n        })\n\n        it('fails if not a valid (true)', function () {\n          this.setup({ scrollBehavior: true })\n\n          return this.expectValidationFails('be one of these values')\n        })\n      })\n\n      context('watchForFileChanges', () => {\n        it('passes if a boolean', function () {\n          this.setup({ watchForFileChanges: false })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a boolean', function () {\n          this.setup({ watchForFileChanges: 42 })\n\n          return this.expectValidationFails('be a boolean')\n        })\n      })\n\n      context('blockHosts', () => {\n        it('passes if a string', function () {\n          this.setup({ blockHosts: 'google.com' })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if an array of strings', function () {\n          this.setup({ blockHosts: ['google.com'] })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if not a string or array', function () {\n          this.setup({ blockHosts: 5 })\n\n          return this.expectValidationFails('be a string or an array of strings')\n        })\n\n        it('fails if not an array of strings', function () {\n          this.setup({ blockHosts: [5] })\n          this.expectValidationFails('be a string or an array of strings')\n\n          return this.expectValidationFails('the value was: `[5]`')\n        })\n      })\n\n      context('retries', () => {\n        const retriesError = 'a positive number or null or an object with keys \"openMode\" and \"runMode\" with values of numbers or nulls'\n\n        // need to keep the const here or it'll get stripped by the build\n        // eslint-disable-next-line no-unused-vars\n        const cases = [\n          [{ retries: null }, 'with null', true],\n          [{ retries: 3 }, 'when a number', true],\n          [{ retries: 3.2 }, 'when a float', false],\n          [{ retries: -1 }, 'with a negative number', false],\n          [{ retries: true }, 'when true', false],\n          [{ retries: false }, 'when false', false],\n          [{ retries: {} }, 'with an empty object', true],\n          [{ retries: { runMode: 3 } }, 'when runMode is a positive number', true],\n          [{ retries: { runMode: -1 } }, 'when runMode is a negative number', false],\n          [{ retries: { openMode: 3 } }, 'when openMode is a positive number', true],\n          [{ retries: { openMode: -1 } }, 'when openMode is a negative number', false],\n          [{ retries: { openMode: 3, TypoRunMode: 3 } }, 'when there is an additional unknown key', false],\n          [{ retries: { openMode: 3, runMode: 3 } }, 'when both runMode and openMode are positive numbers', true],\n        ].forEach(([config, expectation, shouldPass]) => {\n          it(`${shouldPass ? 'passes' : 'fails'} ${expectation}`, function () {\n            this.setup(config)\n\n            return shouldPass ? this.expectValidationPasses() : this.expectValidationFails(retriesError)\n          })\n        })\n      })\n\n      context('firefoxGcInterval', () => {\n        it('passes if a number', function () {\n          this.setup({ firefoxGcInterval: 1 })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if null', function () {\n          this.setup({ firefoxGcInterval: null })\n\n          return this.expectValidationPasses()\n        })\n\n        it('passes if correctly shaped object', function () {\n          this.setup({ firefoxGcInterval: { runMode: 1, openMode: null } })\n\n          return this.expectValidationPasses()\n        })\n\n        it('fails if string', function () {\n          this.setup({ firefoxGcInterval: 'foo' })\n\n          return this.expectValidationFails('a positive number or null or an object')\n        })\n\n        it('fails if invalid object', function () {\n          this.setup({ firefoxGcInterval: { foo: 'bar' } })\n\n          return this.expectValidationFails('a positive number or null or an object')\n        })\n      })\n    })\n  })\n\n  context('.getConfigKeys', () => {\n    beforeEach(function () {\n      this.includes = (key) => {\n        expect(config.getConfigKeys()).to.include(key)\n      }\n    })\n\n    it('includes blockHosts', function () {\n      return this.includes('blockHosts')\n    })\n  })\n\n  context('.resolveConfigValues', () => {\n    beforeEach(function () {\n      this.expected = function (obj) {\n        const merged = config.resolveConfigValues(obj.config, obj.defaults, obj.resolved)\n\n        expect(merged).to.deep.eq(obj.final)\n      }\n    })\n\n    it('sets baseUrl to default', function () {\n      return this.expected({\n        config: { baseUrl: null },\n        defaults: { baseUrl: null },\n        resolved: {},\n        final: {\n          baseUrl: {\n            value: null,\n            from: 'default',\n          },\n        },\n      })\n    })\n\n    it('sets baseUrl to config', function () {\n      return this.expected({\n        config: { baseUrl: 'localhost' },\n        defaults: { baseUrl: null },\n        resolved: {},\n        final: {\n          baseUrl: {\n            value: 'localhost',\n            from: 'config',\n          },\n        },\n      })\n    })\n\n    it('does not change existing resolved values', function () {\n      return this.expected({\n        config: { baseUrl: 'localhost' },\n        defaults: { baseUrl: null },\n        resolved: { baseUrl: 'cli' },\n        final: {\n          baseUrl: {\n            value: 'localhost',\n            from: 'cli',\n          },\n        },\n      })\n    })\n\n    it('ignores values not found in configKeys', function () {\n      return this.expected({\n        config: { baseUrl: 'localhost', foo: 'bar' },\n        defaults: { baseUrl: null },\n        resolved: { baseUrl: 'cli' },\n        final: {\n          baseUrl: {\n            value: 'localhost',\n            from: 'cli',\n          },\n        },\n      })\n    })\n  })\n\n  context('.mergeDefaults', () => {\n    beforeEach(function () {\n      this.defaults = (prop, value, cfg = {}, options = {}) => {\n        cfg.projectRoot = '/foo/bar/'\n\n        return config.mergeDefaults(cfg, options)\n        .then(R.prop(prop))\n        .then((result) => {\n          expect(result).to.deep.eq(value)\n        })\n      }\n    })\n\n    it('port=null', function () {\n      return this.defaults('port', null)\n    })\n\n    it('projectId=null', function () {\n      return this.defaults('projectId', null)\n    })\n\n    it('autoOpen=false', function () {\n      return this.defaults('autoOpen', false)\n    })\n\n    it('browserUrl=http://localhost:2020/__/', function () {\n      return this.defaults('browserUrl', 'http://localhost:2020/__/', { port: 2020 })\n    })\n\n    it('proxyUrl=http://localhost:2020', function () {\n      return this.defaults('proxyUrl', 'http://localhost:2020', { port: 2020 })\n    })\n\n    it('namespace=__cypress', function () {\n      return this.defaults('namespace', '__cypress')\n    })\n\n    it('baseUrl=http://localhost:8000/app/', function () {\n      return this.defaults('baseUrl', 'http://localhost:8000/app/', {\n        baseUrl: 'http://localhost:8000/app///',\n      })\n    })\n\n    it('baseUrl=http://localhost:8000/app/', function () {\n      return this.defaults('baseUrl', 'http://localhost:8000/app/', {\n        baseUrl: 'http://localhost:8000/app//',\n      })\n    })\n\n    it('baseUrl=http://localhost:8000/app', function () {\n      return this.defaults('baseUrl', 'http://localhost:8000/app', {\n        baseUrl: 'http://localhost:8000/app',\n      })\n    })\n\n    it('baseUrl=http://localhost:8000/', function () {\n      return this.defaults('baseUrl', 'http://localhost:8000/', {\n        baseUrl: 'http://localhost:8000//',\n      })\n    })\n\n    it('baseUrl=http://localhost:8000/', function () {\n      return this.defaults('baseUrl', 'http://localhost:8000/', {\n        baseUrl: 'http://localhost:8000/',\n      })\n    })\n\n    it('baseUrl=http://localhost:8000', function () {\n      return this.defaults('baseUrl', 'http://localhost:8000', {\n        baseUrl: 'http://localhost:8000',\n      })\n    })\n\n    it('javascripts=[]', function () {\n      return this.defaults('javascripts', [])\n    })\n\n    it('viewportWidth=1000', function () {\n      return this.defaults('viewportWidth', 1000)\n    })\n\n    it('viewportHeight=660', function () {\n      return this.defaults('viewportHeight', 660)\n    })\n\n    it('userAgent=null', function () {\n      return this.defaults('userAgent', null)\n    })\n\n    it('baseUrl=null', function () {\n      return this.defaults('baseUrl', null)\n    })\n\n    it('defaultCommandTimeout=4000', function () {\n      return this.defaults('defaultCommandTimeout', 4000)\n    })\n\n    it('pageLoadTimeout=60000', function () {\n      return this.defaults('pageLoadTimeout', 60000)\n    })\n\n    it('requestTimeout=5000', function () {\n      return this.defaults('requestTimeout', 5000)\n    })\n\n    it('responseTimeout=30000', function () {\n      return this.defaults('responseTimeout', 30000)\n    })\n\n    it('execTimeout=60000', function () {\n      return this.defaults('execTimeout', 60000)\n    })\n\n    it('waitForAnimations=true', function () {\n      return this.defaults('waitForAnimations', true)\n    })\n\n    it('scrollBehavior=start', function () {\n      return this.defaults('scrollBehavior', 'top')\n    })\n\n    it('animationDistanceThreshold=5', function () {\n      return this.defaults('animationDistanceThreshold', 5)\n    })\n\n    it('video=true', function () {\n      return this.defaults('video', true)\n    })\n\n    it('videoCompression=32', function () {\n      return this.defaults('videoCompression', 32)\n    })\n\n    it('videoUploadOnPasses=true', function () {\n      return this.defaults('videoUploadOnPasses', true)\n    })\n\n    it('trashAssetsBeforeRuns=32', function () {\n      return this.defaults('trashAssetsBeforeRuns', true)\n    })\n\n    it('morgan=true', function () {\n      return this.defaults('morgan', true)\n    })\n\n    it('isTextTerminal=false', function () {\n      return this.defaults('isTextTerminal', false)\n    })\n\n    it('socketId=null', function () {\n      return this.defaults('socketId', null)\n    })\n\n    it('reporter=spec', function () {\n      return this.defaults('reporter', 'spec')\n    })\n\n    it('watchForFileChanges=true', function () {\n      return this.defaults('watchForFileChanges', true)\n    })\n\n    it('numTestsKeptInMemory=50', function () {\n      return this.defaults('numTestsKeptInMemory', 50)\n    })\n\n    it('modifyObstructiveCode=true', function () {\n      return this.defaults('modifyObstructiveCode', true)\n    })\n\n    it('supportFile=false', function () {\n      return this.defaults('supportFile', false, { supportFile: false })\n    })\n\n    it('blockHosts=null', function () {\n      return this.defaults('blockHosts', null)\n    })\n\n    it('blockHosts=[a,b]', function () {\n      return this.defaults('blockHosts', ['a', 'b'], {\n        blockHosts: ['a', 'b'],\n      })\n    })\n\n    it('blockHosts=a|b', function () {\n      return this.defaults('blockHosts', ['a', 'b'], {\n        blockHosts: ['a', 'b'],\n      })\n    })\n\n    it('hosts=null', function () {\n      return this.defaults('hosts', null)\n    })\n\n    it('hosts={}', function () {\n      return this.defaults('hosts', {\n        foo: 'bar',\n        baz: 'quux',\n      }, {\n        hosts: {\n          foo: 'bar',\n          baz: 'quux',\n        },\n      })\n    })\n\n    it('resets numTestsKeptInMemory to 0 when runMode', () => {\n      return config.mergeDefaults({ projectRoot: '/foo/bar/' }, { isTextTerminal: true })\n      .then((cfg) => {\n        expect(cfg.numTestsKeptInMemory).to.eq(0)\n      })\n    })\n\n    it('resets watchForFileChanges to false when runMode', () => {\n      return config.mergeDefaults({ projectRoot: '/foo/bar/' }, { isTextTerminal: true })\n      .then((cfg) => {\n        expect(cfg.watchForFileChanges).to.be.false\n      })\n    })\n\n    it('can override morgan in options', () => {\n      return config.mergeDefaults({ projectRoot: '/foo/bar/' }, { morgan: false })\n      .then((cfg) => {\n        expect(cfg.morgan).to.be.false\n      })\n    })\n\n    it('can override isTextTerminal in options', () => {\n      return config.mergeDefaults({ projectRoot: '/foo/bar/' }, { isTextTerminal: true })\n      .then((cfg) => {\n        expect(cfg.isTextTerminal).to.be.true\n      })\n    })\n\n    it('can override socketId in options', () => {\n      return config.mergeDefaults({ projectRoot: '/foo/bar/' }, { socketId: 1234 })\n      .then((cfg) => {\n        expect(cfg.socketId).to.eq(1234)\n      })\n    })\n\n    it('deletes envFile', () => {\n      const obj = {\n        projectRoot: '/foo/bar/',\n        env: {\n          foo: 'bar',\n          version: '0.5.2',\n        },\n        envFile: {\n          bar: 'baz',\n          version: '1.0.1',\n        },\n      }\n\n      return config.mergeDefaults(obj)\n      .then((cfg) => {\n        expect(cfg.env).to.deep.eq({\n          foo: 'bar',\n          bar: 'baz',\n          version: '1.0.1',\n        })\n\n        expect(cfg.cypressEnv).to.eq(process.env['CYPRESS_INTERNAL_ENV'])\n\n        expect(cfg).not.to.have.property('envFile')\n      })\n    })\n\n    it('merges env into @config.env', () => {\n      const obj = {\n        projectRoot: '/foo/bar/',\n        env: {\n          host: 'localhost',\n          user: 'brian',\n          version: '0.12.2',\n        },\n      }\n\n      const options = {\n        env: {\n          version: '0.13.1',\n          foo: 'bar',\n        },\n      }\n\n      return config.mergeDefaults(obj, options)\n      .then((cfg) => {\n        expect(cfg.env).to.deep.eq({\n          host: 'localhost',\n          user: 'brian',\n          version: '0.13.1',\n          foo: 'bar',\n        })\n      })\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/6892\n    it('warns if experimentalGetCookiesSameSite is passed', async function () {\n      const warning = sinon.spy(errors, 'warning')\n\n      await this.defaults('experimentalGetCookiesSameSite', true, {\n        experimentalGetCookiesSameSite: true,\n      })\n\n      expect(warning).to.be.calledWith('EXPERIMENTAL_SAMESITE_REMOVED')\n    })\n\n    it('warns if experimentalShadowDomSupport is passed', async function () {\n      const warning = sinon.spy(errors, 'warning')\n\n      await this.defaults('experimentalShadowDomSupport', true, {\n        experimentalShadowDomSupport: true,\n      })\n\n      expect(warning).to.be.calledWith('EXPERIMENTAL_SHADOW_DOM_REMOVED')\n    })\n\n    it('warns if experimentalRunEvents is passed', async function () {\n      const warning = sinon.spy(errors, 'warning')\n\n      await this.defaults('experimentalRunEvents', true, {\n        experimentalRunEvents: true,\n      })\n\n      expect(warning).to.be.calledWith('EXPERIMENTAL_RUN_EVENTS_REMOVED')\n    })\n\n    // @see https://github.com/cypress-io/cypress/pull/9185\n    it('warns if experimentalNetworkStubbing is passed', async function () {\n      const warning = sinon.spy(errors, 'warning')\n\n      await this.defaults('experimentalNetworkStubbing', true, {\n        experimentalNetworkStubbing: true,\n      })\n\n      expect(warning).to.be.calledWith('EXPERIMENTAL_NETWORK_STUBBING_REMOVED')\n    })\n\n    describe('.resolved', () => {\n      it('sets reporter and port to cli', () => {\n        const obj = {\n          projectRoot: '/foo/bar',\n        }\n\n        const options = {\n          reporter: 'json',\n          port: 1234,\n        }\n\n        return config.mergeDefaults(obj, options)\n        .then((cfg) => {\n          expect(cfg.resolved).to.deep.eq({\n            animationDistanceThreshold: { value: 5, from: 'default' },\n            baseUrl: { value: null, from: 'default' },\n            blockHosts: { value: null, from: 'default' },\n            browsers: { value: [], from: 'default' },\n            chromeWebSecurity: { value: true, from: 'default' },\n            component: { from: 'default', value: {} },\n            componentFolder: { value: 'cypress/component', from: 'default' },\n            defaultCommandTimeout: { value: 4000, from: 'default' },\n            downloadsFolder: { value: 'cypress/downloads', from: 'default' },\n            e2e: { from: 'default', value: {} },\n            env: {},\n            execTimeout: { value: 60000, from: 'default' },\n            experimentalFetchPolyfill: { value: false, from: 'default' },\n            experimentalInteractiveRunEvents: { value: false, from: 'default' },\n            experimentalSourceRewriting: { value: false, from: 'default' },\n            experimentalStudio: { value: false, from: 'default' },\n            fileServerFolder: { value: '', from: 'default' },\n            firefoxGcInterval: { value: { openMode: null, runMode: 1 }, from: 'default' },\n            fixturesFolder: { value: 'cypress/fixtures', from: 'default' },\n            hosts: { value: null, from: 'default' },\n            ignoreTestFiles: { value: '*.hot-update.js', from: 'default' },\n            includeShadowDom: { value: false, from: 'default' },\n            integrationFolder: { value: 'cypress/integration', from: 'default' },\n            modifyObstructiveCode: { value: true, from: 'default' },\n            nodeVersion: { value: 'default', from: 'default' },\n            numTestsKeptInMemory: { value: 50, from: 'default' },\n            pageLoadTimeout: { value: 60000, from: 'default' },\n            pluginsFile: { value: 'cypress/plugins', from: 'default' },\n            port: { value: 1234, from: 'cli' },\n            projectId: { value: null, from: 'default' },\n            redirectionLimit: { value: 20, from: 'default' },\n            reporter: { value: 'json', from: 'cli' },\n            reporterOptions: { value: null, from: 'default' },\n            requestTimeout: { value: 5000, from: 'default' },\n            responseTimeout: { value: 30000, from: 'default' },\n            retries: { value: { runMode: 0, openMode: 0 }, from: 'default' },\n            screenshotOnRunFailure: { value: true, from: 'default' },\n            screenshotsFolder: { value: 'cypress/screenshots', from: 'default' },\n            supportFile: { value: 'cypress/support', from: 'default' },\n            taskTimeout: { value: 60000, from: 'default' },\n            testFiles: { value: '**/*.*', from: 'default' },\n            trashAssetsBeforeRuns: { value: true, from: 'default' },\n            userAgent: { value: null, from: 'default' },\n            video: { value: true, from: 'default' },\n            videoCompression: { value: 32, from: 'default' },\n            videosFolder: { value: 'cypress/videos', from: 'default' },\n            videoUploadOnPasses: { value: true, from: 'default' },\n            viewportHeight: { value: 660, from: 'default' },\n            viewportWidth: { value: 1000, from: 'default' },\n            waitForAnimations: { value: true, from: 'default' },\n            scrollBehavior: { value: 'top', from: 'default' },\n            watchForFileChanges: { value: true, from: 'default' },\n          })\n        })\n      })\n\n      it('sets config, envFile and env', () => {\n        sinon.stub(config, 'getProcessEnvVars').returns({\n          quux: 'quux',\n          RECORD_KEY: 'foobarbazquux',\n          PROJECT_ID: 'projectId123',\n        })\n\n        const obj = {\n          projectRoot: '/foo/bar',\n          baseUrl: 'http://localhost:8080',\n          port: 2020,\n          env: {\n            foo: 'foo',\n          },\n          envFile: {\n            bar: 'bar',\n          },\n        }\n\n        const options = {\n          env: {\n            baz: 'baz',\n          },\n        }\n\n        return config.mergeDefaults(obj, options)\n        .then((cfg) => {\n          expect(cfg.resolved).to.deep.eq({\n            animationDistanceThreshold: { value: 5, from: 'default' },\n            baseUrl: { value: 'http://localhost:8080', from: 'config' },\n            blockHosts: { value: null, from: 'default' },\n            browsers: { value: [], from: 'default' },\n            chromeWebSecurity: { value: true, from: 'default' },\n            component: { from: 'default', value: {} },\n            componentFolder: { value: 'cypress/component', from: 'default' },\n            defaultCommandTimeout: { value: 4000, from: 'default' },\n            downloadsFolder: { value: 'cypress/downloads', from: 'default' },\n            e2e: { from: 'default', value: {} },\n            execTimeout: { value: 60000, from: 'default' },\n            experimentalFetchPolyfill: { value: false, from: 'default' },\n            experimentalInteractiveRunEvents: { value: false, from: 'default' },\n            experimentalSourceRewriting: { value: false, from: 'default' },\n            experimentalStudio: { value: false, from: 'default' },\n            env: {\n              foo: {\n                value: 'foo',\n                from: 'config',\n              },\n              bar: {\n                value: 'bar',\n                from: 'envFile',\n              },\n              baz: {\n                value: 'baz',\n                from: 'cli',\n              },\n              quux: {\n                value: 'quux',\n                from: 'env',\n              },\n              RECORD_KEY: {\n                value: 'fooba...zquux',\n                from: 'env',\n              },\n            },\n            fileServerFolder: { value: '', from: 'default' },\n            firefoxGcInterval: { value: { openMode: null, runMode: 1 }, from: 'default' },\n            fixturesFolder: { value: 'cypress/fixtures', from: 'default' },\n            hosts: { value: null, from: 'default' },\n            ignoreTestFiles: { value: '*.hot-update.js', from: 'default' },\n            includeShadowDom: { value: false, from: 'default' },\n            integrationFolder: { value: 'cypress/integration', from: 'default' },\n            modifyObstructiveCode: { value: true, from: 'default' },\n            nodeVersion: { value: 'default', from: 'default' },\n            numTestsKeptInMemory: { value: 50, from: 'default' },\n            pageLoadTimeout: { value: 60000, from: 'default' },\n            pluginsFile: { value: 'cypress/plugins', from: 'default' },\n            port: { value: 2020, from: 'config' },\n            projectId: { value: 'projectId123', from: 'env' },\n            redirectionLimit: { value: 20, from: 'default' },\n            reporter: { value: 'spec', from: 'default' },\n            reporterOptions: { value: null, from: 'default' },\n            requestTimeout: { value: 5000, from: 'default' },\n            responseTimeout: { value: 30000, from: 'default' },\n            retries: { value: { runMode: 0, openMode: 0 }, from: 'default' },\n            screenshotOnRunFailure: { value: true, from: 'default' },\n            screenshotsFolder: { value: 'cypress/screenshots', from: 'default' },\n            supportFile: { value: 'cypress/support', from: 'default' },\n            taskTimeout: { value: 60000, from: 'default' },\n            testFiles: { value: '**/*.*', from: 'default' },\n            trashAssetsBeforeRuns: { value: true, from: 'default' },\n            userAgent: { value: null, from: 'default' },\n            video: { value: true, from: 'default' },\n            videoCompression: { value: 32, from: 'default' },\n            videosFolder: { value: 'cypress/videos', from: 'default' },\n            videoUploadOnPasses: { value: true, from: 'default' },\n            viewportHeight: { value: 660, from: 'default' },\n            viewportWidth: { value: 1000, from: 'default' },\n            waitForAnimations: { value: true, from: 'default' },\n            scrollBehavior: { value: 'top', from: 'default' },\n            watchForFileChanges: { value: true, from: 'default' },\n          })\n        })\n      })\n    })\n  })\n\n  context('.setPluginResolvedOn', () => {\n    it('resolves an object with single property', () => {\n      const cfg = {}\n      const obj = {\n        foo: 'bar',\n      }\n\n      config.setPluginResolvedOn(cfg, obj)\n\n      expect(cfg).to.deep.eq({\n        foo: {\n          value: 'bar',\n          from: 'plugin',\n        },\n      })\n    })\n\n    it('resolves an object with multiple properties', () => {\n      const cfg = {}\n      const obj = {\n        foo: 'bar',\n        baz: [1, 2, 3],\n      }\n\n      config.setPluginResolvedOn(cfg, obj)\n\n      expect(cfg).to.deep.eq({\n        foo: {\n          value: 'bar',\n          from: 'plugin',\n        },\n        baz: {\n          value: [1, 2, 3],\n          from: 'plugin',\n        },\n      })\n    })\n\n    it('resolves a nested object', () => {\n      // we need at least the structure\n      const cfg = {\n        foo: {\n          bar: 1,\n        },\n      }\n      const obj = {\n        foo: {\n          bar: 42,\n        },\n      }\n\n      config.setPluginResolvedOn(cfg, obj)\n\n      expect(cfg, 'foo.bar gets value').to.deep.eq({\n        foo: {\n          bar: {\n            value: 42,\n            from: 'plugin',\n          },\n        },\n      })\n    })\n\n    // https://github.com/cypress-io/cypress/issues/7959\n    it('resolves a single object', () => {\n      const cfg = {\n      }\n      const obj = {\n        foo: {\n          bar: {\n            baz: 42,\n          },\n        },\n      }\n\n      config.setPluginResolvedOn(cfg, obj)\n\n      expect(cfg).to.deep.eq({\n        foo: {\n          from: 'plugin',\n          value: {\n            bar: {\n              baz: 42,\n            },\n          },\n        },\n      })\n    })\n  })\n\n  context('_.defaultsDeep', () => {\n    it('merges arrays', () => {\n    // sanity checks to confirm how Lodash merges arrays in defaultsDeep\n      const diffs = {\n        list: [1],\n      }\n      const cfg = {\n        list: [1, 2],\n      }\n      const merged = _.defaultsDeep({}, diffs, cfg)\n\n      expect(merged, 'arrays are combined').to.deep.eq({\n        list: [1, 2],\n      })\n    })\n  })\n\n  context('.updateWithPluginValues', () => {\n    it('is noop when no overrides', () => {\n      expect(config.updateWithPluginValues({ foo: 'bar' }, null)).to.deep.eq({\n        foo: 'bar',\n      })\n    })\n\n    it('is noop with empty overrides', () => {\n      expect(config.updateWithPluginValues({ foo: 'bar' }, {})).to.deep.eq({\n        foo: 'bar',\n      })\n    })\n\n    it('updates resolved config values and returns config with overrides', () => {\n      const cfg = {\n        foo: 'bar',\n        baz: 'quux',\n        quux: 'foo',\n        lol: 1234,\n        env: {\n          a: 'a',\n          b: 'b',\n        },\n        // previously resolved values\n        resolved: {\n          foo: { value: 'bar', from: 'default' },\n          baz: { value: 'quux', from: 'cli' },\n          quux: { value: 'foo', from: 'default' },\n          lol: { value: 1234, from: 'env' },\n          env: {\n            a: { value: 'a', from: 'config' },\n            b: { value: 'b', from: 'config' },\n          },\n        },\n      }\n\n      const overrides = {\n        baz: 'baz',\n        quux: ['bar', 'quux'],\n        env: {\n          b: 'bb',\n          c: 'c',\n        },\n      }\n\n      expect(config.updateWithPluginValues(cfg, overrides)).to.deep.eq({\n        foo: 'bar',\n        baz: 'baz',\n        lol: 1234,\n        quux: ['bar', 'quux'],\n        env: {\n          a: 'a',\n          b: 'bb',\n          c: 'c',\n        },\n        resolved: {\n          foo: { value: 'bar', from: 'default' },\n          baz: { value: 'baz', from: 'plugin' },\n          quux: { value: ['bar', 'quux'], from: 'plugin' },\n          lol: { value: 1234, from: 'env' },\n          env: {\n            a: { value: 'a', from: 'config' },\n            b: { value: 'bb', from: 'plugin' },\n            c: { value: 'c', from: 'plugin' },\n          },\n        },\n      })\n    })\n\n    it('keeps the list of browsers if the plugins returns empty object', () => {\n      const browser = {\n        name: 'fake browser name',\n        family: 'chromium',\n        displayName: 'My browser',\n        version: 'x.y.z',\n        path: '/path/to/browser',\n        majorVersion: 'x',\n      }\n\n      const cfg = {\n        browsers: [browser],\n        resolved: {\n          browsers: {\n            value: [browser],\n            from: 'default',\n          },\n        },\n      }\n\n      const overrides = {}\n\n      expect(config.updateWithPluginValues(cfg, overrides)).to.deep.eq({\n        browsers: [browser],\n        resolved: {\n          browsers: {\n            value: [browser],\n            from: 'default',\n          },\n        },\n      })\n    })\n\n    it('catches browsers=null returned from plugins', () => {\n      const browser = {\n        name: 'fake browser name',\n        family: 'chromium',\n        displayName: 'My browser',\n        version: 'x.y.z',\n        path: '/path/to/browser',\n        majorVersion: 'x',\n      }\n\n      const cfg = {\n        browsers: [browser],\n        resolved: {\n          browsers: {\n            value: [browser],\n            from: 'default',\n          },\n        },\n      }\n\n      const overrides = {\n        browsers: null,\n      }\n\n      sinon.stub(errors, 'throw')\n      config.updateWithPluginValues(cfg, overrides)\n\n      expect(errors.throw).to.have.been.calledWith('CONFIG_VALIDATION_ERROR')\n    })\n\n    it('allows user to filter browsers', () => {\n      const browserOne = {\n        name: 'fake browser name',\n        family: 'chromium',\n        displayName: 'My browser',\n        version: 'x.y.z',\n        path: '/path/to/browser',\n        majorVersion: 'x',\n      }\n      const browserTwo = {\n        name: 'fake electron',\n        family: 'chromium',\n        displayName: 'Electron',\n        version: 'x.y.z',\n        // Electron browser is built-in, no external path\n        path: '',\n        majorVersion: 'x',\n      }\n\n      const cfg = {\n        browsers: [browserOne, browserTwo],\n        resolved: {\n          browsers: {\n            value: [browserOne, browserTwo],\n            from: 'default',\n          },\n        },\n      }\n\n      const overrides = {\n        browsers: [browserTwo],\n      }\n\n      const updated = config.updateWithPluginValues(cfg, overrides)\n\n      expect(updated.resolved, 'resolved values').to.deep.eq({\n        browsers: {\n          value: [browserTwo],\n          from: 'plugin',\n        },\n      })\n\n      expect(updated, 'all values').to.deep.eq({\n        browsers: [browserTwo],\n        resolved: {\n          browsers: {\n            value: [browserTwo],\n            from: 'plugin',\n          },\n        },\n      })\n    })\n  })\n\n  context('.parseEnv', () => {\n    it('merges together env from config, env from file, env from process, and env from CLI', () => {\n      sinon.stub(config, 'getProcessEnvVars').returns({\n        version: '0.12.1',\n        user: 'bob',\n      })\n\n      const obj = {\n        env: {\n          version: '0.10.9',\n          project: 'todos',\n          host: 'localhost',\n          baz: 'quux',\n        },\n\n        envFile: {\n          host: 'http://localhost:8888',\n          user: 'brian',\n          foo: 'bar',\n        },\n      }\n\n      const envCLI = {\n        version: '0.14.0',\n        project: 'pie',\n      }\n\n      expect(config.parseEnv(obj, envCLI)).to.deep.eq({\n        version: '0.14.0',\n        project: 'pie',\n        host: 'http://localhost:8888',\n        user: 'bob',\n        foo: 'bar',\n        baz: 'quux',\n      })\n    })\n  })\n\n  context('.getProcessEnvVars', () => {\n    ['cypress_', 'CYPRESS_'].forEach((key) => {\n      it(`reduces key: ${key}`, () => {\n        const obj = {\n          cypress_host: 'http://localhost:8888',\n          foo: 'bar',\n          env: '123',\n        }\n\n        obj[`${key}version`] = '0.12.0'\n\n        expect(config.getProcessEnvVars(obj)).to.deep.eq({\n          host: 'http://localhost:8888',\n          version: '0.12.0',\n        })\n      })\n    })\n\n    it('does not merge reserved environment variables', () => {\n      const obj = {\n        CYPRESS_INTERNAL_ENV: 'production',\n        CYPRESS_FOO: 'bar',\n        CYPRESS_CRASH_REPORTS: '0',\n        CYPRESS_PROJECT_ID: 'abc123',\n      }\n\n      expect(config.getProcessEnvVars(obj)).to.deep.eq({\n        FOO: 'bar',\n        PROJECT_ID: 'abc123',\n        CRASH_REPORTS: 0,\n      })\n    })\n  })\n\n  context('.setUrls', () => {\n    it('does not mutate existing obj', () => {\n      const obj = {}\n\n      expect(config.setUrls(obj)).not.to.eq(obj)\n    })\n\n    it('uses baseUrl when set', () => {\n      const obj = {\n        port: 65432,\n        baseUrl: 'https://www.google.com',\n        clientRoute: '/__/',\n      }\n\n      const urls = config.setUrls(obj)\n\n      expect(urls.browserUrl).to.eq('https://www.google.com/__/')\n\n      expect(urls.proxyUrl).to.eq('http://localhost:65432')\n    })\n\n    it('strips baseUrl to host when set', () => {\n      const obj = {\n        port: 65432,\n        baseUrl: 'http://localhost:9999/app/?foo=bar#index.html',\n        clientRoute: '/__/',\n      }\n\n      const urls = config.setUrls(obj)\n\n      expect(urls.browserUrl).to.eq('http://localhost:9999/__/')\n\n      expect(urls.proxyUrl).to.eq('http://localhost:65432')\n    })\n  })\n\n  context('.setScaffoldPaths', () => {\n    it('sets integrationExamplePath + integrationExampleName + scaffoldedFiles', () => {\n      const obj = {\n        integrationFolder: '/_test-output/path/to/project/cypress/integration',\n      }\n\n      sinon.stub(scaffold, 'fileTree').resolves([])\n\n      return config.setScaffoldPaths(obj).then((result) => {\n        expect(result).to.deep.eq({\n          integrationFolder: '/_test-output/path/to/project/cypress/integration',\n          integrationExamplePath: '/_test-output/path/to/project/cypress/integration/examples',\n          integrationExampleName: 'examples',\n          scaffoldedFiles: [],\n        })\n      })\n    })\n  })\n\n  context('.setSupportFileAndFolder', () => {\n    it('does nothing if supportFile is falsey', () => {\n      const obj = {\n        projectRoot: '/_test-output/path/to/project',\n      }\n\n      return config.setSupportFileAndFolder(obj)\n      .then((result) => {\n        expect(result).to.eql(obj)\n      })\n    })\n\n    it('sets the full path to the supportFile and supportFolder if it exists', () => {\n      const projectRoot = process.cwd()\n\n      const obj = config.setAbsolutePaths({\n        projectRoot,\n        supportFile: 'test/unit/config_spec.js',\n      })\n\n      return config.setSupportFileAndFolder(obj)\n      .then((result) => {\n        expect(result).to.eql({\n          projectRoot,\n          supportFile: `${projectRoot}/test/unit/config_spec.js`,\n          supportFolder: `${projectRoot}/test/unit`,\n        })\n      })\n    })\n\n    it('sets the supportFile to default index.js if it does not exist, support folder does not exist, and supportFile is the default', () => {\n      const projectRoot = path.join(process.cwd(), 'test/support/fixtures/projects/no-scaffolding')\n\n      const obj = config.setAbsolutePaths({\n        projectRoot,\n        supportFile: 'cypress/support',\n      })\n\n      return config.setSupportFileAndFolder(obj)\n      .then((result) => {\n        expect(result).to.eql({\n          projectRoot,\n          supportFile: `${projectRoot}/cypress/support/index.js`,\n          supportFolder: `${projectRoot}/cypress/support`,\n        })\n      })\n    })\n\n    it('sets the supportFile to false if it does not exist, support folder exists, and supportFile is the default', () => {\n      const projectRoot = path.join(process.cwd(), 'test/support/fixtures/projects/empty-folders')\n\n      const obj = config.setAbsolutePaths({\n        projectRoot,\n        supportFile: 'cypress/support',\n      })\n\n      return config.setSupportFileAndFolder(obj)\n      .then((result) => {\n        expect(result).to.eql({\n          projectRoot,\n          supportFile: false,\n        })\n      })\n    })\n\n    it('throws error if supportFile is not default and does not exist', () => {\n      const projectRoot = process.cwd()\n\n      const obj = config.setAbsolutePaths({\n        projectRoot,\n        supportFile: 'does/not/exist',\n      })\n\n      return config.setSupportFileAndFolder(obj)\n      .catch((err) => {\n        expect(err.message).to.include('The support file is missing or invalid.')\n      })\n    })\n\n    it('sets the supportFile to index.ts if it exists (without ts require hook)', () => {\n      const projectRoot = path.join(process.cwd(), 'test/support/fixtures/projects/ts-proj')\n      const supportFolder = `${projectRoot}/cypress/support`\n      const supportFilename = `${supportFolder}/index.ts`\n\n      const e = new Error('Cannot resolve TS file by default')\n\n      e.code = 'MODULE_NOT_FOUND'\n      sinon.stub(config.utils, 'resolveModule').withArgs(supportFolder).throws(e)\n\n      const obj = config.setAbsolutePaths({\n        projectRoot,\n        supportFile: 'cypress/support',\n      })\n\n      return config.setSupportFileAndFolder(obj)\n      .then((result) => {\n        debug('result is', result)\n\n        expect(result).to.eql({\n          projectRoot,\n          supportFolder,\n          supportFile: supportFilename,\n        })\n      })\n    })\n\n    it('uses custom TS supportFile if it exists (without ts require hook)', () => {\n      const projectRoot = path.join(process.cwd(), 'test/support/fixtures/projects/ts-proj-custom-names')\n      const supportFolder = `${projectRoot}/cypress`\n      const supportFilename = `${supportFolder}/support.ts`\n\n      const e = new Error('Cannot resolve TS file by default')\n\n      e.code = 'MODULE_NOT_FOUND'\n      sinon.stub(config.utils, 'resolveModule').withArgs(supportFilename).throws(e)\n\n      const obj = config.setAbsolutePaths({\n        projectRoot,\n        supportFile: 'cypress/support.ts',\n      })\n\n      return config.setSupportFileAndFolder(obj)\n      .then((result) => {\n        debug('result is', result)\n\n        expect(result).to.eql({\n          projectRoot,\n          supportFolder,\n          supportFile: supportFilename,\n        })\n      })\n    })\n  })\n\n  context('.setPluginsFile', () => {\n    it('does nothing if pluginsFile is falsey', () => {\n      const obj = {\n        projectRoot: '/_test-output/path/to/project',\n      }\n\n      return config.setPluginsFile(obj)\n      .then((result) => {\n        expect(result).to.eql(obj)\n      })\n    })\n\n    it('sets the pluginsFile to default index.js if does not exist', () => {\n      const projectRoot = path.join(process.cwd(), 'test/support/fixtures/projects/no-scaffolding')\n\n      const obj = {\n        projectRoot,\n        pluginsFile: `${projectRoot}/cypress/plugins`,\n      }\n\n      return config.setPluginsFile(obj)\n      .then((result) => {\n        expect(result).to.eql({\n          projectRoot,\n          pluginsFile: `${projectRoot}/cypress/plugins/index.js`,\n        })\n      })\n    })\n\n    it('sets the pluginsFile to index.ts if it exists', () => {\n      const projectRoot = path.join(process.cwd(), 'test/support/fixtures/projects/ts-proj-with-module-esnext')\n\n      const obj = {\n        projectRoot,\n        pluginsFile: `${projectRoot}/cypress/plugins`,\n      }\n\n      return config.setPluginsFile(obj)\n      .then((result) => {\n        expect(result).to.eql({\n          projectRoot,\n          pluginsFile: `${projectRoot}/cypress/plugins/index.ts`,\n        })\n      })\n    })\n\n    it('sets the pluginsFile to index.ts if it exists (without ts require hook)', () => {\n      const projectRoot = path.join(process.cwd(), 'test/support/fixtures/projects/ts-proj-with-module-esnext')\n      const pluginsFolder = `${projectRoot}/cypress/plugins`\n      const pluginsFilename = `${pluginsFolder}/index.ts`\n\n      const e = new Error('Cannot resolve TS file by default')\n\n      e.code = 'MODULE_NOT_FOUND'\n      sinon.stub(config.utils, 'resolveModule').withArgs(pluginsFolder).throws(e)\n\n      const obj = {\n        projectRoot,\n        pluginsFile: pluginsFolder,\n      }\n\n      return config.setPluginsFile(obj)\n      .then((result) => {\n        expect(result).to.eql({\n          projectRoot,\n          pluginsFile: pluginsFilename,\n        })\n      })\n    })\n\n    it('set the pluginsFile to false if it does not exist, plugins folder exists, and pluginsFile is the default', () => {\n      const projectRoot = path.join(process.cwd(), 'test/support/fixtures/projects/empty-folders')\n\n      const obj = config.setAbsolutePaths({\n        projectRoot,\n        pluginsFile: `${projectRoot}/cypress/plugins`,\n      })\n\n      return config.setPluginsFile(obj)\n      .then((result) => {\n        expect(result).to.eql({\n          projectRoot,\n          pluginsFile: false,\n        })\n      })\n    })\n\n    it('throws error if pluginsFile is not default and does not exist', () => {\n      const projectRoot = process.cwd()\n\n      const obj = {\n        projectRoot,\n        pluginsFile: 'does/not/exist',\n      }\n\n      return config.setPluginsFile(obj)\n      .catch((err) => {\n        expect(err.message).to.include('The plugins file is missing or invalid.')\n      })\n    })\n\n    it('uses custom TS pluginsFile if it exists (without ts require hook)', () => {\n      const projectRoot = path.join(process.cwd(), 'test/support/fixtures/projects/ts-proj-custom-names')\n      const pluginsFolder = `${projectRoot}/cypress`\n      const pluginsFile = `${pluginsFolder}/plugins.ts`\n\n      const e = new Error('Cannot resolve TS file by default')\n\n      e.code = 'MODULE_NOT_FOUND'\n      sinon.stub(config.utils, 'resolveModule').withArgs(pluginsFile).throws(e)\n\n      const obj = {\n        projectRoot,\n        pluginsFile,\n      }\n\n      return config.setPluginsFile(obj)\n      .then((result) => {\n        expect(result).to.eql({\n          projectRoot,\n          pluginsFile,\n        })\n      })\n    })\n  })\n\n  context('.setParentTestsPaths', () => {\n    it('sets parentTestsFolder and parentTestsFolderDisplay', () => {\n      const obj = {\n        projectRoot: '/_test-output/path/to/project',\n        integrationFolder: '/_test-output/path/to/project/cypress/integration',\n      }\n\n      expect(config.setParentTestsPaths(obj)).to.deep.eq({\n        projectRoot: '/_test-output/path/to/project',\n        integrationFolder: '/_test-output/path/to/project/cypress/integration',\n        parentTestsFolder: '/_test-output/path/to/project/cypress',\n        parentTestsFolderDisplay: 'project/cypress',\n      })\n    })\n\n    it('sets parentTestsFolderDisplay to parentTestsFolder if they are the same', () => {\n      const obj = {\n        projectRoot: '/_test-output/path/to/project',\n        integrationFolder: '/_test-output/path/to/project/tests',\n      }\n\n      expect(config.setParentTestsPaths(obj)).to.deep.eq({\n        projectRoot: '/_test-output/path/to/project',\n        integrationFolder: '/_test-output/path/to/project/tests',\n        parentTestsFolder: '/_test-output/path/to/project',\n        parentTestsFolderDisplay: 'project',\n      })\n    })\n  })\n\n  context('.setAbsolutePaths', () => {\n    it('is noop without projectRoot', () => {\n      expect(config.setAbsolutePaths({})).to.deep.eq({})\n    })\n\n    // it \"resolves fileServerFolder with projectRoot\", ->\n    //   obj = {\n    //     projectRoot: \"/_test-output/path/to/project\"\n    //     fileServerFolder: \"foo\"\n    //   }\n\n    //   expect(config.setAbsolutePaths(obj)).to.deep.eq({\n    //     projectRoot: \"/_test-output/path/to/project\"\n    //     fileServerFolder: \"/_test-output/path/to/project/foo\"\n    //   })\n\n    it('does not mutate existing obj', () => {\n      const obj = {}\n\n      expect(config.setAbsolutePaths(obj)).not.to.eq(obj)\n    })\n\n    it('ignores non special *folder properties', () => {\n      const obj = {\n        projectRoot: '/_test-output/path/to/project',\n        blehFolder: 'some/rando/path',\n        foo: 'bar',\n        baz: 'quux',\n      }\n\n      expect(config.setAbsolutePaths(obj)).to.deep.eq(obj)\n    })\n\n    return ['fileServerFolder', 'fixturesFolder', 'integrationFolder', 'unitFolder', 'supportFile', 'pluginsFile'].forEach((folder) => {\n      it(`converts relative ${folder} to absolute path`, () => {\n        const obj = {\n          projectRoot: '/_test-output/path/to/project',\n        }\n\n        obj[folder] = 'foo/bar'\n\n        const expected = {\n          projectRoot: '/_test-output/path/to/project',\n        }\n\n        expected[folder] = '/_test-output/path/to/project/foo/bar'\n\n        expect(config.setAbsolutePaths(obj)).to.deep.eq(expected)\n      })\n    })\n  })\n\n  context('.setNodeBinary', () => {\n    beforeEach(function () {\n      this.findSystemNode = sinon.stub(findSystemNode, 'findNodePathAndVersion')\n      this.nodeVersion = process.versions.node\n    })\n\n    it('sets current Node ver if nodeVersion != system', function () {\n      return config.setNodeBinary({\n        nodeVersion: undefined,\n      })\n      .then((obj) => {\n        expect(this.findSystemNode).to.not.be.called\n\n        expect(obj).to.deep.eq({\n          nodeVersion: undefined,\n          resolvedNodeVersion: this.nodeVersion,\n        })\n      })\n    })\n\n    it('sets found Node ver if nodeVersion = system and findNodePathAndVersion resolves', function () {\n      this.findSystemNode.resolves({\n        path: '/foo/bar/node',\n        version: '1.2.3',\n      })\n\n      return config.setNodeBinary({\n        nodeVersion: 'system',\n      })\n      .then((obj) => {\n        expect(this.findSystemNode).to.be.calledOnce\n\n        expect(obj).to.deep.eq({\n          nodeVersion: 'system',\n          resolvedNodeVersion: '1.2.3',\n          resolvedNodePath: '/foo/bar/node',\n        })\n      })\n    })\n\n    it('sets current Node ver and warns if nodeVersion = system and findNodePathAndVersion rejects', function () {\n      const err = new Error()\n      const onWarning = sinon.stub()\n\n      this.findSystemNode.rejects(err)\n\n      return config.setNodeBinary({\n        nodeVersion: 'system',\n      }, onWarning)\n      .then((obj) => {\n        expect(this.findSystemNode).to.be.calledOnce\n        expect(onWarning).to.be.calledOnce\n        expect(obj).to.deep.eq({\n          nodeVersion: 'system',\n          resolvedNodeVersion: this.nodeVersion,\n        })\n\n        expect(obj.resolvedNodePath).to.be.undefined\n      })\n    })\n  })\n})\n\ndescribe('lib/util/config', () => {\n  context('.isDefault', () => {\n    it('returns true if value is default value', () => {\n      settings = { baseUrl: null }\n      const defaults = { baseUrl: null }\n      const resolved = {}\n      const merged = config.setResolvedConfigValues(settings, defaults, resolved)\n\n      expect(configUtil.isDefault(merged, 'baseUrl')).to.be.true\n    })\n\n    it('returns false if value is not default value', () => {\n      settings = { baseUrl: null }\n      const defaults = { baseUrl: 'http://localhost:8080' }\n      const resolved = {}\n      const merged = config.setResolvedConfigValues(settings, defaults, resolved)\n\n      expect(configUtil.isDefault(merged, 'baseUrl')).to.be.false\n    })\n  })\n})\n",
    "packages/server/test/unit/modes/info_spec.js": "require('../../spec_helper')\n\nconst info = require(`${root}../lib/modes/info`)\nconst capture = require(`${root}../lib/capture`)\nconst browserUtils = require(`${root}../lib/browsers/utils`)\nconst { fs } = require(`${root}../lib/util/fs`)\nconst detect = require('@packages/launcher/lib/detect')\nconst snapshot = require('snap-shot-it')\nconst stripAnsi = require('strip-ansi')\nconst _ = require('lodash')\n\ndescribe('lib/modes/info', () => {\n  beforeEach(() => {\n    capture.restore()\n  })\n\n  afterEach(() => {\n    capture.restore()\n  })\n\n  const chromeStable = {\n    displayName: 'Chrome',\n    name: 'chrome',\n    channel: 'stable',\n    version: '12.34.56',\n    majorVersion: 12,\n    path: '/path/to/google-chrome',\n  }\n\n  const firefoxDev = {\n    displayName: 'Firefox Dev',\n    name: 'firefox',\n    channel: 'dev',\n    version: '79.0a1',\n    majorVersion: 79,\n    path: '/path/to/firefox',\n  }\n\n  const infoAndSnapshot = async (snapshotName) => {\n    expect(snapshotName, 'missing snapshot name').to.be.a('string')\n\n    const captured = capture.stdout()\n\n    await info()\n\n    capture.restore()\n    snapshot(snapshotName, stripAnsi(captured.toString()))\n  }\n\n  it('prints no browsers', async () => {\n    sinon.stub(detect, 'detect').resolves([])\n    await infoAndSnapshot('output without any browsers')\n  })\n\n  it('prints 1 found browser', async () => {\n    sinon.stub(detect, 'detect').resolves([chromeStable])\n    await infoAndSnapshot('single chrome:stable')\n  })\n\n  it('prints 2 found browsers', async () => {\n    sinon.stub(detect, 'detect').resolves([chromeStable, firefoxDev])\n    // have to make sure random sampling from the browser list\n    // to create examples returns same order\n    // so Chrome will be picked first, Firefox will be second\n    const sample = sinon.stub(_, 'sample')\n\n    sample.onFirstCall().returns(chromeStable)\n    sample.onSecondCall().returns(firefoxDev)\n\n    await infoAndSnapshot('two browsers')\n    expect(sample, 'two browsers were picked to create examples').to.be.calledTwice\n  })\n\n  it('adds profile for browser if folder exists', async () => {\n    sinon.stub(detect, 'detect').resolves([chromeStable, firefoxDev])\n    sinon.stub(browserUtils, 'getBrowserPath')\n    .withArgs(chromeStable).returns('/path/to/user/chrome/profile')\n    .withArgs(firefoxDev).returns('/path/to/user/firefox/profile')\n\n    sinon.stub(fs, 'statAsync')\n    .withArgs('/path/to/user/chrome/profile').throws('No Chrome profile folder')\n    .withArgs('/path/to/user/firefox/profile').resolves({\n      isDirectory: _.stubTrue,\n    })\n\n    // have to make sure random sampling from the browser list\n    // to create examples returns same order\n    // so Chrome will be picked first, Firefox will be second\n    const sample = sinon.stub(_, 'sample')\n\n    sample.onFirstCall().returns(chromeStable)\n    sample.onSecondCall().returns(firefoxDev)\n\n    await infoAndSnapshot('two browsers with firefox having profile folder')\n  })\n})\n",
    "packages/server/test/unit/modes/interactive-ct_spec.js": "require('../../spec_helper')\n\nconst { browsers } = require('@packages/launcher/lib/browsers')\nconst {\n  returnDefaultBrowser,\n  browsersForCtInteractive,\n} = require(`${root}../lib/modes/interactive-ct`)\n\nfunction filterBrowsers (list) {\n  return browsers.filter((browser) => list.includes(browser.name))\n}\n\ndescribe('returnDefaultBrowser', () => {\n  it('returns chrome by default is available', async () => {\n    const installedBrowsers = filterBrowsers(['electron', 'chromium', 'chrome'])\n    const actual = await returnDefaultBrowser(browsersForCtInteractive, installedBrowsers)\n\n    expect(actual).to.eq('chrome')\n  })\n\n  it('returns chromium if chrome is not installed', async () => {\n    const installedBrowsers = filterBrowsers(['electron', 'edge', 'chromium'])\n    const actual = await returnDefaultBrowser(browsersForCtInteractive, installedBrowsers)\n\n    expect(actual).to.eq('chromium')\n  })\n\n  it('returns undefined if no browser found', async () => {\n    // error message is handlded further down.\n    const installedBrowsers = filterBrowsers([])\n    const actual = await returnDefaultBrowser(browsersForCtInteractive, installedBrowsers)\n\n    expect(actual).to.eq(undefined)\n  })\n})\n",
    "packages/server/test/unit/modes/record_spec.js": "require('../../spec_helper')\n\nconst _ = require('lodash')\nconst debug = require('debug')('test')\nconst commitInfo = require('@cypress/commit-info')\nconst mockedEnv = require('mocked-env')\n\nconst errors = require(`${root}../lib/errors`)\nconst api = require(`${root}../lib/api`)\nconst logger = require(`${root}../lib/logger`)\nconst recordMode = require(`${root}../lib/modes/record`)\nconst ciProvider = require(`${root}../lib/util/ci_provider`)\n\nconst initialEnv = _.clone(process.env)\n\n// NOTE: the majority of the logic of record_spec is\n// tested as an e2e/record_spec\ndescribe('lib/modes/record', () => {\n  // QUESTION: why are these tests here when\n  // this is a module... ?\n  context('.getCommitFromGitOrCi', () => {\n    const gitCommit = {\n      branch: null,\n    }\n\n    beforeEach(() => {\n      delete process.env.CIRCLE_BRANCH\n      delete process.env.TRAVIS_BRANCH\n      delete process.env.BUILDKITE_BRANCH\n      delete process.env.CI_BRANCH\n      delete process.env.CIRCLECI\n      delete process.env.TRAVIS\n      delete process.env.BUILDKITE\n      delete process.env.CI_NAME\n      delete process.env.APPVEYOR\n      delete process.env.APPVEYOR_REPO_BRANCH\n    })\n\n    afterEach(() => {\n      process.env = initialEnv\n    })\n\n    it('gets branch from process.env.CIRCLE_BRANCH', () => {\n      process.env.CIRCLECI = '1'\n      process.env.CIRCLE_BRANCH = 'bem/circle'\n      process.env.TRAVIS_BRANCH = 'bem/travis'\n      process.env.CI_BRANCH = 'bem/ci'\n\n      const commit = recordMode.getCommitFromGitOrCi(gitCommit)\n\n      debug(commit)\n\n      expect(commit.branch).to.eq('bem/circle')\n    })\n\n    it('gets branch from process.env.TRAVIS_BRANCH', () => {\n      process.env.TRAVIS = '1'\n      process.env.TRAVIS_BRANCH = 'bem/travis'\n      process.env.CI_BRANCH = 'bem/ci'\n\n      const commit = recordMode.getCommitFromGitOrCi(gitCommit)\n\n      debug(commit)\n\n      expect(commit.branch).to.eq('bem/travis')\n    })\n\n    it('gets branch from process.env.BUILDKITE_BRANCH', () => {\n      process.env.BUILDKITE = '1'\n      process.env.BUILDKITE_BRANCH = 'bem/buildkite'\n      process.env.CI_BRANCH = 'bem/ci'\n\n      const commit = recordMode.getCommitFromGitOrCi(gitCommit)\n\n      debug(commit)\n\n      expect(commit.branch).to.eq('bem/buildkite')\n    })\n\n    it('gets branch from process.env.CI_BRANCH for codeship', () => {\n      process.env.CI_NAME = 'codeship'\n      process.env.CI_BRANCH = 'bem/ci'\n\n      const commit = recordMode.getCommitFromGitOrCi(gitCommit)\n\n      debug(commit)\n\n      expect(commit.branch).to.eq('bem/ci')\n    })\n\n    it('gets branch from process.env.APPVEYOR_REPO_BRANCH for AppVeyor', () => {\n      process.env.APPVEYOR = '1'\n      process.env.APPVEYOR_REPO_BRANCH = 'bem/app'\n\n      const commit = recordMode.getCommitFromGitOrCi(gitCommit)\n\n      debug(commit)\n\n      expect(commit.branch).to.eq('bem/app')\n    })\n\n    it('gets branch from git', () => {\n      // this is tested inside @cypress/commit-info\n    })\n  })\n\n  context('.createRunAndRecordSpecs', () => {\n    describe('fallback commit information', () => {\n      let resetEnv = null\n\n      const env = {\n        COMMIT_INFO_BRANCH: 'my-branch-221',\n        COMMIT_INFO_MESSAGE: 'best commit ever',\n        COMMIT_INFO_EMAIL: 'user@company.com',\n        COMMIT_INFO_AUTHOR: 'Agent Smith',\n        COMMIT_INFO_SHA: '0123456',\n        COMMIT_INFO_REMOTE: 'remote repo',\n      }\n\n      beforeEach(() => {\n        // stub git commands to return nulls\n        sinon.stub(commitInfo, 'getBranch').resolves(null)\n        sinon.stub(commitInfo, 'getMessage').resolves(null)\n        sinon.stub(commitInfo, 'getEmail').resolves(null)\n        sinon.stub(commitInfo, 'getAuthor').resolves(null)\n        sinon.stub(commitInfo, 'getSha').resolves(null)\n        sinon.stub(commitInfo, 'getRemoteOrigin').resolves(null)\n        resetEnv = mockedEnv(env, { clear: true })\n      })\n\n      afterEach(() => {\n        resetEnv()\n      })\n\n      it('calls api.createRun with the commit extracted from environment variables', () => {\n        const createRun = sinon.stub(api, 'createRun').resolves()\n        const runAllSpecs = sinon.stub()\n\n        return recordMode.createRunAndRecordSpecs({\n          key: 'foo',\n          sys: {},\n          browser: {},\n          runAllSpecs,\n        })\n        .then(() => {\n          expect(runAllSpecs).to.have.been.calledWith({ parallel: false })\n          expect(createRun).to.have.been.calledOnce\n          expect(createRun.firstCall.args).to.have.length(1)\n          const { commit } = createRun.firstCall.args[0]\n\n          debug('git is %o', commit)\n\n          expect(commit).to.deep.equal({\n            sha: env.COMMIT_INFO_SHA,\n            branch: env.COMMIT_INFO_BRANCH,\n            authorName: env.COMMIT_INFO_AUTHOR,\n            authorEmail: env.COMMIT_INFO_EMAIL,\n            message: env.COMMIT_INFO_MESSAGE,\n            remoteOrigin: env.COMMIT_INFO_REMOTE,\n            defaultBranch: null,\n          })\n        })\n      })\n    })\n\n    describe('override commit information', () => {\n      let resetEnv = null\n\n      const env = {\n        COMMIT_INFO_BRANCH: 'my-branch-221',\n        COMMIT_INFO_MESSAGE: 'best commit ever',\n        COMMIT_INFO_EMAIL: 'user@company.com',\n        COMMIT_INFO_AUTHOR: 'Agent Smith',\n        COMMIT_INFO_SHA: '0123456',\n        COMMIT_INFO_REMOTE: 'remote repo',\n      }\n\n      beforeEach(() => {\n        // stub git commands to return values\n        sinon.stub(commitInfo, 'getBranch').resolves('my-ci-branch')\n        sinon.stub(commitInfo, 'getMessage').resolves('my ci msg')\n        sinon.stub(commitInfo, 'getEmail').resolves('my.ci@email.com')\n        sinon.stub(commitInfo, 'getAuthor').resolves('My CI Name')\n        sinon.stub(commitInfo, 'getSha').resolves('mycisha')\n        sinon.stub(commitInfo, 'getRemoteOrigin').resolves('my ci remote')\n        resetEnv = mockedEnv(env, { clear: true })\n      })\n\n      afterEach(() => {\n        resetEnv()\n      })\n\n      it('calls api.createRun with the commit overrided from environment variables', () => {\n        const createRun = sinon.stub(api, 'createRun').resolves()\n        const runAllSpecs = sinon.stub()\n\n        return recordMode.createRunAndRecordSpecs({\n          key: 'foo',\n          sys: {},\n          browser: {},\n          runAllSpecs,\n        })\n        .then(() => {\n          expect(runAllSpecs).to.have.been.calledWith({ parallel: false })\n          expect(createRun).to.have.been.calledOnce\n          expect(createRun.firstCall.args).to.have.length(1)\n          const { commit } = createRun.firstCall.args[0]\n\n          debug('git is %o', commit)\n\n          expect(commit).to.deep.equal({\n            sha: env.COMMIT_INFO_SHA,\n            branch: env.COMMIT_INFO_BRANCH,\n            authorName: env.COMMIT_INFO_AUTHOR,\n            authorEmail: env.COMMIT_INFO_EMAIL,\n            message: env.COMMIT_INFO_MESSAGE,\n            remoteOrigin: env.COMMIT_INFO_REMOTE,\n            defaultBranch: null,\n          })\n        })\n      })\n    })\n\n    describe('with CI info', () => {\n      const specs = [\n        { relative: 'path/to/spec/a' },\n        { relative: 'path/to/spec/b' },\n      ]\n\n      beforeEach(function () {\n        sinon.stub(ciProvider, 'provider').returns('circle')\n        sinon.stub(ciProvider, 'ciParams').returns({ foo: 'bar' })\n\n        this.commitDefaults = {\n          branch: 'master',\n          author: 'brian',\n          email: 'brian@cypress.io',\n          message: 'such hax',\n          sha: 'sha-123',\n          remote: 'https://github.com/foo/bar.git',\n        }\n\n        sinon.stub(commitInfo, 'commitInfo').resolves(this.commitDefaults)\n        sinon.stub(ciProvider, 'commitDefaults').returns({\n          sha: this.commitDefaults.sha,\n          branch: this.commitDefaults.branch,\n          authorName: this.commitDefaults.author,\n          authorEmail: this.commitDefaults.email,\n          message: this.commitDefaults.message,\n          remoteOrigin: this.commitDefaults.remote,\n        })\n\n        sinon.stub(api, 'createRun').resolves()\n      })\n\n      it('calls api.createRun with the right args', () => {\n        const key = 'recordKey'\n        const projectId = 'pId123'\n        const specPattern = ['spec/pattern1', 'spec/pattern2']\n        const projectRoot = 'project/root'\n        const ciBuildId = 'ciId123'\n        const parallel = null\n        const group = null\n        const runAllSpecs = sinon.stub()\n        const sys = {\n          osCpus: 1,\n          osName: 2,\n          osMemory: 3,\n          osVersion: 4,\n        }\n        const browser = {\n          displayName: 'chrome',\n          version: '59',\n        }\n        const tag = 'nightly,develop'\n        const testingType = 'e2e'\n\n        return recordMode.createRunAndRecordSpecs({\n          key,\n          sys,\n          specs,\n          group,\n          browser,\n          parallel,\n          ciBuildId,\n          projectId,\n          projectRoot,\n          specPattern,\n          runAllSpecs,\n          tag,\n          testingType,\n        })\n        .then(() => {\n          expect(commitInfo.commitInfo).to.be.calledWith(projectRoot)\n\n          expect(api.createRun).to.be.calledWith({\n            group,\n            parallel,\n            projectId,\n            ciBuildId,\n            recordKey: key,\n            testingType,\n            specPattern: 'spec/pattern1,spec/pattern2',\n            specs: ['path/to/spec/a', 'path/to/spec/b'],\n            platform: {\n              osCpus: 1,\n              osName: 2,\n              osMemory: 3,\n              osVersion: 4,\n              browserName: 'chrome',\n              browserVersion: '59',\n            },\n            ci: {\n              params: {\n                foo: 'bar',\n              },\n              provider: 'circle',\n            },\n            commit: {\n              authorEmail: 'brian@cypress.io',\n              authorName: 'brian',\n              branch: 'master',\n              message: 'such hax',\n              remoteOrigin: 'https://github.com/foo/bar.git',\n              sha: 'sha-123',\n            },\n            tags: ['nightly', 'develop'],\n          })\n        })\n      })\n    })\n  })\n\n  context('.updateInstanceStdout', () => {\n    beforeEach(function () {\n      sinon.stub(api, 'updateInstanceStdout')\n\n      this.options = {\n        runId: 'run-id-123',\n        instanceId: 'id-123',\n        captured: {\n          toString () {\n            return 'foobarbaz\\n'\n          },\n        },\n      }\n    })\n\n    it('calls api.updateInstanceStdout', function () {\n      api.updateInstanceStdout.resolves()\n\n      return recordMode.updateInstanceStdout(this.options)\n      .then(() => {\n        expect(api.updateInstanceStdout).to.be.calledWith({\n          runId: 'run-id-123',\n          instanceId: 'id-123',\n          stdout: 'foobarbaz\\n',\n        })\n      })\n    })\n\n    it('does not createException when statusCode is 503', () => {\n      const err = new Error('foo')\n\n      err.statusCode = 503\n\n      api.updateInstanceStdout.rejects(err)\n      sinon.spy(logger, 'createException')\n\n      const options = {\n        instanceId: 'id-123',\n        captured: { toString () {\n          return 'foobarbaz\\n'\n        } },\n      }\n\n      return recordMode.updateInstanceStdout(options)\n      .then(() => {\n        expect(logger.createException).not.to.be.called\n      })\n    })\n  })\n\n  context('.createInstance', () => {\n    beforeEach(function () {\n      sinon.stub(api, 'createInstance')\n\n      this.options = {\n        runId: 'run-123',\n        groupId: 'group-123',\n        machineId: 'machine-123',\n        platform: {},\n        spec: { relative: 'cypress/integration/app_spec.coffee' },\n      }\n    })\n\n    it('calls api.createInstance', function () {\n      api.createInstance.resolves()\n\n      return recordMode.createInstance(this.options)\n      .then(() => {\n        expect(api.createInstance).to.be.calledWith({\n          runId: 'run-123',\n          groupId: 'group-123',\n          machineId: 'machine-123',\n          platform: {},\n          spec: 'cypress/integration/app_spec.coffee',\n        })\n      })\n    })\n\n    it('errors when statusCode is 503', async () => {\n      const err = new Error('foo')\n\n      err.statusCode = 503\n\n      api.createInstance.rejects(err)\n\n      sinon.spy(errors, 'get')\n\n      await expect(recordMode.createInstance({\n        runId: 'run-123',\n        groupId: 'group-123',\n        machineId: 'machine-123',\n        platform: {},\n        spec: { relative: 'cypress/integration/app_spec.coffee' },\n      })).to.be.rejected\n\n      expect(errors.get).to.have.been.calledWith('DASHBOARD_CANNOT_PROCEED_IN_SERIAL')\n    })\n  })\n\n  context('.createRun', () => {\n    beforeEach(function () {\n      sinon.stub(api, 'createRun')\n      sinon.stub(ciProvider, 'ciParams').returns({})\n      sinon.stub(ciProvider, 'provider').returns('')\n      sinon.stub(ciProvider, 'commitDefaults').returns({})\n\n      this.options = {\n        git: {},\n        recordKey: '1',\n      }\n    })\n\n    // https://github.com/cypress-io/cypress/issues/14571\n    it('handles non-string key', async () => {\n      const err = new Error('Invalid Record Key')\n\n      err.statusCode = 401\n\n      api.createRun.rejects(err)\n\n      sinon.spy(errors, 'throw')\n      await expect(recordMode.createRun({\n        git: {},\n        recordKey: true, // instead of a string\n      })).to.be.rejected\n\n      expect(errors.throw).to.have.been.calledWith('DASHBOARD_RECORD_KEY_NOT_VALID', 'undefined')\n    })\n  })\n\n  context('.postInstanceTests', () => {\n    beforeEach(function () {\n      sinon.stub(api, 'postInstanceTests')\n      sinon.stub(ciProvider, 'ciParams').returns({})\n      sinon.stub(ciProvider, 'provider').returns('')\n      sinon.stub(ciProvider, 'commitDefaults').returns({})\n\n      this.options = {\n        results: {},\n        captured: '',\n      }\n    })\n  })\n\n  context('.postInstanceResults', () => {\n    beforeEach(function () {\n      sinon.stub(api, 'postInstanceResults')\n      sinon.stub(ciProvider, 'ciParams').returns({})\n      sinon.stub(ciProvider, 'provider').returns('')\n      sinon.stub(ciProvider, 'commitDefaults').returns({})\n\n      this.options = {\n        results: {},\n        captured: '',\n      }\n    })\n  })\n})\n",
    "packages/server/test/unit/modes/run_spec.js": "require('../../spec_helper')\n\nconst Promise = require('bluebird')\nconst electron = require('electron')\nconst stripAnsi = require('strip-ansi')\nconst snapshot = require('snap-shot-it')\nconst R = require('ramda')\nconst pkg = require('@packages/root')\nconst { ProjectBase } = require('../../../lib/project-base')\nconst { fs } = require(`${root}../lib/util/fs`)\nconst user = require(`${root}../lib/user`)\nconst errors = require(`${root}../lib/errors`)\nconst config = require(`${root}../lib/config`)\nconst { ProjectE2E } = require(`${root}../lib/project-e2e`)\nconst browsers = require(`${root}../lib/browsers`)\nconst Reporter = require(`${root}../lib/reporter`)\nconst runMode = require(`${root}../lib/modes/run`)\nconst openProject = require(`${root}../lib/open_project`)\nconst videoCapture = require(`${root}../lib/video_capture`)\nconst env = require(`${root}../lib/util/env`)\nconst random = require(`${root}../lib/util/random`)\nconst system = require(`${root}../lib/util/system`)\nconst specsUtil = require(`${root}../lib/util/specs`)\nconst { experimental } = require(`${root}../lib/experiments`)\n\ndescribe('lib/modes/run', () => {\n  beforeEach(function () {\n    this.projectInstance = new ProjectBase('/_test-output/path/to/project-e2e')\n  })\n\n  context('.getProjectId', () => {\n    it('resolves if id', () => {\n      return runMode.getProjectId('project', 'id123')\n      .then((ret) => {\n        expect(ret).to.eq('id123')\n      })\n    })\n\n    it('resolves if CYPRESS_PROJECT_ID set', () => {\n      sinon.stub(env, 'get').withArgs('CYPRESS_PROJECT_ID').returns('envId123')\n\n      return runMode.getProjectId('project')\n      .then((ret) => {\n        expect(ret).to.eq('envId123')\n      })\n    })\n\n    it('is null when no projectId', () => {\n      const project = {\n        getProjectId: sinon.stub().rejects(new Error),\n      }\n\n      return runMode.getProjectId(project)\n      .then((ret) => {\n        expect(ret).to.be.null\n      })\n    })\n  })\n\n  context('.openProjectCreate', () => {\n    let onError\n\n    beforeEach(() => {\n      sinon.stub(openProject, 'create').resolves()\n\n      onError = sinon.spy()\n      const options = {\n        onError,\n        port: 8080,\n        env: { foo: 'bar' },\n        isTextTerminal: true,\n        projectRoot: '/_test-output/path/to/project/foo',\n      }\n\n      return runMode.openProjectCreate(options.projectRoot, 1234, options)\n    })\n\n    it('calls openProject.create with projectRoot + options', () => {\n      expect(openProject.create).to.be.calledWithMatch('/_test-output/path/to/project/foo', {\n        port: 8080,\n        projectRoot: '/_test-output/path/to/project/foo',\n        env: { foo: 'bar' },\n      }, {\n        morgan: false,\n        socketId: 1234,\n        report: true,\n        isTextTerminal: true,\n      })\n    })\n\n    it('calls options.onError with error message onError', () => {\n      const error = { message: 'the message' }\n\n      expect(openProject.create.lastCall.args[2].onError).to.be.a('function')\n      openProject.create.lastCall.args[2].onError(error)\n      expect(onError).to.be.calledWith(error)\n    })\n  })\n\n  context('.getElectronProps', () => {\n    it('sets width and height', () => {\n      const props = runMode.getElectronProps()\n\n      expect(props.width).to.eq(1920)\n\n      expect(props.height).to.eq(1080)\n    })\n\n    it('sets show to boolean', () => {\n      let props = runMode.getElectronProps(false)\n\n      expect(props.show).to.be.false\n\n      props = runMode.getElectronProps(true)\n\n      expect(props.show).to.be.true\n    })\n\n    it('sets onScreencastFrame when write is true', () => {\n      const write = sinon.stub()\n\n      const image = {\n        data: '',\n      }\n\n      const props = runMode.getElectronProps(true, write)\n\n      props.onScreencastFrame(image)\n\n      expect(write).to.be.calledOnce\n    })\n\n    it('does not set onScreencastFrame when write is falsy', () => {\n      const props = runMode.getElectronProps(true, false)\n\n      expect(props).not.to.have.property('recordFrameRate')\n      expect(props).not.to.have.property('onScreencastFrame')\n    })\n\n    it('sets options.show = false onNewWindow callback', () => {\n      const options = { show: true }\n\n      const props = runMode.getElectronProps()\n\n      props.onNewWindow(null, null, null, null, options)\n\n      expect(options.show).to.eq(false)\n    })\n\n    it('calls options.onError when webContents crashes', function () {\n      sinon.spy(errors, 'get')\n      sinon.spy(errors, 'log')\n\n      const onError = sinon.spy()\n      const props = runMode.getElectronProps(true, this.projectInstance, onError)\n\n      props.onCrashed()\n\n      expect(errors.get).to.be.calledWith('RENDERER_CRASHED')\n      expect(errors.log).to.be.calledOnce\n\n      expect(onError).to.be.called\n      expect(onError.lastCall.args[0].message).to.include('We detected that the Chromium Renderer process just crashed.')\n    })\n  })\n\n  context('.launchBrowser', () => {\n    beforeEach(function () {\n      this.launch = sinon.stub(openProject, 'launch')\n      sinon.stub(runMode, 'screenshotMetadata').returns({ a: 'a' })\n    })\n\n    it('can launch electron', function () {\n      const screenshots = []\n\n      const spec = {\n        absolute: '/path/to/spec',\n      }\n\n      const browser = {\n        name: 'electron',\n        family: 'chromium',\n        isHeaded: false,\n      }\n\n      runMode.launchBrowser({\n        spec,\n        browser,\n        project: this.projectInstance,\n        writeVideoFrame: 'write',\n        screenshots,\n      })\n\n      expect(this.launch).to.be.calledWithMatch(browser, spec)\n\n      const browserOpts = this.launch.firstCall.args[2]\n\n      const { onAfterResponse } = browserOpts.automationMiddleware\n\n      expect(onAfterResponse).to.be.a('function')\n\n      onAfterResponse('take:screenshot', {}, {})\n      onAfterResponse('get:cookies')\n\n      expect(screenshots).to.deep.eq([{ a: 'a' }])\n    })\n\n    it('can launch chrome', function () {\n      const spec = {\n        absolute: '/path/to/spec',\n      }\n\n      const browser = {\n        name: 'chrome',\n        family: 'chromium',\n        isHeaded: true,\n      }\n\n      runMode.launchBrowser({\n        spec,\n        browser,\n        project: {},\n      })\n\n      expect(this.launch).to.be.calledWithMatch(browser, spec, {})\n    })\n  })\n\n  context('.postProcessRecording', () => {\n    beforeEach(() => {\n      sinon.stub(videoCapture, 'process').resolves()\n    })\n\n    it('calls video process with name, cname and videoCompression', () => {\n      return runMode.postProcessRecording('foo', 'foo-compress', 32, true)\n      .then(() => {\n        expect(videoCapture.process).to.be.calledWith('foo', 'foo-compress', 32)\n      })\n    })\n\n    it('does not call video process when videoCompression is false', () => {\n      return runMode.postProcessRecording('foo', 'foo-compress', false, true)\n      .then(() => {\n        expect(videoCapture.process).not.to.be.called\n      })\n    })\n\n    it('calls video process if we have been told to upload videos', () => {\n      return runMode.postProcessRecording('foo', 'foo-compress', 32, true)\n      .then(() => {\n        expect(videoCapture.process).to.be.calledWith('foo', 'foo-compress', 32)\n      })\n    })\n\n    it('does not call video process if there are no failing tests and we have set not to upload video on passing', () => {\n      return runMode.postProcessRecording('foo', 'foo-compress', 32, false)\n      .then(() => {\n        expect(videoCapture.process).not.to.be.called\n      })\n    })\n  })\n\n  context('.waitForBrowserToConnect', () => {\n    it('throws TESTS_DID_NOT_START_FAILED after 3 connection attempts', function () {\n      sinon.spy(errors, 'warning')\n      sinon.spy(errors, 'get')\n      sinon.spy(openProject, 'closeBrowser')\n      sinon.stub(runMode, 'launchBrowser').resolves()\n      sinon.stub(runMode, 'waitForSocketConnection').callsFake(() => {\n        return Promise.delay(1000)\n      })\n\n      const onError = sinon.spy()\n\n      return runMode.waitForBrowserToConnect({ project: this.projectInstance, timeout: 10, onError })\n      .then(() => {\n        expect(openProject.closeBrowser).to.be.calledThrice\n        expect(runMode.launchBrowser).to.be.calledThrice\n        expect(runMode.launchBrowser.firstCall.args[0]).not.property('writeVideoFrame')\n        expect(errors.warning).to.be.calledWith('TESTS_DID_NOT_START_RETRYING', 'Retrying...')\n        expect(errors.warning).to.be.calledWith('TESTS_DID_NOT_START_RETRYING', 'Retrying again...')\n        expect(errors.get).to.be.calledWith('TESTS_DID_NOT_START_FAILED')\n\n        expect(onError).to.be.called\n        expect(onError.lastCall.args[0].message).to.include('The browser never connected. Something is wrong. The tests cannot run. Aborting...')\n      })\n    })\n  })\n\n  context('.waitForSocketConnection', () => {\n    beforeEach(function () {\n      this.projectStub = sinon.stub({\n        on () {},\n        removeListener () {},\n      })\n    })\n\n    it('attaches fn to \\'socket:connected\\' event', function () {\n      runMode.waitForSocketConnection(this.projectStub, 1234)\n\n      expect(this.projectStub.on).to.be.calledWith('socket:connected')\n    })\n\n    it('calls removeListener if socketId matches id', function () {\n      this.projectStub.on.yields(1234)\n\n      return runMode.waitForSocketConnection(this.projectStub, 1234)\n      .then(() => {\n        expect(this.projectStub.removeListener).to.be.calledWith('socket:connected')\n      })\n    })\n\n    describe('integration', () => {\n      it('resolves undefined when socket:connected fires', function () {\n        process.nextTick(() => {\n          return this.projectInstance.emit('socket:connected', 1234)\n        })\n\n        return runMode.waitForSocketConnection(this.projectInstance, 1234)\n        .then((ret) => {\n          expect(ret).to.be.undefined\n        })\n      })\n\n      it('does not resolve if socketId does not match id', function () {\n        process.nextTick(() => {\n          return this.projectInstance.emit('socket:connected', 12345)\n        })\n\n        return runMode\n        .waitForSocketConnection(this.projectInstance, 1234)\n        .timeout(50)\n        .then(() => {\n          throw new Error('should time out and not resolve')\n        }).catch(Promise.TimeoutError, (err) => {})\n      })\n\n      it('actually removes the listener', function () {\n        process.nextTick(() => {\n          this.projectInstance.emit('socket:connected', 12345)\n          expect(this.projectInstance.listeners('socket:connected')).to.have.length(1)\n          this.projectInstance.emit('socket:connected', '1234')\n          expect(this.projectInstance.listeners('socket:connected')).to.have.length(1)\n          this.projectInstance.emit('socket:connected', 1234)\n\n          expect(this.projectInstance.listeners('socket:connected')).to.have.length(0)\n        })\n\n        return runMode.waitForSocketConnection(this.projectInstance, 1234)\n      })\n    })\n  })\n\n  context('.waitForTestsToFinishRunning', () => {\n    beforeEach(function () {\n      sinon.stub(fs, 'pathExists').resolves(true)\n      sinon.stub(this.projectInstance, 'getConfig').resolves({})\n      sinon.spy(runMode, 'getVideoRecordingDelay')\n      sinon.spy(errors, 'warning')\n\n      this.setupProjectEnd = (results) => {\n        results = results || {\n          stats: {\n            failures: 0,\n          },\n        }\n\n        process.nextTick(() => {\n          this.projectInstance.emit('end', results)\n        })\n      }\n    })\n\n    it('end event resolves with obj, displays stats, displays screenshots, sets video timestamps', function () {\n      const startedVideoCapture = new Date\n      const screenshots = [{}, {}, {}]\n      const endVideoCapture = sinon.stub().resolves()\n      const results = {\n        tests: [{ attempts: [1] }, { attempts: [2] }, { attempts: [3] }],\n        stats: {\n          tests: 1,\n          passes: 2,\n          failures: 3,\n          pending: 4,\n          duration: 5,\n        },\n      }\n\n      sinon.stub(Reporter, 'setVideoTimestamp')\n      sinon.stub(runMode, 'postProcessRecording').resolves()\n      sinon.spy(runMode, 'displayResults')\n      sinon.spy(runMode, 'displayScreenshots')\n      sinon.spy(Promise.prototype, 'delay')\n\n      this.setupProjectEnd(results)\n\n      return runMode.waitForTestsToFinishRunning({\n        project: this.projectInstance,\n        videoName: 'foo.mp4',\n        compressedVideoName: 'foo-compressed.mp4',\n        videoCompression: 32,\n        videoUploadOnPasses: true,\n        gui: false,\n        screenshots,\n        startedVideoCapture,\n        endVideoCapture,\n        spec: {\n          path: 'cypress/integration/spec.js',\n        },\n      })\n      .then((obj) => {\n        // since video was recording, there was a delay to let video finish\n        expect(Reporter.setVideoTimestamp).calledWith(startedVideoCapture, [1, 2, 3])\n        expect(runMode.getVideoRecordingDelay).to.have.returned(1000)\n        expect(Promise.prototype.delay).to.be.calledWith(1000)\n        expect(runMode.postProcessRecording).to.be.calledWith('foo.mp4', 'foo-compressed.mp4', 32, true)\n\n        expect(runMode.displayResults).to.be.calledWith(results)\n        expect(runMode.displayScreenshots).to.be.calledWith(screenshots)\n\n        expect(obj).to.deep.eq({\n          screenshots,\n          video: 'foo.mp4',\n          error: null,\n          hooks: null,\n          reporterStats: null,\n          shouldUploadVideo: true,\n          tests: results.tests,\n          spec: {\n            path: 'cypress/integration/spec.js',\n          },\n          stats: {\n            tests: 1,\n            passes: 2,\n            failures: 3,\n            pending: 4,\n            duration: 5,\n          },\n        })\n      })\n    })\n\n    it('exiting early resolves with no tests, and error', function () {\n      sinon.useFakeTimers({ shouldAdvanceTime: true })\n\n      const err = new Error('foo')\n      const startedVideoCapture = new Date\n      const wallClock = new Date()\n      const screenshots = [{}, {}, {}]\n      const endVideoCapture = sinon.stub().resolves()\n\n      sinon.stub(runMode, 'postProcessRecording').resolves()\n      sinon.spy(runMode, 'displayResults')\n      sinon.spy(runMode, 'displayScreenshots')\n      sinon.spy(Promise.prototype, 'delay')\n\n      process.nextTick(() => {\n        runMode.exitEarly(err)\n      })\n\n      return runMode.waitForTestsToFinishRunning({\n        project: this.projectInstance,\n        videoName: 'foo.mp4',\n        compressedVideoName: 'foo-compressed.mp4',\n        videoCompression: 32,\n        videoUploadOnPasses: true,\n        gui: false,\n        screenshots,\n        startedVideoCapture,\n        endVideoCapture,\n        spec: {\n          path: 'cypress/integration/spec.js',\n        },\n      })\n      .then((obj) => {\n        // since video was recording, there was a delay to let video finish\n        expect(runMode.getVideoRecordingDelay).to.have.returned(1000)\n        expect(Promise.prototype.delay).to.be.calledWith(1000)\n        expect(runMode.postProcessRecording).to.be.calledWith('foo.mp4', 'foo-compressed.mp4', 32, true)\n\n        expect(runMode.displayResults).to.be.calledWith(obj)\n        expect(runMode.displayScreenshots).to.be.calledWith(screenshots)\n\n        expect(obj).to.deep.eq({\n          screenshots,\n          error: err.message,\n          video: 'foo.mp4',\n          hooks: null,\n          tests: null,\n          reporterStats: null,\n          shouldUploadVideo: true,\n          spec: {\n            path: 'cypress/integration/spec.js',\n          },\n          stats: {\n            failures: 1,\n            tests: 0,\n            passes: 0,\n            pending: 0,\n            suites: 0,\n            skipped: 0,\n            wallClockDuration: 0,\n            wallClockStartedAt: wallClock.toJSON(),\n            wallClockEndedAt: wallClock.toJSON(),\n          },\n        })\n      })\n    })\n\n    it('logs warning and resolves on failed video end', async function () {\n      this.setupProjectEnd()\n\n      sinon.spy(videoCapture, 'process')\n      const endVideoCapture = sinon.stub().rejects()\n\n      await runMode.waitForTestsToFinishRunning({\n        project: this.projectInstance,\n        videoName: 'foo.mp4',\n        compressedVideoName: 'foo-compressed.mp4',\n        videoCompression: 32,\n        videoUploadOnPasses: true,\n        gui: false,\n        endVideoCapture,\n      })\n\n      expect(errors.warning).to.be.calledWith('VIDEO_POST_PROCESSING_FAILED')\n\n      expect(videoCapture.process).not.to.be.called\n    })\n\n    it('logs warning and resolves on failed video compression', async function () {\n      this.setupProjectEnd()\n\n      const endVideoCapture = sinon.stub().resolves()\n\n      sinon.stub(videoCapture, 'process').rejects()\n\n      await runMode.waitForTestsToFinishRunning({\n        project: this.projectInstance,\n        videoName: 'foo.mp4',\n        compressedVideoName: 'foo-compressed.mp4',\n        videoCompression: 32,\n        videoUploadOnPasses: true,\n        gui: false,\n        endVideoCapture,\n      })\n\n      expect(errors.warning).to.be.calledWith('VIDEO_POST_PROCESSING_FAILED')\n    })\n\n    it('does not upload video when videoUploadOnPasses is false and no failures', function () {\n      this.setupProjectEnd()\n\n      sinon.spy(runMode, 'postProcessRecording')\n      sinon.spy(videoCapture, 'process')\n      const endVideoCapture = sinon.stub().resolves()\n\n      return runMode.waitForTestsToFinishRunning({\n        project: this.projectInstance,\n        videoName: 'foo.mp4',\n        compressedVideoName: 'foo-compressed.mp4',\n        videoCompression: 32,\n        videoUploadOnPasses: false,\n        gui: false,\n        endVideoCapture,\n      })\n      .then(() => {\n        expect(runMode.postProcessRecording).to.be.calledWith('foo.mp4', 'foo-compressed.mp4', 32, false)\n\n        expect(videoCapture.process).not.to.be.called\n      })\n    })\n\n    it('does not delay when not capturing a video', () => {\n      sinon.stub(runMode, 'listenForProjectEnd').resolves({})\n\n      return runMode.waitForTestsToFinishRunning({\n        startedVideoCapture: null,\n      })\n      .then(() => {\n        expect(runMode.getVideoRecordingDelay).to.have.returned(0)\n      })\n    })\n\n    describe('when video is deleted in after:spec event', function () {\n      beforeEach(function () {\n        this.setupProjectEnd()\n        sinon.spy(runMode, 'postProcessRecording')\n        sinon.spy(videoCapture, 'process')\n\n        fs.pathExists.resolves(false)\n      })\n\n      it('does not process or upload video', function () {\n        return runMode.waitForTestsToFinishRunning({\n          project: this.projectInstance,\n          startedVideoCapture: new Date(),\n          videoName: 'foo.mp4',\n          endVideoCapture: sinon.stub().resolves(),\n        })\n        .then((results) => {\n          expect(runMode.postProcessRecording).not.to.be.called\n          expect(videoCapture.process).not.to.be.called\n          expect(results.shouldUploadVideo).to.be.false\n        })\n      })\n\n      it('nulls out video value from results', function () {\n        return runMode.waitForTestsToFinishRunning({\n          project: this.projectInstance,\n          startedVideoCapture: new Date(),\n          videoName: 'foo.mp4',\n          endVideoCapture: sinon.stub().resolves(),\n        })\n        .then((results) => {\n          expect(results.video).to.be.null\n        })\n      })\n    })\n  })\n\n  context('.listenForProjectEnd', () => {\n    it('resolves with end event + argument', function () {\n      process.nextTick(() => {\n        return this.projectInstance.emit('end', { foo: 'bar' })\n      })\n\n      return runMode.listenForProjectEnd(this.projectInstance)\n      .then((obj) => {\n        expect(obj).to.deep.eq({\n          foo: 'bar',\n        })\n      })\n    })\n\n    it('stops listening to end event', function () {\n      process.nextTick(() => {\n        expect(this.projectInstance.listeners('end')).to.have.length(1)\n        this.projectInstance.emit('end', { foo: 'bar' })\n\n        expect(this.projectInstance.listeners('end')).to.have.length(0)\n      })\n\n      return runMode.listenForProjectEnd(this.projectInstance)\n    })\n  })\n\n  context('.run browser vs video recording', () => {\n    beforeEach(function () {\n      sinon.stub(electron.app, 'on').withArgs('ready').yieldsAsync()\n      sinon.stub(user, 'ensureAuthToken')\n      sinon.stub(ProjectE2E, 'ensureExists').resolves()\n      sinon.stub(ProjectBase, 'ensureExists').resolves()\n      sinon.stub(random, 'id').returns(1234)\n      sinon.stub(openProject, 'create').resolves(openProject)\n      sinon.stub(runMode, 'waitForSocketConnection').resolves()\n      sinon.stub(runMode, 'waitForTestsToFinishRunning').resolves({\n        stats: { failures: 10 },\n        spec: {},\n      })\n\n      sinon.spy(runMode, 'waitForBrowserToConnect')\n      sinon.stub(videoCapture, 'start').resolves()\n      sinon.stub(openProject, 'launch').resolves()\n      sinon.stub(openProject, 'getProject').resolves(this.projectInstance)\n      sinon.spy(errors, 'warning')\n      sinon.stub(config, 'get').resolves({\n        proxyUrl: 'http://localhost:12345',\n        video: true,\n        videosFolder: 'videos',\n        integrationFolder: '/path/to/integrationFolder',\n      })\n\n      sinon.stub(specsUtil, 'find').resolves([\n        {\n          name: 'foo_spec.js',\n          path: 'cypress/integration/foo_spec.js',\n          absolute: '/path/to/spec.js',\n        },\n      ])\n    })\n\n    it('shows no warnings for default browser', () => {\n      return runMode.run()\n      .then(() => {\n        expect(errors.warning).to.not.be.called\n      })\n    })\n\n    it('throws an error if invalid browser family supplied', () => {\n      const browser = { name: 'opera', family: 'opera - btw when is Opera support coming?' }\n\n      sinon.stub(browsers, 'ensureAndGetByNameOrPath').resolves(browser)\n\n      return expect(runMode.run({ browser: 'opera' }))\n      .to.be.rejectedWith(/invalid browser family in/)\n    })\n\n    it('shows no warnings for chrome browser', () => {\n      return runMode.run({ browser: 'chrome' })\n      .then(() => {\n        expect(errors.warning).to.not.be.called\n      })\n    })\n\n    it('names video file with spec name', () => {\n      return runMode.run()\n      .then(() => {\n        expect(videoCapture.start).to.be.calledWith('videos/foo_spec.js.mp4')\n\n        expect(runMode.waitForTestsToFinishRunning).to.be.calledWithMatch({\n          compressedVideoName: 'videos/foo_spec.js-compressed.mp4',\n        })\n      })\n    })\n  })\n\n  context('.run', () => {\n    beforeEach(function () {\n      sinon.stub(this.projectInstance, 'getConfig').resolves({\n        proxyUrl: 'http://localhost:12345',\n      })\n\n      sinon.stub(electron.app, 'on').withArgs('ready').yieldsAsync()\n      sinon.stub(user, 'ensureAuthToken')\n      sinon.stub(ProjectE2E, 'ensureExists').resolves()\n      sinon.stub(ProjectBase, 'ensureExists').resolves()\n      sinon.stub(random, 'id').returns(1234)\n      sinon.stub(openProject, 'create').resolves(openProject)\n      sinon.stub(system, 'info').resolves({ osName: 'osFoo', osVersion: 'fooVersion' })\n      sinon.stub(browsers, 'ensureAndGetByNameOrPath').resolves({\n        name: 'fooBrowser',\n        path: 'path/to/browser',\n        version: '777',\n        family: 'chromium',\n      })\n\n      sinon.stub(runMode, 'waitForSocketConnection').resolves()\n      sinon.stub(runMode, 'waitForTestsToFinishRunning').resolves({\n        stats: { failures: 10 },\n        spec: {},\n      })\n\n      sinon.spy(runMode, 'waitForBrowserToConnect')\n      sinon.spy(runMode, 'runSpecs')\n      sinon.stub(openProject, 'launch').resolves()\n      sinon.stub(openProject, 'getProject').resolves(this.projectInstance)\n      sinon.stub(specsUtil, 'find').resolves([\n        {\n          name: 'foo_spec.js',\n          path: 'cypress/integration/foo_spec.js',\n          absolute: '/path/to/spec.js',\n        },\n      ])\n    })\n\n    it('no longer ensures user session', () => {\n      return runMode.run()\n      .then(() => {\n        expect(user.ensureAuthToken).not.to.be.called\n      })\n    })\n\n    it('resolves with object and totalFailed', () => {\n      return runMode.run()\n      .then((results) => {\n        expect(results).to.have.property('totalFailed', 10)\n      })\n    })\n\n    it('passes projectRoot + options to openProject', () => {\n      const opts = { projectRoot: '/path/to/project', foo: 'bar' }\n\n      return runMode.run(opts)\n      .then(() => {\n        expect(openProject.create).to.be.calledWithMatch(opts.projectRoot, opts)\n      })\n    })\n\n    it('passes project + id to waitForBrowserToConnect', function () {\n      return runMode.run()\n      .then(() => {\n        expect(runMode.waitForBrowserToConnect).to.be.calledWithMatch({\n          project: this.projectInstance,\n          socketId: 1234,\n        })\n      })\n    })\n\n    it('passes project to waitForTestsToFinishRunning', function () {\n      return runMode.run()\n      .then(() => {\n        expect(runMode.waitForTestsToFinishRunning).to.be.calledWithMatch({\n          project: this.projectInstance,\n        })\n      })\n    })\n\n    it('passes headed to openProject.launch', () => {\n      const browser = { name: 'electron', family: 'chromium' }\n\n      browsers.ensureAndGetByNameOrPath.resolves(browser)\n\n      return runMode.run({ headed: true })\n      .then(() => {\n        expect(openProject.launch).to.be.calledWithMatch(\n          browser,\n          {\n            name: 'foo_spec.js',\n            path: 'cypress/integration/foo_spec.js',\n            absolute: '/path/to/spec.js',\n          },\n          {\n            show: true,\n          },\n        )\n      })\n    })\n\n    it('passes sys to runSpecs', () => {\n      return runMode.run()\n      .then(() => {\n        expect(runMode.runSpecs).to.be.calledWithMatch({\n          sys: {\n            osName: 'osFoo',\n            osVersion: 'fooVersion',\n          },\n        })\n      })\n    })\n\n    it('passes browser to runSpecs', () => {\n      return runMode.run()\n      .then(() => {\n        expect(runMode.runSpecs).to.be.calledWithMatch({\n          browser: {\n            name: 'fooBrowser',\n            path: 'path/to/browser',\n            version: '777',\n          },\n        })\n      })\n    })\n  })\n\n  context('#displayRunStarting', () => {\n    // restore pkg.version property\n    // for some reason I cannot stub property value using Sinon\n    let version\n    // save a copy of \"true\" experiments right away\n    const names = R.clone(experimental.names)\n\n    before(() => {\n      // reset experiments names before each test\n      experimental.names = {}\n      version = pkg.version\n    })\n\n    afterEach(() => {\n      pkg.version = version\n      experimental.names = names\n    })\n\n    it('returns heading with experiments', () => {\n      pkg.version = '1.2.3'\n\n      experimental.names = {\n        experimentalFeatureA: 'experimentalFeatureA',\n        experimentalFeatureB: 'experimentalFeatureB',\n      }\n\n      const options = {\n        browser: {\n          displayName: 'Electron',\n          majorVersion: 99,\n          isHeadless: true,\n        },\n        config: {\n          resolved: {\n            experimentalFeatureA: {\n              value: true,\n              from: 'config',\n            },\n            experimentalFeatureB: {\n              value: 4,\n              from: 'cli',\n            },\n          },\n        },\n      }\n      const heading = runMode.displayRunStarting(options)\n\n      snapshot('enabled experiments', stripAnsi(heading))\n    })\n\n    it('resets the experiments names', () => {\n      expect(experimental.names, 'experiments were reset').to.deep.equal(names)\n    })\n\n    it('returns heading with some enabled experiments', () => {\n      pkg.version = '1.2.3'\n\n      experimental.names = {\n        experimentalFeatureA: 'experimentalFeatureA',\n        experimentalFeatureB: 'experimentalFeatureB',\n      }\n\n      const options = {\n        browser: {\n          displayName: 'Electron',\n          majorVersion: 99,\n          isHeadless: true,\n        },\n        config: {\n          resolved: {\n            // means this feature is not enabled, should not appear in the heading\n            experimentalFeatureA: {\n              value: true,\n              from: 'default',\n            },\n            experimentalFeatureB: {\n              value: 4,\n              from: 'cli',\n            },\n          },\n        },\n      }\n      const heading = runMode.displayRunStarting(options)\n\n      const text = stripAnsi(heading)\n\n      snapshot('some enabled experiments', text)\n      // explicit assertions for test clarity\n      expect(text).to.not.include('experimentalFeatureA')\n      expect(text).to.include('experimentalFeatureB')\n    })\n\n    it('returns heading without experiments', () => {\n      pkg.version = '1.2.3'\n\n      const options = {\n        browser: {\n          displayName: 'Electron',\n          majorVersion: 99,\n          isHeadless: true,\n        },\n        config: {\n          resolved: {},\n        },\n      }\n      const heading = runMode.displayRunStarting(options)\n\n      snapshot('without enabled experiments', stripAnsi(heading))\n    })\n\n    it('restores pkg.version', () => {\n      expect(pkg.version).to.not.equal('1.2.3')\n    })\n  })\n})\n",
    "packages/server/test/unit/screenshots_spec.js": "require('../spec_helper')\n\nconst _ = require('lodash')\nconst path = require('path')\nconst Jimp = require('jimp')\nconst { Buffer } = require('buffer')\nconst dataUriToBuffer = require('data-uri-to-buffer')\nconst sizeOf = require('image-size')\nconst Fixtures = require('../support/helpers/fixtures')\nconst config = require(`${root}lib/config`)\nconst screenshots = require(`${root}lib/screenshots`)\nconst { fs } = require(`${root}lib/util/fs`)\nconst plugins = require(`${root}lib/plugins`)\nconst { Screenshot } = require(`${root}lib/automation/screenshot`)\n\nconst image = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAALlJREFUeNpi1F3xYAIDA4MBA35wgQWqyB5dRoaVmeHJ779wPhOM0aQtyBAoyglmOwmwM6z1lWY44CMDFgcBFmRTGp3EGGJe/WIQ5mZm4GRlBGJmhlm3PqGaeODpNzCtKsbGIARUCALvvv6FWw9XeOvrH4bbQNOQwfabnzHdGK3AwyAjyAqX2HPzC0Pn7Y9wPtyNIMGlD74wmAqwMZz+8AvFxzATVZAFQIqwABWQiWtgAY5uCnKAAwQYAPr8OZysiz4PAAAAAElFTkSuQmCC'\nconst iso8601Regex = /^\\d{4}\\-\\d{2}\\-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.?\\d*Z?$/\n\ndescribe('lib/screenshots', () => {\n  beforeEach(function () {\n    // make each test timeout after only 1 sec\n    // so that durations are handled correctly\n    this.currentTest.timeout(1000)\n\n    Fixtures.scaffold()\n    this.todosPath = Fixtures.projectPath('todos')\n\n    this.appData = {\n      capture: 'viewport',\n      clip: { x: 0, y: 0, width: 10, height: 10 },\n      viewport: { width: 40, height: 40 },\n    }\n\n    this.buffer = Buffer.from('image 1 data buffer')\n\n    this.jimpImage = {\n      id: 1,\n      bitmap: {\n        width: 40,\n        height: 40,\n        data: this.buffer,\n      },\n      crop: sinon.stub().callsFake(() => {\n        return this.jimpImage\n      }),\n      getBuffer: sinon.stub().resolves(this.buffer),\n      getMIME () {\n        return 'image/png'\n      },\n      hash: sinon.stub().returns('image hash'),\n      clone: () => {\n        return this.jimpImage\n      },\n    }\n\n    Jimp.prototype.composite = sinon.stub()\n    // Jimp.prototype.getBuffer = sinon.stub().resolves(@buffer)\n\n    return config.get(this.todosPath).then((config1) => {\n      this.config = config1\n    })\n  })\n\n  afterEach(() => {\n    return Fixtures.remove()\n  })\n\n  context('.capture', () => {\n    beforeEach(function () {\n      this.getPixelColor = sinon.stub()\n      this.getPixelColor.withArgs(0, 0).returns('grey')\n      this.getPixelColor.withArgs(1, 0).returns('white')\n      this.getPixelColor.withArgs(0, 1).returns('white')\n      this.getPixelColor.withArgs(40, 0).returns('white')\n      this.getPixelColor.withArgs(0, 40).returns('white')\n      this.getPixelColor.withArgs(40, 40).returns('black')\n      this.jimpImage.getPixelColor = this.getPixelColor\n\n      sinon.stub(Jimp, 'read').resolves(this.jimpImage)\n      const intToRGBA = sinon.stub(Jimp, 'intToRGBA')\n\n      intToRGBA.withArgs('black').returns({ r: 0, g: 0, b: 0 })\n      intToRGBA.withArgs('grey').returns({ r: 127, g: 127, b: 127 })\n      intToRGBA.withArgs('white').returns({ r: 255, g: 255, b: 255 })\n\n      this.automate = sinon.stub().resolves(image)\n\n      this.passPixelTest = () => {\n        return this.getPixelColor.withArgs(0, 0).returns('white')\n      }\n    })\n\n    it('captures screenshot with automation', function () {\n      const data = { viewport: this.jimpImage.bitmap }\n\n      return screenshots.capture(data, this.automate).then(() => {\n        expect(this.automate).to.be.calledOnce\n\n        expect(this.automate).to.be.calledWith(data)\n      })\n    })\n\n    it('retries until helper pixels are no longer present for viewport capture', function () {\n      this.getPixelColor.withArgs(0, 0).onCall(1).returns('white')\n\n      return screenshots.capture(this.appData, this.automate).then(() => {\n        expect(this.automate).to.be.calledTwice\n      })\n    })\n\n    it('retries until helper pixels are present for runner capture', function () {\n      this.passPixelTest()\n      this.getPixelColor.withArgs(0, 0).onCall(1).returns('black')\n\n      return screenshots.capture({ viewport: this.jimpImage.bitmap }, this.automate)\n      .then(() => {\n        expect(this.automate).to.be.calledTwice\n      })\n    })\n\n    it('adjusts cropping based on pixel ratio', function () {\n      this.appData.viewport = { width: 20, height: 20 }\n      this.appData.clip = { x: 5, y: 5, width: 10, height: 10 }\n      this.passPixelTest()\n      this.getPixelColor.withArgs(2, 0).returns('white')\n      this.getPixelColor.withArgs(0, 2).returns('white')\n\n      return screenshots.capture(this.appData, this.automate)\n      .then(() => {\n        expect(this.jimpImage.crop).to.be.calledWith(10, 10, 20, 20)\n      })\n    })\n\n    it('resolves details w/ image', function () {\n      this.passPixelTest()\n\n      return screenshots.capture(this.appData, this.automate).then((details) => {\n        expect(details.image).to.equal(this.jimpImage)\n        expect(details.multipart).to.be.false\n        expect(details.pixelRatio).to.equal(1)\n\n        expect(details.takenAt).to.match(iso8601Regex)\n      })\n    })\n\n    describe('simple capture', () => {\n      beforeEach(function () {\n        this.appData.simple = true\n      })\n\n      it('skips pixel checking / reading into Jimp image', function () {\n        return screenshots.capture(this.appData, this.automate).then(() => {\n          expect(Jimp.read).not.to.be.called\n        })\n      })\n\n      it('resolves details w/ buffer', function () {\n        return screenshots.capture(this.appData, this.automate).then((details) => {\n          expect(details.takenAt).to.match(iso8601Regex)\n          expect(details.multipart).to.be.false\n\n          expect(details.buffer).to.be.instanceOf(Buffer)\n        })\n      })\n    })\n\n    describe('userClip', () => {\n      it('crops final image if userClip specified', function () {\n        this.appData.userClip = { width: 5, height: 5, x: 2, y: 2 }\n        this.passPixelTest()\n\n        return screenshots.capture(this.appData, this.automate).then(() => {\n          expect(this.jimpImage.crop).to.be.calledWith(2, 2, 5, 5)\n        })\n      })\n\n      it('does not crop intermediary multi-part images', function () {\n        this.appData.userClip = { width: 5, height: 5, x: 2, y: 2 }\n        this.appData.current = 1\n        this.appData.total = 3\n        this.passPixelTest()\n\n        return screenshots.capture(this.appData, this.automate).then(() => {\n          expect(this.jimpImage.crop).not.to.be.called\n        })\n      })\n\n      it('adjusts cropping based on pixel ratio', function () {\n        this.appData.viewport = { width: 20, height: 20 }\n        this.appData.userClip = { x: 5, y: 5, width: 10, height: 10 }\n        this.passPixelTest()\n        this.getPixelColor.withArgs(2, 0).returns('white')\n        this.getPixelColor.withArgs(0, 2).returns('white')\n\n        return screenshots.capture(this.appData, this.automate).then(() => {\n          expect(this.jimpImage.crop).to.be.calledWith(10, 10, 20, 20)\n        })\n      })\n    })\n\n    describe('multi-part capture (fullPage or element)', () => {\n      beforeEach(function () {\n        screenshots.clearMultipartState()\n\n        this.appData.current = 1\n        this.appData.total = 3\n\n        this.getPixelColor.withArgs(0, 0).onSecondCall().returns('white')\n\n        const clone = (img, props) => {\n          return _.defaultsDeep(props, img)\n        }\n\n        this.jimpImage2 = clone(this.jimpImage, {\n          id: 2,\n          bitmap: {\n            data: Buffer.from('image 2 data buffer'),\n          },\n        })\n\n        this.jimpImage3 = clone(this.jimpImage, {\n          id: 3,\n          bitmap: {\n            data: Buffer.from('image 3 data buffer'),\n          },\n        })\n\n        this.jimpImage4 = clone(this.jimpImage, {\n          id: 4,\n          bitmap: {\n            data: Buffer.from('image 4 data buffer'),\n          },\n        })\n      })\n\n      it('retries until helper pixels are no longer present on first capture', function () {\n        return screenshots.capture(this.appData, this.automate)\n        .then(() => {\n          expect(this.automate).to.be.calledTwice\n        })\n      })\n\n      it('retries until images aren\\'t the same on subsequent captures', function () {\n        return screenshots.capture(this.appData, this.automate)\n        .then(() => {\n          Jimp.read.onCall(3).resolves(this.jimpImage2)\n\n          this.appData.current = 2\n\n          return screenshots.capture(this.appData, this.automate)\n        }).then(() => {\n          expect(this.automate.callCount).to.equal(4)\n        })\n      })\n\n      it('resolves no image on non-last captures', function () {\n        return screenshots.capture(this.appData, this.automate)\n        .then((image) => {\n          expect(image).to.be.null\n        })\n      })\n\n      it('resolves details w/ image on last capture', function () {\n        return screenshots.capture(this.appData, this.automate)\n        .then(() => {\n          Jimp.read.onCall(3).resolves(this.jimpImage2)\n\n          this.appData.current = 3\n\n          return screenshots.capture(this.appData, this.automate)\n        }).then(({ image }) => {\n          expect(image).to.be.an.instanceOf(Jimp)\n        })\n      })\n\n      it('composites images into one image', function () {\n        Jimp.read.onThirdCall().resolves(this.jimpImage2)\n        Jimp.read.onCall(3).resolves(this.jimpImage3)\n\n        return screenshots.capture(this.appData, this.automate)\n        .then(() => {\n          this.appData.current = 2\n\n          return screenshots.capture(this.appData, this.automate)\n        }).then(() => {\n          this.appData.current = 3\n\n          return screenshots.capture(this.appData, this.automate)\n        }).then(() => {\n          const { composite } = Jimp.prototype\n\n          expect(composite).to.be.calledThrice\n          expect(composite.getCall(0).args[0]).to.equal(this.jimpImage)\n          expect(composite.getCall(0).args[1]).to.equal(0)\n          expect(composite.getCall(0).args[2]).to.equal(0)\n          expect(composite.getCall(1).args[0]).to.equal(this.jimpImage)\n          expect(composite.getCall(1).args[2]).to.equal(40)\n          expect(composite.getCall(2).args[0]).to.equal(this.jimpImage)\n\n          expect(composite.getCall(2).args[2]).to.equal(80)\n        })\n      })\n\n      it('clears previous full page state once complete', function () {\n        this.getPixelColor.withArgs(0, 0).returns('white')\n\n        Jimp.read.onSecondCall().resolves(this.jimpImage2)\n        Jimp.read.onThirdCall().resolves(this.jimpImage3)\n        Jimp.read.onCall(3).resolves(this.jimpImage4)\n\n        this.appData.total = 2\n\n        return screenshots.capture(this.appData, this.automate)\n        .then(() => {\n          this.appData.current = 2\n\n          return screenshots.capture(this.appData, this.automate)\n        }).then(() => {\n          this.appData.current = 1\n\n          return screenshots.capture(this.appData, this.automate)\n        }).then(() => {\n          this.appData.current = 2\n\n          return screenshots.capture(this.appData, this.automate)\n        }).then(() => {\n          expect(Jimp.prototype.composite.callCount).to.equal(4)\n        })\n      })\n\n      it('skips full page process if only one capture needed', function () {\n        this.appData.total = 1\n\n        return screenshots.capture(this.appData, this.automate)\n        .then(() => {\n          expect(Jimp.prototype.composite).not.to.be.called\n        })\n      })\n    })\n\n    describe('integration', () => {\n      beforeEach(function () {\n        screenshots.clearMultipartState()\n\n        this.currentTest.timeout(10000)\n\n        sinon.restore()\n\n        this.data1 = {\n          titles: ['cy.screenshot() - take a screenshot'],\n          testId: 'r2',\n          name: 'app-screenshot',\n          capture: 'fullPage',\n          clip: { x: 0, y: 0, width: 1000, height: 646 },\n          viewport: { width: 1280, height: 646 },\n          current: 1,\n          total: 3,\n        }\n\n        this.data2 = {\n          titles: ['cy.screenshot() - take a screenshot'],\n          testId: 'r2',\n          name: 'app-screenshot',\n          capture: 'fullPage',\n          clip: { x: 0, y: 0, width: 1000, height: 646 },\n          viewport: { width: 1280, height: 646 },\n          current: 2,\n          total: 3,\n        }\n\n        this.data3 = {\n          titles: ['cy.screenshot() - take a screenshot'],\n          testId: 'r2',\n          name: 'app-screenshot',\n          capture: 'fullPage',\n          clip: { x: 0, y: 138, width: 1000, height: 508 },\n          viewport: { width: 1280, height: 646 },\n          current: 3,\n          total: 3,\n        }\n\n        this.dataUri = (img) => {\n          return () => {\n            return fs.readFileAsync(Fixtures.path(`img/${img}`))\n            .then((buf) => {\n              return `data:image/png;base64,${buf.toString('base64')}`\n            })\n          }\n        }\n      })\n\n      it('stiches together 1x DPI images', function () {\n        return screenshots\n        .capture(this.data1, this.dataUri('DPI-1x/1.png'))\n        .then((img1) => {\n          expect(img1).to.be.null\n\n          return screenshots\n          .capture(this.data2, this.dataUri('DPI-1x/2.png'))\n        }).then((img2) => {\n          expect(img2).to.be.null\n\n          return screenshots\n          .capture(this.data3, this.dataUri('DPI-1x/3.png'))\n        }).then((img3) => {\n          return Jimp.read(Fixtures.path('img/DPI-1x/stitched.png'))\n          .then((img) => {\n            expect(screenshots.imagesMatch(img, img3.image))\n          })\n        })\n      })\n\n      it('stiches together 2x DPI images', function () {\n        return screenshots\n        .capture(this.data1, this.dataUri('DPI-2x/1.png'))\n        .then((img1) => {\n          expect(img1).to.be.null\n\n          return screenshots\n          .capture(this.data2, this.dataUri('DPI-2x/2.png'))\n        }).then((img2) => {\n          expect(img2).to.be.null\n\n          return screenshots\n          .capture(this.data3, this.dataUri('DPI-2x/3.png'))\n        }).then((img3) => {\n          return Jimp.read(Fixtures.path('img/DPI-2x/stitched.png'))\n          .then((img) => {\n            expect(screenshots.imagesMatch(img, img3.image))\n          })\n        })\n      })\n    })\n  })\n\n  context('.crop', () => {\n    beforeEach(function () {\n      this.dimensions = (overrides) => {\n        return _.extend({ x: 0, y: 0, width: 10, height: 10 }, overrides)\n      }\n    })\n\n    it('crops to dimension size if less than the image size', function () {\n      screenshots.crop(this.jimpImage, this.dimensions())\n\n      expect(this.jimpImage.crop).to.be.calledWith(0, 0, 10, 10)\n    })\n\n    it('crops to dimension size if less than the image size', function () {\n      screenshots.crop(this.jimpImage, this.dimensions())\n\n      expect(this.jimpImage.crop).to.be.calledWith(0, 0, 10, 10)\n    })\n\n    it('crops to one less than width if dimensions x is more than the image width', function () {\n      screenshots.crop(this.jimpImage, this.dimensions({ x: 50 }))\n\n      expect(this.jimpImage.crop).to.be.calledWith(39, 0, 1, 10)\n    })\n\n    it('crops to one less than height if dimensions y is more than the image height', function () {\n      screenshots.crop(this.jimpImage, this.dimensions({ y: 50 }))\n\n      expect(this.jimpImage.crop).to.be.calledWith(0, 39, 10, 1)\n    })\n\n    it('crops only width if dimensions height is more than the image height', function () {\n      screenshots.crop(this.jimpImage, this.dimensions({ height: 50 }))\n\n      expect(this.jimpImage.crop).to.be.calledWith(0, 0, 10, 40)\n    })\n\n    it('crops only height if dimensions width is more than the image width', function () {\n      screenshots.crop(this.jimpImage, this.dimensions({ width: 50 }))\n\n      expect(this.jimpImage.crop).to.be.calledWith(0, 0, 40, 10)\n    })\n  })\n\n  context('.save', () => {\n    it('outputs file and returns details', function () {\n      const buf = dataUriToBuffer(image)\n\n      return Jimp.read(buf)\n      .then((i) => {\n        const details = {\n          image: i,\n          multipart: false,\n          pixelRatio: 2,\n          takenAt: '1234-date',\n        }\n\n        const dimensions = sizeOf(buf)\n\n        return screenshots.save(\n          { name: 'foo bar\\\\baz/my-screenshot', specName: 'foo.spec.js', testFailure: false },\n          details,\n          this.config.screenshotsFolder,\n        )\n        .then((result) => {\n          const expectedPath = path.join(\n            this.config.screenshotsFolder, 'foo.spec.js', 'foo bar', 'baz', 'my-screenshot.png',\n          )\n\n          const actualPath = path.normalize(result.path)\n\n          expect(result).to.deep.eq({\n            multipart: false,\n            pixelRatio: 2,\n            path: path.normalize(result.path),\n            size: 272,\n            name: 'foo bar\\\\baz/my-screenshot',\n            specName: 'foo.spec.js',\n            testFailure: false,\n            takenAt: '1234-date',\n            dimensions: _.pick(dimensions, 'width', 'height'),\n          })\n\n          expect(expectedPath).to.eq(actualPath)\n\n          return fs.statAsync(expectedPath)\n        })\n      })\n    })\n\n    it('can handle saving buffer', function () {\n      const details = {\n        multipart: false,\n        pixelRatio: 1,\n        buffer: dataUriToBuffer(image),\n        takenAt: '1234-date',\n      }\n\n      const dimensions = sizeOf(details.buffer)\n\n      return screenshots.save(\n        { name: 'with-buffer', specName: 'foo.spec.js', testFailure: false },\n        details,\n        this.config.screenshotsFolder,\n      )\n      .then((result) => {\n        const expectedPath = path.join(\n          this.config.screenshotsFolder, 'foo.spec.js', 'with-buffer.png',\n        )\n\n        const actualPath = path.normalize(result.path)\n\n        expect(result).to.deep.eq({\n          name: 'with-buffer',\n          multipart: false,\n          pixelRatio: 1,\n          path: path.normalize(result.path),\n          size: 279,\n          specName: 'foo.spec.js',\n          testFailure: false,\n          takenAt: '1234-date',\n          dimensions: _.pick(dimensions, 'width', 'height'),\n        })\n\n        expect(expectedPath).to.eq(actualPath)\n\n        return fs.statAsync(expectedPath)\n      })\n    })\n  })\n\n  context('.copy', () => {\n    it('doesnt yell over ENOENT errors', () => {\n      return screenshots.copy('/does/not/exist', '/foo/bar/baz')\n    })\n\n    it('copies src to des with {overwrite: true}', () => {\n      sinon.stub(fs, 'copyAsync').withArgs('foo', 'bar', { overwrite: true }).resolves()\n\n      return screenshots.copy('foo', 'bar')\n    })\n  })\n\n  context('.getPath', () => {\n    beforeEach(() => {\n      sinon.stub(fs, 'outputFileAsync').resolves()\n    })\n\n    it('concats spec name, screenshotsFolder, and name', () => {\n      return screenshots.getPath({\n        specName: 'examples/user/list.js',\n        titles: ['bar', 'baz'],\n        name: 'quux/lorem',\n      }, 'png', 'path/to/screenshots')\n      .then((p) => {\n        expect(p).to.eq(\n          'path/to/screenshots/examples/user/list.js/quux/lorem.png',\n        )\n      })\n    })\n\n    it('concats spec name, screenshotsFolder, and titles', () => {\n      return screenshots.getPath({\n        specName: 'examples/user/list.js',\n        titles: ['bar', 'baz'],\n        takenPaths: ['a'],\n        testFailure: true,\n      }, 'png', 'path/to/screenshots')\n      .then((p) => {\n        expect(p).to.eq(\n          'path/to/screenshots/examples/user/list.js/bar -- baz (failed).png',\n        )\n      })\n    })\n\n    it('sanitizes file paths', () => {\n      return screenshots.getPath({\n        specName: 'examples$/user/list.js',\n        titles: ['bar*', 'baz..', '語言'],\n        takenPaths: ['a'],\n        testFailure: true,\n      }, 'png', 'path/to/screenshots')\n      .then((p) => {\n        expect(p).to.eq(\n          'path/to/screenshots/examples$/user/list.js/bar -- baz -- 語言 (failed).png',\n        )\n      })\n    })\n\n    // @see https://github.com/cypress-io/cypress/issues/2403\n    it('truncates long paths with unicode in them', async () => {\n      const fullPath = await screenshots.getPath({\n        titles: [\n          'WMED: [STORY] Тестовые сценарии для CI',\n          'Сценарии:',\n          'Сценарий 2: Создание обращения, создание медзаписи, привязкапривязка обращения к медзаписи',\n          '- Сценарий 2',\n        ],\n        testFailure: true,\n        specName: 'WMED_UAT_Scenarios_For_CI_spec.js',\n      }, 'png', '/jenkins-slave/workspace/test-wmed/qa/cypress/wmed_ci/cypress/screenshots/')\n\n      const basename = path.basename(fullPath)\n\n      expect(Buffer.from(basename).byteLength).to.be.lessThan(255)\n    })\n\n    it('reacts to ENAMETOOLONG errors and tries to shorten the filename', async () => {\n      const err = new Error('enametoolong')\n\n      err.code = 'ENAMETOOLONG'\n\n      _.times(50, (i) => fs.outputFileAsync.onCall(i).rejects(err))\n\n      const fullPath = await screenshots.getPath({\n        specName: 'foo.js',\n        name: 'a'.repeat(256),\n      }, 'png', '/tmp')\n\n      expect(path.basename(fullPath)).to.have.length(204)\n    })\n\n    it('rejects with ENAMETOOLONG errors if name goes below MIN_PREFIX_LENGTH', async () => {\n      const err = new Error('enametoolong')\n\n      err.code = 'ENAMETOOLONG'\n\n      _.times(150, (i) => fs.outputFileAsync.onCall(i).rejects(err))\n\n      await expect(screenshots.getPath({\n        specName: 'foo.js',\n        name: 'a'.repeat(256),\n      }, 'png', '/tmp')).to.be.rejectedWith(err)\n    })\n\n    _.each([Infinity, 0 / 0, [], {}, 1, false], (value) => {\n      it(`doesn't err and stringifies non-string test title: ${value}`, () => {\n        return screenshots.getPath({\n          specName: 'examples$/user/list.js',\n          titles: ['bar*', '語言', value],\n          takenPaths: ['a'],\n          testFailure: true,\n        }, 'png', 'path/to/screenshots')\n        .then((p) => {\n          expect(p).to.eq(`path/to/screenshots/examples$/user/list.js/bar -- 語言 -- ${value} (failed).png`)\n        })\n      })\n    })\n\n    _.each([null, undefined], (value) => {\n      it(`doesn't err and removes null/undefined test title: ${value}`, () => {\n        return screenshots.getPath({\n          specName: 'examples$/user/list.js',\n          titles: ['bar*', '語言', value],\n          takenPaths: ['a'],\n          testFailure: true,\n        }, 'png', 'path/to/screenshots')\n        .then((p) => {\n          expect(p).to.eq('path/to/screenshots/examples$/user/list.js/bar -- 語言 --  (failed).png')\n        })\n      })\n    })\n  })\n\n  context('.afterScreenshot', () => {\n    beforeEach(function () {\n      this.data = {\n        titles: ['the', 'title'],\n        testId: 'r1',\n        name: 'my-screenshot',\n        capture: 'runner',\n        clip: { x: 0, y: 0, width: 1000, height: 660 },\n        viewport: { width: 1400, height: 700 },\n        scaled: true,\n        blackout: [],\n        startTime: '2018-06-27T20:17:19.537Z',\n        specName: 'integration/spec.coffee',\n      }\n\n      this.details = {\n        size: 100,\n        takenAt: new Date().toISOString(),\n        dimensions: { width: 1000, height: 660 },\n        multipart: false,\n        pixelRatio: 1,\n        name: 'my-screenshot',\n        specName: 'integration/spec.coffee',\n        testFailure: true,\n        path: '/path/to/my-screenshot.png',\n      }\n\n      sinon.stub(plugins, 'has')\n\n      return sinon.stub(plugins, 'execute')\n    })\n\n    it('resolves allowed details if no after:screenshot plugin registered', function () {\n      plugins.has.returns(false)\n\n      return screenshots.afterScreenshot(this.data, this.details).then((result) => {\n        expect(_.omit(result, 'duration')).to.eql({\n          size: 100,\n          takenAt: this.details.takenAt,\n          dimensions: this.details.dimensions,\n          multipart: false,\n          pixelRatio: 1,\n          name: 'my-screenshot',\n          specName: 'integration/spec.coffee',\n          testFailure: true,\n          path: '/path/to/my-screenshot.png',\n          scaled: true,\n          blackout: [],\n        })\n\n        expect(result.duration).to.be.a('number')\n      })\n    })\n\n    it('executes after:screenshot plugin and merges in size, dimensions, and/or path', function () {\n      plugins.has.returns(true)\n      plugins.execute.resolves({\n        size: 200,\n        dimensions: { width: 2000, height: 1320 },\n        path: '/new/path/to/screenshot.png',\n        pixelRatio: 2,\n        takenAt: '1234',\n      })\n\n      return screenshots.afterScreenshot(this.data, this.details).then((result) => {\n        expect(_.omit(result, 'duration')).to.eql({\n          size: 200,\n          takenAt: this.details.takenAt,\n          dimensions: { width: 2000, height: 1320 },\n          multipart: false,\n          pixelRatio: 1,\n          name: 'my-screenshot',\n          specName: 'integration/spec.coffee',\n          testFailure: true,\n          path: '/new/path/to/screenshot.png',\n          scaled: true,\n          blackout: [],\n        })\n\n        expect(result.duration).to.be.a('number')\n      })\n    })\n\n    it('ignores updates that are not an object', function () {\n      plugins.execute.resolves('foo')\n\n      return screenshots.afterScreenshot(this.data, this.details).then((result) => {\n        expect(_.omit(result, 'duration')).to.eql({\n          size: 100,\n          takenAt: this.details.takenAt,\n          dimensions: this.details.dimensions,\n          multipart: false,\n          pixelRatio: 1,\n          name: 'my-screenshot',\n          specName: 'integration/spec.coffee',\n          testFailure: true,\n          path: '/path/to/my-screenshot.png',\n          scaled: true,\n          blackout: [],\n        })\n\n        expect(result.duration).to.be.a('number')\n      })\n    })\n  })\n})\n\ndescribe('lib/automation/screenshot', () => {\n  beforeEach(function () {\n    this.details = {}\n    sinon.stub(screenshots, 'capture').resolves(this.details)\n    this.savedDetails = {}\n    sinon.stub(screenshots, 'save').resolves(this.savedDetails)\n    this.updatedDetails = {}\n    sinon.stub(screenshots, 'afterScreenshot').resolves(this.updatedDetails)\n\n    this.screenshot = Screenshot('cypress/screenshots')\n  })\n\n  it('captures screenshot', function () {\n    const data = {}\n    const automation = function () {}\n\n    return this.screenshot.capture(data, automation).then(() => {\n      expect(screenshots.capture).to.be.calledWith(data, automation)\n    })\n  })\n\n  it('saves screenshot if there\\'s a buffer', function () {\n    const data = {}\n\n    return this.screenshot.capture(data, this.automate).then(() => {\n      expect(screenshots.save).to.be.calledWith(data, this.details, 'cypress/screenshots')\n    })\n  })\n\n  it('does not save screenshot if there\\'s no buffer', function () {\n    screenshots.capture.resolves(null)\n\n    return this.screenshot.capture({}, this.automate).then(() => {\n      expect(screenshots.save).not.to.be.called\n    })\n  })\n\n  it('calls afterScreenshot', function () {\n    const data = {}\n\n    return this.screenshot.capture(data, this.automate).then(() => {\n      expect(screenshots.afterScreenshot).to.be.calledWith(data, this.savedDetails)\n    })\n  })\n\n  it('resolves with updated details', function () {\n    return this.screenshot.capture({}, this.automate).then((details) => {\n      expect(details).to.equal(this.updatedDetails)\n    })\n  })\n})\n",
    "packages/server/test/unit/updater_spec.js": "require('../spec_helper')\n\nconst os = require('os')\nconst rp = require('@cypress/request-promise')\nconst pkg = require('@packages/root')\nconst machineId = require(`${root}lib/util/machine_id`)\nconst Updater = require(`${root}lib/updater`)\n\ndescribe('lib/updater', () => {\n  context('._getManifest', () => {\n    const BASE_URL = 'https://download.cypress.io'\n\n    beforeEach(function () {\n      nock.cleanAll()\n\n      nock.enableNetConnect()\n    })\n\n    it('sends the right headers', () => {\n      sinon.stub(os, 'platform').returns('win32')\n      sinon.stub(os, 'arch').returns('x32')\n\n      nock(BASE_URL)\n      .matchHeader('x-cypress-version', pkg.version)\n      .matchHeader('x-os-name', 'win32')\n      .matchHeader('x-arch', 'x32')\n      .matchHeader('x-machine-id', 'machine-id')\n      .matchHeader('x-initial-launch', 'true')\n      .matchHeader('x-testing-type', 'type')\n      .get('/desktop.json')\n      .reply(200, {\n        version: '1000.0.0',\n      })\n\n      return Updater\n      ._getManifest({ testingType: 'type', initialLaunch: true, id: 'machine-id' })\n      .then((resp) => {\n        expect(resp.version).to.eq('1000.0.0')\n      })\n    })\n  })\n\n  context('.check', () => {\n    const version = pkg.version\n\n    beforeEach(() => {\n      pkg.version = '5.0.0'\n      sinon.stub(machineId, 'machineId').resolves('machine-id')\n    })\n\n    afterEach(() => {\n      pkg.version = version\n    })\n\n    it('calls onNewVersion when local version is lower than manifest\\'s version', async () => {\n      sinon.stub(rp, 'get').resolves({ version: '5.1.0' })\n      const onNewVersion = sinon.spy()\n\n      await Updater.check({ onNewVersion })\n\n      expect(onNewVersion).to.be.calledWithMatch({ version: '5.1.0' })\n    })\n\n    it('calls onNoNewVersion when local version is same as the manifest\\'s version', async () => {\n      sinon.stub(rp, 'get').resolves({ version: '5.0.0' })\n      const onNoNewVersion = sinon.spy()\n\n      await Updater.check({ onNoNewVersion })\n\n      expect(onNoNewVersion).to.be.calledWithMatch()\n    })\n\n    it('calls onNoNewVersion when manifest is invalid', async () => {\n      sinon.stub(rp, 'get').resolves({})\n      const onNoNewVersion = sinon.spy()\n\n      await Updater.check({ onNoNewVersion })\n\n      expect(onNoNewVersion).to.be.calledWithMatch()\n    })\n\n    it('calls onNoNewVersion when fetching the manifest throws an error', async () => {\n      sinon.stub(rp, 'get').rejects(new Error())\n      const onNoNewVersion = sinon.spy()\n\n      await Updater.check({ onNoNewVersion })\n\n      expect(onNoNewVersion).to.be.calledWithMatch()\n    })\n  })\n})\n",
    "packages/server-ct/crossword-example/unit/App.spec.js": "/* global jest */\nimport { mount } from '@vue/test-utils'\nimport App from '@/App'\nimport { crossword } from '../cypress/fixtures/crosswords'\nimport { fillCrossword, getCrossword } from './jestHelpers'\n\nglobal.fetch = jest.fn(() => {\n  return Promise.resolve({\n    json: () => Promise.resolve({}),\n  })\n})\n\nfetch.mockImplementationOnce(() => {\n  return Promise.resolve({\n    json: () => Promise.resolve(crossword),\n  })\n})\n\nbeforeEach(() => {\n  fetch.mockClear()\n})\n\ndescribe('App', () => {\n  let wrapper\n\n  beforeEach(async () => {\n    fetch.mockImplementationOnce(() => {\n      return Promise.resolve({\n        json: () => Promise.resolve(crossword),\n      })\n    })\n\n    wrapper = mount(App)\n    await wrapper.vm.$nextTick()\n  })\n\n  it('renders the crossword puzzle on load', function () {\n    const crossword = wrapper.find('[data-testid=crossword]')\n\n    expect(crossword.exists()).toBeTruthy()\n  })\n\n  it('lets you navigate to previous days', async () => {\n    const title = wrapper.find('[data-testid=crossword-title]')\n    const oldTitle = title.text()\n\n    wrapper.find('[data-testid=prev]').trigger('click')\n    await wrapper.vm.$nextTick()\n\n    const newTitle = wrapper.find('[data-testid=crossword-title]').text()\n\n    expect(newTitle).not.toEqual(oldTitle)\n\n    wrapper.find('[data-testid=next]').trigger('click')\n    await wrapper.vm.$nextTick()\n\n    const backToTheOldTitle = wrapper.find('[data-testid=crossword-title]').text()\n\n    expect(backToTheOldTitle).toEqual(oldTitle)\n  })\n\n  it('rerenders the crossword when you go to another day', async () => {\n    const crosswordWrapper = wrapper.find('[data-testid=crossword]')\n\n    fillCrossword(crosswordWrapper.findAll('input').wrappers, { partially: true, crossword })\n\n    await wrapper.vm.$nextTick()\n\n    wrapper.find('[data-testid=prev]').trigger('click')\n    await wrapper.vm.$nextTick()\n\n    expect(getCrossword(wrapper.findAll('[data-testid=crossword] input'))).toEqual('')\n\n    wrapper.find('[data-testid=next]').trigger('click')\n    await wrapper.vm.$nextTick()\n\n    expect(getCrossword(wrapper.findAll('[data-testid=crossword] input'))).toEqual('')\n  })\n\n  it('resets the crossword correctly after you fill it in', async () => {\n    const crosswordWrapper = wrapper.find('[data-testid=crossword]')\n\n    fillCrossword(crosswordWrapper.findAll('input').wrappers, { crossword, partially: true })\n\n    await wrapper.vm.$nextTick()\n\n    const oldTitle = wrapper.find('[data-testid=crossword-title]').text()\n    const oldCrossword = getCrossword(wrapper.findAll('[data-testid=crossword] input'))\n\n    wrapper.find('[data-testid=reset]').trigger('click')\n    await wrapper.vm.$nextTick()\n\n    expect(wrapper.find('[data-testid=crossword]').text()).not.toEqual(oldCrossword)\n    expect(wrapper.find('[data-testid=crossword-title]').text()).toEqual(oldTitle)\n  })\n})\n",
    "packages/server-ct/crossword-example/unit/CrosswordBoard.spec.js": "import { mount } from '@vue/test-utils'\nimport CrosswordBoard from '@/components/CrosswordBoard'\nimport {\n  helloWorld as crossword,\n  crossword as bigCrossword } from '../cypress/fixtures/crosswords'\n\ndescribe('Crossword', () => {\n  it('requires a crossword', () => {\n    expect(() => mount(CrosswordBoard)).toThrow()\n  })\n\n  describe('successfully renders', () => {\n    let wrapper\n\n    beforeEach(async () => {\n      wrapper = mount(CrosswordBoard, {\n        propsData: {\n          crossword,\n          solved: true,\n        },\n      })\n\n      await wrapper.vm.$nextTick()\n    })\n\n    it('renders props.msg when passed', async () => {\n      expect(wrapper.exists()).toBeTruthy()\n    })\n\n    it('has a crossword puzzle', async () => {\n      expect(wrapper.props('crossword')).toBeTruthy()\n      expect(typeof wrapper.props('crossword')).toEqual('object')\n    })\n\n    it('renders the crossword puzzle successfully', () => {\n      const cells = wrapper.findAll('[data-testid=crossword] [data-testid=cell]')\n\n      expect(cells).toHaveLength(crossword.grid.length)\n    })\n\n    it('doesnt contain any placeholder dots', () => {\n      const board = wrapper.find('[data-testid=crossword]')\n\n      expect(board.text()).not.toContain('.')\n    })\n\n    it('numbers the crossword puzzle correctly', () => {\n      const cells = wrapper.findAll('[data-testid=crossword] [data-testid=cell]')\n\n      cells.wrappers.forEach((c, idx) => {\n        if (crossword.gridnums[idx] > 0) {\n          expect(c.text()).toContain(crossword.gridnums[idx])\n        } else {\n          expect(c.text()).not.toContain(0)\n        }\n      })\n    })\n\n    it('renders the correct number of rows and columns', () => {\n      const rowsWrapper = wrapper.findAll('[data-testid=crossword] [data-testid=row]')\n\n      expect(rowsWrapper.wrappers).toHaveLength(crossword.size.rows)\n      const input = wrapper.find('[data-testid=crossword] [data-testid=row] input')\n\n      expect(input.element.value).toEqual(crossword.grid[0])\n    })\n  })\n\n  describe('larger board', () => {\n    describe('solved', () => {\n      it('renders successfully', async () => {\n        const wrapper = await mount(CrosswordBoard, {\n          propsData: { crossword: bigCrossword, solved: true },\n        })\n\n        await wrapper.vm.$nextTick()\n\n        expect(wrapper.exists()).toBeTruthy()\n      })\n    })\n\n    describe('unsolved', () => {\n      it('renders successfully', async () => {\n        const wrapper = mount(CrosswordBoard, {\n          propsData: { crossword: bigCrossword, solved: false },\n        })\n\n        await wrapper.vm.$nextTick()\n\n        expect(wrapper.exists()).toBeTruthy()\n      })\n    })\n  })\n})\n",
    "packages/server-ct/src/specs-store.ts": "import Bluebird from 'bluebird'\nimport chokidar, { FSWatcher } from 'chokidar'\nimport _ from 'lodash'\nimport { findSpecsOfType } from '@packages/server/lib/util/specs'\n\ntype SpecFile = Cypress.Cypress['spec']\ntype SpecFiles = SpecFile[]\n\ninterface SpecsWatcherOptions {\n  onSpecsChanged: (specFiles: SpecFiles) => void\n}\n\nconst COMMON_SEARCH_OPTIONS = ['fixturesFolder', 'supportFile', 'projectRoot', 'javascripts', 'testFiles', 'ignoreTestFiles']\n\n// TODO: shouldn't this be on the trailing edge, not leading?\nconst debounce = (fn) => _.debounce(fn, 250, { leading: true })\n\nexport class SpecsStore {\n  watcher: FSWatcher | null = null\n  specFiles: SpecFiles = []\n\n  constructor (private cypressConfig) {\n\n  }\n\n  get specDirectory () {\n    return this.cypressConfig.resolved.componentFolder.value\n  }\n\n  get testFiles () {\n    return this.cypressConfig.resolved.testFiles.value\n  }\n\n  get watchOptions (): chokidar.WatchOptions {\n    return {\n      cwd: this.specDirectory,\n      ignored: this.cypressConfig.ignoreTestFiles,\n      ignoreInitial: true,\n    }\n  }\n\n  storeSpecFiles (): Bluebird<void> {\n    return this.getSpecFiles()\n    .then((specFiles) => {\n      this.specFiles = specFiles\n    })\n  }\n\n  getSpecFiles (): Bluebird<SpecFiles> {\n    const searchOptions = _.pick(this.cypressConfig, COMMON_SEARCH_OPTIONS)\n\n    searchOptions.searchFolder = this.specDirectory\n    searchOptions.testFiles = this.testFiles\n\n    return findSpecsOfType(searchOptions)\n  }\n\n  watch (options?: SpecsWatcherOptions) {\n    this.watcher = chokidar.watch(this.cypressConfig.testFiles, this.watchOptions)\n\n    if (options?.onSpecsChanged) {\n      const onSpecsChanged = debounce(async () => {\n        const newSpecs = await this.getSpecFiles()\n\n        if (_.isEqual(newSpecs, this.specFiles)) return\n\n        this.specFiles = newSpecs\n\n        options.onSpecsChanged(newSpecs)\n      })\n\n      this.watcher.on('add', onSpecsChanged)\n      this.watcher.on('unlink', onSpecsChanged)\n    }\n  }\n\n  reset (): void {\n    this.watcher?.removeAllListeners()\n  }\n}\n",
    "scripts/after-pack-hook.js": "/* eslint-disable no-console */\nconst fs = require('fs-extra')\nconst { join } = require('path')\nconst globby = require('globby')\nconst os = require('os')\n\nmodule.exports = async function (params) {\n  console.log('****************************')\n  console.log('After pack hook')\n  console.log(params.appOutDir)\n  console.log(params.outDir)\n  console.log(params.electronPlatformName)\n  console.log('****************************')\n\n  const packages = await globby('packages/*/node_modules', {\n    cwd: params.packager.info._appDir,\n    onlyFiles: false,\n  })\n\n  const buildSubfoldersPerPlatform = {\n    darwin: join('Cypress.app', 'Contents', 'Resources', 'app'),\n    linux: join('resources', 'app'),\n    win32: join('resources', 'app'), // TODO check this path\n  }\n  const buildSubfolder = buildSubfoldersPerPlatform[os.platform()]\n  const outputFolder = join(params.appOutDir, buildSubfolder)\n\n  console.log('copying node_modules to', outputFolder)\n\n  for await (const packageNodeModules of packages) {\n    console.log('copying', packageNodeModules)\n\n    const sourceFolder = join(params.packager.info._appDir, packageNodeModules)\n    const destinationFolder = join(outputFolder, packageNodeModules)\n\n    await fs.copy(sourceFolder, destinationFolder)\n  }\n\n  console.log('all node_modules subfolders copied to', outputFolder)\n}\n",
    "scripts/after-sign-hook.js": "// from https://medium.com/@TwitterArchiveEraser/notarize-electron-apps-7a5f988406db\n// to enable running this hook, set in \"electron-builder.json\" the option\n// \"afterSign\": \"./scripts/after-sign-hook.js\"\nconst fs = require('fs')\nconst path = require('path')\nlet electron_notarize = require('electron-notarize')\n\n/* eslint-disable no-console */\n\nmodule.exports = async function (params) {\n  // Only notarize the app on Mac OS only.\n  if (process.platform !== 'darwin') {\n    console.log('not Mac, skipping after sign hook')\n\n    return\n  }\n\n  console.log('afterSign hook triggered in', params.appOutDir)\n\n  // Same appId in electron-builder.\n  let appId = 'com.electron.cypress'\n\n  let appPath = path.join(params.appOutDir, `${params.packager.appInfo.productFilename}.app`)\n\n  if (!fs.existsSync(appPath)) {\n    throw new Error(`Cannot find application at: ${appPath}`)\n  }\n\n  console.log(`Notarizing ${appId} found at ${appPath}`)\n\n  if (!process.env.NOTARIZE_APP_APPLE_ID) {\n    throw new Error('Missing Apple id for notarization: NOTARIZE_APP_APPLE_ID')\n  }\n\n  if (!process.env.NOTARIZE_APP_PASSWORD) {\n    throw new Error('Missing Apple password for notarization: NOTARIZE_APP_PASSWORD')\n  }\n\n  try {\n    await electron_notarize.notarize({\n      appBundleId: appId,\n      appPath,\n      appleId: process.env.NOTARIZE_APP_APPLE_ID,\n      appleIdPassword: process.env.NOTARIZE_APP_PASSWORD,\n    })\n  } catch (error) {\n    console.error('could not notarize application')\n    console.error(error)\n    throw error\n  }\n\n  console.log(`Done notarizing ${appId}`)\n}\n",
    "scripts/binary/util/testStaticAssets.js": "/* eslint-disable arrow-body-style */\n\nconst la = require('lazy-ass')\nconst fs = require('fs-extra')\nconst _ = require('lodash')\nconst glob = require('glob')\nconst chalk = require('chalk').default\nconst Promise = require('bluebird')\nconst { stripIndent } = require('common-tags')\n\nconst globAsync = Promise.promisify(glob)\n\nconst testStaticAssets = async (buildResourcePath) => {\n  await Promise.all([\n    testPackageStaticAssets({\n      assetGlob: `${buildResourcePath}/packages/runner/dist/cypress_runner.js`,\n      badStrings: [\n        // should only exist during development\n        'webpack-livereload-plugin',\n        // indicates eval source maps were included, which cause cross-origin errors\n        '//# sourceURL=cypress://',\n        // make sure webpack is not run with NODE_ENV=development\n        'react.development.js',\n      ],\n      goodStrings: [\n        // make sure webpack is run with NODE_ENV=production\n        'react.production.min.js',\n      ],\n      testAssetStrings: [\n        [\n          (str) => !str.split('\\n').slice(-1)[0].includes('//# sourceMappingURL'),\n          'sourcemaps were detected, ensure `web-config/webpack.base.config.ts` does not have sourcemaps enabled in production',\n        ],\n      ],\n      minLineCount: 5000,\n    }),\n    testPackageStaticAssets({\n      assetGlob: `${buildResourcePath}/packages/runner/dist/injection.js`,\n      goodStrings: [\n        'action(\"app:window:before:load\",window)',\n      ],\n    }),\n    testPackageStaticAssets({\n      assetGlob: `${buildResourcePath}/packages/runner/dist/*.css`,\n      goodStrings: [\n        // indicates css autoprefixer is correctly appending vendor prefixes (e.g -moz-touch)\n        ['-ms-', 20],\n      ],\n    }),\n\n    testPackageStaticAssets({\n      assetGlob: `${buildResourcePath}/packages/desktop-gui/dist/index.html`,\n      goodStrings: [\n        // make sure webpack is run with NODE_ENV=production\n        `window.env = 'production'`,\n      ],\n    }),\n    testPackageStaticAssets({\n      assetGlob: `${buildResourcePath}/packages/desktop-gui/dist/app.js`,\n      goodStrings: [\n        // make sure webpack is run with NODE_ENV=production\n        'react.production.min.js',\n      ],\n    }),\n  ])\n}\n\nconst testPackageStaticAssets = async (options = {}) => {\n  la(options.assetGlob, 'missing resourcePath')\n  const opts = _.defaults(options, {\n    assetGlob: '',\n    goodStrings: [],\n    badStrings: [],\n    testAssetStrings: [],\n    minLineCount: 0,\n  })\n\n  const foundAssets = await globAsync(opts.assetGlob)\n  .map(async (path) => {\n    const fileStr = (await fs.readFile(path)).toString()\n\n    opts.goodStrings.forEach((str) => {\n      const [passed, count, atLeast] = includesString(fileStr, str)\n\n      la(passed, stripIndent`\n      Error in ${path}: expected to find at least ${atLeast} strings of ${chalk.bold(str)}\n      contained: ${count}\n    `)\n    })\n\n    opts.badStrings.forEach((str) => {\n      const [passed, count, atLeast] = includesString(fileStr, str)\n\n      la(!passed, stripIndent`\n        Error in ${path}: expected ${chalk.bold('not')} to find more than ${atLeast - 1} strings of ${chalk.bold(str)}\n        contained: ${count}\n      `)\n    })\n\n    opts.testAssetStrings.forEach(([testFn, errorMsg]) => {\n      la(testFn(fileStr), `Error in ${path}: ${errorMsg}`)\n    })\n\n    if (opts.minLineCount) {\n      const lineCount = (fileStr.match(/\\n/g) || '').length + 1\n\n      la(lineCount > opts.minLineCount, stripIndent`\n      Error in ${chalk.red(path)}: Detected this file was minified, having fewer than ${opts.minLineCount} lines of code.\n      Minified code takes longer to inspect in browser Devtools, so we should leave it un-minified.\n      `)\n    }\n\n    return path\n  })\n\n  la(!!foundAssets.length, stripIndent`\n  expected assets to be found in ${chalk.green(opts.assetGlob)}\n  `)\n}\n\nmodule.exports = {\n  testStaticAssets,\n  testPackageStaticAssets,\n}\n\nfunction includesCount (string, subString) {\n  string += ''\n  subString += ''\n  if (subString.length <= 0) return (string.length + 1)\n\n  let n = 0\n  let pos = 0\n  let step = subString.length\n\n  // eslint-disable-next-line\n  while (true) {\n    pos = string.indexOf(subString, pos)\n    if (pos >= 0) {\n      ++n\n      pos += step\n    } else {\n      break\n    }\n  }\n\n  return n\n}\n\nconst includesString = (fileStr, options) => {\n  const opts = _.isArray(options) ? options : [options, 1]\n\n  const [substr, atLeast] = opts\n\n  const count = includesCount(fileStr, substr)\n\n  const passed = count >= atLeast\n\n  return [passed, count, atLeast]\n}\n",
    "scripts/binary/util/transform-requires.js": "const fs = require('fs-extra')\nconst path = require('path')\nconst glob = require('glob')\nconst chalk = require('chalk').default\nconst Promise = require('bluebird')\nconst Debug = require('debug')\n\nconst debug = Debug('cypress:scripts:util:transform-requires')\n\nconst requireRE = /(require\\([\"'`])@packages\\/(.+?)([\\/\"'`])/g\nconst globAsync = Promise.promisify(glob)\n\nconst rewritePackageNames = (fileStr, buildRoot, filePath, onFound) => {\n  // const matches = requireRE.exec(fileStr)\n  return fileStr.replace(requireRE, (...match) => {\n    debug(match.slice(0, -1))\n    const pkg = match[2]\n    const afterPkg = match[3]\n\n    const pkgPath = path.join(buildRoot, `packages/${pkg}`)\n    const replaceWith = path.relative(path.dirname(filePath), pkgPath).replace(/\\\\/g, '/')\n\n    const replaceString = `${match[1]}${replaceWith}${afterPkg}`\n\n    // eslint-disable-next-line no-console\n    console.log()\n    // eslint-disable-next-line no-console\n    console.log('resolve:', chalk.grey(pkgPath), '\\nfrom:', chalk.grey(filePath))\n    // eslint-disable-next-line no-console\n    console.log(chalk.yellow(`@packages/${pkg}`), '->', chalk.green(replaceWith))\n\n    onFound && onFound(replaceString)\n\n    return replaceString\n  })\n}\n\nconst transformRequires = async function (buildResourcePath) {\n  const buildRoot = buildResourcePath\n\n  const globPattern = `${buildRoot}/packages/**/*.js`\n\n  debug({ globPattern })\n\n  let replaceCount = 0\n\n  // Statically transform all requires of @packages/* to direct relative paths\n  // e.g. @packages/server/lib -> ../../../server/lib\n  // This prevents us having to ship symlinks in the final binary, because some OS's (Windows)\n  // do not have relative symlinks/junctions or bad symlink support\n  await globAsync(globPattern, { ignore: ['**/node_modules/**', '**/packages/**/dist/**'] })\n  .map(async (filePath) => {\n    debug('glob found:', filePath)\n    const buff = await fs.readFile(filePath)\n\n    const fileStr = buff.toString()\n\n    let shouldWriteFile = false\n\n    const newFile = rewritePackageNames(fileStr, buildRoot, filePath, (replaceString) => {\n      debug(replaceString)\n\n      replaceCount++\n      shouldWriteFile = true\n    })\n\n    if (shouldWriteFile) {\n      debug('writing to file:', chalk.red(filePath))\n\n      await fs.writeFile(filePath, newFile)\n    }\n  })\n\n  return replaceCount\n}\n\nmodule.exports = {\n  transformRequires,\n\n  rewritePackageNames,\n}\n",
    "scripts/get-next-version.js": "/* eslint-disable no-console */\n\nconst semver = require('semver')\nconst Bluebird = require('bluebird')\nconst bumpCb = require('conventional-recommended-bump')\nconst currentVersion = require('../package.json').version\n\nconst bump = Bluebird.promisify(bumpCb)\nconst paths = ['packages', 'cli']\n\nlet nextVersion\n\nconst getNextVersionForPath = async (path) => {\n  // allow the semantic next version to be overridden by environment\n  if (process.env.NEXT_VERSION) {\n    return process.env.NEXT_VERSION\n  }\n\n  const { releaseType } = await bump({ preset: 'angular', path })\n\n  return semver.inc(currentVersion, releaseType || 'patch')\n}\n\nBluebird.mapSeries(paths, async (path) => {\n  const pathNextVersion = await getNextVersionForPath(path)\n\n  if (!nextVersion || semver.gt(pathNextVersion, nextVersion)) {\n    nextVersion = pathNextVersion\n  }\n})\n.then(() => {\n  if (!nextVersion) {\n    throw new Error('Unable to determine next version.')\n  }\n\n  if (process.argv.includes('--npm')) {\n    const cmd = `npm --no-git-tag-version version ${nextVersion}`\n\n    console.log(`Running '${cmd}'...`)\n\n    return require('child_process').execSync(cmd)\n  }\n\n  console.log(nextVersion)\n})\n",
    "scripts/npm-release.js": "/**\n * To easily test if your release will apply locally, you can run:\n * yarn test-npm-package-release-script\n */\n/* eslint-disable no-console */\nconst execa = require('execa')\nconst fs = require('fs')\nconst path = require('path')\nconst semverSortNewestFirst = require('semver/functions/rcompare')\n\nconst { getCurrentBranch, getPackagePath, readPackageJson, independentTagRegex } = require('./utils')\n\nconst error = (message) => {\n  if (require.main === module) {\n    console.error(`\\nERROR!`)\n    console.error(message)\n\n    process.exit(1)\n  } else {\n    throw new Error(message)\n  }\n}\n\nconst getTags = async () => {\n  const { stdout } = await execa('git', ['tag', '--merged', await getCurrentBranch()])\n\n  return stdout.split('\\n')\n}\n\nconst getBinaryVersion = async () => {\n  const { stdout: root } = await execa('git', ['rev-parse', '--show-toplevel'])\n  const rootPath = path.join(root, 'package.json')\n  const rootPackage = JSON.parse(fs.readFileSync(rootPath))\n\n  return rootPackage.version\n}\n\nconst parseSemanticReleaseOutput = (output) => {\n  const currentVersion = (output.match(/associated with version (\\d+\\.\\d+\\.\\d+-?\\S*)/) || [])[1]\n  const nextVersion = (output.match(/next release version is (\\d+\\.\\d+\\.\\d+-?\\S*)/) || [])[1]\n\n  return {\n    currentVersion,\n    nextVersion,\n  }\n}\n\n// in addition to getting the next version that's going to be released\n// this serves as a good double check that the release will work before we actually do it\nconst getNextVersion = async (name) => {\n  // we cannot use the semantic-release javascript api\n  // since it will break semantic-release-monorepo plugin\n  const { stdout } = await execa('npx', ['lerna', 'exec', '--scope', name, '--', 'npx', '--no-install', 'semantic-release', '--dry-run'])\n\n  return parseSemanticReleaseOutput(stdout).nextVersion\n}\n\n// we manually check the last version on this branch as opposed to what semantic-release says\n// since semantic-release may be not be configured on the current branch for a package\nconst getCurrentVersion = async (name) => {\n  const tags = await getTags()\n\n  const versions = tags\n  .map((tag) => (tag.match(independentTagRegex(name)) || [])[1])\n  .filter((tag) => tag)\n  .sort(semverSortNewestFirst)\n\n  return versions[0]\n}\n\nconst getPackageVersions = async (packages) => {\n  console.log(`Finding package versions...\\n`)\n\n  const binaryVersion = await getBinaryVersion()\n\n  console.log(`Cypress binary: ${binaryVersion}`)\n\n  const versions = {\n    cypress: {\n      currentVersion: binaryVersion,\n      nextVersion: undefined,\n    },\n  }\n\n  for (const name of packages) {\n    console.log(`\\n${name}`)\n\n    const currentVersion = await getCurrentVersion(name)\n    const nextVersion = await getNextVersion(name)\n\n    console.log(`Current version: ${currentVersion || 'N/A'}`)\n    console.log(`Next version: ${nextVersion || 'N/A'}`)\n\n    versions[name] = {\n      currentVersion,\n      nextVersion,\n    }\n  }\n\n  return versions\n}\n\n// updates a public package's package.json\n// replaces any local dependencies that have a * version\n// with the actual numbered version of that dependency\n// if that dependency is also going to be released from this run\n// it updates with the new version\nconst injectVersions = (packagesToRelease, versions, packages) => {\n  console.log('\\nInjecting versions into package.json files...')\n\n  for (const name of packagesToRelease) {\n    console.log(`\\nUpdating package.json of ${name}`)\n\n    const info = packages.find((p) => p.name === name)\n    const packageJson = readPackageJson(info)\n\n    if (packageJson.dependencies) {\n      for (const dependency in packageJson.dependencies) {\n        if (packageJson.dependencies[dependency] === '0.0.0-development' || packageJson.dependencies[dependency] === '*') {\n          const version = versions[dependency].nextVersion || versions[dependency].currentVersion\n\n          if (!version) {\n            return error(`Could not inject a version for ${dependency} since it has no current or next version`)\n          }\n\n          packageJson.dependencies[dependency] = version\n\n          console.log(`\\t${dependency}: ${version}`)\n        }\n      }\n\n      fs.writeFileSync(getPackagePath(info), JSON.stringify(packageJson, null, 2))\n    }\n  }\n}\n\nconst releasePackages = async (packages) => {\n  console.log(`\\nReleasing packages`)\n\n  // it would make sense to run each release simultaneously with something like Promise.all()\n  // however this can cause a race condition within git (git lock throws an error)\n  // so we run them one by one to avoid this\n  for (const name of packages) {\n    console.log(`\\nReleasing ${name}...`)\n    const { stdout } = await execa('npx', ['lerna', 'exec', '--scope', name, '--', 'npx', '--no-install', 'semantic-release'])\n\n    console.log(`Released ${name} successfully:`)\n    console.log(stdout)\n  }\n\n  console.log(`\\nAll packages released successfully`)\n}\n\nconst getLernaPackages = async () => {\n  const { stdout } = await execa('npx', ['lerna', 'la', '--json'])\n\n  return JSON.parse(stdout)\n}\n\n// goes through the release process for all of our independent npm projects\nconst main = async () => {\n  // in case no NPM_TOKEN is provided (running a simulation locally),\n  // make up a fake one to avoid semantic-release breaking\n  if (!process.env.CIRCLECI && !process.env.NPM_TOKEN) {\n    process.env.NPM_TOKEN = 1\n  }\n\n  const packages = await getLernaPackages()\n  const publicPackages = packages\n  .filter((pkg) => !pkg.private && !pkg.name.includes('@packages'))\n  .map((pkg) => pkg.name)\n\n  console.log(`Found the following public packages: ${publicPackages.join(', ')}\\n`)\n\n  const versions = await getPackageVersions(publicPackages)\n  const packagesToRelease = Object.keys(versions).filter((key) => versions[key].nextVersion)\n\n  console.log(`\\nFound a new release for the following packages: ${packagesToRelease.join(', ')}`)\n\n  if (!packagesToRelease.length) {\n    return console.log(`\\nThere are no packages to release!`)\n  }\n\n  injectVersions(packagesToRelease, versions, packages)\n\n  if (!process.env.CIRCLECI) {\n    return error(`Cannot run release process outside of Circle CI`)\n  }\n\n  if (process.env.CIRCLE_PULL_REQUEST) {\n    return console.log(`Release process cannot be run on a PR`)\n  }\n\n  await releasePackages(packagesToRelease)\n\n  console.log(`\\n\\nRelease process completed successfully!`)\n}\n\n// execute main function if called from command line\nif (require.main === module) {\n  main()\n}\n\nmodule.exports = {\n  parseSemanticReleaseOutput,\n  readPackageJson,\n}\n",
    "scripts/run-ct-examples.js": "/* eslint-disable no-console */\nconst execa = require('execa')\nconst { chdir } = require('process')\nconst path = require('path')\nconst fs = require('fs')\nconst minimist = require('minimist')\n\nconst args = minimist(process.argv.slice(2))\n\nconst filePath = path.resolve(process.cwd(), args.examplesList)\n\nconst PROJECTS_FOR_CI = fs.readFileSync(filePath, { encoding: 'utf8' })\n.split('\\n')\n.filter((a) => !/^\\#/.test(a))\n\nconst reporterConfig = path.resolve(process.cwd(), '../../mocha-reporter-config.json')\n\nconst testResultsDestination = path.resolve(process.cwd(), 'test_results')\n\nconst runTests = async (dir) => {\n  try {\n    chdir(dir)\n\n    if (dir !== __dirname) {\n      console.log(`Running yarn install in project ${dir}`)\n      await execa('yarn', ['install', '--frozen-lockfile'], { stdout: 'inherit' })\n    }\n\n    console.log(`Running yarn test in project ${dir}`)\n    await execa('yarn', [\n      'test',\n      '--reporter',\n      'mocha-multi-reporters',\n      '--reporter-options',\n      `configFile=${reporterConfig},resultsDir=${testResultsDestination}`,\n    ], { stdout: 'inherit' })\n  } catch (e) {\n    if (e.stdout) {\n      console.error(e.stdout)\n    }\n\n    const exitCode = e.exitCode ? e.exitCode : 1\n\n    console.error(`Tests failed with exit code ${exitCode}`)\n    process.exit(exitCode)\n  }\n}\n\nconst main = async () => {\n  const NODE_INDEX = process.env.CIRCLE_NODE_INDEX || 0\n\n  if (NODE_INDEX > PROJECTS_FOR_CI.length - 1) {\n    return\n  }\n\n  const projectDir = `${process.cwd()}${PROJECTS_FOR_CI[NODE_INDEX]}`\n\n  console.log(`Running tests in ${projectDir}`)\n  await runTests(projectDir)\n}\n\n// execute main function if called from command line\nif (require.main === module) {\n  main()\n}\n",
    "scripts/test-unit.js": "// This file exists because mocha doesn't return non-zero value when there is a failed test.\n// When https://github.com/mochajs/mocha/issues/3893 is fixed, it will be removed.\n\nconst { spawn } = require('child_process')\nconst Promise = require('bluebird')\n\n// Test result on console.\nlet log = ''\nconst proc = spawn(`node`, ['./node_modules/.bin/mocha', 'src/**/*.spec.*'], {})\n\nproc.stdout.on('data', (data) => {\n  log += data\n})\n\nproc.stdout.on('end', async () => {\n  await Promise.delay(500)\n\n  const result = log.match(/\\d+ passing.*\\n\\s*(\\d+) failing/)\n  const numFailing = result && parseInt(result[1], 10)\n\n  if (!isNaN(numFailing)) {\n    process.exit(numFailing)\n  }\n\n  process.exit(0)\n})\n\n// Show result on console.\nspawn(`node`, ['./node_modules/.bin/mocha', '\"src/*.spec.*\" \"src/**/*.spec.*\"'], {\n  stdio: 'inherit',\n  shell: true,\n})\n",
    "scripts/unit/binary/util/packages-spec.js": "/* global sinon */\nconst os = require('os')\nconst _ = require('lodash')\nconst path = require('path')\nconst proxyquire = require('proxyquire')\nconst mockfs = require('mock-fs')\nconst _snapshot = require('snap-shot-it')\nconst chai = require('chai')\nconst debug = require('debug')('test')\n\nchai.use(require('chai-as-promised'))\n\nconst { expect } = chai\n\nconst packages = require('../../../binary/util/packages')\nconst { transformRequires, rewritePackageNames } = require('../../../binary/util/transform-requires')\nconst { testPackageStaticAssets } = require('../../../binary/util/testStaticAssets')\nconst externalUtils = require('../../../binary/util/3rd-party')\n\nglobal.beforeEach(() => {\n  mockfs.restore()\n})\n\nconst snapshot = (...args) => {\n  mockfs.restore()\n\n  return _snapshot(...args)\n}\n\ndescribe('packages', () => {\n  it('can copy files from package.json', async () => {\n    sinon.stub(os, 'tmpdir').returns('/tmp')\n\n    mockfs({\n      'packages': {\n        'coffee': {\n          'package.json': '{\"main\":\"src/main.js\", \"name\": \"foo\", \"files\": [\"lib\"]}',\n          'src': { 'main.js': Buffer.from('console.log()') },\n          'lib': { 'foo.js': '{}' },\n        },\n      },\n    })\n\n    const globbyStub = sinon.stub(externalUtils, 'globby')\n\n    globbyStub\n    .withArgs(['./packages/*', './npm/*'])\n    .resolves(['./packages/coffee'])\n\n    globbyStub\n    .withArgs(['package.json', 'lib', 'src/main.js'])\n    .resolves([\n      'package.json',\n      'lib/foo.js',\n      'src/main.js',\n    ])\n\n    const destinationFolder = os.tmpdir()\n\n    debug('destination folder %s', destinationFolder)\n\n    await packages.copyAllToDist(destinationFolder)\n\n    const files = getFs()\n\n    snapshot(files)\n  })\n})\n\ndescribe('rewritePackageNames', () => {\n  it('renames requires', () => {\n    const fileStr = `\n      const a = require('@packages/server')\n      const b = require('@packages/server-ct')\n      const b = require('@packages/runner-ct/')\n      const c = require(\"@packages/runner-ct/lib/quux.js\")\n    `\n\n    const stub = sinon.stub()\n\n    const newStr = rewritePackageNames(fileStr, '/root/build', '/root/packages/dep/index.js', stub)\n\n    expect(newStr).to.eq(`\n      const a = require('../../build/packages/server')\n      const b = require('../../build/packages/server-ct')\n      const b = require('../../build/packages/runner-ct/')\n      const c = require(\"../../build/packages/runner-ct/lib/quux.js\")\n    `)\n\n    expect(stub.getCall(0).args[0]).to.eq(`require('../../build/packages/server'`)\n    expect(stub.getCall(1).args[0]).to.eq(`require('../../build/packages/server-ct'`)\n    expect(stub.getCall(2).args[0]).to.eq(`require('../../build/packages/runner-ct/`)\n    expect(stub.getCall(3).args[0]).to.eq(`require(\"../../build/packages/runner-ct/`)\n  })\n})\n\ndescribe('transformRequires', () => {\n  it('can find and replace symlink requires', async function () {\n    // these tests really refuse to work on Mac, so for now run it only on Linux\n    if (os.platform() !== 'linux') {\n      return this.skip()\n    }\n\n    const buildRoot = 'build/linux/Cypress/resources/app'\n\n    mockfs({\n      [buildRoot]: { 'packages': {\n        'foo': {\n          'package.json': '{\"main\":\"src/main.js\", \"name\": \"foo\", \"files\": [\"lib\"]}',\n          'src': { 'main.js': Buffer.from('console.log()') },\n          'lib': { 'foo.js': /*js*/`require(\"@packages/bar/src/main\")${''}` },\n        },\n        'bar': {\n          'package.json': '{\"main\":\"src/main.js\", \"name\": \"foo\", \"files\": [\"lib\"]}',\n          'src': { 'main.js': Buffer.from('console.log()') },\n          'lib': { 'foo.js': `require(\"@packages/foo/lib/somefoo\")${''}` },\n          'node_modules': { 'no-search.js': '' },\n          'dist': { 'no-search.js': '' },\n        },\n      },\n      },\n    })\n\n    sinon.stub(externalUtils, 'globby')\n    .withArgs([\n      'build/linux/Cypress/resources/app/packages/**/*.js',\n      'build/linux/Cypress/resources/app/npm/**/*.js',\n    ])\n    .resolves([\n      'build/linux/Cypress/resources/app/packages/foo/src/main.js',\n      'build/linux/Cypress/resources/app/packages/foo/lib/foo.js',\n      'build/linux/Cypress/resources/app/packages/bar/src/main.js',\n      'build/linux/Cypress/resources/app/packages/bar/lib/foo.js',\n    ])\n\n    // should return number of transformed requires\n    await expect(transformRequires(buildRoot)).to.eventually.eq(2)\n\n    const files = getFs()\n\n    if (debug.enabled) {\n      debug('returned file system')\n      /* eslint-disable-next-line no-console */\n      console.error(files)\n    }\n\n    snapshot(files)\n  })\n\n  it('can find and replace symlink requires on win32', async function () {\n    if (os.platform() !== 'linux') {\n      return this.skip()\n    }\n\n    const { transformRequires } = proxyquire('../../../binary/util/transform-requires', { path: path.win32 })\n    const buildRoot = 'build/linux/Cypress/resources/app'\n\n    mockfs({\n      [buildRoot]: { 'packages': {\n        'foo': {\n          'package.json': '{\"main\":\"src/main.js\", \"name\": \"foo\", \"files\": [\"lib\"]}',\n          'src': { 'main.js': Buffer.from('console.log()') },\n          'lib': { 'foo.js': /*js*/`require(\"@packages/bar/src/main\")${''}` },\n        },\n        'bar': {\n          'package.json': '{\"main\":\"src/main.js\", \"name\": \"foo\", \"files\": [\"lib\"]}',\n          'src': { 'main.js': Buffer.from('console.log()') },\n          'lib': { 'foo.js': `require(\"@packages/foo/lib/somefoo\")${''}` },\n          'node_modules': { 'no-search.js': '' },\n          'dist': { 'no-search.js': '' },\n        },\n      },\n      },\n    })\n\n    sinon.stub(externalUtils, 'globby')\n    .withArgs([\n      'build/linux/Cypress/resources/app/packages/**/*.js',\n      'build/linux/Cypress/resources/app/npm/**/*.js',\n    ])\n    .resolves([\n      'build/linux/Cypress/resources/app/packages/foo/src/main.js',\n      'build/linux/Cypress/resources/app/packages/foo/lib/foo.js',\n      'build/linux/Cypress/resources/app/packages/bar/src/main.js',\n      'build/linux/Cypress/resources/app/packages/bar/lib/foo.js',\n    ])\n\n    await transformRequires(buildRoot)\n\n    snapshot(getFs())\n  })\n})\n\ndescribe('testStaticAssets', () => {\n  it('can detect bad strings in asset', async () => {\n    const buildDir = 'resources/app'\n\n    mockfs({\n      [buildDir]: {\n        'packages': {\n          'runner': {\n            'dist': {\n              'runner.js': `\n              some js\n              some really bad string\n              some more js\n              `,\n            },\n          },\n        },\n      },\n    })\n\n    // logFs()\n\n    await expect(testPackageStaticAssets({\n      assetGlob: `${buildDir}/packages/runner/dist/*.js`,\n      badStrings: ['some really bad string'],\n    })).to.rejected.with.eventually.property('message').contain('some really bad string')\n\n    mockfs.restore()\n\n    mockfs({\n      [buildDir]: {\n        'packages': {\n          'runner': {\n            'dist': {},\n          },\n        },\n      },\n    })\n\n    await expect(testPackageStaticAssets({\n      assetGlob: `${buildDir}/packages/runner/dist/*.js`,\n      badStrings: ['some really bad string'],\n    })).to.rejected.with.eventually\n    .property('message').contain('assets to be found')\n  })\n\n  it('can detect asset with too many lines', async () => {\n    const buildDir = 'resources/app'\n\n    mockfs({\n      [buildDir]: {\n        'packages': {\n          'runner': {\n            'dist': {\n              'runner.js': `\n              ${'minified code;minified code;minified code;\\n'.repeat(50)}\n              `,\n            },\n          },\n        },\n      },\n    })\n\n    await expect(testPackageStaticAssets({\n      assetGlob: `${buildDir}/packages/runner/dist/*.js`,\n      minLineCount: 100,\n    })).to.rejected.with.eventually\n    .property('message').contain('minified')\n  })\n\n  it('can detect asset that includes specified number of goodStrings', async () => {\n    const buildDir = 'resources/app'\n\n    mockfs({\n      [buildDir]: {\n        'packages': {\n          'test': {\n            'file.css': `\n              ${'-moz-user-touch: \"none\"\\n'.repeat(5)}\n              `,\n          },\n        },\n      },\n    })\n\n    await expect(testPackageStaticAssets({\n      assetGlob: `${buildDir}/packages/test/file.css`,\n      goodStrings: [['-moz-', 10]],\n    })).to.rejected.with.eventually\n    .property('message').contain('at least 10')\n  })\n\n  it('can have custom testAssetString tests', async () => {\n    const buildDir = 'resources/app'\n\n    mockfs({\n      [buildDir]: {\n        'packages': {\n          'test': {\n            'file.css': `\n              ${'-moz-user-touch: \"none\"\\n'.repeat(5)}\n              foo-bar-baz\\\n              `,\n          },\n        },\n      },\n    })\n\n    await expect(testPackageStaticAssets({\n      assetGlob: `${buildDir}/packages/test/file.css`,\n      testAssetStrings: [\n        [(str) => !str.split('\\n').slice(-1)[0].includes('foo-bar-baz'), 'expected not to end with foo-bar-baz'],\n      ],\n    })).to.rejected.with.eventually\n    .property('message').contain('foo-bar-baz')\n  })\n})\n\n/*\n// Example: Test real assets\n  it('can detect', async () => {\n    const buildDir = process.cwd()\n\n    await expect(testPackageStaticAssets({\n      assetGlob: `${buildDir}/packages/runner/dist/*.css`,\n      goodStrings: [['-ms-', 20]],\n    })).not.be.rejected\n  })\n*/\n\nafterEach(() => {\n  mockfs.restore()\n})\n\n// eslint-disable-next-line\nconst logFs = () => {\n  // eslint-disable-next-line no-console\n  console.dir(getFs(), { depth: null })\n}\n\nconst getFs = () => {\n  const cwd = process.cwd().split(path.sep).slice(1)\n\n  const recurse = (dir, d) => {\n    if (_.isString(dir)) {\n      return dir\n    }\n\n    return _.extend({}, ..._.map(dir, (val, key) => {\n      let nextDepth = null\n\n      if (d !== null) {\n        if (d === -1) {\n          nextDepth = d + 1\n        } else if (!(d > cwd.length) && key === cwd[d]) {\n          key = 'foo'\n          nextDepth = d + 1\n\n          if (d === cwd.length - 1) {\n            return { '[cwd]': recurse(val._items, nextDepth) }\n          }\n\n          return recurse(val._items, nextDepth)\n        } else {\n          nextDepth = null\n        }\n      }\n\n      return {\n        [key]: recurse(val._content ? val._content.toString() : val._items, nextDepth),\n      }\n    }))\n  }\n\n  return recurse({ root: mockfs.getMockRoot() }, -1).root\n}\n",
    "scripts/utils.js": "const minimist = require('minimist')\nconst la = require('lazy-ass')\nconst is = require('check-more-types')\nconst path = require('path')\nconst fs = require('fs')\nconst execa = require('execa')\n\n/* eslint-disable no-console */\n\nfunction getNameAndBinary (args = process.argv) {\n  const options = minimist(args)\n\n  la(is.unemptyString(options.npm), 'missing --npm option', options)\n  la(is.unemptyString(options.binary), 'missing --binary option', options)\n\n  let npm = options.npm\n\n  if (fs.existsSync(options.npm)) {\n    console.log('loading NPM url from', options.npm)\n    npm = require(path.resolve(options.npm)).url\n    la(is.url(npm), 'not an url', npm)\n  } else {\n    console.log('NPM option \"%s\" is not a file', options.npm)\n  }\n\n  let binary = options.binary\n\n  if (fs.existsSync(options.binary)) {\n    console.log('loading binary url from', options.binary)\n    binary = require(path.resolve(options.binary)).url\n    la(is.url(binary), 'not an url', binary)\n  } else {\n    console.log('binary option \"%s\" is not a file', options.binary)\n  }\n\n  return {\n    npm,\n    binary,\n  }\n}\n\nfunction getJustVersion (npmNameOrUrl) {\n  la(is.unemptyString(npmNameOrUrl), 'missing NPM string', npmNameOrUrl)\n\n  if (npmNameOrUrl.startsWith('cypress')) {\n    return npmNameOrUrl\n  }\n\n  if (is.url(npmNameOrUrl)) {\n    // try finding semver in the url\n    // https://something/0.20.3/something...\n    const re = /\\/(\\d+\\.\\d+\\.\\d+(-\\w+)?)\\//\n    const matches = re.exec(npmNameOrUrl)\n\n    if (matches) {\n      return matches[1]\n    }\n  }\n\n  return npmNameOrUrl\n}\n\nconst shorten = (s) => {\n  return s.substr(0, 7)\n}\n\n/**\n * Grabs the full commit SHA and its short version from CI environment variables\n */\nconst getShortCommit = () => {\n  const sha =\n    process.env.APPVEYOR_REPO_COMMIT ||\n    process.env.CIRCLE_SHA1\n\n  if (sha) {\n    return {\n      sha,\n      short: shorten(sha),\n    }\n  }\n}\n\n/**\n * Returns CI name for know CIs\n */\nconst getCIName = () => {\n  if (process.env.CIRCLECI) {\n    return 'Circle'\n  }\n\n  if (process.env.APPVEYOR) {\n    return 'AppVeyor'\n  }\n}\n\n/**\n * Returns the current CI build url\n */\nconst getCIBuildUrl = () => {\n  if (process.env.CIRCLECI) {\n    // https://circleci.com/docs/2.0/env-vars/#built-in-environment-variables\n    return process.env.CIRCLE_BUILD_URL\n  }\n\n  if (process.env.APPVEYOR) {\n    // https://www.appveyor.com/docs/environment-variables/\n    // there is no single url, but we can form one\n    // looks like this\n    // https://ci.appveyor.com/project/cypress-io/cypress/builds/25882716/job/7iv75s2vjt5w4usf\n    return `${process.env.APPVEYOR_URL}/project/${\n      process.env.APPVEYOR_ACCOUNT_NAME}/${process.env.APPVEYOR_PROJECT_SLUG\n    }/builds/${process.env.APPVEYOR_BUILD_ID\n    }/job/${process.env.APPVEYOR_JOB_ID}`\n  }\n}\n\nconst seconds = (s) => s * 1000\nconst minutes = (m) => m * 60 * 1000\n\nconst getCurrentBranch = async () => {\n  const { stdout } = await execa('git', ['rev-parse', '--abbrev-ref', 'HEAD'])\n\n  return stdout\n}\n\nconst getPackagePath = ({ location }) => path.join(location, 'package.json')\n\nconst readPackageJson = (pack) => JSON.parse(fs.readFileSync(getPackagePath(pack)))\n\nconst independentTagRegex = (name) => new RegExp(`^${name}-v(.+)`)\n\nmodule.exports = {\n  getNameAndBinary,\n  getJustVersion,\n  getShortCommit,\n  getCIName,\n  getCIBuildUrl,\n  seconds,\n  minutes,\n  getCurrentBranch,\n  getPackagePath,\n  readPackageJson,\n  independentTagRegex,\n}\n",
    "scripts/wait-on-circle-jobs.js": "/* eslint-disable no-console */\n\nconst _ = require('lodash')\nconst minimist = require('minimist')\nconst Promise = require('bluebird')\nconst retry = require('bluebird-retry')\nconst got = require('got')\n// always print the debug logs\nconst debug = require('debug')('*')\n\nconst { seconds, minutes } = require('./utils')\n\n// we expect CircleCI to set the current polling job name\nconst jobName = process.env.CIRCLE_JOB || 'wait-on-circle-jobs'\n\nconst workflowId = process.env.CIRCLE_WORKFLOW_ID\n\nconst getAuth = () => `${process.env.CIRCLE_TOKEN}:`\n\nconst verifyCI = () => {\n  if (!process.env.CIRCLE_TOKEN) {\n    console.error('Cannot find CIRCLE_TOKEN')\n    process.exit(1)\n  }\n\n  if (!process.env.CIRCLE_WORKFLOW_ID) {\n    console.error('Cannot find CIRCLE_WORKFLOW_ID')\n    process.exit(1)\n  }\n}\n\n/* eslint-disable-next-line no-unused-vars */\nconst getWorkflow = async (workflowId) => {\n  const auth = getAuth()\n  const url = `https://${auth}@circleci.com/api/v2/workflow/${workflowId}`\n  const response = await got(url).json()\n\n  // returns something like\n  // {\n  //   pipeline_id: '5b937e8b-6138-41ad-b8d0-1c1969c4dad1',\n  //   id: '566ffe9a-62d4-45cd-9a27-9882139e0121',\n  //   name: 'linux',\n  //   project_slug: 'gh/cypress-io/cypress',\n  //   status: 'failed',\n  //   started_by: '45ae8c6a-4686-4e71-a078-fb7a3b9d9e59',\n  //   pipeline_number: 12461,\n  //   created_at: '2020-07-20T19:45:41Z',\n  //   stopped_at: '2020-07-20T20:06:54Z'\n  // }\n\n  return response\n}\n\n/**\n * Job status\n *  - blocked (has not run yet)\n *  - running (currently running)\n *  - failed | success\n*/\nconst getJobStatus = async (workflowId) => {\n  const auth = getAuth()\n  // typo at https://circleci.com/docs/2.0/api-intro/\n  // to retrieve all jobs, the url is \"/workflow/:id/job\"\n  const url = `https://${auth}@circleci.com/api/v2/workflow/${workflowId}/job`\n  const response = await got(url).json()\n\n  // returns something like\n  // {\n  //   next_page_token: null,\n  //   items: [\n  //     {\n  //       dependencies: [],\n  //       job_number: 400959,\n  //       id: '7021bcc7-90c1-47d9-bf99-c0372a4f8f49',\n  //       started_at: '2020-07-20T19:45:46Z',\n  //       name: 'build',\n  //       project_slug: 'gh/cypress-io/cypress',\n  //       status: 'success',\n  //       type: 'build',\n  //       stopped_at: '2020-07-20T19:50:07Z'\n  //     }\n  //   ]\n  // }\n  return response\n}\n\nconst waitForAllJobs = async (jobNames, workflowId) => {\n  let response\n\n  try {\n    response = await getJobStatus(workflowId)\n  } catch (e) {\n    console.error(e)\n    process.exit(1)\n  }\n\n  // if a job is pending, its status will be \"blocked\"\n  const blockedJobs = _.filter(response.items, { status: 'blocked' })\n  const failedJobs = _.filter(response.items, { status: 'failed' })\n  const runningJobs = _.filter(response.items, { status: 'running' })\n\n  const blockedJobNames = _.map(blockedJobs, 'name')\n  const runningJobNames = _.map(runningJobs, 'name')\n\n  debug('failed jobs %o', _.map(failedJobs, 'name'))\n  debug('blocked jobs %o', blockedJobNames)\n  debug('running jobs %o', runningJobNames)\n\n  if (!runningJobs.length || (runningJobs.length === 1 && runningJobs[0].name === jobName)) {\n    // there are no more jobs to run, or this is the last running job\n    console.log('all jobs are done, finishing this job')\n\n    return Promise.resolve()\n  }\n\n  const futureOrRunning = _.union(blockedJobs, runningJobNames)\n  const jobsToWaitFor = _.intersection(jobNames, futureOrRunning)\n\n  debug('jobs to wait for %o', jobsToWaitFor)\n\n  if (!jobsToWaitFor.length) {\n    console.log('No more jobs to wait for!')\n\n    return Promise.resolve()\n  }\n\n  return Promise.reject(new Error('Jobs have not finished'))\n}\n\nconst waitForJobToPass = Promise.method(async (jobName, workflow = workflowId) => {\n  verifyCI()\n\n  let response\n\n  try {\n    response = await getJobStatus(workflow)\n  } catch (e) {\n    console.error(e)\n    process.exit(1)\n  }\n\n  const job = _.find(response.items, { name: jobName })\n\n  if (!job) {\n    return Promise.reject(new Error('Job not found'))\n  }\n\n  const { status } = job\n\n  if (status === 'success') {\n    return Promise.resolve()\n  }\n\n  if (status === 'failed') {\n    return Promise.reject(new Error('Job failed'))\n  }\n\n  await Promise.delay(seconds(30))\n\n  return waitForJobToPass(jobName, workflow)\n})\n\nconst main = () => {\n  verifyCI()\n\n  const args = minimist(process.argv.slice(2), { boolean: false })\n\n  const jobNames = _\n  .chain(args['job-names'])\n  .split(',')\n  .without('true')\n  .map(_.trim)\n  .compact()\n  .value()\n\n  if (!jobNames.length) {\n    console.error('Missing argument: --job-names')\n    console.error('You must pass a comma separated list of Circle CI job names to wait for.')\n    process.exit(1)\n  }\n\n  debug('received circle jobs: %o', jobNames)\n\n  // finished, has one failed job\n  // const workflowId = '566ffe9a-62d4-45cd-9a27-9882139e0121'\n  // pending workflow\n  // jobs that have not run have \"status: 'blocked'\"\n\n  // getWorkflow(workflowId).then(console.log, console.error)\n  // getWorkflowJobs(workflowId).then(console.log, console.error)\n\n  // https://github.com/demmer/bluebird-retry\n  retry(waitForAllJobs.bind(null, jobNames, workflowId), {\n    timeout: minutes(30), // max time for this job\n    interval: seconds(30), // poll intervals\n    max_interval: seconds(30),\n  }).then(() => {\n    console.log('all done')\n  }, (err) => {\n    console.error(err)\n    process.exit(1)\n  })\n\n  // getJobStatus(workflowId).then(console.log, console.error)\n}\n\n// execute main function if called from command line\nif (require.main === module) {\n  main()\n}\n\nmodule.exports = {\n  minutes,\n  waitForJobToPass,\n}\n"
  }
}